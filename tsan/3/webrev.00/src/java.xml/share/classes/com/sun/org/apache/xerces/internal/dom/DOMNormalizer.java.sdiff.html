<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMConfigurationImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="DeferredDocumentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 
  24 
<span class="line-removed">  25 import com.sun.org.apache.xerces.internal.dom.AbortException;</span>
  26 import com.sun.org.apache.xerces.internal.impl.Constants;
  27 import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
<span class="line-modified">  28 import com.sun.org.apache.xerces.internal.impl.dtd.DTDGrammar;</span>
<span class="line-removed">  29 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDDescription;</span>
  30 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator;
  31 import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
  32 import com.sun.org.apache.xerces.internal.impl.xs.util.SimpleLocator;
<span class="line-removed">  33 import com.sun.org.apache.xerces.internal.parsers.XMLGrammarPreparser;</span>
  34 import com.sun.org.apache.xerces.internal.util.AugmentationsImpl;
  35 import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
  36 import com.sun.org.apache.xerces.internal.util.SymbolTable;
  37 import com.sun.org.apache.xerces.internal.util.XML11Char;
  38 import com.sun.org.apache.xerces.internal.util.XMLChar;
<span class="line-removed">  39 import com.sun.org.apache.xerces.internal.util.XMLGrammarPoolImpl;</span>
  40 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
  41 import com.sun.org.apache.xerces.internal.xni.Augmentations;
  42 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
  43 import com.sun.org.apache.xerces.internal.xni.QName;
  44 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
  45 import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
  46 import com.sun.org.apache.xerces.internal.xni.XMLLocator;
  47 import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
  48 import com.sun.org.apache.xerces.internal.xni.XMLString;
  49 import com.sun.org.apache.xerces.internal.xni.XNIException;
  50 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
<span class="line-removed">  51 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarPool;</span>
  52 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
  53 import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;
<span class="line-removed">  54 import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;</span>
  55 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
  56 import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
  57 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
  58 import java.io.IOException;
<span class="line-removed">  59 import java.io.StringReader;</span>
  60 import java.util.ArrayList;
  61 import java.util.List;
  62 import java.util.Vector;
  63 import org.w3c.dom.Attr;
  64 import org.w3c.dom.Comment;
  65 import org.w3c.dom.DOMError;
  66 import org.w3c.dom.DOMErrorHandler;
  67 import org.w3c.dom.Document;
  68 import org.w3c.dom.DocumentType;
  69 import org.w3c.dom.Element;
  70 import org.w3c.dom.Entity;
  71 import org.w3c.dom.NamedNodeMap;
  72 import org.w3c.dom.Node;
  73 import org.w3c.dom.NodeList;
  74 import org.w3c.dom.ProcessingInstruction;
  75 import org.w3c.dom.Text;
  76 /**
  77  * This class adds implementation for normalizeDocument method.
  78  * It acts as if the document was going through a save and load cycle, putting
  79  * the document in a &quot;normal&quot; form. The actual result depends on the features being set
  80  * and governing what operations actually take place. See setNormalizationFeature for details.
  81  * Noticeably this method normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
  82  * according to the algorithm described below in pseudo code, by adding missing namespace
  83  * declaration attributes and adding or changing namespace prefixes, updates the replacement
  84  * tree of EntityReference nodes, normalizes attribute values, etc.
  85  * Mutation events, when supported, are generated to reflect the changes occuring on the
  86  * document.
  87  * See Namespace normalization for details on how namespace declaration attributes and prefixes
  88  * are normalized.
  89  *
  90  * NOTE: There is an initial support for DOM revalidation with XML Schema as a grammar.
  91  * The tree might not be validated correctly if entityReferences, CDATA sections are
  92  * present in the tree. The PSVI information is not exposed, normalized data (including element
  93  * default content is not available).
  94  *
  95  * @xerces.experimental
  96  *
  97  * @author Elena Litani, IBM
  98  * @author Neeraj Bajaj, Sun Microsystems, inc.
<span class="line-modified">  99  * @LastModified: Nov 2017</span>
 100  */
 101 public class DOMNormalizer implements XMLDocumentHandler {
 102 
 103     //
 104     // constants
 105     //
 106     /** Debug normalize document*/
 107     protected final static boolean DEBUG_ND = false;
 108     /** Debug namespace fix up algorithm*/
 109     protected final static boolean DEBUG = false;
 110     /** Debug document handler events */
 111     protected final static boolean DEBUG_EVENTS = false;
 112 
 113     /** prefix added by namespace fixup algorithm should follow a pattern &quot;NS&quot; + index*/
 114     protected final static String PREFIX = &quot;NS&quot;;
 115 
 116     //
 117     // Data
 118     //
 119     protected DOMConfigurationImpl fConfiguration = null;
</pre>
<hr />
<pre>
 138     // Validation against namespace aware grammar
 139     protected boolean fNamespaceValidation = false;
 140 
 141     // Update PSVI information in the tree
 142     protected boolean fPSVI = false;
 143 
 144     /** The namespace context of this document: stores namespaces in scope */
 145     protected final NamespaceContext fNamespaceContext = new NamespaceSupport();
 146 
 147     /** Stores all namespace bindings on the current element */
 148     protected final NamespaceContext fLocalNSBinder = new NamespaceSupport();
 149 
 150     /** list of attributes */
 151     protected final List&lt;Node&gt; fAttributeList = new ArrayList&lt;&gt;(5);
 152 
 153     /** DOM Locator -  for namespace fixup algorithm */
 154     protected final DOMLocatorImpl fLocator = new DOMLocatorImpl();
 155 
 156     /** for setting the PSVI */
 157     protected Node fCurrentNode = null;
<span class="line-modified"> 158     private QName fAttrQName = new QName();</span>
 159 
 160     // attribute value normalization
 161     final XMLString fNormalizedValue = new XMLString(new char[16], 0, 0);
 162 
 163     //DTD validator
 164     private XMLDTDValidator fDTDValidator;
 165 
<span class="line-modified"> 166     //Check if element content is all &quot;ignorable whitespace&quot;</span>
<span class="line-modified"> 167     private boolean allWhitespace = false;</span>



 168 
 169     // Constructor
 170     //
 171 
 172     public DOMNormalizer(){}
 173 
 174 
 175 
 176     /**
 177      * Normalizes document.
 178      * Note: reset() must be called before this method.
 179      */
<span class="line-modified"> 180         protected void normalizeDocument(CoreDocumentImpl document, DOMConfigurationImpl config) {</span>





 181 
<span class="line-modified"> 182                 fDocument = document;</span>
<span class="line-modified"> 183                 fConfiguration = config;</span>

 184 
<span class="line-modified"> 185                 // intialize and reset DOMNormalizer component</span>
<span class="line-modified"> 186                 //</span>
<span class="line-modified"> 187                 fSymbolTable = (SymbolTable) fConfiguration.getProperty(DOMConfigurationImpl.SYMBOL_TABLE);</span>
<span class="line-modified"> 188                 // reset namespace context</span>
<span class="line-modified"> 189                 fNamespaceContext.reset();</span>
<span class="line-modified"> 190                 fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);</span>
 191 
<span class="line-modified"> 192                 if ((fConfiguration.features &amp; DOMConfigurationImpl.VALIDATE) != 0) {</span>
 193             String schemaLang = (String)fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_LANGUAGE);
 194 
<span class="line-modified"> 195             if(schemaLang != null &amp;&amp; schemaLang.equals(Constants.NS_XMLSCHEMA)) {</span>
<span class="line-modified"> 196                         fValidationHandler =</span>
<span class="line-modified"> 197                                 CoreDOMImplementationImpl.singleton.getValidator(XMLGrammarDescription.XML_SCHEMA);</span>
 198                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA, true);
 199                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA_FULL_CHECKING, true);
 200                 // report fatal error on DOM Level 1 nodes
 201                 fNamespaceValidation = true;
 202 
 203                 // check if we need to fill in PSVI
 204                 fPSVI = ((fConfiguration.features &amp; DOMConfigurationImpl.PSVI) !=0)?true:false;
 205             }









 206 
<span class="line-modified"> 207                         fConfiguration.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);</span>
 208 
 209             // reset ID table
 210             fDocument.clearIdentifiers();
 211 
<span class="line-modified"> 212             if(fValidationHandler != null)</span>
<span class="line-modified"> 213             // reset schema validator</span>
 214                 ((XMLComponent) fValidationHandler).reset(fConfiguration);





 215 
<span class="line-modified"> 216                 }</span>
<span class="line-modified"> 217 </span>
<span class="line-modified"> 218                 fErrorHandler = (DOMErrorHandler) fConfiguration.getParameter(Constants.DOM_ERROR_HANDLER);</span>
<span class="line-modified"> 219                 if (fValidationHandler != null) {</span>
<span class="line-removed"> 220                         fValidationHandler.setDocumentHandler(this);</span>
<span class="line-removed"> 221                         fValidationHandler.startDocument(</span>
 222                     new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,
<span class="line-modified"> 223                                                 -1, -1 ), fDocument.encoding, fNamespaceContext, null);</span>
<span class="line-modified"> 224 </span>
<span class="line-modified"> 225                 }</span>
<span class="line-modified"> 226                 try {</span>
<span class="line-modified"> 227                         Node kid, next;</span>
<span class="line-modified"> 228                         for (kid = fDocument.getFirstChild(); kid != null; kid = next) {</span>
<span class="line-modified"> 229                                 next = kid.getNextSibling();</span>
<span class="line-modified"> 230                                 kid = normalizeNode(kid);</span>
<span class="line-removed"> 231                                 if (kid != null) { // don&#39;t advance</span>
<span class="line-removed"> 232                                         next = kid;</span>
<span class="line-removed"> 233                                 }</span>
<span class="line-removed"> 234                         }</span>
 235 
<span class="line-modified"> 236                         // release resources</span>
<span class="line-modified"> 237                         if (fValidationHandler != null) {</span>
<span class="line-modified"> 238                                 fValidationHandler.endDocument(null);</span>
<span class="line-modified"> 239                                 CoreDOMImplementationImpl.singleton.releaseValidator(</span>
<span class="line-modified"> 240                                         XMLGrammarDescription.XML_SCHEMA, fValidationHandler);</span>
<span class="line-modified"> 241                                 fValidationHandler = null;</span>
<span class="line-removed"> 242                         }</span>
<span class="line-removed"> 243                 } catch (AbortException e) {</span>
<span class="line-removed"> 244                     return;</span>
 245                 }

 246 







 247         }
<span class="line-modified"> 248 </span>












 249 
 250     /**
 251      *
 252      * This method acts as if the document was going through a save
 253      * and load cycle, putting the document in a &quot;normal&quot; form. The actual result
 254      * depends on the features being set and governing what operations actually
 255      * take place. See setNormalizationFeature for details. Noticeably this method
 256      * normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
 257      * according to the algorithm described below in pseudo code, by adding missing
 258      * namespace declaration attributes and adding or changing namespace prefixes, updates
 259      * the replacement tree of EntityReference nodes,normalizes attribute values, etc.
 260      *
 261      * @param node   Modified node or null. If node is returned, we need
 262      *               to normalize again starting on the node returned.
 263      * @return  the normalized Node
 264      */
 265     protected Node normalizeNode (Node node){
 266 
 267         int type = node.getNodeType();
 268         boolean wellformed;
 269         fLocator.fRelatedNode=node;
 270 
 271         switch (type) {
 272         case Node.DOCUMENT_TYPE_NODE: {
 273                 if (DEBUG_ND) {
 274                     System.out.println(&quot;==&gt;normalizeNode:{doctype}&quot;);
 275                 }
<span class="line-modified"> 276                 DocumentTypeImpl docType = (DocumentTypeImpl)node;</span>
<span class="line-removed"> 277                 fDTDValidator = (XMLDTDValidator)CoreDOMImplementationImpl.singleton.getValidator(XMLGrammarDescription.XML_DTD);</span>
<span class="line-removed"> 278                 fDTDValidator.setDocumentHandler(this);</span>
<span class="line-removed"> 279                 fConfiguration.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY, createGrammarPool(docType));</span>
<span class="line-removed"> 280                 fDTDValidator.reset(fConfiguration);</span>
<span class="line-removed"> 281                 fDTDValidator.startDocument(</span>
<span class="line-removed"> 282                         new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,</span>
<span class="line-removed"> 283                             -1, -1 ), fDocument.encoding, fNamespaceContext, null);</span>
<span class="line-removed"> 284                 fDTDValidator.doctypeDecl(docType.getName(), docType.getPublicId(), docType.getSystemId(), null);</span>
<span class="line-removed"> 285                 //REVISIT: well-formness encoding info</span>
 286                 break;
 287             }
 288 
 289         case Node.ELEMENT_NODE: {
 290                 if (DEBUG_ND) {
 291                     System.out.println(&quot;==&gt;normalizeNode:{element} &quot;+node.getNodeName());
 292                 }
 293 
 294                 //do the name check only when version of the document was changed &amp;
 295                 //application has set the value of well-formed features to true
 296                 if (fDocument.errorChecking) {
 297                     if ( ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;
 298                             fDocument.isXMLVersionChanged()){
 299                         if (fNamespaceValidation){
<span class="line-modified"> 300                             wellformed = CoreDocumentImpl.isValidQName(node.getPrefix() , node.getLocalName(), fDocument.isXML11Version()) ;</span>
 301                         }
 302                         else {
 303                             wellformed = CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
 304                         }
 305                         if (!wellformed){
 306                             String msg = DOMMessageFormatter.formatMessage(
 307                                     DOMMessageFormatter.DOM_DOMAIN,
 308                                     &quot;wf-invalid-character-in-node-name&quot;,
 309                                     new Object[]{&quot;Element&quot;, node.getNodeName()});
 310                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 311                             &quot;wf-invalid-character-in-node-name&quot;);
 312                         }
 313                     }
 314                 }
 315                 // push namespace context
 316                 fNamespaceContext.pushContext();
 317                 fLocalNSBinder.reset();
 318 
 319                 ElementImpl elem = (ElementImpl)node;
 320                 if (elem.needsSyncChildren()) {
 321                     elem.synchronizeChildren();
 322                 }
 323                 AttributeMap attributes = (elem.hasAttributes()) ? (AttributeMap) elem.getAttributes() : null;
 324 
 325                 // fix namespaces and remove default attributes
 326                 if ((fConfiguration.features &amp; DOMConfigurationImpl.NAMESPACES) !=0) {
 327                     // fix namespaces
 328                     // normalize attribute values
 329                     // remove default attributes
 330                     namespaceFixUp(elem, attributes);
 331 
<span class="line-modified"> 332                     if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0 &amp;&amp; attributes != null ) {</span>
<span class="line-modified"> 333                         for (int i = 0; i &lt; attributes.getLength(); ++i) {</span>
<span class="line-modified"> 334                             Attr att = (Attr)attributes.getItem(i);</span>
<span class="line-modified"> 335                             if (XMLSymbols.PREFIX_XMLNS.equals(att.getPrefix()) ||</span>
<span class="line-modified"> 336                                 XMLSymbols.PREFIX_XMLNS.equals(att.getName())) {</span>
<span class="line-modified"> 337                                 elem.removeAttributeNode(att);</span>
<span class="line-modified"> 338                                 --i;</span>








 339                             }
 340                         }
 341                     }
 342 
 343                 } else {
 344                     if ( attributes!=null ) {
 345                         for ( int i=0; i&lt;attributes.getLength(); ++i ) {
 346                             Attr attr = (Attr)attributes.item(i);
 347                             //removeDefault(attr, attributes);
 348                             attr.normalize();
 349                             if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
<span class="line-modified"> 350                                     isAttrValueWF(fErrorHandler, fError, fLocator, attributes, (AttrImpl)attr, attr.getValue(), fDocument.isXML11Version());</span>
<span class="line-modified"> 351                                 if (fDocument.isXMLVersionChanged()){</span>
<span class="line-modified"> 352                                     wellformed=CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());</span>
<span class="line-modified"> 353                                     if (!wellformed){</span>
<span class="line-modified"> 354                                                             String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-modified"> 355                                                               DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-modified"> 356                                                               &quot;wf-invalid-character-in-node-name&quot;,</span>
<span class="line-modified"> 357                                                                new Object[]{&quot;Attr&quot;,node.getNodeName()});</span>
<span class="line-modified"> 358                                                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,</span>
<span class="line-modified"> 359                                                                 &quot;wf-invalid-character-in-node-name&quot;);</span>





 360                                     }
 361                                 }
 362                             }
 363                         }
 364                     }
 365                 }
 366 
 367 
 368                 if (fValidationHandler != null) {
 369                     // REVISIT: possible solutions to discard default content are:
 370                     //         either we pass some flag to XML Schema validator
 371                     //         or rely on the PSVI information.
 372                     fAttrProxy.setAttributes(attributes, fDocument, elem);
 373                     updateQName(elem, fQName); // updates global qname
 374                     // set error node in the dom error wrapper
 375                     // so if error occurs we can report an error node
 376                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 377                     fCurrentNode = node;
 378                     // call re-validation handler
 379                     fValidationHandler.startElement(fQName, fAttrProxy, null);
 380                 }
 381 
<span class="line-removed"> 382                 if (fDTDValidator != null) {</span>
<span class="line-removed"> 383                     // REVISIT: possible solutions to discard default content are:</span>
<span class="line-removed"> 384                     //         either we pass some flag to XML Schema validator</span>
<span class="line-removed"> 385                     //         or rely on the PSVI information.</span>
<span class="line-removed"> 386                     fAttrProxy.setAttributes(attributes, fDocument, elem);</span>
<span class="line-removed"> 387                     updateQName(elem, fQName); // updates global qname</span>
<span class="line-removed"> 388                     // set error node in the dom error wrapper</span>
<span class="line-removed"> 389                     // so if error occurs we can report an error node</span>
<span class="line-removed"> 390                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-removed"> 391                     fCurrentNode = node;</span>
<span class="line-removed"> 392                     // call re-validation handler</span>
<span class="line-removed"> 393                     fDTDValidator.startElement(fQName, fAttrProxy, null);</span>
<span class="line-removed"> 394                 }</span>
<span class="line-removed"> 395 </span>
 396                 // normalize children
 397                 Node kid, next;
 398                 for (kid = elem.getFirstChild(); kid != null; kid = next) {
 399                     next = kid.getNextSibling();
 400                     kid = normalizeNode(kid);
<span class="line-modified"> 401                     if (kid !=null) {</span>
 402                         next = kid;  // don&#39;t advance
 403                     }
 404                 }
 405                 if (DEBUG_ND) {
 406                     // normalized subtree
 407                     System.out.println(&quot;***The children of {&quot;+node.getNodeName()+&quot;} are normalized&quot;);
 408                     for (kid = elem.getFirstChild(); kid != null; kid = next) {
 409                         next = kid.getNextSibling();
 410                         System.out.println(kid.getNodeName() +&quot;[&quot;+kid.getNodeValue()+&quot;]&quot;);
 411                     }
 412 
 413                 }
 414 
<span class="line-removed"> 415 </span>
 416                 if (fValidationHandler != null) {
 417                     updateQName(elem, fQName); // updates global qname
 418                     //
 419                     // set error node in the dom error wrapper
 420                     // so if error occurs we can report an error node
 421                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 422                     fCurrentNode = node;
 423                     fValidationHandler.endElement(fQName, null);
 424                 }
 425 
<span class="line-removed"> 426                 if (fDTDValidator != null) {</span>
<span class="line-removed"> 427                     updateQName(elem, fQName); // updates global qname</span>
<span class="line-removed"> 428                     //</span>
<span class="line-removed"> 429                     // set error node in the dom error wrapper</span>
<span class="line-removed"> 430                     // so if error occurs we can report an error node</span>
<span class="line-removed"> 431                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-removed"> 432                     fCurrentNode = node;</span>
<span class="line-removed"> 433                     fDTDValidator.endElement(fQName, null);</span>
<span class="line-removed"> 434                 }</span>
<span class="line-removed"> 435 </span>
 436                 // pop namespace context
 437                 fNamespaceContext.popContext();
 438 
 439                 break;
 440             }
 441 
 442         case Node.COMMENT_NODE: {
 443                 if (DEBUG_ND) {
 444                     System.out.println(&quot;==&gt;normalizeNode:{comments}&quot;);
 445                 }
 446 
 447                 if ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0) {
 448                     Node prevSibling = node.getPreviousSibling();
 449                     Node parent = node.getParentNode();
 450                     // remove the comment node
 451                     parent.removeChild(node);
 452                     if (prevSibling != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE) {
 453                         Node nextSibling = prevSibling.getNextSibling();
 454                         if (nextSibling != null &amp;&amp; nextSibling.getNodeType() == Node.TEXT_NODE) {
 455                             ((TextImpl)nextSibling).insertData(0, prevSibling.getNodeValue());
 456                             parent.removeChild(prevSibling);
 457                             return nextSibling;
 458                         }
 459                     }
 460                 }//if comment node need not be removed
 461                 else {
 462                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
 463                         String commentdata = ((Comment)node).getData();
 464                         // check comments for invalid xml chracter as per the version
 465                         // of the document
 466                         isCommentWF(fErrorHandler, fError, fLocator, commentdata, fDocument.isXML11Version());
 467                     }







 468                 }//end-else if comment node is not to be removed.
 469                                 break;
 470             }
 471         case Node.ENTITY_REFERENCE_NODE: {
 472                 if (DEBUG_ND) {
 473                     System.out.println(&quot;==&gt;normalizeNode:{entityRef} &quot;+node.getNodeName());
 474                 }
 475 
 476                 if ((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0) {
 477                     Node prevSibling = node.getPreviousSibling();
 478                     Node parent = node.getParentNode();
 479                     ((EntityReferenceImpl)node).setReadOnly(false, true);
 480                     expandEntityRef (parent, node);
 481                     parent.removeChild(node);
 482                     Node next = (prevSibling != null)?prevSibling.getNextSibling():parent.getFirstChild();
 483                     // The list of children #text -&gt; &amp;ent;
 484                     // and entity has a first child as a text
 485                     // we should not advance
 486                     if (prevSibling != null &amp;&amp; next != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE &amp;&amp;
 487                         next.getNodeType() == Node.TEXT_NODE) {
</pre>
<hr />
<pre>
 514                     }
 515                     else {
 516                         Text text = fDocument.createTextNode(node.getNodeValue());
 517                         Node parent = node.getParentNode();
 518                         node = parent.replaceChild(text, node);
 519                         return text;  //don&#39;t advance
 520 
 521                     }
 522                 }
 523 
 524                 // send characters call for CDATA
 525                 if (fValidationHandler != null) {
 526                     // set error node in the dom error wrapper
 527                     // so if error occurs we can report an error node
 528                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 529                     fCurrentNode = node;
 530                     fValidationHandler.startCDATA(null);
 531                     fValidationHandler.characterData(node.getNodeValue(), null);
 532                     fValidationHandler.endCDATA(null);
 533                 }
<span class="line-removed"> 534 </span>
<span class="line-removed"> 535                 if (fDTDValidator != null) {</span>
<span class="line-removed"> 536                     // set error node in the dom error wrapper</span>
<span class="line-removed"> 537                     // so if error occurs we can report an error node</span>
<span class="line-removed"> 538                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-removed"> 539                     fCurrentNode = node;</span>
<span class="line-removed"> 540                     fDTDValidator.startCDATA(null);</span>
<span class="line-removed"> 541                     fDTDValidator.characterData(node.getNodeValue(), null);</span>
<span class="line-removed"> 542                     fDTDValidator.endCDATA(null);</span>
<span class="line-removed"> 543                 }</span>
 544                 String value = node.getNodeValue();
 545 
 546                 if ((fConfiguration.features &amp; DOMConfigurationImpl.SPLITCDATA) != 0) {
 547                     int index;
 548                     Node parent = node.getParentNode();
 549                     if (fDocument.errorChecking) {
 550                         isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());
 551                     }
 552                     while ( (index=value.indexOf(&quot;]]&gt;&quot;)) &gt;= 0 ) {
 553                         node.setNodeValue(value.substring(0, index+2));
 554                         value = value.substring(index +2);
 555 
 556                         Node firstSplitNode = node;
 557                         Node newChild = fDocument.createCDATASection(value);
 558                         parent.insertBefore(newChild, node.getNextSibling());
 559                         node = newChild;
 560                         // issue warning
 561                         fLocator.fRelatedNode = firstSplitNode;
 562                         String msg = DOMMessageFormatter.formatMessage(
 563                             DOMMessageFormatter.DOM_DOMAIN,
</pre>
<hr />
<pre>
 588                 // If an adjacent text node, merge it with this node
 589                 if ( next!=null &amp;&amp; next.getNodeType() == Node.TEXT_NODE ) {
 590                     ((Text)node).appendData(next.getNodeValue());
 591                     node.getParentNode().removeChild( next );
 592                     // We don&#39;t need to check well-formness here since we are not yet
 593                     // done with this node.
 594 
 595                     return node; // Don&#39;t advance;
 596                 } else if (node.getNodeValue().length()==0) {
 597                     // If kid is empty, remove it
 598                     node.getParentNode().removeChild( node );
 599                 } else {
 600                     // validator.characters() call and well-formness
 601                     // Don&#39;t send characters or check well-formness in the following cases:
 602                     // 1. entities is false, next child is entity reference: expand tree first
 603                     // 2. comments is false, and next child is comment
 604                     // 3. cdata is false, and next child is cdata
 605 
 606                     short nextType = (next != null)?next.getNodeType():-1;
 607                     if (nextType == -1 || !(((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0 &amp;&amp;
<span class="line-modified"> 608                            nextType == Node.ENTITY_NODE) ||</span>
<span class="line-modified"> 609                           ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0 &amp;&amp;</span>
<span class="line-modified"> 610                            nextType == Node.COMMENT_NODE) ||</span>
<span class="line-modified"> 611                           ((fConfiguration.features &amp; DOMConfigurationImpl.CDATA) == 0) &amp;&amp;</span>
<span class="line-modified"> 612                           nextType == Node.CDATA_SECTION_NODE)) {</span>
<span class="line-modified"> 613                               if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) ){</span>
<span class="line-modified"> 614                                   isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());</span>
<span class="line-modified"> 615                               }</span>
<span class="line-modified"> 616                               if (fValidationHandler != null) {</span>
<span class="line-modified"> 617                                      fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-modified"> 618                                      fCurrentNode = node;</span>
<span class="line-modified"> 619                                      fValidationHandler.characterData(node.getNodeValue(), null);</span>
<span class="line-modified"> 620                                      if (DEBUG_ND) {</span>
<span class="line-modified"> 621                                          System.out.println(&quot;=====&gt;characterData(),&quot;+nextType);</span>
<span class="line-modified"> 622 </span>
<span class="line-modified"> 623                                      }</span>
<span class="line-modified"> 624                               }</span>
<span class="line-modified"> 625                               if (fDTDValidator != null) {</span>
<span class="line-modified"> 626                                   fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-modified"> 627                                   fCurrentNode = node;</span>
<span class="line-modified"> 628                                   fDTDValidator.characterData(node.getNodeValue(), null);</span>
<span class="line-modified"> 629                                   if (DEBUG_ND) {</span>
<span class="line-modified"> 630                                       System.out.println(&quot;=====&gt;characterData(),&quot;+nextType);</span>
<span class="line-modified"> 631 </span>
<span class="line-modified"> 632                                   }</span>
<span class="line-removed"> 633                                   if(allWhitespace) {</span>
<span class="line-removed"> 634                                       allWhitespace = false;</span>
<span class="line-removed"> 635                                       ((TextImpl)node).setIgnorableWhitespace(true);</span>
<span class="line-removed"> 636                                   }</span>
<span class="line-removed"> 637                               }</span>
 638                     }
 639                     else {
<span class="line-modified"> 640                             if (DEBUG_ND) {</span>
<span class="line-modified"> 641                                 System.out.println(&quot;=====&gt;don&#39;t send characters(),&quot;+nextType);</span>
 642 
<span class="line-modified"> 643                             }</span>
 644                     }
 645                 }
 646                 break;
 647             }
 648         case Node.PROCESSING_INSTRUCTION_NODE: {
 649 
 650             //do the well-formed valid PI target name , data check when application has set the value of well-formed feature to true
 651             if (fDocument.errorChecking &amp;&amp; (fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0 ) {
 652                 ProcessingInstruction pinode = (ProcessingInstruction)node ;
 653 
 654                 String target = pinode.getTarget();
 655                 //1.check PI target name
 656                 if(fDocument.isXML11Version()){
 657                     wellformed = XML11Char.isXML11ValidName(target);
 658                 }
 659                 else{
 660                     wellformed = XMLChar.isValidName(target);
 661                 }
 662 
 663                                 if (!wellformed) {
 664                                     String msg = DOMMessageFormatter.formatMessage(
 665                                         DOMMessageFormatter.DOM_DOMAIN,
 666                                         &quot;wf-invalid-character-in-node-name&quot;,
 667                                         new Object[]{&quot;Element&quot;, node.getNodeName()});
 668                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 669                         &quot;wf-invalid-character-in-node-name&quot;);
 670                 }
 671 
 672                 //2. check PI data
 673                 //processing isntruction data may have certain characters
 674                 //which may not be valid XML character
 675                 isXMLCharWF(fErrorHandler, fError, fLocator, pinode.getData(), fDocument.isXML11Version());
 676             }









 677         }//end case Node.PROCESSING_INSTRUCTION_NODE
 678 
 679         }//end of switch
 680         return null;
 681     }//normalizeNode
 682 
<span class="line-modified"> 683     private XMLGrammarPool createGrammarPool(DocumentTypeImpl docType) {</span>
<span class="line-removed"> 684 </span>
<span class="line-removed"> 685         XMLGrammarPoolImpl pool = new XMLGrammarPoolImpl();</span>
 686 
<span class="line-modified"> 687         XMLGrammarPreparser preParser = new XMLGrammarPreparser(fSymbolTable);</span>
<span class="line-modified"> 688         preParser.registerPreparser(XMLGrammarDescription.XML_DTD, null);</span>
<span class="line-modified"> 689         preParser.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE, true);</span>
<span class="line-modified"> 690         preParser.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.VALIDATION_FEATURE, true);</span>
<span class="line-modified"> 691         preParser.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY, pool);</span>
 692 
<span class="line-modified"> 693         String internalSubset = docType.getInternalSubset();</span>
<span class="line-modified"> 694         XMLInputSource is = new XMLInputSource(docType.getPublicId(), docType.getSystemId(), null, false);</span>















 695 
<span class="line-modified"> 696         if(internalSubset != null)</span>
<span class="line-removed"> 697             is.setCharacterStream(new StringReader(internalSubset));</span>
 698         try {
<span class="line-modified"> 699             DTDGrammar g = (DTDGrammar)preParser.preparseGrammar(XMLGrammarDescription.XML_DTD, is);</span>
<span class="line-modified"> 700             ((XMLDTDDescription)g.getGrammarDescription()).setRootName(docType.getName());</span>
<span class="line-modified"> 701             is.setCharacterStream(null);</span>
<span class="line-modified"> 702             g = (DTDGrammar)preParser.preparseGrammar(XMLGrammarDescription.XML_DTD, is);</span>
<span class="line-modified"> 703             ((XMLDTDDescription)g.getGrammarDescription()).setRootName(docType.getName());</span>
<span class="line-modified"> 704 </span>
<span class="line-modified"> 705         } catch (XNIException e) {</span>
<span class="line-removed"> 706         } catch (IOException e) {</span>
 707         }
<span class="line-modified"> 708 </span>
<span class="line-modified"> 709         return pool;</span>
<span class="line-modified"> 710     }</span>
<span class="line-modified"> 711 </span>
<span class="line-modified"> 712 </span>




 713 
 714     protected final void expandEntityRef (Node parent, Node reference){
 715         Node kid, next;
 716         for (kid = reference.getFirstChild(); kid != null; kid = next) {
 717             next = kid.getNextSibling();
 718             parent.insertBefore(kid, reference);
 719         }
 720     }
 721 
 722     // fix namespaces
 723     // normalize attribute values
 724     // remove default attributes
 725     // check attribute names if the version of the document changed.
 726 
 727     protected final void namespaceFixUp (ElementImpl element, AttributeMap attributes){
 728         if (DEBUG) {
 729             System.out.println(&quot;[ns-fixup] element:&quot; +element.getNodeName()+
 730                                &quot; uri: &quot;+element.getNamespaceURI());
 731         }
 732 
 733         // ------------------------------------
 734         // pick up local namespace declarations
 735         // &lt;xsl:stylesheet xmlns:xsl=&quot;http://xslt&quot;&gt;
 736         //   &lt;!-- add the following via DOM
 737         //          body is bound to http://xslt
 738         //    --&gt;
 739         //   &lt;xsl:body xmlns:xsl=&quot;http://bound&quot;/&gt;
 740         //
 741         // ------------------------------------
 742 
<span class="line-modified"> 743         String value, name, uri, prefix;</span>
 744         if (attributes != null) {
 745 
 746             // Record all valid local declarations
 747             for (int k = 0; k &lt; attributes.getLength(); ++k) {
 748                 Attr attr = (Attr)attributes.getItem(k);
<span class="line-removed"> 749 </span>
<span class="line-removed"> 750                 //do the name check only when version of the document was changed &amp;</span>
<span class="line-removed"> 751                 //application has set the value of well-formed features to true</span>
<span class="line-removed"> 752                 if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;</span>
<span class="line-removed"> 753                     fDocument.isXMLVersionChanged()) {</span>
<span class="line-removed"> 754                     //checkQName does checking based on the version of the document</span>
<span class="line-removed"> 755                     fDocument.checkQName(attr.getPrefix() , attr.getLocalName()) ;</span>
<span class="line-removed"> 756                 }</span>
<span class="line-removed"> 757 </span>
 758                 uri = attr.getNamespaceURI();
 759                 if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 760                     // namespace attribute
<span class="line-removed"> 761 </span>
<span class="line-removed"> 762                     // &quot;namespace-declarations&quot; == false; Discard all namespace declaration attributes</span>
<span class="line-removed"> 763                     if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0) {</span>
<span class="line-removed"> 764                         continue;</span>
<span class="line-removed"> 765                     }</span>
<span class="line-removed"> 766 </span>
 767                     value = attr.getNodeValue();
 768                     if (value == null) {
 769                         value=XMLSymbols.EMPTY_STRING;
 770                     }
 771 
 772                     // Check for invalid namespace declaration:
 773                     if (fDocument.errorChecking &amp;&amp; value.equals(NamespaceContext.XMLNS_URI)) {
 774                         //A null value for locale is passed to formatMessage,
 775                         //which means that the default locale will be used
 776                         fLocator.fRelatedNode = attr;
 777                         String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,&quot;CantBindXMLNS&quot;,null );
 778                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR, &quot;CantBindXMLNS&quot;);
 779                     } else {
 780                         // XML 1.0 Attribute value normalization
 781                         // value = normalizeAttributeValue(value, attr);
 782                         prefix = attr.getPrefix();
 783                         prefix = (prefix == null ||
 784                                   prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 785                         String localpart = fSymbolTable.addSymbol( attr.getLocalName());
 786                         if (prefix == XMLSymbols.PREFIX_XMLNS) { //xmlns:prefix
 787 
 788                             value = fSymbolTable.addSymbol(value);
 789                             if (value.length() != 0) {
 790                                 fNamespaceContext.declarePrefix(localpart, value);
 791                             } else {
 792                                 // REVISIT: issue error on invalid declarations
 793                                 //          xmlns:foo = &quot;&quot;
 794 
 795                             }
 796                             //removeDefault (attr, attributes);
 797                             continue;
 798                         } else { // (localpart == fXmlnsSymbol &amp;&amp; prefix == fEmptySymbol)  -- xmlns
 799                             // empty prefix is always bound (&quot;&quot; or some string)
 800                             value = fSymbolTable.addSymbol(value);
<span class="line-modified"> 801                             fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, value);</span>
 802                             //removeDefault (attr, attributes);
 803                             continue;
 804                         }
 805                     }  // end-else: valid declaration
 806                 } // end-if: namespace attribute
 807             }
 808         }
 809 
 810 
 811 
 812         // ---------------------------------------------------------
 813         // Fix up namespaces for element: per DOM L3
 814         // Need to consider the following cases:
 815         //
 816         // case 1: &lt;xsl:stylesheet xmlns:xsl=&quot;http://xsl&quot;&gt;
 817         // We create another element body bound to the &quot;http://xsl&quot; namespace
 818         // as well as namespace attribute rebounding xsl to another namespace.
 819         // &lt;xsl:body xmlns:xsl=&quot;http://another&quot;&gt;
 820         // Need to make sure that the new namespace decl value is changed to
 821         // &quot;http://xsl&quot;
 822         //
 823         // ---------------------------------------------------------
 824         // check if prefix/namespace is correct for current element
 825         // ---------------------------------------------------------
 826 
 827         uri = element.getNamespaceURI();
 828         prefix = element.getPrefix();
<span class="line-modified"> 829 </span>
<span class="line-removed"> 830         // &quot;namespace-declarations&quot; == false? Discard all namespace declaration attributes</span>
<span class="line-removed"> 831         if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0) {</span>
<span class="line-removed"> 832             // no namespace declaration == no namespace URI, semantics are to keep prefix</span>
<span class="line-removed"> 833             uri = null;</span>
<span class="line-removed"> 834         } else if (uri != null) {  // Element has a namespace</span>
 835             uri = fSymbolTable.addSymbol(uri);
 836             prefix = (prefix == null ||
 837                       prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 838             if (fNamespaceContext.getURI(prefix) == uri) {
 839                 // The xmlns:prefix=namespace or xmlns=&quot;default&quot; was declared at parent.
 840                 // The binder always stores mapping of empty prefix to &quot;&quot;.
 841             } else {
 842                 // the prefix is either undeclared
 843                 // or
 844                 // conflict: the prefix is bound to another URI
 845                 addNamespaceDecl(prefix, uri, element);
 846                 fLocalNSBinder.declarePrefix(prefix, uri);
 847                 fNamespaceContext.declarePrefix(prefix, uri);
 848             }
 849         } else { // Element has no namespace
 850             if (element.getLocalName() == null) {
 851 
 852                 //  Error: DOM Level 1 node!
 853                 if (fNamespaceValidation) {
 854                     String msg = DOMMessageFormatter.formatMessage(
 855                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 856                             new Object[]{element.getNodeName()});
 857                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR,
 858                     &quot;NullLocalElementName&quot;);
 859                 } else {
 860                     String msg = DOMMessageFormatter.formatMessage(
 861                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 862                             new Object[]{element.getNodeName()});
 863                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 864                     &quot;NullLocalElementName&quot;);
 865                 }
 866 
 867             } else { // uri=null and no colon (DOM L2 node)
 868                 uri = fNamespaceContext.getURI(XMLSymbols.EMPTY_STRING);
 869                 if (uri !=null &amp;&amp; uri.length() &gt; 0) {
 870                     // undeclare default namespace declaration (before that element
 871                     // bound to non-zero length uir), but adding xmlns=&quot;&quot; decl
 872                     addNamespaceDecl (XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING, element);
<span class="line-modified"> 873                     fLocalNSBinder.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);</span>
<span class="line-modified"> 874                     fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);</span>
 875                 }
 876             }
 877         }
 878 
 879         // -----------------------------------------
 880         // Fix up namespaces for attributes: per DOM L3
 881         // check if prefix/namespace is correct the attributes
 882         // -----------------------------------------
 883         if (attributes != null) {
 884 
 885             // clone content of the attributes
 886             attributes.cloneMap(fAttributeList);
 887             for (int i = 0; i &lt; fAttributeList.size(); i++) {
 888                 Attr attr = (Attr) fAttributeList.get(i);
 889                 fLocator.fRelatedNode = attr;
 890 
 891                 if (DEBUG) {
 892                     System.out.println(&quot;==&gt;[ns-fixup] process attribute: &quot;+attr.getNodeName());
 893                 }
 894                 // normalize attribute value
 895                 attr.normalize();
 896                 value = attr.getValue();
<span class="line-removed"> 897                 name = attr.getNodeName();</span>
 898                 uri = attr.getNamespaceURI();
 899 
 900                 // make sure that value is never null.
 901                 if (value == null) {
<span class="line-modified"> 902                     value=XMLSymbols.EMPTY_STRING;</span>
























 903                 }
 904 
 905                 if (uri != null) {  // attribute has namespace !=null
 906                     prefix = attr.getPrefix();
 907                     prefix = (prefix == null ||
 908                               prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 909                     /*String localpart =*/ fSymbolTable.addSymbol( attr.getLocalName());
 910 
 911                     // ---------------------------------------
 912                     // skip namespace declarations
 913                     // ---------------------------------------
 914                     // REVISIT: can we assume that &quot;uri&quot; is from some symbol
 915                     // table, and compare by reference? -SG
 916                     if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 917                         continue;
 918                     }
<span class="line-removed"> 919                     //---------------------------------------</span>
<span class="line-removed"> 920                     // check if value of the attribute is namespace well-formed</span>
<span class="line-removed"> 921                     //---------------------------------------</span>
<span class="line-removed"> 922                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)) {</span>
<span class="line-removed"> 923                             isAttrValueWF(fErrorHandler, fError, fLocator, attributes, (AttrImpl)attr, attr.getValue(), fDocument.isXML11Version());</span>
<span class="line-removed"> 924                             if (fDocument.isXMLVersionChanged()){</span>
<span class="line-removed"> 925                                 boolean wellformed=CoreDocumentImpl.isXMLName(attr.getNodeName() , fDocument.isXML11Version());</span>
<span class="line-removed"> 926                                 if (!wellformed){</span>
<span class="line-removed"> 927                                                         String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-removed"> 928                                                             DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-removed"> 929                                                             &quot;wf-invalid-character-in-node-name&quot;,</span>
<span class="line-removed"> 930                                                             new Object[]{&quot;Attribute&quot;, attr.getNodeName()});</span>
<span class="line-removed"> 931                                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,</span>
<span class="line-removed"> 932                                             &quot;wf-invalid-character-in-node-name&quot;);</span>
<span class="line-removed"> 933                                 }</span>
<span class="line-removed"> 934                         }</span>
<span class="line-removed"> 935                     }</span>
 936 
 937                     // ---------------------------------------
 938                     // remove default attributes
 939                     // ---------------------------------------
 940                     /*
 941                     if (removeDefault(attr, attributes)) {
 942                         continue;
 943                     }
 944                     */
 945                     // XML 1.0 Attribute value normalization
 946                     //value = normalizeAttributeValue(value, attr);
 947 
 948                     // reset id-attributes
 949                     ((AttrImpl)attr).setIdAttribute(false);
 950 
<span class="line-removed"> 951 </span>
 952                     uri = fSymbolTable.addSymbol(uri);
 953 
 954                     // find if for this prefix a URI was already declared
 955                     String declaredURI =  fNamespaceContext.getURI(prefix);
 956 
 957                     if (prefix == XMLSymbols.EMPTY_STRING || declaredURI != uri) {
 958                         // attribute has no prefix (default namespace decl does not apply to attributes)
 959                         // OR
 960                         // attribute prefix is not declared
 961                         // OR
 962                         // conflict: attribute has a prefix that conficlicts with a binding
 963                         //           already active in scope
 964 
<span class="line-removed"> 965                         name  = attr.getNodeName();</span>
 966                         // Find if any prefix for attributes namespace URI is available
 967                         // in the scope
 968                         String declaredPrefix = fNamespaceContext.getPrefix(uri);
 969                         if (declaredPrefix !=null &amp;&amp; declaredPrefix !=XMLSymbols.EMPTY_STRING) {
 970 
 971                             // use the prefix that was found (declared previously for this URI
 972                             prefix = declaredPrefix;
 973                         } else {
 974                             if (prefix != XMLSymbols.EMPTY_STRING &amp;&amp; fLocalNSBinder.getURI(prefix) == null) {
 975                                 // the current prefix is not null and it has no in scope declaration
 976 
 977                                 // use this prefix
 978                             } else {
 979 
 980                                 // find a prefix following the pattern &quot;NS&quot; +index (starting at 1)
 981                                 // make sure this prefix is not declared in the current scope.
 982                                 int counter = 1;
 983                                 prefix = fSymbolTable.addSymbol(PREFIX +counter++);
 984                                 while (fLocalNSBinder.getURI(prefix)!=null) {
 985                                     prefix = fSymbolTable.addSymbol(PREFIX +counter++);
</pre>
<hr />
<pre>
1430                int next = i+1;
1431                if (next &lt; end &amp;&amp; value.charAt(next)==0x000A) i=next; // skip following xA
1432             }
1433             else {
1434                 fNormalizedValue.ch[fNormalizedValue.length++] = c;
1435             }
1436         }
1437         if (normalized){
1438            value = fNormalizedValue.toString();
1439            attr.setValue(value);
1440         }
1441         return value;
1442     }
1443 
1444     protected final class XMLAttributesProxy
1445     implements XMLAttributes {
1446         protected AttributeMap fAttributes;
1447         protected CoreDocumentImpl fDocument;
1448         protected ElementImpl fElement;
1449 
<span class="line-modified">1450         protected final Vector&lt;Augmentations&gt; fAugmentations = new Vector&lt;&gt;(5);</span>
<span class="line-modified">1451 </span>
1452 
1453         public void setAttributes(AttributeMap attributes, CoreDocumentImpl doc, ElementImpl elem) {
1454             fDocument = doc;
1455             fAttributes = attributes;
1456             fElement = elem;
1457             if (attributes != null) {
1458                 int length = attributes.getLength();
<span class="line-modified">1459 </span>
1460                 fAugmentations.setSize(length);
1461                 // REVISIT: this implementation does not store any value in augmentations
1462                 //          and basically not keeping augs in parallel to attributes map
1463                 //          untill all attributes are added (default attributes)
1464                 for (int i = 0; i &lt; length; i++) {
1465                     fAugmentations.setElementAt(new AugmentationsImpl(), i);
1466                 }
<span class="line-modified">1467             } else {</span>


1468                 fAugmentations.setSize(0);
1469             }
1470         }
1471 
1472 
<span class="line-modified">1473                 /**</span>
1474          * This method adds default declarations
1475                  * @see com.sun.org.apache.xerces.internal.xni.XMLAttributes#addAttribute(QName, String, String)
<span class="line-modified">1476                  */</span>
<span class="line-modified">1477                 public int addAttribute(QName qname, String attrType, String attrValue) {</span>
<span class="line-modified">1478                         int index = fElement.getXercesAttribute(qname.uri, qname.localpart);</span>
<span class="line-modified">1479                         // add defaults to the tree</span>
<span class="line-modified">1480                         if (index &lt; 0) {</span>
1481                 // the default attribute was removed by a user and needed to
1482                 // be added back
<span class="line-modified">1483                                 AttrImpl attr = (AttrImpl)</span>
<span class="line-modified">1484                                         ((CoreDocumentImpl) fElement.getOwnerDocument()).createAttributeNS(</span>
<span class="line-modified">1485                                                 qname.uri,</span>
<span class="line-modified">1486                                                 qname.rawname,</span>
<span class="line-modified">1487                                                 qname.localpart);</span>
1488                 // REVISIT: the following should also update ID table
1489                 attr.setNodeValue(attrValue);
1490                 index = fElement.setXercesAttributeNode(attr);

1491                 fAugmentations.insertElementAt(new AugmentationsImpl(), index);
1492                 attr.setSpecified(false);
<span class="line-modified">1493                         }</span>
<span class="line-modified">1494                         else {</span>
1495                 // default attribute is in the tree
1496                 // we don&#39;t need to do anything since prefix was already fixed
1497                 // at the namespace fixup time and value must be same value, otherwise
1498                 // attribute will be treated as specified and we will never reach
1499                 // this method.
1500 
1501             }
1502             return index;
<span class="line-modified">1503                 }</span>
1504 
1505 
1506         public void removeAllAttributes(){
1507             // REVISIT: implement
1508         }
1509 
1510 
1511         public void removeAttributeAt(int attrIndex){
1512             // REVISIT: implement
1513         }
1514 
1515 
1516         public int getLength(){
1517             return(fAttributes != null)?fAttributes.getLength():0;
1518         }
1519 
1520 
1521         public int getIndex(String qName){
1522             // REVISIT: implement
1523             return -1;
1524         }
1525 
<span class="line-modified">1526         public int getIndex(String uri, String localPart){</span>
1527             // REVISIT: implement
1528             return -1;
1529         }
1530 
<span class="line-modified">1531         public void setName(int attrIndex, QName attrName){</span>
1532             // REVISIT: implement
1533         }
1534 
<span class="line-modified">1535         public void getName(int attrIndex, QName attrName){</span>
<span class="line-modified">1536             if (fAttributes !=null) {</span>
1537                 updateQName((Node)fAttributes.getItem(attrIndex), attrName);
1538             }
1539         }
1540 
<span class="line-modified">1541         public String getPrefix(int index){</span>
<span class="line-modified">1542             // REVISIT: implement</span>





1543             return null;
1544         }
1545 
<span class="line-modified">1546 </span>
<span class="line-modified">1547         public String getURI(int index){</span>
<span class="line-modified">1548             // REVISIT: implement</span>




1549             return null;
1550         }
1551 
1552 
<span class="line-modified">1553         public String getLocalName(int index){</span>
<span class="line-modified">1554             // REVISIT: implement</span>





1555             return null;
1556         }
1557 
<span class="line-modified">1558 </span>
<span class="line-modified">1559         public String getQName(int index){</span>
<span class="line-modified">1560             // REVISIT: implement</span>



1561             return null;
1562         }
1563 
1564          public QName getQualifiedName(int index){
1565             //return fAttributes.item(index).ge);
1566             return null;
1567         }
1568 
<span class="line-modified">1569         public void setType(int attrIndex, String attrType){</span>
<span class="line-modified">1570             // REVISIT: implement</span>
1571         }
1572 
<span class="line-modified">1573 </span>
<span class="line-modified">1574         public String getType(int index){</span>
<span class="line-modified">1575             return &quot;CDATA&quot;;</span>
1576         }
1577 
<span class="line-modified">1578 </span>
<span class="line-removed">1579         public String getType(String qName){</span>
1580             return &quot;CDATA&quot;;
1581         }
1582 
<span class="line-modified">1583 </span>
<span class="line-removed">1584         public String getType(String uri, String localName){</span>
1585             return &quot;CDATA&quot;;
1586         }
1587 






1588 
<span class="line-modified">1589         public void setValue(int attrIndex, String attrValue){</span>
1590             // REVISIT: is this desired behaviour?
1591             // The values are updated in the case datatype-normalization is turned on
1592             // in this case we need to make sure that specified attributes stay specified
1593 
1594             if (fAttributes != null){
1595                 AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1596                 boolean specified = attr.getSpecified();
1597                 attr.setValue(attrValue);
1598                 attr.setSpecified(specified);
1599 
1600             }
1601         }
1602 
1603         public  void setValue(int attrIndex, String attrValue, XMLString value){
1604             setValue(attrIndex, value.toString());
1605         }
1606 
1607         public String getValue(int index){
1608             return (fAttributes !=null)?fAttributes.item(index).getNodeValue():&quot;&quot;;
1609 
1610         }
1611 
<span class="line-removed">1612 </span>
1613         public String getValue(String qName){
1614             // REVISIT: implement
1615             return null;
1616         }
1617 
<span class="line-removed">1618 </span>
1619         public String getValue(String uri, String localName){
1620             if (fAttributes != null) {
1621                 Node node =  fAttributes.getNamedItemNS(uri, localName);
1622                 return(node != null)? node.getNodeValue():null;
1623             }
1624             return null;
1625         }
1626 
<span class="line-removed">1627 </span>
1628         public void setNonNormalizedValue(int attrIndex, String attrValue){
1629             // REVISIT: implement
1630 
1631         }
1632 
<span class="line-removed">1633 </span>
1634         public String getNonNormalizedValue(int attrIndex){
1635             // REVISIT: implement
1636             return null;
1637         }
1638 
<span class="line-removed">1639 </span>
1640         public void setSpecified(int attrIndex, boolean specified){
1641             AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1642             attr.setSpecified(specified);
1643         }
1644 
1645         public boolean isSpecified(int attrIndex){
1646             return((Attr)fAttributes.getItem(attrIndex)).getSpecified();
1647         }
1648 
1649         public Augmentations getAugmentations (int attributeIndex){
1650             return fAugmentations.elementAt(attributeIndex);
1651         }
1652 
1653         public Augmentations getAugmentations (String uri, String localPart){
1654             // REVISIT: implement
1655             return null;
1656         }
1657 
1658         public Augmentations getAugmentations(String qName){
1659             // REVISIT: implement
</pre>
<hr />
<pre>
1771      * @param data   The data or null if none specified.
1772      * @param augs   Additional information that may include infoset augmentations
1773      *
1774      * @exception XNIException
1775      *                   Thrown by handler to signal an error.
1776      */
1777     public void processingInstruction(String target, XMLString data, Augmentations augs)
1778         throws XNIException{
1779     }
1780 
1781     /**
1782      * The start of an element.
1783      *
1784      * @param element    The name of the element.
1785      * @param attributes The element attributes.
1786      * @param augs       Additional information that may include infoset augmentations
1787      *
1788      * @exception XNIException
1789      *                   Thrown by handler to signal an error.
1790      */
<span class="line-modified">1791         public void startElement(QName element, XMLAttributes attributes, Augmentations augs)</span>
<span class="line-modified">1792                 throws XNIException {</span>
<span class="line-modified">1793                 Element currentElement = (Element) fCurrentNode;</span>
<span class="line-modified">1794                 int attrCount = attributes.getLength();</span>
1795         if (DEBUG_EVENTS) {
1796             System.out.println(&quot;==&gt;startElement: &quot; +element+
<span class="line-modified">1797             &quot; attrs.length=&quot;+attrCount);</span>
1798         }
1799 
<span class="line-modified">1800                 for (int i = 0; i &lt; attrCount; i++) {</span>
<span class="line-modified">1801                         attributes.getName(i, fAttrQName);</span>
<span class="line-modified">1802                         Attr attr = null;</span>
1803 
<span class="line-modified">1804                         attr = currentElement.getAttributeNodeNS(fAttrQName.uri, fAttrQName.localpart);</span>




1805             AttributePSVI attrPSVI =
<span class="line-modified">1806                                 (AttributePSVI) attributes.getAugmentations(i).getItem(Constants.ATTRIBUTE_PSVI);</span>
1807 
<span class="line-modified">1808                         if (attrPSVI != null) {</span>
1809                 //REVISIT: instead we should be using augmentations:
1810                 // to set/retrieve Id attributes
1811                 XSTypeDefinition decl = attrPSVI.getMemberTypeDefinition();
1812                 boolean id = false;
<span class="line-modified">1813                 if (decl != null){</span>
1814                     id = ((XSSimpleType)decl).isIDType();
<span class="line-modified">1815                 } else{</span>

1816                     decl = attrPSVI.getTypeDefinition();
<span class="line-modified">1817                     if (decl !=null){</span>
<span class="line-modified">1818                        id = ((XSSimpleType)decl).isIDType();</span>
1819                     }
1820                 }
<span class="line-modified">1821                 if (id){</span>
1822                     ((ElementImpl)currentElement).setIdAttributeNode(attr, true);
1823                 }
1824 
<span class="line-modified">1825                                 if (fPSVI) {</span>
<span class="line-modified">1826                                         ((PSVIAttrNSImpl) attr).setPSVI(attrPSVI);</span>
<span class="line-modified">1827                                 }</span>
<span class="line-modified">1828                                 if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {</span>
<span class="line-modified">1829                                         // datatype-normalization</span>
<span class="line-modified">1830                                         // NOTE: The specified value MUST be set after we set</span>
<span class="line-modified">1831                                         //       the node value because that turns the &quot;specified&quot;</span>
<span class="line-modified">1832                                         //       flag to &quot;true&quot; which may overwrite a &quot;false&quot;</span>
<span class="line-modified">1833                                         //       value from the attribute list.</span>
<span class="line-modified">1834                                         boolean specified = attr.getSpecified();</span>
<span class="line-modified">1835                                         attr.setValue(attrPSVI.getSchemaValue().getNormalizedValue());</span>
<span class="line-modified">1836                                         if (!specified) {</span>
<span class="line-modified">1837                                                 ((AttrImpl) attr).setSpecified(specified);</span>
<span class="line-modified">1838                                         }</span>
<span class="line-modified">1839                                 }</span>




1840                         }














1841                 }



1842         }

1843 
1844 
1845     /**
1846      * An empty element.
1847      *
1848      * @param element    The name of the element.
1849      * @param attributes The element attributes.
1850      * @param augs       Additional information that may include infoset augmentations
1851      *
1852      * @exception XNIException
1853      *                   Thrown by handler to signal an error.
1854      */
1855         public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs)
1856                 throws XNIException {
1857         if (DEBUG_EVENTS) {
1858             System.out.println(&quot;==&gt;emptyElement: &quot; +element);
1859         }
1860 
1861                 startElement(element, attributes, augs);
1862         endElement(element, augs);
</pre>
<hr />
<pre>
1931      *                   Thrown by handler to signal an error.
1932      */
1933     public void characters(XMLString text, Augmentations augs) throws XNIException{
1934     }
1935 
1936     /**
1937      * Ignorable whitespace. For this method to be called, the document
1938      * source must have some way of determining that the text containing
1939      * only whitespace characters should be considered ignorable. For
1940      * example, the validator can determine if a length of whitespace
1941      * characters in the document are ignorable based on the element
1942      * content model.
1943      *
1944      * @param text   The ignorable whitespace.
1945      * @param augs   Additional information that may include infoset augmentations
1946      *
1947      * @exception XNIException
1948      *                   Thrown by handler to signal an error.
1949      */
1950     public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException{
<span class="line-modified">1951         allWhitespace = true;</span>
1952     }
1953 
1954     /**
1955      * The end of an element.
1956      *
1957      * @param element The name of the element.
1958      * @param augs    Additional information that may include infoset augmentations
1959      *
1960      * @exception XNIException
1961      *                   Thrown by handler to signal an error.
1962      */
<span class="line-modified">1963         public void endElement(QName element, Augmentations augs) throws XNIException {</span>
<span class="line-modified">1964                 if (DEBUG_EVENTS) {</span>
<span class="line-modified">1965                         System.out.println(&quot;==&gt;endElement: &quot; + element);</span>
<span class="line-modified">1966                 }</span>
1967 
<span class="line-modified">1968         if(augs != null) {</span>
<span class="line-modified">1969                 ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);</span>
<span class="line-modified">1970                 if (elementPSVI != null) {</span>
<span class="line-modified">1971                         ElementImpl elementNode = (ElementImpl) fCurrentNode;</span>
<span class="line-modified">1972                         if (fPSVI) {</span>
<span class="line-modified">1973                                 ((PSVIElementNSImpl) fCurrentNode).setPSVI(elementPSVI);</span>
<span class="line-modified">1974                         }</span>
<span class="line-modified">1975                         // include element default content (if one is available)</span>
<span class="line-modified">1976                         String normalizedValue = elementPSVI.getSchemaValue().getNormalizedValue();</span>
<span class="line-modified">1977                         if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {</span>








1978                     if (normalizedValue !=null)
<span class="line-modified">1979                                     elementNode.setTextContent(normalizedValue);</span>
<span class="line-modified">1980                         }</span>
<span class="line-modified">1981                         else {</span>
<span class="line-modified">1982                                 // NOTE: this is a hack: it is possible that DOM had an empty element</span>
<span class="line-modified">1983                                 // and validator sent default value using characters(), which we don&#39;t</span>
<span class="line-modified">1984                                 // implement. Thus, here we attempt to add the default value.</span>
<span class="line-modified">1985                                 String text = elementNode.getTextContent();</span>
<span class="line-modified">1986                                 if (text.length() == 0) {</span>
<span class="line-modified">1987                                         // default content could be provided</span>
1988                         if (normalizedValue !=null)
1989                             elementNode.setTextContent(normalizedValue);
<span class="line-modified">1990                                 }</span>
<span class="line-removed">1991                         }</span>
1992                 }


1993         }



1994         }

1995 
1996 
1997     /**
1998      * The start of a CDATA section.
1999      *
2000      * @param augs   Additional information that may include infoset augmentations
2001      *
2002      * @exception XNIException
2003      *                   Thrown by handler to signal an error.
2004      */
2005     public void startCDATA(Augmentations augs) throws XNIException{
2006     }
2007 
2008     /**
2009      * The end of a CDATA section.
2010      *
2011      * @param augs   Additional information that may include infoset augmentations
2012      *
2013      * @exception XNIException
2014      *                   Thrown by handler to signal an error.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 
  24 

  25 import com.sun.org.apache.xerces.internal.impl.Constants;
  26 import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
<span class="line-modified">  27 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDLoader;</span>

  28 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator;
  29 import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
  30 import com.sun.org.apache.xerces.internal.impl.xs.util.SimpleLocator;

  31 import com.sun.org.apache.xerces.internal.util.AugmentationsImpl;
  32 import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
  33 import com.sun.org.apache.xerces.internal.util.SymbolTable;
  34 import com.sun.org.apache.xerces.internal.util.XML11Char;
  35 import com.sun.org.apache.xerces.internal.util.XMLChar;

  36 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
  37 import com.sun.org.apache.xerces.internal.xni.Augmentations;
  38 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
  39 import com.sun.org.apache.xerces.internal.xni.QName;
  40 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
  41 import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
  42 import com.sun.org.apache.xerces.internal.xni.XMLLocator;
  43 import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
  44 import com.sun.org.apache.xerces.internal.xni.XMLString;
  45 import com.sun.org.apache.xerces.internal.xni.XNIException;
  46 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;

  47 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
  48 import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;

  49 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
  50 import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
  51 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
  52 import java.io.IOException;

  53 import java.util.ArrayList;
  54 import java.util.List;
  55 import java.util.Vector;
  56 import org.w3c.dom.Attr;
  57 import org.w3c.dom.Comment;
  58 import org.w3c.dom.DOMError;
  59 import org.w3c.dom.DOMErrorHandler;
  60 import org.w3c.dom.Document;
  61 import org.w3c.dom.DocumentType;
  62 import org.w3c.dom.Element;
  63 import org.w3c.dom.Entity;
  64 import org.w3c.dom.NamedNodeMap;
  65 import org.w3c.dom.Node;
  66 import org.w3c.dom.NodeList;
  67 import org.w3c.dom.ProcessingInstruction;
  68 import org.w3c.dom.Text;
  69 /**
  70  * This class adds implementation for normalizeDocument method.
  71  * It acts as if the document was going through a save and load cycle, putting
  72  * the document in a &quot;normal&quot; form. The actual result depends on the features being set
  73  * and governing what operations actually take place. See setNormalizationFeature for details.
  74  * Noticeably this method normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
  75  * according to the algorithm described below in pseudo code, by adding missing namespace
  76  * declaration attributes and adding or changing namespace prefixes, updates the replacement
  77  * tree of EntityReference nodes, normalizes attribute values, etc.
  78  * Mutation events, when supported, are generated to reflect the changes occuring on the
  79  * document.
  80  * See Namespace normalization for details on how namespace declaration attributes and prefixes
  81  * are normalized.
  82  *
  83  * NOTE: There is an initial support for DOM revalidation with XML Schema as a grammar.
  84  * The tree might not be validated correctly if entityReferences, CDATA sections are
  85  * present in the tree. The PSVI information is not exposed, normalized data (including element
  86  * default content is not available).
  87  *
  88  * @xerces.experimental
  89  *
  90  * @author Elena Litani, IBM
  91  * @author Neeraj Bajaj, Sun Microsystems, inc.
<span class="line-modified">  92  * @LastModified: Apr 2019</span>
  93  */
  94 public class DOMNormalizer implements XMLDocumentHandler {
  95 
  96     //
  97     // constants
  98     //
  99     /** Debug normalize document*/
 100     protected final static boolean DEBUG_ND = false;
 101     /** Debug namespace fix up algorithm*/
 102     protected final static boolean DEBUG = false;
 103     /** Debug document handler events */
 104     protected final static boolean DEBUG_EVENTS = false;
 105 
 106     /** prefix added by namespace fixup algorithm should follow a pattern &quot;NS&quot; + index*/
 107     protected final static String PREFIX = &quot;NS&quot;;
 108 
 109     //
 110     // Data
 111     //
 112     protected DOMConfigurationImpl fConfiguration = null;
</pre>
<hr />
<pre>
 131     // Validation against namespace aware grammar
 132     protected boolean fNamespaceValidation = false;
 133 
 134     // Update PSVI information in the tree
 135     protected boolean fPSVI = false;
 136 
 137     /** The namespace context of this document: stores namespaces in scope */
 138     protected final NamespaceContext fNamespaceContext = new NamespaceSupport();
 139 
 140     /** Stores all namespace bindings on the current element */
 141     protected final NamespaceContext fLocalNSBinder = new NamespaceSupport();
 142 
 143     /** list of attributes */
 144     protected final List&lt;Node&gt; fAttributeList = new ArrayList&lt;&gt;(5);
 145 
 146     /** DOM Locator -  for namespace fixup algorithm */
 147     protected final DOMLocatorImpl fLocator = new DOMLocatorImpl();
 148 
 149     /** for setting the PSVI */
 150     protected Node fCurrentNode = null;
<span class="line-modified"> 151     private final QName fAttrQName = new QName();</span>
 152 
 153     // attribute value normalization
 154     final XMLString fNormalizedValue = new XMLString(new char[16], 0, 0);
 155 
 156     //DTD validator
 157     private XMLDTDValidator fDTDValidator;
 158 
<span class="line-modified"> 159     /** Empty string to pass to the validator. **/</span>
<span class="line-modified"> 160     public static final XMLString EMPTY_STRING = new XMLString();</span>
<span class="line-added"> 161 </span>
<span class="line-added"> 162     // Check if element content is all &quot;ignorable whitespace&quot;</span>
<span class="line-added"> 163     private boolean fAllWhitespace = false;</span>
 164 
 165     // Constructor
 166     //
 167 
 168     public DOMNormalizer(){}
 169 
 170 
 171 
 172     /**
 173      * Normalizes document.
 174      * Note: reset() must be called before this method.
 175      */
<span class="line-modified"> 176     protected void normalizeDocument(CoreDocumentImpl document, DOMConfigurationImpl config) {</span>
<span class="line-added"> 177 </span>
<span class="line-added"> 178         fDocument = document;</span>
<span class="line-added"> 179         fConfiguration = config;</span>
<span class="line-added"> 180         fAllWhitespace = false;</span>
<span class="line-added"> 181         fNamespaceValidation = false;</span>
 182 
<span class="line-modified"> 183         String xmlVersion = fDocument.getXmlVersion();</span>
<span class="line-modified"> 184         String schemaType = null;</span>
<span class="line-added"> 185         String [] schemaLocations = null;</span>
 186 
<span class="line-modified"> 187         // intialize and reset DOMNormalizer component</span>
<span class="line-modified"> 188         //</span>
<span class="line-modified"> 189         fSymbolTable = (SymbolTable) fConfiguration.getProperty(DOMConfigurationImpl.SYMBOL_TABLE);</span>
<span class="line-modified"> 190         // reset namespace context</span>
<span class="line-modified"> 191         fNamespaceContext.reset();</span>
<span class="line-modified"> 192         fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, null);</span>
 193 
<span class="line-modified"> 194         if ((fConfiguration.features &amp; DOMConfigurationImpl.VALIDATE) != 0) {</span>
 195             String schemaLang = (String)fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_LANGUAGE);
 196 
<span class="line-modified"> 197             if (schemaLang != null &amp;&amp; schemaLang.equals(Constants.NS_XMLSCHEMA)) {</span>
<span class="line-modified"> 198                 schemaType = XMLGrammarDescription.XML_SCHEMA;</span>
<span class="line-modified"> 199                 fValidationHandler = CoreDOMImplementationImpl.singleton.getValidator(schemaType, xmlVersion);</span>
 200                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA, true);
 201                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA_FULL_CHECKING, true);
 202                 // report fatal error on DOM Level 1 nodes
 203                 fNamespaceValidation = true;
 204 
 205                 // check if we need to fill in PSVI
 206                 fPSVI = ((fConfiguration.features &amp; DOMConfigurationImpl.PSVI) !=0)?true:false;
 207             }
<span class="line-added"> 208             else {</span>
<span class="line-added"> 209                 schemaType = XMLGrammarDescription.XML_DTD;</span>
<span class="line-added"> 210                 if (schemaLang != null) {</span>
<span class="line-added"> 211                     schemaLocations = (String []) fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_SOURCE);</span>
<span class="line-added"> 212                 }</span>
<span class="line-added"> 213                 fConfiguration.setDTDValidatorFactory(xmlVersion);</span>
<span class="line-added"> 214                 fValidationHandler = CoreDOMImplementationImpl.singleton.getValidator(schemaType, xmlVersion);</span>
<span class="line-added"> 215                 fPSVI = false;</span>
<span class="line-added"> 216             }</span>
 217 
<span class="line-modified"> 218             fConfiguration.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);</span>
 219 
 220             // reset ID table
 221             fDocument.clearIdentifiers();
 222 
<span class="line-modified"> 223             if (fValidationHandler != null) {</span>
<span class="line-modified"> 224                 // reset the validation handler</span>
 225                 ((XMLComponent) fValidationHandler).reset(fConfiguration);
<span class="line-added"> 226             }</span>
<span class="line-added"> 227         }</span>
<span class="line-added"> 228         else {</span>
<span class="line-added"> 229             fValidationHandler = null;</span>
<span class="line-added"> 230         }</span>
 231 
<span class="line-modified"> 232         fErrorHandler = (DOMErrorHandler) fConfiguration.getParameter(Constants.DOM_ERROR_HANDLER);</span>
<span class="line-modified"> 233         if (fValidationHandler != null) {</span>
<span class="line-modified"> 234             fValidationHandler.setDocumentHandler(this);</span>
<span class="line-modified"> 235             fValidationHandler.startDocument(</span>


 236                     new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,
<span class="line-modified"> 237                             -1, -1 ), fDocument.encoding, fNamespaceContext, null);</span>
<span class="line-modified"> 238             fValidationHandler.xmlDecl(fDocument.getXmlVersion(),</span>
<span class="line-modified"> 239                     fDocument.getXmlEncoding(), fDocument.getXmlStandalone() ? &quot;yes&quot; : &quot;no&quot;, null);</span>
<span class="line-modified"> 240         }</span>
<span class="line-modified"> 241         try {</span>
<span class="line-modified"> 242             if (schemaType == XMLGrammarDescription.XML_DTD) {</span>
<span class="line-modified"> 243                 processDTD(xmlVersion, schemaLocations != null ? schemaLocations[0] : null);</span>
<span class="line-modified"> 244             }</span>




 245 
<span class="line-modified"> 246             Node kid, next;</span>
<span class="line-modified"> 247             for (kid = fDocument.getFirstChild(); kid != null; kid = next) {</span>
<span class="line-modified"> 248                 next = kid.getNextSibling();</span>
<span class="line-modified"> 249                 kid = normalizeNode(kid);</span>
<span class="line-modified"> 250                 if (kid != null) { // don&#39;t advance</span>
<span class="line-modified"> 251                     next = kid;</span>



 252                 }
<span class="line-added"> 253             }</span>
 254 
<span class="line-added"> 255             // release resources</span>
<span class="line-added"> 256             if (fValidationHandler != null) {</span>
<span class="line-added"> 257                 fValidationHandler.endDocument(null);</span>
<span class="line-added"> 258                 fValidationHandler.setDocumentHandler(null);</span>
<span class="line-added"> 259                 CoreDOMImplementationImpl.singleton.releaseValidator(schemaType, xmlVersion, fValidationHandler);</span>
<span class="line-added"> 260                 fValidationHandler = null;</span>
<span class="line-added"> 261             }</span>
 262         }
<span class="line-modified"> 263         catch (RuntimeException e) {</span>
<span class="line-added"> 264             // release resources</span>
<span class="line-added"> 265             if (fValidationHandler != null) {</span>
<span class="line-added"> 266                 fValidationHandler.setDocumentHandler(null);</span>
<span class="line-added"> 267                 CoreDOMImplementationImpl.singleton.releaseValidator(schemaType, xmlVersion, fValidationHandler);</span>
<span class="line-added"> 268                 fValidationHandler = null;</span>
<span class="line-added"> 269             }</span>
<span class="line-added"> 270             if (e instanceof AbortException) {</span>
<span class="line-added"> 271                 return; // processing aborted by the user</span>
<span class="line-added"> 272             }</span>
<span class="line-added"> 273             throw e; // otherwise re-throw.</span>
<span class="line-added"> 274         }</span>
<span class="line-added"> 275     }</span>
 276 
 277     /**
 278      *
 279      * This method acts as if the document was going through a save
 280      * and load cycle, putting the document in a &quot;normal&quot; form. The actual result
 281      * depends on the features being set and governing what operations actually
 282      * take place. See setNormalizationFeature for details. Noticeably this method
 283      * normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
 284      * according to the algorithm described below in pseudo code, by adding missing
 285      * namespace declaration attributes and adding or changing namespace prefixes, updates
 286      * the replacement tree of EntityReference nodes,normalizes attribute values, etc.
 287      *
 288      * @param node   Modified node or null. If node is returned, we need
 289      *               to normalize again starting on the node returned.
 290      * @return  the normalized Node
 291      */
 292     protected Node normalizeNode (Node node){
 293 
 294         int type = node.getNodeType();
 295         boolean wellformed;
 296         fLocator.fRelatedNode=node;
 297 
 298         switch (type) {
 299         case Node.DOCUMENT_TYPE_NODE: {
 300                 if (DEBUG_ND) {
 301                     System.out.println(&quot;==&gt;normalizeNode:{doctype}&quot;);
 302                 }
<span class="line-modified"> 303                 // REVISIT: well-formedness encoding info</span>









 304                 break;
 305             }
 306 
 307         case Node.ELEMENT_NODE: {
 308                 if (DEBUG_ND) {
 309                     System.out.println(&quot;==&gt;normalizeNode:{element} &quot;+node.getNodeName());
 310                 }
 311 
 312                 //do the name check only when version of the document was changed &amp;
 313                 //application has set the value of well-formed features to true
 314                 if (fDocument.errorChecking) {
 315                     if ( ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;
 316                             fDocument.isXMLVersionChanged()){
 317                         if (fNamespaceValidation){
<span class="line-modified"> 318                             wellformed = CoreDocumentImpl.isValidQName(node.getPrefix() , node.getLocalName(), fDocument.isXML11Version());</span>
 319                         }
 320                         else {
 321                             wellformed = CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
 322                         }
 323                         if (!wellformed){
 324                             String msg = DOMMessageFormatter.formatMessage(
 325                                     DOMMessageFormatter.DOM_DOMAIN,
 326                                     &quot;wf-invalid-character-in-node-name&quot;,
 327                                     new Object[]{&quot;Element&quot;, node.getNodeName()});
 328                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 329                             &quot;wf-invalid-character-in-node-name&quot;);
 330                         }
 331                     }
 332                 }
 333                 // push namespace context
 334                 fNamespaceContext.pushContext();
 335                 fLocalNSBinder.reset();
 336 
 337                 ElementImpl elem = (ElementImpl)node;
 338                 if (elem.needsSyncChildren()) {
 339                     elem.synchronizeChildren();
 340                 }
 341                 AttributeMap attributes = (elem.hasAttributes()) ? (AttributeMap) elem.getAttributes() : null;
 342 
 343                 // fix namespaces and remove default attributes
 344                 if ((fConfiguration.features &amp; DOMConfigurationImpl.NAMESPACES) !=0) {
 345                     // fix namespaces
 346                     // normalize attribute values
 347                     // remove default attributes
 348                     namespaceFixUp(elem, attributes);
 349 
<span class="line-modified"> 350                     if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0) {</span>
<span class="line-modified"> 351                         // Namespace declarations may have been added by namespace fix-up. Need</span>
<span class="line-modified"> 352                         // to fetch the AttributeMap again if it contained no attributes prior</span>
<span class="line-modified"> 353                         // to namespace fix-up.</span>
<span class="line-modified"> 354                         if (attributes == null) {</span>
<span class="line-modified"> 355                             attributes = (elem.hasAttributes()) ? (AttributeMap) elem.getAttributes() : null;</span>
<span class="line-modified"> 356                         }</span>
<span class="line-added"> 357                         if (attributes != null) {</span>
<span class="line-added"> 358                             for (int i = 0; i &lt; attributes.getLength(); ++i) {</span>
<span class="line-added"> 359                                 Attr att = (Attr)attributes.getItem(i);</span>
<span class="line-added"> 360                                 if (XMLSymbols.PREFIX_XMLNS.equals(att.getPrefix()) ||</span>
<span class="line-added"> 361                                         XMLSymbols.PREFIX_XMLNS.equals(att.getName())) {</span>
<span class="line-added"> 362                                     elem.removeAttributeNode(att);</span>
<span class="line-added"> 363                                     --i;</span>
<span class="line-added"> 364                                 }</span>
 365                             }
 366                         }
 367                     }
 368 
 369                 } else {
 370                     if ( attributes!=null ) {
 371                         for ( int i=0; i&lt;attributes.getLength(); ++i ) {
 372                             Attr attr = (Attr)attributes.item(i);
 373                             //removeDefault(attr, attributes);
 374                             attr.normalize();
 375                             if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
<span class="line-modified"> 376                                     isAttrValueWF(fErrorHandler, fError, fLocator, attributes, attr, attr.getValue(), fDocument.isXML11Version());</span>
<span class="line-modified"> 377                                 if (fDocument.isXMLVersionChanged()) {</span>
<span class="line-modified"> 378                                     if (fNamespaceValidation){</span>
<span class="line-modified"> 379                                         wellformed = CoreDocumentImpl.isValidQName(node.getPrefix(), node.getLocalName(), fDocument.isXML11Version());</span>
<span class="line-modified"> 380                                     }</span>
<span class="line-modified"> 381                                     else {</span>
<span class="line-modified"> 382                                         wellformed = CoreDocumentImpl.isXMLName(node.getNodeName(), fDocument.isXML11Version());</span>
<span class="line-modified"> 383                                     }</span>
<span class="line-modified"> 384                                     if (!wellformed) {</span>
<span class="line-modified"> 385                                         String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-added"> 386                                           DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-added"> 387                                           &quot;wf-invalid-character-in-node-name&quot;,</span>
<span class="line-added"> 388                                            new Object[]{&quot;Attr&quot;,node.getNodeName()});</span>
<span class="line-added"> 389                                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,</span>
<span class="line-added"> 390                                             &quot;wf-invalid-character-in-node-name&quot;);</span>
 391                                     }
 392                                 }
 393                             }
 394                         }
 395                     }
 396                 }
 397 
 398 
 399                 if (fValidationHandler != null) {
 400                     // REVISIT: possible solutions to discard default content are:
 401                     //         either we pass some flag to XML Schema validator
 402                     //         or rely on the PSVI information.
 403                     fAttrProxy.setAttributes(attributes, fDocument, elem);
 404                     updateQName(elem, fQName); // updates global qname
 405                     // set error node in the dom error wrapper
 406                     // so if error occurs we can report an error node
 407                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 408                     fCurrentNode = node;
 409                     // call re-validation handler
 410                     fValidationHandler.startElement(fQName, fAttrProxy, null);
 411                 }
 412 














 413                 // normalize children
 414                 Node kid, next;
 415                 for (kid = elem.getFirstChild(); kid != null; kid = next) {
 416                     next = kid.getNextSibling();
 417                     kid = normalizeNode(kid);
<span class="line-modified"> 418                     if (kid != null) {</span>
 419                         next = kid;  // don&#39;t advance
 420                     }
 421                 }
 422                 if (DEBUG_ND) {
 423                     // normalized subtree
 424                     System.out.println(&quot;***The children of {&quot;+node.getNodeName()+&quot;} are normalized&quot;);
 425                     for (kid = elem.getFirstChild(); kid != null; kid = next) {
 426                         next = kid.getNextSibling();
 427                         System.out.println(kid.getNodeName() +&quot;[&quot;+kid.getNodeValue()+&quot;]&quot;);
 428                     }
 429 
 430                 }
 431 

 432                 if (fValidationHandler != null) {
 433                     updateQName(elem, fQName); // updates global qname
 434                     //
 435                     // set error node in the dom error wrapper
 436                     // so if error occurs we can report an error node
 437                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 438                     fCurrentNode = node;
 439                     fValidationHandler.endElement(fQName, null);
 440                 }
 441 










 442                 // pop namespace context
 443                 fNamespaceContext.popContext();
 444 
 445                 break;
 446             }
 447 
 448         case Node.COMMENT_NODE: {
 449                 if (DEBUG_ND) {
 450                     System.out.println(&quot;==&gt;normalizeNode:{comments}&quot;);
 451                 }
 452 
 453                 if ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0) {
 454                     Node prevSibling = node.getPreviousSibling();
 455                     Node parent = node.getParentNode();
 456                     // remove the comment node
 457                     parent.removeChild(node);
 458                     if (prevSibling != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE) {
 459                         Node nextSibling = prevSibling.getNextSibling();
 460                         if (nextSibling != null &amp;&amp; nextSibling.getNodeType() == Node.TEXT_NODE) {
 461                             ((TextImpl)nextSibling).insertData(0, prevSibling.getNodeValue());
 462                             parent.removeChild(prevSibling);
 463                             return nextSibling;
 464                         }
 465                     }
 466                 }//if comment node need not be removed
 467                 else {
 468                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
 469                         String commentdata = ((Comment)node).getData();
 470                         // check comments for invalid xml chracter as per the version
 471                         // of the document
 472                         isCommentWF(fErrorHandler, fError, fLocator, commentdata, fDocument.isXML11Version());
 473                     }
<span class="line-added"> 474                     if (fValidationHandler != null) {</span>
<span class="line-added"> 475                         // Don&#39;t bother filling an XMLString with the text of the comment.</span>
<span class="line-added"> 476                         // We only send the comment event to the validator handler so that</span>
<span class="line-added"> 477                         // when  the schema-type is DTD an error will be reported for a</span>
<span class="line-added"> 478                         // comment appearing in EMPTY content.</span>
<span class="line-added"> 479                         fValidationHandler.comment(EMPTY_STRING, null);</span>
<span class="line-added"> 480                     }</span>
 481                 }//end-else if comment node is not to be removed.
 482                                 break;
 483             }
 484         case Node.ENTITY_REFERENCE_NODE: {
 485                 if (DEBUG_ND) {
 486                     System.out.println(&quot;==&gt;normalizeNode:{entityRef} &quot;+node.getNodeName());
 487                 }
 488 
 489                 if ((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0) {
 490                     Node prevSibling = node.getPreviousSibling();
 491                     Node parent = node.getParentNode();
 492                     ((EntityReferenceImpl)node).setReadOnly(false, true);
 493                     expandEntityRef (parent, node);
 494                     parent.removeChild(node);
 495                     Node next = (prevSibling != null)?prevSibling.getNextSibling():parent.getFirstChild();
 496                     // The list of children #text -&gt; &amp;ent;
 497                     // and entity has a first child as a text
 498                     // we should not advance
 499                     if (prevSibling != null &amp;&amp; next != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE &amp;&amp;
 500                         next.getNodeType() == Node.TEXT_NODE) {
</pre>
<hr />
<pre>
 527                     }
 528                     else {
 529                         Text text = fDocument.createTextNode(node.getNodeValue());
 530                         Node parent = node.getParentNode();
 531                         node = parent.replaceChild(text, node);
 532                         return text;  //don&#39;t advance
 533 
 534                     }
 535                 }
 536 
 537                 // send characters call for CDATA
 538                 if (fValidationHandler != null) {
 539                     // set error node in the dom error wrapper
 540                     // so if error occurs we can report an error node
 541                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 542                     fCurrentNode = node;
 543                     fValidationHandler.startCDATA(null);
 544                     fValidationHandler.characterData(node.getNodeValue(), null);
 545                     fValidationHandler.endCDATA(null);
 546                 }










 547                 String value = node.getNodeValue();
 548 
 549                 if ((fConfiguration.features &amp; DOMConfigurationImpl.SPLITCDATA) != 0) {
 550                     int index;
 551                     Node parent = node.getParentNode();
 552                     if (fDocument.errorChecking) {
 553                         isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());
 554                     }
 555                     while ( (index=value.indexOf(&quot;]]&gt;&quot;)) &gt;= 0 ) {
 556                         node.setNodeValue(value.substring(0, index+2));
 557                         value = value.substring(index +2);
 558 
 559                         Node firstSplitNode = node;
 560                         Node newChild = fDocument.createCDATASection(value);
 561                         parent.insertBefore(newChild, node.getNextSibling());
 562                         node = newChild;
 563                         // issue warning
 564                         fLocator.fRelatedNode = firstSplitNode;
 565                         String msg = DOMMessageFormatter.formatMessage(
 566                             DOMMessageFormatter.DOM_DOMAIN,
</pre>
<hr />
<pre>
 591                 // If an adjacent text node, merge it with this node
 592                 if ( next!=null &amp;&amp; next.getNodeType() == Node.TEXT_NODE ) {
 593                     ((Text)node).appendData(next.getNodeValue());
 594                     node.getParentNode().removeChild( next );
 595                     // We don&#39;t need to check well-formness here since we are not yet
 596                     // done with this node.
 597 
 598                     return node; // Don&#39;t advance;
 599                 } else if (node.getNodeValue().length()==0) {
 600                     // If kid is empty, remove it
 601                     node.getParentNode().removeChild( node );
 602                 } else {
 603                     // validator.characters() call and well-formness
 604                     // Don&#39;t send characters or check well-formness in the following cases:
 605                     // 1. entities is false, next child is entity reference: expand tree first
 606                     // 2. comments is false, and next child is comment
 607                     // 3. cdata is false, and next child is cdata
 608 
 609                     short nextType = (next != null)?next.getNodeType():-1;
 610                     if (nextType == -1 || !(((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0 &amp;&amp;
<span class="line-modified"> 611                             nextType == Node.ENTITY_NODE) ||</span>
<span class="line-modified"> 612                             ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0 &amp;&amp;</span>
<span class="line-modified"> 613                                     nextType == Node.COMMENT_NODE) ||</span>
<span class="line-modified"> 614                                     ((fConfiguration.features &amp; DOMConfigurationImpl.CDATA) == 0) &amp;&amp;</span>
<span class="line-modified"> 615                                     nextType == Node.CDATA_SECTION_NODE)) {</span>
<span class="line-modified"> 616                         if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) ){</span>
<span class="line-modified"> 617                             isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());</span>
<span class="line-modified"> 618                         }</span>
<span class="line-modified"> 619                         if (fValidationHandler != null) {</span>
<span class="line-modified"> 620                             fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;</span>
<span class="line-modified"> 621                             fCurrentNode = node;</span>
<span class="line-modified"> 622                             fValidationHandler.characterData(node.getNodeValue(), null);</span>
<span class="line-modified"> 623                             if (!fNamespaceValidation) {</span>
<span class="line-modified"> 624                                 if (fAllWhitespace) {</span>
<span class="line-modified"> 625                                     fAllWhitespace = false;</span>
<span class="line-modified"> 626                                     ((TextImpl)node).setIgnorableWhitespace(true);</span>
<span class="line-modified"> 627                                 }</span>
<span class="line-modified"> 628                                 else {</span>
<span class="line-modified"> 629                                     ((TextImpl)node).setIgnorableWhitespace(false);</span>
<span class="line-modified"> 630                                 }</span>
<span class="line-modified"> 631                             }</span>
<span class="line-modified"> 632                             if (DEBUG_ND) {</span>
<span class="line-modified"> 633                                 System.out.println(&quot;=====&gt;characterData(),&quot;+nextType);</span>
<span class="line-modified"> 634                             }</span>
<span class="line-modified"> 635                         }</span>





 636                     }
 637                     else {
<span class="line-modified"> 638                         if (DEBUG_ND) {</span>
<span class="line-modified"> 639                             System.out.println(&quot;=====&gt;don&#39;t send characters(),&quot;+nextType);</span>
 640 
<span class="line-modified"> 641                         }</span>
 642                     }
 643                 }
 644                 break;
 645             }
 646         case Node.PROCESSING_INSTRUCTION_NODE: {
 647 
 648             //do the well-formed valid PI target name , data check when application has set the value of well-formed feature to true
 649             if (fDocument.errorChecking &amp;&amp; (fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0 ) {
 650                 ProcessingInstruction pinode = (ProcessingInstruction)node ;
 651 
 652                 String target = pinode.getTarget();
 653                 //1.check PI target name
 654                 if(fDocument.isXML11Version()){
 655                     wellformed = XML11Char.isXML11ValidName(target);
 656                 }
 657                 else{
 658                     wellformed = XMLChar.isValidName(target);
 659                 }
 660 
 661                                 if (!wellformed) {
 662                                     String msg = DOMMessageFormatter.formatMessage(
 663                                         DOMMessageFormatter.DOM_DOMAIN,
 664                                         &quot;wf-invalid-character-in-node-name&quot;,
 665                                         new Object[]{&quot;Element&quot;, node.getNodeName()});
 666                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 667                         &quot;wf-invalid-character-in-node-name&quot;);
 668                 }
 669 
 670                 //2. check PI data
 671                 //processing isntruction data may have certain characters
 672                 //which may not be valid XML character
 673                 isXMLCharWF(fErrorHandler, fError, fLocator, pinode.getData(), fDocument.isXML11Version());
 674             }
<span class="line-added"> 675 </span>
<span class="line-added"> 676             if (fValidationHandler != null) {</span>
<span class="line-added"> 677                 // Don&#39;t bother filling an XMLString with the data section of the</span>
<span class="line-added"> 678                 // processing instruction. We only send the processing instruction</span>
<span class="line-added"> 679                 // event to the validator handler so that when the schema-type is</span>
<span class="line-added"> 680                 // DTD an error will be reported for a processing instruction</span>
<span class="line-added"> 681                 // appearing in EMPTY content.</span>
<span class="line-added"> 682                 fValidationHandler.processingInstruction(((ProcessingInstruction) node).getTarget(), EMPTY_STRING, null);</span>
<span class="line-added"> 683             }</span>
 684         }//end case Node.PROCESSING_INSTRUCTION_NODE
 685 
 686         }//end of switch
 687         return null;
 688     }//normalizeNode
 689 
<span class="line-modified"> 690     private void processDTD(String xmlVersion, String schemaLocation) {</span>


 691 
<span class="line-modified"> 692         String rootName = null;</span>
<span class="line-modified"> 693         String publicId = null;</span>
<span class="line-modified"> 694         String systemId = schemaLocation;</span>
<span class="line-modified"> 695         String baseSystemId = fDocument.getDocumentURI();</span>
<span class="line-modified"> 696         String internalSubset = null;</span>
 697 
<span class="line-modified"> 698         DocumentType docType = fDocument.getDoctype();</span>
<span class="line-modified"> 699         if (docType != null) {</span>
<span class="line-added"> 700             rootName = docType.getName();</span>
<span class="line-added"> 701             publicId = docType.getPublicId();</span>
<span class="line-added"> 702             if (systemId == null || systemId.length() == 0) {</span>
<span class="line-added"> 703                 systemId = docType.getSystemId();</span>
<span class="line-added"> 704             }</span>
<span class="line-added"> 705             internalSubset = docType.getInternalSubset();</span>
<span class="line-added"> 706         }</span>
<span class="line-added"> 707         // If the DOM doesn&#39;t have a DocumentType node we may still</span>
<span class="line-added"> 708         // be able to fetch a DTD if the application provided a URI</span>
<span class="line-added"> 709         else {</span>
<span class="line-added"> 710             Element elem = fDocument.getDocumentElement();</span>
<span class="line-added"> 711             if (elem == null) return;</span>
<span class="line-added"> 712             rootName = elem.getNodeName();</span>
<span class="line-added"> 713             if (systemId == null || systemId.length() == 0) return;</span>
<span class="line-added"> 714         }</span>
 715 
<span class="line-modified"> 716         XMLDTDLoader loader = null;</span>

 717         try {
<span class="line-modified"> 718             fValidationHandler.doctypeDecl(rootName, publicId, systemId, null);</span>
<span class="line-modified"> 719             loader = CoreDOMImplementationImpl.singleton.getDTDLoader(xmlVersion);</span>
<span class="line-modified"> 720             loader.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);</span>
<span class="line-modified"> 721             loader.setEntityResolver(fConfiguration.getEntityResolver());</span>
<span class="line-modified"> 722             loader.setErrorHandler(fConfiguration.getErrorHandler());</span>
<span class="line-modified"> 723             loader.loadGrammarWithContext((XMLDTDValidator) fValidationHandler, rootName,</span>
<span class="line-modified"> 724                     publicId, systemId, baseSystemId, internalSubset);</span>

 725         }
<span class="line-modified"> 726         // REVISIT: Should probably report this exception to the error handler.</span>
<span class="line-modified"> 727         catch (IOException e) {</span>
<span class="line-modified"> 728         }</span>
<span class="line-modified"> 729         finally {</span>
<span class="line-modified"> 730             if (loader != null) {</span>
<span class="line-added"> 731                 CoreDOMImplementationImpl.singleton.releaseDTDLoader(xmlVersion, loader);</span>
<span class="line-added"> 732             }</span>
<span class="line-added"> 733         }</span>
<span class="line-added"> 734     } // processDTD(String, String)</span>
 735 
 736     protected final void expandEntityRef (Node parent, Node reference){
 737         Node kid, next;
 738         for (kid = reference.getFirstChild(); kid != null; kid = next) {
 739             next = kid.getNextSibling();
 740             parent.insertBefore(kid, reference);
 741         }
 742     }
 743 
 744     // fix namespaces
 745     // normalize attribute values
 746     // remove default attributes
 747     // check attribute names if the version of the document changed.
 748 
 749     protected final void namespaceFixUp (ElementImpl element, AttributeMap attributes){
 750         if (DEBUG) {
 751             System.out.println(&quot;[ns-fixup] element:&quot; +element.getNodeName()+
 752                                &quot; uri: &quot;+element.getNamespaceURI());
 753         }
 754 
 755         // ------------------------------------
 756         // pick up local namespace declarations
 757         // &lt;xsl:stylesheet xmlns:xsl=&quot;http://xslt&quot;&gt;
 758         //   &lt;!-- add the following via DOM
 759         //          body is bound to http://xslt
 760         //    --&gt;
 761         //   &lt;xsl:body xmlns:xsl=&quot;http://bound&quot;/&gt;
 762         //
 763         // ------------------------------------
 764 
<span class="line-modified"> 765         String value, uri, prefix;</span>
 766         if (attributes != null) {
 767 
 768             // Record all valid local declarations
 769             for (int k = 0; k &lt; attributes.getLength(); ++k) {
 770                 Attr attr = (Attr)attributes.getItem(k);









 771                 uri = attr.getNamespaceURI();
 772                 if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 773                     // namespace attribute






 774                     value = attr.getNodeValue();
 775                     if (value == null) {
 776                         value=XMLSymbols.EMPTY_STRING;
 777                     }
 778 
 779                     // Check for invalid namespace declaration:
 780                     if (fDocument.errorChecking &amp;&amp; value.equals(NamespaceContext.XMLNS_URI)) {
 781                         //A null value for locale is passed to formatMessage,
 782                         //which means that the default locale will be used
 783                         fLocator.fRelatedNode = attr;
 784                         String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,&quot;CantBindXMLNS&quot;,null );
 785                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR, &quot;CantBindXMLNS&quot;);
 786                     } else {
 787                         // XML 1.0 Attribute value normalization
 788                         // value = normalizeAttributeValue(value, attr);
 789                         prefix = attr.getPrefix();
 790                         prefix = (prefix == null ||
 791                                   prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 792                         String localpart = fSymbolTable.addSymbol( attr.getLocalName());
 793                         if (prefix == XMLSymbols.PREFIX_XMLNS) { //xmlns:prefix
 794 
 795                             value = fSymbolTable.addSymbol(value);
 796                             if (value.length() != 0) {
 797                                 fNamespaceContext.declarePrefix(localpart, value);
 798                             } else {
 799                                 // REVISIT: issue error on invalid declarations
 800                                 //          xmlns:foo = &quot;&quot;
 801 
 802                             }
 803                             //removeDefault (attr, attributes);
 804                             continue;
 805                         } else { // (localpart == fXmlnsSymbol &amp;&amp; prefix == fEmptySymbol)  -- xmlns
 806                             // empty prefix is always bound (&quot;&quot; or some string)
 807                             value = fSymbolTable.addSymbol(value);
<span class="line-modified"> 808                             fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, value.length() != 0 ? value : null);</span>
 809                             //removeDefault (attr, attributes);
 810                             continue;
 811                         }
 812                     }  // end-else: valid declaration
 813                 } // end-if: namespace attribute
 814             }
 815         }
 816 
 817 
 818 
 819         // ---------------------------------------------------------
 820         // Fix up namespaces for element: per DOM L3
 821         // Need to consider the following cases:
 822         //
 823         // case 1: &lt;xsl:stylesheet xmlns:xsl=&quot;http://xsl&quot;&gt;
 824         // We create another element body bound to the &quot;http://xsl&quot; namespace
 825         // as well as namespace attribute rebounding xsl to another namespace.
 826         // &lt;xsl:body xmlns:xsl=&quot;http://another&quot;&gt;
 827         // Need to make sure that the new namespace decl value is changed to
 828         // &quot;http://xsl&quot;
 829         //
 830         // ---------------------------------------------------------
 831         // check if prefix/namespace is correct for current element
 832         // ---------------------------------------------------------
 833 
 834         uri = element.getNamespaceURI();
 835         prefix = element.getPrefix();
<span class="line-modified"> 836         if (uri != null) {  // Element has a namespace</span>





 837             uri = fSymbolTable.addSymbol(uri);
 838             prefix = (prefix == null ||
 839                       prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 840             if (fNamespaceContext.getURI(prefix) == uri) {
 841                 // The xmlns:prefix=namespace or xmlns=&quot;default&quot; was declared at parent.
 842                 // The binder always stores mapping of empty prefix to &quot;&quot;.
 843             } else {
 844                 // the prefix is either undeclared
 845                 // or
 846                 // conflict: the prefix is bound to another URI
 847                 addNamespaceDecl(prefix, uri, element);
 848                 fLocalNSBinder.declarePrefix(prefix, uri);
 849                 fNamespaceContext.declarePrefix(prefix, uri);
 850             }
 851         } else { // Element has no namespace
 852             if (element.getLocalName() == null) {
 853 
 854                 //  Error: DOM Level 1 node!
 855                 if (fNamespaceValidation) {
 856                     String msg = DOMMessageFormatter.formatMessage(
 857                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 858                             new Object[]{element.getNodeName()});
 859                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR,
 860                     &quot;NullLocalElementName&quot;);
 861                 } else {
 862                     String msg = DOMMessageFormatter.formatMessage(
 863                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 864                             new Object[]{element.getNodeName()});
 865                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 866                     &quot;NullLocalElementName&quot;);
 867                 }
 868 
 869             } else { // uri=null and no colon (DOM L2 node)
 870                 uri = fNamespaceContext.getURI(XMLSymbols.EMPTY_STRING);
 871                 if (uri !=null &amp;&amp; uri.length() &gt; 0) {
 872                     // undeclare default namespace declaration (before that element
 873                     // bound to non-zero length uir), but adding xmlns=&quot;&quot; decl
 874                     addNamespaceDecl (XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING, element);
<span class="line-modified"> 875                     fLocalNSBinder.declarePrefix(XMLSymbols.EMPTY_STRING, null);</span>
<span class="line-modified"> 876                     fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, null);</span>
 877                 }
 878             }
 879         }
 880 
 881         // -----------------------------------------
 882         // Fix up namespaces for attributes: per DOM L3
 883         // check if prefix/namespace is correct the attributes
 884         // -----------------------------------------
 885         if (attributes != null) {
 886 
 887             // clone content of the attributes
 888             attributes.cloneMap(fAttributeList);
 889             for (int i = 0; i &lt; fAttributeList.size(); i++) {
 890                 Attr attr = (Attr) fAttributeList.get(i);
 891                 fLocator.fRelatedNode = attr;
 892 
 893                 if (DEBUG) {
 894                     System.out.println(&quot;==&gt;[ns-fixup] process attribute: &quot;+attr.getNodeName());
 895                 }
 896                 // normalize attribute value
 897                 attr.normalize();
 898                 value = attr.getValue();

 899                 uri = attr.getNamespaceURI();
 900 
 901                 // make sure that value is never null.
 902                 if (value == null) {
<span class="line-modified"> 903                     value = XMLSymbols.EMPTY_STRING;</span>
<span class="line-added"> 904                 }</span>
<span class="line-added"> 905 </span>
<span class="line-added"> 906                 //---------------------------------------</span>
<span class="line-added"> 907                 // check if value of the attribute is namespace well-formed</span>
<span class="line-added"> 908                 //---------------------------------------</span>
<span class="line-added"> 909                 if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)) {</span>
<span class="line-added"> 910                     isAttrValueWF(fErrorHandler, fError, fLocator, attributes, attr, value, fDocument.isXML11Version());</span>
<span class="line-added"> 911                     if (fDocument.isXMLVersionChanged()) {</span>
<span class="line-added"> 912                         boolean wellformed;</span>
<span class="line-added"> 913                         if (fNamespaceValidation){</span>
<span class="line-added"> 914                             wellformed = CoreDocumentImpl.isValidQName(attr.getPrefix(), attr.getLocalName(), fDocument.isXML11Version());</span>
<span class="line-added"> 915                         }</span>
<span class="line-added"> 916                         else {</span>
<span class="line-added"> 917                             wellformed = CoreDocumentImpl.isXMLName(attr.getNodeName(), fDocument.isXML11Version());</span>
<span class="line-added"> 918                         }</span>
<span class="line-added"> 919                         if (!wellformed) {</span>
<span class="line-added"> 920                             String msg = DOMMessageFormatter.formatMessage(</span>
<span class="line-added"> 921                                     DOMMessageFormatter.DOM_DOMAIN,</span>
<span class="line-added"> 922                                     &quot;wf-invalid-character-in-node-name&quot;,</span>
<span class="line-added"> 923                                     new Object[]{&quot;Attr&quot;, attr.getNodeName()});</span>
<span class="line-added"> 924                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,</span>
<span class="line-added"> 925                             &quot;wf-invalid-character-in-node-name&quot;);</span>
<span class="line-added"> 926                         }</span>
<span class="line-added"> 927                     }</span>
 928                 }
 929 
 930                 if (uri != null) {  // attribute has namespace !=null
 931                     prefix = attr.getPrefix();
 932                     prefix = (prefix == null ||
 933                               prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 934                     /*String localpart =*/ fSymbolTable.addSymbol( attr.getLocalName());
 935 
 936                     // ---------------------------------------
 937                     // skip namespace declarations
 938                     // ---------------------------------------
 939                     // REVISIT: can we assume that &quot;uri&quot; is from some symbol
 940                     // table, and compare by reference? -SG
 941                     if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 942                         continue;
 943                     }

















 944 
 945                     // ---------------------------------------
 946                     // remove default attributes
 947                     // ---------------------------------------
 948                     /*
 949                     if (removeDefault(attr, attributes)) {
 950                         continue;
 951                     }
 952                     */
 953                     // XML 1.0 Attribute value normalization
 954                     //value = normalizeAttributeValue(value, attr);
 955 
 956                     // reset id-attributes
 957                     ((AttrImpl)attr).setIdAttribute(false);
 958 

 959                     uri = fSymbolTable.addSymbol(uri);
 960 
 961                     // find if for this prefix a URI was already declared
 962                     String declaredURI =  fNamespaceContext.getURI(prefix);
 963 
 964                     if (prefix == XMLSymbols.EMPTY_STRING || declaredURI != uri) {
 965                         // attribute has no prefix (default namespace decl does not apply to attributes)
 966                         // OR
 967                         // attribute prefix is not declared
 968                         // OR
 969                         // conflict: attribute has a prefix that conficlicts with a binding
 970                         //           already active in scope
 971 

 972                         // Find if any prefix for attributes namespace URI is available
 973                         // in the scope
 974                         String declaredPrefix = fNamespaceContext.getPrefix(uri);
 975                         if (declaredPrefix !=null &amp;&amp; declaredPrefix !=XMLSymbols.EMPTY_STRING) {
 976 
 977                             // use the prefix that was found (declared previously for this URI
 978                             prefix = declaredPrefix;
 979                         } else {
 980                             if (prefix != XMLSymbols.EMPTY_STRING &amp;&amp; fLocalNSBinder.getURI(prefix) == null) {
 981                                 // the current prefix is not null and it has no in scope declaration
 982 
 983                                 // use this prefix
 984                             } else {
 985 
 986                                 // find a prefix following the pattern &quot;NS&quot; +index (starting at 1)
 987                                 // make sure this prefix is not declared in the current scope.
 988                                 int counter = 1;
 989                                 prefix = fSymbolTable.addSymbol(PREFIX +counter++);
 990                                 while (fLocalNSBinder.getURI(prefix)!=null) {
 991                                     prefix = fSymbolTable.addSymbol(PREFIX +counter++);
</pre>
<hr />
<pre>
1436                int next = i+1;
1437                if (next &lt; end &amp;&amp; value.charAt(next)==0x000A) i=next; // skip following xA
1438             }
1439             else {
1440                 fNormalizedValue.ch[fNormalizedValue.length++] = c;
1441             }
1442         }
1443         if (normalized){
1444            value = fNormalizedValue.toString();
1445            attr.setValue(value);
1446         }
1447         return value;
1448     }
1449 
1450     protected final class XMLAttributesProxy
1451     implements XMLAttributes {
1452         protected AttributeMap fAttributes;
1453         protected CoreDocumentImpl fDocument;
1454         protected ElementImpl fElement;
1455 
<span class="line-modified">1456         protected Vector&lt;String&gt; fDTDTypes = new Vector&lt;&gt;(5);</span>
<span class="line-modified">1457         protected Vector&lt;Augmentations&gt; fAugmentations = new Vector&lt;&gt;(5);</span>
1458 
1459         public void setAttributes(AttributeMap attributes, CoreDocumentImpl doc, ElementImpl elem) {
1460             fDocument = doc;
1461             fAttributes = attributes;
1462             fElement = elem;
1463             if (attributes != null) {
1464                 int length = attributes.getLength();
<span class="line-modified">1465                 fDTDTypes.setSize(length);</span>
1466                 fAugmentations.setSize(length);
1467                 // REVISIT: this implementation does not store any value in augmentations
1468                 //          and basically not keeping augs in parallel to attributes map
1469                 //          untill all attributes are added (default attributes)
1470                 for (int i = 0; i &lt; length; i++) {
1471                     fAugmentations.setElementAt(new AugmentationsImpl(), i);
1472                 }
<span class="line-modified">1473             }</span>
<span class="line-added">1474             else {</span>
<span class="line-added">1475                 fDTDTypes.setSize(0);</span>
1476                 fAugmentations.setSize(0);
1477             }
1478         }
1479 
1480 
<span class="line-modified">1481         /**</span>
1482          * This method adds default declarations
1483                  * @see com.sun.org.apache.xerces.internal.xni.XMLAttributes#addAttribute(QName, String, String)
<span class="line-modified">1484          */</span>
<span class="line-modified">1485         public int addAttribute(QName qname, String attrType, String attrValue) {</span>
<span class="line-modified">1486             int index = fElement.getXercesAttribute(qname.uri, qname.localpart);</span>
<span class="line-modified">1487             // add defaults to the tree</span>
<span class="line-modified">1488             if (index &lt; 0) {</span>
1489                 // the default attribute was removed by a user and needed to
1490                 // be added back
<span class="line-modified">1491                 AttrImpl attr = (AttrImpl)</span>
<span class="line-modified">1492                     ((CoreDocumentImpl) fElement.getOwnerDocument()).createAttributeNS(</span>
<span class="line-modified">1493                         qname.uri,</span>
<span class="line-modified">1494                         qname.rawname,</span>
<span class="line-modified">1495                         qname.localpart);</span>
1496                 // REVISIT: the following should also update ID table
1497                 attr.setNodeValue(attrValue);
1498                 index = fElement.setXercesAttributeNode(attr);
<span class="line-added">1499                 fDTDTypes.insertElementAt(attrType, index);</span>
1500                 fAugmentations.insertElementAt(new AugmentationsImpl(), index);
1501                 attr.setSpecified(false);
<span class="line-modified">1502             }</span>
<span class="line-modified">1503             else {</span>
1504                 // default attribute is in the tree
1505                 // we don&#39;t need to do anything since prefix was already fixed
1506                 // at the namespace fixup time and value must be same value, otherwise
1507                 // attribute will be treated as specified and we will never reach
1508                 // this method.
1509 
1510             }
1511             return index;
<span class="line-modified">1512         }</span>
1513 
1514 
1515         public void removeAllAttributes(){
1516             // REVISIT: implement
1517         }
1518 
1519 
1520         public void removeAttributeAt(int attrIndex){
1521             // REVISIT: implement
1522         }
1523 
1524 
1525         public int getLength(){
1526             return(fAttributes != null)?fAttributes.getLength():0;
1527         }
1528 
1529 
1530         public int getIndex(String qName){
1531             // REVISIT: implement
1532             return -1;
1533         }
1534 
<span class="line-modified">1535         public int getIndex(String uri, String localPart) {</span>
1536             // REVISIT: implement
1537             return -1;
1538         }
1539 
<span class="line-modified">1540         public void setName(int attrIndex, QName attrName) {</span>
1541             // REVISIT: implement
1542         }
1543 
<span class="line-modified">1544         public void getName(int attrIndex, QName attrName) {</span>
<span class="line-modified">1545             if (fAttributes != null) {</span>
1546                 updateQName((Node)fAttributes.getItem(attrIndex), attrName);
1547             }
1548         }
1549 
<span class="line-modified">1550         public String getPrefix(int index) {</span>
<span class="line-modified">1551             if (fAttributes != null) {</span>
<span class="line-added">1552                 Node node = (Node) fAttributes.getItem(index);</span>
<span class="line-added">1553                 String prefix = node.getPrefix();</span>
<span class="line-added">1554                 prefix = (prefix != null &amp;&amp; prefix.length() != 0) ? fSymbolTable.addSymbol(prefix) : null;</span>
<span class="line-added">1555                 return prefix;</span>
<span class="line-added">1556             }</span>
1557             return null;
1558         }
1559 
<span class="line-modified">1560         public String getURI(int index) {</span>
<span class="line-modified">1561             if (fAttributes != null) {</span>
<span class="line-modified">1562                 Node node = (Node) fAttributes.getItem(index);</span>
<span class="line-added">1563                 String namespace = node.getNamespaceURI();</span>
<span class="line-added">1564                 namespace = (namespace != null) ? fSymbolTable.addSymbol(namespace) : null;</span>
<span class="line-added">1565                 return namespace;</span>
<span class="line-added">1566             }</span>
1567             return null;
1568         }
1569 
1570 
<span class="line-modified">1571         public String getLocalName(int index) {</span>
<span class="line-modified">1572             if (fAttributes != null) {</span>
<span class="line-added">1573                 Node node = (Node) fAttributes.getItem(index);</span>
<span class="line-added">1574                 String localName = node.getLocalName();</span>
<span class="line-added">1575                 localName = (localName != null) ? fSymbolTable.addSymbol(localName) : null;</span>
<span class="line-added">1576                 return localName;</span>
<span class="line-added">1577             }</span>
1578             return null;
1579         }
1580 
<span class="line-modified">1581         public String getQName(int index) {</span>
<span class="line-modified">1582             if (fAttributes != null) {</span>
<span class="line-modified">1583                 Node node = (Node) fAttributes.getItem(index);</span>
<span class="line-added">1584                 String rawname = fSymbolTable.addSymbol(node.getNodeName());</span>
<span class="line-added">1585                 return rawname;</span>
<span class="line-added">1586             }</span>
1587             return null;
1588         }
1589 
1590          public QName getQualifiedName(int index){
1591             //return fAttributes.item(index).ge);
1592             return null;
1593         }
1594 
<span class="line-modified">1595         public void setType(int attrIndex, String attrType) {</span>
<span class="line-modified">1596             fDTDTypes.setElementAt(attrType, attrIndex);</span>
1597         }
1598 
<span class="line-modified">1599         public String getType(int index) {</span>
<span class="line-modified">1600             String type = fDTDTypes.elementAt(index);</span>
<span class="line-modified">1601             return (type != null) ? getReportableType(type) : &quot;CDATA&quot;;</span>
1602         }
1603 
<span class="line-modified">1604         public String getType(String qName) {</span>

1605             return &quot;CDATA&quot;;
1606         }
1607 
<span class="line-modified">1608         public String getType(String uri, String localName) {</span>

1609             return &quot;CDATA&quot;;
1610         }
1611 
<span class="line-added">1612         private String getReportableType(String type) {</span>
<span class="line-added">1613             if (type.charAt(0) == &#39;(&#39;) {</span>
<span class="line-added">1614                 return &quot;NMTOKEN&quot;;</span>
<span class="line-added">1615             }</span>
<span class="line-added">1616             return type;</span>
<span class="line-added">1617         }</span>
1618 
<span class="line-modified">1619         public void setValue(int attrIndex, String attrValue) {</span>
1620             // REVISIT: is this desired behaviour?
1621             // The values are updated in the case datatype-normalization is turned on
1622             // in this case we need to make sure that specified attributes stay specified
1623 
1624             if (fAttributes != null){
1625                 AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1626                 boolean specified = attr.getSpecified();
1627                 attr.setValue(attrValue);
1628                 attr.setSpecified(specified);
1629 
1630             }
1631         }
1632 
1633         public  void setValue(int attrIndex, String attrValue, XMLString value){
1634             setValue(attrIndex, value.toString());
1635         }
1636 
1637         public String getValue(int index){
1638             return (fAttributes !=null)?fAttributes.item(index).getNodeValue():&quot;&quot;;
1639 
1640         }
1641 

1642         public String getValue(String qName){
1643             // REVISIT: implement
1644             return null;
1645         }
1646 

1647         public String getValue(String uri, String localName){
1648             if (fAttributes != null) {
1649                 Node node =  fAttributes.getNamedItemNS(uri, localName);
1650                 return(node != null)? node.getNodeValue():null;
1651             }
1652             return null;
1653         }
1654 

1655         public void setNonNormalizedValue(int attrIndex, String attrValue){
1656             // REVISIT: implement
1657 
1658         }
1659 

1660         public String getNonNormalizedValue(int attrIndex){
1661             // REVISIT: implement
1662             return null;
1663         }
1664 

1665         public void setSpecified(int attrIndex, boolean specified){
1666             AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1667             attr.setSpecified(specified);
1668         }
1669 
1670         public boolean isSpecified(int attrIndex){
1671             return((Attr)fAttributes.getItem(attrIndex)).getSpecified();
1672         }
1673 
1674         public Augmentations getAugmentations (int attributeIndex){
1675             return fAugmentations.elementAt(attributeIndex);
1676         }
1677 
1678         public Augmentations getAugmentations (String uri, String localPart){
1679             // REVISIT: implement
1680             return null;
1681         }
1682 
1683         public Augmentations getAugmentations(String qName){
1684             // REVISIT: implement
</pre>
<hr />
<pre>
1796      * @param data   The data or null if none specified.
1797      * @param augs   Additional information that may include infoset augmentations
1798      *
1799      * @exception XNIException
1800      *                   Thrown by handler to signal an error.
1801      */
1802     public void processingInstruction(String target, XMLString data, Augmentations augs)
1803         throws XNIException{
1804     }
1805 
1806     /**
1807      * The start of an element.
1808      *
1809      * @param element    The name of the element.
1810      * @param attributes The element attributes.
1811      * @param augs       Additional information that may include infoset augmentations
1812      *
1813      * @exception XNIException
1814      *                   Thrown by handler to signal an error.
1815      */
<span class="line-modified">1816     public void startElement(QName element, XMLAttributes attributes, Augmentations augs)</span>
<span class="line-modified">1817         throws XNIException {</span>
<span class="line-modified">1818         Element currentElement = (Element) fCurrentNode;</span>
<span class="line-modified">1819         int attrCount = attributes.getLength();</span>
1820         if (DEBUG_EVENTS) {
1821             System.out.println(&quot;==&gt;startElement: &quot; +element+
<span class="line-modified">1822                     &quot; attrs.length=&quot;+attrCount);</span>
1823         }
1824 
<span class="line-modified">1825         for (int i = 0; i &lt; attrCount; i++) {</span>
<span class="line-modified">1826             attributes.getName(i, fAttrQName);</span>
<span class="line-modified">1827             Attr attr = null;</span>
1828 
<span class="line-modified">1829             attr = currentElement.getAttributeNodeNS(fAttrQName.uri, fAttrQName.localpart);</span>
<span class="line-added">1830             if (attr == null) {</span>
<span class="line-added">1831                 // Must be a non-namespace aware DOM Level 1 node.</span>
<span class="line-added">1832                 attr = currentElement.getAttributeNode(fAttrQName.rawname);</span>
<span class="line-added">1833             }</span>
1834             AttributePSVI attrPSVI =
<span class="line-modified">1835                 (AttributePSVI) attributes.getAugmentations(i).getItem(Constants.ATTRIBUTE_PSVI);</span>
1836 
<span class="line-modified">1837             if (attrPSVI != null) {</span>
1838                 //REVISIT: instead we should be using augmentations:
1839                 // to set/retrieve Id attributes
1840                 XSTypeDefinition decl = attrPSVI.getMemberTypeDefinition();
1841                 boolean id = false;
<span class="line-modified">1842                 if (decl != null) {</span>
1843                     id = ((XSSimpleType)decl).isIDType();
<span class="line-modified">1844                 }</span>
<span class="line-added">1845                 else {</span>
1846                     decl = attrPSVI.getTypeDefinition();
<span class="line-modified">1847                     if (decl != null) {</span>
<span class="line-modified">1848                         id = ((XSSimpleType)decl).isIDType();</span>
1849                     }
1850                 }
<span class="line-modified">1851                 if (id) {</span>
1852                     ((ElementImpl)currentElement).setIdAttributeNode(attr, true);
1853                 }
1854 
<span class="line-modified">1855                 if (fPSVI) {</span>
<span class="line-modified">1856                     ((PSVIAttrNSImpl) attr).setPSVI(attrPSVI);</span>
<span class="line-modified">1857                 }</span>
<span class="line-modified">1858 </span>
<span class="line-modified">1859                 // Updating the TypeInfo for this attribute.</span>
<span class="line-modified">1860                 ((AttrImpl) attr).setType(decl);</span>
<span class="line-modified">1861 </span>
<span class="line-modified">1862                 if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {</span>
<span class="line-modified">1863                     // datatype-normalization</span>
<span class="line-modified">1864                     // NOTE: The specified value MUST be set after we set</span>
<span class="line-modified">1865                     //       the node value because that turns the &quot;specified&quot;</span>
<span class="line-modified">1866                     //       flag to &quot;true&quot; which may overwrite a &quot;false&quot;</span>
<span class="line-modified">1867                     //       value from the attribute list.</span>
<span class="line-modified">1868                     final String normalizedValue = attrPSVI.getSchemaValue().getNormalizedValue();</span>
<span class="line-modified">1869                     if (normalizedValue != null) {</span>
<span class="line-added">1870                         boolean specified = attr.getSpecified();</span>
<span class="line-added">1871                         attr.setValue(normalizedValue);</span>
<span class="line-added">1872                         if (!specified) {</span>
<span class="line-added">1873                             ((AttrImpl) attr).setSpecified(specified);</span>
1874                         }
<span class="line-added">1875                     }</span>
<span class="line-added">1876                 }</span>
<span class="line-added">1877             }</span>
<span class="line-added">1878             else { // DTD</span>
<span class="line-added">1879                 String type = null;</span>
<span class="line-added">1880                 boolean isDeclared = Boolean.TRUE.equals(attributes.getAugmentations(i).getItem (Constants.ATTRIBUTE_DECLARED));</span>
<span class="line-added">1881                 // For DOM Level 3 TypeInfo, the type name must</span>
<span class="line-added">1882                 // be null if this attribute has not been declared</span>
<span class="line-added">1883                 // in the DTD.</span>
<span class="line-added">1884                 if (isDeclared) {</span>
<span class="line-added">1885                     type = attributes.getType(i);</span>
<span class="line-added">1886                     if (&quot;ID&quot;.equals (type)) {</span>
<span class="line-added">1887                         ((ElementImpl) currentElement).setIdAttributeNode(attr, true);</span>
<span class="line-added">1888                     }</span>
1889                 }
<span class="line-added">1890                 // Updating the TypeInfo for this attribute.</span>
<span class="line-added">1891                 ((AttrImpl) attr).setType(type);</span>
<span class="line-added">1892             }</span>
1893         }
<span class="line-added">1894     }</span>
1895 
1896 
1897     /**
1898      * An empty element.
1899      *
1900      * @param element    The name of the element.
1901      * @param attributes The element attributes.
1902      * @param augs       Additional information that may include infoset augmentations
1903      *
1904      * @exception XNIException
1905      *                   Thrown by handler to signal an error.
1906      */
1907         public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs)
1908                 throws XNIException {
1909         if (DEBUG_EVENTS) {
1910             System.out.println(&quot;==&gt;emptyElement: &quot; +element);
1911         }
1912 
1913                 startElement(element, attributes, augs);
1914         endElement(element, augs);
</pre>
<hr />
<pre>
1983      *                   Thrown by handler to signal an error.
1984      */
1985     public void characters(XMLString text, Augmentations augs) throws XNIException{
1986     }
1987 
1988     /**
1989      * Ignorable whitespace. For this method to be called, the document
1990      * source must have some way of determining that the text containing
1991      * only whitespace characters should be considered ignorable. For
1992      * example, the validator can determine if a length of whitespace
1993      * characters in the document are ignorable based on the element
1994      * content model.
1995      *
1996      * @param text   The ignorable whitespace.
1997      * @param augs   Additional information that may include infoset augmentations
1998      *
1999      * @exception XNIException
2000      *                   Thrown by handler to signal an error.
2001      */
2002     public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException{
<span class="line-modified">2003         fAllWhitespace = true;</span>
2004     }
2005 
2006     /**
2007      * The end of an element.
2008      *
2009      * @param element The name of the element.
2010      * @param augs    Additional information that may include infoset augmentations
2011      *
2012      * @exception XNIException
2013      *                   Thrown by handler to signal an error.
2014      */
<span class="line-modified">2015     public void endElement(QName element, Augmentations augs) throws XNIException {</span>
<span class="line-modified">2016         if (DEBUG_EVENTS) {</span>
<span class="line-modified">2017             System.out.println(&quot;==&gt;endElement: &quot; + element);</span>
<span class="line-modified">2018         }</span>
2019 
<span class="line-modified">2020         if (augs != null) {</span>
<span class="line-modified">2021             ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);</span>
<span class="line-modified">2022             if (elementPSVI != null) {</span>
<span class="line-modified">2023                 ElementImpl elementNode = (ElementImpl) fCurrentNode;</span>
<span class="line-modified">2024                 if (fPSVI) {</span>
<span class="line-modified">2025                     ((PSVIElementNSImpl) fCurrentNode).setPSVI(elementPSVI);</span>
<span class="line-modified">2026                 }</span>
<span class="line-modified">2027                 // Updating the TypeInfo for this element.</span>
<span class="line-modified">2028                 if (elementNode instanceof ElementNSImpl) {</span>
<span class="line-modified">2029                     XSTypeDefinition type = elementPSVI.getMemberTypeDefinition();</span>
<span class="line-added">2030                     if (type == null) {</span>
<span class="line-added">2031                         type = elementPSVI.getTypeDefinition();</span>
<span class="line-added">2032                     }</span>
<span class="line-added">2033                     ((ElementNSImpl) elementNode).setType(type);</span>
<span class="line-added">2034                 }</span>
<span class="line-added">2035                 // include element default content (if one is available)</span>
<span class="line-added">2036                 String normalizedValue = elementPSVI.getSchemaValue().getNormalizedValue();</span>
<span class="line-added">2037                 if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {</span>
2038                     if (normalizedValue !=null)
<span class="line-modified">2039                         elementNode.setTextContent(normalizedValue);</span>
<span class="line-modified">2040                 }</span>
<span class="line-modified">2041                 else {</span>
<span class="line-modified">2042                     // NOTE: this is a hack: it is possible that DOM had an empty element</span>
<span class="line-modified">2043                     // and validator sent default value using characters(), which we don&#39;t</span>
<span class="line-modified">2044                     // implement. Thus, here we attempt to add the default value.</span>
<span class="line-modified">2045                     String text = elementNode.getTextContent();</span>
<span class="line-modified">2046                     if (text.length() == 0) {</span>
<span class="line-modified">2047                         // default content could be provided</span>
2048                         if (normalizedValue !=null)
2049                             elementNode.setTextContent(normalizedValue);
<span class="line-modified">2050                     }</span>

2051                 }
<span class="line-added">2052                 return;</span>
<span class="line-added">2053             }</span>
2054         }
<span class="line-added">2055         // DTD; elements have no type.</span>
<span class="line-added">2056         if (fCurrentNode instanceof ElementNSImpl) {</span>
<span class="line-added">2057             ((ElementNSImpl) fCurrentNode).setType(null);</span>
2058         }
<span class="line-added">2059     }</span>
2060 
2061 
2062     /**
2063      * The start of a CDATA section.
2064      *
2065      * @param augs   Additional information that may include infoset augmentations
2066      *
2067      * @exception XNIException
2068      *                   Thrown by handler to signal an error.
2069      */
2070     public void startCDATA(Augmentations augs) throws XNIException{
2071     }
2072 
2073     /**
2074      * The end of a CDATA section.
2075      *
2076      * @param augs   Additional information that may include infoset augmentations
2077      *
2078      * @exception XNIException
2079      *                   Thrown by handler to signal an error.
</pre>
</td>
</tr>
</table>
<center><a href="DOMConfigurationImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="DeferredDocumentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantPool.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantPool.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantPool.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantPool.java
@@ -33,29 +33,26 @@
  * specification that skips an entry after an 8-byte constant (double,
  * long) entry.  Those interested in generating constant pools
  * programatically should see <a href="../generic/ConstantPoolGen.html">
  * ConstantPoolGen</a>.
 
- * @version $Id: ConstantPool.java 1749603 2016-06-21 20:50:19Z ggregory $
  * @see     Constant
  * @see     com.sun.org.apache.bcel.internal.generic.ConstantPoolGen
  */
 public class ConstantPool implements Cloneable, Node {
 
     private Constant[] constant_pool;
 
-
     /**
      * @param constant_pool Array of constants
      */
     public ConstantPool(final Constant[] constant_pool) {
         this.constant_pool = constant_pool;
     }
 
-
     /**
-     * Read constants from given input stream.
+     * Reads constants from given input stream.
      *
      * @param input Input stream
      * @throws IOException
      * @throws ClassFormatException
      */
@@ -80,11 +77,10 @@
                 i++;
             }
         }
     }
 
-
     /**
      * Called by objects that are traversing the nodes of the tree implicitely
      * defined by the contents of a Java class. I.e., the hierarchy of methods,
      * fields, attributes, etc. spawns a tree of objects.
      *
@@ -93,13 +89,12 @@
     @Override
     public void accept( final Visitor v ) {
         v.visitConstantPool(this);
     }
 
-
     /**
-     * Resolve constant to a string representation.
+     * Resolves constant to a string representation.
      *
      * @param  c Constant to be printed
      * @return String representation
      */
     public String constantToString( Constant c ) throws ClassFormatException {
@@ -133,11 +128,11 @@
                 str = String.valueOf(((ConstantInteger) c).getBytes());
                 break;
             case Const.CONSTANT_NameAndType:
                 str = constantToString(((ConstantNameAndType) c).getNameIndex(),
                         Const.CONSTANT_Utf8)
-                        + ":" + constantToString(((ConstantNameAndType) c).getSignatureIndex(),
+                        + " " + constantToString(((ConstantNameAndType) c).getSignatureIndex(),
                         Const.CONSTANT_Utf8);
                 break;
             case Const.CONSTANT_InterfaceMethodref:
             case Const.CONSTANT_Methodref:
             case Const.CONSTANT_Fieldref:
@@ -161,17 +156,26 @@
                 final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;
                 str = cid.getBootstrapMethodAttrIndex()
                         + ":" + constantToString(cid.getNameAndTypeIndex(),
                         Const.CONSTANT_NameAndType);
                 break;
+            case Const.CONSTANT_Module:
+                i = ((ConstantModule) c).getNameIndex();
+                c = getConstant(i, Const.CONSTANT_Utf8);
+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
+                break;
+            case Const.CONSTANT_Package:
+                i = ((ConstantPackage) c).getNameIndex();
+                c = getConstant(i, Const.CONSTANT_Utf8);
+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);
+                break;
             default: // Never reached
                 throw new RuntimeException("Unknown constant type " + tag);
         }
         return str;
     }
 
-
     private static String escape( final String str ) {
         final int len = str.length();
         final StringBuilder buf = new StringBuilder(len + 5);
         final char[] ch = str.toCharArray();
         for (int i = 0; i < len; i++) {
@@ -196,13 +200,12 @@
             }
         }
         return buf.toString();
     }
 
-
     /**
-     * Retrieve constant at `index' from constant pool and resolve it to
+     * Retrieves constant at `index' from constant pool and resolve it to
      * a string representation.
      *
      * @param  index of constant in constant pool
      * @param  tag expected type
      * @return String representation
@@ -210,11 +213,10 @@
     public String constantToString( final int index, final byte tag ) throws ClassFormatException {
         final Constant c = getConstant(index, tag);
         return constantToString(c);
     }
 
-
     /**
      * Dump constant pool to file stream in binary format.
      *
      * @param file Output file stream
      * @throws IOException
@@ -226,13 +228,12 @@
                 constant_pool[i].dump(file);
             }
         }
     }
 
-
     /**
-     * Get constant from constant pool.
+     * Gets constant from constant pool.
      *
      * @param  index Index in constant pool
      * @return Constant value
      * @see    Constant
      */
@@ -242,13 +243,12 @@
                     + ". Constant pool size is: " + constant_pool.length);
         }
         return constant_pool[index];
     }
 
-
     /**
-     * Get constant from constant pool and check whether it has the
+     * Gets constant from constant pool and check whether it has the
      * expected type.
      *
      * @param  index Index in constant pool
      * @param  tag Tag of expected constant, i.e., its type
      * @return Constant value
@@ -266,22 +266,20 @@
                     + "' at index " + index + " and got " + c);
         }
         return c;
     }
 
-
     /**
      * @return Array of constants.
      * @see    Constant
      */
     public Constant[] getConstantPool() {
         return constant_pool;
     }
 
-
     /**
-     * Get string from constant pool and bypass the indirection of
+     * Gets string from constant pool and bypass the indirection of
      * `ConstantClass' and `ConstantString' objects. I.e. these classes have
      * an index field that points to another entry of the constant pool of
      * type `ConstantUtf8' which contains the real data.
      *
      * @param  index Index in constant pool
@@ -293,11 +291,11 @@
      */
     public String getConstantString( final int index, final byte tag ) throws ClassFormatException {
         Constant c;
         int i;
         c = getConstant(index, tag);
-        /* This switch() is not that elegant, since the two classes have the
+        /* This switch() is not that elegant, since the four classes have the
          * same contents, they just differ in the name of the index
          * field variable.
          * But we want to stick to the JVM naming conventions closely though
          * we could have solved these more elegantly by using the same
          * variable name or by subclassing.
@@ -307,10 +305,16 @@
                 i = ((ConstantClass) c).getNameIndex();
                 break;
             case Const.CONSTANT_String:
                 i = ((ConstantString) c).getStringIndex();
                 break;
+            case Const.CONSTANT_Module:
+                i = ((ConstantModule) c).getNameIndex();
+                break;
+            case Const.CONSTANT_Package:
+                i = ((ConstantPackage) c).getNameIndex();
+                break;
             default:
                 throw new RuntimeException("getConstantString called with illegal tag " + tag);
         }
         // Finally get the string from the constant pool
         c = getConstant(i, Const.CONSTANT_Utf8);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ClassGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CPInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ClassGenException.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ClassGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * reserved comment block</span>
<span class="line-removed">  3  * DO NOT REMOVE OR ALTER!</span>
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import java.util.ArrayList;
 24 import java.util.List;

 25 
 26 import com.sun.org.apache.bcel.internal.Const;
 27 import com.sun.org.apache.bcel.internal.classfile.AccessFlags;
 28 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 29 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 30 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 32 import com.sun.org.apache.bcel.internal.classfile.Field;
 33 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 34 import com.sun.org.apache.bcel.internal.classfile.Method;
 35 import com.sun.org.apache.bcel.internal.classfile.RuntimeInvisibleAnnotations;
 36 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleAnnotations;
 37 import com.sun.org.apache.bcel.internal.classfile.SourceFile;
 38 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 39 
 40 /**
 41  * Template class for building up a java class. May be initialized with an
 42  * existing java class (file).
 43  *
 44  * @see JavaClass
<span class="line-modified"> 45  * @version $Id: ClassGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 46  */
 47 public class ClassGen extends AccessFlags implements Cloneable {
 48 
 49     /* Corresponds to the fields found in a JavaClass object.
 50      */
 51     private String class_name;
 52     private String super_class_name;
 53     private final String file_name;
 54     private int class_name_index = -1;
 55     private int superclass_name_index = -1;
 56     private int major = Const.MAJOR;
 57     private int minor = Const.MINOR;
 58     private ConstantPoolGen cp; // Template for building up constant pool
 59     // ArrayLists instead of arrays to gather fields, methods, etc.
 60     private final List&lt;Field&gt; field_vec = new ArrayList&lt;&gt;();
 61     private final List&lt;Method&gt; method_vec = new ArrayList&lt;&gt;();
 62     private final List&lt;Attribute&gt; attribute_vec = new ArrayList&lt;&gt;();
 63     private final List&lt;String&gt; interface_vec = new ArrayList&lt;&gt;();
 64     private final List&lt;AnnotationEntryGen&gt; annotation_vec = new ArrayList&lt;&gt;();
 65 
 66     private static BCELComparator _cmp = new BCELComparator() {
 67 
 68         @Override
<span class="line-modified"> 69         public boolean equals(final Object o1, final Object o2) {</span>
 70             final ClassGen THIS = (ClassGen) o1;
 71             final ClassGen THAT = (ClassGen) o2;
<span class="line-modified"> 72             return THIS.getClassName().equals(THAT.getClassName());</span>
 73         }
 74 

 75         @Override
<span class="line-modified"> 76         public int hashCode(final Object o) {</span>
 77             final ClassGen THIS = (ClassGen) o;
 78             return THIS.getClassName().hashCode();
 79         }
 80     };
 81 
<span class="line-modified"> 82     /**</span>
<span class="line-modified"> 83      * Convenience constructor to set up some important values initially.</span>
 84      *
 85      * @param class_name fully qualified class name
 86      * @param super_class_name fully qualified superclass name
 87      * @param file_name source file name
 88      * @param access_flags access qualifiers
 89      * @param interfaces implemented interfaces
 90      * @param cp constant pool to use
 91      */
 92     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
 93             final String[] interfaces, final ConstantPoolGen cp) {
 94         super(access_flags);
 95         this.class_name = class_name;
 96         this.super_class_name = super_class_name;
 97         this.file_name = file_name;
 98         this.cp = cp;
 99         // Put everything needed by default into the constant pool and the vectors
100         if (file_name != null) {
101             addAttribute(new SourceFile(cp.addUtf8(&quot;SourceFile&quot;), 2, cp.addUtf8(file_name), cp
102                     .getConstantPool()));
103         }
104         class_name_index = cp.addClass(class_name);
105         superclass_name_index = cp.addClass(super_class_name);
106         if (interfaces != null) {
107             for (final String interface1 : interfaces) {
108                 addInterface(interface1);
109             }
110         }
111     }
112 
<span class="line-modified">113     /**</span>
<span class="line-modified">114      * Convenience constructor to set up some important values initially.</span>
115      *
116      * @param class_name fully qualified class name
117      * @param super_class_name fully qualified superclass name
118      * @param file_name source file name
119      * @param access_flags access qualifiers
120      * @param interfaces implemented interfaces
121      */
122     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
123             final String[] interfaces) {
124         this(class_name, super_class_name, file_name, access_flags, interfaces,
125                 new ConstantPoolGen());
126     }
127 

128     /**
129      * Initialize with existing class.
<span class="line-removed">130      *</span>
131      * @param clazz JavaClass object (e.g. read from file)
132      */
133     public ClassGen(final JavaClass clazz) {
134         super(clazz.getAccessFlags());
135         class_name_index = clazz.getClassNameIndex();
136         superclass_name_index = clazz.getSuperclassNameIndex();
137         class_name = clazz.getClassName();
138         super_class_name = clazz.getSuperclassName();
139         file_name = clazz.getSourceFileName();
140         cp = new ConstantPoolGen(clazz.getConstantPool());
141         major = clazz.getMajor();
142         minor = clazz.getMinor();
143         final Attribute[] attributes = clazz.getAttributes();
144         // J5TODO: Could make unpacking lazy, done on first reference
145         final AnnotationEntryGen[] annotations = unpackAnnotations(attributes);
146         final Method[] methods = clazz.getMethods();
147         final Field[] fields = clazz.getFields();
148         final String[] interfaces = clazz.getInterfaceNames();
149         for (final String interface1 : interfaces) {
150             addInterface(interface1);
151         }
152         for (final Attribute attribute : attributes) {
153             if (!(attribute instanceof Annotations)) {
154                 addAttribute(attribute);
155             }
156         }
157         for (final AnnotationEntryGen annotation : annotations) {
158             addAnnotationEntry(annotation);
159         }
160         for (final Method method : methods) {
161             addMethod(method);
162         }
163         for (final Field field : fields) {
164             addField(field);
165         }
166     }
167 
168     /**
169      * Look for attributes representing annotations and unpack them.
170      */
<span class="line-modified">171     private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {</span>

172         final List&lt;AnnotationEntryGen&gt; annotationGenObjs = new ArrayList&lt;&gt;();
173         for (final Attribute attr : attrs) {
<span class="line-modified">174             if (attr instanceof RuntimeVisibleAnnotations) {</span>

175                 final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;
176                 final AnnotationEntry[] annos = rva.getAnnotationEntries();
177                 for (final AnnotationEntry a : annos) {
178                     annotationGenObjs.add(new AnnotationEntryGen(a,
179                             getConstantPool(), false));
180                 }
<span class="line-removed">181             } else if (attr instanceof RuntimeInvisibleAnnotations) {</span>
<span class="line-removed">182                 final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;</span>
<span class="line-removed">183                 final AnnotationEntry[] annos = ria.getAnnotationEntries();</span>
<span class="line-removed">184                 for (final AnnotationEntry a : annos) {</span>
<span class="line-removed">185                     annotationGenObjs.add(new AnnotationEntryGen(a,</span>
<span class="line-removed">186                             getConstantPool(), false));</span>
<span class="line-removed">187                 }</span>
188             }










189         }
190         return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);
191     }
192 

193     /**
194      * @return the (finally) built up Java class object.
195      */
196     public JavaClass getJavaClass() {
197         final int[] interfaces = getInterfaces();
198         final Field[] fields = getFields();
199         final Method[] methods = getMethods();
<span class="line-modified">200         Attribute[] attributes;</span>
201         if (annotation_vec.isEmpty()) {
202             attributes = getAttributes();
203         } else {
204             // TODO: Sometime later, trash any attributes called &#39;RuntimeVisibleAnnotations&#39; or &#39;RuntimeInvisibleAnnotations&#39;
<span class="line-modified">205             final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());</span>
<span class="line-modified">206             attributes = new Attribute[attribute_vec.size() + annAttributes.length];</span>
207             attribute_vec.toArray(attributes);
<span class="line-modified">208             System.arraycopy(annAttributes, 0, attributes, attribute_vec.size(), annAttributes.length);</span>
209         }
210         // Must be last since the above calls may still add something to it
211         final ConstantPool _cp = this.cp.getFinalConstantPool();
212         return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
213                 super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);
214     }
215 

216     /**
217      * Add an interface to this class, i.e., this class has to implement it.
<span class="line-removed">218      *</span>
219      * @param name interface to implement (fully qualified class name)
220      */
<span class="line-modified">221     public final void addInterface(final String name) {</span>
222         interface_vec.add(name);
223     }
224 

225     /**
226      * Remove an interface from this class.
<span class="line-removed">227      *</span>
228      * @param name interface to remove (fully qualified name)
229      */
<span class="line-modified">230     public void removeInterface(final String name) {</span>
231         interface_vec.remove(name);
232     }
233 

234     /**
235      * @return major version number of class file
236      */
237     public int getMajor() {
238         return major;
239     }
240 
<span class="line-modified">241     /**</span>
<span class="line-modified">242      * Set major version number of class file, default value is 45 (JDK 1.1)</span>
<span class="line-removed">243      *</span>
244      * @param major major version number
245      */
<span class="line-modified">246     public void setMajor(final int major) { // TODO could be package-protected - only called by test code</span>
247         this.major = major;
248     }
249 
<span class="line-modified">250     /**</span>
<span class="line-modified">251      * Set minor version number of class file, default value is 3 (JDK 1.1)</span>
<span class="line-removed">252      *</span>
253      * @param minor minor version number
254      */
<span class="line-modified">255     public void setMinor(final int minor) {  // TODO could be package-protected - only called by test code</span>
256         this.minor = minor;
257     }
258 
259     /**
260      * @return minor version number of class file
261      */
262     public int getMinor() {
263         return minor;
264     }
265 

266     /**
267      * Add an attribute to this class.
<span class="line-removed">268      *</span>
269      * @param a attribute to add
270      */
<span class="line-modified">271     public final void addAttribute(final Attribute a) {</span>
272         attribute_vec.add(a);
273     }
274 
<span class="line-modified">275     public final void addAnnotationEntry(final AnnotationEntryGen a) {</span>
276         annotation_vec.add(a);
277     }
278 

279     /**
280      * Add a method to this class.
<span class="line-removed">281      *</span>
282      * @param m method to add
283      */
<span class="line-modified">284     public final void addMethod(final Method m) {</span>
285         method_vec.add(m);
286     }
287 

288     /**
289      * Convenience method.
290      *
<span class="line-modified">291      * Add an empty constructor to this class that does nothing but calling</span>
<span class="line-removed">292      * super().</span>
<span class="line-removed">293      *</span>
294      * @param access_flags rights for constructor
295      */
<span class="line-modified">296     public void addEmptyConstructor(final int access_flags) {</span>
297         final InstructionList il = new InstructionList();
298         il.append(InstructionConst.THIS); // Push `this&#39;
299         il.append(new INVOKESPECIAL(cp.addMethodref(super_class_name, &quot;&lt;init&gt;&quot;, &quot;()V&quot;)));
300         il.append(InstructionConst.RETURN);
301         final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, &quot;&lt;init&gt;&quot;,
302                 class_name, il, cp);
303         mg.setMaxStack(1);
304         addMethod(mg.getMethod());
305     }
306 

307     /**
308      * Add a field to this class.
<span class="line-removed">309      *</span>
310      * @param f field to add
311      */
<span class="line-modified">312     public final void addField(final Field f) {</span>
313         field_vec.add(f);
314     }
315 
<span class="line-modified">316     public boolean containsField(final Field f) {</span>

317         return field_vec.contains(f);
318     }
319 
<span class="line-modified">320     /**</span>
<span class="line-modified">321      * @return field object with given name, or null</span>
322      */
<span class="line-modified">323     public Field containsField(final String name) {</span>
324         for (final Field f : field_vec) {
325             if (f.getName().equals(name)) {
326                 return f;
327             }
328         }
329         return null;
330     }
331 
<span class="line-modified">332     /**</span>
<span class="line-modified">333      * @return method object with given name and signature, or null</span>
334      */
<span class="line-modified">335     public Method containsMethod(final String name, final String signature) {</span>
336         for (final Method m : method_vec) {
337             if (m.getName().equals(name) &amp;&amp; m.getSignature().equals(signature)) {
338                 return m;
339             }
340         }
341         return null;
342     }
343 

344     /**
345      * Remove an attribute from this class.
<span class="line-removed">346      *</span>
347      * @param a attribute to remove
348      */
<span class="line-modified">349     public void removeAttribute(final Attribute a) {</span>
350         attribute_vec.remove(a);
351     }
352 

353     /**
354      * Remove a method from this class.
<span class="line-removed">355      *</span>
356      * @param m method to remove
357      */
<span class="line-modified">358     public void removeMethod(final Method m) {</span>
359         method_vec.remove(m);
360     }
361 
<span class="line-modified">362     /**</span>
<span class="line-modified">363      * Replace given method with new one. If the old one does not exist add the</span>
<span class="line-modified">364      * new_ method to the class anyway.</span>
365      */
<span class="line-modified">366     public void replaceMethod(final Method old, final Method new_) {</span>
367         if (new_ == null) {
368             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
369         }
370         final int i = method_vec.indexOf(old);
371         if (i &lt; 0) {
372             method_vec.add(new_);
373         } else {
374             method_vec.set(i, new_);
375         }
376     }
377 
<span class="line-modified">378     /**</span>
<span class="line-modified">379      * Replace given field with new one. If the old one does not exist add the</span>
<span class="line-modified">380      * new_ field to the class anyway.</span>
381      */
<span class="line-modified">382     public void replaceField(final Field old, final Field new_) {</span>
383         if (new_ == null) {
384             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
385         }
386         final int i = field_vec.indexOf(old);
387         if (i &lt; 0) {
388             field_vec.add(new_);
389         } else {
390             field_vec.set(i, new_);
391         }
392     }
393 

394     /**
395      * Remove a field to this class.
<span class="line-removed">396      *</span>
397      * @param f field to remove
398      */
<span class="line-modified">399     public void removeField(final Field f) {</span>
400         field_vec.remove(f);
401     }
402 

403     public String getClassName() {
404         return class_name;
405     }
406 

407     public String getSuperclassName() {
408         return super_class_name;
409     }
410 

411     public String getFileName() {
412         return file_name;
413     }
414 
<span class="line-modified">415     public void setClassName(final String name) {</span>

416         class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
417         class_name_index = cp.addClass(name);
418     }
419 
<span class="line-modified">420     public void setSuperclassName(final String name) {</span>

421         super_class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
422         superclass_name_index = cp.addClass(name);
423     }
424 

425     public Method[] getMethods() {
426         return method_vec.toArray(new Method[method_vec.size()]);
427     }
428 
<span class="line-modified">429     public void setMethods(final Method[] methods) {</span>

430         method_vec.clear();
431         for (final Method method : methods) {
432             addMethod(method);
433         }
434     }
435 
<span class="line-modified">436     public void setMethodAt(final Method method, final int pos) {</span>

437         method_vec.set(pos, method);
438     }
439 
<span class="line-modified">440     public Method getMethodAt(final int pos) {</span>

441         return method_vec.get(pos);
442     }
443 

444     public String[] getInterfaceNames() {
445         final int size = interface_vec.size();
446         final String[] interfaces = new String[size];
447         interface_vec.toArray(interfaces);
448         return interfaces;
449     }
450 

451     public int[] getInterfaces() {
452         final int size = interface_vec.size();
453         final int[] interfaces = new int[size];
454         for (int i = 0; i &lt; size; i++) {
455             interfaces[i] = cp.addClass(interface_vec.get(i));
456         }
457         return interfaces;
458     }
459 

460     public Field[] getFields() {
461         return field_vec.toArray(new Field[field_vec.size()]);
462     }
463 

464     public Attribute[] getAttributes() {
465         return attribute_vec.toArray(new Attribute[attribute_vec.size()]);
466     }
467 
468     //  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?
469     public AnnotationEntryGen[] getAnnotationEntries() {
470         return annotation_vec.toArray(new AnnotationEntryGen[annotation_vec.size()]);
471     }
472 

473     public ConstantPoolGen getConstantPool() {
474         return cp;
475     }
476 
<span class="line-modified">477     public void setConstantPool(final ConstantPoolGen constant_pool) {</span>

478         cp = constant_pool;
479     }
480 
<span class="line-modified">481     public void setClassNameIndex(final int class_name_index) {</span>

482         this.class_name_index = class_name_index;
483         class_name = cp.getConstantPool().getConstantString(class_name_index,
484                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
485     }
486 
<span class="line-modified">487     public void setSuperclassNameIndex(final int superclass_name_index) {</span>

488         this.superclass_name_index = superclass_name_index;
489         super_class_name = cp.getConstantPool().getConstantString(superclass_name_index,
490                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
491     }
492 

493     public int getSuperclassNameIndex() {
494         return superclass_name_index;
495     }
496 

497     public int getClassNameIndex() {
498         return class_name_index;
499     }
500 
501     private List&lt;ClassObserver&gt; observers;
502 
<span class="line-modified">503     /**</span>
<span class="line-modified">504      * Add observer for this object.</span>
505      */
<span class="line-modified">506     public void addObserver(final ClassObserver o) {</span>
507         if (observers == null) {
508             observers = new ArrayList&lt;&gt;();
509         }
510         observers.add(o);
511     }
512 
<span class="line-modified">513     /**</span>
<span class="line-modified">514      * Remove observer for this object.</span>
515      */
<span class="line-modified">516     public void removeObserver(final ClassObserver o) {</span>
517         if (observers != null) {
518             observers.remove(o);
519         }
520     }
521 
<span class="line-modified">522     /**</span>
<span class="line-modified">523      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">524      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">525      * user after he has finished editing the object.</span>
526      */
527     public void update() {
528         if (observers != null) {
529             for (final ClassObserver observer : observers) {
530                 observer.notify(this);
531             }
532         }
533     }
534 

535     @Override
536     public Object clone() {
537         try {
538             return super.clone();
539         } catch (final CloneNotSupportedException e) {
540             throw new Error(&quot;Clone Not Supported&quot;); // never happens
541         }
542     }
543 

544     /**
545      * @return Comparison strategy object
546      */
547     public static BCELComparator getComparator() {
548         return _cmp;
549     }
550 

551     /**
552      * @param comparator Comparison strategy object
553      */
<span class="line-modified">554     public static void setComparator(final BCELComparator comparator) {</span>
555         _cmp = comparator;
556     }
557 

558     /**
<span class="line-modified">559      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">560      * ClassGen objects are said to be equal when their class names are equal.</span>

561      *
562      * @see java.lang.Object#equals(java.lang.Object)
563      */
564     @Override
<span class="line-modified">565     public boolean equals(final Object obj) {</span>
566         return _cmp.equals(this, obj);
567     }
568 

569     /**
<span class="line-modified">570      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">571      * return the hashcode of the class name.</span>
572      *
573      * @see java.lang.Object#hashCode()
574      */
575     @Override
576     public int hashCode() {
577         return _cmp.hashCode(this);
578     }
579 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>

  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
<span class="line-added"> 24 import java.util.Objects;</span>
 25 
 26 import com.sun.org.apache.bcel.internal.Const;
 27 import com.sun.org.apache.bcel.internal.classfile.AccessFlags;
 28 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 29 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 30 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 32 import com.sun.org.apache.bcel.internal.classfile.Field;
 33 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 34 import com.sun.org.apache.bcel.internal.classfile.Method;
 35 import com.sun.org.apache.bcel.internal.classfile.RuntimeInvisibleAnnotations;
 36 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleAnnotations;
 37 import com.sun.org.apache.bcel.internal.classfile.SourceFile;
 38 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 39 
 40 /**
 41  * Template class for building up a java class. May be initialized with an
 42  * existing java class (file).
 43  *
 44  * @see JavaClass
<span class="line-modified"> 45  * @LastModified: Jan 2020</span>
 46  */
 47 public class ClassGen extends AccessFlags implements Cloneable {
 48 
 49     /* Corresponds to the fields found in a JavaClass object.
 50      */
 51     private String class_name;
 52     private String super_class_name;
 53     private final String file_name;
 54     private int class_name_index = -1;
 55     private int superclass_name_index = -1;
 56     private int major = Const.MAJOR;
 57     private int minor = Const.MINOR;
 58     private ConstantPoolGen cp; // Template for building up constant pool
 59     // ArrayLists instead of arrays to gather fields, methods, etc.
 60     private final List&lt;Field&gt; field_vec = new ArrayList&lt;&gt;();
 61     private final List&lt;Method&gt; method_vec = new ArrayList&lt;&gt;();
 62     private final List&lt;Attribute&gt; attribute_vec = new ArrayList&lt;&gt;();
 63     private final List&lt;String&gt; interface_vec = new ArrayList&lt;&gt;();
 64     private final List&lt;AnnotationEntryGen&gt; annotation_vec = new ArrayList&lt;&gt;();
 65 
 66     private static BCELComparator _cmp = new BCELComparator() {
 67 
 68         @Override
<span class="line-modified"> 69         public boolean equals( final Object o1, final Object o2 ) {</span>
 70             final ClassGen THIS = (ClassGen) o1;
 71             final ClassGen THAT = (ClassGen) o2;
<span class="line-modified"> 72             return Objects.equals(THIS.getClassName(), THAT.getClassName());</span>
 73         }
 74 
<span class="line-added"> 75 </span>
 76         @Override
<span class="line-modified"> 77         public int hashCode( final Object o ) {</span>
 78             final ClassGen THIS = (ClassGen) o;
 79             return THIS.getClassName().hashCode();
 80         }
 81     };
 82 
<span class="line-modified"> 83 </span>
<span class="line-modified"> 84     /** Convenience constructor to set up some important values initially.</span>
 85      *
 86      * @param class_name fully qualified class name
 87      * @param super_class_name fully qualified superclass name
 88      * @param file_name source file name
 89      * @param access_flags access qualifiers
 90      * @param interfaces implemented interfaces
 91      * @param cp constant pool to use
 92      */
 93     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
 94             final String[] interfaces, final ConstantPoolGen cp) {
 95         super(access_flags);
 96         this.class_name = class_name;
 97         this.super_class_name = super_class_name;
 98         this.file_name = file_name;
 99         this.cp = cp;
100         // Put everything needed by default into the constant pool and the vectors
101         if (file_name != null) {
102             addAttribute(new SourceFile(cp.addUtf8(&quot;SourceFile&quot;), 2, cp.addUtf8(file_name), cp
103                     .getConstantPool()));
104         }
105         class_name_index = cp.addClass(class_name);
106         superclass_name_index = cp.addClass(super_class_name);
107         if (interfaces != null) {
108             for (final String interface1 : interfaces) {
109                 addInterface(interface1);
110             }
111         }
112     }
113 
<span class="line-modified">114 </span>
<span class="line-modified">115     /** Convenience constructor to set up some important values initially.</span>
116      *
117      * @param class_name fully qualified class name
118      * @param super_class_name fully qualified superclass name
119      * @param file_name source file name
120      * @param access_flags access qualifiers
121      * @param interfaces implemented interfaces
122      */
123     public ClassGen(final String class_name, final String super_class_name, final String file_name, final int access_flags,
124             final String[] interfaces) {
125         this(class_name, super_class_name, file_name, access_flags, interfaces,
126                 new ConstantPoolGen());
127     }
128 
<span class="line-added">129 </span>
130     /**
131      * Initialize with existing class.

132      * @param clazz JavaClass object (e.g. read from file)
133      */
134     public ClassGen(final JavaClass clazz) {
135         super(clazz.getAccessFlags());
136         class_name_index = clazz.getClassNameIndex();
137         superclass_name_index = clazz.getSuperclassNameIndex();
138         class_name = clazz.getClassName();
139         super_class_name = clazz.getSuperclassName();
140         file_name = clazz.getSourceFileName();
141         cp = new ConstantPoolGen(clazz.getConstantPool());
142         major = clazz.getMajor();
143         minor = clazz.getMinor();
144         final Attribute[] attributes = clazz.getAttributes();
145         // J5TODO: Could make unpacking lazy, done on first reference
146         final AnnotationEntryGen[] annotations = unpackAnnotations(attributes);
147         final Method[] methods = clazz.getMethods();
148         final Field[] fields = clazz.getFields();
149         final String[] interfaces = clazz.getInterfaceNames();
150         for (final String interface1 : interfaces) {
151             addInterface(interface1);
152         }
153         for (final Attribute attribute : attributes) {
154             if (!(attribute instanceof Annotations)) {
155                 addAttribute(attribute);
156             }
157         }
158         for (final AnnotationEntryGen annotation : annotations) {
159             addAnnotationEntry(annotation);
160         }
161         for (final Method method : methods) {
162             addMethod(method);
163         }
164         for (final Field field : fields) {
165             addField(field);
166         }
167     }
168 
169     /**
170      * Look for attributes representing annotations and unpack them.
171      */
<span class="line-modified">172     private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs)</span>
<span class="line-added">173     {</span>
174         final List&lt;AnnotationEntryGen&gt; annotationGenObjs = new ArrayList&lt;&gt;();
175         for (final Attribute attr : attrs) {
<span class="line-modified">176             if (attr instanceof RuntimeVisibleAnnotations)</span>
<span class="line-added">177             {</span>
178                 final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;
179                 final AnnotationEntry[] annos = rva.getAnnotationEntries();
180                 for (final AnnotationEntry a : annos) {
181                     annotationGenObjs.add(new AnnotationEntryGen(a,
182                             getConstantPool(), false));
183                 }







184             }
<span class="line-added">185             else</span>
<span class="line-added">186                 if (attr instanceof RuntimeInvisibleAnnotations)</span>
<span class="line-added">187                 {</span>
<span class="line-added">188                     final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;</span>
<span class="line-added">189                     final AnnotationEntry[] annos = ria.getAnnotationEntries();</span>
<span class="line-added">190                     for (final AnnotationEntry a : annos) {</span>
<span class="line-added">191                         annotationGenObjs.add(new AnnotationEntryGen(a,</span>
<span class="line-added">192                                 getConstantPool(), false));</span>
<span class="line-added">193                     }</span>
<span class="line-added">194                 }</span>
195         }
196         return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);
197     }
198 
<span class="line-added">199 </span>
200     /**
201      * @return the (finally) built up Java class object.
202      */
203     public JavaClass getJavaClass() {
204         final int[] interfaces = getInterfaces();
205         final Field[] fields = getFields();
206         final Method[] methods = getMethods();
<span class="line-modified">207         Attribute[] attributes = null;</span>
208         if (annotation_vec.isEmpty()) {
209             attributes = getAttributes();
210         } else {
211             // TODO: Sometime later, trash any attributes called &#39;RuntimeVisibleAnnotations&#39; or &#39;RuntimeInvisibleAnnotations&#39;
<span class="line-modified">212             final Attribute[] annAttributes  = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());</span>
<span class="line-modified">213             attributes = new Attribute[attribute_vec.size()+annAttributes.length];</span>
214             attribute_vec.toArray(attributes);
<span class="line-modified">215             System.arraycopy(annAttributes,0,attributes,attribute_vec.size(),annAttributes.length);</span>
216         }
217         // Must be last since the above calls may still add something to it
218         final ConstantPool _cp = this.cp.getFinalConstantPool();
219         return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
220                 super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);
221     }
222 
<span class="line-added">223 </span>
224     /**
225      * Add an interface to this class, i.e., this class has to implement it.

226      * @param name interface to implement (fully qualified class name)
227      */
<span class="line-modified">228     public void addInterface( final String name ) {</span>
229         interface_vec.add(name);
230     }
231 
<span class="line-added">232 </span>
233     /**
234      * Remove an interface from this class.

235      * @param name interface to remove (fully qualified name)
236      */
<span class="line-modified">237     public void removeInterface( final String name ) {</span>
238         interface_vec.remove(name);
239     }
240 
<span class="line-added">241 </span>
242     /**
243      * @return major version number of class file
244      */
245     public int getMajor() {
246         return major;
247     }
248 
<span class="line-modified">249 </span>
<span class="line-modified">250     /** Set major version number of class file, default value is 45 (JDK 1.1)</span>

251      * @param major major version number
252      */
<span class="line-modified">253     public void setMajor( final int major ) { // TODO could be package-protected - only called by test code</span>
254         this.major = major;
255     }
256 
<span class="line-modified">257 </span>
<span class="line-modified">258     /** Set minor version number of class file, default value is 3 (JDK 1.1)</span>

259      * @param minor minor version number
260      */
<span class="line-modified">261     public void setMinor( final int minor ) {  // TODO could be package-protected - only called by test code</span>
262         this.minor = minor;
263     }
264 
265     /**
266      * @return minor version number of class file
267      */
268     public int getMinor() {
269         return minor;
270     }
271 
<span class="line-added">272 </span>
273     /**
274      * Add an attribute to this class.

275      * @param a attribute to add
276      */
<span class="line-modified">277     public void addAttribute( final Attribute a ) {</span>
278         attribute_vec.add(a);
279     }
280 
<span class="line-modified">281     public void addAnnotationEntry(final AnnotationEntryGen a) {</span>
282         annotation_vec.add(a);
283     }
284 
<span class="line-added">285 </span>
286     /**
287      * Add a method to this class.

288      * @param m method to add
289      */
<span class="line-modified">290     public void addMethod( final Method m ) {</span>
291         method_vec.add(m);
292     }
293 
<span class="line-added">294 </span>
295     /**
296      * Convenience method.
297      *
<span class="line-modified">298      * Add an empty constructor to this class that does nothing but calling super().</span>


299      * @param access_flags rights for constructor
300      */
<span class="line-modified">301     public void addEmptyConstructor( final int access_flags ) {</span>
302         final InstructionList il = new InstructionList();
303         il.append(InstructionConst.THIS); // Push `this&#39;
304         il.append(new INVOKESPECIAL(cp.addMethodref(super_class_name, &quot;&lt;init&gt;&quot;, &quot;()V&quot;)));
305         il.append(InstructionConst.RETURN);
306         final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, &quot;&lt;init&gt;&quot;,
307                 class_name, il, cp);
308         mg.setMaxStack(1);
309         addMethod(mg.getMethod());
310     }
311 
<span class="line-added">312 </span>
313     /**
314      * Add a field to this class.

315      * @param f field to add
316      */
<span class="line-modified">317     public void addField( final Field f ) {</span>
318         field_vec.add(f);
319     }
320 
<span class="line-modified">321 </span>
<span class="line-added">322     public boolean containsField( final Field f ) {</span>
323         return field_vec.contains(f);
324     }
325 
<span class="line-modified">326 </span>
<span class="line-modified">327     /** @return field object with given name, or null</span>
328      */
<span class="line-modified">329     public Field containsField( final String name ) {</span>
330         for (final Field f : field_vec) {
331             if (f.getName().equals(name)) {
332                 return f;
333             }
334         }
335         return null;
336     }
337 
<span class="line-modified">338 </span>
<span class="line-modified">339     /** @return method object with given name and signature, or null</span>
340      */
<span class="line-modified">341     public Method containsMethod( final String name, final String signature ) {</span>
342         for (final Method m : method_vec) {
343             if (m.getName().equals(name) &amp;&amp; m.getSignature().equals(signature)) {
344                 return m;
345             }
346         }
347         return null;
348     }
349 
<span class="line-added">350 </span>
351     /**
352      * Remove an attribute from this class.

353      * @param a attribute to remove
354      */
<span class="line-modified">355     public void removeAttribute( final Attribute a ) {</span>
356         attribute_vec.remove(a);
357     }
358 
<span class="line-added">359 </span>
360     /**
361      * Remove a method from this class.

362      * @param m method to remove
363      */
<span class="line-modified">364     public void removeMethod( final Method m ) {</span>
365         method_vec.remove(m);
366     }
367 
<span class="line-modified">368 </span>
<span class="line-modified">369     /** Replace given method with new one. If the old one does not exist</span>
<span class="line-modified">370      * add the new_ method to the class anyway.</span>
371      */
<span class="line-modified">372     public void replaceMethod( final Method old, final Method new_ ) {</span>
373         if (new_ == null) {
374             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
375         }
376         final int i = method_vec.indexOf(old);
377         if (i &lt; 0) {
378             method_vec.add(new_);
379         } else {
380             method_vec.set(i, new_);
381         }
382     }
383 
<span class="line-modified">384 </span>
<span class="line-modified">385     /** Replace given field with new one. If the old one does not exist</span>
<span class="line-modified">386      * add the new_ field to the class anyway.</span>
387      */
<span class="line-modified">388     public void replaceField( final Field old, final Field new_ ) {</span>
389         if (new_ == null) {
390             throw new ClassGenException(&quot;Replacement method must not be null&quot;);
391         }
392         final int i = field_vec.indexOf(old);
393         if (i &lt; 0) {
394             field_vec.add(new_);
395         } else {
396             field_vec.set(i, new_);
397         }
398     }
399 
<span class="line-added">400 </span>
401     /**
402      * Remove a field to this class.

403      * @param f field to remove
404      */
<span class="line-modified">405     public void removeField( final Field f ) {</span>
406         field_vec.remove(f);
407     }
408 
<span class="line-added">409 </span>
410     public String getClassName() {
411         return class_name;
412     }
413 
<span class="line-added">414 </span>
415     public String getSuperclassName() {
416         return super_class_name;
417     }
418 
<span class="line-added">419 </span>
420     public String getFileName() {
421         return file_name;
422     }
423 
<span class="line-modified">424 </span>
<span class="line-added">425     public void setClassName( final String name ) {</span>
426         class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
427         class_name_index = cp.addClass(name);
428     }
429 
<span class="line-modified">430 </span>
<span class="line-added">431     public void setSuperclassName( final String name ) {</span>
432         super_class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
433         superclass_name_index = cp.addClass(name);
434     }
435 
<span class="line-added">436 </span>
437     public Method[] getMethods() {
438         return method_vec.toArray(new Method[method_vec.size()]);
439     }
440 
<span class="line-modified">441 </span>
<span class="line-added">442     public void setMethods( final Method[] methods ) {</span>
443         method_vec.clear();
444         for (final Method method : methods) {
445             addMethod(method);
446         }
447     }
448 
<span class="line-modified">449 </span>
<span class="line-added">450     public void setMethodAt( final Method method, final int pos ) {</span>
451         method_vec.set(pos, method);
452     }
453 
<span class="line-modified">454 </span>
<span class="line-added">455     public Method getMethodAt( final int pos ) {</span>
456         return method_vec.get(pos);
457     }
458 
<span class="line-added">459 </span>
460     public String[] getInterfaceNames() {
461         final int size = interface_vec.size();
462         final String[] interfaces = new String[size];
463         interface_vec.toArray(interfaces);
464         return interfaces;
465     }
466 
<span class="line-added">467 </span>
468     public int[] getInterfaces() {
469         final int size = interface_vec.size();
470         final int[] interfaces = new int[size];
471         for (int i = 0; i &lt; size; i++) {
472             interfaces[i] = cp.addClass(interface_vec.get(i));
473         }
474         return interfaces;
475     }
476 
<span class="line-added">477 </span>
478     public Field[] getFields() {
479         return field_vec.toArray(new Field[field_vec.size()]);
480     }
481 
<span class="line-added">482 </span>
483     public Attribute[] getAttributes() {
484         return attribute_vec.toArray(new Attribute[attribute_vec.size()]);
485     }
486 
487     //  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?
488     public AnnotationEntryGen[] getAnnotationEntries() {
489         return annotation_vec.toArray(new AnnotationEntryGen[annotation_vec.size()]);
490     }
491 
<span class="line-added">492 </span>
493     public ConstantPoolGen getConstantPool() {
494         return cp;
495     }
496 
<span class="line-modified">497 </span>
<span class="line-added">498     public void setConstantPool( final ConstantPoolGen constant_pool ) {</span>
499         cp = constant_pool;
500     }
501 
<span class="line-modified">502 </span>
<span class="line-added">503     public void setClassNameIndex( final int class_name_index ) {</span>
504         this.class_name_index = class_name_index;
505         class_name = cp.getConstantPool().getConstantString(class_name_index,
506                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
507     }
508 
<span class="line-modified">509 </span>
<span class="line-added">510     public void setSuperclassNameIndex( final int superclass_name_index ) {</span>
511         this.superclass_name_index = superclass_name_index;
512         super_class_name = cp.getConstantPool().getConstantString(superclass_name_index,
513                 Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
514     }
515 
<span class="line-added">516 </span>
517     public int getSuperclassNameIndex() {
518         return superclass_name_index;
519     }
520 
<span class="line-added">521 </span>
522     public int getClassNameIndex() {
523         return class_name_index;
524     }
525 
526     private List&lt;ClassObserver&gt; observers;
527 
<span class="line-modified">528 </span>
<span class="line-modified">529     /** Add observer for this object.</span>
530      */
<span class="line-modified">531     public void addObserver( final ClassObserver o ) {</span>
532         if (observers == null) {
533             observers = new ArrayList&lt;&gt;();
534         }
535         observers.add(o);
536     }
537 
<span class="line-modified">538 </span>
<span class="line-modified">539     /** Remove observer for this object.</span>
540      */
<span class="line-modified">541     public void removeObserver( final ClassObserver o ) {</span>
542         if (observers != null) {
543             observers.remove(o);
544         }
545     }
546 
<span class="line-modified">547 </span>
<span class="line-modified">548     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">549      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">550      * called by the user after he has finished editing the object.</span>
551      */
552     public void update() {
553         if (observers != null) {
554             for (final ClassObserver observer : observers) {
555                 observer.notify(this);
556             }
557         }
558     }
559 
<span class="line-added">560 </span>
561     @Override
562     public Object clone() {
563         try {
564             return super.clone();
565         } catch (final CloneNotSupportedException e) {
566             throw new Error(&quot;Clone Not Supported&quot;); // never happens
567         }
568     }
569 
<span class="line-added">570 </span>
571     /**
572      * @return Comparison strategy object
573      */
574     public static BCELComparator getComparator() {
575         return _cmp;
576     }
577 
<span class="line-added">578 </span>
579     /**
580      * @param comparator Comparison strategy object
581      */
<span class="line-modified">582     public static void setComparator( final BCELComparator comparator ) {</span>
583         _cmp = comparator;
584     }
585 
<span class="line-added">586 </span>
587     /**
<span class="line-modified">588      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">589      * By default two ClassGen objects are said to be equal when</span>
<span class="line-added">590      * their class names are equal.</span>
591      *
592      * @see java.lang.Object#equals(java.lang.Object)
593      */
594     @Override
<span class="line-modified">595     public boolean equals( final Object obj ) {</span>
596         return _cmp.equals(this, obj);
597     }
598 
<span class="line-added">599 </span>
600     /**
<span class="line-modified">601      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">602      * By default return the hashcode of the class name.</span>
603      *
604      * @see java.lang.Object#hashCode()
605      */
606     @Override
607     public int hashCode() {
608         return _cmp.hashCode(this);
609     }
610 }
</pre>
</td>
</tr>
</table>
<center><a href="CPInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ClassGenException.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
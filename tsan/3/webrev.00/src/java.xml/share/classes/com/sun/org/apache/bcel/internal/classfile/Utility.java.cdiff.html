<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Utility.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnknownAttributeReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Visitor.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Utility.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,72 ***</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Utility functions that do not really belong to any class in particular.
   *
<span class="line-modified">!  * @version $Id: Utility.java 1751107 2016-07-03 02:41:18Z dbrosius $</span>
<span class="line-removed">-  * @LastModified: Oct 2017</span>
   */
  // @since 6.0 methods are no longer final
  public abstract class Utility {
  
<span class="line-modified">!     private static int unwrap(final ThreadLocal&lt;Integer&gt; tl) {</span>
<span class="line-modified">!         return tl.get().intValue();</span>
      }
  
<span class="line-modified">!     private static void wrap(final ThreadLocal&lt;Integer&gt; tl, final int value) {</span>
<span class="line-modified">!         tl.set(Integer.valueOf(value));</span>
      }
  
      private static ThreadLocal&lt;Integer&gt; consumed_chars = new ThreadLocal&lt;Integer&gt;() {
<span class="line-removed">- </span>
          @Override
          protected Integer initialValue() {
<span class="line-modified">!             return Integer.valueOf(0);</span>
          }
<span class="line-modified">!     };/* How many chars have been consumed</span>
<span class="line-removed">-      * during parsing in signatureToString().</span>
<span class="line-removed">-      * Read by methodSignatureToString().</span>
<span class="line-removed">-      * Set by side effect,but only internally.</span>
<span class="line-removed">-      */</span>
  
<span class="line-modified">!     private static boolean wide = false; /* The `WIDE&#39; instruction is used in the</span>
       * byte code to allow 16-bit wide indices
       * for local variables. This opcode
       * precedes an `ILOAD&#39;, e.g.. The opcode
       * immediately following takes an extra
       * byte which is combined with the
       * following byte to form a
       * 16-bit value.
       */
  
  
      /**
       * Convert bit field of flags into string such as `static final&#39;.
       *
<span class="line-modified">!      * @param access_flags Access flags</span>
       * @return String representation of flags
       */
<span class="line-modified">!     public static String accessToString(final int access_flags) {</span>
          return accessToString(access_flags, false);
      }
  
      /**
       * Convert bit field of flags into string such as `static final&#39;.
       *
       * Special case: Classes compiled with new compilers and with the
<span class="line-modified">!      * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is because SUN</span>
<span class="line-modified">!      * used the same value for the flags `ACC_SUPER&#39; and `ACC_SYNCHRONIZED&#39;.</span>
       *
<span class="line-modified">!      * @param access_flags Access flags</span>
<span class="line-modified">!      * @param for_class access flags are for class qualifiers ?</span>
       * @return String representation of flags
       */
<span class="line-modified">!     public static String accessToString(final int access_flags, final boolean for_class) {</span>
          final StringBuilder buf = new StringBuilder();
          int p = 0;
<span class="line-modified">!         for (int i = 0; p &lt; Const.MAX_ACC_FLAG; i++) { // Loop through known flags</span>
              p = pow2(i);
              if ((access_flags &amp; p) != 0) {
                  /* Special case: Classes compiled with new compilers and with the
                   * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is
                   * because SUN used the same value for the flags `ACC_SUPER&#39; and
<span class="line-new-header">--- 40,74 ---</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Utility functions that do not really belong to any class in particular.
   *
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  // @since 6.0 methods are no longer final
  public abstract class Utility {
  
<span class="line-modified">!     private static int unwrap( final ThreadLocal&lt;Integer&gt; tl ) {</span>
<span class="line-modified">!         return tl.get();</span>
      }
  
<span class="line-modified">!     private static void wrap( final ThreadLocal&lt;Integer&gt; tl, final int value ) {</span>
<span class="line-modified">!         tl.set(value);</span>
      }
  
<span class="line-added">+     /* How many chars have been consumed</span>
<span class="line-added">+      * during parsing in typeSignatureToString().</span>
<span class="line-added">+      * Read by methodSignatureToString().</span>
<span class="line-added">+      * Set by side effect, but only internally.</span>
<span class="line-added">+      */</span>
      private static ThreadLocal&lt;Integer&gt; consumed_chars = new ThreadLocal&lt;Integer&gt;() {
          @Override
          protected Integer initialValue() {
<span class="line-modified">!             return 0;</span>
          }
<span class="line-modified">!     };</span>
  
<span class="line-modified">!     /* The `WIDE&#39; instruction is used in the</span>
       * byte code to allow 16-bit wide indices
       * for local variables. This opcode
       * precedes an `ILOAD&#39;, e.g.. The opcode
       * immediately following takes an extra
       * byte which is combined with the
       * following byte to form a
       * 16-bit value.
       */
<span class="line-added">+     private static boolean wide = false;</span>
  
  
      /**
       * Convert bit field of flags into string such as `static final&#39;.
       *
<span class="line-modified">!      * @param  access_flags Access flags</span>
       * @return String representation of flags
       */
<span class="line-modified">!     public static String accessToString( final int access_flags ) {</span>
          return accessToString(access_flags, false);
      }
  
<span class="line-added">+ </span>
      /**
       * Convert bit field of flags into string such as `static final&#39;.
       *
       * Special case: Classes compiled with new compilers and with the
<span class="line-modified">!      * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is</span>
<span class="line-modified">!      * because SUN used the same value for the flags `ACC_SUPER&#39; and</span>
<span class="line-added">+      * `ACC_SYNCHRONIZED&#39;.</span>
       *
<span class="line-modified">!      * @param  access_flags Access flags</span>
<span class="line-modified">!      * @param  for_class access flags are for class qualifiers ?</span>
       * @return String representation of flags
       */
<span class="line-modified">!     public static String accessToString( final int access_flags, final boolean for_class ) {</span>
          final StringBuilder buf = new StringBuilder();
          int p = 0;
<span class="line-modified">!         for (int i = 0; p &lt; Const.MAX_ACC_FLAG_I; i++) { // Loop through known flags</span>
              p = pow2(i);
              if ((access_flags &amp; p) != 0) {
                  /* Special case: Classes compiled with new compilers and with the
                   * `ACC_SUPER&#39; flag would be said to be &quot;synchronized&quot;. This is
                   * because SUN used the same value for the flags `ACC_SUPER&#39; and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,70 ***</span>
              }
          }
          return buf.toString().trim();
      }
  
      /**
       * @param access_flags the class flags
       *
       * @return &quot;class&quot; or &quot;interface&quot;, depending on the ACC_INTERFACE flag
       */
<span class="line-modified">!     public static String classOrInterface(final int access_flags) {</span>
          return ((access_flags &amp; Const.ACC_INTERFACE) != 0) ? &quot;interface&quot; : &quot;class&quot;;
      }
  
      /**
       * Disassemble a byte array of JVM byte codes starting from code line
       * `index&#39; and return the disassembled string representation. Decode only
<span class="line-modified">!      * `num&#39; opcodes (including their operands), use -1 if you want to decompile</span>
<span class="line-modified">!      * everything.</span>
       *
<span class="line-modified">!      * @param code byte code array</span>
<span class="line-modified">!      * @param constant_pool Array of constants</span>
<span class="line-modified">!      * @param index offset in `code&#39; array</span>
       * &lt;EM&gt;(number of opcodes, not bytes!)&lt;/EM&gt;
<span class="line-modified">!      * @param length number of opcodes to decompile, -1 for all</span>
<span class="line-modified">!      * @param verbose be verbose, e.g. print constant pool index</span>
       * @return String representation of byte codes
       */
<span class="line-modified">!     public static String codeToString(final byte[] code, final ConstantPool constant_pool,</span>
<span class="line-modified">!             final int index, final int length, final boolean verbose) {</span>
<span class="line-modified">!         // Should be sufficient // CHECKSTYLE IGNORE MagicNumber</span>
<span class="line-removed">-         final StringBuilder buf = new StringBuilder(code.length * 20);</span>
          try (ByteSequence stream = new ByteSequence(code)) {
              for (int i = 0; i &lt; index; i++) {
                  codeToString(stream, constant_pool, verbose);
              }
              for (int i = 0; stream.available() &gt; 0; i++) {
                  if ((length &lt; 0) || (i &lt; length)) {
                      final String indices = fillup(stream.getIndex() + &quot;:&quot;, 6, true, &#39; &#39;);
<span class="line-modified">!                     buf.append(indices)</span>
<span class="line-removed">-                             .append(codeToString(stream, constant_pool, verbose))</span>
<span class="line-removed">-                             .append(&#39;\n&#39;);</span>
                  }
              }
          } catch (final IOException e) {
              throw new ClassFormatException(&quot;Byte code error: &quot; + buf.toString(), e);
          }
          return buf.toString();
      }
  
<span class="line-modified">!     public static String codeToString(final byte[] code, final ConstantPool constant_pool,</span>
<span class="line-modified">!             final int index, final int length) {</span>
          return codeToString(code, constant_pool, index, length, true);
      }
  
      /**
<span class="line-modified">!      * Disassemble a stream of byte codes and return the string representation.</span>
       *
<span class="line-modified">!      * @param bytes stream of bytes</span>
<span class="line-modified">!      * @param constant_pool Array of constants</span>
<span class="line-modified">!      * @param verbose be verbose, e.g. print constant pool index</span>
       * @return String representation of byte code
       *
<span class="line-modified">!      * @throws IOException if a failure from reading from the bytes argument</span>
<span class="line-removed">-      * occurs</span>
       */
      @SuppressWarnings(&quot;fallthrough&quot;) // by design for case Const.INSTANCEOF
      public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool,
              final boolean verbose) throws IOException {
          final short opcode = (short) bytes.readUnsignedByte();
<span class="line-new-header">--- 120,70 ---</span>
              }
          }
          return buf.toString().trim();
      }
  
<span class="line-added">+ </span>
      /**
       * @param access_flags the class flags
       *
       * @return &quot;class&quot; or &quot;interface&quot;, depending on the ACC_INTERFACE flag
       */
<span class="line-modified">!     public static String classOrInterface( final int access_flags ) {</span>
          return ((access_flags &amp; Const.ACC_INTERFACE) != 0) ? &quot;interface&quot; : &quot;class&quot;;
      }
  
<span class="line-added">+ </span>
      /**
       * Disassemble a byte array of JVM byte codes starting from code line
       * `index&#39; and return the disassembled string representation. Decode only
<span class="line-modified">!      * `num&#39; opcodes (including their operands), use -1 if you want to</span>
<span class="line-modified">!      * decompile everything.</span>
       *
<span class="line-modified">!      * @param  code byte code array</span>
<span class="line-modified">!      * @param  constant_pool Array of constants</span>
<span class="line-modified">!      * @param  index offset in `code&#39; array</span>
       * &lt;EM&gt;(number of opcodes, not bytes!)&lt;/EM&gt;
<span class="line-modified">!      * @param  length number of opcodes to decompile, -1 for all</span>
<span class="line-modified">!      * @param  verbose be verbose, e.g. print constant pool index</span>
       * @return String representation of byte codes
       */
<span class="line-modified">!     public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index,</span>
<span class="line-modified">!             final int length, final boolean verbose ) {</span>
<span class="line-modified">!         final StringBuilder buf = new StringBuilder(code.length * 20); // Should be sufficient // CHECKSTYLE IGNORE MagicNumber</span>
          try (ByteSequence stream = new ByteSequence(code)) {
              for (int i = 0; i &lt; index; i++) {
                  codeToString(stream, constant_pool, verbose);
              }
              for (int i = 0; stream.available() &gt; 0; i++) {
                  if ((length &lt; 0) || (i &lt; length)) {
                      final String indices = fillup(stream.getIndex() + &quot;:&quot;, 6, true, &#39; &#39;);
<span class="line-modified">!                     buf.append(indices).append(codeToString(stream, constant_pool, verbose)).append(&#39;\n&#39;);</span>
                  }
              }
          } catch (final IOException e) {
              throw new ClassFormatException(&quot;Byte code error: &quot; + buf.toString(), e);
          }
          return buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index, final int length ) {</span>
          return codeToString(code, constant_pool, index, length, true);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Disassemble a stream of byte codes and return the</span>
<span class="line-added">+      * string representation.</span>
       *
<span class="line-modified">!      * @param  bytes stream of bytes</span>
<span class="line-modified">!      * @param  constant_pool Array of constants</span>
<span class="line-modified">!      * @param  verbose be verbose, e.g. print constant pool index</span>
       * @return String representation of byte code
       *
<span class="line-modified">!      * @throws IOException if a failure from reading from the bytes argument occurs</span>
       */
      @SuppressWarnings(&quot;fallthrough&quot;) // by design for case Const.INSTANCEOF
      public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool,
              final boolean verbose) throws IOException {
          final short opcode = (short) bytes.readUnsignedByte();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,11 ***</span>
                          buf.append(&quot;, &quot;);
                      }
                  }
                  buf.append(&quot;)&quot;);
              }
<span class="line-modified">!             break;</span>
              /* Two address bytes + offset from start of byte stream form the
               * jump target
               */
              case Const.GOTO:
              case Const.IFEQ:
<span class="line-new-header">--- 253,11 ---</span>
                          buf.append(&quot;, &quot;);
                      }
                  }
                  buf.append(&quot;)&quot;);
              }
<span class="line-modified">!                 break;</span>
              /* Two address bytes + offset from start of byte stream form the
               * jump target
               */
              case Const.GOTO:
              case Const.IFEQ:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,18 ***</span>
              case Const.PUTFIELD:
              case Const.PUTSTATIC:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t\t&quot;).append(
                          constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(
<span class="line-modified">!                                 verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
                  break;
              /* Operands are references to classes in constant pool
               */
              case Const.NEW:
              case Const.CHECKCAST:
                  buf.append(&quot;\t&quot;);
<span class="line-modified">!             //$FALL-THROUGH$</span>
              case Const.INSTANCEOF:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t&lt;&quot;).append(
                          constant_pool.constantToString(index, Const.CONSTANT_Class))
                          .append(&quot;&gt;&quot;).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
<span class="line-new-header">--- 327,18 ---</span>
              case Const.PUTFIELD:
              case Const.PUTSTATIC:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t\t&quot;).append(
                          constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(
<span class="line-modified">!                         verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
                  break;
              /* Operands are references to classes in constant pool
               */
              case Const.NEW:
              case Const.CHECKCAST:
                  buf.append(&quot;\t&quot;);
<span class="line-modified">!                 //$FALL-THROUGH$</span>
              case Const.INSTANCEOF:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t&lt;&quot;).append(
                          constant_pool.constantToString(index, Const.CONSTANT_Class))
                          .append(&quot;&gt;&quot;).append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 362,21 ***</span>
              case Const.INVOKEINTERFACE:
                  index = bytes.readUnsignedShort();
                  final int nargs = bytes.readUnsignedByte(); // historical, redundant
                  buf.append(&quot;\t&quot;).append(
                          constant_pool
<span class="line-modified">!                         .constantToString(index, Const.CONSTANT_InterfaceMethodref))</span>
                          .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;).append(nargs).append(&quot;\t&quot;)
                          .append(bytes.readUnsignedByte()); // Last byte is a reserved space
                  break;
              case Const.INVOKEDYNAMIC:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t&quot;).append(
                          constant_pool
<span class="line-modified">!                         .constantToString(index, Const.CONSTANT_InvokeDynamic))</span>
                          .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;)
<span class="line-modified">!                         .append(bytes.readUnsignedByte()) // Thrid byte is a reserved space</span>
                          .append(bytes.readUnsignedByte()); // Last byte is a reserved space
                  break;
              /* Operands are references to items in constant pool
               */
              case Const.LDC_W:
<span class="line-new-header">--- 364,21 ---</span>
              case Const.INVOKEINTERFACE:
                  index = bytes.readUnsignedShort();
                  final int nargs = bytes.readUnsignedByte(); // historical, redundant
                  buf.append(&quot;\t&quot;).append(
                          constant_pool
<span class="line-modified">!                                 .constantToString(index, Const.CONSTANT_InterfaceMethodref))</span>
                          .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;).append(nargs).append(&quot;\t&quot;)
                          .append(bytes.readUnsignedByte()); // Last byte is a reserved space
                  break;
              case Const.INVOKEDYNAMIC:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t&quot;).append(
                          constant_pool
<span class="line-modified">!                                 .constantToString(index, Const.CONSTANT_InvokeDynamic))</span>
                          .append(verbose ? &quot; (&quot; + index + &quot;)\t&quot; : &quot;&quot;)
<span class="line-modified">!                         .append(bytes.readUnsignedByte())  // Thrid byte is a reserved space</span>
                          .append(bytes.readUnsignedByte()); // Last byte is a reserved space
                  break;
              /* Operands are references to items in constant pool
               */
              case Const.LDC_W:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,24 ***</span>
               */
              case Const.ANEWARRAY:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t\t&lt;&quot;).append(
                          compactClassName(constant_pool.getConstantString(index,
<span class="line-modified">!                                         Const.CONSTANT_Class), false)).append(&quot;&gt;&quot;).append(</span>
<span class="line-modified">!                                 verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
                  break;
              /* Multidimensional array of references.
               */
              case Const.MULTIANEWARRAY: {
                  index = bytes.readUnsignedShort();
                  final int dimensions = bytes.readUnsignedByte();
                  buf.append(&quot;\t&lt;&quot;).append(
                          compactClassName(constant_pool.getConstantString(index,
<span class="line-modified">!                                         Const.CONSTANT_Class), false)).append(&quot;&gt;\t&quot;).append(dimensions)</span>
                          .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
              }
<span class="line-modified">!             break;</span>
              /* Increment local variable.
               */
              case Const.IINC:
                  if (wide) {
                      vindex = bytes.readUnsignedShort();
<span class="line-new-header">--- 398,24 ---</span>
               */
              case Const.ANEWARRAY:
                  index = bytes.readUnsignedShort();
                  buf.append(&quot;\t\t&lt;&quot;).append(
                          compactClassName(constant_pool.getConstantString(index,
<span class="line-modified">!                                 Const.CONSTANT_Class), false)).append(&quot;&gt;&quot;).append(</span>
<span class="line-modified">!                         verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);</span>
                  break;
              /* Multidimensional array of references.
               */
              case Const.MULTIANEWARRAY: {
                  index = bytes.readUnsignedShort();
                  final int dimensions = bytes.readUnsignedByte();
                  buf.append(&quot;\t&lt;&quot;).append(
                          compactClassName(constant_pool.getConstantString(index,
<span class="line-modified">!                                 Const.CONSTANT_Class), false)).append(&quot;&gt;\t&quot;).append(dimensions)</span>
                          .append(verbose ? &quot; (&quot; + index + &quot;)&quot; : &quot;&quot;);
              }
<span class="line-modified">!                 break;</span>
              /* Increment local variable.
               */
              case Const.IINC:
                  if (wide) {
                      vindex = bytes.readUnsignedShort();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,37 ***</span>
                  }
          }
          return buf.toString();
      }
  
<span class="line-modified">!     public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool)</span>
              throws IOException {
          return codeToString(bytes, constant_pool, true);
      }
  
      /**
       * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes
       * &lt;em&gt;String&lt;/em&gt;.
       *
       * @param str The long class name
       * @return Compacted class name
       */
<span class="line-modified">!     public static String compactClassName(final String str) {</span>
          return compactClassName(str, true);
      }
  
      /**
       * Shorten long class name &lt;em&gt;str&lt;/em&gt;, i.e., chop off the &lt;em&gt;prefix&lt;/em&gt;,
<span class="line-modified">!      * if the class name starts with this string and the flag &lt;em&gt;chopit&lt;/em&gt; is</span>
<span class="line-modified">!      * true. Slashes &lt;em&gt;/&lt;/em&gt; are converted to dots &lt;em&gt;.&lt;/em&gt;.</span>
       *
       * @param str The long class name
       * @param prefix The prefix the get rid off
<span class="line-modified">!      * @param chopit Flag that determines whether chopping is executed or not</span>
       * @return Compacted class name
       */
<span class="line-modified">!     public static String compactClassName(String str, final String prefix, final boolean chopit) {</span>
          final int len = prefix.length();
          str = str.replace(&#39;/&#39;, &#39;.&#39;); // Is `/&#39; on all systems, even DOS
          if (chopit) {
              // If string starts with `prefix&#39; and contains no further dots
              if (str.startsWith(prefix) &amp;&amp; (str.substring(len).indexOf(&#39;.&#39;) == -1)) {
<span class="line-new-header">--- 448,56 ---</span>
                  }
          }
          return buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public static String codeToString( final ByteSequence bytes, final ConstantPool constant_pool )</span>
              throws IOException {
          return codeToString(bytes, constant_pool, true);
      }
  
<span class="line-added">+ </span>
      /**
       * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes
       * &lt;em&gt;String&lt;/em&gt;.
       *
       * @param str The long class name
       * @return Compacted class name
       */
<span class="line-modified">!     public static String compactClassName( final String str ) {</span>
          return compactClassName(str, true);
      }
  
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes</span>
<span class="line-added">+      * &lt;em&gt;java.lang.String&lt;/em&gt;,</span>
<span class="line-added">+      * e.g.. If &lt;em&gt;chopit&lt;/em&gt; is &lt;em&gt;true&lt;/em&gt; the prefix &lt;em&gt;java.lang&lt;/em&gt;</span>
<span class="line-added">+      * is also removed.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param str The long class name</span>
<span class="line-added">+      * @param chopit flag that determines whether chopping is executed or not</span>
<span class="line-added">+      * @return Compacted class name</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static String compactClassName( final String str, final boolean chopit ) {</span>
<span class="line-added">+         return compactClassName(str, &quot;java.lang.&quot;, chopit);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      /**
       * Shorten long class name &lt;em&gt;str&lt;/em&gt;, i.e., chop off the &lt;em&gt;prefix&lt;/em&gt;,
<span class="line-modified">!      * if the</span>
<span class="line-modified">!      * class name starts with this string and the flag &lt;em&gt;chopit&lt;/em&gt; is true.</span>
<span class="line-added">+      * Slashes &lt;em&gt;/&lt;/em&gt; are converted to dots &lt;em&gt;.&lt;/em&gt;.</span>
       *
       * @param str The long class name
       * @param prefix The prefix the get rid off
<span class="line-modified">!      * @param chopit flag that determines whether chopping is executed or not</span>
       * @return Compacted class name
       */
<span class="line-modified">!     public static String compactClassName( String str, final String prefix, final boolean chopit ) {</span>
          final int len = prefix.length();
          str = str.replace(&#39;/&#39;, &#39;.&#39;); // Is `/&#39; on all systems, even DOS
          if (chopit) {
              // If string starts with `prefix&#39; and contains no further dots
              if (str.startsWith(prefix) &amp;&amp; (str.substring(len).indexOf(&#39;.&#39;) == -1)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 484,57 ***</span>
              }
          }
          return str;
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Shorten long class names, &lt;em&gt;java/lang/String&lt;/em&gt; becomes</span>
<span class="line-removed">-      * &lt;em&gt;java.lang.String&lt;/em&gt;, e.g.. If &lt;em&gt;chopit&lt;/em&gt; is &lt;em&gt;true&lt;/em&gt; the</span>
<span class="line-removed">-      * prefix &lt;em&gt;java.lang&lt;/em&gt;</span>
<span class="line-removed">-      * is also removed.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param str The long class name</span>
<span class="line-removed">-      * @param chopit Flag that determines whether chopping is executed or not</span>
<span class="line-removed">-      * @return Compacted class name</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public static String compactClassName(final String str, final boolean chopit) {</span>
<span class="line-removed">-         return compactClassName(str, &quot;java.lang.&quot;, chopit);</span>
<span class="line-removed">-     }</span>
  
      /**
       * @return `flag&#39; with bit `i&#39; set to 1
       */
<span class="line-modified">!     public static int setBit(final int flag, final int i) {</span>
          return flag | pow2(i);
      }
  
      /**
       * @return `flag&#39; with bit `i&#39; set to 0
       */
<span class="line-modified">!     public static int clearBit(final int flag, final int i) {</span>
          final int bit = pow2(i);
          return (flag &amp; bit) == 0 ? flag : flag ^ bit;
      }
  
      /**
       * @return true, if bit `i&#39; in `flag&#39; is set
       */
<span class="line-modified">!     public static boolean isSet(final int flag, final int i) {</span>
          return (flag &amp; pow2(i)) != 0;
      }
  
      /**
<span class="line-modified">!      * Converts string containing the method return and argument types to a byte</span>
<span class="line-modified">!      * code method signature.</span>
       *
<span class="line-modified">!      * @param ret Return type of method</span>
<span class="line-modified">!      * @param argv Types of method arguments</span>
       * @return Byte code representation of method signature
       *
       * @throws ClassFormatException if the signature is for Void
       */
<span class="line-modified">!     public static String methodTypeToSignature(final String ret, final String[] argv)</span>
              throws ClassFormatException {
          final StringBuilder buf = new StringBuilder(&quot;(&quot;);
          String str;
          if (argv != null) {
              for (final String element : argv) {
<span class="line-new-header">--- 505,47 ---</span>
              }
          }
          return str;
      }
  
  
      /**
       * @return `flag&#39; with bit `i&#39; set to 1
       */
<span class="line-modified">!     public static int setBit( final int flag, final int i ) {</span>
          return flag | pow2(i);
      }
  
<span class="line-added">+ </span>
      /**
       * @return `flag&#39; with bit `i&#39; set to 0
       */
<span class="line-modified">!     public static int clearBit( final int flag, final int i ) {</span>
          final int bit = pow2(i);
          return (flag &amp; bit) == 0 ? flag : flag ^ bit;
      }
  
<span class="line-added">+ </span>
      /**
       * @return true, if bit `i&#39; in `flag&#39; is set
       */
<span class="line-modified">!     public static boolean isSet( final int flag, final int i ) {</span>
          return (flag &amp; pow2(i)) != 0;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Converts string containing the method return and argument types</span>
<span class="line-modified">!      * to a byte code method signature.</span>
       *
<span class="line-modified">!      * @param  ret Return type of method</span>
<span class="line-modified">!      * @param  argv Types of method arguments</span>
       * @return Byte code representation of method signature
       *
       * @throws ClassFormatException if the signature is for Void
       */
<span class="line-modified">!     public static String methodTypeToSignature( final String ret, final String[] argv )</span>
              throws ClassFormatException {
          final StringBuilder buf = new StringBuilder(&quot;(&quot;);
          String str;
          if (argv != null) {
              for (final String element : argv) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,143 ***</span>
          str = getSignature(ret);
          buf.append(&quot;)&quot;).append(str);
          return buf.toString();
      }
  
      /**
<span class="line-modified">!      * @param signature Method signature</span>
<span class="line-modified">!      * @return Array of argument types</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String[] methodSignatureArgumentTypes(final String signature)</span>
              throws ClassFormatException {
          return methodSignatureArgumentTypes(signature, true);
      }
  
      /**
<span class="line-modified">!      * @param signature Method signature</span>
<span class="line-modified">!      * @param chopit Shorten class names ?</span>
<span class="line-modified">!      * @return Array of argument types</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String[] methodSignatureArgumentTypes(final String signature, final boolean chopit)</span>
              throws ClassFormatException {
          final List&lt;String&gt; vec = new ArrayList&lt;&gt;();
          int index;
<span class="line-modified">!         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">!             if (signature.charAt(0) != &#39;(&#39;) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
<span class="line-removed">-             index = 1; // current string position</span>
              while (signature.charAt(index) != &#39;)&#39;) {
<span class="line-modified">!                 vec.add(signatureToString(signature.substring(index), chopit));</span>
                  //corrected concurrent private static field acess
                  index += unwrap(consumed_chars); // update position
              }
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
          return vec.toArray(new String[vec.size()]);
      }
  
      /**
<span class="line-modified">!      * @param signature Method signature</span>
<span class="line-modified">!      * @return return type of method</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String methodSignatureReturnType(final String signature)</span>
<span class="line-removed">-             throws ClassFormatException {</span>
          return methodSignatureReturnType(signature, true);
      }
  
      /**
<span class="line-modified">!      * @param signature Method signature</span>
<span class="line-modified">!      * @param chopit Shorten class names ?</span>
<span class="line-modified">!      * @return return type of method</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String methodSignatureReturnType(final String signature,</span>
<span class="line-removed">-             final boolean chopit) throws ClassFormatException {</span>
          int index;
          String type;
          try {
              // Read return type after `)&#39;
              index = signature.lastIndexOf(&#39;)&#39;) + 1;
<span class="line-modified">!             type = signatureToString(signature.substring(index), chopit);</span>
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
          return type;
      }
  
      /**
       * Converts method signature to string with all class names compacted.
       *
<span class="line-modified">!      * @param signature to convert</span>
<span class="line-modified">!      * @param name of method</span>
<span class="line-modified">!      * @param access flags of method</span>
       * @return Human readable signature
       */
<span class="line-modified">!     public static String methodSignatureToString(final String signature,</span>
<span class="line-removed">-             final String name, final String access) {</span>
          return methodSignatureToString(signature, name, access, true);
      }
  
<span class="line-modified">!     public static String methodSignatureToString(final String signature,</span>
<span class="line-modified">!             final String name, final String access, final boolean chopit) {</span>
          return methodSignatureToString(signature, name, access, chopit, null);
      }
  
      /**
<span class="line-modified">!      * A returntype signature represents the return value from a method. It is a</span>
<span class="line-removed">-      * series of bytes in the following grammar:</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;pre&gt;</span>
<span class="line-removed">-      * &amp;lt;return_signature&amp;gt; ::= &amp;lt;field_type&amp;gt; | V</span>
<span class="line-removed">-      * &lt;/pre&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * The character V indicates that the method returns no value. Otherwise,</span>
<span class="line-removed">-      * the signature indicates the type of the return value. An argument</span>
<span class="line-removed">-      * signature represents an argument passed to a method:</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;pre&gt;</span>
<span class="line-removed">-      * &amp;lt;argument_signature&amp;gt; ::= &amp;lt;field_type&amp;gt;</span>
<span class="line-removed">-      * &lt;/pre&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * A method signature represents the arguments that the method expects, and</span>
<span class="line-removed">-      * the value that it returns.</span>
<span class="line-removed">-      * &lt;pre&gt;</span>
<span class="line-removed">-      * &amp;lt;method_signature&amp;gt; ::= (&amp;lt;arguments_signature&amp;gt;) &amp;lt;return_signature&amp;gt;</span>
<span class="line-removed">-      * &amp;lt;arguments_signature&amp;gt;::= &amp;lt;argument_signature&amp;gt;*</span>
<span class="line-removed">-      * &lt;/pre&gt;</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * This method converts such a string into a Java type declaration like</span>
       * `void main(String[])&#39; and throws a `ClassFormatException&#39; when the parsed
       * type is invalid.
       *
<span class="line-modified">!      * @param signature Method signature</span>
<span class="line-modified">!      * @param name Method name</span>
<span class="line-modified">!      * @param access Method access rights</span>
<span class="line-modified">!      * @param chopit</span>
<span class="line-modified">!      * @param vars</span>
       * @return Java type declaration
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String methodSignatureToString(final String signature, final String name,</span>
<span class="line-modified">!             final String access, final boolean chopit, final LocalVariableTable vars)</span>
<span class="line-removed">-             throws ClassFormatException {</span>
          final StringBuilder buf = new StringBuilder(&quot;(&quot;);
          String type;
          int index;
          int var_index = access.contains(&quot;static&quot;) ? 0 : 1;
<span class="line-modified">!         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">!             if (signature.charAt(0) != &#39;(&#39;) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
<span class="line-removed">-             index = 1; // current string position</span>
              while (signature.charAt(index) != &#39;)&#39;) {
<span class="line-modified">!                 final String param_type = signatureToString(signature.substring(index), chopit);</span>
                  buf.append(param_type);
                  if (vars != null) {
                      final LocalVariable l = vars.getLocalVariable(var_index, 0);
                      if (l != null) {
                          buf.append(&quot; &quot;).append(l.getName());
<span class="line-new-header">--- 559,145 ---</span>
          str = getSignature(ret);
          buf.append(&quot;)&quot;).append(str);
          return buf.toString();
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Converts argument list portion of method signature to string with all class names compacted.</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * @param  signature    Method signature</span>
<span class="line-added">+      * @return String Array of argument types</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String[] methodSignatureArgumentTypes( final String signature )</span>
              throws ClassFormatException {
          return methodSignatureArgumentTypes(signature, true);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Converts argument list portion of method signature to string.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param  signature    Method signature</span>
<span class="line-added">+      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added">+      * @return String Array of argument types</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String[] methodSignatureArgumentTypes( final String signature, final boolean chopit )</span>
              throws ClassFormatException {
          final List&lt;String&gt; vec = new ArrayList&lt;&gt;();
          int index;
<span class="line-modified">!         try {</span>
<span class="line-modified">!             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added">+             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added">+             if (index &lt;= 0) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
              while (signature.charAt(index) != &#39;)&#39;) {
<span class="line-modified">!                 vec.add(typeSignatureToString(signature.substring(index), chopit));</span>
                  //corrected concurrent private static field acess
                  index += unwrap(consumed_chars); // update position
              }
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
          return vec.toArray(new String[vec.size()]);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Converts return type portion of method signature to string with all class names compacted.</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * @param  signature    Method signature</span>
<span class="line-added">+      * @return String representation of method return type</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String methodSignatureReturnType( final String signature ) throws ClassFormatException {</span>
          return methodSignatureReturnType(signature, true);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Converts return type portion of method signature to string.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param  signature    Method signature</span>
<span class="line-added">+      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added">+      * @return String representation of method return type</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String methodSignatureReturnType( final String signature, final boolean chopit ) throws ClassFormatException {</span>
          int index;
          String type;
          try {
              // Read return type after `)&#39;
              index = signature.lastIndexOf(&#39;)&#39;) + 1;
<span class="line-modified">!             if (index &lt;= 0) {</span>
<span class="line-added">+                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             type = typeSignatureToString(signature.substring(index), chopit);</span>
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
          return type;
      }
  
<span class="line-added">+ </span>
      /**
       * Converts method signature to string with all class names compacted.
       *
<span class="line-modified">!      * @param  signature to convert</span>
<span class="line-modified">!      * @param  name of method</span>
<span class="line-modified">!      * @param  access flags of method</span>
       * @return Human readable signature
       */
<span class="line-modified">!     public static String methodSignatureToString( final String signature, final String name, final String access ) {</span>
          return methodSignatureToString(signature, name, access, true);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /**</span>
<span class="line-added">+      * Converts method signature to string.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param  signature to convert</span>
<span class="line-added">+      * @param  name of method</span>
<span class="line-added">+      * @param  access flags of method</span>
<span class="line-added">+      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added">+      * @return Human readable signature</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static String methodSignatureToString( final String signature, final String name, final String access, final boolean chopit ) {</span>
          return methodSignatureToString(signature, name, access, chopit, null);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * This method converts a method signature string into a Java type declaration like</span>
       * `void main(String[])&#39; and throws a `ClassFormatException&#39; when the parsed
       * type is invalid.
       *
<span class="line-modified">!      * @param  signature    Method signature</span>
<span class="line-modified">!      * @param  name         Method name</span>
<span class="line-modified">!      * @param  access       Method access rights</span>
<span class="line-modified">!      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified">!      * @param  vars the LocalVariableTable for the method</span>
       * @return Java type declaration
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String methodSignatureToString( final String signature, final String name,</span>
<span class="line-modified">!             final String access, final boolean chopit, final LocalVariableTable vars ) throws ClassFormatException {</span>
          final StringBuilder buf = new StringBuilder(&quot;(&quot;);
          String type;
          int index;
          int var_index = access.contains(&quot;static&quot;) ? 0 : 1;
<span class="line-modified">!         try {</span>
<span class="line-modified">!             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added">+             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added">+             if (index &lt;= 0) {</span>
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
              while (signature.charAt(index) != &#39;)&#39;) {
<span class="line-modified">!                 final String param_type = typeSignatureToString(signature.substring(index), chopit);</span>
                  buf.append(param_type);
                  if (vars != null) {
                      final LocalVariable l = vars.getLocalVariable(var_index, 0);
                      if (l != null) {
                          buf.append(&quot; &quot;).append(l.getName());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 701,37 ***</span>
                  //corrected concurrent private static field acess
                  index += unwrap(consumed_chars); // update position
              }
              index++; // update position
              // Read return type after `)&#39;
<span class="line-modified">!             type = signatureToString(signature.substring(index), chopit);</span>
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
          if (buf.length() &gt; 1) {
              buf.setLength(buf.length() - 2);
          }
          buf.append(&quot;)&quot;);
          return access + ((access.length() &gt; 0) ? &quot; &quot; : &quot;&quot;) + // May be an empty string
                  type + &quot; &quot; + name + buf.toString();
      }
  
<span class="line-modified">!     // Guess what this does</span>
<span class="line-modified">!     private static int pow2(final int n) {</span>
          return 1 &lt;&lt; n;
      }
  
      /**
<span class="line-modified">!      * Replace all occurrences of &lt;em&gt;old&lt;/em&gt; in &lt;em&gt;str&lt;/em&gt; with</span>
<span class="line-removed">-      * &lt;em&gt;new&lt;/em&gt;.</span>
       *
       * @param str String to permute
       * @param old String to be replaced
       * @param new_ Replacement string
       * @return new String object
       */
<span class="line-modified">!     public static String replace(String str, final String old, final String new_) {</span>
          int index;
          int old_index;
          try {
              if (str.contains(old)) { // `old&#39; found in str
                  final StringBuilder buf = new StringBuilder();
<span class="line-new-header">--- 714,38 ---</span>
                  //corrected concurrent private static field acess
                  index += unwrap(consumed_chars); // update position
              }
              index++; // update position
              // Read return type after `)&#39;
<span class="line-modified">!             type = typeSignatureToString(signature.substring(index), chopit);</span>
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
<span class="line-added">+         // ignore any throws information in the signature</span>
          if (buf.length() &gt; 1) {
              buf.setLength(buf.length() - 2);
          }
          buf.append(&quot;)&quot;);
          return access + ((access.length() &gt; 0) ? &quot; &quot; : &quot;&quot;) + // May be an empty string
                  type + &quot; &quot; + name + buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     private static int pow2( final int n ) {</span>
          return 1 &lt;&lt; n;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Replace all occurrences of &lt;em&gt;old&lt;/em&gt; in &lt;em&gt;str&lt;/em&gt; with &lt;em&gt;new&lt;/em&gt;.</span>
       *
       * @param str String to permute
       * @param old String to be replaced
       * @param new_ Replacement string
       * @return new String object
       */
<span class="line-modified">!     public static String replace( String str, final String old, final String new_ ) {</span>
          int index;
          int old_index;
          try {
              if (str.contains(old)) { // `old&#39; found in str
                  final StringBuilder buf = new StringBuilder();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 749,55 ***</span>
              System.err.println(e);
          }
          return str;
      }
  
      /**
<span class="line-modified">!      * Converts signature to string with all class names compacted.</span>
       *
<span class="line-modified">!      * @param signature to convert</span>
<span class="line-modified">!      * @return Human readable signature</span>
       */
<span class="line-modified">!     public static String signatureToString(final String signature) {</span>
          return signatureToString(signature, true);
      }
  
      /**
<span class="line-modified">!      * The field signature represents the value of an argument to a function or</span>
<span class="line-modified">!      * the value of a variable. It is a series of bytes generated by the</span>
<span class="line-modified">!      * following grammar:</span>
       *
<span class="line-modified">!      * &lt;PRE&gt;</span>
<span class="line-modified">!      * &amp;lt;field_signature&amp;gt; ::= &amp;lt;field_type&amp;gt;</span>
<span class="line-modified">!      * &amp;lt;field_type&amp;gt;      ::= &amp;lt;base_type&amp;gt;|&amp;lt;object_type&amp;gt;|&amp;lt;array_type&amp;gt;</span>
<span class="line-modified">!      * &amp;lt;base_type&amp;gt;       ::= B|C|D|F|I|J|S|Z</span>
<span class="line-modified">!      * &amp;lt;object_type&amp;gt;     ::= L&amp;lt;fullclassname&amp;gt;;</span>
<span class="line-modified">!      * &amp;lt;array_type&amp;gt;      ::= [&amp;lt;field_type&amp;gt;</span>
       *
<span class="line-modified">!      * The meaning of the base types is as follows:</span>
<span class="line-modified">!      * B byte signed byte</span>
<span class="line-modified">!      * C char character</span>
<span class="line-modified">!      * D double double precision IEEE float</span>
<span class="line-modified">!      * F float single precision IEEE float</span>
<span class="line-modified">!      * I int integer</span>
<span class="line-modified">!      * J long long integer</span>
<span class="line-modified">!      * L&amp;lt;fullclassname&amp;gt;; ... an object of the given class</span>
<span class="line-modified">!      * S short signed short</span>
<span class="line-modified">!      * Z boolean true or false</span>
<span class="line-modified">!      * [&amp;lt;field sig&amp;gt; ... array</span>
<span class="line-modified">!      * &lt;/PRE&gt;</span>
       *
<span class="line-modified">!      * This method converts this string into a Java type declaration such as</span>
<span class="line-modified">!      * `String[]&#39; and throws a `ClassFormatException&#39; when the parsed type is</span>
<span class="line-removed">-      * invalid.</span>
       *
<span class="line-modified">!      * @param signature Class signature</span>
<span class="line-modified">!      * @param chopit Flag that determines whether chopping is executed or not</span>
<span class="line-modified">!      * @return Java type declaration</span>
       * @throws ClassFormatException
       */
<span class="line-modified">!     public static String signatureToString(final String signature, final boolean chopit) {</span>
          //corrected concurrent private static field acess
          wrap(consumed_chars, 1); // This is the default, read just one char like `B&#39;
          try {
              switch (signature.charAt(0)) {
                  case &#39;B&#39;:
<span class="line-new-header">--- 763,205 ---</span>
              System.err.println(e);
          }
          return str;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * WARNING:</span>
       *
<span class="line-modified">!      * There is some nomenclature confusion through much of the BCEL code base with</span>
<span class="line-modified">!      * respect to the terms Descriptor and Signature.  For the offical definitions see:</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @see &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3&quot;&gt;</span>
<span class="line-added">+      * Descriptors in The Java Virtual Machine Specification&lt;/a&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @see &lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1&quot;&gt;</span>
<span class="line-added">+      * Signatures in The Java Virtual Machine Specification&lt;/a&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * In brief, a descriptor is a string representing the type of a field or method.</span>
<span class="line-added">+      * Signatures are similar, but more complex.  Signatures are used to encode declarations</span>
<span class="line-added">+      * written in the Java programming language that use types outside the type system of the</span>
<span class="line-added">+      * Java Virtual Machine.  They are used to describe the type of any class, interface,</span>
<span class="line-added">+      * constructor, method or field whose declaration uses type variables or parameterized types.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * To parse a descriptor, call typeSignatureToString.</span>
<span class="line-added">+      * To parse a signature, call signatureToString.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Note that if the signature string is a single, non-generic item, the call to</span>
<span class="line-added">+      * signatureToString reduces to a call to typeSignatureToString.</span>
<span class="line-added">+      * Also note, that if you only wish to parse the first item in a longer signature</span>
<span class="line-added">+      * string, you should call typeSignatureToString directly.</span>
       */
<span class="line-modified">! </span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts a signature to a string with all class names compacted.</span>
<span class="line-added">+      * Class, Method and Type signatures are supported.</span>
<span class="line-added">+      * Enum and Interface signatures are not supported.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param  signature signature to convert</span>
<span class="line-added">+      * @return String containg human readable signature</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public static String signatureToString( final String signature ) {</span>
          return signatureToString(signature, true);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Converts a signature to a string.</span>
<span class="line-modified">!      * Class, Method and Type signatures are supported.</span>
<span class="line-modified">!      * Enum and Interface signatures are not supported.</span>
       *
<span class="line-modified">!      * @param  signature signature to convert</span>
<span class="line-modified">!      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified">!      * @return String containg human readable signature</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     public static String signatureToString( final String signature, final boolean chopit ) {</span>
<span class="line-modified">!         String type = &quot;&quot;;</span>
<span class="line-added">+         String typeParams = &quot;&quot;;</span>
<span class="line-added">+         int index = 0;</span>
<span class="line-added">+         if (signature.charAt(0) == &#39;&lt;&#39;) {</span>
<span class="line-added">+             // we have type paramters</span>
<span class="line-added">+             typeParams = typeParamTypesToString(signature, chopit);</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (signature.charAt(index) == &#39;(&#39;) {</span>
<span class="line-added">+             // We have a Method signature.</span>
<span class="line-added">+             // add types of arguments</span>
<span class="line-added">+             type = typeParams + typeSignaturesToString(signature.substring(index), chopit, &#39;)&#39;);</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+             // add return type</span>
<span class="line-added">+             type = type + typeSignatureToString(signature.substring(index), chopit);</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+             // ignore any throws information in the signature</span>
<span class="line-added">+             return type;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // Could be Class or Type...</span>
<span class="line-added">+             type = typeSignatureToString(signature.substring(index), chopit);</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+             if ((typeParams.length() == 0) &amp;&amp; (index == signature.length())) {</span>
<span class="line-added">+                 // We have a Type signature.</span>
<span class="line-added">+                 return type;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // We have a Class signature.</span>
<span class="line-added">+             final StringBuilder typeClass = new StringBuilder(typeParams);</span>
<span class="line-added">+             typeClass.append(&quot; extends &quot;);</span>
<span class="line-added">+             typeClass.append(type);</span>
<span class="line-added">+             if (index &lt; signature.length()) {</span>
<span class="line-added">+                 typeClass.append(&quot; implements &quot;);</span>
<span class="line-added">+                 typeClass.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added">+                 index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+             }</span>
<span class="line-added">+             while (index &lt; signature.length()) {</span>
<span class="line-added">+                 typeClass.append(&quot;, &quot;);</span>
<span class="line-added">+                 typeClass.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added">+                 index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return typeClass.toString();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts a type parameter list signature to a string.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param  signature signature to convert</span>
<span class="line-added">+      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added">+      * @return String containg human readable signature</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static String typeParamTypesToString( final String signature, final boolean chopit ) {</span>
<span class="line-added">+         // The first character is guranteed to be &#39;&lt;&#39;</span>
<span class="line-added">+         final StringBuilder typeParams = new StringBuilder(&quot;&lt;&quot;);</span>
<span class="line-added">+         int index = 1;  // skip the &#39;&lt;&#39;</span>
<span class="line-added">+         // get the first TypeParameter</span>
<span class="line-added">+         typeParams.append(typeParamTypeToString(signature.substring(index), chopit));</span>
<span class="line-added">+         index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+         // are there more TypeParameters?</span>
<span class="line-added">+         while (signature.charAt(index) != &#39;&gt;&#39;) {</span>
<span class="line-added">+             typeParams.append(&quot;, &quot;);</span>
<span class="line-added">+             typeParams.append(typeParamTypeToString(signature.substring(index), chopit));</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+         }</span>
<span class="line-added">+         wrap(consumed_chars, index + 1); // account for the &#39;&gt;&#39; char</span>
<span class="line-added">+         return typeParams.append(&quot;&gt;&quot;).toString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts a type parameter signature to a string.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param  signature signature to convert</span>
<span class="line-added">+      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-added">+      * @return String containg human readable signature</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private static String typeParamTypeToString( final String signature, final boolean chopit ) {</span>
<span class="line-added">+         int index = signature.indexOf(&#39;:&#39;);</span>
<span class="line-added">+         if (index &lt;= 0) {</span>
<span class="line-added">+             throw new ClassFormatException(&quot;Invalid type parameter signature: &quot; + signature);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // get the TypeParameter identifier</span>
<span class="line-added">+         final StringBuilder typeParam = new StringBuilder(signature.substring(0, index));</span>
<span class="line-added">+         index++;  // account for the &#39;:&#39;</span>
<span class="line-added">+         if (signature.charAt(index) != &#39;:&#39;) {</span>
<span class="line-added">+             // we have a class bound</span>
<span class="line-added">+             typeParam.append(&quot; extends &quot;);</span>
<span class="line-added">+             typeParam.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // look for interface bounds</span>
<span class="line-added">+         while (signature.charAt(index) == &#39;:&#39;) {</span>
<span class="line-added">+             index++;  // skip over the &#39;:&#39;</span>
<span class="line-added">+             typeParam.append(&quot; &amp; &quot;);</span>
<span class="line-added">+             typeParam.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+         }</span>
<span class="line-added">+         wrap(consumed_chars, index);</span>
<span class="line-added">+         return typeParam.toString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Converts a list of type signatures to a string.</span>
       *
<span class="line-modified">!      * @param  signature signature to convert</span>
<span class="line-modified">!      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified">!      * @param  term character indicating the end of the list</span>
<span class="line-modified">!      * @return String containg human readable signature</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     private static String typeSignaturesToString( final String signature, final boolean chopit, final char term ) {</span>
<span class="line-modified">!         // The first character will be an &#39;open&#39; that matches the &#39;close&#39; contained in term.</span>
<span class="line-modified">!         final StringBuilder typeList = new StringBuilder(signature.substring(0, 1));</span>
<span class="line-modified">!         int index = 1;  // skip the &#39;open&#39; character</span>
<span class="line-modified">!         // get the first Type in the list</span>
<span class="line-modified">!         if (signature.charAt(index) != term) {</span>
<span class="line-modified">!             typeList.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // are there more types in the list?</span>
<span class="line-added">+         while (signature.charAt(index) != term) {</span>
<span class="line-added">+             typeList.append(&quot;, &quot;);</span>
<span class="line-added">+             typeList.append(typeSignatureToString(signature.substring(index), chopit));</span>
<span class="line-added">+             index += unwrap(consumed_chars); // update position</span>
<span class="line-added">+         }</span>
<span class="line-added">+         wrap(consumed_chars, index + 1); // account for the term char</span>
<span class="line-added">+         return typeList.append(term).toString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
       *
<span class="line-modified">!      * This method converts a type signature string into a Java type declaration such as</span>
<span class="line-modified">!      * `String[]&#39; and throws a `ClassFormatException&#39; when the parsed type is invalid.</span>
       *
<span class="line-modified">!      * @param  signature type signature</span>
<span class="line-modified">!      * @param  chopit flag that determines whether chopping is executed or not</span>
<span class="line-modified">!      * @return string containing human readable type signature</span>
       * @throws ClassFormatException
<span class="line-added">+      * @since 6.4.0</span>
       */
<span class="line-modified">!     public static String typeSignatureToString( final String signature, final boolean chopit ) throws ClassFormatException {</span>
          //corrected concurrent private static field acess
          wrap(consumed_chars, 1); // This is the default, read just one char like `B&#39;
          try {
              switch (signature.charAt(0)) {
                  case &#39;B&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 813,11 ***</span>
                  case &#39;J&#39;:
                      return &quot;long&quot;;
                  case &#39;T&#39;: { // TypeVariableSignature
                      final int index = signature.indexOf(&#39;;&#39;); // Look for closing `;&#39;
                      if (index &lt; 0) {
<span class="line-modified">!                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
                      }
                      //corrected concurrent private static field acess
                      wrap(consumed_chars, index + 1); // &quot;Tblabla;&quot; `T&#39; and `;&#39; are removed
                      return compactClassName(signature.substring(1, index), chopit);
                  }
<span class="line-new-header">--- 977,11 ---</span>
                  case &#39;J&#39;:
                      return &quot;long&quot;;
                  case &#39;T&#39;: { // TypeVariableSignature
                      final int index = signature.indexOf(&#39;;&#39;); // Look for closing `;&#39;
                      if (index &lt; 0) {
<span class="line-modified">!                         throw new ClassFormatException(&quot;Invalid type variable signature: &quot; + signature);</span>
                      }
                      //corrected concurrent private static field acess
                      wrap(consumed_chars, index + 1); // &quot;Tblabla;&quot; `T&#39; and `;&#39; are removed
                      return compactClassName(signature.substring(1, index), chopit);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 835,63 ***</span>
                      }
                      final int index = signature.indexOf(&#39;;&#39;, fromIndex); // Look for closing `;&#39;
                      if (index &lt; 0) {
                          throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
                      }
                      // check to see if there are any TypeArguments
                      final int bracketIndex = signature.substring(0, index).indexOf(&#39;&lt;&#39;);
                      if (bracketIndex &lt; 0) {
                          // just a class identifier
                          wrap(consumed_chars, index + 1); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
                          return compactClassName(signature.substring(1, index), chopit);
                      }
  
                      // we have TypeArguments; build up partial result
                      // as we recurse for each TypeArgument
<span class="line-modified">!                     final StringBuilder type = new StringBuilder(</span>
<span class="line-removed">-                             compactClassName(signature.substring(1, bracketIndex), chopit))</span>
<span class="line-removed">-                             .append(&quot;&lt;&quot;);</span>
                      int consumed_chars = bracketIndex + 1; // Shadows global var
  
                      // check for wildcards
                      if (signature.charAt(consumed_chars) == &#39;+&#39;) {
                          type.append(&quot;? extends &quot;);
                          consumed_chars++;
                      } else if (signature.charAt(consumed_chars) == &#39;-&#39;) {
                          type.append(&quot;? super &quot;);
                          consumed_chars++;
<span class="line-removed">-                     } else if (signature.charAt(consumed_chars) == &#39;*&#39;) {</span>
<span class="line-removed">-                         // must be at end of signature</span>
<span class="line-removed">-                         if (signature.charAt(consumed_chars + 1) != &#39;&gt;&#39;) {</span>
<span class="line-removed">-                             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         if (signature.charAt(consumed_chars + 2) != &#39;;&#39;) {</span>
<span class="line-removed">-                             throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         wrap(Utility.consumed_chars, consumed_chars + 3); // remove final &quot;*&gt;;&quot;</span>
<span class="line-removed">-                         return type + &quot;?&gt;...&quot;;</span>
                      }
  
                      // get the first TypeArgument
<span class="line-modified">!                     type.append(signatureToString(signature.substring(consumed_chars), chopit));</span>
<span class="line-modified">!                     // update our consumed count by the number of characters the for type argument</span>
<span class="line-modified">!                     consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;</span>
<span class="line-modified">!                     wrap(Utility.consumed_chars, consumed_chars);</span>
  
                      // are there more TypeArguments?
                      while (signature.charAt(consumed_chars) != &#39;&gt;&#39;) {
<span class="line-modified">!                         type.append(&quot;, &quot;).append(signatureToString(signature.substring(consumed_chars), chopit));</span>
                          // update our consumed count by the number of characters the for type argument
                          consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;
                          wrap(Utility.consumed_chars, consumed_chars);
                      }
<span class="line-modified">! </span>
<span class="line-removed">-                     if (signature.charAt(consumed_chars + 1) != &#39;;&#39;) {</span>
                          throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
                      }
<span class="line-modified">!                     wrap(Utility.consumed_chars, consumed_chars + 2); // remove final &quot;&gt;;&quot;</span>
<span class="line-modified">!                     return type.append(&quot;&gt;&quot;).toString();</span>
                  }
                  case &#39;S&#39;:
                      return &quot;short&quot;;
                  case &#39;Z&#39;:
                      return &quot;boolean&quot;;
<span class="line-new-header">--- 999,98 ---</span>
                      }
                      final int index = signature.indexOf(&#39;;&#39;, fromIndex); // Look for closing `;&#39;
                      if (index &lt; 0) {
                          throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
                      }
<span class="line-added">+ </span>
                      // check to see if there are any TypeArguments
                      final int bracketIndex = signature.substring(0, index).indexOf(&#39;&lt;&#39;);
                      if (bracketIndex &lt; 0) {
                          // just a class identifier
                          wrap(consumed_chars, index + 1); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
                          return compactClassName(signature.substring(1, index), chopit);
                      }
<span class="line-added">+                     // but make sure we are not looking past the end of the current item</span>
<span class="line-added">+                     fromIndex = signature.indexOf(&#39;;&#39;);</span>
<span class="line-added">+                     if (fromIndex &lt; 0) {</span>
<span class="line-added">+                         throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (fromIndex &lt; bracketIndex) {</span>
<span class="line-added">+                         // just a class identifier</span>
<span class="line-added">+                         wrap(consumed_chars, fromIndex + 1); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed</span>
<span class="line-added">+                         return compactClassName(signature.substring(1, fromIndex), chopit);</span>
<span class="line-added">+                     }</span>
  
                      // we have TypeArguments; build up partial result
                      // as we recurse for each TypeArgument
<span class="line-modified">!                     final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(&quot;&lt;&quot;);</span>
                      int consumed_chars = bracketIndex + 1; // Shadows global var
  
                      // check for wildcards
                      if (signature.charAt(consumed_chars) == &#39;+&#39;) {
                          type.append(&quot;? extends &quot;);
                          consumed_chars++;
                      } else if (signature.charAt(consumed_chars) == &#39;-&#39;) {
                          type.append(&quot;? super &quot;);
                          consumed_chars++;
                      }
  
                      // get the first TypeArgument
<span class="line-modified">!                     if (signature.charAt(consumed_chars) == &#39;*&#39;) {</span>
<span class="line-modified">!                         type.append(&quot;?&quot;);</span>
<span class="line-modified">!                         consumed_chars++;</span>
<span class="line-modified">!                     } else {</span>
<span class="line-added">+                         type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));</span>
<span class="line-added">+                         // update our consumed count by the number of characters the for type argument</span>
<span class="line-added">+                         consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;</span>
<span class="line-added">+                         wrap(Utility.consumed_chars, consumed_chars);</span>
<span class="line-added">+                     }</span>
  
                      // are there more TypeArguments?
                      while (signature.charAt(consumed_chars) != &#39;&gt;&#39;) {
<span class="line-modified">!                         type.append(&quot;, &quot;);</span>
<span class="line-added">+                         // check for wildcards</span>
<span class="line-added">+                         if (signature.charAt(consumed_chars) == &#39;+&#39;) {</span>
<span class="line-added">+                             type.append(&quot;? extends &quot;);</span>
<span class="line-added">+                             consumed_chars++;</span>
<span class="line-added">+                         } else if (signature.charAt(consumed_chars) == &#39;-&#39;) {</span>
<span class="line-added">+                             type.append(&quot;? super &quot;);</span>
<span class="line-added">+                             consumed_chars++;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         if (signature.charAt(consumed_chars) == &#39;*&#39;) {</span>
<span class="line-added">+                             type.append(&quot;?&quot;);</span>
<span class="line-added">+                             consumed_chars++;</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));</span>
<span class="line-added">+                             // update our consumed count by the number of characters the for type argument</span>
<span class="line-added">+                             consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;</span>
<span class="line-added">+                             wrap(Utility.consumed_chars, consumed_chars);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // process the closing &quot;&gt;&quot;</span>
<span class="line-added">+                     consumed_chars++;</span>
<span class="line-added">+                     type.append(&quot;&gt;&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (signature.charAt(consumed_chars) == &#39;.&#39;) {</span>
<span class="line-added">+                         // we have a ClassTypeSignatureSuffix</span>
<span class="line-added">+                         type.append(&quot;.&quot;);</span>
<span class="line-added">+                         // convert SimpleClassTypeSignature to fake ClassTypeSignature</span>
<span class="line-added">+                         // and then recurse to parse it</span>
<span class="line-added">+                         type.append(typeSignatureToString(&quot;L&quot; + signature.substring(consumed_chars+1), chopit));</span>
                          // update our consumed count by the number of characters the for type argument
<span class="line-added">+                         // note that this count includes the &quot;L&quot; we added, but that is ok</span>
<span class="line-added">+                         // as it accounts for the &quot;.&quot; we didn&#39;t consume</span>
                          consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;
                          wrap(Utility.consumed_chars, consumed_chars);
<span class="line-added">+                         return type.toString();</span>
                      }
<span class="line-modified">!                     if (signature.charAt(consumed_chars) != &#39;;&#39;) {</span>
                          throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
                      }
<span class="line-modified">!                     wrap(Utility.consumed_chars, consumed_chars + 1); // remove final &quot;;&quot;</span>
<span class="line-modified">!                     return type.toString();</span>
                  }
                  case &#39;S&#39;:
                      return &quot;short&quot;;
                  case &#39;Z&#39;:
                      return &quot;boolean&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 905,11 ***</span>
                      for (n = 0; signature.charAt(n) == &#39;[&#39;; n++) {
                          brackets.append(&quot;[]&quot;);
                      }
                      consumed_chars = n; // Remember value
                      // The rest of the string denotes a `&lt;field_type&gt;&#39;
<span class="line-modified">!                     type = signatureToString(signature.substring(n), chopit);</span>
                      //corrected concurrent private static field acess
                      //Utility.consumed_chars += consumed_chars; is replaced by:
                      final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;
                      wrap(Utility.consumed_chars, _temp);
                      return type + brackets.toString();
<span class="line-new-header">--- 1104,11 ---</span>
                      for (n = 0; signature.charAt(n) == &#39;[&#39;; n++) {
                          brackets.append(&quot;[]&quot;);
                      }
                      consumed_chars = n; // Remember value
                      // The rest of the string denotes a `&lt;field_type&gt;&#39;
<span class="line-modified">!                     type = typeSignatureToString(signature.substring(n), chopit);</span>
                      //corrected concurrent private static field acess
                      //Utility.consumed_chars += consumed_chars; is replaced by:
                      final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;
                      wrap(Utility.consumed_chars, _temp);
                      return type + brackets.toString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 922,26 ***</span>
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid signature: &quot; + signature, e);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Parse Java type such as &quot;char&quot;, or &quot;java.lang.String[]&quot; and return the</span>
<span class="line-modified">!      * signature in byte code format, e.g. &quot;C&quot; or &quot;[Ljava/lang/String;&quot;</span>
<span class="line-removed">-      * respectively.</span>
       *
<span class="line-modified">!      * @param type Java type</span>
       * @return byte code signature
       */
<span class="line-modified">!     public static String getSignature(String type) {</span>
          final StringBuilder buf = new StringBuilder();
          final char[] chars = type.toCharArray();
          boolean char_found = false;
          boolean delim = false;
          int index = -1;
<span class="line-modified">!         loop:</span>
<span class="line-removed">-         for (int i = 0; i &lt; chars.length; i++) {</span>
              switch (chars[i]) {
                  case &#39; &#39;:
                  case &#39;\t&#39;:
                  case &#39;\n&#39;:
                  case &#39;\r&#39;:
<span class="line-new-header">--- 1121,24 ---</span>
          } catch (final StringIndexOutOfBoundsException e) { // Should never occur
              throw new ClassFormatException(&quot;Invalid signature: &quot; + signature, e);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Parse Java type such as &quot;char&quot;, or &quot;java.lang.String[]&quot; and return the</span>
<span class="line-modified">!      * signature in byte code format, e.g. &quot;C&quot; or &quot;[Ljava/lang/String;&quot; respectively.</span>
       *
<span class="line-modified">!      * @param  type Java type</span>
       * @return byte code signature
       */
<span class="line-modified">!     public static String getSignature( String type ) {</span>
          final StringBuilder buf = new StringBuilder();
          final char[] chars = type.toCharArray();
          boolean char_found = false;
          boolean delim = false;
          int index = -1;
<span class="line-modified">!         loop: for (int i = 0; i &lt; chars.length; i++) {</span>
              switch (chars[i]) {
                  case &#39; &#39;:
                  case &#39;\t&#39;:
                  case &#39;\n&#39;:
                  case &#39;\r&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 983,11 ***</span>
              buf.append(&#39;L&#39;).append(type.replace(&#39;.&#39;, &#39;/&#39;)).append(&#39;;&#39;);
          }
          return buf.toString();
      }
  
<span class="line-modified">!     private static int countBrackets(final String brackets) {</span>
          final char[] chars = brackets.toCharArray();
          int count = 0;
          boolean open = false;
          for (final char c : chars) {
              switch (c) {
<span class="line-new-header">--- 1180,12 ---</span>
              buf.append(&#39;L&#39;).append(type.replace(&#39;.&#39;, &#39;/&#39;)).append(&#39;;&#39;);
          }
          return buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private static int countBrackets( final String brackets ) {</span>
          final char[] chars = brackets.toCharArray();
          int count = 0;
          boolean open = false;
          for (final char c : chars) {
              switch (c) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1013,21 ***</span>
              throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
          }
          return count;
      }
  
      /**
<span class="line-modified">!      * Return type of method signature as a byte value as defined in</span>
<span class="line-removed">-      * &lt;em&gt;Constants&lt;/em&gt;</span>
       *
<span class="line-modified">!      * @param signature in format described above</span>
       * @return type of method signature
<span class="line-modified">!      * @see Const</span>
       *
       * @throws ClassFormatException if signature is not a method signature
       */
<span class="line-modified">!     public static byte typeOfMethodSignature(final String signature) throws ClassFormatException {</span>
          int index;
          try {
              if (signature.charAt(0) != &#39;(&#39;) {
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
<span class="line-new-header">--- 1211,21 ---</span>
              throw new RuntimeException(&quot;Illegally nested brackets:&quot; + brackets);
          }
          return count;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return type of method signature as a byte value as defined in &lt;em&gt;Constants&lt;/em&gt;</span>
       *
<span class="line-modified">!      * @param  signature in format described above</span>
       * @return type of method signature
<span class="line-modified">!      * @see    Const</span>
       *
       * @throws ClassFormatException if signature is not a method signature
       */
<span class="line-modified">!     public static byte typeOfMethodSignature( final String signature ) throws ClassFormatException {</span>
          int index;
          try {
              if (signature.charAt(0) != &#39;(&#39;) {
                  throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1036,20 ***</span>
          } catch (final StringIndexOutOfBoundsException e) {
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
      }
  
      /**
       * Return type of signature as a byte value as defined in &lt;em&gt;Constants&lt;/em&gt;
       *
<span class="line-modified">!      * @param signature in format described above</span>
       * @return type of signature
<span class="line-modified">!      * @see Const</span>
       *
       * @throws ClassFormatException if signature isn&#39;t a known type
       */
<span class="line-modified">!     public static byte typeOfSignature(final String signature) throws ClassFormatException {</span>
          try {
              switch (signature.charAt(0)) {
                  case &#39;B&#39;:
                      return Const.T_BYTE;
                  case &#39;C&#39;:
<span class="line-new-header">--- 1234,21 ---</span>
          } catch (final StringIndexOutOfBoundsException e) {
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Return type of signature as a byte value as defined in &lt;em&gt;Constants&lt;/em&gt;
       *
<span class="line-modified">!      * @param  signature in format described above</span>
       * @return type of signature
<span class="line-modified">!      * @see    Const</span>
       *
       * @throws ClassFormatException if signature isn&#39;t a known type
       */
<span class="line-modified">!     public static byte typeOfSignature( final String signature ) throws ClassFormatException {</span>
          try {
              switch (signature.charAt(0)) {
                  case &#39;B&#39;:
                      return Const.T_BYTE;
                  case &#39;C&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1083,40 ***</span>
          } catch (final StringIndexOutOfBoundsException e) {
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Map opcode names to opcode numbers. E.g., return Constants.ALOAD for</span>
<span class="line-removed">-      * &quot;aload&quot;</span>
       */
<span class="line-modified">!     public static short searchOpcode(String name) {</span>
          name = name.toLowerCase(Locale.ENGLISH);
          for (short i = 0; i &lt; Const.OPCODE_NAMES_LENGTH; i++) {
              if (Const.getOpcodeName(i).equals(name)) {
                  return i;
              }
          }
          return -1;
      }
  
      /**
       * Convert (signed) byte to (unsigned) short value, i.e., all negative
       * values become positive.
       */
<span class="line-modified">!     private static short byteToShort(final byte b) {</span>
          return (b &lt; 0) ? (short) (256 + b) : (short) b;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Convert bytes into hexadecimal string</span>
       *
       * @param bytes an array of bytes to convert to hexadecimal
       *
       * @return bytes as hexadecimal string, e.g. 00 fa 12 ...
       */
<span class="line-modified">!     public static String toHexString(final byte[] bytes) {</span>
          final StringBuilder buf = new StringBuilder();
          for (int i = 0; i &lt; bytes.length; i++) {
              final short b = byteToShort(bytes[i]);
              final String hex = Integer.toHexString(b);
              if (b &lt; 0x10) {
<span class="line-new-header">--- 1282,40 ---</span>
          } catch (final StringIndexOutOfBoundsException e) {
              throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for &quot;aload&quot;</span>
       */
<span class="line-modified">!     public static short searchOpcode( String name ) {</span>
          name = name.toLowerCase(Locale.ENGLISH);
          for (short i = 0; i &lt; Const.OPCODE_NAMES_LENGTH; i++) {
              if (Const.getOpcodeName(i).equals(name)) {
                  return i;
              }
          }
          return -1;
      }
  
<span class="line-added">+ </span>
      /**
       * Convert (signed) byte to (unsigned) short value, i.e., all negative
       * values become positive.
       */
<span class="line-modified">!     private static short byteToShort( final byte b ) {</span>
          return (b &lt; 0) ? (short) (256 + b) : (short) b;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Convert bytes into hexadecimal string</span>
       *
       * @param bytes an array of bytes to convert to hexadecimal
       *
       * @return bytes as hexadecimal string, e.g. 00 fa 12 ...
       */
<span class="line-modified">!     public static String toHexString( final byte[] bytes ) {</span>
          final StringBuilder buf = new StringBuilder();
          for (int i = 0; i &lt; bytes.length; i++) {
              final short b = byteToShort(bytes[i]);
              final String hex = Integer.toHexString(b);
              if (b &lt; 0x10) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1128,37 ***</span>
              }
          }
          return buf.toString();
      }
  
      /**
       * Return a string for an integer justified left or right and filled up with
       * `fill&#39; characters if necessary.
       *
       * @param i integer to format
       * @param length length of desired string
       * @param left_justify format left or right
       * @param fill fill character
       * @return formatted int
       */
<span class="line-modified">!     public static String format(final int i, final int length,</span>
<span class="line-removed">-             final boolean left_justify, final char fill) {</span>
          return fillup(Integer.toString(i), length, left_justify, fill);
      }
  
      /**
<span class="line-modified">!      * Fillup char with up to length characters with char `fill&#39; and justify it</span>
<span class="line-removed">-      * left or right.</span>
       *
       * @param str string to format
       * @param length length of desired string
       * @param left_justify format left or right
       * @param fill fill character
       * @return formatted string
       */
<span class="line-modified">!     public static String fillup(final String str, final int length,</span>
<span class="line-removed">-             final boolean left_justify, final char fill) {</span>
          final int len = length - str.length();
          final char[] buf = new char[(len &lt; 0) ? 0 : len];
          for (int j = 0; j &lt; buf.length; j++) {
              buf[j] = fill;
          }
<span class="line-new-header">--- 1327,36 ---</span>
              }
          }
          return buf.toString();
      }
  
<span class="line-added">+ </span>
      /**
       * Return a string for an integer justified left or right and filled up with
       * `fill&#39; characters if necessary.
       *
       * @param i integer to format
       * @param length length of desired string
       * @param left_justify format left or right
       * @param fill fill character
       * @return formatted int
       */
<span class="line-modified">!     public static String format( final int i, final int length, final boolean left_justify, final char fill ) {</span>
          return fillup(Integer.toString(i), length, left_justify, fill);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Fillup char with up to length characters with char `fill&#39; and justify it left or right.</span>
       *
       * @param str string to format
       * @param length length of desired string
       * @param left_justify format left or right
       * @param fill fill character
       * @return formatted string
       */
<span class="line-modified">!     public static String fillup( final String str, final int length, final boolean left_justify, final char fill ) {</span>
          final int len = length - str.length();
          final char[] buf = new char[(len &lt; 0) ? 0 : len];
          for (int j = 0; j &lt; buf.length; j++) {
              buf[j] = fill;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1166,11 ***</span>
              return str + new String(buf);
          }
          return new String(buf) + str;
      }
  
<span class="line-modified">!     static boolean equals(final byte[] a, final byte[] b) {</span>
          int size;
          if ((size = a.length) != b.length) {
              return false;
          }
          for (int i = 0; i &lt; size; i++) {
<span class="line-new-header">--- 1364,12 ---</span>
              return str + new String(buf);
          }
          return new String(buf) + str;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     static boolean equals( final byte[] a, final byte[] b ) {</span>
          int size;
          if ((size = a.length) != b.length) {
              return false;
          }
          for (int i = 0; i &lt; size; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1179,27 ***</span>
              }
          }
          return true;
      }
  
<span class="line-modified">!     public static void printArray(final PrintStream out, final Object[] obj) {</span>
          out.println(printArray(obj, true));
      }
  
<span class="line-modified">!     public static void printArray(final PrintWriter out, final Object[] obj) {</span>
          out.println(printArray(obj, true));
      }
  
<span class="line-modified">!     public static String printArray(final Object[] obj) {</span>
          return printArray(obj, true);
      }
  
<span class="line-modified">!     public static String printArray(final Object[] obj, final boolean braces) {</span>
          return printArray(obj, braces, false);
      }
  
<span class="line-modified">!     public static String printArray(final Object[] obj, final boolean braces, final boolean quote) {</span>
          if (obj == null) {
              return null;
          }
          final StringBuilder buf = new StringBuilder();
          if (braces) {
<span class="line-new-header">--- 1378,32 ---</span>
              }
          }
          return true;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public static void printArray( final PrintStream out, final Object[] obj ) {</span>
          out.println(printArray(obj, true));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public static void printArray( final PrintWriter out, final Object[] obj ) {</span>
          out.println(printArray(obj, true));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public static String printArray( final Object[] obj ) {</span>
          return printArray(obj, true);
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public static String printArray( final Object[] obj, final boolean braces ) {</span>
          return printArray(obj, braces, false);
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public static String printArray( final Object[] obj, final boolean braces, final boolean quote ) {</span>
          if (obj == null) {
              return null;
          }
          final StringBuilder buf = new StringBuilder();
          if (braces) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1219,36 ***</span>
              buf.append(&#39;}&#39;);
          }
          return buf.toString();
      }
  
      /**
       * @param ch the character to test if it&#39;s part of an identifier
       *
       * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)
       */
<span class="line-modified">!     public static boolean isJavaIdentifierPart(final char ch) {</span>
          return ((ch &gt;= &#39;a&#39;) &amp;&amp; (ch &lt;= &#39;z&#39;)) || ((ch &gt;= &#39;A&#39;) &amp;&amp; (ch &lt;= &#39;Z&#39;))
                  || ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) || (ch == &#39;_&#39;);
      }
  
      /**
<span class="line-modified">!      * Encode byte array it into Java identifier string, i.e., a string that</span>
<span class="line-modified">!      * only contains the following characters: (a, ... z, A, ... Z, 0, ... 9, _,</span>
<span class="line-modified">!      * $). The encoding algorithm itself is not too clever: if the current</span>
<span class="line-modified">!      * byte&#39;s ASCII value already is a valid Java identifier part, leave it as</span>
<span class="line-modified">!      * it is. Otherwise it writes the escape character($) followed by:</span>
       *
       * &lt;ul&gt;
<span class="line-modified">!      * &lt;li&gt; the ASCII value as a hexadecimal string, if the value is not in the</span>
<span class="line-modified">!      * range 200..247&lt;/li&gt;</span>
<span class="line-removed">-      * &lt;li&gt;a Java identifier char not used in a lowercase hexadecimal string, if</span>
<span class="line-removed">-      * the value is in the range 200..247&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-removed">-      * This operation inflates the original byte array by roughly 40-50%&lt;/p&gt;</span>
       *
       * @param bytes the byte array to convert
       * @param compress use gzip to minimize string
       *
       * @throws IOException if there&#39;s a gzip exception
<span class="line-new-header">--- 1423,36 ---</span>
              buf.append(&#39;}&#39;);
          }
          return buf.toString();
      }
  
<span class="line-added">+ </span>
      /**
       * @param ch the character to test if it&#39;s part of an identifier
       *
       * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)
       */
<span class="line-modified">!     public static boolean isJavaIdentifierPart( final char ch ) {</span>
          return ((ch &gt;= &#39;a&#39;) &amp;&amp; (ch &lt;= &#39;z&#39;)) || ((ch &gt;= &#39;A&#39;) &amp;&amp; (ch &lt;= &#39;Z&#39;))
                  || ((ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;)) || (ch == &#39;_&#39;);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Encode byte array it into Java identifier string, i.e., a string</span>
<span class="line-modified">!      * that only contains the following characters: (a, ... z, A, ... Z,</span>
<span class="line-modified">!      * 0, ... 9, _, $).  The encoding algorithm itself is not too</span>
<span class="line-modified">!      * clever: if the current byte&#39;s ASCII value already is a valid Java</span>
<span class="line-modified">!      * identifier part, leave it as it is. Otherwise it writes the</span>
<span class="line-added">+      * escape character($) followed by:</span>
       *
       * &lt;ul&gt;
<span class="line-modified">!      *   &lt;li&gt; the ASCII value as a hexadecimal string, if the value is not in the range 200..247&lt;/li&gt;</span>
<span class="line-modified">!      *   &lt;li&gt;a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247&lt;/li&gt;</span>
       * &lt;/ul&gt;
       *
<span class="line-modified">!      * &lt;p&gt;This operation inflates the original byte array by roughly 40-50%&lt;/p&gt;</span>
       *
       * @param bytes the byte array to convert
       * @param compress use gzip to minimize string
       *
       * @throws IOException if there&#39;s a gzip exception
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1269,10 ***</span>
<span class="line-new-header">--- 1473,11 ---</span>
              }
          }
          return caw.toString();
      }
  
<span class="line-added">+ </span>
      /**
       * Decode a string back to a byte array.
       *
       * @param s the string to convert
       * @param uncompress use gzip to uncompress the stream of bytes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1306,11 ***</span>
      // A-Z, g-z, _, $
      private static final int FREE_CHARS = 48;
      private static int[] CHAR_MAP = new int[FREE_CHARS];
      private static int[] MAP_CHAR = new int[256]; // Reverse map
      private static final char ESCAPE_CHAR = &#39;$&#39;;
<span class="line-removed">- </span>
      static {
          int j = 0;
          for (int i = &#39;A&#39;; i &lt;= &#39;Z&#39;; i++) {
              CHAR_MAP[j] = i;
              MAP_CHAR[i] = j;
<span class="line-new-header">--- 1511,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1327,19 ***</span>
          CHAR_MAP[j] = &#39;_&#39;;
          MAP_CHAR[&#39;_&#39;] = j;
      }
  
      /**
<span class="line-modified">!      * Decode characters into bytes. Used by &lt;a</span>
<span class="line-modified">!      * href=&quot;Utility.html#decode(java.lang.String, boolean)&quot;&gt;decode()&lt;/a&gt;</span>
       */
      private static class JavaReader extends FilterReader {
  
          public JavaReader(final Reader in) {
              super(in);
          }
  
          @Override
          public int read() throws IOException {
              final int b = in.read();
              if (b != ESCAPE_CHAR) {
                  return b;
<span class="line-new-header">--- 1531,20 ---</span>
          CHAR_MAP[j] = &#39;_&#39;;
          MAP_CHAR[&#39;_&#39;] = j;
      }
  
      /**
<span class="line-modified">!      * Decode characters into bytes.</span>
<span class="line-modified">!      * Used by &lt;a href=&quot;Utility.html#decode(java.lang.String, boolean)&quot;&gt;decode()&lt;/a&gt;</span>
       */
      private static class JavaReader extends FilterReader {
  
          public JavaReader(final Reader in) {
              super(in);
          }
  
<span class="line-added">+ </span>
          @Override
          public int read() throws IOException {
              final int b = in.read();
              if (b != ESCAPE_CHAR) {
                  return b;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1352,39 ***</span>
                  final int j = in.read();
                  if (j &lt; 0) {
                      return -1;
                  }
                  final char[] tmp = {
<span class="line-modified">!                     (char) i, (char) j</span>
                  };
                  final int s = Integer.parseInt(new String(tmp), 16);
                  return s;
              }
              return MAP_CHAR[i];
          }
  
          @Override
<span class="line-modified">!         public int read(final char[] cbuf, final int off, final int len) throws IOException {</span>
              for (int i = 0; i &lt; len; i++) {
                  cbuf[off + i] = (char) read();
              }
              return len;
          }
      }
  
      /**
<span class="line-modified">!      * Encode bytes into valid java identifier characters. Used by &lt;a</span>
<span class="line-modified">!      * href=&quot;Utility.html#encode(byte[], boolean)&quot;&gt;encode()&lt;/a&gt;</span>
       */
      private static class JavaWriter extends FilterWriter {
  
          public JavaWriter(final Writer out) {
              super(out);
          }
  
          @Override
<span class="line-modified">!         public void write(final int b) throws IOException {</span>
              if (isJavaIdentifierPart((char) b) &amp;&amp; (b != ESCAPE_CHAR)) {
                  out.write(b);
              } else {
                  out.write(ESCAPE_CHAR); // Escape character
                  // Special escape
<span class="line-new-header">--- 1557,41 ---</span>
                  final int j = in.read();
                  if (j &lt; 0) {
                      return -1;
                  }
                  final char[] tmp = {
<span class="line-modified">!                         (char) i, (char) j</span>
                  };
                  final int s = Integer.parseInt(new String(tmp), 16);
                  return s;
              }
              return MAP_CHAR[i];
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public int read( final char[] cbuf, final int off, final int len ) throws IOException {</span>
              for (int i = 0; i &lt; len; i++) {
                  cbuf[off + i] = (char) read();
              }
              return len;
          }
      }
  
      /**
<span class="line-modified">!      * Encode bytes into valid java identifier characters.</span>
<span class="line-modified">!      * Used by &lt;a href=&quot;Utility.html#encode(byte[], boolean)&quot;&gt;encode()&lt;/a&gt;</span>
       */
      private static class JavaWriter extends FilterWriter {
  
          public JavaWriter(final Writer out) {
              super(out);
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public void write( final int b ) throws IOException {</span>
              if (isJavaIdentifierPart((char) b) &amp;&amp; (b != ESCAPE_CHAR)) {
                  out.write(b);
              } else {
                  out.write(ESCAPE_CHAR); // Escape character
                  // Special escape
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1401,27 ***</span>
                      }
                  }
              }
          }
  
          @Override
<span class="line-modified">!         public void write(final char[] cbuf, final int off, final int len) throws IOException {</span>
              for (int i = 0; i &lt; len; i++) {
                  write(cbuf[off + i]);
              }
          }
  
          @Override
<span class="line-modified">!         public void write(final String str, final int off, final int len) throws IOException {</span>
              write(str.toCharArray(), off, len);
          }
      }
  
      /**
       * Escape all occurences of newline chars &#39;\n&#39;, quotes \&quot;, etc.
       */
<span class="line-modified">!     public static String convertString(final String label) {</span>
          final char[] ch = label.toCharArray();
          final StringBuilder buf = new StringBuilder();
          for (final char element : ch) {
              switch (element) {
                  case &#39;\n&#39;:
<span class="line-new-header">--- 1608,30 ---</span>
                      }
                  }
              }
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public void write( final char[] cbuf, final int off, final int len ) throws IOException {</span>
              for (int i = 0; i &lt; len; i++) {
                  write(cbuf[off + i]);
              }
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public void write( final String str, final int off, final int len ) throws IOException {</span>
              write(str.toCharArray(), off, len);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Escape all occurences of newline chars &#39;\n&#39;, quotes \&quot;, etc.
       */
<span class="line-modified">!     public static String convertString( final String label ) {</span>
          final char[] ch = label.toCharArray();
          final StringBuilder buf = new StringBuilder();
          for (final char element : ch) {
              switch (element) {
                  case &#39;\n&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1444,6 ***</span>
<span class="line-new-header">--- 1654,7 ---</span>
                      break;
              }
          }
          return buf.toString();
      }
<span class="line-added">+ </span>
  }
</pre>
<center><a href="UnknownAttributeReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="Visitor.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
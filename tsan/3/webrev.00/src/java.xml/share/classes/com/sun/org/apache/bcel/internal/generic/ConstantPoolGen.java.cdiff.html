<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompoundInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantPushInstruction.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,20 ***</span>
  import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
  import com.sun.org.apache.bcel.internal.classfile.ConstantString;
  import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
  
  /**
<span class="line-modified">!  * This class is used to build up a constant pool. The user adds constants via</span>
<span class="line-modified">!  * `addXXX&#39; methods, `addString&#39;, `addClass&#39;, etc.. These methods return an</span>
<span class="line-modified">!  * index into the constant pool. Finally, `getFinalConstantPool()&#39; returns the</span>
<span class="line-modified">!  * constant pool built up. Intermediate versions of the constant pool can be</span>
   * obtained with `getConstantPool()&#39;. A constant pool has capacity for
<span class="line-modified">!  * Constants.MAX_SHORT entries. Note that the first (0) is used by the JVM and</span>
<span class="line-modified">!  * that Double and Long constants need two slots.</span>
   *
<span class="line-removed">-  * @version $Id: ConstantPoolGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   * @see Constant
   */
  public class ConstantPoolGen {
  
      private static final int DEFAULT_BUFFER_SIZE = 256;
      private int size;
<span class="line-new-header">--- 38,21 ---</span>
  import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
  import com.sun.org.apache.bcel.internal.classfile.ConstantString;
  import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
  
  /**
<span class="line-modified">!  * This class is used to build up a constant pool. The user adds</span>
<span class="line-modified">!  * constants via `addXXX&#39; methods, `addString&#39;, `addClass&#39;,</span>
<span class="line-modified">!  * etc.. These methods return an index into the constant</span>
<span class="line-modified">!  * pool. Finally, `getFinalConstantPool()&#39; returns the constant pool</span>
<span class="line-added">+  * built up. Intermediate versions of the constant pool can be</span>
   * obtained with `getConstantPool()&#39;. A constant pool has capacity for
<span class="line-modified">!  * Constants.MAX_SHORT entries. Note that the first (0) is used by the</span>
<span class="line-modified">!  * JVM and that Double and Long constants need two slots.</span>
   *
   * @see Constant
<span class="line-added">+  * @LastModified: Jan 2020</span>
   */
  public class ConstantPoolGen {
  
      private static final int DEFAULT_BUFFER_SIZE = 256;
      private int size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,15 ***</span>
<span class="line-new-header">--- 66,17 ---</span>
  
      private static class Index {
  
          final int index;
  
<span class="line-added">+ </span>
          Index(final int i) {
              index = i;
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Initialize with given array of constants.
       *
       * @param cs array of given constants, new ones will be appended
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,10 ***</span>
<span class="line-new-header">--- 89,11 ---</span>
          System.arraycopy(cs, 0, constants, 0, cs.length);
          if (cs.length &gt; 0) {
              index = cs.length;
          }
  
<span class="line-added">+ </span>
          for (int i = 1; i &lt; index; i++) {
              final Constant c = constants[i];
              if (c instanceof ConstantString) {
                  final ConstantString s = (ConstantString) c;
                  final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,11 ***</span>
                  if (c instanceof ConstantInvokeDynamic) {
                      class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());
                      // since name can&#39;t begin with digit, can  use
                      // METHODREF_DELIM with out fear of duplicates.
                  } else {
<span class="line-modified">!                     final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];</span>
                      u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
                      class_name = u8.getBytes().replace(&#39;/&#39;, &#39;.&#39;);
                  }
  
                  final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
<span class="line-new-header">--- 136,11 ---</span>
                  if (c instanceof ConstantInvokeDynamic) {
                      class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());
                      // since name can&#39;t begin with digit, can  use
                      // METHODREF_DELIM with out fear of duplicates.
                  } else {
<span class="line-modified">!                 final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];</span>
                      u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
                      class_name = u8.getBytes().replace(&#39;/&#39;, &#39;.&#39;);
                  }
  
                  final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,33 ***</span>
                  // nothing to do
              } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {
                  // TODO should this be handled somehow?
              } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {
                  // TODO should this be handled somehow?
              } else {
                  assert false : &quot;Unexpected constant type: &quot; + c.getClass().getName();
              }
          }
      }
  
      /**
       * Initialize with given constant pool.
       */
      public ConstantPoolGen(final ConstantPool cp) {
          this(cp.getConstantPool());
      }
  
      /**
       * Create empty constant pool.
       */
      public ConstantPoolGen() {
          size = DEFAULT_BUFFER_SIZE;
          constants = new Constant[size];
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Resize internal array of constants.</span>
       */
      protected void adjustSize() {
          if (index + 3 &gt;= size) {
              final Constant[] cs = constants;
              size *= 2;
<span class="line-new-header">--- 179,39 ---</span>
                  // nothing to do
              } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {
                  // TODO should this be handled somehow?
              } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {
                  // TODO should this be handled somehow?
<span class="line-added">+             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {</span>
<span class="line-added">+                 // TODO should this be handled somehow?</span>
<span class="line-added">+             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {</span>
<span class="line-added">+                 // TODO should this be handled somehow?</span>
              } else {
                  assert false : &quot;Unexpected constant type: &quot; + c.getClass().getName();
              }
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Initialize with given constant pool.
       */
      public ConstantPoolGen(final ConstantPool cp) {
          this(cp.getConstantPool());
      }
  
<span class="line-added">+ </span>
      /**
       * Create empty constant pool.
       */
      public ConstantPoolGen() {
          size = DEFAULT_BUFFER_SIZE;
          constants = new Constant[size];
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Resize internal array of constants.</span>
       */
      protected void adjustSize() {
          if (index + 3 &gt;= size) {
              final Constant[] cs = constants;
              size *= 2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,29 ***</span>
          }
      }
  
      private final Map&lt;String, Index&gt; string_table = new HashMap&lt;&gt;();
  
      /**
       * Look for ConstantString in ConstantPool containing String `str&#39;.
       *
       * @param str String to search for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupString(final String str) {</span>
          final Index index = string_table.get(str);
          return (index != null) ? index.index : -1;
      }
  
      /**
<span class="line-modified">!      * Add a new String constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">-      * there.</span>
       *
       * @param str String to add
       * @return index of entry
       */
<span class="line-modified">!     public int addString(final String str) {</span>
          int ret;
          if ((ret = lookupString(str)) != -1) {
              return ret; // Already in CP
          }
          final int utf8 = addUtf8(str);
<span class="line-new-header">--- 220,30 ---</span>
          }
      }
  
      private final Map&lt;String, Index&gt; string_table = new HashMap&lt;&gt;();
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantString in ConstantPool containing String `str&#39;.
       *
       * @param str String to search for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupString( final String str ) {</span>
          final Index index = string_table.get(str);
          return (index != null) ? index.index : -1;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new String constant to the ConstantPool, if it is not already in there.</span>
       *
       * @param str String to add
       * @return index of entry
       */
<span class="line-modified">!     public int addString( final String str ) {</span>
          int ret;
          if ((ret = lookupString(str)) != -1) {
              return ret; // Already in CP
          }
          final int utf8 = addUtf8(str);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,22 ***</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; class_table = new HashMap&lt;&gt;();
  
      /**
       * Look for ConstantClass in ConstantPool named `str&#39;.
       *
       * @param str String to search for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupClass(final String str) {</span>
          final Index index = class_table.get(str.replace(&#39;.&#39;, &#39;/&#39;));
          return (index != null) ? index.index : -1;
      }
  
<span class="line-modified">!     private int addClass_(final String clazz) {</span>
          int ret;
          if ((ret = lookupClass(clazz)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
<span class="line-new-header">--- 257,24 ---</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; class_table = new HashMap&lt;&gt;();
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantClass in ConstantPool named `str&#39;.
       *
       * @param str String to search for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupClass( final String str ) {</span>
          final Index index = class_table.get(str.replace(&#39;.&#39;, &#39;/&#39;));
          return (index != null) ? index.index : -1;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private int addClass_( final String clazz ) {</span>
          int ret;
          if ((ret = lookupClass(clazz)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,49 ***</span>
              class_table.put(clazz, new Index(ret));
          }
          return ret;
      }
  
      /**
<span class="line-modified">!      * Add a new Class reference to the ConstantPool, if it is not already in</span>
<span class="line-removed">-      * there.</span>
       *
       * @param str Class to add
       * @return index of entry
       */
<span class="line-modified">!     public int addClass(final String str) {</span>
          return addClass_(str.replace(&#39;.&#39;, &#39;/&#39;));
      }
  
      /**
       * Add a new Class reference to the ConstantPool for a given type.
       *
       * @param type Class to add
       * @return index of entry
       */
<span class="line-modified">!     public int addClass(final ObjectType type) {</span>
          return addClass(type.getClassName());
      }
  
      /**
<span class="line-modified">!      * Add a reference to an array class (e.g. String[][]) as needed by</span>
<span class="line-modified">!      * MULTIANEWARRAY instruction, e.g. to the ConstantPool.</span>
       *
       * @param type type of array class
       * @return index of entry
       */
<span class="line-modified">!     public int addArrayClass(final ArrayType type) {</span>
          return addClass_(type.getSignature());
      }
  
      /**
       * Look for ConstantInteger in ConstantPool.
       *
       * @param n integer number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupInteger(final int n) {</span>
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantInteger) {
                  final ConstantInteger c = (ConstantInteger) constants[i];
                  if (c.getBytes() == n) {
                      return i;
<span class="line-new-header">--- 285,52 ---</span>
              class_table.put(clazz, new Index(ret));
          }
          return ret;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new Class reference to the ConstantPool, if it is not already in there.</span>
       *
       * @param str Class to add
       * @return index of entry
       */
<span class="line-modified">!     public int addClass( final String str ) {</span>
          return addClass_(str.replace(&#39;.&#39;, &#39;/&#39;));
      }
  
<span class="line-added">+ </span>
      /**
       * Add a new Class reference to the ConstantPool for a given type.
       *
       * @param type Class to add
       * @return index of entry
       */
<span class="line-modified">!     public int addClass( final ObjectType type ) {</span>
          return addClass(type.getClassName());
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY</span>
<span class="line-modified">!      * instruction, e.g. to the ConstantPool.</span>
       *
       * @param type type of array class
       * @return index of entry
       */
<span class="line-modified">!     public int addArrayClass( final ArrayType type ) {</span>
          return addClass_(type.getSignature());
      }
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantInteger in ConstantPool.
       *
       * @param n integer number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupInteger( final int n ) {</span>
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantInteger) {
                  final ConstantInteger c = (ConstantInteger) constants[i];
                  if (c.getBytes() == n) {
                      return i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,35 ***</span>
              }
          }
          return -1;
      }
  
      /**
<span class="line-modified">!      * Add a new Integer constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">-      * there.</span>
       *
       * @param n integer number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addInteger(final int n) {</span>
          int ret;
          if ((ret = lookupInteger(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
          ret = index;
          constants[index++] = new ConstantInteger(n);
          return ret;
      }
  
      /**
       * Look for ConstantFloat in ConstantPool.
       *
       * @param n Float number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupFloat(final float n) {</span>
          final int bits = Float.floatToIntBits(n);
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantFloat) {
                  final ConstantFloat c = (ConstantFloat) constants[i];
                  if (Float.floatToIntBits(c.getBytes()) == bits) {
<span class="line-new-header">--- 338,36 ---</span>
              }
          }
          return -1;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new Integer constant to the ConstantPool, if it is not already in there.</span>
       *
       * @param n integer number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addInteger( final int n ) {</span>
          int ret;
          if ((ret = lookupInteger(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
          ret = index;
          constants[index++] = new ConstantInteger(n);
          return ret;
      }
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantFloat in ConstantPool.
       *
       * @param n Float number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupFloat( final float n ) {</span>
          final int bits = Float.floatToIntBits(n);
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantFloat) {
                  final ConstantFloat c = (ConstantFloat) constants[i];
                  if (Float.floatToIntBits(c.getBytes()) == bits) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 359,18 ***</span>
              }
          }
          return -1;
      }
  
      /**
<span class="line-modified">!      * Add a new Float constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">-      * there.</span>
       *
       * @param n Float number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addFloat(final float n) {</span>
          int ret;
          if ((ret = lookupFloat(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
<span class="line-new-header">--- 376,18 ---</span>
              }
          }
          return -1;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new Float constant to the ConstantPool, if it is not already in there.</span>
       *
       * @param n Float number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addFloat( final float n ) {</span>
          int ret;
          if ((ret = lookupFloat(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,29 ***</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; utf8_table = new HashMap&lt;&gt;();
  
      /**
       * Look for ConstantUtf8 in ConstantPool.
       *
       * @param n Utf8 string to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupUtf8(final String n) {</span>
          final Index index = utf8_table.get(n);
          return (index != null) ? index.index : -1;
      }
  
      /**
<span class="line-modified">!      * Add a new Utf8 constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">-      * there.</span>
       *
       * @param n Utf8 string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addUtf8(final String n) {</span>
          int ret;
          if ((ret = lookupUtf8(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
<span class="line-new-header">--- 396,30 ---</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; utf8_table = new HashMap&lt;&gt;();
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantUtf8 in ConstantPool.
       *
       * @param n Utf8 string to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupUtf8( final String n ) {</span>
          final Index index = utf8_table.get(n);
          return (index != null) ? index.index : -1;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new Utf8 constant to the ConstantPool, if it is not already in there.</span>
       *
       * @param n Utf8 string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addUtf8( final String n ) {</span>
          int ret;
          if ((ret = lookupUtf8(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,17 ***</span>
              utf8_table.put(n, new Index(ret));
          }
          return ret;
      }
  
      /**
       * Look for ConstantLong in ConstantPool.
       *
       * @param n Long number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupLong(final long n) {</span>
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantLong) {
                  final ConstantLong c = (ConstantLong) constants[i];
                  if (c.getBytes() == n) {
                      return i;
<span class="line-new-header">--- 429,18 ---</span>
              utf8_table.put(n, new Index(ret));
          }
          return ret;
      }
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantLong in ConstantPool.
       *
       * @param n Long number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupLong( final long n ) {</span>
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantLong) {
                  final ConstantLong c = (ConstantLong) constants[i];
                  if (c.getBytes() == n) {
                      return i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,18 ***</span>
              }
          }
          return -1;
      }
  
      /**
<span class="line-modified">!      * Add a new long constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">-      * there.</span>
       *
       * @param n Long number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addLong(final long n) {</span>
          int ret;
          if ((ret = lookupLong(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
<span class="line-new-header">--- 448,18 ---</span>
              }
          }
          return -1;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new long constant to the ConstantPool, if it is not already in there.</span>
       *
       * @param n Long number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addLong( final long n ) {</span>
          int ret;
          if ((ret = lookupLong(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 448,17 ***</span>
          constants[index] = new ConstantLong(n);
          index += 2; // Wastes one entry according to spec
          return ret;
      }
  
      /**
       * Look for ConstantDouble in ConstantPool.
       *
       * @param n Double number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupDouble(final double n) {</span>
          final long bits = Double.doubleToLongBits(n);
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantDouble) {
                  final ConstantDouble c = (ConstantDouble) constants[i];
                  if (Double.doubleToLongBits(c.getBytes()) == bits) {
<span class="line-new-header">--- 467,18 ---</span>
          constants[index] = new ConstantLong(n);
          index += 2; // Wastes one entry according to spec
          return ret;
      }
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantDouble in ConstantPool.
       *
       * @param n Double number to look for
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupDouble( final double n ) {</span>
          final long bits = Double.doubleToLongBits(n);
          for (int i = 1; i &lt; index; i++) {
              if (constants[i] instanceof ConstantDouble) {
                  final ConstantDouble c = (ConstantDouble) constants[i];
                  if (Double.doubleToLongBits(c.getBytes()) == bits) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 467,18 ***</span>
              }
          }
          return -1;
      }
  
      /**
<span class="line-modified">!      * Add a new double constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">-      * there.</span>
       *
       * @param n Double number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addDouble(final double n) {</span>
          int ret;
          if ((ret = lookupDouble(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
<span class="line-new-header">--- 487,18 ---</span>
              }
          }
          return -1;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new double constant to the ConstantPool, if it is not already in there.</span>
       *
       * @param n Double number to add
       * @return index of entry
       */
<span class="line-modified">!     public int addDouble( final double n ) {</span>
          int ret;
          if ((ret = lookupDouble(n)) != -1) {
              return ret; // Already in CP
          }
          adjustSize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,31 ***</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; n_a_t_table = new HashMap&lt;&gt;();
  
      /**
       * Look for ConstantNameAndType in ConstantPool.
       *
       * @param name of variable/method
       * @param signature of variable/method
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupNameAndType(final String name, final String signature) {</span>
          final Index _index = n_a_t_table.get(name + NAT_DELIM + signature);
          return (_index != null) ? _index.index : -1;
      }
  
      /**
       * Add a new NameAndType constant to the ConstantPool if it is not already
       * in there.
       *
       * @param name Name string to add
       * @param signature signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addNameAndType(final String name, final String signature) {</span>
          int ret;
          int name_index;
          int signature_index;
          if ((ret = lookupNameAndType(name, signature)) != -1) {
              return ret; // Already in CP
<span class="line-new-header">--- 508,33 ---</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; n_a_t_table = new HashMap&lt;&gt;();
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantNameAndType in ConstantPool.
       *
       * @param name of variable/method
       * @param signature of variable/method
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupNameAndType( final String name, final String signature ) {</span>
          final Index _index = n_a_t_table.get(name + NAT_DELIM + signature);
          return (_index != null) ? _index.index : -1;
      }
  
<span class="line-added">+ </span>
      /**
       * Add a new NameAndType constant to the ConstantPool if it is not already
       * in there.
       *
       * @param name Name string to add
       * @param signature signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addNameAndType( final String name, final String signature ) {</span>
          int ret;
          int name_index;
          int signature_index;
          if ((ret = lookupNameAndType(name, signature)) != -1) {
              return ret; // Already in CP
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,38 ***</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; cp_table = new HashMap&lt;&gt;();
  
      /**
       * Look for ConstantMethodref in ConstantPool.
       *
       * @param class_name Where to find method
       * @param method_name Guess what
       * @param signature return and argument types
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupMethodref(final String class_name, final String method_name, final String signature) {</span>
          final Index index = cp_table.get(class_name + METHODREF_DELIM + method_name
                  + METHODREF_DELIM + signature);
          return (index != null) ? index.index : -1;
      }
  
<span class="line-modified">!     public int lookupMethodref(final MethodGen method) {</span>
          return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());
      }
  
      /**
<span class="line-modified">!      * Add a new Methodref constant to the ConstantPool, if it is not already in</span>
<span class="line-modified">!      * there.</span>
       *
       * @param class_name class name string to add
       * @param method_name method name string to add
       * @param signature method signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addMethodref(final String class_name, final String method_name, final String signature) {</span>
          int ret;
          int class_index;
          int name_and_type_index;
          if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {
              return ret; // Already in CP
<span class="line-new-header">--- 551,41 ---</span>
          return ret;
      }
  
      private final Map&lt;String, Index&gt; cp_table = new HashMap&lt;&gt;();
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantMethodref in ConstantPool.
       *
       * @param class_name Where to find method
       * @param method_name Guess what
       * @param signature return and argument types
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupMethodref( final String class_name, final String method_name, final String signature ) {</span>
          final Index index = cp_table.get(class_name + METHODREF_DELIM + method_name
                  + METHODREF_DELIM + signature);
          return (index != null) ? index.index : -1;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public int lookupMethodref( final MethodGen method ) {</span>
          return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new Methodref constant to the ConstantPool, if it is not already</span>
<span class="line-modified">!      * in there.</span>
       *
       * @param class_name class name string to add
       * @param method_name method name string to add
       * @param signature method signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addMethodref( final String class_name, final String method_name, final String signature ) {</span>
          int ret;
          int class_index;
          int name_and_type_index;
          if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {
              return ret; // Already in CP
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,43 ***</span>
              cp_table.put(key, new Index(ret));
          }
          return ret;
      }
  
<span class="line-modified">!     public int addMethodref(final MethodGen method) {</span>
          return addMethodref(method.getClassName(), method.getName(), method.getSignature());
      }
  
      /**
       * Look for ConstantInterfaceMethodref in ConstantPool.
       *
       * @param class_name Where to find method
       * @param method_name Guess what
       * @param signature return and argument types
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupInterfaceMethodref(final String class_name, final String method_name, final String signature) {</span>
          final Index index = cp_table.get(class_name + IMETHODREF_DELIM + method_name
                  + IMETHODREF_DELIM + signature);
          return (index != null) ? index.index : -1;
      }
  
<span class="line-modified">!     public int lookupInterfaceMethodref(final MethodGen method) {</span>
          return lookupInterfaceMethodref(method.getClassName(), method.getName(), method
                  .getSignature());
      }
  
      /**
<span class="line-modified">!      * Add a new InterfaceMethodref constant to the ConstantPool, if it is not</span>
<span class="line-modified">!      * already in there.</span>
       *
       * @param class_name class name string to add
       * @param method_name method name string to add
       * @param signature signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addInterfaceMethodref(final String class_name, final String method_name, final String signature) {</span>
          int ret;
          int class_index;
          int name_and_type_index;
          if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {
              return ret; // Already in CP
<span class="line-new-header">--- 600,47 ---</span>
              cp_table.put(key, new Index(ret));
          }
          return ret;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public int addMethodref( final MethodGen method ) {</span>
          return addMethodref(method.getClassName(), method.getName(), method.getSignature());
      }
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantInterfaceMethodref in ConstantPool.
       *
       * @param class_name Where to find method
       * @param method_name Guess what
       * @param signature return and argument types
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupInterfaceMethodref( final String class_name, final String method_name, final String signature ) {</span>
          final Index index = cp_table.get(class_name + IMETHODREF_DELIM + method_name
                  + IMETHODREF_DELIM + signature);
          return (index != null) ? index.index : -1;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public int lookupInterfaceMethodref( final MethodGen method ) {</span>
          return lookupInterfaceMethodref(method.getClassName(), method.getName(), method
                  .getSignature());
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already</span>
<span class="line-modified">!      * in there.</span>
       *
       * @param class_name class name string to add
       * @param method_name method name string to add
       * @param signature signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addInterfaceMethodref( final String class_name, final String method_name, final String signature ) {</span>
          int ret;
          int class_index;
          int name_and_type_index;
          if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {
              return ret; // Already in CP
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,38 ***</span>
              cp_table.put(key, new Index(ret));
          }
          return ret;
      }
  
<span class="line-modified">!     public int addInterfaceMethodref(final MethodGen method) {</span>
          return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());
      }
  
      /**
       * Look for ConstantFieldref in ConstantPool.
       *
       * @param class_name Where to find method
       * @param field_name Guess what
       * @param signature return and argument types
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupFieldref(final String class_name, final String field_name, final String signature) {</span>
          final Index index = cp_table.get(class_name + FIELDREF_DELIM + field_name
                  + FIELDREF_DELIM + signature);
          return (index != null) ? index.index : -1;
      }
  
      /**
<span class="line-modified">!      * Add a new Fieldref constant to the ConstantPool, if it is not already in</span>
<span class="line-modified">!      * there.</span>
       *
       * @param class_name class name string to add
       * @param field_name field name string to add
       * @param signature signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addFieldref(final String class_name, final String field_name, final String signature) {</span>
          int ret;
          int class_index;
          int name_and_type_index;
          if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {
              return ret; // Already in CP
<span class="line-new-header">--- 655,41 ---</span>
              cp_table.put(key, new Index(ret));
          }
          return ret;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public int addInterfaceMethodref( final MethodGen method ) {</span>
          return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());
      }
  
<span class="line-added">+ </span>
      /**
       * Look for ConstantFieldref in ConstantPool.
       *
       * @param class_name Where to find method
       * @param field_name Guess what
       * @param signature return and argument types
       * @return index on success, -1 otherwise
       */
<span class="line-modified">!     public int lookupFieldref( final String class_name, final String field_name, final String signature ) {</span>
          final Index index = cp_table.get(class_name + FIELDREF_DELIM + field_name
                  + FIELDREF_DELIM + signature);
          return (index != null) ? index.index : -1;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Add a new Fieldref constant to the ConstantPool, if it is not already</span>
<span class="line-modified">!      * in there.</span>
       *
       * @param class_name class name string to add
       * @param field_name field name string to add
       * @param signature signature string to add
       * @return index of entry
       */
<span class="line-modified">!     public int addFieldref( final String class_name, final String field_name, final String signature ) {</span>
          int ret;
          int class_index;
          int name_and_type_index;
          if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {
              return ret; // Already in CP
</pre>
<hr />
<pre>
<span class="line-old-header">*** 672,51 ***</span>
              cp_table.put(key, new Index(ret));
          }
          return ret;
      }
  
      /**
       * @param i index in constant pool
       * @return constant pool entry at index i
       */
<span class="line-modified">!     public Constant getConstant(final int i) {</span>
          return constants[i];
      }
  
      /**
       * Use with care!
       *
       * @param i index in constant pool
       * @param c new constant pool entry at index i
       */
<span class="line-modified">!     public void setConstant(final int i, final Constant c) {</span>
          constants[i] = c;
      }
  
      /**
       * @return intermediate constant pool
       */
      public ConstantPool getConstantPool() {
          return new ConstantPool(constants);
      }
  
      /**
       * @return current size of constant pool
       */
      public int getSize() {
          return index;
      }
  
      /**
       * @return constant pool with proper length
       */
      public ConstantPool getFinalConstantPool() {
          final Constant[] cs = new Constant[index];
          System.arraycopy(constants, 0, cs, 0, index);
          return new ConstantPool(cs);
      }
  
      /**
       * @return String representation.
       */
      @Override
      public String toString() {
<span class="line-new-header">--- 704,57 ---</span>
              cp_table.put(key, new Index(ret));
          }
          return ret;
      }
  
<span class="line-added">+ </span>
      /**
       * @param i index in constant pool
       * @return constant pool entry at index i
       */
<span class="line-modified">!     public Constant getConstant( final int i ) {</span>
          return constants[i];
      }
  
<span class="line-added">+ </span>
      /**
       * Use with care!
       *
       * @param i index in constant pool
       * @param c new constant pool entry at index i
       */
<span class="line-modified">!     public void setConstant( final int i, final Constant c ) {</span>
          constants[i] = c;
      }
  
<span class="line-added">+ </span>
      /**
       * @return intermediate constant pool
       */
      public ConstantPool getConstantPool() {
          return new ConstantPool(constants);
      }
  
<span class="line-added">+ </span>
      /**
       * @return current size of constant pool
       */
      public int getSize() {
          return index;
      }
  
<span class="line-added">+ </span>
      /**
       * @return constant pool with proper length
       */
      public ConstantPool getFinalConstantPool() {
          final Constant[] cs = new Constant[index];
          System.arraycopy(constants, 0, cs, 0, index);
          return new ConstantPool(cs);
      }
  
<span class="line-added">+ </span>
      /**
       * @return String representation.
       */
      @Override
      public String toString() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,14 ***</span>
              buf.append(i).append(&quot;)&quot;).append(constants[i]).append(&quot;\n&quot;);
          }
          return buf.toString();
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Import constant from another ConstantPool and return new index.</span>
       */
<span class="line-modified">!     public int addConstant(final Constant c, final ConstantPoolGen cp) {</span>
          final Constant[] constants = cp.getConstantPool().getConstantPool();
          switch (c.getTag()) {
              case Const.CONSTANT_String: {
                  final ConstantString s = (ConstantString) c;
                  final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
<span class="line-new-header">--- 763,14 ---</span>
              buf.append(i).append(&quot;)&quot;).append(constants[i]).append(&quot;\n&quot;);
          }
          return buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Import constant from another ConstantPool and return new index.</span>
       */
<span class="line-modified">!     public int addConstant( final Constant c, final ConstantPoolGen cp ) {</span>
          final Constant[] constants = cp.getConstantPool().getConstantPool();
          switch (c.getTag()) {
              case Const.CONSTANT_String: {
                  final ConstantString s = (ConstantString) c;
                  final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
</pre>
<center><a href="CompoundInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantPushInstruction.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
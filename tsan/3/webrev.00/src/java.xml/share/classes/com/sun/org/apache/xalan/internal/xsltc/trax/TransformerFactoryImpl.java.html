<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xalan.internal.xsltc.trax;
  22 
  23 import com.sun.org.apache.xalan.internal.XalanConstants;
  24 import com.sun.org.apache.xalan.internal.utils.FeaturePropertyBase;
  25 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
  26 import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
  27 import com.sun.org.apache.xalan.internal.utils.XMLSecurityPropertyManager.Property;
  28 import com.sun.org.apache.xalan.internal.utils.XMLSecurityPropertyManager;
  29 import com.sun.org.apache.xalan.internal.xsltc.compiler.Constants;
  30 import com.sun.org.apache.xalan.internal.xsltc.compiler.SourceLoader;
  31 import com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC;
  32 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
  33 import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
  34 import com.sun.org.apache.xml.internal.utils.StopParseException;
  35 import com.sun.org.apache.xml.internal.utils.StylesheetPIHandler;
  36 import java.io.File;
  37 import java.io.FileInputStream;
  38 import java.io.FileNotFoundException;
  39 import java.io.FilenameFilter;
  40 import java.io.IOException;
  41 import java.io.InputStream;
  42 import java.net.MalformedURLException;
  43 import java.net.URL;
  44 import java.util.ArrayList;
  45 import java.util.Enumeration;
  46 import java.util.List;
  47 import java.util.Map;
  48 import java.util.Properties;
  49 import java.util.zip.ZipEntry;
  50 import java.util.zip.ZipFile;
  51 import javax.xml.XMLConstants;
  52 import javax.xml.catalog.CatalogException;
  53 import javax.xml.catalog.CatalogFeatures.Feature;
  54 import javax.xml.catalog.CatalogFeatures;
  55 import javax.xml.catalog.CatalogManager;
  56 import javax.xml.catalog.CatalogResolver;
  57 import javax.xml.transform.ErrorListener;
  58 import javax.xml.transform.Source;
  59 import javax.xml.transform.Templates;
  60 import javax.xml.transform.Transformer;
  61 import javax.xml.transform.TransformerConfigurationException;
  62 import javax.xml.transform.TransformerException;
  63 import javax.xml.transform.URIResolver;
  64 import javax.xml.transform.dom.DOMResult;
  65 import javax.xml.transform.dom.DOMSource;
  66 import javax.xml.transform.sax.SAXResult;
  67 import javax.xml.transform.sax.SAXSource;
  68 import javax.xml.transform.sax.SAXTransformerFactory;
  69 import javax.xml.transform.sax.TemplatesHandler;
  70 import javax.xml.transform.sax.TransformerHandler;
  71 import javax.xml.transform.stax.*;
  72 import javax.xml.transform.stream.StreamResult;
  73 import javax.xml.transform.stream.StreamSource;
  74 import jdk.xml.internal.JdkXmlFeatures;
  75 import jdk.xml.internal.JdkXmlUtils;
  76 import jdk.xml.internal.SecuritySupport;
  77 import jdk.xml.internal.TransformErrorListener;
  78 import org.xml.sax.InputSource;
  79 import org.xml.sax.SAXException;
  80 import org.xml.sax.XMLFilter;
  81 import org.xml.sax.XMLReader;
  82 
  83 /**
  84  * Implementation of a JAXP TransformerFactory for Translets.
  85  * @author G. Todd Miller
  86  * @author Morten Jorgensen
  87  * @author Santiago Pericas-Geertsen
  88  * @LastModified: Aug 2019
  89  */
  90 public class TransformerFactoryImpl
  91     extends SAXTransformerFactory implements SourceLoader
  92 {
  93     // Public constants for attributes supported by the XSLTC TransformerFactory.
  94     public final static String TRANSLET_NAME = &quot;translet-name&quot;;
  95     public final static String DESTINATION_DIRECTORY = &quot;destination-directory&quot;;
  96     public final static String PACKAGE_NAME = &quot;package-name&quot;;
  97     public final static String JAR_NAME = &quot;jar-name&quot;;
  98     public final static String GENERATE_TRANSLET = &quot;generate-translet&quot;;
  99     public final static String AUTO_TRANSLET = &quot;auto-translet&quot;;
 100     public final static String USE_CLASSPATH = &quot;use-classpath&quot;;
 101     public final static String DEBUG = &quot;debug&quot;;
 102     public final static String ENABLE_INLINING = &quot;enable-inlining&quot;;
 103     public final static String INDENT_NUMBER = &quot;indent-number&quot;;
 104 
 105     /**
 106      * Default error listener
 107      */
 108     private final ErrorListener _defaultListener = new TransformErrorListener();
 109 
 110     /**
 111      * This error listener is used only for this factory and is not passed to
 112      * the Templates or Transformer objects that we create.
 113      */
 114     private ErrorListener _errorListener = _defaultListener;
 115 
 116     // flag indicating whether there&#39;s an user&#39;s ErrorListener
 117     private boolean _hasUserErrListener;
 118 
 119     /**
 120      * This URIResolver is passed to all created Templates and Transformers
 121      */
 122     private URIResolver _uriResolver = null;
 123 
 124     /**
 125      * As Gregor Samsa awoke one morning from uneasy dreams he found himself
 126      * transformed in his bed into a gigantic insect. He was lying on his hard,
 127      * as it were armour plated, back, and if he lifted his head a little he
 128      * could see his big, brown belly divided into stiff, arched segments, on
 129      * top of which the bed quilt could hardly keep in position and was about
 130      * to slide off completely. His numerous legs, which were pitifully thin
 131      * compared to the rest of his bulk, waved helplessly before his eyes.
 132      * &quot;What has happened to me?&quot;, he thought. It was no dream....
 133      */
 134     protected final static String DEFAULT_TRANSLET_NAME = &quot;GregorSamsa&quot;;
 135 
 136     /**
 137      * The class name of the translet
 138      */
 139     private String _transletName = DEFAULT_TRANSLET_NAME;
 140 
 141     /**
 142      * The destination directory for the translet
 143      */
 144     private String _destinationDirectory = null;
 145 
 146     /**
 147      * The package name prefix for all generated translet classes
 148      */
 149     private static final String DEFAULT_TRANSLATE_PACKAGE = &quot;die.verwandlung&quot;;
 150     private String _packageName = DEFAULT_TRANSLATE_PACKAGE;
 151 
 152     /**
 153      * The jar file name which the translet classes are packaged into
 154      */
 155     private String _jarFileName = null;
 156 
 157     /**
 158      * This Map is used to store parameters for locating
 159      * &lt;?xml-stylesheet ...?&gt; processing instructions in XML docs.
 160      */
 161     private Map&lt;Source, PIParamWrapper&gt; _piParams = null;
 162 
 163     /**
 164      * The above Map stores objects of this class.
 165      */
 166     private static class PIParamWrapper {
 167         public String _media = null;
 168         public String _title = null;
 169         public String _charset = null;
 170 
 171         public PIParamWrapper(String media, String title, String charset) {
 172             _media = media;
 173             _title = title;
 174             _charset = charset;
 175         }
 176     }
 177 
 178     /**
 179      * Set to &lt;code&gt;true&lt;/code&gt; when debugging is enabled.
 180      */
 181     private boolean _debug = false;
 182 
 183     /**
 184      * Set to &lt;code&gt;true&lt;/code&gt; when templates are inlined.
 185      */
 186     private boolean _enableInlining = false;
 187 
 188     /**
 189      * Set to &lt;code&gt;true&lt;/code&gt; when we want to generate
 190      * translet classes from the stylesheet.
 191      */
 192     private boolean _generateTranslet = false;
 193 
 194     /**
 195      * If this is set to &lt;code&gt;true&lt;/code&gt;, we attempt to use translet classes
 196      * for transformation if possible without compiling the stylesheet. The
 197      * translet class is only used if its timestamp is newer than the timestamp
 198      * of the stylesheet.
 199      */
 200     private boolean _autoTranslet = false;
 201 
 202     /**
 203      * If this is set to &lt;code&gt;true&lt;/code&gt;, we attempt to load the translet
 204      * from the CLASSPATH.
 205      */
 206     private boolean _useClasspath = false;
 207 
 208     /**
 209      * Number of indent spaces when indentation is turned on.
 210      */
 211     private int _indentNumber = -1;
 212 
 213     /**
 214      * &lt;p&gt;State of secure processing feature.&lt;/p&gt;
 215      */
 216     private boolean _isNotSecureProcessing = true;
 217     /**
 218      * &lt;p&gt;State of secure mode.&lt;/p&gt;
 219      */
 220     private boolean _isSecureMode = false;
 221 
 222     /**
 223      * Indicates whether 3rd party parser may be used to override the system-default
 224      * Note the default value (false) is the safe option.
 225      * Note same as the old property useServicesMechanism
 226      */
 227     private boolean _overrideDefaultParser;
 228 
 229     /**
 230      * protocols allowed for external references set by the stylesheet
 231      * processing instruction, Import and Include element.
 232      */
 233     private String _accessExternalStylesheet = XalanConstants.EXTERNAL_ACCESS_DEFAULT;
 234      /**
 235      * protocols allowed for external DTD references in source file and/or stylesheet.
 236      */
 237     private String _accessExternalDTD = XalanConstants.EXTERNAL_ACCESS_DEFAULT;
 238 
 239     private XMLSecurityPropertyManager _xmlSecurityPropertyMgr;
 240     private XMLSecurityManager _xmlSecurityManager;
 241 
 242     private final JdkXmlFeatures _xmlFeatures;
 243 
 244     private ClassLoader _extensionClassLoader = null;
 245 
 246     // Unmodifiable view of external extension function from xslt compiler
 247     // It will be populated by user-specified extension functions during the
 248     // type checking
 249     private Map&lt;String, Class&lt;?&gt;&gt; _xsltcExtensionFunctions;
 250 
 251     CatalogResolver _catalogUriResolver;
 252     CatalogFeatures _catalogFeatures;
 253     CatalogFeatures.Builder cfBuilder = CatalogFeatures.builder();
 254     // Catalog features
 255     String _catalogFiles = null;
 256     String _catalogDefer = null;
 257     String _catalogPrefer = null;
 258     String _catalogResolve = null;
 259 
 260     int _cdataChunkSize = JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT;
 261 
 262     /**
 263      * javax.xml.transform.sax.TransformerFactory implementation.
 264      */
 265     public TransformerFactoryImpl() {
 266 
 267         if (System.getSecurityManager() != null) {
 268             _isSecureMode = true;
 269             _isNotSecureProcessing = false;
 270         }
 271 
 272         _xmlFeatures = new JdkXmlFeatures(!_isNotSecureProcessing);
 273         _overrideDefaultParser = _xmlFeatures.getFeature(
 274                 JdkXmlFeatures.XmlFeature.JDK_OVERRIDE_PARSER);
 275         _xmlSecurityPropertyMgr = new XMLSecurityPropertyManager();
 276         _accessExternalDTD = _xmlSecurityPropertyMgr.getValue(
 277                 Property.ACCESS_EXTERNAL_DTD);
 278         _accessExternalStylesheet = _xmlSecurityPropertyMgr.getValue(
 279                 Property.ACCESS_EXTERNAL_STYLESHEET);
 280 
 281         //Parser&#39;s security manager
 282         _xmlSecurityManager = new XMLSecurityManager(true);
 283         //Unmodifiable hash map with loaded external extension functions
 284         _xsltcExtensionFunctions = null;
 285     }
 286 
 287     public Map&lt;String, Class&lt;?&gt;&gt; getExternalExtensionsMap() {
 288         return _xsltcExtensionFunctions;
 289     }
 290 
 291     /**
 292      * javax.xml.transform.sax.TransformerFactory implementation.
 293      * Set the error event listener for the TransformerFactory, which is used
 294      * for the processing of transformation instructions, and not for the
 295      * transformation itself.
 296      *
 297      * @param listener The error listener to use with the TransformerFactory
 298      * @throws IllegalArgumentException
 299      */
 300     @Override
 301     public void setErrorListener(ErrorListener listener)
 302         throws IllegalArgumentException
 303     {
 304         if (listener == null) {
 305             ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
 306                                         &quot;TransformerFactory&quot;);
 307             throw new IllegalArgumentException(err.toString());
 308         }
 309         _hasUserErrListener = true;
 310         _errorListener = listener;
 311     }
 312 
 313     /**
 314      * javax.xml.transform.sax.TransformerFactory implementation.
 315      * Get the error event handler for the TransformerFactory.
 316      *
 317      * @return The error listener used with the TransformerFactory
 318      */
 319     @Override
 320     public ErrorListener getErrorListener() {
 321         return _errorListener;
 322     }
 323 
 324     /**
 325      * Returns the package name.
 326      */
 327     String getPackageName() {
 328         return _packageName;
 329     }
 330 
 331     /**
 332      * javax.xml.transform.sax.TransformerFactory implementation.
 333      * Returns the value set for a TransformerFactory attribute
 334      *
 335      * @param name The attribute name
 336      * @return An object representing the attribute value
 337      * @throws IllegalArgumentException
 338      */
 339     @Override
 340     public Object getAttribute(String name)
 341         throws IllegalArgumentException
 342     {
 343         // Return value for attribute &#39;translet-name&#39;
 344         if (name.equals(TRANSLET_NAME)) {
 345             return _transletName;
 346         }
 347         else if (name.equals(GENERATE_TRANSLET)) {
 348             return _generateTranslet;
 349         }
 350         else if (name.equals(AUTO_TRANSLET)) {
 351             return _autoTranslet;
 352         }
 353         else if (name.equals(ENABLE_INLINING)) {
 354             if (_enableInlining)
 355               return Boolean.TRUE;
 356             else
 357               return Boolean.FALSE;
 358         } else if (name.equals(XalanConstants.SECURITY_MANAGER)) {
 359             return _xmlSecurityManager;
 360         } else if (name.equals(XalanConstants.JDK_EXTENSION_CLASSLOADER)) {
 361            return _extensionClassLoader;
 362         } else if (JdkXmlUtils.CATALOG_FILES.equals(name)) {
 363             return _catalogFiles;
 364         } else if (JdkXmlUtils.CATALOG_DEFER.equals(name)) {
 365             return _catalogDefer;
 366         } else if (JdkXmlUtils.CATALOG_PREFER.equals(name)) {
 367             return _catalogPrefer;
 368         } else if (JdkXmlUtils.CATALOG_RESOLVE.equals(name)) {
 369             return _catalogResolve;
 370         } else if (JdkXmlFeatures.CATALOG_FEATURES.equals(name)) {
 371             return buildCatalogFeatures();
 372         } else if (JdkXmlUtils.CDATA_CHUNK_SIZE.equals(name)) {
 373             return _cdataChunkSize;
 374         }
 375 
 376         /** Check to see if the property is managed by the security manager **/
 377         String propertyValue = (_xmlSecurityManager != null) ?
 378                 _xmlSecurityManager.getLimitAsString(name) : null;
 379         if (propertyValue != null) {
 380             return propertyValue;
 381         } else {
 382             propertyValue = (_xmlSecurityPropertyMgr != null) ?
 383                 _xmlSecurityPropertyMgr.getValue(name) : null;
 384             if (propertyValue != null) {
 385                 return propertyValue;
 386             }
 387         }
 388 
 389         // Throw an exception for all other attributes
 390         ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_INVALID_ATTR_ERR, name);
 391         throw new IllegalArgumentException(err.toString());
 392     }
 393 
 394     /**
 395      * javax.xml.transform.sax.TransformerFactory implementation.
 396      * Sets the value for a TransformerFactory attribute.
 397      *
 398      * @param name The attribute name
 399      * @param value An object representing the attribute value
 400      * @throws IllegalArgumentException
 401      */
 402     @Override
 403     public void setAttribute(String name, Object value)
 404         throws IllegalArgumentException
 405     {
 406         // Set the default translet name (ie. class name), which will be used
 407         // for translets that cannot be given a name from their system-id.
 408         if (name.equals(TRANSLET_NAME) &amp;&amp; value instanceof String) {
 409             _transletName = (String) value;
 410             return;
 411         }
 412         else if (name.equals(DESTINATION_DIRECTORY) &amp;&amp; value instanceof String) {
 413             _destinationDirectory = (String) value;
 414             return;
 415         }
 416         else if (name.equals(PACKAGE_NAME) &amp;&amp; value instanceof String) {
 417             _packageName = (String) value;
 418             return;
 419         }
 420         else if (name.equals(JAR_NAME) &amp;&amp; value instanceof String) {
 421             _jarFileName = (String) value;
 422             return;
 423         }
 424         else if (name.equals(GENERATE_TRANSLET)) {
 425             if (value instanceof Boolean) {
 426                 _generateTranslet = ((Boolean) value);
 427                 return;
 428             }
 429             else if (value instanceof String) {
 430                 _generateTranslet = ((String) value).equalsIgnoreCase(&quot;true&quot;);
 431                 return;
 432             }
 433         }
 434         else if (name.equals(AUTO_TRANSLET)) {
 435             if (value instanceof Boolean) {
 436                 _autoTranslet = ((Boolean) value);
 437                 return;
 438             }
 439             else if (value instanceof String) {
 440                 _autoTranslet = ((String) value).equalsIgnoreCase(&quot;true&quot;);
 441                 return;
 442             }
 443         }
 444         else if (name.equals(USE_CLASSPATH)) {
 445             if (value instanceof Boolean) {
 446                 _useClasspath = ((Boolean) value);
 447                 return;
 448             }
 449             else if (value instanceof String) {
 450                 _useClasspath = ((String) value).equalsIgnoreCase(&quot;true&quot;);
 451                 return;
 452             }
 453         }
 454         else if (name.equals(DEBUG)) {
 455             if (value instanceof Boolean) {
 456                 _debug = ((Boolean) value);
 457                 return;
 458             }
 459             else if (value instanceof String) {
 460                 _debug = ((String) value).equalsIgnoreCase(&quot;true&quot;);
 461                 return;
 462             }
 463         }
 464         else if (name.equals(ENABLE_INLINING)) {
 465             if (value instanceof Boolean) {
 466                 _enableInlining = ((Boolean) value);
 467                 return;
 468             }
 469             else if (value instanceof String) {
 470                 _enableInlining = ((String) value).equalsIgnoreCase(&quot;true&quot;);
 471                 return;
 472             }
 473         }
 474         else if (name.equals(INDENT_NUMBER)) {
 475             if (value instanceof String) {
 476                 try {
 477                     _indentNumber = Integer.parseInt((String) value);
 478                     return;
 479                 }
 480                 catch (NumberFormatException e) {
 481                     // Falls through
 482                 }
 483             }
 484             else if (value instanceof Integer) {
 485                 _indentNumber = ((Integer) value);
 486                 return;
 487             }
 488         }
 489         else if ( name.equals(XalanConstants.JDK_EXTENSION_CLASSLOADER)) {
 490             if (value instanceof ClassLoader) {
 491                 _extensionClassLoader = (ClassLoader) value;
 492                 return;
 493             } else {
 494                 final ErrorMsg err
 495                     = new ErrorMsg(ErrorMsg.JAXP_INVALID_ATTR_VALUE_ERR, &quot;Extension Functions ClassLoader&quot;);
 496                 throw new IllegalArgumentException(err.toString());
 497             }
 498         } else if (JdkXmlUtils.CATALOG_FILES.equals(name)) {
 499             _catalogFiles = (String) value;
 500             cfBuilder = CatalogFeatures.builder().with(Feature.FILES, _catalogFiles);
 501             return;
 502         } else if (JdkXmlUtils.CATALOG_DEFER.equals(name)) {
 503             _catalogDefer = (String) value;
 504             cfBuilder = CatalogFeatures.builder().with(Feature.DEFER, _catalogDefer);
 505             return;
 506         } else if (JdkXmlUtils.CATALOG_PREFER.equals(name)) {
 507             _catalogPrefer = (String) value;
 508             cfBuilder = CatalogFeatures.builder().with(Feature.PREFER, _catalogPrefer);
 509             return;
 510         } else if (JdkXmlUtils.CATALOG_RESOLVE.equals(name)) {
 511             _catalogResolve = (String) value;
 512             cfBuilder = CatalogFeatures.builder().with(Feature.RESOLVE, _catalogResolve);
 513             return;
 514         } else if (JdkXmlUtils.CDATA_CHUNK_SIZE.equals(name)) {
 515             _cdataChunkSize = JdkXmlUtils.getValue(value, _cdataChunkSize);
 516             return;
 517         }
 518 
 519         if (_xmlSecurityManager != null &amp;&amp;
 520                 _xmlSecurityManager.setLimit(name, XMLSecurityManager.State.APIPROPERTY, value)) {
 521             return;
 522         }
 523 
 524         if (_xmlSecurityPropertyMgr != null &amp;&amp;
 525             _xmlSecurityPropertyMgr.setValue(name, XMLSecurityPropertyManager.State.APIPROPERTY, value)) {
 526             _accessExternalDTD = _xmlSecurityPropertyMgr.getValue(
 527                     Property.ACCESS_EXTERNAL_DTD);
 528             _accessExternalStylesheet = _xmlSecurityPropertyMgr.getValue(
 529                     Property.ACCESS_EXTERNAL_STYLESHEET);
 530             return;
 531         }
 532 
 533         // Throw an exception for all other attributes
 534         final ErrorMsg err
 535             = new ErrorMsg(ErrorMsg.JAXP_INVALID_ATTR_ERR, name);
 536         throw new IllegalArgumentException(err.toString());
 537     }
 538 
 539     /**
 540      * &lt;p&gt;Set a feature for this &lt;code&gt;TransformerFactory&lt;/code&gt; and &lt;code&gt;Transformer&lt;/code&gt;s
 541      * or &lt;code&gt;Template&lt;/code&gt;s created by this factory.&lt;/p&gt;
 542      *
 543      * &lt;p&gt;
 544      * Feature names are fully qualified {@link java.net.URI}s.
 545      * Implementations may define their own features.
 546      * An {@link TransformerConfigurationException} is thrown if this &lt;code&gt;TransformerFactory&lt;/code&gt; or the
 547      * &lt;code&gt;Transformer&lt;/code&gt;s or &lt;code&gt;Template&lt;/code&gt;s it creates cannot support the feature.
 548      * It is possible for an &lt;code&gt;TransformerFactory&lt;/code&gt; to expose a feature value but be unable to change its state.
 549      * &lt;/p&gt;
 550      *
 551      * &lt;p&gt;See {@link javax.xml.transform.TransformerFactory} for full documentation of specific features.&lt;/p&gt;
 552      *
 553      * @param name Feature name.
 554      * @param value Is feature state &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.
 555      *
 556      * @throws TransformerConfigurationException if this &lt;code&gt;TransformerFactory&lt;/code&gt;
 557      *   or the &lt;code&gt;Transformer&lt;/code&gt;s or &lt;code&gt;Template&lt;/code&gt;s it creates cannot support this feature.
 558      * @throws NullPointerException If the &lt;code&gt;name&lt;/code&gt; parameter is null.
 559      */
 560     @Override
 561     public void setFeature(String name, boolean value)
 562         throws TransformerConfigurationException {
 563 
 564         // feature name cannot be null
 565         if (name == null) {
 566             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_SET_FEATURE_NULL_NAME);
 567             throw new NullPointerException(err.toString());
 568         }
 569         // secure processing?
 570         else if (name.equals(XMLConstants.FEATURE_SECURE_PROCESSING)) {
 571             if ((_isSecureMode) &amp;&amp; (!value)) {
 572                 ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_SECUREPROCESSING_FEATURE);
 573                 throw new TransformerConfigurationException(err.toString());
 574             }
 575             _isNotSecureProcessing = !value;
 576             _xmlSecurityManager.setSecureProcessing(value);
 577 
 578             // set external access restriction when FSP is explicitly set
 579             if (value) {
 580                 _xmlSecurityPropertyMgr.setValue(Property.ACCESS_EXTERNAL_DTD,
 581                         FeaturePropertyBase.State.FSP, XalanConstants.EXTERNAL_ACCESS_DEFAULT_FSP);
 582                 _xmlSecurityPropertyMgr.setValue(Property.ACCESS_EXTERNAL_STYLESHEET,
 583                         FeaturePropertyBase.State.FSP, XalanConstants.EXTERNAL_ACCESS_DEFAULT_FSP);
 584                 _accessExternalDTD = _xmlSecurityPropertyMgr.getValue(
 585                         Property.ACCESS_EXTERNAL_DTD);
 586                 _accessExternalStylesheet = _xmlSecurityPropertyMgr.getValue(
 587                         Property.ACCESS_EXTERNAL_STYLESHEET);
 588             }
 589 
 590             if (value &amp;&amp; _xmlFeatures != null) {
 591                 _xmlFeatures.setFeature(JdkXmlFeatures.XmlFeature.ENABLE_EXTENSION_FUNCTION,
 592                         JdkXmlFeatures.State.FSP, false);
 593             }
 594         }
 595         else {
 596             if (name.equals(XalanConstants.ORACLE_FEATURE_SERVICE_MECHANISM)) {
 597                 // for compatibility, in secure mode, useServicesMechanism is determined by the constructor
 598                 if (_isSecureMode) {
 599                     return;
 600                 }
 601             }
 602             if (_xmlFeatures != null &amp;&amp;
 603                     _xmlFeatures.setFeature(name, JdkXmlFeatures.State.APIPROPERTY, value)) {
 604                 if (name.equals(JdkXmlUtils.OVERRIDE_PARSER) ||
 605                         name.equals(JdkXmlFeatures.ORACLE_FEATURE_SERVICE_MECHANISM)) {
 606                     _overrideDefaultParser = _xmlFeatures.getFeature(
 607                             JdkXmlFeatures.XmlFeature.JDK_OVERRIDE_PARSER);
 608                 }
 609                 return;
 610             }
 611 
 612             // unknown feature
 613             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNSUPPORTED_FEATURE, name);
 614             throw new TransformerConfigurationException(err.toString());
 615         }
 616     }
 617 
 618     /**
 619      * javax.xml.transform.sax.TransformerFactory implementation.
 620      * Look up the value of a feature (to see if it is supported).
 621      * This method must be updated as the various methods and features of this
 622      * class are implemented.
 623      *
 624      * @param name The feature name
 625      * @return &#39;true&#39; if feature is supported, &#39;false&#39; if not
 626      */
 627     @Override
 628     public boolean getFeature(String name) {
 629         // All supported features should be listed here
 630         String[] features = {
 631             DOMSource.FEATURE,
 632             DOMResult.FEATURE,
 633             SAXSource.FEATURE,
 634             SAXResult.FEATURE,
 635             StAXSource.FEATURE,
 636             StAXResult.FEATURE,
 637             StreamSource.FEATURE,
 638             StreamResult.FEATURE,
 639             SAXTransformerFactory.FEATURE,
 640             SAXTransformerFactory.FEATURE_XMLFILTER,
 641             XalanConstants.ORACLE_FEATURE_SERVICE_MECHANISM
 642         };
 643 
 644         // feature name cannot be null
 645         if (name == null) {
 646             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_GET_FEATURE_NULL_NAME);
 647             throw new NullPointerException(err.toString());
 648         }
 649 
 650         // Inefficient, but array is small
 651         for (int i =0; i &lt; features.length; i++) {
 652             if (name.equals(features[i])) {
 653                 return true;
 654             }
 655         }
 656 
 657         if (name.equals(XMLConstants.FEATURE_SECURE_PROCESSING)) {
 658             return !_isNotSecureProcessing;
 659         }
 660 
 661         /** Check to see if the property is managed by the JdkXmlFeatues **/
 662         int index = _xmlFeatures.getIndex(name);
 663         if (index &gt; -1) {
 664             return _xmlFeatures.getFeature(index);
 665         }
 666 
 667         // Feature not supported
 668         return false;
 669     }
 670     /**
 671      * Return the state of the services mechanism feature.
 672      */
 673     public boolean overrideDefaultParser() {
 674         return _overrideDefaultParser;
 675     }
 676 
 677      /**
 678      * @return the feature manager
 679      */
 680     public JdkXmlFeatures getJdkXmlFeatures() {
 681         return _xmlFeatures;
 682     }
 683 
 684     /**
 685      * javax.xml.transform.sax.TransformerFactory implementation.
 686      * Get the object that is used by default during the transformation to
 687      * resolve URIs used in document(), xsl:import, or xsl:include.
 688      *
 689      * @return The URLResolver used for this TransformerFactory and all
 690      * Templates and Transformer objects created using this factory
 691      */
 692     @Override
 693     public URIResolver getURIResolver() {
 694         return _uriResolver;
 695     }
 696 
 697     /**
 698      * javax.xml.transform.sax.TransformerFactory implementation.
 699      * Set the object that is used by default during the transformation to
 700      * resolve URIs used in document(), xsl:import, or xsl:include. Note that
 701      * this does not affect Templates and Transformers that are already
 702      * created with this factory.
 703      *
 704      * @param resolver The URLResolver used for this TransformerFactory and all
 705      * Templates and Transformer objects created using this factory
 706      */
 707     @Override
 708     public void setURIResolver(URIResolver resolver) {
 709         _uriResolver = resolver;
 710     }
 711 
 712     /**
 713      * javax.xml.transform.sax.TransformerFactory implementation.
 714      * Get the stylesheet specification(s) associated via the xml-stylesheet
 715      * processing instruction (see http://www.w3.org/TR/xml-stylesheet/) with
 716      * the document document specified in the source parameter, and that match
 717      * the given criteria.
 718      *
 719      * @param source The XML source document.
 720      * @param media The media attribute to be matched. May be null, in which
 721      * case the prefered templates will be used (i.e. alternate = no).
 722      * @param title The value of the title attribute to match. May be null.
 723      * @param charset The value of the charset attribute to match. May be null.
 724      * @return A Source object suitable for passing to the TransformerFactory.
 725      * @throws TransformerConfigurationException
 726      */
 727     @Override
 728     public Source  getAssociatedStylesheet(Source source, String media,
 729                                           String title, String charset)
 730         throws TransformerConfigurationException {
 731 
 732         String baseId;
 733         XMLReader reader = null;
 734         InputSource isource;
 735 
 736         /**
 737          * Fix for bugzilla bug 24187
 738          */
 739         StylesheetPIHandler _stylesheetPIHandler = new StylesheetPIHandler(null,media,title,charset);
 740 
 741         try {
 742 
 743             if (source instanceof DOMSource ) {
 744                 final DOMSource domsrc = (DOMSource) source;
 745                 baseId = domsrc.getSystemId();
 746                 final org.w3c.dom.Node node = domsrc.getNode();
 747                 final DOM2SAX dom2sax = new DOM2SAX(node);
 748 
 749                 _stylesheetPIHandler.setBaseId(baseId);
 750 
 751                 dom2sax.setContentHandler( _stylesheetPIHandler);
 752                 dom2sax.parse();
 753             } else {
 754                 if (source instanceof SAXSource) {
 755                     reader = ((SAXSource)source).getXMLReader();
 756                 }
 757                 isource = SAXSource.sourceToInputSource(source);
 758                 baseId = isource.getSystemId();
 759 
 760                 if (reader == null) {
 761                     reader = JdkXmlUtils.getXMLReader(_overrideDefaultParser,
 762                             !_isNotSecureProcessing);
 763                 }
 764 
 765                 _stylesheetPIHandler.setBaseId(baseId);
 766                 reader.setContentHandler(_stylesheetPIHandler);
 767                 reader.parse(isource);
 768 
 769             }
 770 
 771             if (_uriResolver != null ) {
 772                 _stylesheetPIHandler.setURIResolver(_uriResolver);
 773             }
 774 
 775         } catch (StopParseException e ) {
 776           // startElement encountered so do not parse further
 777 
 778         } catch (SAXException | IOException e) {
 779              throw new TransformerConfigurationException(
 780              &quot;getAssociatedStylesheets failed&quot;, e);
 781         }
 782 
 783          return _stylesheetPIHandler.getAssociatedStylesheet();
 784 
 785     }
 786 
 787     /**
 788      * javax.xml.transform.sax.TransformerFactory implementation.
 789      * Create a Transformer object that copies the input document to the result.
 790      *
 791      * @return A Transformer object that simply copies the source to the result.
 792      * @throws TransformerConfigurationException
 793      */
 794     @Override
 795     public Transformer newTransformer()
 796         throws TransformerConfigurationException
 797     {
 798         // create CatalogFeatures that is accessible by the Transformer
 799         // through the factory instance
 800         buildCatalogFeatures();
 801         TransformerImpl result = new TransformerImpl(new Properties(),
 802             _indentNumber, this);
 803         if (_uriResolver != null) {
 804             result.setURIResolver(_uriResolver);
 805         }
 806 
 807         if (!_isNotSecureProcessing) {
 808             result.setSecureProcessing(true);
 809         }
 810         return result;
 811     }
 812 
 813     /**
 814      * javax.xml.transform.sax.TransformerFactory implementation.
 815      * Process the Source into a Templates object, which is a a compiled
 816      * representation of the source. Note that this method should not be
 817      * used with XSLTC, as the time-consuming compilation is done for each
 818      * and every transformation.
 819      *
 820      * @return A Templates object that can be used to create Transformers.
 821      * @throws TransformerConfigurationException
 822      */
 823     @Override
 824     public Transformer newTransformer(Source source) throws
 825         TransformerConfigurationException
 826     {
 827         final Templates templates = newTemplates(source);
 828         final Transformer transformer = templates.newTransformer();
 829         if (_uriResolver != null) {
 830             transformer.setURIResolver(_uriResolver);
 831         }
 832         return(transformer);
 833     }
 834 
 835     /**
 836      * Pass warning messages from the compiler to the error listener
 837      */
 838     private void passWarningsToListener(List&lt;ErrorMsg&gt; messages)
 839         throws TransformerException
 840     {
 841         if (_errorListener == null || messages == null) {
 842             return;
 843         }
 844         // Pass messages to listener, one by one
 845         final int count = messages.size();
 846         for (int pos = 0; pos &lt; count; pos++) {
 847             ErrorMsg msg = messages.get(pos);
 848             // Workaround for the TCK failure ErrorListener.errorTests.error001.
 849             if (msg.isWarningError())
 850                 _errorListener.error(
 851                     new TransformerConfigurationException(msg.toString()));
 852             else
 853                 _errorListener.warning(
 854                     new TransformerConfigurationException(msg.toString()));
 855         }
 856     }
 857 
 858     /**
 859      * Pass error messages from the compiler to the error listener
 860      */
 861     private void passErrorsToListener(List&lt;ErrorMsg&gt; messages) {
 862         try {
 863             if (_errorListener == null || messages == null) {
 864                 return;
 865             }
 866             // Pass messages to listener, one by one
 867             final int count = messages.size();
 868             for (int pos = 0; pos &lt; count; pos++) {
 869                 String message = messages.get(pos).toString();
 870                 _errorListener.error(new TransformerException(message));
 871             }
 872         }
 873         catch (TransformerException e) {
 874             // nada
 875         }
 876     }
 877 
 878     /**
 879      * javax.xml.transform.sax.TransformerFactory implementation.
 880      * Process the Source into a Templates object, which is a a compiled
 881      * representation of the source.
 882      *
 883      * @param source The input stylesheet - DOMSource not supported!!!
 884      * @return A Templates object that can be used to create Transformers.
 885      * @throws TransformerConfigurationException
 886      */
 887     @Override
 888     public Templates newTemplates(Source source)
 889         throws TransformerConfigurationException
 890     {
 891         TemplatesImpl templates;
 892         // If the _useClasspath attribute is true, try to load the translet from
 893         // the CLASSPATH and create a template object using the loaded
 894         // translet.
 895         if (_useClasspath) {
 896             String transletName = getTransletBaseName(source);
 897 
 898             if (_packageName != null)
 899                 transletName = _packageName + &quot;.&quot; + transletName;
 900 
 901             try {
 902                 final Class&lt;?&gt; clazz = ObjectFactory.findProviderClass(transletName, true);
 903                 resetTransientAttributes();
 904 
 905                 templates = new TemplatesImpl(new Class&lt;?&gt;[]{clazz}, transletName, null, _indentNumber, this);
 906                 if (_uriResolver != null) {
 907                     templates.setURIResolver(_uriResolver);
 908                 }
 909                 return templates;
 910             }
 911             catch (ClassNotFoundException cnfe) {
 912                 ErrorMsg err = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, transletName);
 913                 throw new TransformerConfigurationException(err.toString());
 914             }
 915             catch (Exception e) {
 916                 ErrorMsg err = new ErrorMsg(
 917                                      new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)
 918                                      + e.getMessage());
 919                 throw new TransformerConfigurationException(err.toString());
 920             }
 921         }
 922 
 923         // If _autoTranslet is true, we will try to load the bytecodes
 924         // from the translet classes without compiling the stylesheet.
 925         if (_autoTranslet)  {
 926             byte[][] bytecodes;
 927             String transletClassName = getTransletBaseName(source);
 928 
 929             if (_packageName != null)
 930                transletClassName = _packageName + &quot;.&quot; + transletClassName;
 931 
 932             if (_jarFileName != null)
 933                 bytecodes = getBytecodesFromJar(source, transletClassName);
 934             else
 935                 bytecodes = getBytecodesFromClasses(source, transletClassName);
 936 
 937             if (bytecodes != null) {
 938                 if (_debug) {
 939                     if (_jarFileName != null)
 940                         System.err.println(new ErrorMsg(
 941                             ErrorMsg.TRANSFORM_WITH_JAR_STR, transletClassName, _jarFileName));
 942                     else
 943                         System.err.println(new ErrorMsg(
 944                             ErrorMsg.TRANSFORM_WITH_TRANSLET_STR, transletClassName));
 945                 }
 946 
 947                 // Reset the per-session attributes to their default values
 948                 // after each newTemplates() call.
 949                 resetTransientAttributes();
 950                 templates = new TemplatesImpl(bytecodes, transletClassName, null, _indentNumber, this);
 951                 if (_uriResolver != null) {
 952                     templates.setURIResolver(_uriResolver);
 953                 }
 954                 return templates;
 955             }
 956         }
 957 
 958         // Create and initialize a stylesheet compiler
 959         final XSLTC xsltc = new XSLTC(_xmlFeatures, _hasUserErrListener);
 960         if (_debug) xsltc.setDebug(true);
 961         if (_enableInlining)
 962                 xsltc.setTemplateInlining(true);
 963         else
 964                 xsltc.setTemplateInlining(false);
 965 
 966         if (!_isNotSecureProcessing) xsltc.setSecureProcessing(true);
 967         xsltc.setProperty(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, _accessExternalStylesheet);
 968         xsltc.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, _accessExternalDTD);
 969         xsltc.setProperty(XalanConstants.SECURITY_MANAGER, _xmlSecurityManager);
 970         xsltc.setProperty(XalanConstants.JDK_EXTENSION_CLASSLOADER, _extensionClassLoader);
 971 
 972         // set Catalog features
 973         buildCatalogFeatures();
 974         xsltc.setProperty(JdkXmlFeatures.CATALOG_FEATURES, _catalogFeatures);
 975 
 976         xsltc.init();
 977         if (!_isNotSecureProcessing)
 978             _xsltcExtensionFunctions = xsltc.getExternalExtensionFunctions();
 979         // Set a document loader (for xsl:include/import) if defined
 980         if (_uriResolver != null || ( _catalogFiles != null
 981                 &amp;&amp; _xmlFeatures.getFeature(JdkXmlFeatures.XmlFeature.USE_CATALOG))) {
 982             xsltc.setSourceLoader(this);
 983         }
 984 
 985         // Pass parameters to the Parser to make sure it locates the correct
 986         // &lt;?xml-stylesheet ...?&gt; PI in an XML input document
 987         if ((_piParams != null) &amp;&amp; (_piParams.get(source) != null)) {
 988             // Get the parameters for this Source object
 989             PIParamWrapper p = _piParams.get(source);
 990             // Pass them on to the compiler (which will pass then to the parser)
 991             if (p != null) {
 992                 xsltc.setPIParameters(p._media, p._title, p._charset);
 993             }
 994         }
 995 
 996         // Set the attributes for translet generation
 997         int outputType = XSLTC.BYTEARRAY_OUTPUT;
 998         if (_generateTranslet || _autoTranslet) {
 999             // Set the translet name
1000             xsltc.setClassName(getTransletBaseName(source));
1001 
1002             if (_destinationDirectory != null)
1003                 xsltc.setDestDirectory(_destinationDirectory);
1004             else {
1005                 String xslName = getStylesheetFileName(source);
1006                 if (xslName != null) {
1007                     File xslFile = new File(xslName);
1008                     String xslDir = xslFile.getParent();
1009 
1010                     if (xslDir != null)
1011                         xsltc.setDestDirectory(xslDir);
1012                 }
1013             }
1014 
1015             if (_packageName != null)
1016                 xsltc.setPackageName(_packageName);
1017 
1018             if (_jarFileName != null) {
1019                 xsltc.setJarFileName(_jarFileName);
1020                 outputType = XSLTC.BYTEARRAY_AND_JAR_OUTPUT;
1021             }
1022             else
1023                 outputType = XSLTC.BYTEARRAY_AND_FILE_OUTPUT;
1024         }
1025 
1026         // Compile the stylesheet
1027         final InputSource input = Util.getInputSource(xsltc, source);
1028         byte[][] bytecodes = xsltc.compile(null, input, outputType);
1029         final String transletName = xsltc.getClassName();
1030 
1031         // Output to the jar file if the jar file name is set.
1032         if ((_generateTranslet || _autoTranslet)
1033                 &amp;&amp; bytecodes != null &amp;&amp; _jarFileName != null) {
1034             try {
1035                 xsltc.outputToJar();
1036             }
1037             catch (java.io.IOException e) { }
1038         }
1039 
1040         // Reset the per-session attributes to their default values
1041         // after each newTemplates() call.
1042         resetTransientAttributes();
1043 
1044         // Pass compiler warnings to the error listener
1045         if (_errorListener != this) {
1046             try {
1047                 passWarningsToListener(xsltc.getWarnings());
1048             }
1049             catch (TransformerException e) {
1050                 throw new TransformerConfigurationException(e);
1051             }
1052         }
1053         else {
1054             xsltc.printWarnings();
1055         }
1056 
1057         // Check that the transformation went well before returning
1058         if (bytecodes == null) {
1059             List&lt;ErrorMsg&gt; errs = xsltc.getErrors();
1060             ErrorMsg err;
1061             if (errs != null) {
1062                 err = errs.get(errs.size()-1);
1063             } else {
1064                 err = new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR);
1065             }
1066             Throwable cause = err.getCause();
1067             TransformerConfigurationException exc;
1068             if (cause != null) {
1069                 exc =  new TransformerConfigurationException(cause.getMessage(), cause);
1070             } else {
1071                 exc =  new TransformerConfigurationException(err.toString());
1072             }
1073 
1074             // Pass compiler errors to the error listener
1075             if (_errorListener != null) {
1076                 passErrorsToListener(xsltc.getErrors());
1077 
1078                 // As required by TCK 1.2, send a fatalError to the
1079                 // error listener because compilation of the stylesheet
1080                 // failed and no further processing will be possible.
1081                 try {
1082                     _errorListener.fatalError(exc);
1083                 } catch (TransformerException te) {
1084                     // well, we tried.
1085                 }
1086             }
1087             else {
1088                 xsltc.printErrors();
1089             }
1090             throw exc;
1091         }
1092 
1093         templates = new TemplatesImpl(bytecodes, transletName, xsltc.getOutputProperties(),
1094                 _indentNumber, this);
1095         if (_uriResolver != null) {
1096             templates.setURIResolver(_uriResolver);
1097         }
1098         return templates;
1099     }
1100 
1101     /**
1102      * javax.xml.transform.sax.SAXTransformerFactory implementation.
1103      * Get a TemplatesHandler object that can process SAX ContentHandler
1104      * events into a Templates object.
1105      *
1106      * @return A TemplatesHandler object that can handle SAX events
1107      * @throws TransformerConfigurationException
1108      */
1109     @Override
1110     public TemplatesHandler newTemplatesHandler()
1111         throws TransformerConfigurationException
1112     {
1113         // create CatalogFeatures that is accessible by the Handler
1114         // through the factory instance
1115         buildCatalogFeatures();
1116         final TemplatesHandlerImpl handler =
1117             new TemplatesHandlerImpl(_indentNumber, this, _hasUserErrListener);
1118         if (_uriResolver != null) {
1119             handler.setURIResolver(_uriResolver);
1120         }
1121         return handler;
1122     }
1123 
1124     /**
1125      * javax.xml.transform.sax.SAXTransformerFactory implementation.
1126      * Get a TransformerHandler object that can process SAX ContentHandler
1127      * events into a Result. This method will return a pure copy transformer.
1128      *
1129      * @return A TransformerHandler object that can handle SAX events
1130      * @throws TransformerConfigurationException
1131      */
1132     @Override
1133     public TransformerHandler newTransformerHandler()
1134         throws TransformerConfigurationException
1135     {
1136         final Transformer transformer = newTransformer();
1137         if (_uriResolver != null) {
1138             transformer.setURIResolver(_uriResolver);
1139         }
1140         return new TransformerHandlerImpl((TransformerImpl) transformer);
1141     }
1142 
1143     /**
1144      * javax.xml.transform.sax.SAXTransformerFactory implementation.
1145      * Get a TransformerHandler object that can process SAX ContentHandler
1146      * events into a Result, based on the transformation instructions
1147      * specified by the argument.
1148      *
1149      * @param src The source of the transformation instructions.
1150      * @return A TransformerHandler object that can handle SAX events
1151      * @throws TransformerConfigurationException
1152      */
1153     @Override
1154     public TransformerHandler newTransformerHandler(Source src)
1155         throws TransformerConfigurationException
1156     {
1157         final Transformer transformer = newTransformer(src);
1158         if (_uriResolver != null) {
1159             transformer.setURIResolver(_uriResolver);
1160         }
1161         return new TransformerHandlerImpl((TransformerImpl) transformer);
1162     }
1163 
1164     /**
1165      * javax.xml.transform.sax.SAXTransformerFactory implementation.
1166      * Get a TransformerHandler object that can process SAX ContentHandler
1167      * events into a Result, based on the transformation instructions
1168      * specified by the argument.
1169      *
1170      * @param templates Represents a pre-processed stylesheet
1171      * @return A TransformerHandler object that can handle SAX events
1172      * @throws TransformerConfigurationException
1173      */
1174     @Override
1175     public TransformerHandler newTransformerHandler(Templates templates)
1176         throws TransformerConfigurationException
1177     {
1178         final Transformer transformer = templates.newTransformer();
1179         final TransformerImpl internal = (TransformerImpl)transformer;
1180         return new TransformerHandlerImpl(internal);
1181     }
1182 
1183     /**
1184      * javax.xml.transform.sax.SAXTransformerFactory implementation.
1185      * Create an XMLFilter that uses the given source as the
1186      * transformation instructions.
1187      *
1188      * @param src The source of the transformation instructions.
1189      * @return An XMLFilter object, or null if this feature is not supported.
1190      * @throws TransformerConfigurationException
1191      */
1192     @Override
1193     public XMLFilter newXMLFilter(Source src)
1194         throws TransformerConfigurationException
1195     {
1196         Templates templates = newTemplates(src);
1197         if (templates == null) return null;
1198         return newXMLFilter(templates);
1199     }
1200 
1201     /**
1202      * javax.xml.transform.sax.SAXTransformerFactory implementation.
1203      * Create an XMLFilter that uses the given source as the
1204      * transformation instructions.
1205      *
1206      * @param templates The source of the transformation instructions.
1207      * @return An XMLFilter object, or null if this feature is not supported.
1208      * @throws TransformerConfigurationException
1209      */
1210     @Override
1211     public XMLFilter newXMLFilter(Templates templates)
1212         throws TransformerConfigurationException
1213     {
1214         try {
1215             return new com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter(templates);
1216         }
1217         catch (TransformerConfigurationException e1) {
1218             if (_errorListener != null) {
1219                 try {
1220                     _errorListener.fatalError(e1);
1221                     return null;
1222                 }
1223                 catch (TransformerException e2) {
1224                     throw new TransformerConfigurationException(e2);
1225                 }
1226             }
1227             throw e1;
1228         }
1229     }
1230 
1231     /**
1232      * This method implements XSLTC&#39;s SourceLoader interface. It is used to
1233      * glue a TrAX URIResolver to the XSLTC compiler&#39;s Input and Import classes.
1234      *
1235      * @param href The URI of the document to load
1236      * @param context The URI of the currently loaded document
1237      * @param xsltc The compiler that resuests the document
1238      * @return An InputSource with the loaded document
1239      */
1240     @Override
1241     public InputSource loadSource(String href, String context, XSLTC xsltc) {
1242         try {
1243             Source source = null;
1244             if (_uriResolver != null) {
1245                 source = _uriResolver.resolve(href, context);
1246             }
1247             if (source == null &amp;&amp; _catalogFiles != null &amp;&amp;
1248                     _xmlFeatures.getFeature(JdkXmlFeatures.XmlFeature.USE_CATALOG)) {
1249                 if (_catalogUriResolver == null) {
1250                     _catalogUriResolver = CatalogManager.catalogResolver(_catalogFeatures);
1251                 }
1252                 source = _catalogUriResolver.resolve(href, context);
1253             }
1254             if (source != null) {
1255                 return Util.getInputSource(xsltc, source);
1256             }
1257         }
1258         catch (TransformerException e) {
1259             // should catch it when the resolver explicitly throws the exception
1260             final ErrorMsg msg = new ErrorMsg(ErrorMsg.INVALID_URI_ERR, href + &quot;\n&quot; + e.getMessage(), this);
1261             xsltc.getParser().reportError(Constants.FATAL, msg);
1262         }
1263         catch (CatalogException e) {
1264             final ErrorMsg msg = new ErrorMsg(ErrorMsg.CATALOG_EXCEPTION, href + &quot;\n&quot; + e.getMessage(), this);
1265             xsltc.getParser().reportError(Constants.FATAL, msg);
1266         }
1267 
1268         return null;
1269     }
1270 
1271     /**
1272      * Build the CatalogFeatures object when a newTemplates or newTransformer is
1273      * created. This will read any System Properties for the CatalogFeatures that
1274      * may have been set.
1275      */
1276     private CatalogFeatures buildCatalogFeatures() {
1277         // build will cause the CatalogFeatures to read SPs for those not set through the API
1278         if (_catalogFeatures == null) {
1279             _catalogFeatures = cfBuilder.build();
1280         }
1281 
1282         // update fields
1283         _catalogFiles = _catalogFeatures.get(Feature.FILES);
1284         _catalogDefer = _catalogFeatures.get(Feature.DEFER);
1285         _catalogPrefer = _catalogFeatures.get(Feature.PREFER);
1286         _catalogResolve = _catalogFeatures.get(Feature.RESOLVE);
1287 
1288         return _catalogFeatures;
1289     }
1290 
1291     /**
1292      * Reset the per-session attributes to their default values
1293      */
1294     private void resetTransientAttributes() {
1295         _transletName = DEFAULT_TRANSLET_NAME;
1296         _destinationDirectory = null;
1297         _packageName = DEFAULT_TRANSLATE_PACKAGE;
1298         _jarFileName = null;
1299     }
1300 
1301     /**
1302      * Load the translet classes from local .class files and return
1303      * the bytecode array.
1304      *
1305      * @param source The xsl source
1306      * @param fullClassName The full name of the translet
1307      * @return The bytecode array
1308      */
1309     private byte[][] getBytecodesFromClasses(Source source, String fullClassName)
1310     {
1311         if (fullClassName == null)
1312             return null;
1313 
1314         String xslFileName = getStylesheetFileName(source);
1315         File xslFile = null;
1316         if (xslFileName != null)
1317             xslFile = new File(xslFileName);
1318 
1319         // Find the base name of the translet
1320         final String transletName;
1321         int lastDotIndex = fullClassName.lastIndexOf(&#39;.&#39;);
1322         if (lastDotIndex &gt; 0)
1323             transletName = fullClassName.substring(lastDotIndex+1);
1324         else
1325             transletName = fullClassName;
1326 
1327         // Construct the path name for the translet class file
1328         String transletPath = fullClassName.replace(&#39;.&#39;, &#39;/&#39;);
1329         if (_destinationDirectory != null) {
1330             transletPath = _destinationDirectory + &quot;/&quot; + transletPath + &quot;.class&quot;;
1331         }
1332         else {
1333             if (xslFile != null &amp;&amp; xslFile.getParent() != null)
1334                 transletPath = xslFile.getParent() + &quot;/&quot; + transletPath + &quot;.class&quot;;
1335             else
1336                 transletPath = transletPath + &quot;.class&quot;;
1337         }
1338 
1339         // Return null if the translet class file does not exist.
1340         File transletFile = new File(transletPath);
1341         if (!transletFile.exists())
1342             return null;
1343 
1344         // Compare the timestamps of the translet and the xsl file.
1345         // If the translet is older than the xsl file, return null
1346         // so that the xsl file is used for the transformation and
1347         // the translet is regenerated.
1348         if (xslFile != null &amp;&amp; xslFile.exists()) {
1349             long xslTimestamp = xslFile.lastModified();
1350             long transletTimestamp = transletFile.lastModified();
1351             if (transletTimestamp &lt; xslTimestamp)
1352                 return null;
1353         }
1354 
1355         // Load the translet into a bytecode array.
1356         List&lt;byte[]&gt; bytecodes = new ArrayList&lt;&gt;();
1357         int fileLength = (int)transletFile.length();
1358         if (fileLength &gt; 0) {
1359             FileInputStream input;
1360             try {
1361                 input = new FileInputStream(transletFile);
1362             }
1363             catch (FileNotFoundException e) {
1364                 return null;
1365             }
1366 
1367             byte[] bytes = new byte[fileLength];
1368             try {
1369                 readFromInputStream(bytes, input, fileLength);
1370                 input.close();
1371             }
1372             catch (IOException e) {
1373                 return null;
1374             }
1375 
1376             bytecodes.add(bytes);
1377         }
1378         else
1379             return null;
1380 
1381         // Find the parent directory of the translet.
1382         String transletParentDir = transletFile.getParent();
1383         if (transletParentDir == null)
1384             transletParentDir = SecuritySupport.getSystemProperty(&quot;user.dir&quot;);
1385 
1386         File transletParentFile = new File(transletParentDir);
1387 
1388         // Find all the auxiliary files which have a name pattern of &quot;transletClass$nnn.class&quot;.
1389         final String transletAuxPrefix = transletName + &quot;$&quot;;
1390         File[] auxfiles = transletParentFile.listFiles(new FilenameFilter() {
1391                 @Override
1392                 public boolean accept(File dir, String name)
1393                 {
1394                     return (name.endsWith(&quot;.class&quot;) &amp;&amp; name.startsWith(transletAuxPrefix));
1395                 }
1396               });
1397 
1398         // Load the auxiliary class files and add them to the bytecode array.
1399         for (int i = 0; i &lt; auxfiles.length; i++)
1400         {
1401             File auxfile = auxfiles[i];
1402             int auxlength = (int)auxfile.length();
1403             if (auxlength &gt; 0) {
1404                 FileInputStream auxinput = null;
1405                 try {
1406                     auxinput = new FileInputStream(auxfile);
1407                 }
1408                 catch (FileNotFoundException e) {
1409                     continue;
1410                 }
1411 
1412                 byte[] bytes = new byte[auxlength];
1413 
1414                 try {
1415                     readFromInputStream(bytes, auxinput, auxlength);
1416                     auxinput.close();
1417                 }
1418                 catch (IOException e) {
1419                     continue;
1420                 }
1421 
1422                 bytecodes.add(bytes);
1423             }
1424         }
1425 
1426         // Convert the ArrayList of byte[] to byte[][].
1427         final int count = bytecodes.size();
1428         if ( count &gt; 0) {
1429             final byte[][] result = new byte[count][1];
1430             for (int i = 0; i &lt; count; i++) {
1431                 result[i] = bytecodes.get(i);
1432             }
1433 
1434             return result;
1435         }
1436         else
1437             return null;
1438     }
1439 
1440     /**
1441      * Load the translet classes from the jar file and return the bytecode.
1442      *
1443      * @param source The xsl source
1444      * @param fullClassName The full name of the translet
1445      * @return The bytecode array
1446      */
1447     private byte[][] getBytecodesFromJar(Source source, String fullClassName)
1448     {
1449         String xslFileName = getStylesheetFileName(source);
1450         File xslFile = null;
1451         if (xslFileName != null)
1452             xslFile = new File(xslFileName);
1453 
1454         // Construct the path for the jar file
1455         String jarPath;
1456         if (_destinationDirectory != null)
1457             jarPath = _destinationDirectory + &quot;/&quot; + _jarFileName;
1458         else {
1459             if (xslFile != null &amp;&amp; xslFile.getParent() != null)
1460                 jarPath = xslFile.getParent() + &quot;/&quot; + _jarFileName;
1461             else
1462                 jarPath = _jarFileName;
1463         }
1464 
1465         // Return null if the jar file does not exist.
1466         File file = new File(jarPath);
1467         if (!file.exists())
1468             return null;
1469 
1470         // Compare the timestamps of the jar file and the xsl file. Return null
1471         // if the xsl file is newer than the jar file.
1472         if (xslFile != null &amp;&amp; xslFile.exists()) {
1473             long xslTimestamp = xslFile.lastModified();
1474             long transletTimestamp = file.lastModified();
1475             if (transletTimestamp &lt; xslTimestamp)
1476                 return null;
1477         }
1478 
1479         // Create a ZipFile object for the jar file
1480         ZipFile jarFile;
1481         try {
1482             jarFile = new ZipFile(file);
1483         }
1484         catch (IOException e) {
1485             return null;
1486         }
1487 
1488         String transletPath = fullClassName.replace(&#39;.&#39;, &#39;/&#39;);
1489         String transletAuxPrefix = transletPath + &quot;$&quot;;
1490         String transletFullName = transletPath + &quot;.class&quot;;
1491 
1492         List&lt;byte[]&gt; bytecodes = new ArrayList&lt;&gt;();
1493 
1494         // Iterate through all entries in the jar file to find the
1495         // translet and auxiliary classes.
1496         Enumeration&lt;? extends ZipEntry&gt; entries = jarFile.entries();
1497         while (entries.hasMoreElements())
1498         {
1499             ZipEntry entry = (ZipEntry)entries.nextElement();
1500             String entryName = entry.getName();
1501             if (entry.getSize() &gt; 0 &amp;&amp;
1502                   (entryName.equals(transletFullName) ||
1503                   (entryName.endsWith(&quot;.class&quot;) &amp;&amp;
1504                       entryName.startsWith(transletAuxPrefix))))
1505             {
1506                 try {
1507                     InputStream input = jarFile.getInputStream(entry);
1508                     int size = (int)entry.getSize();
1509                     byte[] bytes = new byte[size];
1510                     readFromInputStream(bytes, input, size);
1511                     input.close();
1512                     bytecodes.add(bytes);
1513                 }
1514                 catch (IOException e) {
1515                     return null;
1516                 }
1517             }
1518         }
1519 
1520         // Convert the ArrayList of byte[] to byte[][].
1521         final int count = bytecodes.size();
1522         if (count &gt; 0) {
1523             final byte[][] result = new byte[count][1];
1524             for (int i = 0; i &lt; count; i++) {
1525                 result[i] = bytecodes.get(i);
1526             }
1527 
1528             return result;
1529         }
1530         else
1531             return null;
1532     }
1533 
1534     /**
1535      * Read a given number of bytes from the InputStream into a byte array.
1536      *
1537      * @param bytes The byte array to store the input content.
1538      * @param input The input stream.
1539      * @param size The number of bytes to read.
1540      */
1541     private void readFromInputStream(byte[] bytes, InputStream input, int size)
1542         throws IOException
1543     {
1544       int n = 0;
1545       int offset = 0;
1546       int length = size;
1547       while (length &gt; 0 &amp;&amp; (n = input.read(bytes, offset, length)) &gt; 0) {
1548           offset = offset + n;
1549           length = length - n;
1550       }
1551     }
1552 
1553     /**
1554      * Return the base class name of the translet.
1555      * The translet name is resolved using the following rules:
1556      * 1. if the _transletName attribute is set and its value is not &quot;GregorSamsa&quot;,
1557      *    then _transletName is returned.
1558      * 2. otherwise get the translet name from the base name of the system ID
1559      * 3. return &quot;GregorSamsa&quot; if the result from step 2 is null.
1560      *
1561      * @param source The input Source
1562      * @return The name of the translet class
1563      */
1564     private String getTransletBaseName(Source source)
1565     {
1566         String transletBaseName = null;
1567         if (!_transletName.equals(DEFAULT_TRANSLET_NAME))
1568             return _transletName;
1569         else {
1570             String systemId = source.getSystemId();
1571             if (systemId != null) {
1572                 String baseName = Util.baseName(systemId);
1573                 if (baseName != null) {
1574                     baseName = Util.noExtName(baseName);
1575                     transletBaseName = Util.toJavaName(baseName);
1576                 }
1577             }
1578         }
1579 
1580         return (transletBaseName != null) ? transletBaseName : DEFAULT_TRANSLET_NAME;
1581     }
1582 
1583     /**
1584      *  Return the local file name from the systemId of the Source object
1585      *
1586      * @param source The Source
1587      * @return The file name in the local filesystem, or null if the
1588      * systemId does not represent a local file.
1589      */
1590     private String getStylesheetFileName(Source source)
1591     {
1592         String systemId = source.getSystemId();
1593         if (systemId != null) {
1594             File file = new File(systemId);
1595             if (file.exists())
1596                 return systemId;
1597             else {
1598                 URL url;
1599                 try {
1600                     url = new URL(systemId);
1601                 }
1602                 catch (MalformedURLException e) {
1603                     return null;
1604                 }
1605 
1606                 if (&quot;file&quot;.equals(url.getProtocol()))
1607                     return url.getFile();
1608                 else
1609                     return null;
1610             }
1611         }
1612         else
1613             return null;
1614     }
1615 
1616     /**
1617      * Returns a new instance of the XSLTC DTM Manager service.
1618      */
1619     protected final XSLTCDTMManager createNewDTMManagerInstance() {
1620         return XSLTCDTMManager.createNewDTMManagerInstance();
1621     }
1622 }
    </pre>
  </body>
</html>
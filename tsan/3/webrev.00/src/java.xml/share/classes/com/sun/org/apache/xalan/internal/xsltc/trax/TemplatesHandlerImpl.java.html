<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesHandlerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *     http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xalan.internal.xsltc.trax;
 22 
 23 import com.sun.org.apache.xalan.internal.XalanConstants;
 24 import com.sun.org.apache.xalan.internal.xsltc.compiler.CompilerException;
 25 import com.sun.org.apache.xalan.internal.xsltc.compiler.Parser;
 26 import com.sun.org.apache.xalan.internal.xsltc.compiler.SourceLoader;
 27 import com.sun.org.apache.xalan.internal.xsltc.compiler.Stylesheet;
 28 import com.sun.org.apache.xalan.internal.xsltc.compiler.SyntaxTreeNode;
 29 import com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC;
 30 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
 31 import java.util.ArrayList;
 32 import javax.xml.XMLConstants;
 33 import javax.xml.catalog.CatalogFeatures;
 34 import javax.xml.transform.Source;
 35 import javax.xml.transform.Templates;
 36 import javax.xml.transform.TransformerException;
 37 import javax.xml.transform.URIResolver;
 38 import javax.xml.transform.sax.TemplatesHandler;
 39 import jdk.xml.internal.JdkXmlFeatures;
 40 import org.xml.sax.Attributes;
 41 import org.xml.sax.ContentHandler;
 42 import org.xml.sax.InputSource;
 43 import org.xml.sax.Locator;
 44 import org.xml.sax.SAXException;
 45 
 46 /**
 47  * Implementation of a JAXP1.1 TemplatesHandler
 48  * @author Morten Jorgensen
 49  * @author Santiago Pericas-Geertsen
 50  * @LastModified: July 2019
 51  */
 52 public class TemplatesHandlerImpl
 53     implements ContentHandler, TemplatesHandler, SourceLoader
 54 {
 55     /**
 56      * System ID for this stylesheet.
 57      */
 58     private String _systemId;
 59 
 60     /**
 61      * Number of spaces to add for output indentation.
 62      */
 63     private int _indentNumber;
 64 
 65     /**
 66      * This URIResolver is passed to all Transformers.
 67      */
 68     private URIResolver _uriResolver = null;
 69 
 70     /**
 71      * A reference to the transformer factory that this templates
 72      * object belongs to.
 73      */
 74     private TransformerFactoryImpl _tfactory = null;
 75 
 76     /**
 77      * A reference to XSLTC&#39;s parser object.
 78      */
 79     private Parser _parser = null;
 80 
 81     /**
 82      * The created Templates object.
 83      */
 84     private TemplatesImpl _templates = null;
 85 
 86     // Catalog features
 87     CatalogFeatures _catalogFeatures;
 88 
 89     // Catalog is enabled by default
 90     boolean _useCatalog = true;
 91 
 92     /**
 93      * Default constructor
 94      */
 95     protected TemplatesHandlerImpl(int indentNumber, TransformerFactoryImpl tfactory,
 96             boolean hasUserErrListener)
 97     {
 98         _indentNumber = indentNumber;
 99         _tfactory = tfactory;
100 
101         // Instantiate XSLTC and get reference to parser object
102         XSLTC xsltc = new XSLTC(tfactory.getJdkXmlFeatures(), hasUserErrListener);
103         if (tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING))
104             xsltc.setSecureProcessing(true);
105 
106         xsltc.setProperty(XMLConstants.ACCESS_EXTERNAL_STYLESHEET,
107                 (String)tfactory.getAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET));
108         xsltc.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD,
109                 (String)tfactory.getAttribute(XMLConstants.ACCESS_EXTERNAL_DTD));
110         xsltc.setProperty(XalanConstants.SECURITY_MANAGER,
111                 tfactory.getAttribute(XalanConstants.SECURITY_MANAGER));
112 
113 
114         if (&quot;true&quot;.equals(tfactory.getAttribute(TransformerFactoryImpl.ENABLE_INLINING)))
115             xsltc.setTemplateInlining(true);
116         else
117             xsltc.setTemplateInlining(false);
118 
119         _useCatalog = tfactory.getFeature(XMLConstants.USE_CATALOG);
120         _catalogFeatures = (CatalogFeatures)tfactory.getAttribute(JdkXmlFeatures.CATALOG_FEATURES);
121         xsltc.setProperty(JdkXmlFeatures.CATALOG_FEATURES, _catalogFeatures);
122 
123         _parser = xsltc.getParser();
124     }
125 
126     /**
127      * Implements javax.xml.transform.sax.TemplatesHandler.getSystemId()
128      * Get the base ID (URI or system ID) from where relative URLs will be
129      * resolved.
130      * @return The systemID that was set with setSystemId(String id)
131      */
132     public String getSystemId() {
133         return _systemId;
134     }
135 
136     /**
137      * Implements javax.xml.transform.sax.TemplatesHandler.setSystemId()
138      * Get the base ID (URI or system ID) from where relative URLs will be
139      * resolved.
140      * @param id Base URI for this stylesheet
141      */
142     public void setSystemId(String id) {
143         _systemId = id;
144     }
145 
146     /**
147      * Store URIResolver needed for Transformers.
148      */
149     public void setURIResolver(URIResolver resolver) {
150         _uriResolver = resolver;
151     }
152 
153     /**
154      * Implements javax.xml.transform.sax.TemplatesHandler.getTemplates()
155      * When a TemplatesHandler object is used as a ContentHandler or
156      * DocumentHandler for the parsing of transformation instructions, it
157      * creates a Templates object, which the caller can get once the SAX
158      * events have been completed.
159      * @return The Templates object that was created during the SAX event
160      *         process, or null if no Templates object has been created.
161      */
162     public Templates getTemplates() {
163         return _templates;
164     }
165 
166     /**
167      * This method implements XSLTC&#39;s SourceLoader interface. It is used to
168      * glue a TrAX URIResolver to the XSLTC compiler&#39;s Input and Import classes.
169      *
170      * @param href The URI of the document to load
171      * @param context The URI of the currently loaded document
172      * @param xsltc The compiler that resuests the document
173      * @return An InputSource with the loaded document
174      */
175     public InputSource loadSource(String href, String context, XSLTC xsltc) {
176         try {
177             // A _uriResolver must be set if this method is called
178             final Source source = _uriResolver.resolve(href, context);
179             if (source != null) {
180                 return Util.getInputSource(xsltc, source);
181             }
182         }
183         catch (TransformerException e) {
184             // Falls through
185         }
186         return null;
187     }
188 
189     // -- ContentHandler --------------------------------------------------
190 
191     /**
192      * Re-initialize parser and forward SAX2 event.
193      */
194     public void startDocument() {
195         XSLTC xsltc = _parser.getXSLTC();
196         xsltc.init();   // calls _parser.init()
197         xsltc.setOutputType(XSLTC.BYTEARRAY_OUTPUT);
198         _parser.startDocument();
199     }
200 
201     /**
202      * Just forward SAX2 event to parser object.
203      */
204     public void endDocument() throws SAXException {
205         _parser.endDocument();
206 
207         // create the templates
208         try {
209             XSLTC xsltc = _parser.getXSLTC();
210 
211             // Set the translet class name if not already set
212             String transletName;
213             if (_systemId != null) {
214                 transletName = Util.baseName(_systemId);
215             }
216             else {
217                 transletName = (String)_tfactory.getAttribute(&quot;translet-name&quot;);
218             }
219             xsltc.setClassName(transletName);
220 
221             // Get java-legal class name from XSLTC module
222             transletName = xsltc.getClassName();
223 
224             Stylesheet stylesheet = null;
225             SyntaxTreeNode root = _parser.getDocumentRoot();
226 
227             // Compile the translet - this is where the work is done!
228             if (!_parser.errorsFound() &amp;&amp; root != null) {
229                 // Create a Stylesheet element from the root node
230                 stylesheet = _parser.makeStylesheet(root);
231                 stylesheet.setSystemId(_systemId);
232                 stylesheet.setParentStylesheet(null);
233 
234                 if (xsltc.getTemplateInlining())
235                    stylesheet.setTemplateInlining(true);
236                 else
237                    stylesheet.setTemplateInlining(false);
238 
239                 // Set a document loader (for xsl:include/import) if defined
240                 if (_uriResolver != null || (_useCatalog &amp;&amp;
241                         _catalogFeatures.get(CatalogFeatures.Feature.FILES) != null)) {
242                     stylesheet.setSourceLoader(this);
243                 }
244 
245                 _parser.setCurrentStylesheet(stylesheet);
246 
247                 // Set it as top-level in the XSLTC object
248                 xsltc.setStylesheet(stylesheet);
249 
250                 // Create AST under the Stylesheet element
251                 _parser.createAST(stylesheet);
252             }
253 
254             // Generate the bytecodes and output the translet class(es)
255             if (!_parser.errorsFound() &amp;&amp; stylesheet != null) {
256                 stylesheet.setMultiDocument(xsltc.isMultiDocument());
257                 stylesheet.setHasIdCall(xsltc.hasIdCall());
258 
259                 // Class synchronization is needed for BCEL
260                 synchronized (xsltc.getClass()) {
261                     stylesheet.translate();
262                 }
263             }
264 
265             if (!_parser.errorsFound()) {
266                 // Check that the transformation went well before returning
267                 final byte[][] bytecodes = xsltc.getBytecodes();
268                 if (bytecodes != null) {
269                     _templates =
270                     new TemplatesImpl(xsltc.getBytecodes(), transletName,
271                         _parser.getOutputProperties(), _indentNumber, _tfactory);
272 
273                     // Set URIResolver on templates object
274                     if (_uriResolver != null) {
275                         _templates.setURIResolver(_uriResolver);
276                     }
277                 }
278             }
279             else {
280                 StringBuilder errorMessage = new StringBuilder();
281                 ArrayList&lt;ErrorMsg&gt; errors = _parser.getErrors();
282                 final int count = errors.size();
283                 for (int i = 0; i &lt; count; i++) {
284                     if (errorMessage.length() &gt; 0)
285                         errorMessage.append(&#39;\n&#39;);
286                     errorMessage.append(errors.get(i).toString());
287                 }
288                 throw new SAXException(ErrorMsg.JAXP_COMPILE_ERR, new TransformerException(errorMessage.toString()));
289             }
290         }
291         catch (CompilerException e) {
292             throw new SAXException(ErrorMsg.JAXP_COMPILE_ERR, e);
293         }
294     }
295 
296     /**
297      * Just forward SAX2 event to parser object.
298      */
299     public void startPrefixMapping(String prefix, String uri) {
300         _parser.startPrefixMapping(prefix, uri);
301     }
302 
303     /**
304      * Just forward SAX2 event to parser object.
305      */
306     public void endPrefixMapping(String prefix) {
307         _parser.endPrefixMapping(prefix);
308     }
309 
310     /**
311      * Just forward SAX2 event to parser object.
312      */
313     public void startElement(String uri, String localname, String qname,
314         Attributes attributes) throws SAXException
315     {
316         _parser.startElement(uri, localname, qname, attributes);
317     }
318 
319     /**
320      * Just forward SAX2 event to parser object.
321      */
322     public void endElement(String uri, String localname, String qname) {
323         _parser.endElement(uri, localname, qname);
324     }
325 
326     /**
327      * Just forward SAX2 event to parser object.
328      */
329     public void characters(char[] ch, int start, int length) {
330         _parser.characters(ch, start, length);
331     }
332 
333     /**
334      * Just forward SAX2 event to parser object.
335      */
336     public void processingInstruction(String name, String value) {
337         _parser.processingInstruction(name, value);
338     }
339 
340     /**
341      * Just forward SAX2 event to parser object.
342      */
343     public void ignorableWhitespace(char[] ch, int start, int length) {
344         _parser.ignorableWhitespace(ch, start, length);
345     }
346 
347     /**
348      * Just forward SAX2 event to parser object.
349      */
350     public void skippedEntity(String name) {
351         _parser.skippedEntity(name);
352     }
353 
354     /**
355      * Set internal system Id and forward SAX2 event to parser object.
356      */
357     public void setDocumentLocator(Locator locator) {
358         setSystemId(locator.getSystemId());
359         _parser.setDocumentLocator(locator);
360     }
361 }
    </pre>
  </body>
</html>
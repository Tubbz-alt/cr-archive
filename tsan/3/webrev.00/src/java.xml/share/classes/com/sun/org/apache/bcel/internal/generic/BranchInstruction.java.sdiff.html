<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/BranchInstruction.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BranchHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CALOAD.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/BranchInstruction.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * reserved comment block</span>
<span class="line-removed">  3  * DO NOT REMOVE OR ALTER!</span>
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import java.io.DataOutputStream;
 24 import java.io.IOException;
 25 
 26 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 27 
 28 /**
<span class="line-modified"> 29  * Abstract super class for branching instructions like GOTO, IFEQ, etc.. Branch</span>
<span class="line-modified"> 30  * instructions may have a variable length, namely GOTO, JSR, LOOKUPSWITCH and</span>
<span class="line-modified"> 31  * TABLESWITCH.</span>
 32  *
 33  * @see InstructionList
<span class="line-modified"> 34  * @version $Id: BranchInstruction.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 35  */
 36 public abstract class BranchInstruction extends Instruction implements InstructionTargeter {
 37 
 38     private int index; // Branch target relative to this instruction
 39     private InstructionHandle target; // Target object in instruction list
 40     private int position; // Byte code offset
 41 
 42     /**
 43      * Empty constructor needed for the Class.newInstance() statement in
 44      * Instruction.readInstruction(). Not to be used otherwise.
 45      */
 46     BranchInstruction() {
 47     }
 48 
<span class="line-modified"> 49     /**</span>
<span class="line-modified"> 50      * Common super constructor</span>
<span class="line-removed"> 51      *</span>
 52      * @param opcode Instruction opcode
 53      * @param target instruction to branch to
 54      */
 55     protected BranchInstruction(final short opcode, final InstructionHandle target) {
 56         super(opcode, (short) 3);
 57         setTarget(target);
 58     }
 59 

 60     /**
 61      * Dump instruction as byte code to stream out.
<span class="line-removed"> 62      *</span>
 63      * @param out Output stream
 64      */
 65     @Override
<span class="line-modified"> 66     public void dump(final DataOutputStream out) throws IOException {</span>
 67         out.writeByte(super.getOpcode());
 68         index = getTargetOffset();
 69         if (!isValidShort(index)) {
 70             throw new ClassGenException(&quot;Branch target offset too large for short: &quot; + index);
 71         }
 72         out.writeShort(index); // May be negative, i.e., point backwards
 73     }
 74 

 75     /**
 76      * @param _target branch target
<span class="line-modified"> 77      * @return the offset to `target&#39; relative to this instruction</span>
 78      */
<span class="line-modified"> 79     protected int getTargetOffset(final InstructionHandle _target) {</span>
 80         if (_target == null) {
 81             throw new ClassGenException(&quot;Target of &quot; + super.toString(true)
 82                     + &quot; is invalid null handle&quot;);
 83         }
 84         final int t = _target.getPosition();
 85         if (t &lt; 0) {
 86             throw new ClassGenException(&quot;Invalid branch target position offset for &quot;
 87                     + super.toString(true) + &quot;:&quot; + t + &quot;:&quot; + _target);
 88         }
 89         return t - position;
 90     }
 91 

 92     /**
 93      * @return the offset to this instruction&#39;s target
 94      */
 95     protected int getTargetOffset() {
 96         return getTargetOffset(target);
 97     }
 98 

 99     /**
<span class="line-modified">100      * Called by InstructionList.setPositions when setting the position for</span>
<span class="line-modified">101      * every instruction. In the presence of variable length instructions</span>
<span class="line-modified">102      * `setPositions&#39; performs multiple passes over the instruction list to</span>
<span class="line-modified">103      * calculate the correct (byte) positions and offsets by calling this</span>
<span class="line-removed">104      * function.</span>
105      *
<span class="line-modified">106      * @param offset additional offset caused by preceding (variable length)</span>
<span class="line-modified">107      * instructions</span>
<span class="line-modified">108      * @param max_offset the maximum offset that may be caused by these</span>
<span class="line-removed">109      * instructions</span>
<span class="line-removed">110      * @return additional offset caused by possible change of this instruction&#39;s</span>
<span class="line-removed">111      * length</span>
112      */
<span class="line-modified">113     protected int updatePosition(final int offset, final int max_offset) {</span>
114         position += offset;
115         return 0;
116     }
117 

118     /**
119      * Long output format:
120      *
<span class="line-modified">121      * &amp;lt;position in byte code&amp;gt; &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode</span>
<span class="line-modified">122      * number&amp;gt;&quot;]&quot; &quot;(&quot;&amp;lt;length of instruction&amp;gt;&quot;)&quot; &quot;&amp;lt;&quot;&amp;lt;target</span>
<span class="line-modified">123      * instruction&amp;gt;&quot;&amp;gt;&quot; &quot;@&quot;&amp;lt;branch target offset&amp;gt;</span>

124      *
125      * @param verbose long/short format switch
126      * @return mnemonic for instruction
127      */
128     @Override
<span class="line-modified">129     public String toString(final boolean verbose) {</span>
130         final String s = super.toString(verbose);
131         String t = &quot;null&quot;;
132         if (verbose) {
133             if (target != null) {
134                 if (target.getInstruction() == this) {
135                     t = &quot;&lt;points to itself&gt;&quot;;
136                 } else if (target.getInstruction() == null) {
137                     t = &quot;&lt;null instruction!!!?&gt;&quot;;
138                 } else {
139                     // I&#39;m more interested in the address of the target then
140                     // the instruction located there.
141                     //t = target.getInstruction().toString(false); // Avoid circles
142                     t = &quot;&quot; + target.getPosition();
143                 }
144             }
145         } else {
146             if (target != null) {
147                 index = target.getPosition();
148                 // index = getTargetOffset();  crashes if positions haven&#39;t been set
149                 // t = &quot;&quot; + (index + position);
150                 t = &quot;&quot; + index;
151             }
152         }
153         return s + &quot; -&gt; &quot; + t;
154     }
155 

156     /**
<span class="line-modified">157      * Read needed data (e.g. index) from file. Conversion to a</span>
<span class="line-modified">158      * InstructionHandle is done in InstructionList(byte[]).</span>
159      *
160      * @param bytes input stream
161      * @param wide wide prefix?
162      * @see InstructionList
163      */
164     @Override
<span class="line-modified">165     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {</span>
166         super.setLength(3);
167         index = bytes.readShort();
168     }
169 

170     /**
171      * @return target offset in byte code
172      */
173     public final int getIndex() {
174         return index;
175     }
176 

177     /**
178      * @return target of branch instruction
179      */
180     public InstructionHandle getTarget() {
181         return target;
182     }
183 

184     /**
185      * Set branch target
<span class="line-removed">186      *</span>
187      * @param target branch target
188      */
<span class="line-modified">189     public void setTarget(final InstructionHandle target) {</span>
190         notifyTarget(this.target, target, this);
191         this.target = target;
192     }
193 

194     /**
<span class="line-modified">195      * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen,</span>
<span class="line-removed">196      * LineNumberGen</span>
197      */
<span class="line-modified">198     static void notifyTarget(final InstructionHandle old_ih, final InstructionHandle new_ih,</span>
<span class="line-modified">199             final InstructionTargeter t) {</span>
200         if (old_ih != null) {
201             old_ih.removeTargeter(t);
202         }
203         if (new_ih != null) {
204             new_ih.addTargeter(t);
205         }
206     }
207 

208     /**
209      * @param old_ih old target
210      * @param new_ih new target
211      */
212     @Override
<span class="line-modified">213     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
214         if (target == old_ih) {
215             setTarget(new_ih);
216         } else {
217             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but &quot; + target);
218         }
219     }
220 

221     /**
222      * @return true, if ih is target of this instruction
223      */
224     @Override
<span class="line-modified">225     public boolean containsTarget(final InstructionHandle ih) {</span>
226         return target == ih;
227     }
228 

229     /**
230      * Inform target that it&#39;s not targeted anymore.
231      */
232     @Override
233     void dispose() {
234         setTarget(null);
235         index = -1;
236         position = -1;
237     }
238 

239     /**
240      * @return the position
241      * @since 6.0
242      */
243     protected int getPosition() {
244         return position;
245     }
246 

247     /**
248      * @param position the position to set
249      * @since 6.0
250      */
251     protected void setPosition(final int position) {
252         this.position = position;
253     }
254 

255     /**
256      * @param index the index to set
257      * @since 6.0
258      */
259     protected void setIndex(final int index) {
260         this.index = index;
261     }
262 
263 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>

  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 26 
 27 /**
<span class="line-modified"> 28  * Abstract super class for branching instructions like GOTO, IFEQ, etc..</span>
<span class="line-modified"> 29  * Branch instructions may have a variable length, namely GOTO, JSR,</span>
<span class="line-modified"> 30  * LOOKUPSWITCH and TABLESWITCH.</span>
 31  *
 32  * @see InstructionList
<span class="line-modified"> 33  * @LastModified: Jan 2020</span>
 34  */
 35 public abstract class BranchInstruction extends Instruction implements InstructionTargeter {
 36 
 37     private int index; // Branch target relative to this instruction
 38     private InstructionHandle target; // Target object in instruction list
 39     private int position; // Byte code offset
 40 
 41     /**
 42      * Empty constructor needed for the Class.newInstance() statement in
 43      * Instruction.readInstruction(). Not to be used otherwise.
 44      */
 45     BranchInstruction() {
 46     }
 47 
<span class="line-modified"> 48 </span>
<span class="line-modified"> 49     /** Common super constructor</span>

 50      * @param opcode Instruction opcode
 51      * @param target instruction to branch to
 52      */
 53     protected BranchInstruction(final short opcode, final InstructionHandle target) {
 54         super(opcode, (short) 3);
 55         setTarget(target);
 56     }
 57 
<span class="line-added"> 58 </span>
 59     /**
 60      * Dump instruction as byte code to stream out.

 61      * @param out Output stream
 62      */
 63     @Override
<span class="line-modified"> 64     public void dump( final DataOutputStream out ) throws IOException {</span>
 65         out.writeByte(super.getOpcode());
 66         index = getTargetOffset();
 67         if (!isValidShort(index)) {
 68             throw new ClassGenException(&quot;Branch target offset too large for short: &quot; + index);
 69         }
 70         out.writeShort(index); // May be negative, i.e., point backwards
 71     }
 72 
<span class="line-added"> 73 </span>
 74     /**
 75      * @param _target branch target
<span class="line-modified"> 76      * @return the offset to  `target&#39; relative to this instruction</span>
 77      */
<span class="line-modified"> 78     protected int getTargetOffset( final InstructionHandle _target ) {</span>
 79         if (_target == null) {
 80             throw new ClassGenException(&quot;Target of &quot; + super.toString(true)
 81                     + &quot; is invalid null handle&quot;);
 82         }
 83         final int t = _target.getPosition();
 84         if (t &lt; 0) {
 85             throw new ClassGenException(&quot;Invalid branch target position offset for &quot;
 86                     + super.toString(true) + &quot;:&quot; + t + &quot;:&quot; + _target);
 87         }
 88         return t - position;
 89     }
 90 
<span class="line-added"> 91 </span>
 92     /**
 93      * @return the offset to this instruction&#39;s target
 94      */
 95     protected int getTargetOffset() {
 96         return getTargetOffset(target);
 97     }
 98 
<span class="line-added"> 99 </span>
100     /**
<span class="line-modified">101      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified">102      * instruction. In the presence of variable length instructions `setPositions&#39;</span>
<span class="line-modified">103      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified">104      * correct (byte) positions and offsets by calling this function.</span>

105      *
<span class="line-modified">106      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified">107      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified">108      * @return additional offset caused by possible change of this instruction&#39;s length</span>



109      */
<span class="line-modified">110     protected int updatePosition( final int offset, final int max_offset ) {</span>
111         position += offset;
112         return 0;
113     }
114 
<span class="line-added">115 </span>
116     /**
117      * Long output format:
118      *
<span class="line-modified">119      * &amp;lt;position in byte code&amp;gt;</span>
<span class="line-modified">120      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot;</span>
<span class="line-modified">121      * &quot;(&quot;&amp;lt;length of instruction&amp;gt;&quot;)&quot;</span>
<span class="line-added">122      * &quot;&amp;lt;&quot;&amp;lt;target instruction&amp;gt;&quot;&amp;gt;&quot; &quot;@&quot;&amp;lt;branch target offset&amp;gt;</span>
123      *
124      * @param verbose long/short format switch
125      * @return mnemonic for instruction
126      */
127     @Override
<span class="line-modified">128     public String toString( final boolean verbose ) {</span>
129         final String s = super.toString(verbose);
130         String t = &quot;null&quot;;
131         if (verbose) {
132             if (target != null) {
133                 if (target.getInstruction() == this) {
134                     t = &quot;&lt;points to itself&gt;&quot;;
135                 } else if (target.getInstruction() == null) {
136                     t = &quot;&lt;null instruction!!!?&gt;&quot;;
137                 } else {
138                     // I&#39;m more interested in the address of the target then
139                     // the instruction located there.
140                     //t = target.getInstruction().toString(false); // Avoid circles
141                     t = &quot;&quot; + target.getPosition();
142                 }
143             }
144         } else {
145             if (target != null) {
146                 index = target.getPosition();
147                 // index = getTargetOffset();  crashes if positions haven&#39;t been set
148                 // t = &quot;&quot; + (index + position);
149                 t = &quot;&quot; + index;
150             }
151         }
152         return s + &quot; -&gt; &quot; + t;
153     }
154 
<span class="line-added">155 </span>
156     /**
<span class="line-modified">157      * Read needed data (e.g. index) from file. Conversion to a InstructionHandle</span>
<span class="line-modified">158      * is done in InstructionList(byte[]).</span>
159      *
160      * @param bytes input stream
161      * @param wide wide prefix?
162      * @see InstructionList
163      */
164     @Override
<span class="line-modified">165     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
166         super.setLength(3);
167         index = bytes.readShort();
168     }
169 
<span class="line-added">170 </span>
171     /**
172      * @return target offset in byte code
173      */
174     public final int getIndex() {
175         return index;
176     }
177 
<span class="line-added">178 </span>
179     /**
180      * @return target of branch instruction
181      */
182     public InstructionHandle getTarget() {
183         return target;
184     }
185 
<span class="line-added">186 </span>
187     /**
188      * Set branch target

189      * @param target branch target
190      */
<span class="line-modified">191     public void setTarget( final InstructionHandle target ) {</span>
192         notifyTarget(this.target, target, this);
193         this.target = target;
194     }
195 
<span class="line-added">196 </span>
197     /**
<span class="line-modified">198      * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen</span>

199      */
<span class="line-modified">200     static void notifyTarget( final InstructionHandle old_ih, final InstructionHandle new_ih,</span>
<span class="line-modified">201             final InstructionTargeter t ) {</span>
202         if (old_ih != null) {
203             old_ih.removeTargeter(t);
204         }
205         if (new_ih != null) {
206             new_ih.addTargeter(t);
207         }
208     }
209 
<span class="line-added">210 </span>
211     /**
212      * @param old_ih old target
213      * @param new_ih new target
214      */
215     @Override
<span class="line-modified">216     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
217         if (target == old_ih) {
218             setTarget(new_ih);
219         } else {
220             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but &quot; + target);
221         }
222     }
223 
<span class="line-added">224 </span>
225     /**
226      * @return true, if ih is target of this instruction
227      */
228     @Override
<span class="line-modified">229     public boolean containsTarget( final InstructionHandle ih ) {</span>
230         return target == ih;
231     }
232 
<span class="line-added">233 </span>
234     /**
235      * Inform target that it&#39;s not targeted anymore.
236      */
237     @Override
238     void dispose() {
239         setTarget(null);
240         index = -1;
241         position = -1;
242     }
243 
<span class="line-added">244 </span>
245     /**
246      * @return the position
247      * @since 6.0
248      */
249     protected int getPosition() {
250         return position;
251     }
252 
<span class="line-added">253 </span>
254     /**
255      * @param position the position to set
256      * @since 6.0
257      */
258     protected void setPosition(final int position) {
259         this.position = position;
260     }
261 
<span class="line-added">262 </span>
263     /**
264      * @param index the index to set
265      * @since 6.0
266      */
267     protected void setIndex(final int index) {
268         this.index = index;
269     }
270 
271 }
</pre>
</td>
</tr>
</table>
<center><a href="BranchHandle.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CALOAD.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
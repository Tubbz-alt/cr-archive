<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
<a name="2" id="anc2"></a><span class="line-modified">   4 /*</span>
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.generic;
  21 
  22 import com.sun.org.apache.bcel.internal.Const;
  23 import com.sun.org.apache.bcel.internal.classfile.Constant;
  24 import com.sun.org.apache.bcel.internal.util.ByteSequence;
  25 import java.io.ByteArrayOutputStream;
  26 import java.io.DataOutputStream;
  27 import java.io.IOException;
  28 import java.util.ArrayList;
  29 import java.util.HashMap;
  30 import java.util.Iterator;
  31 import java.util.List;
  32 import java.util.Map;
  33 import java.util.NoSuchElementException;
  34 
  35 /**
  36  * This class is a container for a list of &lt;a
  37  * href=&quot;Instruction.html&quot;&gt;Instruction&lt;/a&gt; objects. Instructions can be
  38  * appended, inserted, moved, deleted, etc.. Instructions are being wrapped into
  39  * &lt;a href=&quot;InstructionHandle.html&quot;&gt;InstructionHandles&lt;/a&gt; objects that are
  40  * returned upon append/insert operations. They give the user (read only) access
  41  * to the list structure, such that it can be traversed and manipulated in a
  42  * controlled way.
  43  *
  44  * A list is finally dumped to a byte code array with &lt;a
  45  * href=&quot;#getByteCode()&quot;&gt;getByteCode&lt;/a&gt;.
  46  *
<a name="3" id="anc3"></a><span class="line-removed">  47  * @version $Id: InstructionList.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
  48  * @see Instruction
  49  * @see InstructionHandle
  50  * @see BranchHandle
<a name="4" id="anc4"></a>
  51  */
  52 public class InstructionList implements Iterable&lt;InstructionHandle&gt; {
<a name="5" id="anc5"></a>
  53     private InstructionHandle start = null;
  54     private InstructionHandle end = null;
  55     private int length = 0; // number of elements in list
  56     private int[] byte_positions; // byte code offsets corresponding to instructions
  57 
  58     /**
  59      * Create (empty) instruction list.
  60      */
  61     public InstructionList() {
  62     }
  63 
  64     /**
  65      * Create instruction list containing one instruction.
  66      *
<a name="6" id="anc6"></a><span class="line-modified">  67      * @param i initial instruction</span>

  68      */
  69     public InstructionList(final Instruction i) {
  70         append(i);
  71     }
  72 
  73     /**
  74      * Create instruction list containing one instruction.
  75      *
<a name="7" id="anc7"></a><span class="line-modified">  76      * @param i initial instruction</span>

  77      */
  78     public InstructionList(final BranchInstruction i) {
  79         append(i);
  80     }
  81 
  82     /**
  83      * Initialize list with (nonnull) compound instruction. Consumes argument
  84      * list, i.e., it becomes empty.
  85      *
<a name="8" id="anc8"></a><span class="line-modified">  86      * @param c compound instruction (list)</span>

  87      */
  88     public InstructionList(final CompoundInstruction c) {
  89         append(c.getInstructionList());
  90     }
  91 
  92     /**
  93      * Test for empty list.
  94      */
  95     public boolean isEmpty() {
  96         return start == null;
  97     } // &amp;&amp; end == null
  98 
  99     /**
 100      * Find the target instruction (handle) that corresponds to the given target
 101      * position (byte code offset).
 102      *
<a name="9" id="anc9"></a><span class="line-modified"> 103      * @param ihs array of instruction handles, i.e. il.getInstructionHandles()</span>
<span class="line-modified"> 104      * @param pos array of positions corresponding to ihs, i.e.</span>
<span class="line-modified"> 105      * il.getInstructionPositions()</span>
<span class="line-modified"> 106      * @param count length of arrays</span>
<span class="line-modified"> 107      * @param target target position to search for</span>



 108      * @return target position&#39;s instruction handle if available
 109      */
<a name="10" id="anc10"></a><span class="line-modified"> 110     public static InstructionHandle findHandle(final InstructionHandle[] ihs, final int[] pos, final int count, final int target) {</span>

 111         int l = 0;
 112         int r = count - 1;
 113         /*
 114          * Do a binary search since the pos array is orderd.
 115          */
 116         do {
<a name="11" id="anc11"></a><span class="line-modified"> 117             final int i = (l + r) / 2;</span>
 118             final int j = pos[i];
 119             if (j == target) {
 120                 return ihs[i];
 121             } else if (target &lt; j) {
 122                 r = i - 1;
 123             } else {
 124                 l = i + 1;
 125             }
 126         } while (l &lt;= r);
 127         return null;
 128     }
 129 
 130     /**
 131      * Get instruction handle for instruction at byte code position pos. This
 132      * only works properly, if the list is freshly initialized from a byte array
 133      * or setPositions() has been called before this method.
 134      *
<a name="12" id="anc12"></a><span class="line-modified"> 135      * @param pos byte code position to search for</span>

 136      * @return target position&#39;s instruction handle if available
 137      */
 138     public InstructionHandle findHandle(final int pos) {
 139         final int[] positions = byte_positions;
 140         InstructionHandle ih = start;
 141         for (int i = 0; i &lt; length; i++) {
 142             if (positions[i] == pos) {
 143                 return ih;
 144             }
 145             ih = ih.getNext();
 146         }
 147         return null;
 148     }
 149 
 150     /**
 151      * Initialize instruction list from byte array.
 152      *
<a name="13" id="anc13"></a><span class="line-modified"> 153      * @param code byte array containing the instructions</span>

 154      */
 155     public InstructionList(final byte[] code) {
 156         int count = 0; // Contains actual length
 157         int[] pos;
 158         InstructionHandle[] ihs;
 159         try (ByteSequence bytes = new ByteSequence(code)) {
 160             ihs = new InstructionHandle[code.length];
 161             pos = new int[code.length]; // Can&#39;t be more than that
 162             /*
 163              * Pass 1: Create an object for each byte code and append them to the list.
 164              */
 165             while (bytes.available() &gt; 0) {
 166                 // Remember byte offset and associate it with the instruction
 167                 final int off = bytes.getIndex();
 168                 pos[count] = off;
 169                 /*
 170                  * Read one instruction from the byte stream, the byte position is set accordingly.
 171                  */
 172                 final Instruction i = Instruction.readInstruction(bytes);
 173                 InstructionHandle ih;
 174                 if (i instanceof BranchInstruction) {
 175                     ih = append((BranchInstruction) i);
 176                 } else {
 177                     ih = append(i);
 178                 }
 179                 ih.setPosition(off);
 180                 ihs[count] = ih;
 181                 count++;
 182             }
 183         } catch (final IOException e) {
 184             throw new ClassGenException(e.toString(), e);
 185         }
 186         byte_positions = new int[count]; // Trim to proper size
 187         System.arraycopy(pos, 0, byte_positions, 0, count);
 188         /*
 189          * Pass 2: Look for BranchInstruction and update their targets, i.e., convert offsets to instruction handles.
 190          */
 191         for (int i = 0; i &lt; count; i++) {
 192             if (ihs[i] instanceof BranchHandle) {
 193                 final BranchInstruction bi = (BranchInstruction) ihs[i].getInstruction();
<a name="14" id="anc14"></a><span class="line-modified"> 194                 int target = bi.getPosition() + bi.getIndex(); /*</span>

 195                  * Byte code position: relative -&gt; absolute.
<a name="15" id="anc15"></a><span class="line-modified"> 196                  */</span>
<span class="line-removed"> 197 </span>
 198                 // Search for target position
<a name="16" id="anc16"></a><span class="line-removed"> 199 </span>
 200                 InstructionHandle ih = findHandle(ihs, pos, count, target);
 201                 if (ih == null) {
 202                     throw new ClassGenException(&quot;Couldn&#39;t find target for branch: &quot; + bi);
 203                 }
 204                 bi.setTarget(ih); // Update target
 205                 // If it is a Select instruction, update all branch targets
 206                 if (bi instanceof Select) { // Either LOOKUPSWITCH or TABLESWITCH
 207                     final Select s = (Select) bi;
 208                     final int[] indices = s.getIndices();
 209                     for (int j = 0; j &lt; indices.length; j++) {
 210                         target = bi.getPosition() + indices[j];
 211                         ih = findHandle(ihs, pos, count, target);
 212                         if (ih == null) {
 213                             throw new ClassGenException(&quot;Couldn&#39;t find target for switch: &quot; + bi);
 214                         }
 215                         s.setTarget(j, ih); // Update target
 216                     }
 217                 }
 218             }
 219         }
 220     }
 221 
 222     /**
 223      * Append another list after instruction (handle) ih contained in this list.
 224      * Consumes argument list, i.e., it becomes empty.
 225      *
<a name="17" id="anc17"></a><span class="line-modified"> 226      * @param ih where to append the instruction list</span>
<span class="line-modified"> 227      * @param il Instruction list to append to this one</span>
<span class="line-modified"> 228      * @return instruction handle pointing to the &lt;B&gt;first&lt;/B&gt; appended</span>
<span class="line-modified"> 229      * instruction</span>

 230      */
 231     public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {
 232         if (il == null) {
 233             throw new ClassGenException(&quot;Appending null InstructionList&quot;);
 234         }
 235         if (il.isEmpty()) {
 236             return ih;
 237         }
 238         final InstructionHandle next = ih.getNext();
 239         final InstructionHandle ret = il.start;
 240         ih.setNext(il.start);
 241         il.start.setPrev(ih);
 242         il.end.setNext(next);
 243         if (next != null) {
 244             next.setPrev(il.end);
 245         } else {
 246             end = il.end; // Update end ...
 247         }
 248         length += il.length; // Update length
 249         il.clear();
 250         return ret;
 251     }
 252 
 253     /**
 254      * Append another list after instruction i contained in this list. Consumes
 255      * argument list, i.e., it becomes empty.
 256      *
<a name="18" id="anc18"></a><span class="line-modified"> 257      * @param i where to append the instruction list</span>
<span class="line-modified"> 258      * @param il Instruction list to append to this one</span>
<span class="line-modified"> 259      * @return instruction handle pointing to the &lt;B&gt;first&lt;/B&gt; appended</span>
<span class="line-modified"> 260      * instruction</span>

 261      */
 262     public InstructionHandle append(final Instruction i, final InstructionList il) {
 263         InstructionHandle ih;
 264         if ((ih = findInstruction2(i)) == null) {
 265             throw new ClassGenException(&quot;Instruction &quot; + i + &quot; is not contained in this list.&quot;);
 266         }
 267         return append(ih, il);
 268     }
 269 
 270     /**
 271      * Append another list to this one. Consumes argument list, i.e., it becomes
 272      * empty.
 273      *
<a name="19" id="anc19"></a><span class="line-modified"> 274      * @param il list to append to end of this list</span>

 275      * @return instruction handle of the &lt;B&gt;first&lt;/B&gt; appended instruction
 276      */
 277     public InstructionHandle append(final InstructionList il) {
 278         if (il == null) {
 279             throw new ClassGenException(&quot;Appending null InstructionList&quot;);
 280         }
 281         if (il.isEmpty()) {
 282             return null;
 283         }
 284         if (isEmpty()) {
 285             start = il.start;
 286             end = il.end;
 287             length = il.length;
 288             il.clear();
 289             return start;
 290         }
 291         return append(end, il); // was end.instruction
 292     }
 293 
 294     /**
 295      * Append an instruction to the end of this list.
 296      *
<a name="20" id="anc20"></a><span class="line-modified"> 297      * @param ih instruction to append</span>

 298      */
 299     private void append(final InstructionHandle ih) {
 300         if (isEmpty()) {
 301             start = end = ih;
 302             ih.setNext(ih.setPrev(null));
 303         } else {
 304             end.setNext(ih);
 305             ih.setPrev(end);
 306             ih.setNext(null);
 307             end = ih;
 308         }
<a name="21" id="anc21"></a><span class="line-removed"> 309 </span>
 310         length++; // Update length
 311     }
 312 
 313     /**
 314      * Append an instruction to the end of this list.
 315      *
<a name="22" id="anc22"></a><span class="line-modified"> 316      * @param i instruction to append</span>

 317      * @return instruction handle of the appended instruction
 318      */
 319     public InstructionHandle append(final Instruction i) {
 320         final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);
 321         append(ih);
 322         return ih;
 323     }
 324 
 325     /**
 326      * Append a branch instruction to the end of this list.
 327      *
<a name="23" id="anc23"></a><span class="line-modified"> 328      * @param i branch instruction to append</span>

 329      * @return branch instruction handle of the appended instruction
 330      */
 331     public BranchHandle append(final BranchInstruction i) {
 332         final BranchHandle ih = BranchHandle.getBranchHandle(i);
 333         append(ih);
 334         return ih;
 335     }
 336 
 337     /**
 338      * Append a single instruction j after another instruction i, which must be
 339      * in this list of course!
 340      *
<a name="24" id="anc24"></a><span class="line-modified"> 341      * @param i Instruction in list</span>
<span class="line-modified"> 342      * @param j Instruction to append after i in list</span>


 343      * @return instruction handle of the first appended instruction
 344      */
 345     public InstructionHandle append(final Instruction i, final Instruction j) {
 346         return append(i, new InstructionList(j));
 347     }
 348 
 349     /**
 350      * Append a compound instruction, after instruction i.
 351      *
<a name="25" id="anc25"></a><span class="line-modified"> 352      * @param i Instruction in list</span>
<span class="line-modified"> 353      * @param c The composite instruction (containing an InstructionList)</span>


 354      * @return instruction handle of the first appended instruction
 355      */
 356     public InstructionHandle append(final Instruction i, final CompoundInstruction c) {
 357         return append(i, c.getInstructionList());
 358     }
 359 
 360     /**
 361      * Append a compound instruction.
 362      *
<a name="26" id="anc26"></a><span class="line-modified"> 363      * @param c The composite instruction (containing an InstructionList)</span>

 364      * @return instruction handle of the first appended instruction
 365      */
 366     public InstructionHandle append(final CompoundInstruction c) {
 367         return append(c.getInstructionList());
 368     }
 369 
 370     /**
 371      * Append a compound instruction.
 372      *
<a name="27" id="anc27"></a><span class="line-modified"> 373      * @param ih where to append the instruction list</span>
<span class="line-modified"> 374      * @param c The composite instruction (containing an InstructionList)</span>


 375      * @return instruction handle of the first appended instruction
 376      */
 377     public InstructionHandle append(final InstructionHandle ih, final CompoundInstruction c) {
 378         return append(ih, c.getInstructionList());
 379     }
 380 
 381     /**
<a name="28" id="anc28"></a><span class="line-modified"> 382      * Append an instruction after instruction (handle) ih contained in this</span>
<span class="line-removed"> 383      * list.</span>
 384      *
<a name="29" id="anc29"></a><span class="line-modified"> 385      * @param ih where to append the instruction list</span>
<span class="line-modified"> 386      * @param i Instruction to append</span>
<span class="line-modified"> 387      * @return instruction handle pointing to the &lt;B&gt;first&lt;/B&gt; appended</span>
<span class="line-modified"> 388      * instruction</span>

 389      */
 390     public InstructionHandle append(final InstructionHandle ih, final Instruction i) {
 391         return append(ih, new InstructionList(i));
 392     }
 393 
 394     /**
<a name="30" id="anc30"></a><span class="line-modified"> 395      * Append an instruction after instruction (handle) ih contained in this</span>
<span class="line-removed"> 396      * list.</span>
 397      *
<a name="31" id="anc31"></a><span class="line-modified"> 398      * @param ih where to append the instruction list</span>
<span class="line-modified"> 399      * @param i Instruction to append</span>
<span class="line-modified"> 400      * @return instruction handle pointing to the &lt;B&gt;first&lt;/B&gt; appended</span>
<span class="line-modified"> 401      * instruction</span>

 402      */
 403     public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {
 404         final BranchHandle bh = BranchHandle.getBranchHandle(i);
 405         final InstructionList il = new InstructionList();
 406         il.append(bh);
 407         append(ih, il);
 408         return bh;
 409     }
 410 
 411     /**
 412      * Insert another list before Instruction handle ih contained in this list.
 413      * Consumes argument list, i.e., it becomes empty.
 414      *
<a name="32" id="anc32"></a><span class="line-modified"> 415      * @param ih where to append the instruction list</span>
<span class="line-modified"> 416      * @param il Instruction list to insert</span>


 417      * @return instruction handle of the first inserted instruction
 418      */
 419     public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {
 420         if (il == null) {
 421             throw new ClassGenException(&quot;Inserting null InstructionList&quot;);
 422         }
 423         if (il.isEmpty()) {
 424             return ih;
 425         }
 426         final InstructionHandle prev = ih.getPrev();
 427         final InstructionHandle ret = il.start;
 428         ih.setPrev(il.end);
 429         il.end.setNext(ih);
 430         il.start.setPrev(prev);
 431         if (prev != null) {
 432             prev.setNext(il.start);
 433         } else {
 434             start = il.start; // Update start ...
 435         }
<a name="33" id="anc33"></a><span class="line-removed"> 436 </span>
 437         length += il.length; // Update length
 438         il.clear();
 439         return ret;
 440     }
 441 
 442     /**
 443      * Insert another list.
 444      *
<a name="34" id="anc34"></a><span class="line-modified"> 445      * @param il list to insert before start of this list</span>

 446      * @return instruction handle of the first inserted instruction
 447      */
 448     public InstructionHandle insert(final InstructionList il) {
 449         if (isEmpty()) {
 450             append(il); // Code is identical for this case
 451             return start;
 452         }
 453         return insert(start, il);
 454     }
 455 
 456     /**
 457      * Insert an instruction at start of this list.
 458      *
<a name="35" id="anc35"></a><span class="line-modified"> 459      * @param ih instruction to insert</span>

 460      */
 461     private void insert(final InstructionHandle ih) {
 462         if (isEmpty()) {
 463             start = end = ih;
 464             ih.setNext(ih.setPrev(null));
 465         } else {
 466             start.setPrev(ih);
 467             ih.setNext(start);
 468             ih.setPrev(null);
 469             start = ih;
 470         }
<a name="36" id="anc36"></a><span class="line-removed"> 471 </span>
 472         length++;
 473     }
 474 
 475     /**
 476      * Insert another list before Instruction i contained in this list. Consumes
 477      * argument list, i.e., it becomes empty.
 478      *
<a name="37" id="anc37"></a><span class="line-modified"> 479      * @param i where to append the instruction list</span>
<span class="line-modified"> 480      * @param il Instruction list to insert</span>
<span class="line-modified"> 481      * @return instruction handle pointing to the first inserted instruction,</span>
<span class="line-modified"> 482      * i.e., il.getStart()</span>

 483      */
 484     public InstructionHandle insert(final Instruction i, final InstructionList il) {
 485         InstructionHandle ih;
 486         if ((ih = findInstruction1(i)) == null) {
 487             throw new ClassGenException(&quot;Instruction &quot; + i + &quot; is not contained in this list.&quot;);
 488         }
 489         return insert(ih, il);
 490     }
 491 
 492     /**
 493      * Insert an instruction at start of this list.
 494      *
<a name="38" id="anc38"></a><span class="line-modified"> 495      * @param i instruction to insert</span>

 496      * @return instruction handle of the inserted instruction
 497      */
 498     public InstructionHandle insert(final Instruction i) {
 499         final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);
 500         insert(ih);
 501         return ih;
 502     }
 503 
 504     /**
 505      * Insert a branch instruction at start of this list.
 506      *
<a name="39" id="anc39"></a><span class="line-modified"> 507      * @param i branch instruction to insert</span>

 508      * @return branch instruction handle of the appended instruction
 509      */
 510     public BranchHandle insert(final BranchInstruction i) {
 511         final BranchHandle ih = BranchHandle.getBranchHandle(i);
 512         insert(ih);
 513         return ih;
 514     }
 515 
 516     /**
 517      * Insert a single instruction j before another instruction i, which must be
 518      * in this list of course!
 519      *
<a name="40" id="anc40"></a><span class="line-modified"> 520      * @param i Instruction in list</span>
<span class="line-modified"> 521      * @param j Instruction to insert before i in list</span>


 522      * @return instruction handle of the first inserted instruction
 523      */
 524     public InstructionHandle insert(final Instruction i, final Instruction j) {
 525         return insert(i, new InstructionList(j));
 526     }
 527 
 528     /**
 529      * Insert a compound instruction before instruction i.
 530      *
<a name="41" id="anc41"></a><span class="line-modified"> 531      * @param i Instruction in list</span>
<span class="line-modified"> 532      * @param c The composite instruction (containing an InstructionList)</span>


 533      * @return instruction handle of the first inserted instruction
 534      */
 535     public InstructionHandle insert(final Instruction i, final CompoundInstruction c) {
 536         return insert(i, c.getInstructionList());
 537     }
 538 
 539     /**
 540      * Insert a compound instruction.
 541      *
<a name="42" id="anc42"></a><span class="line-modified"> 542      * @param c The composite instruction (containing an InstructionList)</span>

 543      * @return instruction handle of the first inserted instruction
 544      */
 545     public InstructionHandle insert(final CompoundInstruction c) {
 546         return insert(c.getInstructionList());
 547     }
 548 
 549     /**
<a name="43" id="anc43"></a><span class="line-modified"> 550      * Insert an instruction before instruction (handle) ih contained in this</span>
<span class="line-removed"> 551      * list.</span>
 552      *
<a name="44" id="anc44"></a><span class="line-modified"> 553      * @param ih where to insert to the instruction list</span>
<span class="line-modified"> 554      * @param i Instruction to insert</span>


 555      * @return instruction handle of the first inserted instruction
 556      */
 557     public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {
 558         return insert(ih, new InstructionList(i));
 559     }
 560 
 561     /**
 562      * Insert a compound instruction.
 563      *
<a name="45" id="anc45"></a><span class="line-modified"> 564      * @param ih where to insert the instruction list</span>
<span class="line-modified"> 565      * @param c The composite instruction (containing an InstructionList)</span>


 566      * @return instruction handle of the first inserted instruction
 567      */
 568     public InstructionHandle insert(final InstructionHandle ih, final CompoundInstruction c) {
 569         return insert(ih, c.getInstructionList());
 570     }
 571 
 572     /**
<a name="46" id="anc46"></a><span class="line-modified"> 573      * Insert an instruction before instruction (handle) ih contained in this</span>
<span class="line-removed"> 574      * list.</span>
 575      *
<a name="47" id="anc47"></a><span class="line-modified"> 576      * @param ih where to insert to the instruction list</span>
<span class="line-modified"> 577      * @param i Instruction to insert</span>


 578      * @return instruction handle of the first inserted instruction
 579      */
 580     public BranchHandle insert(final InstructionHandle ih, final BranchInstruction i) {
 581         final BranchHandle bh = BranchHandle.getBranchHandle(i);
 582         final InstructionList il = new InstructionList();
 583         il.append(bh);
 584         insert(ih, il);
 585         return bh;
 586     }
 587 
 588     /**
 589      * Take all instructions (handles) from &quot;start&quot; to &quot;end&quot; and append them
 590      * after the new location &quot;target&quot;. Of course, &quot;end&quot; must be after &quot;start&quot;
<a name="48" id="anc48"></a><span class="line-modified"> 591      * and target must not be located withing this range. If you want to move</span>
<span class="line-modified"> 592      * something to the start of the list use null as value for target.&lt;br&gt;</span>

 593      * Any instruction targeters pointing to handles within the block, keep
 594      * their targets.
 595      *
<a name="49" id="anc49"></a><span class="line-modified"> 596      * @param start of moved block</span>
<span class="line-modified"> 597      * @param end of moved block</span>
<span class="line-modified"> 598      * @param target of moved block</span>



 599      */
 600     public void move(final InstructionHandle start, final InstructionHandle end, final InstructionHandle target) {
 601         // Step 1: Check constraints
 602         if ((start == null) || (end == null)) {
 603             throw new ClassGenException(&quot;Invalid null handle: From &quot; + start + &quot; to &quot; + end);
 604         }
 605         if ((target == start) || (target == end)) {
 606             throw new ClassGenException(&quot;Invalid range: From &quot; + start + &quot; to &quot; + end + &quot; contains target &quot; + target);
 607         }
 608         for (InstructionHandle ih = start; ih != end.getNext(); ih = ih.getNext()) {
 609             if (ih == null) {
 610                 throw new ClassGenException(&quot;Invalid range: From &quot; + start + &quot; to &quot; + end);
 611             } else if (ih == target) {
 612                 throw new ClassGenException(&quot;Invalid range: From &quot; + start + &quot; to &quot; + end + &quot; contains target &quot; + target);
 613             }
 614         }
 615         // Step 2: Temporarily remove the given instructions from the list
 616         final InstructionHandle prev = start.getPrev();
 617         InstructionHandle next = end.getNext();
 618         if (prev != null) {
 619             prev.setNext(next);
 620         } else {
 621             this.start = next;
 622         }
 623         if (next != null) {
 624             next.setPrev(prev);
 625         } else {
 626             this.end = prev;
 627         }
 628         start.setPrev(end.setNext(null));
 629         // Step 3: append after target
 630         if (target == null) { // append to start of list
 631             if (this.start != null) {
 632                 this.start.setPrev(end);
 633             }
 634             end.setNext(this.start);
 635             this.start = start;
 636         } else {
 637             next = target.getNext();
 638             target.setNext(start);
 639             start.setPrev(target);
 640             end.setNext(next);
 641             if (next != null) {
 642                 next.setPrev(end);
 643             } else {
 644                 this.end = end;
 645             }
 646         }
 647     }
 648 
 649     /**
 650      * Move a single instruction (handle) to a new location.
 651      *
<a name="50" id="anc50"></a><span class="line-modified"> 652      * @param ih moved instruction</span>
<span class="line-modified"> 653      * @param target new location of moved instruction</span>


 654      */
 655     public void move(final InstructionHandle ih, final InstructionHandle target) {
 656         move(ih, ih, target);
 657     }
 658 
 659     /**
 660      * Remove from instruction `prev&#39; to instruction `next&#39; both contained in
 661      * this list. Throws TargetLostException when one of the removed instruction
 662      * handles is still being targeted.
 663      *
<a name="51" id="anc51"></a><span class="line-modified"> 664      * @param prev where to start deleting (predecessor, exclusive)</span>
<span class="line-modified"> 665      * @param next where to end deleting (successor, exclusive)</span>


 666      */
 667     private void remove(final InstructionHandle prev, InstructionHandle next) throws TargetLostException {
 668         InstructionHandle first;
 669         InstructionHandle last; // First and last deleted instruction
 670         if ((prev == null) &amp;&amp; (next == null)) {
 671             first = start;
 672             last = end;
 673             start = end = null;
 674         } else {
 675             if (prev == null) { // At start of list
 676                 first = start;
 677                 start = next;
 678             } else {
 679                 first = prev.getNext();
 680                 prev.setNext(next);
 681             }
 682             if (next == null) { // At end of list
 683                 last = end;
 684                 end = prev;
 685             } else {
 686                 last = next.getPrev();
 687                 next.setPrev(prev);
 688             }
 689         }
 690         first.setPrev(null); // Completely separated from rest of list
 691         last.setNext(null);
 692         final List&lt;InstructionHandle&gt; target_vec = new ArrayList&lt;&gt;();
 693         for (InstructionHandle ih = first; ih != null; ih = ih.getNext()) {
 694             ih.getInstruction().dispose(); // e.g. BranchInstructions release their targets
 695         }
 696         final StringBuilder buf = new StringBuilder(&quot;{ &quot;);
 697         for (InstructionHandle ih = first; ih != null; ih = next) {
 698             next = ih.getNext();
 699             length--;
 700             if (ih.hasTargeters()) { // Still got targeters?
 701                 target_vec.add(ih);
 702                 buf.append(ih.toString(true)).append(&quot; &quot;);
 703                 ih.setNext(ih.setPrev(null));
 704             } else {
 705                 ih.dispose();
 706             }
 707         }
 708         buf.append(&quot;}&quot;);
 709         if (!target_vec.isEmpty()) {
 710             final InstructionHandle[] targeted = new InstructionHandle[target_vec.size()];
 711             target_vec.toArray(targeted);
 712             throw new TargetLostException(targeted, buf.toString());
 713         }
 714     }
 715 
 716     /**
 717      * Remove instruction from this list. The corresponding Instruction handles
 718      * must not be reused!
 719      *
<a name="52" id="anc52"></a><span class="line-modified"> 720      * @param ih instruction (handle) to remove</span>

 721      */
 722     public void delete(final InstructionHandle ih) throws TargetLostException {
 723         remove(ih.getPrev(), ih.getNext());
 724     }
 725 
 726     /**
<a name="53" id="anc53"></a><span class="line-modified"> 727      * Remove instruction from this list. The corresponding Instruction handles</span>
<span class="line-removed"> 728      * must not be reused!</span>
 729      *
<a name="54" id="anc54"></a><span class="line-modified"> 730      * @param i instruction to remove</span>

 731      */
 732     public void delete(final Instruction i) throws TargetLostException {
 733         InstructionHandle ih;
 734         if ((ih = findInstruction1(i)) == null) {
 735             throw new ClassGenException(&quot;Instruction &quot; + i + &quot; is not contained in this list.&quot;);
 736         }
 737         delete(ih);
 738     }
 739 
 740     /**
 741      * Remove instructions from instruction `from&#39; to instruction `to&#39; contained
 742      * in this list. The user must ensure that `from&#39; is an instruction before
 743      * `to&#39;, or risk havoc. The corresponding Instruction handles must not be
 744      * reused!
 745      *
<a name="55" id="anc55"></a><span class="line-modified"> 746      * @param from where to start deleting (inclusive)</span>
<span class="line-modified"> 747      * @param to where to end deleting (inclusive)</span>


 748      */
 749     public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {
 750         remove(from.getPrev(), to.getNext());
 751     }
 752 
 753     /**
 754      * Remove instructions from instruction `from&#39; to instruction `to&#39; contained
 755      * in this list. The user must ensure that `from&#39; is an instruction before
 756      * `to&#39;, or risk havoc. The corresponding Instruction handles must not be
 757      * reused!
 758      *
<a name="56" id="anc56"></a><span class="line-modified"> 759      * @param from where to start deleting (inclusive)</span>
<span class="line-modified"> 760      * @param to where to end deleting (inclusive)</span>


 761      */
 762     public void delete(final Instruction from, final Instruction to) throws TargetLostException {
 763         InstructionHandle from_ih;
 764         InstructionHandle to_ih;
 765         if ((from_ih = findInstruction1(from)) == null) {
 766             throw new ClassGenException(&quot;Instruction &quot; + from + &quot; is not contained in this list.&quot;);
 767         }
 768         if ((to_ih = findInstruction2(to)) == null) {
 769             throw new ClassGenException(&quot;Instruction &quot; + to + &quot; is not contained in this list.&quot;);
 770         }
 771         delete(from_ih, to_ih);
 772     }
 773 
 774     /**
 775      * Search for given Instruction reference, start at beginning of list.
 776      *
<a name="57" id="anc57"></a><span class="line-modified"> 777      * @param i instruction to search for</span>

 778      * @return instruction found on success, null otherwise
 779      */
 780     private InstructionHandle findInstruction1(final Instruction i) {
 781         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
 782             if (ih.getInstruction() == i) {
 783                 return ih;
 784             }
 785         }
 786         return null;
 787     }
 788 
 789     /**
 790      * Search for given Instruction reference, start at end of list
 791      *
<a name="58" id="anc58"></a><span class="line-modified"> 792      * @param i instruction to search for</span>

 793      * @return instruction found on success, null otherwise
 794      */
 795     private InstructionHandle findInstruction2(final Instruction i) {
 796         for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {
 797             if (ih.getInstruction() == i) {
 798                 return ih;
 799             }
 800         }
 801         return null;
 802     }
 803 
 804     public boolean contains(final InstructionHandle i) {
 805         if (i == null) {
 806             return false;
 807         }
 808         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
 809             if (ih == i) {
 810                 return true;
 811             }
 812         }
 813         return false;
 814     }
 815 
 816     public boolean contains(final Instruction i) {
 817         return findInstruction1(i) != null;
 818     }
 819 
 820     public void setPositions() { // TODO could be package-protected? (some test code would need to be repackaged)
 821         setPositions(false);
 822     }
 823 
 824     /**
 825      * Give all instructions their position number (offset in byte stream),
 826      * i.e., make the list ready to be dumped.
 827      *
<a name="59" id="anc59"></a><span class="line-modified"> 828      * @param check Perform sanity checks, e.g. if all targeted instructions</span>
<span class="line-modified"> 829      * really belong to this list</span>
 830      */
 831     public void setPositions(final boolean check) { // called by code in other packages
 832         int max_additional_bytes = 0;
 833         int additional_bytes = 0;
 834         int index = 0;
 835         int count = 0;
 836         final int[] pos = new int[length];
 837         /*
 838          * Pass 0: Sanity checks
 839          */
 840         if (check) {
 841             for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
 842                 final Instruction i = ih.getInstruction();
 843                 if (i instanceof BranchInstruction) { // target instruction within list?
 844                     Instruction inst = ((BranchInstruction) i).getTarget().getInstruction();
 845                     if (!contains(inst)) {
<a name="60" id="anc60"></a><span class="line-modified"> 846                         throw new ClassGenException(&quot;Branch target of &quot; +</span>
<span class="line-modified"> 847                                 Const.getOpcodeName(i.getOpcode()) + &quot;:&quot; +</span>
<span class="line-modified"> 848                                 inst + &quot; not in instruction list&quot;);</span>
 849                     }
 850                     if (i instanceof Select) {
 851                         final InstructionHandle[] targets = ((Select) i).getTargets();
 852                         for (final InstructionHandle target : targets) {
 853                             inst = target.getInstruction();
 854                             if (!contains(inst)) {
<a name="61" id="anc61"></a><span class="line-modified"> 855                                 throw new ClassGenException(&quot;Branch target of &quot; +</span>
<span class="line-modified"> 856                                         Const.getOpcodeName(i.getOpcode()) + &quot;:&quot; +</span>
<span class="line-modified"> 857                                         inst + &quot; not in instruction list&quot;);</span>
 858                             }
 859                         }
 860                     }
 861                     if (!(ih instanceof BranchHandle)) {
 862                         throw new ClassGenException(
<a name="62" id="anc62"></a><span class="line-modified"> 863                                 &quot;Branch instruction &quot; +</span>
<span class="line-modified"> 864                                         Const.getOpcodeName(i.getOpcode()) + &quot;:&quot; +</span>
<span class="line-modified"> 865                                         inst + &quot; not contained in BranchHandle.&quot;);</span>
 866                     }
 867                 }
 868             }
 869         }
 870         /*
 871          * Pass 1: Set position numbers and sum up the maximum number of bytes an instruction may be shifted.
 872          */
 873         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
<a name="63" id="anc63"></a><span class="line-removed"> 874 </span>
 875             final Instruction i = ih.getInstruction();
 876             ih.setPosition(index);
 877             pos[count++] = index;
<a name="64" id="anc64"></a><span class="line-removed"> 878 </span>
 879             /*
 880              * Get an estimate about how many additional bytes may be added,
 881              * because BranchInstructions may have variable length depending on the target offset
 882              * (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).
 883              */
 884             switch (i.getOpcode()) {
 885                 case Const.JSR:
 886                 case Const.GOTO:
 887                     max_additional_bytes += 2;
<a name="65" id="anc65"></a><span class="line-modified"> 888                     break;</span>
 889                 case Const.TABLESWITCH:
 890                 case Const.LOOKUPSWITCH:
 891                     max_additional_bytes += 3;
<a name="66" id="anc66"></a><span class="line-modified"> 892                     break;</span>
 893             }
 894             index += i.getLength();
 895         }
 896 
 897         /* Pass 2: Expand the variable-length (Branch)Instructions depending on
 898          * the target offset (short or int) and ensure that branch targets are
 899          * within this list.
 900          */
 901         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
 902             additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);
 903         }
 904         /*
 905          * Pass 3: Update position numbers (which may have changed due to the
 906          * preceding expansions), like pass 1.
 907          */
 908         index = count = 0;
 909         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
 910             final Instruction i = ih.getInstruction();
<a name="67" id="anc67"></a><span class="line-removed"> 911 </span>
 912             ih.setPosition(index);
 913             pos[count++] = index;
 914             index += i.getLength();
 915         }
<a name="68" id="anc68"></a><span class="line-modified"> 916         if (length == count) {</span>
<span class="line-modified"> 917             byte_positions = pos;</span>
<span class="line-removed"> 918         } else {</span>
<span class="line-removed"> 919             byte_positions = new int[count]; // Trim to proper size</span>
<span class="line-removed"> 920             System.arraycopy(pos, 0, byte_positions, 0, count);</span>
<span class="line-removed"> 921         }</span>
 922     }
 923 
 924     /**
 925      * When everything is finished, use this method to convert the instruction
 926      * list into an array of bytes.
 927      *
 928      * @return the byte code ready to be dumped
 929      */
 930     public byte[] getByteCode() {
 931         // Update position indices of instructions
 932         setPositions();
 933         final ByteArrayOutputStream b = new ByteArrayOutputStream();
 934         final DataOutputStream out = new DataOutputStream(b);
 935         try {
 936             for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
 937                 final Instruction i = ih.getInstruction();
 938                 i.dump(out); // Traverse list
 939             }
 940             out.flush();
 941         } catch (final IOException e) {
 942             System.err.println(e);
 943             return new byte[0];
 944         }
 945         return b.toByteArray();
 946     }
 947 
 948     /**
 949      * @return an array of instructions without target information for branch
 950      * instructions.
 951      */
 952     public Instruction[] getInstructions() {
 953         final List&lt;Instruction&gt; instructions = new ArrayList&lt;&gt;();
 954         try (ByteSequence bytes = new ByteSequence(getByteCode())) {
 955             while (bytes.available() &gt; 0) {
 956                 instructions.add(Instruction.readInstruction(bytes));
 957             }
 958         } catch (final IOException e) {
 959             throw new ClassGenException(e.toString(), e);
 960         }
 961         return instructions.toArray(new Instruction[instructions.size()]);
 962     }
 963 
 964     @Override
 965     public String toString() {
 966         return toString(true);
 967     }
 968 
 969     /**
<a name="69" id="anc69"></a><span class="line-modified"> 970      * @param verbose toggle output format</span>

 971      * @return String containing all instructions in this list.
 972      */
 973     public String toString(final boolean verbose) {
 974         final StringBuilder buf = new StringBuilder();
 975         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
 976             buf.append(ih.toString(verbose)).append(&quot;\n&quot;);
 977         }
 978         return buf.toString();
 979     }
 980 
 981     /**
 982      * @return iterator that lists all instructions (handles)
 983      */
 984     @Override
 985     public Iterator&lt;InstructionHandle&gt; iterator() {
 986         return new Iterator&lt;InstructionHandle&gt;() {
 987 
 988             private InstructionHandle ih = start;
 989 
 990             @Override
 991             public InstructionHandle next() throws NoSuchElementException {
 992                 if (ih == null) {
 993                     throw new NoSuchElementException();
 994                 }
 995                 final InstructionHandle i = ih;
 996                 ih = ih.getNext();
 997                 return i;
 998             }
 999 
1000             @Override
1001             public void remove() {
1002                 throw new UnsupportedOperationException();
1003             }
1004 
1005             @Override
1006             public boolean hasNext() {
1007                 return ih != null;
1008             }
1009         };
1010     }
1011 
1012     /**
1013      * @return array containing all instructions (handles)
1014      */
1015     public InstructionHandle[] getInstructionHandles() {
1016         final InstructionHandle[] ihs = new InstructionHandle[length];
1017         InstructionHandle ih = start;
1018         for (int i = 0; i &lt; length; i++) {
1019             ihs[i] = ih;
1020             ih = ih.getNext();
1021         }
1022         return ihs;
1023     }
1024 
1025     /**
1026      * Get positions (offsets) of all instructions in the list. This relies on
1027      * that the list has been freshly created from an byte code array, or that
1028      * setPositions() has been called. Otherwise this may be inaccurate.
1029      *
1030      * @return array containing all instruction&#39;s offset in byte code
1031      */
1032     public int[] getInstructionPositions() {
1033         return byte_positions;
1034     }
1035 
1036     /**
1037      * @return complete, i.e., deep copy of this list
1038      */
1039     public InstructionList copy() {
1040         final Map&lt;InstructionHandle, InstructionHandle&gt; map = new HashMap&lt;&gt;();
1041         final InstructionList il = new InstructionList();
1042         /*
<a name="70" id="anc70"></a><span class="line-modified">1043          * Pass 1: Make copies of all instructions, append them to the new list and associate old instruction references with the new ones, i.e., a 1:1 mapping.</span>

1044          */
1045         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
1046             final Instruction i = ih.getInstruction();
1047             final Instruction c = i.copy(); // Use clone for shallow copy
1048             if (c instanceof BranchInstruction) {
1049                 map.put(ih, il.append((BranchInstruction) c));
1050             } else {
1051                 map.put(ih, il.append(c));
1052             }
1053         }
1054         /*
1055          * Pass 2: Update branch targets.
1056          */
1057         InstructionHandle ih = start;
1058         InstructionHandle ch = il.start;
1059         while (ih != null) {
1060             final Instruction i = ih.getInstruction();
1061             final Instruction c = ch.getInstruction();
1062             if (i instanceof BranchInstruction) {
1063                 final BranchInstruction bi = (BranchInstruction) i;
1064                 final BranchInstruction bc = (BranchInstruction) c;
1065                 final InstructionHandle itarget = bi.getTarget(); // old target
1066                 // New target is in hash map
1067                 bc.setTarget(map.get(itarget));
1068                 if (bi instanceof Select) { // Either LOOKUPSWITCH or TABLESWITCH
1069                     final InstructionHandle[] itargets = ((Select) bi).getTargets();
1070                     final InstructionHandle[] ctargets = ((Select) bc).getTargets();
1071                     for (int j = 0; j &lt; itargets.length; j++) { // Update all targets
1072                         ctargets[j] = map.get(itargets[j]);
1073                     }
1074                 }
1075             }
1076             ih = ih.getNext();
1077             ch = ch.getNext();
1078         }
1079         return il;
1080     }
1081 
1082     /**
1083      * Replace all references to the old constant pool with references to the
1084      * new constant pool
1085      */
1086     public void replaceConstantPool(final ConstantPoolGen old_cp, final ConstantPoolGen new_cp) {
1087         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
1088             final Instruction i = ih.getInstruction();
1089             if (i instanceof CPInstruction) {
1090                 final CPInstruction ci = (CPInstruction) i;
1091                 final Constant c = old_cp.getConstant(ci.getIndex());
1092                 ci.setIndex(new_cp.addConstant(c, old_cp));
1093             }
1094         }
1095     }
1096 
1097     private void clear() {
1098         start = end = null;
1099         length = 0;
1100     }
1101 
1102     /**
1103      * Delete contents of list. Provides better memory utilization, because the
1104      * system then may reuse the instruction handles. This method is typically
1105      * called right after {@link MethodGen#getMethod()}.
1106      */
1107     public void dispose() {
1108         // Traverse in reverse order, because ih.next is overwritten
1109         for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {
1110             /*
1111              * Causes BranchInstructions to release target and targeters,
1112              * because it calls dispose() on the contained instruction.
1113              */
1114             ih.dispose();
1115         }
1116         clear();
1117     }
1118 
1119     /**
1120      * @return start of list
1121      */
1122     public InstructionHandle getStart() {
1123         return start;
1124     }
1125 
1126     /**
1127      * @return end of list
1128      */
1129     public InstructionHandle getEnd() {
1130         return end;
1131     }
1132 
1133     /**
1134      * @return length of list (Number of instructions, not bytes)
1135      */
1136     public int getLength() {
1137         return length;
1138     }
1139 
1140     /**
1141      * @return length of list (Number of instructions, not bytes)
1142      */
1143     public int size() {
1144         return length;
1145     }
1146 
1147     /**
1148      * Redirect all references from old_target to new_target, i.e., update
1149      * targets of branch instructions.
1150      *
<a name="71" id="anc71"></a><span class="line-modified">1151      * @param old_target the old target instruction handle</span>
<span class="line-modified">1152      * @param new_target the new target instruction handle</span>


1153      */
<a name="72" id="anc72"></a><span class="line-modified">1154     public void redirectBranches(final InstructionHandle old_target,</span>
<span class="line-removed">1155             final InstructionHandle new_target) {</span>
1156         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
1157             final Instruction i = ih.getInstruction();
1158             if (i instanceof BranchInstruction) {
1159                 final BranchInstruction b = (BranchInstruction) i;
1160                 final InstructionHandle target = b.getTarget();
1161                 if (target == old_target) {
1162                     b.setTarget(new_target);
1163                 }
1164                 if (b instanceof Select) { // Either LOOKUPSWITCH or TABLESWITCH
1165                     final InstructionHandle[] targets = ((Select) b).getTargets();
1166                     for (int j = 0; j &lt; targets.length; j++) {
1167                         if (targets[j] == old_target) {
1168                             ((Select) b).setTarget(j, new_target);
1169                         }
1170                     }
1171                 }
1172             }
1173         }
1174     }
1175 
1176     /**
1177      * Redirect all references of local variables from old_target to new_target.
1178      *
<a name="73" id="anc73"></a><span class="line-modified">1179      * @param lg array of local variables</span>
<span class="line-modified">1180      * @param old_target the old target instruction handle</span>
<span class="line-modified">1181      * @param new_target the new target instruction handle</span>



1182      * @see MethodGen
1183      */
<a name="74" id="anc74"></a><span class="line-modified">1184     public void redirectLocalVariables(final LocalVariableGen[] lg,</span>
<span class="line-removed">1185             final InstructionHandle old_target, final InstructionHandle new_target) {</span>
1186         for (final LocalVariableGen element : lg) {
1187             final InstructionHandle start = element.getStart();
1188             final InstructionHandle end = element.getEnd();
1189             if (start == old_target) {
1190                 element.setStart(new_target);
1191             }
1192             if (end == old_target) {
1193                 element.setEnd(new_target);
1194             }
1195         }
1196     }
1197 
1198     /**
<a name="75" id="anc75"></a><span class="line-modified">1199      * Redirect all references of exception handlers from old_target to</span>
<span class="line-removed">1200      * new_target.</span>
1201      *
<a name="76" id="anc76"></a><span class="line-modified">1202      * @param exceptions array of exception handlers</span>
<span class="line-modified">1203      * @param old_target the old target instruction handle</span>
<span class="line-modified">1204      * @param new_target the new target instruction handle</span>



1205      * @see MethodGen
1206      */
1207     public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions,
1208             final InstructionHandle old_target, final InstructionHandle new_target) {
1209         for (final CodeExceptionGen exception : exceptions) {
1210             if (exception.getStartPC() == old_target) {
1211                 exception.setStartPC(new_target);
1212             }
1213             if (exception.getEndPC() == old_target) {
1214                 exception.setEndPC(new_target);
1215             }
1216             if (exception.getHandlerPC() == old_target) {
1217                 exception.setHandlerPC(new_target);
1218             }
1219         }
1220     }
1221 
1222     private List&lt;InstructionListObserver&gt; observers;
1223 
1224     /**
1225      * Add observer for this object.
1226      */
1227     public void addObserver(final InstructionListObserver o) {
1228         if (observers == null) {
1229             observers = new ArrayList&lt;&gt;();
1230         }
1231         observers.add(o);
1232     }
1233 
1234     /**
1235      * Remove observer for this object.
1236      */
1237     public void removeObserver(final InstructionListObserver o) {
1238         if (observers != null) {
1239             observers.remove(o);
1240         }
1241     }
1242 
1243     /**
1244      * Call notify() method on all observers. This method is not called
1245      * automatically whenever the state has changed, but has to be called by the
1246      * user after he has finished editing the object.
1247      */
1248     public void update() {
1249         if (observers != null) {
1250             for (final InstructionListObserver observer : observers) {
1251                 observer.notify(this);
1252             }
1253         }
1254     }
1255 }
<a name="77" id="anc77"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="77" type="hidden" />
</body>
</html>
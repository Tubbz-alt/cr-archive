<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/AttrImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 import java.io.IOException;
  24 import java.io.ObjectInputStream;
  25 import java.io.ObjectOutputStream;
  26 
  27 import org.w3c.dom.TypeInfo;
  28 import org.w3c.dom.Attr;
  29 import org.w3c.dom.DOMException;
  30 import org.w3c.dom.Element;
  31 import org.w3c.dom.Node;
  32 import org.w3c.dom.NodeList;
  33 import org.w3c.dom.Text;
  34 
  35 /**
  36  * Attribute represents an XML-style attribute of an
  37  * Element. Typically, the allowable values are controlled by its
  38  * declaration in the Document Type Definition (DTD) governing this
  39  * kind of document.
  40  * &lt;P&gt;
  41  * If the attribute has not been explicitly assigned a value, but has
  42  * been declared in the DTD, it will exist and have that default. Only
  43  * if neither the document nor the DTD specifies a value will the
  44  * Attribute really be considered absent and have no value; in that
  45  * case, querying the attribute will return null.
  46  * &lt;P&gt;
  47  * Attributes may have multiple children that contain their data. (XML
  48  * allows attributes to contain entity references, and tokenized
  49  * attribute types such as NMTOKENS may have a child for each token.)
  50  * For convenience, the Attribute object&#39;s getValue() method returns
  51  * the string version of the attribute&#39;s value.
  52  * &lt;P&gt;
  53  * Attributes are not children of the Elements they belong to, in the
  54  * usual sense, and have no valid Parent reference. However, the spec
  55  * says they _do_ belong to a specific Element, and an INUSE exception
  56  * is to be thrown if the user attempts to explicitly share them
  57  * between elements.
  58  * &lt;P&gt;
  59  * Note that Elements do not permit attributes to appear to be shared
  60  * (see the INUSE exception), so this object&#39;s mutability is
  61  * officially not an issue.
  62  * &lt;p&gt;
  63  * Note: The ownerNode attribute is used to store the Element the Attr
  64  * node is associated with. Attr nodes do not have parent nodes.
  65  * Besides, the getOwnerElement() method can be used to get the element node
  66  * this attribute is associated with.
  67  * &lt;P&gt;
  68  * AttrImpl does not support Namespaces. AttrNSImpl, which inherits from
  69  * it, does.
  70  *
  71  * &lt;p&gt;AttrImpl used to inherit from ParentNode. It now directly inherits from
  72  * NodeImpl and provide its own implementation of the ParentNode&#39;s behavior.
  73  * The reason is that we now try and avoid to always create a Text node to
  74  * hold the value of an attribute. The DOM spec requires it, so we still have
  75  * to do it in case getFirstChild() is called for instance. The reason
  76  * attribute values are stored as a list of nodes is so that they can carry
  77  * more than a simple string. They can also contain EntityReference nodes.
  78  * However, most of the times people only have a single string that they only
  79  * set and get through Element.set/getAttribute or Attr.set/getValue. In this
  80  * new version, the Attr node has a value pointer which can either be the
  81  * String directly or a pointer to the first ChildNode. A flag tells which one
  82  * it currently is. Note that while we try to stick with the direct String as
  83  * much as possible once we&#39;ve switched to a node there is no going back. This
  84  * is because we have no way to know whether the application keeps referring to
  85  * the node we once returned.
  86  * &lt;p&gt; The gain in memory varies on the density of attributes in the document.
  87  * But in the tests I&#39;ve run I&#39;ve seen up to 12% of memory gain. And the good
  88  * thing is that it also leads to a slight gain in speed because we allocate
  89  * fewer objects! I mean, that&#39;s until we have to actually create the node...
  90  * &lt;p&gt;
  91  * To avoid too much duplicated code, I got rid of ParentNode and renamed
  92  * ChildAndParentNode, which I never really liked, to ParentNode for
  93  * simplicity, this doesn&#39;t make much of a difference in memory usage because
  94  * there are only very few objects that are only a Parent. This is only true
  95  * now because AttrImpl now inherits directly from NodeImpl and has its own
  96  * implementation of the ParentNode&#39;s node behavior. So there is still some
  97  * duplicated code there.
  98  * &lt;p&gt;
  99  * This class doesn&#39;t directly support mutation events, however, it notifies
 100  * the document when mutations are performed so that the document class do so.
 101  *
 102  * &lt;p&gt;&lt;b&gt;WARNING&lt;/b&gt;: Some of the code here is partially duplicated in
 103  * ParentNode, be careful to keep these two classes in sync!
 104  *
 105  * @xerces.internal
 106  *
 107  * @see AttrNSImpl
 108  *
 109  * @author Arnaud  Le Hors, IBM
 110  * @author Joe Kesselman, IBM
 111  * @author Andy Clark, IBM
 112  * @since PR-DOM-Level-1-19980818.
<a name="2" id="anc2"></a><span class="line-added"> 113  * @LastModified: Apr 2019</span>
 114  *
 115  */
 116 public class AttrImpl
 117     extends NodeImpl
 118     implements Attr, TypeInfo{
 119 
 120     //
 121     // Constants
 122     //
 123 
 124     /** Serialization version. */
 125     static final long serialVersionUID = 7277707688218972102L;
 126 
 127     /** DTD namespace. **/
 128     static final String DTD_URI = &quot;http://www.w3.org/TR/REC-xml&quot;;
 129 
 130     //
 131     // Data
 132     //
 133 
 134     /** This can either be a String or the first child node. */
 135     protected Object value = null;
 136 
 137     /** Attribute name. */
 138     protected String name;
 139 
 140     /** Type information */
 141     // REVISIT: we are losing the type information in DOM during serialization
 142     transient Object type;
 143 
<a name="3" id="anc3"></a>

 144     //
 145     // Constructors
 146     //
 147 
 148     /**
 149      * Attribute has no public constructor. Please use the factory
 150      * method in the Document class.
 151      */
 152     protected AttrImpl(CoreDocumentImpl ownerDocument, String name) {
 153         super(ownerDocument);
 154         this.name = name;
 155         /** False for default attributes. */
 156         isSpecified(true);
 157         hasStringValue(true);
 158     }
 159 
 160     // for AttrNSImpl
 161     protected AttrImpl() {}
 162 
 163     // Support for DOM Level 3 renameNode method.
 164     // Note: This only deals with part of the pb. It is expected to be
 165     // called after the Attr has been detached for one thing.
 166     // CoreDocumentImpl does all the work.
 167     void rename(String name) {
 168         if (needsSyncData()) {
 169             synchronizeData();
 170         }
 171         this.name = name;
 172     }
 173 
 174     // create a real text node as child if we don&#39;t have one yet
 175     protected void makeChildNode() {
 176         if (hasStringValue()) {
 177             if (value != null) {
 178                 TextImpl text =
 179                     (TextImpl) ownerDocument().createTextNode((String) value);
 180                 value = text;
 181                 text.isFirstChild(true);
 182                 text.previousSibling = text;
 183                 text.ownerNode = this;
 184                 text.isOwned(true);
 185             }
 186             hasStringValue(false);
 187         }
 188     }
 189 
 190     /**
 191      * NON-DOM
 192      * set the ownerDocument of this node and its children
 193      */
<a name="4" id="anc4"></a><span class="line-modified"> 194     protected void setOwnerDocument(CoreDocumentImpl doc) {</span>
 195         if (needsSyncChildren()) {
 196             synchronizeChildren();
 197         }
 198         super.setOwnerDocument(doc);
 199         if (!hasStringValue()) {
 200             for (ChildNode child = (ChildNode) value;
<a name="5" id="anc5"></a><span class="line-modified"> 201                 child != null; child = child.nextSibling) {</span>
 202                 child.setOwnerDocument(doc);
 203             }
 204         }
 205     }
 206 
 207     /**
 208      * NON-DOM: set the type of this attribute to be ID type.
 209      *
 210      * @param id
 211      */
 212     public void setIdAttribute(boolean id){
 213         if (needsSyncData()) {
 214             synchronizeData();
 215         }
 216         isIdAttribute(id);
 217     }
 218     /** DOM Level 3: isId*/
 219     public boolean isId(){
 220         // REVISIT: should an attribute that is not in the tree return
 221         // isID true?
 222         return isIdAttribute();
 223     }
 224 
 225 
 226     //
 227     // Node methods
 228     //
 229 
 230     public Node cloneNode(boolean deep) {
 231 
 232         if (needsSyncChildren()) {
 233             synchronizeChildren();
 234         }
 235         AttrImpl clone = (AttrImpl) super.cloneNode(deep);
 236 
 237         // take care of case where there are kids
 238         if (!clone.hasStringValue()) {
 239 
 240             // Need to break the association w/ original kids
 241             clone.value = null;
 242 
 243             // Cloning an Attribute always clones its children,
 244             // since they represent its value, no matter whether this
 245             // is a deep clone or not
 246             for (Node child = (Node) value; child != null;
 247                  child = child.getNextSibling()) {
 248                  clone.appendChild(child.cloneNode(true));
 249             }
 250         }
 251         clone.isSpecified(true);
 252         return clone;
 253     }
 254 
 255     /**
 256      * A short integer indicating what type of node this is. The named
 257      * constants for this value are defined in the org.w3c.dom.Node interface.
 258      */
 259     public short getNodeType() {
 260         return Node.ATTRIBUTE_NODE;
 261     }
 262 
 263     /**
 264      * Returns the attribute name
 265      */
 266     public String getNodeName() {
 267         if (needsSyncData()) {
 268             synchronizeData();
 269         }
 270         return name;
 271     }
 272 
 273     /**
 274      * Implicit in the rerouting of getNodeValue to getValue is the
 275      * need to redefine setNodeValue, for symmetry&#39;s sake.  Note that
 276      * since we&#39;re explicitly providing a value, Specified should be set
 277      * true.... even if that value equals the default.
 278      */
 279     public void setNodeValue(String value) throws DOMException {
 280         setValue(value);
 281     }
 282 
 283     /**
 284      * @see org.w3c.dom.TypeInfo#getTypeName()
 285      */
 286     public String getTypeName() {
 287         return (String)type;
 288     }
 289 
 290     /**
 291      * @see org.w3c.dom.TypeInfo#getTypeNamespace()
 292      */
 293     public String getTypeNamespace() {
 294         if (type != null) {
 295             return DTD_URI;
 296         }
 297         return null;
 298     }
 299 
 300     /**
 301      * Method getSchemaTypeInfo.
 302      * @return TypeInfo
 303      */
 304     public TypeInfo getSchemaTypeInfo(){
 305       return this;
 306     }
 307 
 308     /**
 309      * In Attribute objects, NodeValue is considered a synonym for
 310      * Value.
 311      *
 312      * @see #getValue()
 313      */
 314     public String getNodeValue() {
 315         return getValue();
 316     }
 317 
 318     //
 319     // Attr methods
 320     //
 321 
 322     /**
 323      * In Attributes, NodeName is considered a synonym for the
 324      * attribute&#39;s Name
 325      */
 326     public String getName() {
 327 
 328         if (needsSyncData()) {
 329             synchronizeData();
 330         }
 331         return name;
 332 
 333     } // getName():String
 334 
 335     /**
 336      * The DOM doesn&#39;t clearly define what setValue(null) means. I&#39;ve taken it
 337      * as &quot;remove all children&quot;, which from outside should appear
 338      * similar to setting it to the empty string.
 339      */
 340     public void setValue(String newvalue) {
 341 
 342         CoreDocumentImpl ownerDocument = ownerDocument();
 343 
 344         if (ownerDocument.errorChecking &amp;&amp; isReadOnly()) {
 345             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 346             throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
 347         }
 348 
 349         Element ownerElement = getOwnerElement();
 350         String oldvalue = &quot;&quot;;
<a name="6" id="anc6"></a><span class="line-added"> 351         TextImpl textNode = null;</span>
<span class="line-added"> 352 </span>
 353         if (needsSyncData()) {
 354             synchronizeData();
 355         }
 356         if (needsSyncChildren()) {
 357             synchronizeChildren();
 358         }
 359         if (value != null) {
 360             if (ownerDocument.getMutationEvents()) {
 361                 // Can no longer just discard the kids; they may have
 362                 // event listeners waiting for them to disconnect.
 363                 if (hasStringValue()) {
 364                     oldvalue = (String) value;
 365                     // create an actual text node as our child so
 366                     // that we can use it in the event
<a name="7" id="anc7"></a><span class="line-modified"> 367                     textNode = (TextImpl) ownerDocument.createTextNode((String) value);</span>






 368                     value = textNode;
 369                     textNode.isFirstChild(true);
 370                     textNode.previousSibling = textNode;
 371                     textNode.ownerNode = this;
 372                     textNode.isOwned(true);
 373                     hasStringValue(false);
 374                     internalRemoveChild(textNode, true);
 375                 }
 376                 else {
 377                     oldvalue = getValue();
 378                     while (value != null) {
 379                         internalRemoveChild((Node) value, true);
 380                     }
 381                 }
 382             }
 383             else {
 384                 if (hasStringValue()) {
 385                     oldvalue = (String) value;
 386                 }
 387                 else {
 388                     // simply discard children if any
 389                     oldvalue = getValue();
 390                     // remove ref from first child to last child
 391                     ChildNode firstChild = (ChildNode) value;
 392                     firstChild.previousSibling = null;
 393                     firstChild.isFirstChild(false);
 394                     firstChild.ownerNode = ownerDocument;
 395                 }
 396                 // then remove ref to current value
 397                 value = null;
 398                 needsSyncChildren(false);
 399             }
 400             if (isIdAttribute() &amp;&amp; ownerElement != null) {
 401                 ownerDocument.removeIdentifier(oldvalue);
 402             }
 403         }
 404 
 405         // Create and add the new one, generating only non-aggregate events
 406         // (There are no listeners on the new Text, but there may be
 407         // capture/bubble listeners on the Attr.
 408         // Note that aggregate events are NOT dispatched here,
 409         // since we need to combine the remove and insert.
 410         isSpecified(true);
 411         if (ownerDocument.getMutationEvents()) {
<a name="8" id="anc8"></a><span class="line-modified"> 412             // if there are any event handlers create a real node or</span>
<span class="line-modified"> 413             // reuse the one we synthesized for the remove notifications</span>
<span class="line-modified"> 414             // if it exists.</span>
<span class="line-added"> 415             if (textNode == null) {</span>
<span class="line-added"> 416                 textNode = (TextImpl) ownerDocument.createTextNode(newvalue);</span>
<span class="line-added"> 417             }</span>
<span class="line-added"> 418             else {</span>
<span class="line-added"> 419                 textNode.data = newvalue;</span>
<span class="line-added"> 420             }</span>
<span class="line-added"> 421             internalInsertBefore(textNode, null, true);</span>
 422             hasStringValue(false);
 423             // notify document
 424             ownerDocument.modifiedAttrValue(this, oldvalue);
 425         } else {
 426             // directly store the string
 427             value = newvalue;
 428             hasStringValue(true);
 429             changed();
 430         }
 431         if (isIdAttribute() &amp;&amp; ownerElement != null) {
 432             ownerDocument.putIdentifier(newvalue, ownerElement);
 433         }
 434 
 435     } // setValue(String)
 436 
 437     /**
 438      * The &quot;string value&quot; of an Attribute is its text representation,
 439      * which in turn is a concatenation of the string values of its children.
 440      */
 441     public String getValue() {
 442 
 443         if (needsSyncData()) {
 444             synchronizeData();
 445         }
 446         if (needsSyncChildren()) {
 447             synchronizeChildren();
 448         }
 449         if (value == null) {
 450             return &quot;&quot;;
 451         }
 452         if (hasStringValue()) {
 453             return (String) value;
 454         }
 455 
 456         ChildNode firstChild = ((ChildNode) value);
 457 
 458         String data = null;
 459         if (firstChild.getNodeType() == Node.ENTITY_REFERENCE_NODE){
 460                 data = ((EntityReferenceImpl)firstChild).getEntityRefValue();
 461         }
 462         else {
 463                 data =  firstChild.getNodeValue();
 464         }
 465 
 466         ChildNode node = firstChild.nextSibling;
 467 
 468         if (node == null || data == null)  return (data == null)?&quot;&quot;:data;
 469 
 470         StringBuffer value = new StringBuffer(data);
 471         while (node != null) {
 472             if (node.getNodeType()  == Node.ENTITY_REFERENCE_NODE){
 473                 data = ((EntityReferenceImpl)node).getEntityRefValue();
 474                 if (data == null) return &quot;&quot;;
 475                 value.append(data);
 476             }
 477             else {
 478                 value.append(node.getNodeValue());
 479             }
 480             node = node.nextSibling;
 481         }
 482         return value.toString();
 483 
 484     } // getValue():String
 485 
 486 
 487     /**
 488      * The &quot;specified&quot; flag is true if and only if this attribute&#39;s
 489      * value was explicitly specified in the original document. Note that
 490      * the implementation, not the user, is in charge of this
 491      * property. If the user asserts an Attribute value (even if it ends
 492      * up having the same value as the default), it is considered a
 493      * specified attribute. If you really want to revert to the default,
 494      * delete the attribute from the Element, and the Implementation will
 495      * re-assert the default (if any) in its place, with the appropriate
 496      * specified=false setting.
 497      */
 498     public boolean getSpecified() {
 499 
 500         if (needsSyncData()) {
 501             synchronizeData();
 502         }
 503         return isSpecified();
 504 
 505     } // getSpecified():boolean
 506 
 507     //
 508     // Attr2 methods
 509     //
 510 
 511     /**
 512      * Returns the element node that this attribute is associated with,
 513      * or null if the attribute has not been added to an element.
 514      *
 515      * @see #getOwnerElement
 516      *
 517      * @deprecated Previous working draft of DOM Level 2. New method
 518      *             is &lt;tt&gt;getOwnerElement()&lt;/tt&gt;.
 519      */
 520     @Deprecated
 521     public Element getElement() {
 522         // if we have an owner, ownerNode is our ownerElement, otherwise it&#39;s
 523         // our ownerDocument and we don&#39;t have an ownerElement
 524         return (Element) (isOwned() ? ownerNode : null);
 525     }
 526 
 527     /**
 528      * Returns the element node that this attribute is associated with,
 529      * or null if the attribute has not been added to an element.
 530      *
 531      * @since WD-DOM-Level-2-19990719
 532      */
 533     public Element getOwnerElement() {
 534         // if we have an owner, ownerNode is our ownerElement, otherwise it&#39;s
 535         // our ownerDocument and we don&#39;t have an ownerElement
 536         return (Element) (isOwned() ? ownerNode : null);
 537     }
 538 
 539     public void normalize() {
 540 
 541         // No need to normalize if already normalized or
 542         // if value is kept as a String.
 543         if (isNormalized() || hasStringValue())
 544             return;
 545 
 546         Node kid, next;
 547         ChildNode firstChild = (ChildNode)value;
 548         for (kid = firstChild; kid != null; kid = next) {
 549             next = kid.getNextSibling();
 550 
 551             // If kid is a text node, we need to check for one of two
 552             // conditions:
 553             //   1) There is an adjacent text node
 554             //   2) There is no adjacent text node, but kid is
 555             //      an empty text node.
 556             if ( kid.getNodeType() == Node.TEXT_NODE )
 557             {
 558                 // If an adjacent text node, merge it with kid
 559                 if ( next!=null &amp;&amp; next.getNodeType() == Node.TEXT_NODE )
 560                 {
 561                     ((Text)kid).appendData(next.getNodeValue());
 562                     removeChild( next );
 563                     next = kid; // Don&#39;t advance; there might be another.
 564                 }
 565                 else
 566                 {
 567                     // If kid is empty, remove it
 568                     if ( kid.getNodeValue() == null || kid.getNodeValue().length() == 0 ) {
 569                         removeChild( kid );
 570                     }
 571                 }
 572             }
 573         }
 574 
 575         isNormalized(true);
 576     } // normalize()
 577 
 578     //
 579     // Public methods
 580     //
 581 
 582     /** NON-DOM, for use by parser */
 583     public void setSpecified(boolean arg) {
 584 
 585         if (needsSyncData()) {
 586             synchronizeData();
 587         }
 588         isSpecified(arg);
 589 
 590     } // setSpecified(boolean)
 591 
 592         /**
 593          * NON-DOM: used by the parser
 594          * @param type
 595          */
 596     public void setType (Object type){
 597         this.type = type;
 598     }
 599 
 600     //
 601     // Object methods
 602     //
 603 
 604     /** NON-DOM method for debugging convenience */
 605     public String toString() {
 606         return getName() + &quot;=&quot; + &quot;\&quot;&quot; + getValue() + &quot;\&quot;&quot;;
 607     }
 608 
 609     /**
 610      * Test whether this node has any children. Convenience shorthand
 611      * for (Node.getFirstChild()!=null)
 612      */
 613     public boolean hasChildNodes() {
 614         if (needsSyncChildren()) {
 615             synchronizeChildren();
 616         }
 617         return value != null;
 618     }
 619 
 620     /**
 621      * Obtain a NodeList enumerating all children of this node. If there
 622      * are none, an (initially) empty NodeList is returned.
 623      * &lt;p&gt;
 624      * NodeLists are &quot;live&quot;; as children are added/removed the NodeList
 625      * will immediately reflect those changes. Also, the NodeList refers
 626      * to the actual nodes, so changes to those nodes made via the DOM tree
 627      * will be reflected in the NodeList and vice versa.
 628      * &lt;p&gt;
 629      * In this implementation, Nodes implement the NodeList interface and
 630      * provide their own getChildNodes() support. Other DOMs may solve this
 631      * differently.
 632      */
 633     public NodeList getChildNodes() {
 634         // JKESS: KNOWN ISSUE HERE
 635 
 636         if (needsSyncChildren()) {
 637             synchronizeChildren();
 638         }
 639         return this;
 640 
 641     } // getChildNodes():NodeList
 642 
 643     /** The first child of this Node, or null if none. */
 644     public Node getFirstChild() {
 645 
 646         if (needsSyncChildren()) {
 647             synchronizeChildren();
 648         }
 649         makeChildNode();
 650         return (Node) value;
 651 
 652     }   // getFirstChild():Node
 653 
 654     /** The last child of this Node, or null if none. */
 655     public Node getLastChild() {
 656 
 657         if (needsSyncChildren()) {
 658             synchronizeChildren();
 659         }
 660         return lastChild();
 661 
 662     } // getLastChild():Node
 663 
 664     final ChildNode lastChild() {
 665         // last child is stored as the previous sibling of first child
 666         makeChildNode();
 667         return value != null ? ((ChildNode) value).previousSibling : null;
 668     }
 669 
 670     final void lastChild(ChildNode node) {
 671         // store lastChild as previous sibling of first child
 672         if (value != null) {
 673             ((ChildNode) value).previousSibling = node;
 674         }
 675     }
 676 
 677     /**
 678      * Move one or more node(s) to our list of children. Note that this
 679      * implicitly removes them from their previous parent.
 680      *
 681      * @param newChild The Node to be moved to our subtree. As a
 682      * convenience feature, inserting a DocumentNode will instead insert
 683      * all its children.
 684      *
 685      * @param refChild Current child which newChild should be placed
 686      * immediately before. If refChild is null, the insertion occurs
 687      * after all existing Nodes, like appendChild().
 688      *
 689      * @return newChild, in its new state (relocated, or emptied in the case of
 690      * DocumentNode.)
 691      *
 692      * @throws DOMException(HIERARCHY_REQUEST_ERR) if newChild is of a
 693      * type that shouldn&#39;t be a child of this node, or if newChild is an
 694      * ancestor of this node.
 695      *
 696      * @throws DOMException(WRONG_DOCUMENT_ERR) if newChild has a
 697      * different owner document than we do.
 698      *
 699      * @throws DOMException(NOT_FOUND_ERR) if refChild is not a child of
 700      * this node.
 701      *
 702      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
 703      * read-only.
 704      */
 705     public Node insertBefore(Node newChild, Node refChild)
 706         throws DOMException {
 707         // Tail-call; optimizer should be able to do good things with.
 708         return internalInsertBefore(newChild, refChild, false);
 709     } // insertBefore(Node,Node):Node
 710 
 711     /** NON-DOM INTERNAL: Within DOM actions,we sometimes need to be able
 712      * to control which mutation events are spawned. This version of the
 713      * insertBefore operation allows us to do so. It is not intended
 714      * for use by application programs.
 715      */
 716     Node internalInsertBefore(Node newChild, Node refChild, boolean replace)
 717         throws DOMException {
 718 
 719         CoreDocumentImpl ownerDocument = ownerDocument();
 720         boolean errorChecking = ownerDocument.errorChecking;
 721 
 722         if (newChild.getNodeType() == Node.DOCUMENT_FRAGMENT_NODE) {
 723             // SLOW BUT SAFE: We could insert the whole subtree without
 724             // juggling so many next/previous pointers. (Wipe out the
 725             // parent&#39;s child-list, patch the parent pointers, set the
 726             // ends of the list.) But we know some subclasses have special-
 727             // case behavior they add to insertBefore(), so we don&#39;t risk it.
 728             // This approch also takes fewer bytecodes.
 729 
 730             // NOTE: If one of the children is not a legal child of this
 731             // node, throw HIERARCHY_REQUEST_ERR before _any_ of the children
 732             // have been transferred. (Alternative behaviors would be to
 733             // reparent up to the first failure point or reparent all those
 734             // which are acceptable to the target node, neither of which is
 735             // as robust. PR-DOM-0818 isn&#39;t entirely clear on which it
 736             // recommends?????
 737 
 738             // No need to check kids for right-document; if they weren&#39;t,
 739             // they wouldn&#39;t be kids of that DocFrag.
 740             if (errorChecking) {
 741                 for (Node kid = newChild.getFirstChild(); // Prescan
 742                      kid != null; kid = kid.getNextSibling()) {
 743 
 744                     if (!ownerDocument.isKidOK(this, kid)) {
 745                         String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null);
 746                         throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, msg);
 747                     }
 748                 }
 749             }
 750 
 751             while (newChild.hasChildNodes()) {
 752                 insertBefore(newChild.getFirstChild(), refChild);
 753             }
 754             return newChild;
 755         }
 756 
 757         if (newChild == refChild) {
 758             // stupid case that must be handled as a no-op triggering events...
 759             refChild = refChild.getNextSibling();
 760             removeChild(newChild);
 761             insertBefore(newChild, refChild);
 762             return newChild;
 763         }
 764 
 765         if (needsSyncChildren()) {
 766             synchronizeChildren();
 767         }
 768 
 769         if (errorChecking) {
 770             if (isReadOnly()) {
 771                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 772                 throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
 773             }
 774             if (newChild.getOwnerDocument() != ownerDocument) {
 775                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;WRONG_DOCUMENT_ERR&quot;, null);
 776                 throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);
 777             }
 778             if (!ownerDocument.isKidOK(this, newChild)) {
 779                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null);
 780                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, msg);
 781             }
 782             // refChild must be a child of this node (or null)
 783             if (refChild != null &amp;&amp; refChild.getParentNode() != this) {
 784                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);
 785                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 786             }
 787 
 788             // Prevent cycles in the tree
 789             // newChild cannot be ancestor of this Node,
 790             // and actually cannot be this
 791             boolean treeSafe = true;
 792             for (NodeImpl a = this; treeSafe &amp;&amp; a != null; a = a.parentNode())
 793             {
 794                 treeSafe = newChild != a;
 795             }
 796             if (!treeSafe) {
 797                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null);
 798                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR, msg);
 799             }
 800         }
 801 
 802         makeChildNode(); // make sure we have a node and not a string
 803 
 804         // notify document
 805         ownerDocument.insertingNode(this, replace);
 806 
 807         // Convert to internal type, to avoid repeated casting
 808         ChildNode newInternal = (ChildNode)newChild;
 809 
 810         Node oldparent = newInternal.parentNode();
 811         if (oldparent != null) {
 812             oldparent.removeChild(newInternal);
 813         }
 814 
 815         // Convert to internal type, to avoid repeated casting
 816         ChildNode refInternal = (ChildNode) refChild;
 817 
 818         // Attach up
 819         newInternal.ownerNode = this;
 820         newInternal.isOwned(true);
 821 
 822         // Attach before and after
 823         // Note: firstChild.previousSibling == lastChild!!
 824         ChildNode firstChild = (ChildNode) value;
 825         if (firstChild == null) {
 826             // this our first and only child
 827             value = newInternal; // firstchild = newInternal;
 828             newInternal.isFirstChild(true);
 829             newInternal.previousSibling = newInternal;
 830         }
 831         else {
 832             if (refInternal == null) {
 833                 // this is an append
 834                 ChildNode lastChild = firstChild.previousSibling;
 835                 lastChild.nextSibling = newInternal;
 836                 newInternal.previousSibling = lastChild;
 837                 firstChild.previousSibling = newInternal;
 838             }
 839             else {
 840                 // this is an insert
 841                 if (refChild == firstChild) {
 842                     // at the head of the list
 843                     firstChild.isFirstChild(false);
 844                     newInternal.nextSibling = firstChild;
 845                     newInternal.previousSibling = firstChild.previousSibling;
 846                     firstChild.previousSibling = newInternal;
 847                     value = newInternal; // firstChild = newInternal;
 848                     newInternal.isFirstChild(true);
 849                 }
 850                 else {
 851                     // somewhere in the middle
 852                     ChildNode prev = refInternal.previousSibling;
 853                     newInternal.nextSibling = refInternal;
 854                     prev.nextSibling = newInternal;
 855                     refInternal.previousSibling = newInternal;
 856                     newInternal.previousSibling = prev;
 857                 }
 858             }
 859         }
 860 
 861         changed();
 862 
 863         // notify document
 864         ownerDocument.insertedNode(this, newInternal, replace);
 865 
 866         checkNormalizationAfterInsert(newInternal);
 867 
 868         return newChild;
 869 
 870     } // internalInsertBefore(Node,Node,int):Node
 871 
 872     /**
 873      * Remove a child from this Node. The removed child&#39;s subtree
 874      * remains intact so it may be re-inserted elsewhere.
 875      *
 876      * @return oldChild, in its new state (removed).
 877      *
 878      * @throws DOMException(NOT_FOUND_ERR) if oldChild is not a child of
 879      * this node.
 880      *
 881      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
 882      * read-only.
 883      */
 884     public Node removeChild(Node oldChild)
 885         throws DOMException {
 886         // Tail-call, should be optimizable
 887         if (hasStringValue()) {
 888             // we don&#39;t have any child per say so it can&#39;t be one of them!
 889             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);
 890             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 891         }
 892         return internalRemoveChild(oldChild, false);
 893     } // removeChild(Node) :Node
 894 
 895     /** NON-DOM INTERNAL: Within DOM actions,we sometimes need to be able
 896      * to control which mutation events are spawned. This version of the
 897      * removeChild operation allows us to do so. It is not intended
 898      * for use by application programs.
 899      */
 900     Node internalRemoveChild(Node oldChild, boolean replace)
 901         throws DOMException {
 902 
 903         CoreDocumentImpl ownerDocument = ownerDocument();
 904         if (ownerDocument.errorChecking) {
 905             if (isReadOnly()) {
 906                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null);
 907                 throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);
 908             }
 909             if (oldChild != null &amp;&amp; oldChild.getParentNode() != this) {
 910                 String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NOT_FOUND_ERR&quot;, null);
 911                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 912             }
 913         }
 914 
 915         ChildNode oldInternal = (ChildNode) oldChild;
 916 
 917         // notify document
 918         ownerDocument.removingNode(this, oldInternal, replace);
 919 
 920         // Patch linked list around oldChild
 921         // Note: lastChild == firstChild.previousSibling
 922         if (oldInternal == value) { // oldInternal == firstChild
 923             // removing first child
 924             oldInternal.isFirstChild(false);
 925             // next line is: firstChild = oldInternal.nextSibling
 926             value = oldInternal.nextSibling;
 927             ChildNode firstChild = (ChildNode) value;
 928             if (firstChild != null) {
 929                 firstChild.isFirstChild(true);
 930                 firstChild.previousSibling = oldInternal.previousSibling;
 931             }
 932         } else {
 933             ChildNode prev = oldInternal.previousSibling;
 934             ChildNode next = oldInternal.nextSibling;
 935             prev.nextSibling = next;
 936             if (next == null) {
 937                 // removing last child
 938                 ChildNode firstChild = (ChildNode) value;
 939                 firstChild.previousSibling = prev;
 940             } else {
 941                 // removing some other child in the middle
 942                 next.previousSibling = prev;
 943             }
 944         }
 945 
 946         // Save previous sibling for normalization checking.
 947         ChildNode oldPreviousSibling = oldInternal.previousSibling();
 948 
 949         // Remove oldInternal&#39;s references to tree
 950         oldInternal.ownerNode       = ownerDocument;
 951         oldInternal.isOwned(false);
 952         oldInternal.nextSibling     = null;
 953         oldInternal.previousSibling = null;
 954 
 955         changed();
 956 
 957         // notify document
 958         ownerDocument.removedNode(this, replace);
 959 
 960         checkNormalizationAfterRemove(oldPreviousSibling);
 961 
 962         return oldInternal;
 963 
 964     } // internalRemoveChild(Node,int):Node
 965 
 966     /**
 967      * Make newChild occupy the location that oldChild used to
 968      * have. Note that newChild will first be removed from its previous
 969      * parent, if any. Equivalent to inserting newChild before oldChild,
 970      * then removing oldChild.
 971      *
 972      * @return oldChild, in its new state (removed).
 973      *
 974      * @throws DOMException(HIERARCHY_REQUEST_ERR) if newChild is of a
 975      * type that shouldn&#39;t be a child of this node, or if newChild is
 976      * one of our ancestors.
 977      *
 978      * @throws DOMException(WRONG_DOCUMENT_ERR) if newChild has a
 979      * different owner document than we do.
 980      *
 981      * @throws DOMException(NOT_FOUND_ERR) if oldChild is not a child of
 982      * this node.
 983      *
 984      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if this node is
 985      * read-only.
 986      */
 987     public Node replaceChild(Node newChild, Node oldChild)
 988         throws DOMException {
 989 
 990         makeChildNode();
 991 
 992         // If Mutation Events are being generated, this operation might
 993         // throw aggregate events twice when modifying an Attr -- once
 994         // on insertion and once on removal. DOM Level 2 does not specify
 995         // this as either desirable or undesirable, but hints that
 996         // aggregations should be issued only once per user request.
 997 
 998         // notify document
 999         CoreDocumentImpl ownerDocument = ownerDocument();
1000         ownerDocument.replacingNode(this);
1001 
1002         internalInsertBefore(newChild, oldChild, true);
1003         if (newChild != oldChild) {
1004             internalRemoveChild(oldChild, true);
1005         }
1006 
1007         // notify document
1008         ownerDocument.replacedNode(this);
1009 
1010         return oldChild;
1011     }
1012 
1013     //
1014     // NodeList methods
1015     //
1016 
1017     /**
1018      * NodeList method: Count the immediate children of this node
1019      * @return int
1020      */
1021     public int getLength() {
1022 
1023         if (hasStringValue()) {
1024             return 1;
1025         }
1026         ChildNode node = (ChildNode) value;
1027         int length = 0;
1028         for (; node != null; node = node.nextSibling) {
1029             length++;
1030         }
1031         return length;
1032 
1033     } // getLength():int
1034 
1035     /**
1036      * NodeList method: Return the Nth immediate child of this node, or
1037      * null if the index is out of bounds.
1038      * @return org.w3c.dom.Node
<a name="9" id="anc9"></a><span class="line-modified">1039      * @param index int</span>
1040      */
1041     public Node item(int index) {
1042 
1043         if (hasStringValue()) {
1044             if (index != 0 || value == null) {
1045                 return null;
1046             }
1047             else {
1048                 makeChildNode();
1049                 return (Node) value;
1050             }
1051         }
1052         if (index &lt; 0) {
1053             return null;
1054         }
1055         ChildNode node = (ChildNode) value;
1056         for (int i = 0; i &lt; index &amp;&amp; node != null; i++) {
1057             node = node.nextSibling;
1058         }
1059         return node;
1060 
1061     } // item(int):Node
1062 
1063     //
1064     // DOM3
1065     //
1066 
1067     /**
1068      * DOM Level 3 WD- Experimental.
1069      * Override inherited behavior from ParentNode to support deep equal.
1070      * isEqualNode is always deep on Attr nodes.
1071      */
1072     public boolean isEqualNode(Node arg) {
1073         return super.isEqualNode(arg);
1074     }
1075 
1076     /**
1077      * Introduced in DOM Level 3. &lt;p&gt;
1078      * Checks if a type is derived from another by restriction. See:
1079      * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom
1080      *
<a name="10" id="anc10"></a><span class="line-modified">1081      * @param typeNamespaceArg</span>
1082      *        The namspace of the ancestor type declaration
<a name="11" id="anc11"></a><span class="line-modified">1083      * @param typeNameArg</span>
1084      *        The name of the ancestor type declaration
<a name="12" id="anc12"></a><span class="line-modified">1085      * @param derivationMethod</span>
<span class="line-modified">1086      *        The derivation method</span>
1087      *
1088      * @return boolean True if the type is derived by restriciton for the
1089      *         reference type
1090      */
1091     public boolean isDerivedFrom(String typeNamespaceArg,
1092                                  String typeNameArg,
1093                                  int derivationMethod) {
1094 
1095         return false;
1096     }
1097 
1098 
1099     //
1100     // Public methods
1101     //
1102 
1103     /**
1104      * Override default behavior so that if deep is true, children are also
1105      * toggled.
1106      * @see Node
1107      * &lt;P&gt;
1108      * Note: this will not change the state of an EntityReference or its
1109      * children, which are always read-only.
1110      */
1111     public void setReadOnly(boolean readOnly, boolean deep) {
1112 
1113         super.setReadOnly(readOnly, deep);
1114 
1115         if (deep) {
1116 
1117             if (needsSyncChildren()) {
1118                 synchronizeChildren();
1119             }
1120 
1121             if (hasStringValue()) {
1122                 return;
1123             }
1124             // Recursively set kids
1125             for (ChildNode mykid = (ChildNode) value;
1126                  mykid != null;
1127                  mykid = mykid.nextSibling) {
1128                 if (mykid.getNodeType() != Node.ENTITY_REFERENCE_NODE) {
1129                     mykid.setReadOnly(readOnly,true);
1130                 }
1131             }
1132         }
1133     } // setReadOnly(boolean,boolean)
1134 
1135     //
1136     // Protected methods
1137     //
1138 
1139     /**
1140      * Override this method in subclass to hook in efficient
1141      * internal data structure.
1142      */
1143     protected void synchronizeChildren() {
1144         // By default just change the flag to avoid calling this method again
1145         needsSyncChildren(false);
1146     }
1147 
1148     /**
1149      * Checks the normalized state of this node after inserting a child.
1150      * If the inserted child causes this node to be unnormalized, then this
1151      * node is flagged accordingly.
1152      * The conditions for changing the normalized state are:
1153      * &lt;ul&gt;
1154      * &lt;li&gt;The inserted child is a text node and one of its adjacent siblings
1155      * is also a text node.
1156      * &lt;li&gt;The inserted child is is itself unnormalized.
1157      * &lt;/ul&gt;
1158      *
1159      * @param insertedChild the child node that was inserted into this node
1160      *
1161      * @throws NullPointerException if the inserted child is &lt;code&gt;null&lt;/code&gt;
1162      */
1163     void checkNormalizationAfterInsert(ChildNode insertedChild) {
1164         // See if insertion caused this node to be unnormalized.
1165         if (insertedChild.getNodeType() == Node.TEXT_NODE) {
1166             ChildNode prev = insertedChild.previousSibling();
1167             ChildNode next = insertedChild.nextSibling;
1168             // If an adjacent sibling of the new child is a text node,
1169             // flag this node as unnormalized.
1170             if ((prev != null &amp;&amp; prev.getNodeType() == Node.TEXT_NODE) ||
1171                 (next != null &amp;&amp; next.getNodeType() == Node.TEXT_NODE)) {
1172                 isNormalized(false);
1173             }
1174         }
1175         else {
1176             // If the new child is not normalized,
1177             // then this node is inherently not normalized.
1178             if (!insertedChild.isNormalized()) {
1179                 isNormalized(false);
1180             }
1181         }
1182     } // checkNormalizationAfterInsert(ChildNode)
1183 
1184     /**
1185      * Checks the normalized of this node after removing a child.
1186      * If the removed child causes this node to be unnormalized, then this
1187      * node is flagged accordingly.
1188      * The conditions for changing the normalized state are:
1189      * &lt;ul&gt;
1190      * &lt;li&gt;The removed child had two adjacent siblings that were text nodes.
1191      * &lt;/ul&gt;
1192      *
1193      * @param previousSibling the previous sibling of the removed child, or
1194      * &lt;code&gt;null&lt;/code&gt;
1195      */
1196     void checkNormalizationAfterRemove(ChildNode previousSibling) {
1197         // See if removal caused this node to be unnormalized.
1198         // If the adjacent siblings of the removed child were both text nodes,
1199         // flag this node as unnormalized.
1200         if (previousSibling != null &amp;&amp;
1201             previousSibling.getNodeType() == Node.TEXT_NODE) {
1202 
1203             ChildNode next = previousSibling.nextSibling;
1204             if (next != null &amp;&amp; next.getNodeType() == Node.TEXT_NODE) {
1205                 isNormalized(false);
1206             }
1207         }
1208     } // checkNormalizationAfterRemove(ChildNode)
1209 
1210     //
1211     // Serialization methods
1212     //
1213 
1214     /** Serialize object. */
1215     private void writeObject(ObjectOutputStream out) throws IOException {
1216 
1217         // synchronize chilren
1218         if (needsSyncChildren()) {
1219             synchronizeChildren();
1220         }
1221         // write object
1222         out.defaultWriteObject();
1223 
1224     } // writeObject(ObjectOutputStream)
1225 
1226     /** Deserialize object. */
1227     private void readObject(ObjectInputStream ois)
1228         throws ClassNotFoundException, IOException {
1229 
1230         // perform default deseralization
1231         ois.defaultReadObject();
1232 
1233         // hardset synchildren - so we don&#39;t try to sync -
1234         // it does not make any sense to try to synchildren when we just
1235         // deserialize object.
1236         needsSyncChildren(false);
1237 
1238     } // readObject(ObjectInputStream)
1239 
1240 
1241 } // class AttrImpl
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
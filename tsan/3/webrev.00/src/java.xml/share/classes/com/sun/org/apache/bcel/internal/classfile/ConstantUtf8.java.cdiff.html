<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantUtf8.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ConstantString.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantValue.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/ConstantUtf8.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,186 ***</span>
  import java.util.HashMap;
  import java.util.LinkedHashMap;
  import java.util.Map;
  
  /**
<span class="line-modified">!  * This class is derived from the abstract {@link Constant}</span>
<span class="line-removed">-  * and represents a reference to a Utf8 encoded string.</span>
   *
<span class="line-modified">!  * @version $Id: ConstantUtf8.java 1750029 2016-06-23 22:14:38Z sebb $</span>
<span class="line-modified">!  * @see     Constant</span>
   */
  public final class ConstantUtf8 extends Constant {
  
<span class="line-modified">!     private final String bytes;</span>
  
<span class="line-modified">!     // TODO these should perhaps be AtomicInt?</span>
<span class="line-modified">!     private static volatile int considered = 0;</span>
<span class="line-modified">!     private static volatile int hits = 0;</span>
<span class="line-removed">-     private static volatile int skipped = 0;</span>
<span class="line-removed">-     private static volatile int created = 0;</span>
  
<span class="line-modified">!     // Set the size to 0 or below to skip caching entirely</span>
<span class="line-modified">!     private static final int MAX_CACHED_SIZE = 200;</span>
<span class="line-removed">-     private static final boolean BCEL_STATISTICS = false;</span>
  
<span class="line-removed">- </span>
<span class="line-removed">-     private static class CACHE_HOLDER {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static final int MAX_CACHE_ENTRIES = 20000;</span>
<span class="line-removed">-         private static final int INITIAL_CACHE_CAPACITY = (int)(MAX_CACHE_ENTRIES/0.75);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private static final HashMap&lt;String, ConstantUtf8&gt; CACHE =</span>
<span class="line-removed">-                 new LinkedHashMap&lt;String, ConstantUtf8&gt;(INITIAL_CACHE_CAPACITY, 0.75f, true) {</span>
              private static final long serialVersionUID = -8506975356158971766L;
  
              @Override
              protected boolean removeEldestEntry(final Map.Entry&lt;String, ConstantUtf8&gt; eldest) {
<span class="line-modified">!                  return size() &gt; MAX_CACHE_ENTRIES;</span>
              }
          };
  
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     // for accesss by test code</span>
<span class="line-modified">!     static void printStats() {</span>
<span class="line-modified">!         System.err.println(&quot;Cache hit &quot; + hits + &quot;/&quot; + considered +&quot;, &quot; + skipped + &quot; skipped&quot;);</span>
<span class="line-removed">-         System.err.println(&quot;Total of &quot; + created + &quot; ConstantUtf8 objects created&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-removed">-     // for accesss by test code</span>
<span class="line-removed">-     static void clearStats() {</span>
<span class="line-removed">-         hits = considered = skipped = created = 0;</span>
      }
  
<span class="line-modified">!     static {</span>
<span class="line-modified">!         if (BCEL_STATISTICS) {</span>
<span class="line-modified">!             Runtime.getRuntime().addShutdownHook(new Thread() {</span>
<span class="line-modified">!                 @Override</span>
<span class="line-modified">!                 public void run() {</span>
<span class="line-modified">!                     printStats();</span>
<span class="line-modified">!                 }</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-         }</span>
      }
  
      /**
       * @since 6.0
       */
<span class="line-modified">!     public static ConstantUtf8 getCachedInstance(final String s) {</span>
<span class="line-modified">!         if (s.length() &gt; MAX_CACHED_SIZE) {</span>
<span class="line-modified">!             skipped++;</span>
<span class="line-removed">-             return  new ConstantUtf8(s);</span>
          }
<span class="line-modified">!         considered++;</span>
          synchronized (ConstantUtf8.class) { // might be better with a specific lock object
<span class="line-modified">!             ConstantUtf8 result = CACHE_HOLDER.CACHE.get(s);</span>
              if (result != null) {
<span class="line-modified">!                     hits++;</span>
<span class="line-modified">!                     return result;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             result = new ConstantUtf8(s);</span>
<span class="line-removed">-             CACHE_HOLDER.CACHE.put(s, result);</span>
              return result;
          }
      }
  
      /**
       * @since 6.0
       */
<span class="line-modified">!     public static ConstantUtf8 getInstance(final String s) {</span>
<span class="line-modified">!         return new ConstantUtf8(s);</span>
      }
  
      /**
       * @since 6.0
       */
<span class="line-modified">!     public static ConstantUtf8 getInstance (final DataInput input)  throws IOException {</span>
<span class="line-modified">!         return getInstance(input.readUTF());</span>
      }
  
      /**
<span class="line-modified">!      * Initialize from another object.</span>
       */
<span class="line-modified">!     public ConstantUtf8(final ConstantUtf8 c) {</span>
<span class="line-modified">!         this(c.getBytes());</span>
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Initialize instance from file data.</span>
       *
<span class="line-modified">!      * @param file Input stream</span>
       * @throws IOException
       */
<span class="line-modified">!     ConstantUtf8(final DataInput file) throws IOException {</span>
          super(Const.CONSTANT_Utf8);
<span class="line-modified">!         bytes = file.readUTF();</span>
<span class="line-removed">-         created++;</span>
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * @param bytes Data</span>
       */
<span class="line-modified">!     public ConstantUtf8(final String bytes) {</span>
          super(Const.CONSTANT_Utf8);
<span class="line-modified">!         if (bytes == null) {</span>
<span class="line-modified">!             throw new IllegalArgumentException(&quot;bytes must not be null!&quot;);</span>
          }
<span class="line-modified">!         this.bytes = bytes;</span>
<span class="line-removed">-         created++;</span>
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Called by objects that are traversing the nodes of the tree implicitely</span>
<span class="line-modified">!      * defined by the contents of a Java class. I.e., the hierarchy of methods,</span>
<span class="line-removed">-      * fields, attributes, etc. spawns a tree of objects.</span>
       *
       * @param v Visitor object
       */
      @Override
<span class="line-modified">!     public void accept( final Visitor v ) {</span>
          v.visitConstantUtf8(this);
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * Dump String in Utf8 format to file stream.</span>
       *
       * @param file Output file stream
       * @throws IOException
       */
      @Override
<span class="line-modified">!     public final void dump( final DataOutputStream file ) throws IOException {</span>
          file.writeByte(super.getTag());
<span class="line-modified">!         file.writeUTF(bytes);</span>
      }
  
<span class="line-removed">- </span>
      /**
       * @return Data converted to string.
       */
<span class="line-modified">!     public final String getBytes() {</span>
<span class="line-modified">!         return bytes;</span>
      }
  
<span class="line-removed">- </span>
      /**
<span class="line-modified">!      * @param bytes the raw bytes of this Utf-8</span>
       * @deprecated (since 6.0)
       */
      @java.lang.Deprecated
<span class="line-modified">!     public final void setBytes( final String bytes ) {</span>
          throw new UnsupportedOperationException();
      }
  
<span class="line-removed">- </span>
      /**
       * @return String representation
       */
      @Override
<span class="line-modified">!     public final String toString() {</span>
<span class="line-modified">!         return super.toString() + &quot;(\&quot;&quot; + Utility.replace(bytes, &quot;\n&quot;, &quot;\\n&quot;) + &quot;\&quot;)&quot;;</span>
      }
  }
<span class="line-new-header">--- 27,182 ---</span>
  import java.util.HashMap;
  import java.util.LinkedHashMap;
  import java.util.Map;
  
  /**
<span class="line-modified">!  * Extends the abstract {@link Constant} to represent a reference to a UTF-8 encoded string.</span>
   *
<span class="line-modified">!  * @see Constant</span>
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public final class ConstantUtf8 extends Constant {
  
<span class="line-modified">!     private static class Cache {</span>
  
<span class="line-modified">!         private static final boolean BCEL_STATISTICS = false;</span>
<span class="line-modified">!         private static final int MAX_ENTRIES = 20000;</span>
<span class="line-modified">!         private static final int INITIAL_CAPACITY = (int) (MAX_ENTRIES / 0.75);</span>
  
<span class="line-modified">!         private static final HashMap&lt;String, ConstantUtf8&gt; CACHE = new LinkedHashMap&lt;String, ConstantUtf8&gt;(</span>
<span class="line-modified">!             INITIAL_CAPACITY, 0.75f, true) {</span>
  
              private static final long serialVersionUID = -8506975356158971766L;
  
              @Override
              protected boolean removeEldestEntry(final Map.Entry&lt;String, ConstantUtf8&gt; eldest) {
<span class="line-modified">!                 return size() &gt; MAX_ENTRIES;</span>
              }
          };
  
<span class="line-modified">!         // Set the size to 0 or below to skip caching entirely</span>
<span class="line-added">+         private static final int MAX_ENTRY_SIZE = 200;</span>
  
<span class="line-modified">!         static boolean isEnabled() {</span>
<span class="line-modified">!             return Cache.MAX_ENTRIES &gt; 0 &amp;&amp; MAX_ENTRY_SIZE &gt; 0;</span>
<span class="line-modified">!         }</span>
  
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Clears the cache.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @since 6.4.0</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     public static synchronized void clearCache() {</span>
<span class="line-modified">!         Cache.CACHE.clear();</span>
      }
  
      /**
<span class="line-added">+      * Gets a new or cached instance of the given value.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * See {@link ConstantUtf8} class Javadoc for details.</span>
<span class="line-added">+      * &lt;/p&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param value the value.</span>
<span class="line-added">+      * @return a new or cached instance of the given value.</span>
       * @since 6.0
       */
<span class="line-modified">!     public static ConstantUtf8 getCachedInstance(final String value) {</span>
<span class="line-modified">!         if (value.length() &gt; Cache.MAX_ENTRY_SIZE) {</span>
<span class="line-modified">!             return new ConstantUtf8(value);</span>
          }
<span class="line-modified">! </span>
          synchronized (ConstantUtf8.class) { // might be better with a specific lock object
<span class="line-modified">!             ConstantUtf8 result = Cache.CACHE.get(value);</span>
              if (result != null) {
<span class="line-modified">!                 return result;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             result = new ConstantUtf8(value);</span>
<span class="line-modified">!             Cache.CACHE.put(value, result);</span>
              return result;
          }
      }
  
      /**
<span class="line-added">+      * Gets a new or cached instance of the given value.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * See {@link ConstantUtf8} class Javadoc for details.</span>
<span class="line-added">+      * &lt;/p&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param dataInput the value.</span>
<span class="line-added">+      * @return a new or cached instance of the given value.</span>
<span class="line-added">+      * @throws IOException if an I/O error occurs.</span>
       * @since 6.0
       */
<span class="line-modified">!     public static ConstantUtf8 getInstance(final DataInput dataInput) throws IOException {</span>
<span class="line-modified">!         return getInstance(dataInput.readUTF());</span>
      }
  
      /**
<span class="line-added">+      * Gets a new or cached instance of the given value.</span>
<span class="line-added">+      * &lt;p&gt;</span>
<span class="line-added">+      * See {@link ConstantUtf8} class Javadoc for details.</span>
<span class="line-added">+      * &lt;/p&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param value the value.</span>
<span class="line-added">+      * @return a new or cached instance of the given value.</span>
       * @since 6.0
       */
<span class="line-modified">!     public static ConstantUtf8 getInstance(final String value) {</span>
<span class="line-modified">!         return Cache.isEnabled() ? getCachedInstance(value) : new ConstantUtf8(value);</span>
      }
  
<span class="line-added">+     private final String value;</span>
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Initializes from another object.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param constantUtf8 the value.</span>
       */
<span class="line-modified">!     public ConstantUtf8(final ConstantUtf8 constantUtf8) {</span>
<span class="line-modified">!         this(constantUtf8.getBytes());</span>
      }
  
      /**
<span class="line-modified">!      * Initializes instance from file data.</span>
       *
<span class="line-modified">!      * @param dataInput Input stream</span>
       * @throws IOException
       */
<span class="line-modified">!     ConstantUtf8(final DataInput dataInput) throws IOException {</span>
          super(Const.CONSTANT_Utf8);
<span class="line-modified">!         value = dataInput.readUTF();</span>
      }
  
      /**
<span class="line-modified">!      * @param value Data</span>
       */
<span class="line-modified">!     public ConstantUtf8(final String value) {</span>
          super(Const.CONSTANT_Utf8);
<span class="line-modified">!         if (value == null) {</span>
<span class="line-modified">!             throw new IllegalArgumentException(&quot;Value must not be null.&quot;);</span>
          }
<span class="line-modified">!         this.value = value;</span>
      }
  
      /**
<span class="line-modified">!      * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.</span>
<span class="line-modified">!      * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.</span>
       *
       * @param v Visitor object
       */
      @Override
<span class="line-modified">!     public void accept(final Visitor v) {</span>
          v.visitConstantUtf8(this);
      }
  
      /**
<span class="line-modified">!      * Dumps String in Utf8 format to file stream.</span>
       *
       * @param file Output file stream
       * @throws IOException
       */
      @Override
<span class="line-modified">!     public void dump(final DataOutputStream file) throws IOException {</span>
          file.writeByte(super.getTag());
<span class="line-modified">!         file.writeUTF(value);</span>
      }
  
      /**
       * @return Data converted to string.
       */
<span class="line-modified">!     public String getBytes() {</span>
<span class="line-modified">!         return value;</span>
      }
  
      /**
<span class="line-modified">!      * @param bytes the raw bytes of this UTF-8</span>
       * @deprecated (since 6.0)
       */
      @java.lang.Deprecated
<span class="line-modified">!     public void setBytes(final String bytes) {</span>
          throw new UnsupportedOperationException();
      }
  
      /**
       * @return String representation
       */
      @Override
<span class="line-modified">!     public String toString() {</span>
<span class="line-modified">!         return super.toString() + &quot;(\&quot;&quot; + Utility.replace(value, &quot;\n&quot;, &quot;\\n&quot;) + &quot;\&quot;)&quot;;</span>
      }
  }
</pre>
<center><a href="ConstantString.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantValue.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
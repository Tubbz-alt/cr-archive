<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TransformerFactoryImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../xerces/internal/dom/AttrImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  66 import javax.xml.parsers.ParserConfigurationException;
  67 import javax.xml.stream.XMLEventReader;
  68 import javax.xml.stream.XMLStreamReader;
  69 import javax.xml.transform.ErrorListener;
  70 import javax.xml.transform.OutputKeys;
  71 import javax.xml.transform.Result;
  72 import javax.xml.transform.Source;
  73 import javax.xml.transform.Transformer;
  74 import javax.xml.transform.TransformerException;
  75 import javax.xml.transform.URIResolver;
  76 import javax.xml.transform.dom.DOMResult;
  77 import javax.xml.transform.dom.DOMSource;
  78 import javax.xml.transform.sax.SAXResult;
  79 import javax.xml.transform.sax.SAXSource;
  80 import javax.xml.transform.stax.StAXResult;
  81 import javax.xml.transform.stax.StAXSource;
  82 import javax.xml.transform.stream.StreamResult;
  83 import javax.xml.transform.stream.StreamSource;
  84 import jdk.xml.internal.JdkXmlFeatures;
  85 import jdk.xml.internal.JdkXmlUtils;

  86 import org.xml.sax.ContentHandler;
  87 import org.xml.sax.InputSource;
  88 import org.xml.sax.SAXException;
  89 import org.xml.sax.XMLReader;
  90 import org.xml.sax.ext.LexicalHandler;
  91 
  92 /**
  93  * @author Morten Jorgensen
  94  * @author G. Todd Miller
  95  * @author Santiago Pericas-Geertsen
<span class="line-modified">  96  * @LastModified: Feb 2019</span>
  97  */
  98 public final class TransformerImpl extends Transformer
<span class="line-modified">  99     implements DOMCache, ErrorListener</span>
 100 {
 101 
 102     private final static String LEXICAL_HANDLER_PROPERTY =
 103         &quot;http://xml.org/sax/properties/lexical-handler&quot;;
 104 
 105     /**
 106      * Namespace prefixes feature for {@link XMLReader}.
 107      */
 108     private static final String NAMESPACE_PREFIXES_FEATURE =
 109         &quot;http://xml.org/sax/features/namespace-prefixes&quot;;
 110 
 111     /**
 112      * A reference to the translet or null if the identity transform.
 113      */
 114     private AbstractTranslet _translet = null;
 115 
 116     /**
 117      * The output method of this transformation.
 118      */
 119     private String _method = null;
 120 
 121     /**
 122      * The output encoding of this transformation.
 123      */
 124     private String _encoding = null;
 125 
 126     /**
 127      * The systemId set in input source.
 128      */
 129     private String _sourceSystemId = null;
 130 





 131     /**
 132      * An error listener for runtime errors.
 133      */
<span class="line-modified"> 134     private ErrorListener _errorListener = this;</span>
 135 
 136     /**
 137      * A reference to a URI resolver for calls to document().
 138      */
 139     private URIResolver _uriResolver = null;
 140 
 141     /**
 142      * Output properties of this transformer instance.
 143      */
 144     private Properties _properties, _propertiesClone;
 145 
 146     /**
 147      * A reference to an output handler factory.
 148      */
 149     private TransletOutputHandlerFactory _tohFactory = null;
 150 
 151     /**
 152      * A reference to a internal DOM representation of the input.
 153      */
 154     private DOM _dom = null;
</pre>
<hr />
<pre>
 233         private ErrorListener _errorListener;
 234 
 235         public MessageHandler(ErrorListener errorListener) {
 236             _errorListener = errorListener;
 237         }
 238 
 239         @Override
 240         public void displayMessage(String msg) {
 241             if(_errorListener == null) {
 242                 System.err.println(msg);
 243             }
 244             else {
 245                 try {
 246                     _errorListener.warning(new TransformerException(msg));
 247                 }
 248                 catch (TransformerException e) {
 249                     // ignored
 250                 }
 251             }
 252         }




 253     }
 254 
 255     protected TransformerImpl(Properties outputProperties, int indentNumber,
 256         TransformerFactoryImpl tfactory)
 257     {
 258         this(null, outputProperties, indentNumber, tfactory);
 259         _isIdentity = true;
 260         // _properties.put(OutputKeys.METHOD, &quot;xml&quot;);
 261     }
 262 
 263     protected TransformerImpl(Translet translet, Properties outputProperties,
 264         int indentNumber, TransformerFactoryImpl tfactory)
 265     {
 266         _translet = (AbstractTranslet) translet;



 267         _properties = createOutputProperties(outputProperties);
 268         _propertiesClone = (Properties) _properties.clone();
 269         _indentNumber = indentNumber;
 270         _tfactory = tfactory;
 271         _overrideDefaultParser = _tfactory.overrideDefaultParser();
 272         _accessExternalDTD = (String)_tfactory.getAttribute(XMLConstants.ACCESS_EXTERNAL_DTD);
 273         _securityManager = (XMLSecurityManager)_tfactory.getAttribute(XalanConstants.SECURITY_MANAGER);
 274         _readerManager = XMLReaderManager.getInstance(_overrideDefaultParser);
 275         _readerManager.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, _accessExternalDTD);
 276         _readerManager.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, _isSecureProcessing);
 277         _readerManager.setProperty(XalanConstants.SECURITY_MANAGER, _securityManager);
 278         _cdataChunkSize = JdkXmlUtils.getValue(_tfactory.getAttribute(JdkXmlUtils.CDATA_CHUNK_SIZE),
 279                 JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT);
 280         _readerManager.setProperty(JdkXmlUtils.CDATA_CHUNK_SIZE, _cdataChunkSize);
 281 
 282         _useCatalog = _tfactory.getFeature(XMLConstants.USE_CATALOG);
 283         if (_useCatalog) {
 284             _catalogFeatures = (CatalogFeatures)_tfactory.getAttribute(JdkXmlFeatures.CATALOG_FEATURES);
 285             String catalogFiles = _catalogFeatures.get(CatalogFeatures.Feature.DEFER);
 286             if (catalogFiles != null) {
</pre>
<hr />
<pre>
 383             }
 384         } catch (Exception e) {
 385             System.out.println(&quot;Result writing error&quot;);
 386         }
 387     }
 388 
 389     /**
 390      * Create an output handler for the transformation output based on
 391      * the type and contents of the TrAX Result object passed to the
 392      * transform() method.
 393      */
 394     public SerializationHandler getOutputHandler(Result result)
 395         throws TransformerException
 396     {
 397         // Get output method using get() to ignore defaults
 398         _method = (String) _properties.get(OutputKeys.METHOD);
 399 
 400         // Get encoding using getProperty() to use defaults
 401         _encoding = _properties.getProperty(OutputKeys.ENCODING);
 402 
<span class="line-modified"> 403         _tohFactory = TransletOutputHandlerFactory.newInstance(_overrideDefaultParser);</span>

 404         _tohFactory.setEncoding(_encoding);
 405         if (_method != null) {
 406             _tohFactory.setOutputMethod(_method);
 407         }
 408 
 409         // Set indentation number in the factory
 410         if (_indentNumber &gt;= 0) {
 411             _tohFactory.setIndentNumber(_indentNumber);
 412         }
 413 
 414         // Return the content handler for this Result object
 415         try {
 416             // Result object could be SAXResult, DOMResult, or StreamResult
 417             if (result instanceof SAXResult) {
 418                 final SAXResult target = (SAXResult)result;
 419                 final ContentHandler handler = target.getHandler();
 420 
 421                 _tohFactory.setHandler(handler);
 422 
 423                 /**
</pre>
<hr />
<pre>
 812     /**
 813      * Implements JAXP&#39;s Transformer.setErrorListener()
 814      * Set the error event listener in effect for the transformation.
 815      * Register a message handler in the translet in order to forward
 816      * xsl:messages to error listener.
 817      *
 818      * @param listener The error event listener to use
 819      * @throws IllegalArgumentException
 820      */
 821     @Override
 822     public void setErrorListener(ErrorListener listener)
 823         throws IllegalArgumentException {
 824         if (listener == null) {
 825             ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
 826                                         &quot;Transformer&quot;);
 827             throw new IllegalArgumentException(err.toString());
 828         }
 829         _errorListener = listener;
 830 
 831         // Register a message handler to report xsl:messages
<span class="line-modified"> 832     if (_translet != null)</span>
<span class="line-modified"> 833         _translet.setMessageHandler(new MessageHandler(_errorListener));</span>
 834     }
 835 
 836     /**
 837      * Inform TrAX error listener of an error
 838      */
 839     private void postErrorToListener(String message) {
 840         try {
 841             _errorListener.error(new TransformerException(message));
 842         }
 843         catch (TransformerException e) {
 844             // ignored - transformation cannot be continued
 845         }
 846     }
 847 
 848     /**
 849      * Inform TrAX error listener of a warning
 850      */
 851     private void postWarningToListener(String message) {
 852         try {
 853             _errorListener.warning(new TransformerException(message));
</pre>
<hr />
<pre>
1335                     _catalogUriResolver = CatalogManager.catalogResolver(_catalogFeatures);
1336                 }
1337                 resolvedSource = _catalogUriResolver.resolve(href, baseURI);
1338             }
1339 
1340             if (resolvedSource == null)  {
1341                 StreamSource streamSource = new StreamSource(
1342                      SystemIDResolver.getAbsoluteURI(href, baseURI));
1343                 return getDOM(streamSource) ;
1344             }
1345 
1346             return getDOM(resolvedSource);
1347         }
1348         catch (TransformerException | CatalogException e) {
1349             if (_errorListener != null)
1350                 postErrorToListener(&quot;File not found: &quot; + e.getMessage());
1351             return(null);
1352         }
1353     }
1354 
<span class="line-removed">1355     /**</span>
<span class="line-removed">1356      * Receive notification of a recoverable error.</span>
<span class="line-removed">1357      * The transformer must continue to provide normal parsing events after</span>
<span class="line-removed">1358      * invoking this method. It should still be possible for the application</span>
<span class="line-removed">1359      * to process the document through to the end.</span>
<span class="line-removed">1360      *</span>
<span class="line-removed">1361      * @param e The warning information encapsulated in a transformer</span>
<span class="line-removed">1362      * exception.</span>
<span class="line-removed">1363      * @throws TransformerException if the application chooses to discontinue</span>
<span class="line-removed">1364      * the transformation (always does in our case).</span>
<span class="line-removed">1365      */</span>
<span class="line-removed">1366     @Override</span>
<span class="line-removed">1367     public void error(TransformerException e)</span>
<span class="line-removed">1368         throws TransformerException</span>
<span class="line-removed">1369     {</span>
<span class="line-removed">1370         Throwable wrapped = e.getException();</span>
<span class="line-removed">1371         if (wrapped != null) {</span>
<span class="line-removed">1372             System.err.println(new ErrorMsg(ErrorMsg.ERROR_PLUS_WRAPPED_MSG,</span>
<span class="line-removed">1373                                             e.getMessageAndLocation(),</span>
<span class="line-removed">1374                                             wrapped.getMessage()));</span>
<span class="line-removed">1375         } else {</span>
<span class="line-removed">1376             System.err.println(new ErrorMsg(ErrorMsg.ERROR_MSG,</span>
<span class="line-removed">1377                                             e.getMessageAndLocation()));</span>
<span class="line-removed">1378         }</span>
<span class="line-removed">1379         throw e;</span>
<span class="line-removed">1380     }</span>
<span class="line-removed">1381 </span>
<span class="line-removed">1382     /**</span>
<span class="line-removed">1383      * Receive notification of a non-recoverable error.</span>
<span class="line-removed">1384      * The application must assume that the transformation cannot continue</span>
<span class="line-removed">1385      * after the Transformer has invoked this method, and should continue</span>
<span class="line-removed">1386      * (if at all) only to collect addition error messages. In fact,</span>
<span class="line-removed">1387      * Transformers are free to stop reporting events once this method has</span>
<span class="line-removed">1388      * been invoked.</span>
<span class="line-removed">1389      *</span>
<span class="line-removed">1390      * @param e The warning information encapsulated in a transformer</span>
<span class="line-removed">1391      * exception.</span>
<span class="line-removed">1392      * @throws TransformerException if the application chooses to discontinue</span>
<span class="line-removed">1393      * the transformation (always does in our case).</span>
<span class="line-removed">1394      */</span>
<span class="line-removed">1395     @Override</span>
<span class="line-removed">1396     public void fatalError(TransformerException e)</span>
<span class="line-removed">1397         throws TransformerException</span>
<span class="line-removed">1398     {</span>
<span class="line-removed">1399         Throwable wrapped = e.getException();</span>
<span class="line-removed">1400         if (wrapped != null) {</span>
<span class="line-removed">1401             System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSG,</span>
<span class="line-removed">1402                                             e.getMessageAndLocation(),</span>
<span class="line-removed">1403                                             wrapped.getMessage()));</span>
<span class="line-removed">1404         } else {</span>
<span class="line-removed">1405             System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_MSG,</span>
<span class="line-removed">1406                                             e.getMessageAndLocation()));</span>
<span class="line-removed">1407         }</span>
<span class="line-removed">1408         throw e;</span>
<span class="line-removed">1409     }</span>
<span class="line-removed">1410 </span>
<span class="line-removed">1411     /**</span>
<span class="line-removed">1412      * Receive notification of a warning.</span>
<span class="line-removed">1413      * Transformers can use this method to report conditions that are not</span>
<span class="line-removed">1414      * errors or fatal errors. The default behaviour is to take no action.</span>
<span class="line-removed">1415      * After invoking this method, the Transformer must continue with the</span>
<span class="line-removed">1416      * transformation. It should still be possible for the application to</span>
<span class="line-removed">1417      * process the document through to the end.</span>
<span class="line-removed">1418      *</span>
<span class="line-removed">1419      * @param e The warning information encapsulated in a transformer</span>
<span class="line-removed">1420      * exception.</span>
<span class="line-removed">1421      * @throws TransformerException if the application chooses to discontinue</span>
<span class="line-removed">1422      * the transformation (never does in our case).</span>
<span class="line-removed">1423      */</span>
<span class="line-removed">1424     @Override</span>
<span class="line-removed">1425     public void warning(TransformerException e)</span>
<span class="line-removed">1426         throws TransformerException</span>
<span class="line-removed">1427     {</span>
<span class="line-removed">1428         Throwable wrapped = e.getException();</span>
<span class="line-removed">1429         if (wrapped != null) {</span>
<span class="line-removed">1430             System.err.println(new ErrorMsg(ErrorMsg.WARNING_PLUS_WRAPPED_MSG,</span>
<span class="line-removed">1431                                             e.getMessageAndLocation(),</span>
<span class="line-removed">1432                                             wrapped.getMessage()));</span>
<span class="line-removed">1433         } else {</span>
<span class="line-removed">1434             System.err.println(new ErrorMsg(ErrorMsg.WARNING_MSG,</span>
<span class="line-removed">1435                                             e.getMessageAndLocation()));</span>
<span class="line-removed">1436         }</span>
<span class="line-removed">1437     }</span>
<span class="line-removed">1438 </span>
1439     /**
1440      * This method resets  the Transformer to its original configuration
1441      * Transformer code is reset to the same state it was when it was
1442      * created
1443      * @since 1.5
1444      */
1445     @Override
1446     public void reset() {
1447 
1448         _method = null;
1449         _encoding = null;
1450         _sourceSystemId = null;
<span class="line-modified">1451         _errorListener = this;</span>
1452         _uriResolver = null;
1453         _dom = null;
1454         _parameters = null;
1455         _indentNumber = -1;
1456         setOutputProperties (null);
1457         _tohFactory = null;
1458         _ostream = null;
1459 
1460     }
1461 }
</pre>
</td>
<td>
<hr />
<pre>
  66 import javax.xml.parsers.ParserConfigurationException;
  67 import javax.xml.stream.XMLEventReader;
  68 import javax.xml.stream.XMLStreamReader;
  69 import javax.xml.transform.ErrorListener;
  70 import javax.xml.transform.OutputKeys;
  71 import javax.xml.transform.Result;
  72 import javax.xml.transform.Source;
  73 import javax.xml.transform.Transformer;
  74 import javax.xml.transform.TransformerException;
  75 import javax.xml.transform.URIResolver;
  76 import javax.xml.transform.dom.DOMResult;
  77 import javax.xml.transform.dom.DOMSource;
  78 import javax.xml.transform.sax.SAXResult;
  79 import javax.xml.transform.sax.SAXSource;
  80 import javax.xml.transform.stax.StAXResult;
  81 import javax.xml.transform.stax.StAXSource;
  82 import javax.xml.transform.stream.StreamResult;
  83 import javax.xml.transform.stream.StreamSource;
  84 import jdk.xml.internal.JdkXmlFeatures;
  85 import jdk.xml.internal.JdkXmlUtils;
<span class="line-added">  86 import jdk.xml.internal.TransformErrorListener;</span>
  87 import org.xml.sax.ContentHandler;
  88 import org.xml.sax.InputSource;
  89 import org.xml.sax.SAXException;
  90 import org.xml.sax.XMLReader;
  91 import org.xml.sax.ext.LexicalHandler;
  92 
  93 /**
  94  * @author Morten Jorgensen
  95  * @author G. Todd Miller
  96  * @author Santiago Pericas-Geertsen
<span class="line-modified">  97  * @LastModified: Aug 2019</span>
  98  */
  99 public final class TransformerImpl extends Transformer
<span class="line-modified"> 100     implements DOMCache</span>
 101 {
 102 
 103     private final static String LEXICAL_HANDLER_PROPERTY =
 104         &quot;http://xml.org/sax/properties/lexical-handler&quot;;
 105 
 106     /**
 107      * Namespace prefixes feature for {@link XMLReader}.
 108      */
 109     private static final String NAMESPACE_PREFIXES_FEATURE =
 110         &quot;http://xml.org/sax/features/namespace-prefixes&quot;;
 111 
 112     /**
 113      * A reference to the translet or null if the identity transform.
 114      */
 115     private AbstractTranslet _translet = null;
 116 
 117     /**
 118      * The output method of this transformation.
 119      */
 120     private String _method = null;
 121 
 122     /**
 123      * The output encoding of this transformation.
 124      */
 125     private String _encoding = null;
 126 
 127     /**
 128      * The systemId set in input source.
 129      */
 130     private String _sourceSystemId = null;
 131 
<span class="line-added"> 132     /**</span>
<span class="line-added"> 133      * Default error listener</span>
<span class="line-added"> 134      */</span>
<span class="line-added"> 135     private final ErrorListener _defaultListener = new TransformErrorListener();</span>
<span class="line-added"> 136 </span>
 137     /**
 138      * An error listener for runtime errors.
 139      */
<span class="line-modified"> 140     private ErrorListener _errorListener = _defaultListener;</span>
 141 
 142     /**
 143      * A reference to a URI resolver for calls to document().
 144      */
 145     private URIResolver _uriResolver = null;
 146 
 147     /**
 148      * Output properties of this transformer instance.
 149      */
 150     private Properties _properties, _propertiesClone;
 151 
 152     /**
 153      * A reference to an output handler factory.
 154      */
 155     private TransletOutputHandlerFactory _tohFactory = null;
 156 
 157     /**
 158      * A reference to a internal DOM representation of the input.
 159      */
 160     private DOM _dom = null;
</pre>
<hr />
<pre>
 239         private ErrorListener _errorListener;
 240 
 241         public MessageHandler(ErrorListener errorListener) {
 242             _errorListener = errorListener;
 243         }
 244 
 245         @Override
 246         public void displayMessage(String msg) {
 247             if(_errorListener == null) {
 248                 System.err.println(msg);
 249             }
 250             else {
 251                 try {
 252                     _errorListener.warning(new TransformerException(msg));
 253                 }
 254                 catch (TransformerException e) {
 255                     // ignored
 256                 }
 257             }
 258         }
<span class="line-added"> 259 </span>
<span class="line-added"> 260         public ErrorListener getErrorListener() {</span>
<span class="line-added"> 261             return _errorListener;</span>
<span class="line-added"> 262         }</span>
 263     }
 264 
 265     protected TransformerImpl(Properties outputProperties, int indentNumber,
 266         TransformerFactoryImpl tfactory)
 267     {
 268         this(null, outputProperties, indentNumber, tfactory);
 269         _isIdentity = true;
 270         // _properties.put(OutputKeys.METHOD, &quot;xml&quot;);
 271     }
 272 
 273     protected TransformerImpl(Translet translet, Properties outputProperties,
 274         int indentNumber, TransformerFactoryImpl tfactory)
 275     {
 276         _translet = (AbstractTranslet) translet;
<span class="line-added"> 277         if (_translet != null) {</span>
<span class="line-added"> 278             _translet.setMessageHandler(new MessageHandler(_errorListener));</span>
<span class="line-added"> 279         }</span>
 280         _properties = createOutputProperties(outputProperties);
 281         _propertiesClone = (Properties) _properties.clone();
 282         _indentNumber = indentNumber;
 283         _tfactory = tfactory;
 284         _overrideDefaultParser = _tfactory.overrideDefaultParser();
 285         _accessExternalDTD = (String)_tfactory.getAttribute(XMLConstants.ACCESS_EXTERNAL_DTD);
 286         _securityManager = (XMLSecurityManager)_tfactory.getAttribute(XalanConstants.SECURITY_MANAGER);
 287         _readerManager = XMLReaderManager.getInstance(_overrideDefaultParser);
 288         _readerManager.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, _accessExternalDTD);
 289         _readerManager.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, _isSecureProcessing);
 290         _readerManager.setProperty(XalanConstants.SECURITY_MANAGER, _securityManager);
 291         _cdataChunkSize = JdkXmlUtils.getValue(_tfactory.getAttribute(JdkXmlUtils.CDATA_CHUNK_SIZE),
 292                 JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT);
 293         _readerManager.setProperty(JdkXmlUtils.CDATA_CHUNK_SIZE, _cdataChunkSize);
 294 
 295         _useCatalog = _tfactory.getFeature(XMLConstants.USE_CATALOG);
 296         if (_useCatalog) {
 297             _catalogFeatures = (CatalogFeatures)_tfactory.getAttribute(JdkXmlFeatures.CATALOG_FEATURES);
 298             String catalogFiles = _catalogFeatures.get(CatalogFeatures.Feature.DEFER);
 299             if (catalogFiles != null) {
</pre>
<hr />
<pre>
 396             }
 397         } catch (Exception e) {
 398             System.out.println(&quot;Result writing error&quot;);
 399         }
 400     }
 401 
 402     /**
 403      * Create an output handler for the transformation output based on
 404      * the type and contents of the TrAX Result object passed to the
 405      * transform() method.
 406      */
 407     public SerializationHandler getOutputHandler(Result result)
 408         throws TransformerException
 409     {
 410         // Get output method using get() to ignore defaults
 411         _method = (String) _properties.get(OutputKeys.METHOD);
 412 
 413         // Get encoding using getProperty() to use defaults
 414         _encoding = _properties.getProperty(OutputKeys.ENCODING);
 415 
<span class="line-modified"> 416         _tohFactory = TransletOutputHandlerFactory</span>
<span class="line-added"> 417                 .newInstance(_overrideDefaultParser, _errorListener);</span>
 418         _tohFactory.setEncoding(_encoding);
 419         if (_method != null) {
 420             _tohFactory.setOutputMethod(_method);
 421         }
 422 
 423         // Set indentation number in the factory
 424         if (_indentNumber &gt;= 0) {
 425             _tohFactory.setIndentNumber(_indentNumber);
 426         }
 427 
 428         // Return the content handler for this Result object
 429         try {
 430             // Result object could be SAXResult, DOMResult, or StreamResult
 431             if (result instanceof SAXResult) {
 432                 final SAXResult target = (SAXResult)result;
 433                 final ContentHandler handler = target.getHandler();
 434 
 435                 _tohFactory.setHandler(handler);
 436 
 437                 /**
</pre>
<hr />
<pre>
 826     /**
 827      * Implements JAXP&#39;s Transformer.setErrorListener()
 828      * Set the error event listener in effect for the transformation.
 829      * Register a message handler in the translet in order to forward
 830      * xsl:messages to error listener.
 831      *
 832      * @param listener The error event listener to use
 833      * @throws IllegalArgumentException
 834      */
 835     @Override
 836     public void setErrorListener(ErrorListener listener)
 837         throws IllegalArgumentException {
 838         if (listener == null) {
 839             ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
 840                                         &quot;Transformer&quot;);
 841             throw new IllegalArgumentException(err.toString());
 842         }
 843         _errorListener = listener;
 844 
 845         // Register a message handler to report xsl:messages
<span class="line-modified"> 846         if (_translet != null)</span>
<span class="line-modified"> 847             _translet.setMessageHandler(new MessageHandler(_errorListener));</span>
 848     }
 849 
 850     /**
 851      * Inform TrAX error listener of an error
 852      */
 853     private void postErrorToListener(String message) {
 854         try {
 855             _errorListener.error(new TransformerException(message));
 856         }
 857         catch (TransformerException e) {
 858             // ignored - transformation cannot be continued
 859         }
 860     }
 861 
 862     /**
 863      * Inform TrAX error listener of a warning
 864      */
 865     private void postWarningToListener(String message) {
 866         try {
 867             _errorListener.warning(new TransformerException(message));
</pre>
<hr />
<pre>
1349                     _catalogUriResolver = CatalogManager.catalogResolver(_catalogFeatures);
1350                 }
1351                 resolvedSource = _catalogUriResolver.resolve(href, baseURI);
1352             }
1353 
1354             if (resolvedSource == null)  {
1355                 StreamSource streamSource = new StreamSource(
1356                      SystemIDResolver.getAbsoluteURI(href, baseURI));
1357                 return getDOM(streamSource) ;
1358             }
1359 
1360             return getDOM(resolvedSource);
1361         }
1362         catch (TransformerException | CatalogException e) {
1363             if (_errorListener != null)
1364                 postErrorToListener(&quot;File not found: &quot; + e.getMessage());
1365             return(null);
1366         }
1367     }
1368 




















































































1369     /**
1370      * This method resets  the Transformer to its original configuration
1371      * Transformer code is reset to the same state it was when it was
1372      * created
1373      * @since 1.5
1374      */
1375     @Override
1376     public void reset() {
1377 
1378         _method = null;
1379         _encoding = null;
1380         _sourceSystemId = null;
<span class="line-modified">1381         _errorListener = _defaultListener;</span>
1382         _uriResolver = null;
1383         _dom = null;
1384         _parameters = null;
1385         _indentNumber = -1;
1386         setOutputProperties (null);
1387         _tohFactory = null;
1388         _ostream = null;
1389 
1390     }
1391 }
</pre>
</td>
</tr>
</table>
<center><a href="TransformerFactoryImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../xerces/internal/dom/AttrImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
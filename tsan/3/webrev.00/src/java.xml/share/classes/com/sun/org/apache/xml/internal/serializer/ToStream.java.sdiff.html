<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ToHTMLStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ToTextStream.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToStream.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2006, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
</pre>
<hr />
<pre>
  34 import java.util.Enumeration;
  35 import java.util.Iterator;
  36 import java.util.List;
  37 import java.util.Properties;
  38 import java.util.Set;
  39 import java.util.StringTokenizer;
  40 import javax.xml.transform.ErrorListener;
  41 import javax.xml.transform.OutputKeys;
  42 import javax.xml.transform.Transformer;
  43 import javax.xml.transform.TransformerException;
  44 import org.w3c.dom.Node;
  45 import org.xml.sax.Attributes;
  46 import org.xml.sax.ContentHandler;
  47 import org.xml.sax.SAXException;
  48 
  49 /**
  50  * This abstract class is a base class for other stream
  51  * serializers (xml, html, text ...) that write output to a stream.
  52  *
  53  * @xsl.usage internal
<span class="line-modified">  54  * @LastModified: Sept 2018</span>
  55  */
  56 abstract public class ToStream extends SerializerBase {
  57 
  58     private static final String COMMENT_BEGIN = &quot;&lt;!--&quot;;
  59     private static final String COMMENT_END = &quot;--&gt;&quot;;
  60 
  61     /** Stack to keep track of disabling output escaping. */
  62     protected BoolStack m_disableOutputEscapingStates = new BoolStack();
  63 
  64     /**
  65      * The encoding information associated with this serializer.
  66      * Although initially there is no encoding,
  67      * there is a dummy EncodingInfo object that will say
  68      * that every character is in the encoding. This is useful
  69      * for a serializer that is in temporary output state and has
  70      * no associated encoding. A serializer in final output state
  71      * will have an encoding, and will worry about whether
  72      * single chars or surrogate pairs of high/low chars form
  73      * characters in the output encoding.
  74      */
</pre>
<hr />
<pre>
 181      * Flag to quickly tell if the encoding is UTF8.
 182      */
 183     boolean m_isUTF8 = false;
 184 
 185     /**
 186      * remembers if we are in between the startCDATA() and endCDATA() callbacks
 187      */
 188     protected boolean m_cdataStartCalled = false;
 189 
 190     /**
 191      * If this flag is true DTD entity references are not left as-is,
 192      * which is exiting older behavior.
 193      */
 194     private boolean m_expandDTDEntities = true;
 195 
 196     private char m_highSurrogate = 0;
 197 
 198     /**
 199      * Default constructor
 200      */
<span class="line-modified"> 201     public ToStream() { }</span>






 202 
 203     /**
 204      * This helper method to writes out &quot;]]&gt;&quot; when closing a CDATA section.
 205      *
 206      * @throws org.xml.sax.SAXException
 207      */
 208     protected void closeCDATA() throws org.xml.sax.SAXException {
 209         try {
 210             m_writer.write(CDATA_DELIMITER_CLOSE);
 211             // write out a CDATA section closing &quot;]]&gt;&quot;
 212             m_cdataTagOpen = false; // Remember that we have done so.
 213         }
 214         catch (IOException e) {
 215             throw new SAXException(e);
 216         }
 217     }
 218 
 219     /**
 220      * Serializes the DOM node. Throws an exception only if an I/O
 221      * exception occured while serializing.
</pre>
<hr />
<pre>
 405                 break;
 406             case &#39;e&#39;:
 407                 String newEncoding = val;
 408                 if (OutputKeys.ENCODING.equals(name)) {
 409                     String possible_encoding = Encodings.getMimeEncoding(val);
 410                     if (possible_encoding != null) {
 411                         // if the encoding is being set, try to get the
 412                         // preferred
 413                         // mime-name and set it too.
 414                         super.setProp(&quot;mime-name&quot;, possible_encoding,
 415                                 defaultVal);
 416                     }
 417                     final String oldExplicitEncoding = getOutputPropertyNonDefault(OutputKeys.ENCODING);
 418                     final String oldDefaultEncoding  = getOutputPropertyDefault(OutputKeys.ENCODING);
 419                     if ( (defaultVal &amp;&amp; ( oldDefaultEncoding == null || !oldDefaultEncoding.equalsIgnoreCase(newEncoding)))
 420                             || ( !defaultVal &amp;&amp; (oldExplicitEncoding == null || !oldExplicitEncoding.equalsIgnoreCase(newEncoding) ))) {
 421                        // We are trying to change the default or the non-default setting of the encoding to a different value
 422                        // from what it was
 423 
 424                        EncodingInfo encodingInfo = Encodings.getEncodingInfo(newEncoding);
<span class="line-modified"> 425                        if (newEncoding != null &amp;&amp; encodingInfo.name == null) {</span>
<span class="line-modified"> 426                         // We tried to get an EncodingInfo for Object for the given</span>
<span class="line-modified"> 427                         // encoding, but it came back with an internall null name</span>
<span class="line-modified"> 428                         // so the encoding is not supported by the JDK, issue a message.</span>
<span class="line-modified"> 429                         final String msg = Utils.messages.createMessage(</span>
<span class="line-modified"> 430                                 MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{ newEncoding });</span>
<span class="line-modified"> 431 </span>
<span class="line-modified"> 432                         final String msg2 =</span>
<span class="line-modified"> 433                             &quot;Warning: encoding \&quot;&quot; + newEncoding + &quot;\&quot; not supported, using &quot;</span>
<span class="line-modified"> 434                                    + Encodings.DEFAULT_MIME_ENCODING;</span>
<span class="line-modified"> 435                         try {</span>
<span class="line-modified"> 436                                 // Prepare to issue the warning message</span>
<span class="line-modified"> 437                                 final Transformer tran = super.getTransformer();</span>
<span class="line-modified"> 438                                 if (tran != null) {</span>
<span class="line-modified"> 439                                     final ErrorListener errHandler = tran</span>
<span class="line-modified"> 440                                             .getErrorListener();</span>
<span class="line-removed"> 441                                     // Issue the warning message</span>
<span class="line-removed"> 442                                     if (null != errHandler</span>
<span class="line-removed"> 443                                             &amp;&amp; m_sourceLocator != null) {</span>
<span class="line-removed"> 444                                         errHandler</span>
<span class="line-removed"> 445                                                 .warning(new TransformerException(</span>
<span class="line-removed"> 446                                                         msg, m_sourceLocator));</span>
<span class="line-removed"> 447                                         errHandler</span>
<span class="line-removed"> 448                                                 .warning(new TransformerException(</span>
<span class="line-removed"> 449                                                         msg2, m_sourceLocator));</span>
<span class="line-removed"> 450                                     } else {</span>
<span class="line-removed"> 451                                         System.out.println(msg);</span>
<span class="line-removed"> 452                                         System.out.println(msg2);</span>
<span class="line-removed"> 453                                     }</span>
<span class="line-removed"> 454                                 } else {</span>
<span class="line-removed"> 455                                     System.out.println(msg);</span>
<span class="line-removed"> 456                                     System.out.println(msg2);</span>
 457                                 }
 458                             } catch (Exception e) {
 459                             }
 460 
 461                             // We said we are using UTF-8, so use it
 462                             newEncoding = Encodings.DEFAULT_MIME_ENCODING;
<span class="line-modified"> 463                             val = Encodings.DEFAULT_MIME_ENCODING; // to store the modified value into the properties a little later</span>

 464                             encodingInfo = Encodings.getEncodingInfo(newEncoding);
 465                         }
 466                        // The encoding was good, or was forced to UTF-8 above
 467 
 468 
 469                        // If there is already a non-default set encoding and we
 470                        // are trying to set the default encoding, skip the this block
 471                        // as the non-default value is already the one to use.
 472                        if (defaultVal == false || oldExplicitEncoding == null) {
 473                            m_encodingInfo = encodingInfo;
 474                            if (newEncoding != null)
 475                                m_isUTF8 = newEncoding.equals(Encodings.DEFAULT_MIME_ENCODING);
 476 
 477                            // if there was a previously set OutputStream
 478                            OutputStream os = getOutputStream();
 479                            if (os != null) {
 480                                Writer w = getWriter();
 481 
 482                                // If the writer was previously set, but
 483                                // set by the user, or if the new encoding is the same
</pre>
<hr />
<pre>
1214      * @param length The number of characters to read from the array.
1215      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1216      *            wrapping another exception.
1217      * @see #ignorableWhitespace
1218      * @see org.xml.sax.Locator
1219      *
1220      * @throws org.xml.sax.SAXException
1221      */
1222     protected void cdata(char ch[], int start, final int length)
1223         throws org.xml.sax.SAXException
1224     {
1225         try
1226         {
1227             final int old_start = start;
1228             if (m_elemContext.m_startTagOpen)
1229             {
1230                 closeStartTag();
1231                 m_elemContext.m_startTagOpen = false;
1232             }
1233 
<span class="line-modified">1234             if (!m_cdataTagOpen &amp;&amp; shouldIndent())</span>
1235                 indent();
1236 
1237             boolean writeCDataBrackets =
1238                 (((length &gt;= 1) &amp;&amp; escapingNotNeeded(ch[start])));
1239 
1240             /* Write out the CDATA opening delimiter only if
1241              * we are supposed to, and if we are not already in
1242              * the middle of a CDATA section
1243              */
1244             if (writeCDataBrackets &amp;&amp; !m_cdataTagOpen)
1245             {
1246                 m_writer.write(CDATA_DELIMITER_OPEN);
1247                 m_cdataTagOpen = true;
1248             }
1249 
1250             // writer.write(ch, start, length);
1251             if (isEscapingDisabled())
1252             {
1253                 charactersRaw(ch, start, length);
1254             }
1255             else
1256                 writeNormalizedChars(ch, start, length, true, m_lineSepUse);
1257 
1258             /* used to always write out CDATA closing delimiter here,
1259              * but now we delay, so that we can merge CDATA sections on output.
1260              * need to write closing delimiter later
1261              */
1262             if (writeCDataBrackets)
1263             {
1264                 /* if the CDATA section ends with ] don&#39;t leave it open
1265                  * as there is a chance that an adjacent CDATA sections
1266                  * starts with ]&gt;.
1267                  * We don&#39;t want to merge ]] with &gt; , or ] with ]&gt;
1268                  */
1269                 if (ch[start + length - 1] == &#39;]&#39;)
1270                     closeCDATA();
1271             }
1272 

1273             // time to fire off CDATA event
1274             if (m_tracer != null)
1275                 super.fireCDATAEvent(ch, old_start, length);
1276         }
1277         catch (IOException ioe)
1278         {
1279             throw new org.xml.sax.SAXException(
1280                 Utils.messages.createMessage(
1281                     MsgKey.ER_OIERROR,
1282                     null),
1283                 ioe);
1284             //&quot;IO error&quot;, ioe);
1285         }
1286     }
1287 
1288     /**
1289      * Tell if the character escaping should be disabled for the current state.
1290      *
1291      * @return true if the character escaping should be disabled.
1292      */
</pre>
<hr />
<pre>
1519 
1520             // we&#39;ve reached the end. Any clean characters at the
1521             // end of the array than need to be written out?
1522             startClean = lastDirty + 1;
1523             if (i &gt; startClean)
1524             {
1525                 int lengthClean = i - startClean;
1526                 m_writer.write(chars, startClean, lengthClean);
1527             }
1528 
1529             // For indentation purposes, mark that we&#39;ve just writen text out
1530             m_isprevtext = true;
1531         }
1532         catch (IOException e)
1533         {
1534             throw new SAXException(e);
1535         }
1536     }
1537 
1538     /**
<span class="line-modified">1539      * Used to flush the buffered characters when indentation is on, this method</span>
<span class="line-modified">1540      * will be called when the next node is traversed.</span>
1541      *


1542      */
<span class="line-modified">1543     final protected void flushCharactersBuffer() throws SAXException {</span>
1544         try {
1545             if (shouldFormatOutput() &amp;&amp; m_charactersBuffer.isAnyCharactersBuffered()) {
1546                 if (m_elemContext.m_isCdataSection) {
1547                     /*
1548                      * due to cdata-section-elements atribute, we need this as
1549                      * cdata
1550                      */
1551                     char[] chars = m_charactersBuffer.toChars();
1552                     cdata(chars, 0, chars.length);
1553                     return;
1554                 }
1555 
<span class="line-modified">1556                 m_childNodeNum++;</span>


1557                 boolean skipBeginningNewlines = false;
1558                 if (shouldIndentForText()) {
1559                     indent();
1560                     m_startNewLine = true;
1561                     // newline has always been added here because if this is the
1562                     // text before the first element, shouldIndent() won&#39;t
1563                     // return true.
1564                     skipBeginningNewlines = true;
1565                 }
1566                 m_charactersBuffer.flush(skipBeginningNewlines);
1567             }
1568         } catch (IOException e) {
1569             throw new SAXException(e);
1570         } finally {
1571             m_charactersBuffer.clear();
1572         }
1573     }
1574 
1575     /**
1576      * True if should indent in flushCharactersBuffer method.
</pre>
<hr />
<pre>
1829      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1830      *            wrapping another exception.
1831      * @see org.xml.sax.ContentHandler#startElement
1832      * @see org.xml.sax.ContentHandler#endElement
1833      * @see org.xml.sax.AttributeList
1834      *
1835      * @throws org.xml.sax.SAXException
1836      */
1837     public void startElement(
1838         String namespaceURI,
1839         String localName,
1840         String name,
1841         Attributes atts)
1842         throws org.xml.sax.SAXException
1843     {
1844         if (isInEntityRef())
1845             return;
1846 
1847         if (m_doIndent) {
1848             m_childNodeNum++;
<span class="line-modified">1849             flushCharactersBuffer();</span>
1850         }
1851 
1852         if (m_needToCallStartDocument)
1853         {
1854             startDocumentInternal();
1855             m_needToCallStartDocument = false;
1856         }
1857         else if (m_cdataTagOpen)
1858             closeCDATA();
1859         try
1860         {
1861             if ((true == m_needToOutputDocTypeDecl)
1862                 &amp;&amp; (null != getDoctypeSystem()))
1863             {
1864                 outputDocTypeDecl(name, true);
1865             }
1866 
1867             m_needToOutputDocTypeDecl = false;
1868 
1869             /* before we over-write the current elementLocalName etc.
</pre>
<hr />
<pre>
2100      * @param namespaceURI The Namespace URI, or the empty string if the
2101      *        element has no Namespace URI or if Namespace
2102      *        processing is not being performed.
2103      * @param localName The local name (without prefix), or the
2104      *        empty string if Namespace processing is not being
2105      *        performed.
2106      * @param name The element type name
2107      * @throws org.xml.sax.SAXException Any SAX exception, possibly
2108      *            wrapping another exception.
2109      *
2110      * @throws org.xml.sax.SAXException
2111      */
2112     public void endElement(String namespaceURI, String localName, String name)
2113         throws org.xml.sax.SAXException
2114     {
2115 
2116         if (isInEntityRef())
2117             return;
2118 
2119         if (m_doIndent) {
<span class="line-modified">2120             flushCharactersBuffer();</span>
2121         }
2122         // namespaces declared at the current depth are no longer valid
2123         // so get rid of them
2124         m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth, null);
2125 
2126         try
2127         {
2128             final Writer writer = m_writer;
2129             if (m_elemContext.m_startTagOpen)
2130             {
2131                 if (m_tracer != null)
2132                     super.fireStartElem(m_elemContext.m_elementName);
2133                 int nAttrs = m_attributes.getLength();
2134                 if (nAttrs &gt; 0)
2135                 {
2136                     processAttributes(m_writer, nAttrs);
2137                     // clear attributes object for re-use with next element
2138                     m_attributes.clear();
2139                 }
2140                 if (m_spaceBeforeClose)
</pre>
<hr />
<pre>
2292     }
2293 
2294     /**
2295      * Receive notification of an XML comment anywhere in the document. This
2296      * callback will be used for comments inside or outside the document
2297      * element, including comments in the external DTD subset (if read).
2298      * @param ch An array holding the characters in the comment.
2299      * @param start The starting position in the array.
2300      * @param length The number of characters to use from the array.
2301      * @throws org.xml.sax.SAXException The application may raise an exception.
2302      */
2303     public void comment(char ch[], int start, int length)
2304         throws org.xml.sax.SAXException
2305     {
2306 
2307         int start_old = start;
2308         if (isInEntityRef())
2309             return;
2310         if (m_doIndent) {
2311             m_childNodeNum++;
<span class="line-modified">2312             flushCharactersBuffer();</span>
2313         }
2314         if (m_elemContext.m_startTagOpen)
2315         {
2316             closeStartTag();
2317             m_elemContext.m_startTagOpen = false;
2318         }
2319         else if (m_needToCallStartDocument)
2320         {
2321             startDocumentInternal();
2322             m_needToCallStartDocument = false;
2323         }
2324 
2325         try
2326         {
2327             if (shouldIndent() &amp;&amp; m_isStandalone)
2328                 indent();
2329 
2330             final int limit = start + length;
2331             boolean wasDash = false;
2332             if (m_cdataTagOpen)
</pre>
<hr />
<pre>
2474      * @param name The name of the skipped entity.  If it is a
2475      *       parameter                   entity, the name will begin with &#39;%&#39;,
2476      * and if it is the external DTD subset, it will be the string
2477      * &quot;[dtd]&quot;.
2478      * @throws org.xml.sax.SAXException Any SAX exception, possibly wrapping
2479      * another exception.
2480      */
2481     public void skippedEntity(String name) throws org.xml.sax.SAXException
2482     { // TODO: Should handle
2483     }
2484 
2485     /**
2486      * Report the start of a CDATA section.
2487      *
2488      * @throws org.xml.sax.SAXException The application may raise an exception.
2489      * @see #endCDATA
2490      */
2491     public void startCDATA() throws org.xml.sax.SAXException
2492     {
2493         if (m_doIndent) {
<span class="line-modified">2494             m_childNodeNum++;</span>
<span class="line-removed">2495             flushCharactersBuffer();</span>
2496         }
2497 
2498         m_cdataStartCalled = true;
2499     }
2500 
2501     /**
2502      * Report the beginning of an entity.
2503      *
2504      * The start and end of the document entity are not reported.
2505      * The start and end of the external DTD subset are reported
2506      * using the pseudo-name &quot;[dtd]&quot;.  All other events must be
2507      * properly nested within start/end entity events.
2508      *
2509      * @param name The name of the entity.  If it is a parameter
2510      *        entity, the name will begin with &#39;%&#39;.
2511      * @throws org.xml.sax.SAXException The application may raise an exception.
2512      * @see #endEntity
2513      * @see org.xml.sax.ext.DeclHandler#internalEntityDecl
2514      * @see org.xml.sax.ext.DeclHandler#externalEntityDecl
2515      */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
</pre>
<hr />
<pre>
  34 import java.util.Enumeration;
  35 import java.util.Iterator;
  36 import java.util.List;
  37 import java.util.Properties;
  38 import java.util.Set;
  39 import java.util.StringTokenizer;
  40 import javax.xml.transform.ErrorListener;
  41 import javax.xml.transform.OutputKeys;
  42 import javax.xml.transform.Transformer;
  43 import javax.xml.transform.TransformerException;
  44 import org.w3c.dom.Node;
  45 import org.xml.sax.Attributes;
  46 import org.xml.sax.ContentHandler;
  47 import org.xml.sax.SAXException;
  48 
  49 /**
  50  * This abstract class is a base class for other stream
  51  * serializers (xml, html, text ...) that write output to a stream.
  52  *
  53  * @xsl.usage internal
<span class="line-modified">  54  * @LastModified: Aug 2019</span>
  55  */
  56 abstract public class ToStream extends SerializerBase {
  57 
  58     private static final String COMMENT_BEGIN = &quot;&lt;!--&quot;;
  59     private static final String COMMENT_END = &quot;--&gt;&quot;;
  60 
  61     /** Stack to keep track of disabling output escaping. */
  62     protected BoolStack m_disableOutputEscapingStates = new BoolStack();
  63 
  64     /**
  65      * The encoding information associated with this serializer.
  66      * Although initially there is no encoding,
  67      * there is a dummy EncodingInfo object that will say
  68      * that every character is in the encoding. This is useful
  69      * for a serializer that is in temporary output state and has
  70      * no associated encoding. A serializer in final output state
  71      * will have an encoding, and will worry about whether
  72      * single chars or surrogate pairs of high/low chars form
  73      * characters in the output encoding.
  74      */
</pre>
<hr />
<pre>
 181      * Flag to quickly tell if the encoding is UTF8.
 182      */
 183     boolean m_isUTF8 = false;
 184 
 185     /**
 186      * remembers if we are in between the startCDATA() and endCDATA() callbacks
 187      */
 188     protected boolean m_cdataStartCalled = false;
 189 
 190     /**
 191      * If this flag is true DTD entity references are not left as-is,
 192      * which is exiting older behavior.
 193      */
 194     private boolean m_expandDTDEntities = true;
 195 
 196     private char m_highSurrogate = 0;
 197 
 198     /**
 199      * Default constructor
 200      */
<span class="line-modified"> 201     public ToStream() {</span>
<span class="line-added"> 202         this(null);</span>
<span class="line-added"> 203     }</span>
<span class="line-added"> 204 </span>
<span class="line-added"> 205     public ToStream(ErrorListener l) {</span>
<span class="line-added"> 206         m_errListener = l;</span>
<span class="line-added"> 207     }</span>
 208 
 209     /**
 210      * This helper method to writes out &quot;]]&gt;&quot; when closing a CDATA section.
 211      *
 212      * @throws org.xml.sax.SAXException
 213      */
 214     protected void closeCDATA() throws org.xml.sax.SAXException {
 215         try {
 216             m_writer.write(CDATA_DELIMITER_CLOSE);
 217             // write out a CDATA section closing &quot;]]&gt;&quot;
 218             m_cdataTagOpen = false; // Remember that we have done so.
 219         }
 220         catch (IOException e) {
 221             throw new SAXException(e);
 222         }
 223     }
 224 
 225     /**
 226      * Serializes the DOM node. Throws an exception only if an I/O
 227      * exception occured while serializing.
</pre>
<hr />
<pre>
 411                 break;
 412             case &#39;e&#39;:
 413                 String newEncoding = val;
 414                 if (OutputKeys.ENCODING.equals(name)) {
 415                     String possible_encoding = Encodings.getMimeEncoding(val);
 416                     if (possible_encoding != null) {
 417                         // if the encoding is being set, try to get the
 418                         // preferred
 419                         // mime-name and set it too.
 420                         super.setProp(&quot;mime-name&quot;, possible_encoding,
 421                                 defaultVal);
 422                     }
 423                     final String oldExplicitEncoding = getOutputPropertyNonDefault(OutputKeys.ENCODING);
 424                     final String oldDefaultEncoding  = getOutputPropertyDefault(OutputKeys.ENCODING);
 425                     if ( (defaultVal &amp;&amp; ( oldDefaultEncoding == null || !oldDefaultEncoding.equalsIgnoreCase(newEncoding)))
 426                             || ( !defaultVal &amp;&amp; (oldExplicitEncoding == null || !oldExplicitEncoding.equalsIgnoreCase(newEncoding) ))) {
 427                        // We are trying to change the default or the non-default setting of the encoding to a different value
 428                        // from what it was
 429 
 430                        EncodingInfo encodingInfo = Encodings.getEncodingInfo(newEncoding);
<span class="line-modified"> 431                        if (encodingInfo.name == null) {</span>
<span class="line-modified"> 432                             // We tried to get an EncodingInfo for Object for the given</span>
<span class="line-modified"> 433                             // encoding, but it came back with an internall null name</span>
<span class="line-modified"> 434                             // so the encoding is not supported by the JDK, issue a message.</span>
<span class="line-modified"> 435                             final String msg = Utils.messages.createMessage(</span>
<span class="line-modified"> 436                                     MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{ newEncoding });</span>
<span class="line-modified"> 437 </span>
<span class="line-modified"> 438                             final String msg2 =</span>
<span class="line-modified"> 439                                 &quot;Warning: encoding \&quot;&quot; + newEncoding + &quot;\&quot; not supported, using &quot;</span>
<span class="line-modified"> 440                                        + Encodings.DEFAULT_MIME_ENCODING;</span>
<span class="line-modified"> 441                             try {</span>
<span class="line-modified"> 442                                 // refer to JDK-8229005, should throw Exception instead of warning and</span>
<span class="line-modified"> 443                                 // then falling back to the default encoding. Keep it for now.</span>
<span class="line-modified"> 444                                 if (m_errListener != null) {</span>
<span class="line-modified"> 445                                     m_errListener.warning(new TransformerException(msg, m_sourceLocator));</span>
<span class="line-modified"> 446                                     m_errListener.warning(new TransformerException(msg2, m_sourceLocator));</span>
















 447                                 }
 448                             } catch (Exception e) {
 449                             }
 450 
 451                             // We said we are using UTF-8, so use it
 452                             newEncoding = Encodings.DEFAULT_MIME_ENCODING;
<span class="line-modified"> 453                             // to store the modified value into the properties a little later</span>
<span class="line-added"> 454                             val = Encodings.DEFAULT_MIME_ENCODING;</span>
 455                             encodingInfo = Encodings.getEncodingInfo(newEncoding);
 456                         }
 457                        // The encoding was good, or was forced to UTF-8 above
 458 
 459 
 460                        // If there is already a non-default set encoding and we
 461                        // are trying to set the default encoding, skip the this block
 462                        // as the non-default value is already the one to use.
 463                        if (defaultVal == false || oldExplicitEncoding == null) {
 464                            m_encodingInfo = encodingInfo;
 465                            if (newEncoding != null)
 466                                m_isUTF8 = newEncoding.equals(Encodings.DEFAULT_MIME_ENCODING);
 467 
 468                            // if there was a previously set OutputStream
 469                            OutputStream os = getOutputStream();
 470                            if (os != null) {
 471                                Writer w = getWriter();
 472 
 473                                // If the writer was previously set, but
 474                                // set by the user, or if the new encoding is the same
</pre>
<hr />
<pre>
1205      * @param length The number of characters to read from the array.
1206      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1207      *            wrapping another exception.
1208      * @see #ignorableWhitespace
1209      * @see org.xml.sax.Locator
1210      *
1211      * @throws org.xml.sax.SAXException
1212      */
1213     protected void cdata(char ch[], int start, final int length)
1214         throws org.xml.sax.SAXException
1215     {
1216         try
1217         {
1218             final int old_start = start;
1219             if (m_elemContext.m_startTagOpen)
1220             {
1221                 closeStartTag();
1222                 m_elemContext.m_startTagOpen = false;
1223             }
1224 
<span class="line-modified">1225             if (!m_cdataTagOpen &amp;&amp; shouldIndentForText())</span>
1226                 indent();
1227 
1228             boolean writeCDataBrackets =
1229                 (((length &gt;= 1) &amp;&amp; escapingNotNeeded(ch[start])));
1230 
1231             /* Write out the CDATA opening delimiter only if
1232              * we are supposed to, and if we are not already in
1233              * the middle of a CDATA section
1234              */
1235             if (writeCDataBrackets &amp;&amp; !m_cdataTagOpen)
1236             {
1237                 m_writer.write(CDATA_DELIMITER_OPEN);
1238                 m_cdataTagOpen = true;
1239             }
1240 
1241             // writer.write(ch, start, length);
1242             if (isEscapingDisabled())
1243             {
1244                 charactersRaw(ch, start, length);
1245             }
1246             else
1247                 writeNormalizedChars(ch, start, length, true, m_lineSepUse);
1248 
1249             /* used to always write out CDATA closing delimiter here,
1250              * but now we delay, so that we can merge CDATA sections on output.
1251              * need to write closing delimiter later
1252              */
1253             if (writeCDataBrackets)
1254             {
1255                 /* if the CDATA section ends with ] don&#39;t leave it open
1256                  * as there is a chance that an adjacent CDATA sections
1257                  * starts with ]&gt;.
1258                  * We don&#39;t want to merge ]] with &gt; , or ] with ]&gt;
1259                  */
1260                 if (ch[start + length - 1] == &#39;]&#39;)
1261                     closeCDATA();
1262             }
1263 
<span class="line-added">1264             m_isprevtext = true;</span>
1265             // time to fire off CDATA event
1266             if (m_tracer != null)
1267                 super.fireCDATAEvent(ch, old_start, length);
1268         }
1269         catch (IOException ioe)
1270         {
1271             throw new org.xml.sax.SAXException(
1272                 Utils.messages.createMessage(
1273                     MsgKey.ER_OIERROR,
1274                     null),
1275                 ioe);
1276             //&quot;IO error&quot;, ioe);
1277         }
1278     }
1279 
1280     /**
1281      * Tell if the character escaping should be disabled for the current state.
1282      *
1283      * @return true if the character escaping should be disabled.
1284      */
</pre>
<hr />
<pre>
1511 
1512             // we&#39;ve reached the end. Any clean characters at the
1513             // end of the array than need to be written out?
1514             startClean = lastDirty + 1;
1515             if (i &gt; startClean)
1516             {
1517                 int lengthClean = i - startClean;
1518                 m_writer.write(chars, startClean, lengthClean);
1519             }
1520 
1521             // For indentation purposes, mark that we&#39;ve just writen text out
1522             m_isprevtext = true;
1523         }
1524         catch (IOException e)
1525         {
1526             throw new SAXException(e);
1527         }
1528     }
1529 
1530     /**
<span class="line-modified">1531      * Flushes the buffered characters when indentation is on. This method</span>
<span class="line-modified">1532      * is called before the next node is traversed.</span>
1533      *
<span class="line-added">1534      * @param isText indicates whether the node to be traversed is text</span>
<span class="line-added">1535      * @throws org.xml.sax.SAXException</span>
1536      */
<span class="line-modified">1537     final protected void flushCharactersBuffer(boolean isText) throws SAXException {</span>
1538         try {
1539             if (shouldFormatOutput() &amp;&amp; m_charactersBuffer.isAnyCharactersBuffered()) {
1540                 if (m_elemContext.m_isCdataSection) {
1541                     /*
1542                      * due to cdata-section-elements atribute, we need this as
1543                      * cdata
1544                      */
1545                     char[] chars = m_charactersBuffer.toChars();
1546                     cdata(chars, 0, chars.length);
1547                     return;
1548                 }
1549 
<span class="line-modified">1550                 if (!isText) {</span>
<span class="line-added">1551                     m_childNodeNum++;</span>
<span class="line-added">1552                 }</span>
1553                 boolean skipBeginningNewlines = false;
1554                 if (shouldIndentForText()) {
1555                     indent();
1556                     m_startNewLine = true;
1557                     // newline has always been added here because if this is the
1558                     // text before the first element, shouldIndent() won&#39;t
1559                     // return true.
1560                     skipBeginningNewlines = true;
1561                 }
1562                 m_charactersBuffer.flush(skipBeginningNewlines);
1563             }
1564         } catch (IOException e) {
1565             throw new SAXException(e);
1566         } finally {
1567             m_charactersBuffer.clear();
1568         }
1569     }
1570 
1571     /**
1572      * True if should indent in flushCharactersBuffer method.
</pre>
<hr />
<pre>
1825      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1826      *            wrapping another exception.
1827      * @see org.xml.sax.ContentHandler#startElement
1828      * @see org.xml.sax.ContentHandler#endElement
1829      * @see org.xml.sax.AttributeList
1830      *
1831      * @throws org.xml.sax.SAXException
1832      */
1833     public void startElement(
1834         String namespaceURI,
1835         String localName,
1836         String name,
1837         Attributes atts)
1838         throws org.xml.sax.SAXException
1839     {
1840         if (isInEntityRef())
1841             return;
1842 
1843         if (m_doIndent) {
1844             m_childNodeNum++;
<span class="line-modified">1845             flushCharactersBuffer(false);</span>
1846         }
1847 
1848         if (m_needToCallStartDocument)
1849         {
1850             startDocumentInternal();
1851             m_needToCallStartDocument = false;
1852         }
1853         else if (m_cdataTagOpen)
1854             closeCDATA();
1855         try
1856         {
1857             if ((true == m_needToOutputDocTypeDecl)
1858                 &amp;&amp; (null != getDoctypeSystem()))
1859             {
1860                 outputDocTypeDecl(name, true);
1861             }
1862 
1863             m_needToOutputDocTypeDecl = false;
1864 
1865             /* before we over-write the current elementLocalName etc.
</pre>
<hr />
<pre>
2096      * @param namespaceURI The Namespace URI, or the empty string if the
2097      *        element has no Namespace URI or if Namespace
2098      *        processing is not being performed.
2099      * @param localName The local name (without prefix), or the
2100      *        empty string if Namespace processing is not being
2101      *        performed.
2102      * @param name The element type name
2103      * @throws org.xml.sax.SAXException Any SAX exception, possibly
2104      *            wrapping another exception.
2105      *
2106      * @throws org.xml.sax.SAXException
2107      */
2108     public void endElement(String namespaceURI, String localName, String name)
2109         throws org.xml.sax.SAXException
2110     {
2111 
2112         if (isInEntityRef())
2113             return;
2114 
2115         if (m_doIndent) {
<span class="line-modified">2116             flushCharactersBuffer(false);</span>
2117         }
2118         // namespaces declared at the current depth are no longer valid
2119         // so get rid of them
2120         m_prefixMap.popNamespaces(m_elemContext.m_currentElemDepth, null);
2121 
2122         try
2123         {
2124             final Writer writer = m_writer;
2125             if (m_elemContext.m_startTagOpen)
2126             {
2127                 if (m_tracer != null)
2128                     super.fireStartElem(m_elemContext.m_elementName);
2129                 int nAttrs = m_attributes.getLength();
2130                 if (nAttrs &gt; 0)
2131                 {
2132                     processAttributes(m_writer, nAttrs);
2133                     // clear attributes object for re-use with next element
2134                     m_attributes.clear();
2135                 }
2136                 if (m_spaceBeforeClose)
</pre>
<hr />
<pre>
2288     }
2289 
2290     /**
2291      * Receive notification of an XML comment anywhere in the document. This
2292      * callback will be used for comments inside or outside the document
2293      * element, including comments in the external DTD subset (if read).
2294      * @param ch An array holding the characters in the comment.
2295      * @param start The starting position in the array.
2296      * @param length The number of characters to use from the array.
2297      * @throws org.xml.sax.SAXException The application may raise an exception.
2298      */
2299     public void comment(char ch[], int start, int length)
2300         throws org.xml.sax.SAXException
2301     {
2302 
2303         int start_old = start;
2304         if (isInEntityRef())
2305             return;
2306         if (m_doIndent) {
2307             m_childNodeNum++;
<span class="line-modified">2308             flushCharactersBuffer(false);</span>
2309         }
2310         if (m_elemContext.m_startTagOpen)
2311         {
2312             closeStartTag();
2313             m_elemContext.m_startTagOpen = false;
2314         }
2315         else if (m_needToCallStartDocument)
2316         {
2317             startDocumentInternal();
2318             m_needToCallStartDocument = false;
2319         }
2320 
2321         try
2322         {
2323             if (shouldIndent() &amp;&amp; m_isStandalone)
2324                 indent();
2325 
2326             final int limit = start + length;
2327             boolean wasDash = false;
2328             if (m_cdataTagOpen)
</pre>
<hr />
<pre>
2470      * @param name The name of the skipped entity.  If it is a
2471      *       parameter                   entity, the name will begin with &#39;%&#39;,
2472      * and if it is the external DTD subset, it will be the string
2473      * &quot;[dtd]&quot;.
2474      * @throws org.xml.sax.SAXException Any SAX exception, possibly wrapping
2475      * another exception.
2476      */
2477     public void skippedEntity(String name) throws org.xml.sax.SAXException
2478     { // TODO: Should handle
2479     }
2480 
2481     /**
2482      * Report the start of a CDATA section.
2483      *
2484      * @throws org.xml.sax.SAXException The application may raise an exception.
2485      * @see #endCDATA
2486      */
2487     public void startCDATA() throws org.xml.sax.SAXException
2488     {
2489         if (m_doIndent) {
<span class="line-modified">2490             flushCharactersBuffer(true);</span>

2491         }
2492 
2493         m_cdataStartCalled = true;
2494     }
2495 
2496     /**
2497      * Report the beginning of an entity.
2498      *
2499      * The start and end of the document entity are not reported.
2500      * The start and end of the external DTD subset are reported
2501      * using the pseudo-name &quot;[dtd]&quot;.  All other events must be
2502      * properly nested within start/end entity events.
2503      *
2504      * @param name The name of the entity.  If it is a parameter
2505      *        entity, the name will begin with &#39;%&#39;.
2506      * @throws org.xml.sax.SAXException The application may raise an exception.
2507      * @see #endEntity
2508      * @see org.xml.sax.ext.DeclHandler#internalEntityDecl
2509      * @see org.xml.sax.ext.DeclHandler#externalEntityDecl
2510      */
</pre>
</td>
</tr>
</table>
<center><a href="ToHTMLStream.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ToTextStream.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
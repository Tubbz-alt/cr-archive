<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/ToHTMLStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
  23 import java.io.IOException;
  24 import java.util.Properties;
  25 
  26 import javax.xml.transform.Result;
  27 
  28 import org.xml.sax.Attributes;
  29 import org.xml.sax.SAXException;
  30 
  31 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
  32 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
  33 import javax.xml.transform.ErrorListener;
  34 
  35 /**
  36  * This serializer takes a series of SAX or
  37  * SAX-like events and writes its output
  38  * to the given stream.
  39  *
  40  * This class is not a public API, it is public
  41  * because it is used from another package.
  42  *
  43  * @xsl.usage internal
  44  * @LastModified: Aug 2019
  45  */
  46 public final class ToHTMLStream extends ToStream
  47 {
  48 
  49     /** This flag is set while receiving events from the DTD */
  50     protected boolean m_inDTD = false;
  51 
  52     /** True if the previous element is a block element. */
  53     private boolean m_isprevblock = false;
  54 
  55     /**
  56      * Map that tells which XML characters should have special treatment, and it
  57      *  provides character to entity name lookup.
  58      */
  59     private static final CharInfo m_htmlcharInfo =
  60 //        new CharInfo(CharInfo.HTML_ENTITIES_RESOURCE);
  61         CharInfo.getCharInfoInternal(CharInfo.HTML_ENTITIES_RESOURCE, Method.HTML);
  62 
  63     /** A digital search trie for fast, case insensitive lookup of ElemDesc objects. */
  64     static final Trie m_elementFlags = new Trie();
  65 
  66     static {
  67         initTagReference(m_elementFlags);
  68     }
  69     static void initTagReference(Trie m_elementFlags) {
  70 
  71         // HTML 4.0 loose DTD
  72         m_elementFlags.put(&quot;BASEFONT&quot;, new ElemDesc(0 | ElemDesc.EMPTY));
  73         m_elementFlags.put(
  74             &quot;FRAME&quot;,
  75             new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
  76         m_elementFlags.put(&quot;FRAMESET&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
  77         m_elementFlags.put(&quot;NOFRAMES&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
  78         m_elementFlags.put(
  79             &quot;ISINDEX&quot;,
  80             new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
  81         m_elementFlags.put(
  82             &quot;APPLET&quot;,
  83             new ElemDesc(0 | ElemDesc.WHITESPACESENSITIVE));
  84         m_elementFlags.put(&quot;CENTER&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
  85         m_elementFlags.put(&quot;DIR&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
  86         m_elementFlags.put(&quot;MENU&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
  87 
  88         // HTML 4.0 strict DTD
  89         m_elementFlags.put(&quot;TT&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
  90         m_elementFlags.put(&quot;I&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
  91         m_elementFlags.put(&quot;B&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
  92         m_elementFlags.put(&quot;BIG&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
  93         m_elementFlags.put(&quot;SMALL&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
  94         m_elementFlags.put(&quot;EM&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
  95         m_elementFlags.put(&quot;STRONG&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
  96         m_elementFlags.put(&quot;DFN&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
  97         m_elementFlags.put(&quot;CODE&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
  98         m_elementFlags.put(&quot;SAMP&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
  99         m_elementFlags.put(&quot;KBD&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
 100         m_elementFlags.put(&quot;VAR&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
 101         m_elementFlags.put(&quot;CITE&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
 102         m_elementFlags.put(&quot;ABBR&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
 103         m_elementFlags.put(&quot;ACRONYM&quot;, new ElemDesc(0 | ElemDesc.PHRASE));
 104         m_elementFlags.put(
 105             &quot;SUP&quot;,
 106             new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
 107         m_elementFlags.put(
 108             &quot;SUB&quot;,
 109             new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
 110         m_elementFlags.put(
 111             &quot;SPAN&quot;,
 112             new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
 113         m_elementFlags.put(
 114             &quot;BDO&quot;,
 115             new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
 116         m_elementFlags.put(
 117             &quot;BR&quot;,
 118             new ElemDesc(
 119                 0
 120                     | ElemDesc.SPECIAL
 121                     | ElemDesc.ASPECIAL
 122                     | ElemDesc.EMPTY
 123                     | ElemDesc.BLOCK));
 124         m_elementFlags.put(&quot;BODY&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 125         m_elementFlags.put(
 126             &quot;ADDRESS&quot;,
 127             new ElemDesc(
 128                 0
 129                     | ElemDesc.BLOCK
 130                     | ElemDesc.BLOCKFORM
 131                     | ElemDesc.BLOCKFORMFIELDSET));
 132         m_elementFlags.put(
 133             &quot;DIV&quot;,
 134             new ElemDesc(
 135                 0
 136                     | ElemDesc.BLOCK
 137                     | ElemDesc.BLOCKFORM
 138                     | ElemDesc.BLOCKFORMFIELDSET));
 139         m_elementFlags.put(&quot;A&quot;, new ElemDesc(0 | ElemDesc.SPECIAL));
 140         m_elementFlags.put(
 141             &quot;MAP&quot;,
 142             new ElemDesc(
 143                 0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL | ElemDesc.BLOCK));
 144         m_elementFlags.put(
 145             &quot;AREA&quot;,
 146             new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
 147         m_elementFlags.put(
 148             &quot;LINK&quot;,
 149             new ElemDesc(
 150                 0 | ElemDesc.HEADMISC | ElemDesc.EMPTY | ElemDesc.BLOCK));
 151         m_elementFlags.put(
 152             &quot;IMG&quot;,
 153             new ElemDesc(
 154                 0
 155                     | ElemDesc.SPECIAL
 156                     | ElemDesc.ASPECIAL
 157                     | ElemDesc.EMPTY
 158                     | ElemDesc.WHITESPACESENSITIVE));
 159         m_elementFlags.put(
 160             &quot;OBJECT&quot;,
 161             new ElemDesc(
 162                 0
 163                     | ElemDesc.SPECIAL
 164                     | ElemDesc.ASPECIAL
 165                     | ElemDesc.HEADMISC
 166                     | ElemDesc.WHITESPACESENSITIVE));
 167         m_elementFlags.put(&quot;PARAM&quot;, new ElemDesc(0 | ElemDesc.EMPTY));
 168         m_elementFlags.put(
 169             &quot;HR&quot;,
 170             new ElemDesc(
 171                 0
 172                     | ElemDesc.BLOCK
 173                     | ElemDesc.BLOCKFORM
 174                     | ElemDesc.BLOCKFORMFIELDSET
 175                     | ElemDesc.EMPTY));
 176         m_elementFlags.put(
 177             &quot;P&quot;,
 178             new ElemDesc(
 179                 0
 180                     | ElemDesc.BLOCK
 181                     | ElemDesc.BLOCKFORM
 182                     | ElemDesc.BLOCKFORMFIELDSET));
 183         m_elementFlags.put(
 184             &quot;H1&quot;,
 185             new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
 186         m_elementFlags.put(
 187             &quot;H2&quot;,
 188             new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
 189         m_elementFlags.put(
 190             &quot;H3&quot;,
 191             new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
 192         m_elementFlags.put(
 193             &quot;H4&quot;,
 194             new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
 195         m_elementFlags.put(
 196             &quot;H5&quot;,
 197             new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
 198         m_elementFlags.put(
 199             &quot;H6&quot;,
 200             new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
 201         m_elementFlags.put(
 202             &quot;PRE&quot;,
 203             new ElemDesc(0 | ElemDesc.PREFORMATTED | ElemDesc.BLOCK));
 204         m_elementFlags.put(
 205             &quot;Q&quot;,
 206             new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
 207         m_elementFlags.put(
 208             &quot;BLOCKQUOTE&quot;,
 209             new ElemDesc(
 210                 0
 211                     | ElemDesc.BLOCK
 212                     | ElemDesc.BLOCKFORM
 213                     | ElemDesc.BLOCKFORMFIELDSET));
 214         m_elementFlags.put(&quot;INS&quot;, new ElemDesc(0));
 215         m_elementFlags.put(&quot;DEL&quot;, new ElemDesc(0));
 216         m_elementFlags.put(
 217             &quot;DL&quot;,
 218             new ElemDesc(
 219                 0
 220                     | ElemDesc.BLOCK
 221                     | ElemDesc.BLOCKFORM
 222                     | ElemDesc.BLOCKFORMFIELDSET));
 223         m_elementFlags.put(&quot;DT&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 224         m_elementFlags.put(&quot;DD&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 225         m_elementFlags.put(
 226             &quot;OL&quot;,
 227             new ElemDesc(0 | ElemDesc.LIST | ElemDesc.BLOCK));
 228         m_elementFlags.put(
 229             &quot;UL&quot;,
 230             new ElemDesc(0 | ElemDesc.LIST | ElemDesc.BLOCK));
 231         m_elementFlags.put(&quot;LI&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 232         m_elementFlags.put(&quot;FORM&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 233         m_elementFlags.put(&quot;LABEL&quot;, new ElemDesc(0 | ElemDesc.FORMCTRL));
 234         m_elementFlags.put(
 235             &quot;INPUT&quot;,
 236             new ElemDesc(
 237                 0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL | ElemDesc.EMPTY));
 238         m_elementFlags.put(
 239             &quot;SELECT&quot;,
 240             new ElemDesc(0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL));
 241         m_elementFlags.put(&quot;OPTGROUP&quot;, new ElemDesc(0));
 242         m_elementFlags.put(&quot;OPTION&quot;, new ElemDesc(0));
 243         m_elementFlags.put(
 244             &quot;TEXTAREA&quot;,
 245             new ElemDesc(0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL));
 246         m_elementFlags.put(
 247             &quot;FIELDSET&quot;,
 248             new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM));
 249         m_elementFlags.put(&quot;LEGEND&quot;, new ElemDesc(0));
 250         m_elementFlags.put(
 251             &quot;BUTTON&quot;,
 252             new ElemDesc(0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL));
 253         m_elementFlags.put(
 254             &quot;TABLE&quot;,
 255             new ElemDesc(
 256                 0
 257                     | ElemDesc.BLOCK
 258                     | ElemDesc.BLOCKFORM
 259                     | ElemDesc.BLOCKFORMFIELDSET));
 260         m_elementFlags.put(&quot;CAPTION&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 261         m_elementFlags.put(&quot;THEAD&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 262         m_elementFlags.put(&quot;TFOOT&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 263         m_elementFlags.put(&quot;TBODY&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 264         m_elementFlags.put(&quot;COLGROUP&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 265         m_elementFlags.put(
 266             &quot;COL&quot;,
 267             new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
 268         m_elementFlags.put(&quot;TR&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 269         m_elementFlags.put(&quot;TH&quot;, new ElemDesc(0));
 270         m_elementFlags.put(&quot;TD&quot;, new ElemDesc(0));
 271         m_elementFlags.put(
 272             &quot;HEAD&quot;,
 273             new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.HEADELEM));
 274         m_elementFlags.put(&quot;TITLE&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 275         m_elementFlags.put(
 276             &quot;BASE&quot;,
 277             new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
 278         m_elementFlags.put(
 279             &quot;META&quot;,
 280             new ElemDesc(
 281                 0 | ElemDesc.HEADMISC | ElemDesc.EMPTY | ElemDesc.BLOCK));
 282         m_elementFlags.put(
 283             &quot;STYLE&quot;,
 284             new ElemDesc(
 285                 0 | ElemDesc.HEADMISC | ElemDesc.RAW | ElemDesc.BLOCK));
 286         m_elementFlags.put(
 287             &quot;SCRIPT&quot;,
 288             new ElemDesc(
 289                 0
 290                     | ElemDesc.SPECIAL
 291                     | ElemDesc.ASPECIAL
 292                     | ElemDesc.HEADMISC
 293                     | ElemDesc.RAW));
 294         m_elementFlags.put(
 295             &quot;NOSCRIPT&quot;,
 296             new ElemDesc(
 297                 0
 298                     | ElemDesc.BLOCK
 299                     | ElemDesc.BLOCKFORM
 300                     | ElemDesc.BLOCKFORMFIELDSET));
 301         m_elementFlags.put(&quot;HTML&quot;, new ElemDesc(0 | ElemDesc.BLOCK));
 302 
 303         // From &quot;John Ky&quot; &lt;hand@syd.speednet.com.au
 304         // Transitional Document Type Definition ()
 305         // file:///C:/Documents%20and%20Settings/sboag.BOAG600E/My%20Documents/html/sgml/loosedtd.html#basefont
 306         m_elementFlags.put(&quot;FONT&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
 307 
 308         // file:///C:/Documents%20and%20Settings/sboag.BOAG600E/My%20Documents/html/present/graphics.html#edef-STRIKE
 309         m_elementFlags.put(&quot;S&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
 310         m_elementFlags.put(&quot;STRIKE&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
 311 
 312         // file:///C:/Documents%20and%20Settings/sboag.BOAG600E/My%20Documents/html/present/graphics.html#edef-U
 313         m_elementFlags.put(&quot;U&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
 314 
 315         // From &quot;John Ky&quot; &lt;hand@syd.speednet.com.au
 316         m_elementFlags.put(&quot;NOBR&quot;, new ElemDesc(0 | ElemDesc.FONTSTYLE));
 317 
 318         // HTML 4.0, section 16.5
 319         m_elementFlags.put(
 320             &quot;IFRAME&quot;,
 321             new ElemDesc(
 322                 0
 323                     | ElemDesc.BLOCK
 324                     | ElemDesc.BLOCKFORM
 325                     | ElemDesc.BLOCKFORMFIELDSET));
 326 
 327         // Netscape 4 extension
 328         m_elementFlags.put(
 329             &quot;LAYER&quot;,
 330             new ElemDesc(
 331                 0
 332                     | ElemDesc.BLOCK
 333                     | ElemDesc.BLOCKFORM
 334                     | ElemDesc.BLOCKFORMFIELDSET));
 335         // Netscape 4 extension
 336         m_elementFlags.put(
 337             &quot;ILAYER&quot;,
 338             new ElemDesc(
 339                 0
 340                     | ElemDesc.BLOCK
 341                     | ElemDesc.BLOCKFORM
 342                     | ElemDesc.BLOCKFORMFIELDSET));
 343 
 344 
 345         // NOW FOR ATTRIBUTE INFORMATION . . .
 346         ElemDesc elemDesc;
 347 
 348 
 349         // ----------------------------------------------
 350         elemDesc = (ElemDesc) m_elementFlags.get(&quot;a&quot;);
 351         elemDesc.setAttr(&quot;HREF&quot;, ElemDesc.ATTRURL);
 352         elemDesc.setAttr(&quot;NAME&quot;, ElemDesc.ATTRURL);
 353 
 354         // ----------------------------------------------
 355         elemDesc = (ElemDesc) m_elementFlags.get(&quot;area&quot;);
 356         elemDesc.setAttr(&quot;HREF&quot;, ElemDesc.ATTRURL);
 357         elemDesc.setAttr(&quot;NOHREF&quot;, ElemDesc.ATTREMPTY);
 358 
 359         // ----------------------------------------------
 360         elemDesc = (ElemDesc) m_elementFlags.get(&quot;base&quot;);
 361         elemDesc.setAttr(&quot;HREF&quot;, ElemDesc.ATTRURL);
 362 
 363         // ----------------------------------------------
 364         elemDesc = (ElemDesc) m_elementFlags.get(&quot;button&quot;);
 365         elemDesc.setAttr(&quot;DISABLED&quot;, ElemDesc.ATTREMPTY);
 366 
 367         // ----------------------------------------------
 368         elemDesc = (ElemDesc) m_elementFlags.get(&quot;blockquote&quot;);
 369         elemDesc.setAttr(&quot;CITE&quot;, ElemDesc.ATTRURL);
 370 
 371         // ----------------------------------------------
 372         elemDesc = (ElemDesc) m_elementFlags.get(&quot;del&quot;);
 373         elemDesc.setAttr(&quot;CITE&quot;, ElemDesc.ATTRURL);
 374 
 375         // ----------------------------------------------
 376         elemDesc = (ElemDesc) m_elementFlags.get(&quot;dir&quot;);
 377         elemDesc.setAttr(&quot;COMPACT&quot;, ElemDesc.ATTREMPTY);
 378 
 379         // ----------------------------------------------
 380 
 381         elemDesc = (ElemDesc) m_elementFlags.get(&quot;div&quot;);
 382         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL); // Netscape 4 extension
 383         elemDesc.setAttr(&quot;NOWRAP&quot;, ElemDesc.ATTREMPTY); // Internet-Explorer extension
 384 
 385         // ----------------------------------------------
 386         elemDesc = (ElemDesc) m_elementFlags.get(&quot;dl&quot;);
 387         elemDesc.setAttr(&quot;COMPACT&quot;, ElemDesc.ATTREMPTY);
 388 
 389         // ----------------------------------------------
 390         elemDesc = (ElemDesc) m_elementFlags.get(&quot;form&quot;);
 391         elemDesc.setAttr(&quot;ACTION&quot;, ElemDesc.ATTRURL);
 392 
 393         // ----------------------------------------------
 394         // Attribution to: &quot;Voytenko, Dimitry&quot; &lt;DVoytenko@SECTORBASE.COM&gt;
 395         elemDesc = (ElemDesc) m_elementFlags.get(&quot;frame&quot;);
 396         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL);
 397         elemDesc.setAttr(&quot;LONGDESC&quot;, ElemDesc.ATTRURL);
 398         elemDesc.setAttr(&quot;NORESIZE&quot;,ElemDesc.ATTREMPTY);
 399 
 400         // ----------------------------------------------
 401         elemDesc = (ElemDesc) m_elementFlags.get(&quot;head&quot;);
 402         elemDesc.setAttr(&quot;PROFILE&quot;, ElemDesc.ATTRURL);
 403 
 404         // ----------------------------------------------
 405         elemDesc = (ElemDesc) m_elementFlags.get(&quot;hr&quot;);
 406         elemDesc.setAttr(&quot;NOSHADE&quot;, ElemDesc.ATTREMPTY);
 407 
 408         // ----------------------------------------------
 409         // HTML 4.0, section 16.5
 410         elemDesc = (ElemDesc) m_elementFlags.get(&quot;iframe&quot;);
 411         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL);
 412         elemDesc.setAttr(&quot;LONGDESC&quot;, ElemDesc.ATTRURL);
 413 
 414         // ----------------------------------------------
 415         // Netscape 4 extension
 416         elemDesc = (ElemDesc) m_elementFlags.get(&quot;ilayer&quot;);
 417         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL);
 418 
 419         // ----------------------------------------------
 420         elemDesc = (ElemDesc) m_elementFlags.get(&quot;img&quot;);
 421         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL);
 422         elemDesc.setAttr(&quot;LONGDESC&quot;, ElemDesc.ATTRURL);
 423         elemDesc.setAttr(&quot;USEMAP&quot;, ElemDesc.ATTRURL);
 424         elemDesc.setAttr(&quot;ISMAP&quot;, ElemDesc.ATTREMPTY);
 425 
 426         // ----------------------------------------------
 427         elemDesc = (ElemDesc) m_elementFlags.get(&quot;input&quot;);
 428         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL);
 429         elemDesc.setAttr(&quot;USEMAP&quot;, ElemDesc.ATTRURL);
 430         elemDesc.setAttr(&quot;CHECKED&quot;, ElemDesc.ATTREMPTY);
 431         elemDesc.setAttr(&quot;DISABLED&quot;, ElemDesc.ATTREMPTY);
 432         elemDesc.setAttr(&quot;ISMAP&quot;, ElemDesc.ATTREMPTY);
 433         elemDesc.setAttr(&quot;READONLY&quot;, ElemDesc.ATTREMPTY);
 434 
 435         // ----------------------------------------------
 436         elemDesc = (ElemDesc) m_elementFlags.get(&quot;ins&quot;);
 437         elemDesc.setAttr(&quot;CITE&quot;, ElemDesc.ATTRURL);
 438 
 439         // ----------------------------------------------
 440         // Netscape 4 extension
 441         elemDesc = (ElemDesc) m_elementFlags.get(&quot;layer&quot;);
 442         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL);
 443 
 444         // ----------------------------------------------
 445         elemDesc = (ElemDesc) m_elementFlags.get(&quot;link&quot;);
 446         elemDesc.setAttr(&quot;HREF&quot;, ElemDesc.ATTRURL);
 447 
 448         // ----------------------------------------------
 449         elemDesc = (ElemDesc) m_elementFlags.get(&quot;menu&quot;);
 450         elemDesc.setAttr(&quot;COMPACT&quot;, ElemDesc.ATTREMPTY);
 451 
 452         // ----------------------------------------------
 453         elemDesc = (ElemDesc) m_elementFlags.get(&quot;object&quot;);
 454         elemDesc.setAttr(&quot;CLASSID&quot;, ElemDesc.ATTRURL);
 455         elemDesc.setAttr(&quot;CODEBASE&quot;, ElemDesc.ATTRURL);
 456         elemDesc.setAttr(&quot;DATA&quot;, ElemDesc.ATTRURL);
 457         elemDesc.setAttr(&quot;ARCHIVE&quot;, ElemDesc.ATTRURL);
 458         elemDesc.setAttr(&quot;USEMAP&quot;, ElemDesc.ATTRURL);
 459         elemDesc.setAttr(&quot;DECLARE&quot;, ElemDesc.ATTREMPTY);
 460 
 461         // ----------------------------------------------
 462         elemDesc = (ElemDesc) m_elementFlags.get(&quot;ol&quot;);
 463         elemDesc.setAttr(&quot;COMPACT&quot;, ElemDesc.ATTREMPTY);
 464 
 465         // ----------------------------------------------
 466         elemDesc = (ElemDesc) m_elementFlags.get(&quot;optgroup&quot;);
 467         elemDesc.setAttr(&quot;DISABLED&quot;, ElemDesc.ATTREMPTY);
 468 
 469         // ----------------------------------------------
 470         elemDesc = (ElemDesc) m_elementFlags.get(&quot;option&quot;);
 471         elemDesc.setAttr(&quot;SELECTED&quot;, ElemDesc.ATTREMPTY);
 472         elemDesc.setAttr(&quot;DISABLED&quot;, ElemDesc.ATTREMPTY);
 473 
 474         // ----------------------------------------------
 475         elemDesc = (ElemDesc) m_elementFlags.get(&quot;q&quot;);
 476         elemDesc.setAttr(&quot;CITE&quot;, ElemDesc.ATTRURL);
 477 
 478         // ----------------------------------------------
 479         elemDesc = (ElemDesc) m_elementFlags.get(&quot;script&quot;);
 480         elemDesc.setAttr(&quot;SRC&quot;, ElemDesc.ATTRURL);
 481         elemDesc.setAttr(&quot;FOR&quot;, ElemDesc.ATTRURL);
 482         elemDesc.setAttr(&quot;DEFER&quot;, ElemDesc.ATTREMPTY);
 483 
 484         // ----------------------------------------------
 485         elemDesc = (ElemDesc) m_elementFlags.get(&quot;select&quot;);
 486         elemDesc.setAttr(&quot;DISABLED&quot;, ElemDesc.ATTREMPTY);
 487         elemDesc.setAttr(&quot;MULTIPLE&quot;, ElemDesc.ATTREMPTY);
 488 
 489         // ----------------------------------------------
 490         elemDesc = (ElemDesc) m_elementFlags.get(&quot;table&quot;);
 491         elemDesc.setAttr(&quot;NOWRAP&quot;, ElemDesc.ATTREMPTY); // Internet-Explorer extension
 492 
 493         // ----------------------------------------------
 494         elemDesc = (ElemDesc) m_elementFlags.get(&quot;td&quot;);
 495         elemDesc.setAttr(&quot;NOWRAP&quot;, ElemDesc.ATTREMPTY);
 496 
 497         // ----------------------------------------------
 498         elemDesc = (ElemDesc) m_elementFlags.get(&quot;textarea&quot;);
 499         elemDesc.setAttr(&quot;DISABLED&quot;, ElemDesc.ATTREMPTY);
 500         elemDesc.setAttr(&quot;READONLY&quot;, ElemDesc.ATTREMPTY);
 501 
 502         // ----------------------------------------------
 503         elemDesc = (ElemDesc) m_elementFlags.get(&quot;th&quot;);
 504         elemDesc.setAttr(&quot;NOWRAP&quot;, ElemDesc.ATTREMPTY);
 505 
 506         // ----------------------------------------------
 507         // The nowrap attribute of a tr element is both
 508         // a Netscape and Internet-Explorer extension
 509         elemDesc = (ElemDesc) m_elementFlags.get(&quot;tr&quot;);
 510         elemDesc.setAttr(&quot;NOWRAP&quot;, ElemDesc.ATTREMPTY);
 511 
 512         // ----------------------------------------------
 513         elemDesc = (ElemDesc) m_elementFlags.get(&quot;ul&quot;);
 514         elemDesc.setAttr(&quot;COMPACT&quot;, ElemDesc.ATTREMPTY);
 515     }
 516 
 517     /**
 518      * Dummy element for elements not found.
 519      */
 520     static private final ElemDesc m_dummy = new ElemDesc(0 | ElemDesc.BLOCK);
 521 
 522     /** True if URLs should be specially escaped with the %xx form. */
 523     private boolean m_specialEscapeURLs = true;
 524 
 525     /** True if the META tag should be omitted. */
 526     private boolean m_omitMetaTag = false;
 527 
 528     /**
 529      * Tells if the formatter should use special URL escaping.
 530      *
 531      * @param bool True if URLs should be specially escaped with the %xx form.
 532      */
 533     public void setSpecialEscapeURLs(boolean bool)
 534     {
 535         m_specialEscapeURLs = bool;
 536     }
 537 
 538     /**
 539      * Tells if the formatter should omit the META tag.
 540      *
 541      * @param bool True if the META tag should be omitted.
 542      */
 543     public void setOmitMetaTag(boolean bool)
 544     {
 545         m_omitMetaTag = bool;
 546     }
 547 
 548     /**
 549      * Specifies an output format for this serializer. It the
 550      * serializer has already been associated with an output format,
 551      * it will switch to the new format. This method should not be
 552      * called while the serializer is in the process of serializing
 553      * a document.
 554      *
 555      * This method can be called multiple times before starting
 556      * the serialization of a particular result-tree. In principle
 557      * all serialization parameters can be changed, with the exception
 558      * of method=&quot;html&quot; (it must be method=&quot;html&quot; otherwise we
 559      * shouldn&#39;t even have a ToHTMLStream object here!)
 560      *
 561      * @param format The output format or serialzation parameters
 562      * to use.
 563      */
 564     public void setOutputFormat(Properties format)
 565     {
 566 
 567         m_specialEscapeURLs =
 568             OutputPropertyUtils.getBooleanProperty(
 569                 OutputPropertiesFactory.S_USE_URL_ESCAPING,
 570                 format);
 571 
 572         m_omitMetaTag =
 573             OutputPropertyUtils.getBooleanProperty(
 574                 OutputPropertiesFactory.S_OMIT_META_TAG,
 575                 format);
 576 
 577         super.setOutputFormat(format);
 578     }
 579 
 580     /**
 581      * Tells if the formatter should use special URL escaping.
 582      *
 583      * @return True if URLs should be specially escaped with the %xx form.
 584      */
 585     private final boolean getSpecialEscapeURLs()
 586     {
 587         return m_specialEscapeURLs;
 588     }
 589 
 590     /**
 591      * Tells if the formatter should omit the META tag.
 592      *
 593      * @return True if the META tag should be omitted.
 594      */
 595     private final boolean getOmitMetaTag()
 596     {
 597         return m_omitMetaTag;
 598     }
 599 
 600     /**
 601      * Get a description of the given element.
 602      *
 603      * @param name non-null name of element, case insensitive.
 604      *
 605      * @return non-null reference to ElemDesc, which may be m_dummy if no
 606      *         element description matches the given name.
 607      */
 608     public static final ElemDesc getElemDesc(String name)
 609     {
 610         /* this method used to return m_dummy  when name was null
 611          * but now it doesn&#39;t check and and requires non-null name.
 612          */
 613         Object obj = m_elementFlags.get(name);
 614         if (null != obj)
 615             return (ElemDesc)obj;
 616         return m_dummy;
 617     }
 618 
 619     /**
 620      * A Trie that is just a copy of the &quot;static&quot; one.
 621      * We need this one to be able to use the faster, but not thread-safe
 622      * method Trie.get2(name)
 623      */
 624     private Trie m_htmlInfo = new Trie(m_elementFlags);
 625     /**
 626      * Calls to this method could be replaced with calls to
 627      * getElemDesc(name), but this one should be faster.
 628      */
 629     private ElemDesc getElemDesc2(String name)
 630     {
 631         Object obj = m_htmlInfo.get2(name);
 632         if (null != obj)
 633             return (ElemDesc)obj;
 634         return m_dummy;
 635     }
 636 
 637     /**
 638      * Default constructor.
 639      */
 640     public ToHTMLStream()
 641     {
 642         this(null);
 643     }
 644 
 645     public ToHTMLStream(ErrorListener l)
 646     {
 647         super(l);
 648         m_charInfo = m_htmlcharInfo;
 649         // initialize namespaces
 650         m_prefixMap = new NamespaceMappings();
 651     }
 652 
 653     /** The name of the current element. */
 654 //    private String m_currentElementName = null;
 655 
 656     /**
 657      * Receive notification of the beginning of a document.
 658      *
 659      * @throws org.xml.sax.SAXException Any SAX exception, possibly
 660      *            wrapping another exception.
 661      *
 662      * @throws org.xml.sax.SAXException
 663      */
 664     protected void startDocumentInternal() throws org.xml.sax.SAXException
 665     {
 666         super.startDocumentInternal();
 667 
 668         m_needToCallStartDocument = false;
 669         m_needToOutputDocTypeDecl = true;
 670         m_startNewLine = false;
 671         setOmitXMLDeclaration(true);
 672 
 673         if (true == m_needToOutputDocTypeDecl)
 674         {
 675             String doctypeSystem = getDoctypeSystem();
 676             String doctypePublic = getDoctypePublic();
 677             if ((null != doctypeSystem) || (null != doctypePublic))
 678             {
 679                 final java.io.Writer writer = m_writer;
 680                 try
 681                 {
 682                 writer.write(&quot;&lt;!DOCTYPE html&quot;);
 683 
 684                 if (null != doctypePublic)
 685                 {
 686                     writer.write(&quot; PUBLIC \&quot;&quot;);
 687                     writer.write(doctypePublic);
 688                     writer.write(&#39;&quot;&#39;);
 689                 }
 690 
 691                 if (null != doctypeSystem)
 692                 {
 693                     if (null == doctypePublic)
 694                         writer.write(&quot; SYSTEM \&quot;&quot;);
 695                     else
 696                         writer.write(&quot; \&quot;&quot;);
 697 
 698                     writer.write(doctypeSystem);
 699                     writer.write(&#39;&quot;&#39;);
 700                 }
 701 
 702                 writer.write(&#39;&gt;&#39;);
 703                 outputLineSep();
 704                 }
 705                 catch(IOException e)
 706                 {
 707                     throw new SAXException(e);
 708                 }
 709             }
 710         }
 711 
 712         m_needToOutputDocTypeDecl = false;
 713     }
 714 
 715     /**
 716      * Receive notification of the end of a document.
 717      *
 718      * @throws org.xml.sax.SAXException Any SAX exception, possibly
 719      *            wrapping another exception.
 720      *
 721      * @throws org.xml.sax.SAXException
 722      */
 723     public final void endDocument() throws org.xml.sax.SAXException
 724     {
 725         if (m_doIndent) {
 726             flushCharactersBuffer(false);
 727         }
 728         flushPending();
 729         if (m_doIndent &amp;&amp; !m_isprevtext)
 730         {
 731             try
 732             {
 733             outputLineSep();
 734             }
 735             catch(IOException e)
 736             {
 737                 throw new SAXException(e);
 738             }
 739         }
 740 
 741         flushWriter();
 742         if (m_tracer != null)
 743             super.fireEndDoc();
 744     }
 745 
 746     /**
 747      * If the previous is an inline element, won&#39;t insert a new line before the
 748      * text.
 749      *
 750      */
 751     protected boolean shouldIndentForText() {
 752         return super.shouldIndentForText() &amp;&amp; m_isprevblock;
 753     }
 754 
 755     /**
 756      * Only check m_doIndent, disregard m_ispreserveSpace.
 757      *
 758      * @return True if the content should be formatted.
 759      */
 760     protected boolean shouldFormatOutput() {
 761         return m_doIndent;
 762     }
 763 
 764     /**
 765      * Receive notification of the beginning of an element.
 766      *
 767      *
 768      * @param namespaceURI
 769      * @param localName
 770      * @param name
 771      *            The element type name.
 772      * @param atts
 773      *            The attributes attached to the element, if any.
 774      * @throws org.xml.sax.SAXException
 775      *             Any SAX exception, possibly wrapping another exception.
 776      * @see #endElement
 777      * @see org.xml.sax.AttributeList
 778      */
 779     public void startElement(
 780         String namespaceURI,
 781         String localName,
 782         String name,
 783         Attributes atts)
 784         throws SAXException
 785     {
 786         if (m_doIndent) {
 787             // will add extra one if having namespace but no matter
 788             m_childNodeNum++;
 789             flushCharactersBuffer(false);
 790         }
 791         ElemContext elemContext = m_elemContext;
 792 
 793         // clean up any pending things first
 794         if (elemContext.m_startTagOpen)
 795         {
 796             closeStartTag();
 797             elemContext.m_startTagOpen = false;
 798         }
 799         else if (m_cdataTagOpen)
 800         {
 801             closeCDATA();
 802             m_cdataTagOpen = false;
 803         }
 804         else if (m_needToCallStartDocument)
 805         {
 806             startDocumentInternal();
 807             m_needToCallStartDocument = false;
 808         }
 809 
 810 
 811         // if this element has a namespace then treat it like XML
 812         if (null != namespaceURI &amp;&amp; namespaceURI.length() &gt; 0)
 813         {
 814             super.startElement(namespaceURI, localName, name, atts);
 815 
 816             return;
 817         }
 818 
 819         try
 820         {
 821             // getElemDesc2(name) is faster than getElemDesc(name)
 822             ElemDesc elemDesc = getElemDesc2(name);
 823             int elemFlags = elemDesc.getFlags();
 824 
 825             // deal with indentation issues first
 826             if (m_doIndent)
 827             {
 828                 boolean isBlockElement = (elemFlags &amp; ElemDesc.BLOCK) != 0;
 829                 if ((elemContext.m_elementName != null)
 830                         // If this element is a block element,
 831                         // or if this is not a block element, then if the
 832                         // previous is neither a text nor an inline
 833                         &amp;&amp; (isBlockElement || (!(m_isprevtext || !m_isprevblock))))
 834                 {
 835                     m_startNewLine = true;
 836 
 837                     indent();
 838                 }
 839                 m_isprevblock = isBlockElement;
 840             }
 841 
 842             // save any attributes for later processing
 843             if (atts != null)
 844                 addAttributes(atts);
 845 
 846             m_isprevtext = false;
 847             final java.io.Writer writer = m_writer;
 848             writer.write(&#39;&lt;&#39;);
 849             writer.write(name);
 850 
 851             if (m_doIndent) {
 852                 m_childNodeNumStack.add(m_childNodeNum);
 853                 m_childNodeNum = 0;
 854             }
 855 
 856             if (m_tracer != null)
 857                 firePseudoAttributes();
 858 
 859             if ((elemFlags &amp; ElemDesc.EMPTY) != 0)
 860             {
 861                 // an optimization for elements which are expected
 862                 // to be empty.
 863                 m_elemContext = elemContext.push();
 864                 /* XSLTC sometimes calls namespaceAfterStartElement()
 865                  * so we need to remember the name
 866                  */
 867                 m_elemContext.m_elementName = name;
 868                 m_elemContext.m_elementDesc = elemDesc;
 869                 return;
 870             }
 871             else
 872             {
 873                 elemContext = elemContext.push(namespaceURI,localName,name);
 874                 m_elemContext = elemContext;
 875                 elemContext.m_elementDesc = elemDesc;
 876                 elemContext.m_isRaw = (elemFlags &amp; ElemDesc.RAW) != 0;
 877 
 878                 // set m_startNewLine for the next element
 879                 if (m_doIndent) {
 880                     // elemFlags is equivalent to m_elemContext.m_elementDesc.getFlags(),
 881                     // in this branch m_elemContext.m_elementName is not null
 882                     boolean isBlockElement = (elemFlags &amp; ElemDesc.BLOCK) != 0;
 883                     if (isBlockElement)
 884                         m_startNewLine = true;
 885                 }
 886             }
 887 
 888 
 889             if ((elemFlags &amp; ElemDesc.HEADELEM) != 0)
 890             {
 891                 // This is the &lt;HEAD&gt; element, do some special processing
 892                 closeStartTag();
 893                 elemContext.m_startTagOpen = false;
 894                 if (!m_omitMetaTag)
 895                 {
 896                     if (m_doIndent)
 897                         indent();
 898                     writer.write(
 899                         &quot;&lt;META http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=&quot;);
 900                     String encoding = getEncoding();
 901                     String encode = Encodings.getMimeEncoding(encoding);
 902                     writer.write(encode);
 903                     writer.write(&quot;\&quot;&gt;&quot;);
 904                 }
 905             }
 906         }
 907         catch (IOException e)
 908         {
 909             throw new SAXException(e);
 910         }
 911     }
 912 
 913     /**
 914      *  Receive notification of the end of an element.
 915      *
 916      *
 917      *  @param namespaceURI
 918      *  @param localName
 919      *  @param name The element type name
 920      *  @throws org.xml.sax.SAXException Any SAX exception, possibly
 921      *             wrapping another exception.
 922      */
 923     public final void endElement(
 924         final String namespaceURI,
 925         final String localName,
 926         final String name)
 927         throws org.xml.sax.SAXException
 928     {
 929         if (m_doIndent) {
 930             flushCharactersBuffer(false);
 931         }
 932         // deal with any pending issues
 933         if (m_cdataTagOpen)
 934             closeCDATA();
 935 
 936         // if the element has a namespace, treat it like XML, not HTML
 937         if (null != namespaceURI &amp;&amp; namespaceURI.length() &gt; 0)
 938         {
 939             super.endElement(namespaceURI, localName, name);
 940 
 941             return;
 942         }
 943 
 944         try
 945         {
 946 
 947             ElemContext elemContext = m_elemContext;
 948             final ElemDesc elemDesc = elemContext.m_elementDesc;
 949             final int elemFlags = elemDesc.getFlags();
 950             final boolean elemEmpty = (elemFlags &amp; ElemDesc.EMPTY) != 0;
 951 
 952             // deal with any indentation issues
 953             if (m_doIndent)
 954             {
 955                 final boolean isBlockElement = (elemFlags&amp;ElemDesc.BLOCK) != 0;
 956                 boolean shouldIndent = false;
 957 
 958                 // If this element is a block element,
 959                 // or if this is not a block element, then if the previous is
 960                 // neither a text nor an inline
 961                 if (isBlockElement || (!(m_isprevtext || !m_isprevblock)))
 962                 {
 963                     m_startNewLine = true;
 964                     shouldIndent = true;
 965                 }
 966                 if (!elemContext.m_startTagOpen &amp;&amp; shouldIndent &amp;&amp; (m_childNodeNum &gt; 1 || !m_isprevtext))
 967                     indent(elemContext.m_currentElemDepth - 1);
 968 
 969                 m_isprevblock = isBlockElement;
 970             }
 971 
 972             final java.io.Writer writer = m_writer;
 973             if (!elemContext.m_startTagOpen)
 974             {
 975                 writer.write(&quot;&lt;/&quot;);
 976                 writer.write(name);
 977                 writer.write(&#39;&gt;&#39;);
 978             }
 979             else
 980             {
 981                 // the start-tag open when this method was called,
 982                 // so we need to process it now.
 983 
 984                 if (m_tracer != null)
 985                     super.fireStartElem(name);
 986 
 987                 // the starting tag was still open when we received this endElement() call
 988                 // so we need to process any gathered attributes NOW, before they go away.
 989                 int nAttrs = m_attributes.getLength();
 990                 if (nAttrs &gt; 0)
 991                 {
 992                     processAttributes(m_writer, nAttrs);
 993                     // clear attributes object for re-use with next element
 994                     m_attributes.clear();
 995                 }
 996                 if (!elemEmpty)
 997                 {
 998                     // As per Dave/Paul recommendation 12/06/2000
 999                     // if (shouldIndent)
1000                     // writer.write(&#39;&gt;&#39;);
1001                     //  indent(m_currentIndent);
1002 
1003                     writer.write(&quot;&gt;&lt;/&quot;);
1004                     writer.write(name);
1005                     writer.write(&#39;&gt;&#39;);
1006                 }
1007                 else
1008                 {
1009                     writer.write(&#39;&gt;&#39;);
1010                 }
1011             }
1012 
1013             if (m_doIndent) {
1014                 m_childNodeNum = m_childNodeNumStack.remove(m_childNodeNumStack.size() - 1);
1015                 // clean up because the element has ended
1016                 m_isprevtext = false;
1017             }
1018             // fire off the end element event
1019             if (m_tracer != null)
1020                 super.fireEndElem(name);
1021 
1022             // OPTIMIZE-EMPTY
1023             if (elemEmpty)
1024             {
1025                 // a quick exit if the HTML element had no children.
1026                 // This block of code can be removed if the corresponding block of code
1027                 // in startElement() also labeled with &quot;OPTIMIZE-EMPTY&quot; is also removed
1028                 m_elemContext = elemContext.m_prev;
1029                 return;
1030             }
1031 
1032             // some more clean because the element has ended.
1033             m_elemContext = elemContext.m_prev;
1034 //            m_isRawStack.pop();
1035         }
1036         catch (IOException e)
1037         {
1038             throw new SAXException(e);
1039         }
1040     }
1041 
1042     /**
1043      * Process an attribute.
1044      * @param   writer The writer to write the processed output to.
1045      * @param   name   The name of the attribute.
1046      * @param   value   The value of the attribute.
1047      * @param   elemDesc The description of the HTML element
1048      *           that has this attribute.
1049      *
1050      * @throws org.xml.sax.SAXException
1051      */
1052     protected void processAttribute(
1053         java.io.Writer writer,
1054         String name,
1055         String value,
1056         ElemDesc elemDesc)
1057         throws IOException, SAXException
1058     {
1059         writer.write(&#39; &#39;);
1060 
1061         if (   ((value.length() == 0) || value.equalsIgnoreCase(name))
1062             &amp;&amp; elemDesc != null
1063             &amp;&amp; elemDesc.isAttrFlagSet(name, ElemDesc.ATTREMPTY))
1064         {
1065             writer.write(name);
1066         }
1067         else
1068         {
1069             // %REVIEW% %OPT%
1070             // Two calls to single-char write may NOT
1071             // be more efficient than one to string-write...
1072             writer.write(name);
1073             writer.write(&quot;=\&quot;&quot;);
1074             if (   elemDesc != null
1075                 &amp;&amp; elemDesc.isAttrFlagSet(name, ElemDesc.ATTRURL))
1076                 writeAttrURI(writer, value, m_specialEscapeURLs);
1077             else
1078                 writeAttrString(writer, value, this.getEncoding());
1079             writer.write(&#39;&quot;&#39;);
1080 
1081         }
1082     }
1083 
1084     /**
1085      * Tell if a character is an ASCII digit.
1086      */
1087     private boolean isASCIIDigit(char c)
1088     {
1089         return (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;);
1090     }
1091 
1092     /**
1093      * Make an integer into an HH hex value.
1094      * Does no checking on the size of the input, since this
1095      * is only meant to be used locally by writeAttrURI.
1096      *
1097      * @param i must be a value less than 255.
1098      *
1099      * @return should be a two character string.
1100      */
1101     private static String makeHHString(int i)
1102     {
1103         String s = Integer.toHexString(i).toUpperCase();
1104         if (s.length() == 1)
1105         {
1106             s = &quot;0&quot; + s;
1107         }
1108         return s;
1109     }
1110 
1111     /**
1112     * Dmitri Ilyin: Makes sure if the String is HH encoded sign.
1113     * @param str must be 2 characters long
1114     *
1115     * @return true or false
1116     */
1117     private boolean isHHSign(String str)
1118     {
1119         boolean sign = true;
1120         try
1121         {
1122             char r = (char) Integer.parseInt(str, 16);
1123         }
1124         catch (NumberFormatException e)
1125         {
1126             sign = false;
1127         }
1128         return sign;
1129     }
1130 
1131     /**
1132      * Write the specified &lt;var&gt;string&lt;/var&gt; after substituting non ASCII characters,
1133      * with &lt;CODE&gt;%HH&lt;/CODE&gt;, where HH is the hex of the byte value.
1134      *
1135      * @param   string      String to convert to XML format.
1136      * @param doURLEscaping True if we should try to encode as
1137      *                      per http://www.ietf.org/rfc/rfc2396.txt.
1138      *
1139      * @throws org.xml.sax.SAXException if a bad surrogate pair is detected.
1140      */
1141     public void writeAttrURI(
1142         final java.io.Writer writer, String string, boolean doURLEscaping)
1143         throws IOException
1144     {
1145         // http://www.ietf.org/rfc/rfc2396.txt says:
1146         // A URI is always in an &quot;escaped&quot; form, since escaping or unescaping a
1147         // completed URI might change its semantics.  Normally, the only time
1148         // escape encodings can safely be made is when the URI is being created
1149         // from its component parts; each component may have its own set of
1150         // characters that are reserved, so only the mechanism responsible for
1151         // generating or interpreting that component can determine whether or
1152         // not escaping a character will change its semantics. Likewise, a URI
1153         // must be separated into its components before the escaped characters
1154         // within those components can be safely decoded.
1155         //
1156         // ...So we do our best to do limited escaping of the URL, without
1157         // causing damage.  If the URL is already properly escaped, in theory, this
1158         // function should not change the string value.
1159 
1160         final int end = string.length();
1161         if (end &gt; m_attrBuff.length)
1162         {
1163            m_attrBuff = new char[end*2 + 1];
1164         }
1165         string.getChars(0,end, m_attrBuff, 0);
1166         final char[] chars = m_attrBuff;
1167 
1168         int cleanStart = 0;
1169         int cleanLength = 0;
1170 
1171 
1172         char ch = 0;
1173         for (int i = 0; i &lt; end; i++)
1174         {
1175             ch = chars[i];
1176 
1177             if ((ch &lt; 32) || (ch &gt; 126))
1178             {
1179                 if (cleanLength &gt; 0)
1180                 {
1181                     writer.write(chars, cleanStart, cleanLength);
1182                     cleanLength = 0;
1183                 }
1184                 if (doURLEscaping)
1185                 {
1186                     // Encode UTF16 to UTF8.
1187                     // Reference is Unicode, A Primer, by Tony Graham.
1188                     // Page 92.
1189 
1190                     // Note that Kay doesn&#39;t escape 0x20...
1191                     //  if(ch == 0x20) // Not sure about this... -sb
1192                     //  {
1193                     //    writer.write(ch);
1194                     //  }
1195                     //  else
1196                     if (ch &lt;= 0x7F)
1197                     {
1198                         writer.write(&#39;%&#39;);
1199                         writer.write(makeHHString(ch));
1200                     }
1201                     else if (ch &lt;= 0x7FF)
1202                     {
1203                         // Clear low 6 bits before rotate, put high 4 bits in low byte,
1204                         // and set two high bits.
1205                         int high = (ch &gt;&gt; 6) | 0xC0;
1206                         int low = (ch &amp; 0x3F) | 0x80;
1207                         // First 6 bits, + high bit
1208                         writer.write(&#39;%&#39;);
1209                         writer.write(makeHHString(high));
1210                         writer.write(&#39;%&#39;);
1211                         writer.write(makeHHString(low));
1212                     }
1213                     else if (Encodings.isHighUTF16Surrogate(ch)) // high surrogate
1214                     {
1215                         // I&#39;m sure this can be done in 3 instructions, but I choose
1216                         // to try and do it exactly like it is done in the book, at least
1217                         // until we are sure this is totally clean.  I don&#39;t think performance
1218                         // is a big issue with this particular function, though I could be
1219                         // wrong.  Also, the stuff below clearly does more masking than
1220                         // it needs to do.
1221 
1222                         // Clear high 6 bits.
1223                         int highSurrogate = ((int) ch) &amp; 0x03FF;
1224 
1225                         // Middle 4 bits (wwww) + 1
1226                         // &quot;Note that the value of wwww from the high surrogate bit pattern
1227                         // is incremented to make the uuuuu bit pattern in the scalar value
1228                         // so the surrogate pair don&#39;t address the BMP.&quot;
1229                         int wwww = ((highSurrogate &amp; 0x03C0) &gt;&gt; 6);
1230                         int uuuuu = wwww + 1;
1231 
1232                         // next 4 bits
1233                         int zzzz = (highSurrogate &amp; 0x003C) &gt;&gt; 2;
1234 
1235                         // low 2 bits
1236                         int yyyyyy = ((highSurrogate &amp; 0x0003) &lt;&lt; 4) &amp; 0x30;
1237 
1238                         // Get low surrogate character.
1239                         ch = chars[++i];
1240 
1241                         // Clear high 6 bits.
1242                         int lowSurrogate = ((int) ch) &amp; 0x03FF;
1243 
1244                         // put the middle 4 bits into the bottom of yyyyyy (byte 3)
1245                         yyyyyy = yyyyyy | ((lowSurrogate &amp; 0x03C0) &gt;&gt; 6);
1246 
1247                         // bottom 6 bits.
1248                         int xxxxxx = (lowSurrogate &amp; 0x003F);
1249 
1250                         int byte1 = 0xF0 | (uuuuu &gt;&gt; 2); // top 3 bits of uuuuu
1251                         int byte2 =
1252                             0x80 | (((uuuuu &amp; 0x03) &lt;&lt; 4) &amp; 0x30) | zzzz;
1253                         int byte3 = 0x80 | yyyyyy;
1254                         int byte4 = 0x80 | xxxxxx;
1255 
1256                         writer.write(&#39;%&#39;);
1257                         writer.write(makeHHString(byte1));
1258                         writer.write(&#39;%&#39;);
1259                         writer.write(makeHHString(byte2));
1260                         writer.write(&#39;%&#39;);
1261                         writer.write(makeHHString(byte3));
1262                         writer.write(&#39;%&#39;);
1263                         writer.write(makeHHString(byte4));
1264                     }
1265                     else
1266                     {
1267                         int high = (ch &gt;&gt; 12) | 0xE0; // top 4 bits
1268                         int middle = ((ch &amp; 0x0FC0) &gt;&gt; 6) | 0x80;
1269                         // middle 6 bits
1270                         int low = (ch &amp; 0x3F) | 0x80;
1271                         // First 6 bits, + high bit
1272                         writer.write(&#39;%&#39;);
1273                         writer.write(makeHHString(high));
1274                         writer.write(&#39;%&#39;);
1275                         writer.write(makeHHString(middle));
1276                         writer.write(&#39;%&#39;);
1277                         writer.write(makeHHString(low));
1278                     }
1279 
1280                 }
1281                 else if (escapingNotNeeded(ch))
1282                 {
1283                     writer.write(ch);
1284                 }
1285                 else
1286                 {
1287                     writer.write(&quot;&amp;#&quot;);
1288                     writer.write(Integer.toString(ch));
1289                     writer.write(&#39;;&#39;);
1290                 }
1291                 // In this character range we have first written out any previously accumulated
1292                 // &quot;clean&quot; characters, then processed the current more complicated character,
1293                 // which may have incremented &quot;i&quot;.
1294                 // We now we reset the next possible clean character.
1295                 cleanStart = i + 1;
1296             }
1297             // Since http://www.ietf.org/rfc/rfc2396.txt refers to the URI grammar as
1298             // not allowing quotes in the URI proper syntax, nor in the fragment
1299             // identifier, we believe that it&#39;s OK to double escape quotes.
1300             else if (ch == &#39;&quot;&#39;)
1301             {
1302                 // If the character is a &#39;%&#39; number number, try to avoid double-escaping.
1303                 // There is a question if this is legal behavior.
1304 
1305                 // Dmitri Ilyin: to check if &#39;%&#39; number number is invalid. It must be checked if %xx is a sign, that would be encoded
1306                 // The encoded signes are in Hex form. So %xx my be in form %3C that is &quot;&lt;&quot; sign. I will try to change here a little.
1307 
1308                 //        if( ((i+2) &lt; len) &amp;&amp; isASCIIDigit(stringArray[i+1]) &amp;&amp; isASCIIDigit(stringArray[i+2]) )
1309 
1310                 // We are no longer escaping &#39;%&#39;
1311 
1312                 if (cleanLength &gt; 0)
1313                 {
1314                     writer.write(chars, cleanStart, cleanLength);
1315                     cleanLength = 0;
1316                 }
1317 
1318 
1319                 // Mike Kay encodes this as &amp;#34;, so he may know something I don&#39;t?
1320                 if (doURLEscaping)
1321                     writer.write(&quot;%22&quot;);
1322                 else
1323                     writer.write(&quot;&amp;quot;&quot;); // we have to escape this, I guess.
1324 
1325                 // We have written out any clean characters, then the escaped &#39;%&#39; and now we
1326                 // We now we reset the next possible clean character.
1327                 cleanStart = i + 1;
1328             }
1329             else if (ch == &#39;&amp;&#39;)
1330             {
1331                 // HTML 4.01 reads, &quot;Authors should use &quot;&amp;amp;&quot; (ASCII decimal 38)
1332                 // instead of &quot;&amp;&quot; to avoid confusion with the beginning of a character
1333                 // reference (entity reference open delimiter).
1334                 if (cleanLength &gt; 0)
1335                 {
1336                     writer.write(chars, cleanStart, cleanLength);
1337                     cleanLength = 0;
1338                 }
1339                 writer.write(&quot;&amp;amp;&quot;);
1340                 cleanStart = i + 1;
1341             }
1342             else
1343             {
1344                 // no processing for this character, just count how
1345                 // many characters in a row that we have that need no processing
1346                 cleanLength++;
1347             }
1348         }
1349 
1350         // are there any clean characters at the end of the array
1351         // that we haven&#39;t processed yet?
1352         if (cleanLength &gt; 1)
1353         {
1354             // if the whole string can be written out as-is do so
1355             // otherwise write out the clean chars at the end of the
1356             // array
1357             if (cleanStart == 0)
1358                 writer.write(string);
1359             else
1360                 writer.write(chars, cleanStart, cleanLength);
1361         }
1362         else if (cleanLength == 1)
1363         {
1364             // a little optimization for 1 clean character
1365             // (we could have let the previous if(...) handle them all)
1366             writer.write(ch);
1367         }
1368     }
1369 
1370     /**
1371      * Writes the specified &lt;var&gt;string&lt;/var&gt; after substituting &lt;VAR&gt;specials&lt;/VAR&gt;,
1372      * and UTF-16 surrogates for character references &lt;CODE&gt;&amp;amp;#xnn&lt;/CODE&gt;.
1373      *
1374      * @param   string      String to convert to XML format.
1375      * @param   encoding    CURRENTLY NOT IMPLEMENTED.
1376      *
1377      * @throws org.xml.sax.SAXException
1378      */
1379     public void writeAttrString(
1380         final java.io.Writer writer, String string, String encoding)
1381         throws IOException, SAXException
1382     {
1383         final int end = string.length();
1384         if (end &gt; m_attrBuff.length)
1385         {
1386             m_attrBuff = new char[end * 2 + 1];
1387         }
1388         string.getChars(0, end, m_attrBuff, 0);
1389         final char[] chars = m_attrBuff;
1390 
1391 
1392 
1393         int cleanStart = 0;
1394         int cleanLength = 0;
1395 
1396         char ch = 0;
1397         for (int i = 0; i &lt; end; i++)
1398         {
1399             ch = chars[i];
1400 
1401             // System.out.println(&quot;SPECIALSSIZE: &quot;+SPECIALSSIZE);
1402             // System.out.println(&quot;ch: &quot;+(int)ch);
1403             // System.out.println(&quot;m_maxCharacter: &quot;+(int)m_maxCharacter);
1404             // System.out.println(&quot;m_attrCharsMap[ch]: &quot;+(int)m_attrCharsMap[ch]);
1405             if (escapingNotNeeded(ch) &amp;&amp; (!m_charInfo.isSpecialAttrChar(ch)))
1406             {
1407                 cleanLength++;
1408             }
1409             else if (&#39;&lt;&#39; == ch || &#39;&gt;&#39; == ch)
1410             {
1411                 cleanLength++; // no escaping in this case, as specified in 15.2
1412             }
1413             else if (
1414                 (&#39;&amp;&#39; == ch) &amp;&amp; ((i + 1) &lt; end) &amp;&amp; (&#39;{&#39; == chars[i + 1]))
1415             {
1416                 cleanLength++; // no escaping in this case, as specified in 15.2
1417             }
1418             else
1419             {
1420                 if (cleanLength &gt; 0)
1421                 {
1422                     writer.write(chars,cleanStart,cleanLength);
1423                     cleanLength = 0;
1424                 }
1425                 int pos = accumDefaultEntity(writer, ch, i, chars, end, false, true);
1426 
1427                 if (i != pos)
1428                 {
1429                     i = pos - 1;
1430                 }
1431                 else
1432                 {
1433                     if (Encodings.isHighUTF16Surrogate(ch) ||
1434                             Encodings.isLowUTF16Surrogate(ch))
1435                     {
1436                         if (writeUTF16Surrogate(ch, chars, i, end) &gt;= 0) {
1437                             // move the index if the low surrogate is consumed
1438                             // as writeUTF16Surrogate has written the pair
1439                             if (Encodings.isHighUTF16Surrogate(ch)) {
1440                                 i++;
1441                             }
1442                         }
1443                     }
1444 
1445                     // The next is kind of a hack to keep from escaping in the case
1446                     // of Shift_JIS and the like.
1447 
1448                     /*
1449                     else if ((ch &lt; m_maxCharacter) &amp;&amp; (m_maxCharacter == 0xFFFF)
1450                     &amp;&amp; (ch != 160))
1451                     {
1452                     writer.write(ch);  // no escaping in this case
1453                     }
1454                     else
1455                     */
1456                     String outputStringForChar = m_charInfo.getOutputStringForChar(ch);
1457                     if (null != outputStringForChar)
1458                     {
1459                         writer.write(outputStringForChar);
1460                     }
1461                     else if (escapingNotNeeded(ch))
1462                     {
1463                         writer.write(ch); // no escaping in this case
1464                     }
1465                     else
1466                     {
1467                         writer.write(&quot;&amp;#&quot;);
1468                         writer.write(Integer.toString(ch));
1469                         writer.write(&#39;;&#39;);
1470                     }
1471                 }
1472                 cleanStart = i + 1;
1473             }
1474         } // end of for()
1475 
1476         // are there any clean characters at the end of the array
1477         // that we haven&#39;t processed yet?
1478         if (cleanLength &gt; 1)
1479         {
1480             // if the whole string can be written out as-is do so
1481             // otherwise write out the clean chars at the end of the
1482             // array
1483             if (cleanStart == 0)
1484                 writer.write(string);
1485             else
1486                 writer.write(chars, cleanStart, cleanLength);
1487         }
1488         else if (cleanLength == 1)
1489         {
1490             // a little optimization for 1 clean character
1491             // (we could have let the previous if(...) handle them all)
1492             writer.write(ch);
1493         }
1494     }
1495 
1496 
1497 
1498     /**
1499      * Receive notification of character data.
1500      *
1501      * &lt;p&gt;The Parser will call this method to report each chunk of
1502      * character data.  SAX parsers may return all contiguous character
1503      * data in a single chunk, or they may split it into several
1504      * chunks; however, all of the characters in any single event
1505      * must come from the same external entity, so that the Locator
1506      * provides useful information.&lt;/p&gt;
1507      *
1508      * &lt;p&gt;The application must not attempt to read from the array
1509      * outside of the specified range.&lt;/p&gt;
1510      *
1511      * &lt;p&gt;Note that some parsers will report whitespace using the
1512      * ignorableWhitespace() method rather than this one (validating
1513      * parsers must do so).&lt;/p&gt;
1514      *
1515      * @param chars The characters from the XML document.
1516      * @param start The start position in the array.
1517      * @param length The number of characters to read from the array.
1518      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1519      *            wrapping another exception.
1520      * @see #ignorableWhitespace
1521      * @see org.xml.sax.Locator
1522      *
1523      * @throws org.xml.sax.SAXException
1524      */
1525     public final void characters(char chars[], int start, int length)
1526         throws org.xml.sax.SAXException
1527     {
1528 
1529         if (m_elemContext.m_isRaw)
1530         {
1531             try
1532             {
1533                 if (m_elemContext.m_startTagOpen)
1534                 {
1535                     closeStartTag();
1536                     m_elemContext.m_startTagOpen = false;
1537                 }
1538 
1539 //              With m_ispreserve just set true it looks like shouldIndent()
1540 //              will always return false, so drop any possible indentation.
1541 //              if (shouldIndent())
1542 //                  indent();
1543 
1544                 // writer.write(&quot;&lt;![CDATA[&quot;);
1545                 // writer.write(chars, start, length);
1546                 writeNormalizedChars(chars, start, length, false, m_lineSepUse);
1547                 m_isprevtext = true;
1548                 // writer.write(&quot;]]&gt;&quot;);
1549 
1550                 // time to generate characters event
1551                 if (m_tracer != null)
1552                     super.fireCharEvent(chars, start, length);
1553 
1554                 return;
1555             }
1556             catch (IOException ioe)
1557             {
1558                 throw new org.xml.sax.SAXException(
1559                     Utils.messages.createMessage(
1560                         MsgKey.ER_OIERROR,
1561                         null),
1562                     ioe);
1563                 //&quot;IO error&quot;, ioe);
1564             }
1565         }
1566         else
1567         {
1568             super.characters(chars, start, length);
1569         }
1570     }
1571 
1572     /**
1573      *  Receive notification of cdata.
1574      *
1575      *  &lt;p&gt;The Parser will call this method to report each chunk of
1576      *  character data.  SAX parsers may return all contiguous character
1577      *  data in a single chunk, or they may split it into several
1578      *  chunks; however, all of the characters in any single event
1579      *  must come from the same external entity, so that the Locator
1580      *  provides useful information.&lt;/p&gt;
1581      *
1582      *  &lt;p&gt;The application must not attempt to read from the array
1583      *  outside of the specified range.&lt;/p&gt;
1584      *
1585      *  &lt;p&gt;Note that some parsers will report whitespace using the
1586      *  ignorableWhitespace() method rather than this one (validating
1587      *  parsers must do so).&lt;/p&gt;
1588      *
1589      *  @param ch The characters from the XML document.
1590      *  @param start The start position in the array.
1591      *  @param length The number of characters to read from the array.
1592      *  @throws org.xml.sax.SAXException Any SAX exception, possibly
1593      *             wrapping another exception.
1594      *  @see #ignorableWhitespace
1595      *  @see org.xml.sax.Locator
1596      *
1597      * @throws org.xml.sax.SAXException
1598      */
1599     public final void cdata(char ch[], int start, int length)
1600         throws org.xml.sax.SAXException
1601     {
1602         if ((null != m_elemContext.m_elementName)
1603             &amp;&amp; (m_elemContext.m_elementName.equalsIgnoreCase(&quot;SCRIPT&quot;)
1604                 || m_elemContext.m_elementName.equalsIgnoreCase(&quot;STYLE&quot;)))
1605         {
1606             try
1607             {
1608                 if (m_elemContext.m_startTagOpen)
1609                 {
1610                     closeStartTag();
1611                     m_elemContext.m_startTagOpen = false;
1612                 }
1613 
1614                 if (shouldIndent())
1615                     indent();
1616 
1617                 // writer.write(ch, start, length);
1618                 writeNormalizedChars(ch, start, length, true, m_lineSepUse);
1619             }
1620             catch (IOException ioe)
1621             {
1622                 throw new org.xml.sax.SAXException(
1623                     Utils.messages.createMessage(
1624                         MsgKey.ER_OIERROR,
1625                         null),
1626                     ioe);
1627                 //&quot;IO error&quot;, ioe);
1628             }
1629         }
1630         else
1631         {
1632             super.cdata(ch, start, length);
1633         }
1634     }
1635 
1636     /**
1637      *  Receive notification of a processing instruction.
1638      *
1639      *  @param target The processing instruction target.
1640      *  @param data The processing instruction data, or null if
1641      *         none was supplied.
1642      *  @throws org.xml.sax.SAXException Any SAX exception, possibly
1643      *             wrapping another exception.
1644      *
1645      * @throws org.xml.sax.SAXException
1646      */
1647     public void processingInstruction(String target, String data)
1648         throws org.xml.sax.SAXException
1649     {
1650         if (m_doIndent) {
1651             m_childNodeNum++;
1652             flushCharactersBuffer(false);
1653         }
1654         // Process any pending starDocument and startElement first.
1655         flushPending();
1656 
1657         // Use a fairly nasty hack to tell if the next node is supposed to be
1658         // unescaped text.
1659         if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
1660         {
1661             startNonEscaping();
1662         }
1663         else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
1664         {
1665             endNonEscaping();
1666         }
1667         else
1668         {
1669             try
1670             {
1671             if (m_elemContext.m_startTagOpen)
1672             {
1673                 closeStartTag();
1674                 m_elemContext.m_startTagOpen = false;
1675             }
1676             else if (m_needToCallStartDocument)
1677                 startDocumentInternal();
1678 
1679             if (shouldIndent())
1680                 indent();
1681 
1682             final java.io.Writer writer = m_writer;
1683             //writer.write(&quot;&lt;?&quot; + target);
1684             writer.write(&quot;&lt;?&quot;);
1685             writer.write(target);
1686 
1687             if (data.length() &gt; 0 &amp;&amp; !Character.isSpaceChar(data.charAt(0)))
1688                 writer.write(&#39; &#39;);
1689 
1690             //writer.write(data + &quot;&gt;&quot;); // different from XML
1691             writer.write(data); // different from XML
1692             writer.write(&#39;&gt;&#39;); // different from XML
1693 
1694             // Always output a newline char if not inside of an
1695             // element. The whitespace is not significant in that
1696             // case.
1697             if (m_elemContext.m_currentElemDepth &lt;= 0)
1698                 outputLineSep();
1699 
1700             m_startNewLine = true;
1701             }
1702             catch(IOException e)
1703             {
1704                 throw new SAXException(e);
1705             }
1706         }
1707 
1708         // now generate the PI event
1709         if (m_tracer != null)
1710             super.fireEscapingEvent(target, data);
1711      }
1712 
1713     /**
1714      * Receive notivication of a entityReference.
1715      *
1716      * @param name non-null reference to entity name string.
1717      *
1718      * @throws org.xml.sax.SAXException
1719      */
1720     public final void entityReference(String name)
1721         throws org.xml.sax.SAXException
1722     {
1723         try
1724         {
1725 
1726         final java.io.Writer writer = m_writer;
1727         writer.write(&#39;&amp;&#39;);
1728         writer.write(name);
1729         writer.write(&#39;;&#39;);
1730 
1731         } catch(IOException e)
1732         {
1733             throw new SAXException(e);
1734         }
1735     }
1736     /**
1737      * @see ExtendedContentHandler#endElement(String)
1738      */
1739     public final void endElement(String elemName) throws SAXException
1740     {
1741         endElement(null, null, elemName);
1742     }
1743 
1744     /**
1745      * Process the attributes, which means to write out the currently
1746      * collected attributes to the writer. The attributes are not
1747      * cleared by this method
1748      *
1749      * @param writer the writer to write processed attributes to.
1750      * @param nAttrs the number of attributes in m_attributes
1751      * to be processed
1752      *
1753      * @throws org.xml.sax.SAXException
1754      */
1755     public void processAttributes(java.io.Writer writer, int nAttrs)
1756         throws IOException,SAXException
1757     {
1758             /*
1759              * process the collected attributes
1760              */
1761             for (int i = 0; i &lt; nAttrs; i++)
1762             {
1763                 processAttribute(
1764                     writer,
1765                     m_attributes.getQName(i),
1766                     m_attributes.getValue(i),
1767                     m_elemContext.m_elementDesc);
1768             }
1769     }
1770 
1771     /**
1772      * For the enclosing elements starting tag write out out any attributes
1773      * followed by &quot;&gt;&quot;
1774      *
1775      *@throws org.xml.sax.SAXException
1776      */
1777     protected void closeStartTag() throws SAXException
1778     {
1779             try
1780             {
1781 
1782             // finish processing attributes, time to fire off the start element event
1783             if (m_tracer != null)
1784                 super.fireStartElem(m_elemContext.m_elementName);
1785 
1786             int nAttrs = m_attributes.getLength();
1787             if (nAttrs&gt;0)
1788             {
1789                 processAttributes(m_writer, nAttrs);
1790                 // clear attributes object for re-use with next element
1791                 m_attributes.clear();
1792             }
1793 
1794             m_writer.write(&#39;&gt;&#39;);
1795 
1796             /* whether Xalan or XSLTC, we have the prefix mappings now, so
1797              * lets determine if the current element is specified in the cdata-
1798              * section-elements list.
1799              */
1800             if (m_StringOfCDATASections != null)
1801                 m_elemContext.m_isCdataSection = isCdataSection();
1802 
1803             }
1804             catch(IOException e)
1805             {
1806                 throw new SAXException(e);
1807             }
1808     }
1809 
1810         /**
1811          * This method is used when a prefix/uri namespace mapping
1812          * is indicated after the element was started with a
1813          * startElement() and before and endElement().
1814          * startPrefixMapping(prefix,uri) would be used before the
1815          * startElement() call.
1816          * @param uri the URI of the namespace
1817          * @param prefix the prefix associated with the given URI.
1818          *
1819          * @see ExtendedContentHandler#namespaceAfterStartElement(String, String)
1820          */
1821         public void namespaceAfterStartElement(String prefix, String uri)
1822             throws SAXException
1823         {
1824             // hack for XSLTC with finding URI for default namespace
1825             if (m_elemContext.m_elementURI == null)
1826             {
1827                 String prefix1 = getPrefixPart(m_elemContext.m_elementName);
1828                 if (prefix1 == null &amp;&amp; EMPTYSTRING.equals(prefix))
1829                 {
1830                     // the elements URI is not known yet, and it
1831                     // doesn&#39;t have a prefix, and we are currently
1832                     // setting the uri for prefix &quot;&quot;, so we have
1833                     // the uri for the element... lets remember it
1834                     m_elemContext.m_elementURI = uri;
1835                 }
1836             }
1837             startPrefixMapping(prefix,uri,false);
1838         }
1839 
1840     public void startDTD(String name, String publicId, String systemId)
1841         throws SAXException
1842     {
1843         m_inDTD = true;
1844         super.startDTD(name, publicId, systemId);
1845     }
1846 
1847     /**
1848      * Report the end of DTD declarations.
1849      * @throws org.xml.sax.SAXException The application may raise an exception.
1850      * @see #startDTD
1851      */
1852     public void endDTD() throws org.xml.sax.SAXException
1853     {
1854         m_inDTD = false;
1855         /* for ToHTMLStream the DOCTYPE is entirely output in the
1856          * startDocumentInternal() method, so don&#39;t do anything here
1857          */
1858     }
1859     /**
1860      * This method does nothing.
1861      */
1862     public void attributeDecl(
1863         String eName,
1864         String aName,
1865         String type,
1866         String valueDefault,
1867         String value)
1868         throws SAXException
1869     {
1870         // The internal DTD subset is not serialized by the ToHTMLStream serializer
1871     }
1872 
1873     /**
1874      * This method does nothing.
1875      */
1876     public void elementDecl(String name, String model) throws SAXException
1877     {
1878         // The internal DTD subset is not serialized by the ToHTMLStream serializer
1879     }
1880     /**
1881      * This method does nothing.
1882      */
1883     public void internalEntityDecl(String name, String value)
1884         throws SAXException
1885     {
1886         // The internal DTD subset is not serialized by the ToHTMLStream serializer
1887     }
1888     /**
1889      * This method does nothing.
1890      */
1891     public void externalEntityDecl(
1892         String name,
1893         String publicId,
1894         String systemId)
1895         throws SAXException
1896     {
1897         // The internal DTD subset is not serialized by the ToHTMLStream serializer
1898     }
1899 
1900     /**
1901      * This method is used to add an attribute to the currently open element.
1902      * The caller has guaranted that this attribute is unique, which means that it
1903      * not been seen before and will not be seen again.
1904      *
1905      * @param name the qualified name of the attribute
1906      * @param value the value of the attribute which can contain only
1907      * ASCII printable characters characters in the range 32 to 127 inclusive.
1908      * @param flags the bit values of this integer give optimization information.
1909      */
1910     public void addUniqueAttribute(String name, String value, int flags)
1911         throws SAXException
1912     {
1913         try
1914         {
1915             final java.io.Writer writer = m_writer;
1916             if ((flags &amp; NO_BAD_CHARS) &gt; 0 &amp;&amp; m_htmlcharInfo.onlyQuotAmpLtGt)
1917             {
1918                 // &quot;flags&quot; has indicated that the characters
1919                 // &#39;&gt;&#39;  &#39;&lt;&#39;   &#39;&amp;&#39;  and &#39;&quot;&#39; are not in the value and
1920                 // m_htmlcharInfo has recorded that there are no other
1921                 // entities in the range 0 to 127 so we write out the
1922                 // value directly
1923                 writer.write(&#39; &#39;);
1924                 writer.write(name);
1925                 writer.write(&quot;=\&quot;&quot;);
1926                 writer.write(value);
1927                 writer.write(&#39;&quot;&#39;);
1928             }
1929             else if (
1930                 (flags &amp; HTML_ATTREMPTY) &gt; 0
1931                     &amp;&amp; (value.length() == 0 || value.equalsIgnoreCase(name)))
1932             {
1933                 writer.write(&#39; &#39;);
1934                 writer.write(name);
1935             }
1936             else
1937             {
1938                 writer.write(&#39; &#39;);
1939                 writer.write(name);
1940                 writer.write(&quot;=\&quot;&quot;);
1941                 if ((flags &amp; HTML_ATTRURL) &gt; 0)
1942                 {
1943                     writeAttrURI(writer, value, m_specialEscapeURLs);
1944                 }
1945                 else
1946                 {
1947                     writeAttrString(writer, value, this.getEncoding());
1948                 }
1949                 writer.write(&#39;&quot;&#39;);
1950             }
1951         } catch (IOException e) {
1952             throw new SAXException(e);
1953         }
1954     }
1955 
1956     public void comment(char ch[], int start, int length)
1957             throws SAXException
1958     {
1959         // The internal DTD subset is not serialized by the ToHTMLStream serializer
1960         if (m_inDTD)
1961             return;
1962         super.comment(ch, start, length);
1963     }
1964 
1965     public boolean reset()
1966     {
1967         boolean ret = super.reset();
1968         if (!ret)
1969             return false;
1970         initToHTMLStream();
1971         return true;
1972     }
1973 
1974     private void initToHTMLStream()
1975     {
1976         m_isprevblock = false;
1977         m_inDTD = false;
1978         m_omitMetaTag = false;
1979         m_specialEscapeURLs = true;
1980     }
1981 
1982     static class Trie
1983     {
1984         /**
1985          * A digital search trie for 7-bit ASCII text
1986          * The API is a subset of java.util.Hashtable
1987          * The key must be a 7-bit ASCII string
1988          * The value may be any Java Object
1989          * One can get an object stored in a trie from its key,
1990          * but the search is either case sensitive or case
1991          * insensitive to the characters in the key, and this
1992          * choice of sensitivity or insensitivity is made when
1993          * the Trie is created, before any objects are put in it.
1994          *
1995          * This class is a copy of the one in com.sun.org.apache.xml.internal.utils.
1996          * It exists to cut the serializers dependancy on that package.
1997          *
1998          * @xsl.usage internal
1999          */
2000 
2001         /** Size of the m_nextChar array.  */
2002         public static final int ALPHA_SIZE = 128;
2003 
2004         /** The root node of the tree.    */
2005         final Node m_Root;
2006 
2007         /** helper buffer to convert Strings to char arrays */
2008         private char[] m_charBuffer = new char[0];
2009 
2010         /** true if the search for an object is lower case only with the key */
2011         private final boolean m_lowerCaseOnly;
2012 
2013         /**
2014          * Construct the trie that has a case insensitive search.
2015          */
2016         public Trie()
2017         {
2018             m_Root = new Node();
2019             m_lowerCaseOnly = false;
2020         }
2021 
2022         /**
2023          * Construct the trie given the desired case sensitivity with the key.
2024          * @param lowerCaseOnly true if the search keys are to be loser case only,
2025          * not case insensitive.
2026          */
2027         public Trie(boolean lowerCaseOnly)
2028         {
2029             m_Root = new Node();
2030             m_lowerCaseOnly = lowerCaseOnly;
2031         }
2032 
2033         /**
2034          * Put an object into the trie for lookup.
2035          *
2036          * @param key must be a 7-bit ASCII string
2037          * @param value any java object.
2038          *
2039          * @return The old object that matched key, or null.
2040          */
2041         public Object put(String key, Object value)
2042         {
2043 
2044             final int len = key.length();
2045             if (len &gt; m_charBuffer.length)
2046             {
2047                 // make the biggest buffer ever needed in get(String)
2048                 m_charBuffer = new char[len];
2049             }
2050 
2051             Node node = m_Root;
2052 
2053             for (int i = 0; i &lt; len; i++)
2054             {
2055                 Node nextNode =
2056                     node.m_nextChar[Character.toLowerCase(key.charAt(i))];
2057 
2058                 if (nextNode != null)
2059                 {
2060                     node = nextNode;
2061                 }
2062                 else
2063                 {
2064                     for (; i &lt; len; i++)
2065                     {
2066                         Node newNode = new Node();
2067                         if (m_lowerCaseOnly)
2068                         {
2069                             // put this value into the tree only with a lower case key
2070                             node.m_nextChar[Character.toLowerCase(
2071                                 key.charAt(i))] =
2072                                 newNode;
2073                         }
2074                         else
2075                         {
2076                             // put this value into the tree with a case insensitive key
2077                             node.m_nextChar[Character.toUpperCase(
2078                                 key.charAt(i))] =
2079                                 newNode;
2080                             node.m_nextChar[Character.toLowerCase(
2081                                 key.charAt(i))] =
2082                                 newNode;
2083                         }
2084                         node = newNode;
2085                     }
2086                     break;
2087                 }
2088             }
2089 
2090             Object ret = node.m_Value;
2091 
2092             node.m_Value = value;
2093 
2094             return ret;
2095         }
2096 
2097         /**
2098          * Get an object that matches the key.
2099          *
2100          * @param key must be a 7-bit ASCII string
2101          *
2102          * @return The object that matches the key, or null.
2103          */
2104         public Object get(final String key)
2105         {
2106 
2107             final int len = key.length();
2108 
2109             /* If the name is too long, we won&#39;t find it, this also keeps us
2110              * from overflowing m_charBuffer
2111              */
2112             if (m_charBuffer.length &lt; len)
2113                 return null;
2114 
2115             Node node = m_Root;
2116             switch (len) // optimize the look up based on the number of chars
2117             {
2118                 // case 0 looks silly, but the generated bytecode runs
2119                 // faster for lookup of elements of length 2 with this in
2120                 // and a fair bit faster.  Don&#39;t know why.
2121                 case 0 :
2122                     {
2123                         return null;
2124                     }
2125 
2126                 case 1 :
2127                     {
2128                         final char ch = key.charAt(0);
2129                         if (ch &lt; ALPHA_SIZE)
2130                         {
2131                             node = node.m_nextChar[ch];
2132                             if (node != null)
2133                                 return node.m_Value;
2134                         }
2135                         return null;
2136                     }
2137                     //                comment out case 2 because the default is faster
2138                     //                case 2 :
2139                     //                    {
2140                     //                        final char ch0 = key.charAt(0);
2141                     //                        final char ch1 = key.charAt(1);
2142                     //                        if (ch0 &lt; ALPHA_SIZE &amp;&amp; ch1 &lt; ALPHA_SIZE)
2143                     //                        {
2144                     //                            node = node.m_nextChar[ch0];
2145                     //                            if (node != null)
2146                     //                            {
2147                     //
2148                     //                                if (ch1 &lt; ALPHA_SIZE)
2149                     //                                {
2150                     //                                    node = node.m_nextChar[ch1];
2151                     //                                    if (node != null)
2152                     //                                        return node.m_Value;
2153                     //                                }
2154                     //                            }
2155                     //                        }
2156                     //                        return null;
2157                     //                   }
2158                 default :
2159                     {
2160                         for (int i = 0; i &lt; len; i++)
2161                         {
2162                             // A thread-safe way to loop over the characters
2163                             final char ch = key.charAt(i);
2164                             if (ALPHA_SIZE &lt;= ch)
2165                             {
2166                                 // the key is not 7-bit ASCII so we won&#39;t find it here
2167                                 return null;
2168                             }
2169 
2170                             node = node.m_nextChar[ch];
2171                             if (node == null)
2172                                 return null;
2173                         }
2174 
2175                         return node.m_Value;
2176                     }
2177             }
2178         }
2179 
2180         /**
2181          * The node representation for the trie.
2182          * @xsl.usage internal
2183          */
2184         private class Node
2185         {
2186 
2187             /**
2188              * Constructor, creates a Node[ALPHA_SIZE].
2189              */
2190             Node()
2191             {
2192                 m_nextChar = new Node[ALPHA_SIZE];
2193                 m_Value = null;
2194             }
2195 
2196             /** The next nodes.   */
2197             final Node m_nextChar[];
2198 
2199             /** The value.   */
2200             Object m_Value;
2201         }
2202         /**
2203          * Construct the trie from another Trie.
2204          * Both the existing Trie and this new one share the same table for
2205          * lookup, and it is assumed that the table is fully populated and
2206          * not changing anymore.
2207          *
2208          * @param existingTrie the Trie that this one is a copy of.
2209          */
2210         public Trie(Trie existingTrie)
2211         {
2212             // copy some fields from the existing Trie into this one.
2213             m_Root = existingTrie.m_Root;
2214             m_lowerCaseOnly = existingTrie.m_lowerCaseOnly;
2215 
2216             // get a buffer just big enough to hold the longest key in the table.
2217             int max = existingTrie.getLongestKeyLength();
2218             m_charBuffer = new char[max];
2219         }
2220 
2221         /**
2222          * Get an object that matches the key.
2223          * This method is faster than get(), but is not thread-safe.
2224          *
2225          * @param key must be a 7-bit ASCII string
2226          *
2227          * @return The object that matches the key, or null.
2228          */
2229         public Object get2(final String key)
2230         {
2231 
2232             final int len = key.length();
2233 
2234             /* If the name is too long, we won&#39;t find it, this also keeps us
2235              * from overflowing m_charBuffer
2236              */
2237             if (m_charBuffer.length &lt; len)
2238                 return null;
2239 
2240             Node node = m_Root;
2241             switch (len) // optimize the look up based on the number of chars
2242             {
2243                 // case 0 looks silly, but the generated bytecode runs
2244                 // faster for lookup of elements of length 2 with this in
2245                 // and a fair bit faster.  Don&#39;t know why.
2246                 case 0 :
2247                     {
2248                         return null;
2249                     }
2250 
2251                 case 1 :
2252                     {
2253                         final char ch = key.charAt(0);
2254                         if (ch &lt; ALPHA_SIZE)
2255                         {
2256                             node = node.m_nextChar[ch];
2257                             if (node != null)
2258                                 return node.m_Value;
2259                         }
2260                         return null;
2261                     }
2262                 default :
2263                     {
2264                         /* Copy string into array. This is not thread-safe because
2265                          * it modifies the contents of m_charBuffer. If multiple
2266                          * threads were to use this Trie they all would be
2267                          * using this same array (not good). So this
2268                          * method is not thread-safe, but it is faster because
2269                          * converting to a char[] and looping over elements of
2270                          * the array is faster than a String&#39;s charAt(i).
2271                          */
2272                         key.getChars(0, len, m_charBuffer, 0);
2273 
2274                         for (int i = 0; i &lt; len; i++)
2275                         {
2276                             final char ch = m_charBuffer[i];
2277                             if (ALPHA_SIZE &lt;= ch)
2278                             {
2279                                 // the key is not 7-bit ASCII so we won&#39;t find it here
2280                                 return null;
2281                             }
2282 
2283                             node = node.m_nextChar[ch];
2284                             if (node == null)
2285                                 return null;
2286                         }
2287 
2288                         return node.m_Value;
2289                     }
2290             }
2291         }
2292 
2293         /**
2294          * Get the length of the longest key used in the table.
2295          */
2296         public int getLongestKeyLength()
2297         {
2298             return m_charBuffer.length;
2299         }
2300     }
2301 }
    </pre>
  </body>
</html>
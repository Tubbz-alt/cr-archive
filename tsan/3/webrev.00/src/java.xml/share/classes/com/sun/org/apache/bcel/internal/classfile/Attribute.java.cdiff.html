<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Attribute.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Annotations.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AttributeReader.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Attribute.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,11 ***</span>
   * &lt;em&gt;Exceptiontable&lt;/em&gt;, &lt;em&gt;LineNumberTable&lt;/em&gt;,
   * &lt;em&gt;LocalVariableTable&lt;/em&gt;, &lt;em&gt;InnerClasses&lt;/em&gt; and
   * &lt;em&gt;Synthetic&lt;/em&gt; attributes are supported. The &lt;em&gt;Unknown&lt;/em&gt;
   * attribute stands for non-standard-attributes.
   *
<span class="line-removed">-  * @version $Id: Attribute.java 1750029 2016-06-23 22:14:38Z sebb $</span>
   * @see ConstantValue
   * @see SourceFile
   * @see Code
   * @see Unknown
   * @see ExceptionTable
<span class="line-new-header">--- 34,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,86 ***</span>
   * @see LocalVariableTable
   * @see InnerClasses
   * @see Synthetic
   * @see Deprecated
   * @see Signature
   */
  public abstract class Attribute implements Cloneable, Node {
<span class="line-modified">! </span>
      private int name_index; // Points to attribute name in constant pool
      private int length; // Content length of attribute field
      private final byte tag; // Tag to distinguish subclasses
      private ConstantPool constant_pool;
  
<span class="line-removed">-     protected Attribute(final byte tag, final int name_index, final int length, final ConstantPool constant_pool) {</span>
<span class="line-removed">-         this.tag = tag;</span>
<span class="line-removed">-         this.name_index = name_index;</span>
<span class="line-removed">-         this.length = length;</span>
<span class="line-removed">-         this.constant_pool = constant_pool;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Called by objects that are traversing the nodes of the tree implicitely</span>
<span class="line-removed">-      * defined by the contents of a Java class. I.e., the hierarchy of methods,</span>
<span class="line-removed">-      * fields, attributes, etc. spawns a tree of objects.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param v Visitor object</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     public abstract void accept(Visitor v);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Dump attribute to file stream in binary format.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param file Output file stream</span>
<span class="line-removed">-      * @throws IOException</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public void dump(final DataOutputStream file) throws IOException {</span>
<span class="line-removed">-         file.writeShort(name_index);</span>
<span class="line-removed">-         file.writeInt(length);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      private static final Map&lt;String, Object&gt; readers = new HashMap&lt;&gt;();
  
      /**
       * Add an Attribute reader capable of parsing (user-defined) attributes
       * named &quot;name&quot;. You should not add readers for the standard attributes such
       * as &quot;LineNumberTable&quot;, because those are handled internally.
       *
       * @param name the name of the attribute as stored in the class file
<span class="line-modified">!      * @param r the reader object</span>
       */
<span class="line-modified">!     public static void addAttributeReader(final String name, final UnknownAttributeReader r) {</span>
          readers.put(name, r);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Remove attribute reader</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @param name the name of the attribute as stored in the class file</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public static void removeAttributeReader(final String name) {</span>
<span class="line-removed">-         readers.remove(name);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Class method reads one attribute from the input data stream. This method</span>
<span class="line-removed">-      * must not be accessible from the outside. It is called by the Field and</span>
<span class="line-removed">-      * Method constructor methods.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @see Field</span>
<span class="line-removed">-      * @see Method</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param file Input stream</span>
<span class="line-removed">-      * @param constant_pool Array of constants</span>
<span class="line-removed">-      * @return Attribute</span>
<span class="line-removed">-      * @throws IOException</span>
<span class="line-removed">-      * @throws ClassFormatException</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public static Attribute readAttribute(final DataInputStream file, final ConstantPool constant_pool)</span>
<span class="line-removed">-             throws IOException, ClassFormatException {</span>
<span class="line-removed">-         return readAttribute((DataInput) file, constant_pool);</span>
      }
  
      /**
       * Class method reads one attribute from the input data stream. This method
       * must not be accessible from the outside. It is called by the Field and
<span class="line-new-header">--- 45,38 ---</span>
   * @see LocalVariableTable
   * @see InnerClasses
   * @see Synthetic
   * @see Deprecated
   * @see Signature
<span class="line-added">+  * @LastModified: Jan 2020</span>
   */
  public abstract class Attribute implements Cloneable, Node {
<span class="line-modified">!     private static final boolean debug = false;</span>
      private int name_index; // Points to attribute name in constant pool
      private int length; // Content length of attribute field
      private final byte tag; // Tag to distinguish subclasses
      private ConstantPool constant_pool;
  
      private static final Map&lt;String, Object&gt; readers = new HashMap&lt;&gt;();
  
      /**
       * Add an Attribute reader capable of parsing (user-defined) attributes
       * named &quot;name&quot;. You should not add readers for the standard attributes such
       * as &quot;LineNumberTable&quot;, because those are handled internally.
       *
       * @param name the name of the attribute as stored in the class file
<span class="line-modified">!      * @param r    the reader object</span>
       */
<span class="line-modified">!     public static void addAttributeReader(final String name, final UnknownAttributeReader r)</span>
<span class="line-added">+     {</span>
          readers.put(name, r);
      }
  
<span class="line-modified">!     protected static void println(final String msg) {</span>
<span class="line-modified">!         if (debug) {</span>
<span class="line-modified">!             System.err.println(msg);</span>
<span class="line-modified">!         }</span>
      }
  
      /**
       * Class method reads one attribute from the input data stream. This method
       * must not be accessible from the outside. It is called by the Field and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,33 ***</span>
       * @throws IOException
       * @throws ClassFormatException
       * @since 6.0
       */
      public static Attribute readAttribute(final DataInput file, final ConstantPool constant_pool)
<span class="line-modified">!             throws IOException, ClassFormatException {</span>
          byte tag = Const.ATTR_UNKNOWN; // Unknown attribute
          // Get class name from constant pool via `name_index&#39; indirection
          final int name_index = file.readUnsignedShort();
          final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
          final String name = c.getBytes();
  
          // Length of data in bytes
          final int length = file.readInt();
  
          // Compare strings to find known attribute
<span class="line-modified">!         for (byte i = 0; i &lt; Const.KNOWN_ATTRIBUTES; i++) {</span>
<span class="line-modified">!             if (name.equals(Const.getAttributeName(i))) {</span>
                  tag = i; // found!
                  break;
              }
          }
  
          // Call proper constructor, depending on `tag&#39;
<span class="line-modified">!         switch (tag) {</span>
              case Const.ATTR_UNKNOWN:
                  final Object r = readers.get(name);
<span class="line-modified">!                 if (r instanceof UnknownAttributeReader) {</span>
                      return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);
                  }
                  return new Unknown(name_index, length, file, constant_pool);
              case Const.ATTR_CONSTANT_VALUE:
                  return new ConstantValue(name_index, length, file, constant_pool);
<span class="line-new-header">--- 91,38 ---</span>
       * @throws IOException
       * @throws ClassFormatException
       * @since 6.0
       */
      public static Attribute readAttribute(final DataInput file, final ConstantPool constant_pool)
<span class="line-modified">!             throws IOException, ClassFormatException</span>
<span class="line-added">+     {</span>
          byte tag = Const.ATTR_UNKNOWN; // Unknown attribute
          // Get class name from constant pool via `name_index&#39; indirection
          final int name_index = file.readUnsignedShort();
          final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
          final String name = c.getBytes();
  
          // Length of data in bytes
          final int length = file.readInt();
  
          // Compare strings to find known attribute
<span class="line-modified">!         for (byte i = 0; i &lt; Const.KNOWN_ATTRIBUTES; i++)</span>
<span class="line-modified">!         {</span>
<span class="line-added">+             if (name.equals(Const.getAttributeName(i)))</span>
<span class="line-added">+             {</span>
                  tag = i; // found!
                  break;
              }
          }
  
          // Call proper constructor, depending on `tag&#39;
<span class="line-modified">!         switch (tag)</span>
<span class="line-added">+         {</span>
              case Const.ATTR_UNKNOWN:
                  final Object r = readers.get(name);
<span class="line-modified">!                 if (r instanceof UnknownAttributeReader)</span>
<span class="line-added">+                 {</span>
                      return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);
                  }
                  return new Unknown(name_index, length, file, constant_pool);
              case Const.ATTR_CONSTANT_VALUE:
                  return new ConstantValue(name_index, length, file, constant_pool);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,11 ***</span>
              case Const.ATTR_PMG:
                  return new PMGClass(name_index, length, file, constant_pool);
              case Const.ATTR_SIGNATURE:
                  return new Signature(name_index, length, file, constant_pool);
              case Const.ATTR_STACK_MAP:
<span class="line-modified">!                 return new StackMap(name_index, length, file, constant_pool);</span>
              case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:
                  return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);
              case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:
                  return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);
              case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:
<span class="line-new-header">--- 145,14 ---</span>
              case Const.ATTR_PMG:
                  return new PMGClass(name_index, length, file, constant_pool);
              case Const.ATTR_SIGNATURE:
                  return new Signature(name_index, length, file, constant_pool);
              case Const.ATTR_STACK_MAP:
<span class="line-modified">!                 // old style stack map: unneeded for JDK5 and below;</span>
<span class="line-added">+                 // illegal(?) for JDK6 and above.  So just delete with a warning.</span>
<span class="line-added">+                 println(&quot;Warning: Obsolete StackMap attribute ignored.&quot;);</span>
<span class="line-added">+                 return new Unknown(name_index, length, file, constant_pool);</span>
              case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:
                  return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);
              case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:
                  return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);
              case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,107 ***</span>
              case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
                  return new LocalVariableTypeTable(name_index, length, file, constant_pool);
              case Const.ATTR_ENCLOSING_METHOD:
                  return new EnclosingMethod(name_index, length, file, constant_pool);
              case Const.ATTR_STACK_MAP_TABLE:
                  return new StackMap(name_index, length, file, constant_pool);
              case Const.ATTR_BOOTSTRAP_METHODS:
                  return new BootstrapMethods(name_index, length, file, constant_pool);
              case Const.ATTR_METHOD_PARAMETERS:
                  return new MethodParameters(name_index, length, file, constant_pool);
              default:
                  // Never reached
                  throw new IllegalStateException(&quot;Unrecognized attribute type tag parsed: &quot; + tag);
          }
      }
  
      /**
<span class="line-modified">!      * @return Name of attribute</span>
<span class="line-modified">!      * @since 6.0</span>
       */
<span class="line-modified">!     public String getName() {</span>
<span class="line-modified">!         final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);</span>
<span class="line-modified">!         return c.getBytes();</span>
      }
  
      /**
<span class="line-modified">!      * @return Length of attribute field in bytes.</span>
       */
<span class="line-modified">!     public final int getLength() {</span>
<span class="line-modified">!         return length;</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @param length length in bytes.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     public final void setLength(final int length) {</span>
          this.length = length;
      }
  
      /**
<span class="line-modified">!      * @param name_index of attribute.</span>
       */
<span class="line-modified">!     public final void setNameIndex(final int name_index) {</span>
<span class="line-modified">!         this.name_index = name_index;</span>
<span class="line-removed">-     }</span>
  
      /**
<span class="line-modified">!      * @return Name index in constant pool of attribute name.</span>
       */
<span class="line-modified">!     public final int getNameIndex() {</span>
<span class="line-modified">!         return name_index;</span>
      }
  
      /**
<span class="line-modified">!      * @return Tag of attribute, i.e., its type. Value may not be altered, thus</span>
<span class="line-removed">-      * there is no setTag() method.</span>
       */
<span class="line-modified">!     public final byte getTag() {</span>
<span class="line-modified">!         return tag;</span>
      }
  
      /**
       * @return Constant pool used by this object.
       * @see ConstantPool
       */
<span class="line-modified">!     public final ConstantPool getConstantPool() {</span>
          return constant_pool;
      }
  
      /**
       * @param constant_pool Constant pool to be used for this object.
       * @see ConstantPool
       */
<span class="line-modified">!     public final void setConstantPool(final ConstantPool constant_pool) {</span>
          this.constant_pool = constant_pool;
      }
  
      /**
<span class="line-modified">!      * Use copy() if you want to have a deep copy(), i.e., with all references</span>
<span class="line-removed">-      * copied correctly.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return shallow copy of this attribute</span>
       */
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public Object clone() {</span>
<span class="line-modified">!         Attribute attr = null;</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             attr = (Attribute) super.clone();</span>
<span class="line-removed">-         } catch (final CloneNotSupportedException e) {</span>
<span class="line-removed">-             throw new Error(&quot;Clone Not Supported&quot;); // never happens</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return attr;</span>
      }
  
      /**
<span class="line-modified">!      * @return deep copy of this attribute</span>
       */
<span class="line-modified">!     public abstract Attribute copy(ConstantPool _constant_pool);</span>
  
      /**
       * @return attribute name.
       */
      @Override
<span class="line-modified">!     public String toString() {</span>
          return Const.getAttributeName(tag);
      }
  }
<span class="line-new-header">--- 164,193 ---</span>
              case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:
                  return new LocalVariableTypeTable(name_index, length, file, constant_pool);
              case Const.ATTR_ENCLOSING_METHOD:
                  return new EnclosingMethod(name_index, length, file, constant_pool);
              case Const.ATTR_STACK_MAP_TABLE:
<span class="line-added">+                 // read new style stack map: StackMapTable.  The rest of the code</span>
<span class="line-added">+                 // calls this a StackMap for historical reasons.</span>
                  return new StackMap(name_index, length, file, constant_pool);
              case Const.ATTR_BOOTSTRAP_METHODS:
                  return new BootstrapMethods(name_index, length, file, constant_pool);
              case Const.ATTR_METHOD_PARAMETERS:
                  return new MethodParameters(name_index, length, file, constant_pool);
<span class="line-added">+             case Const.ATTR_MODULE:</span>
<span class="line-added">+                 return new Module(name_index, length, file, constant_pool);</span>
<span class="line-added">+             case Const.ATTR_MODULE_PACKAGES:</span>
<span class="line-added">+                 return new ModulePackages(name_index, length, file, constant_pool);</span>
<span class="line-added">+             case Const.ATTR_MODULE_MAIN_CLASS:</span>
<span class="line-added">+                 return new ModuleMainClass(name_index, length, file, constant_pool);</span>
<span class="line-added">+             case Const.ATTR_NEST_HOST:</span>
<span class="line-added">+                 return new NestHost(name_index, length, file, constant_pool);</span>
<span class="line-added">+             case Const.ATTR_NEST_MEMBERS:</span>
<span class="line-added">+                 return new NestMembers(name_index, length, file, constant_pool);</span>
              default:
                  // Never reached
                  throw new IllegalStateException(&quot;Unrecognized attribute type tag parsed: &quot; + tag);
          }
      }
  
      /**
<span class="line-modified">!      * Class method reads one attribute from the input data stream. This method</span>
<span class="line-modified">!      * must not be accessible from the outside. It is called by the Field and</span>
<span class="line-added">+      * Method constructor methods.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @see Field</span>
<span class="line-added">+      * @see Method</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param file Input stream</span>
<span class="line-added">+      * @param constant_pool Array of constants</span>
<span class="line-added">+      * @return Attribute</span>
<span class="line-added">+      * @throws IOException</span>
<span class="line-added">+      * @throws ClassFormatException</span>
       */
<span class="line-modified">!     public static Attribute readAttribute(final DataInputStream file, final ConstantPool constant_pool)</span>
<span class="line-modified">!             throws IOException, ClassFormatException</span>
<span class="line-modified">!     {</span>
<span class="line-added">+         return readAttribute((DataInput) file, constant_pool);</span>
      }
  
      /**
<span class="line-modified">!      * Remove attribute reader</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param name the name of the attribute as stored in the class file</span>
       */
<span class="line-modified">!     public static void removeAttributeReader(final String name)</span>
<span class="line-modified">!     {</span>
<span class="line-added">+         readers.remove(name);</span>
      }
  
<span class="line-modified">!     protected Attribute(final byte tag, final int name_index, final int length, final ConstantPool constant_pool)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         this.tag = tag;</span>
<span class="line-modified">!         this.name_index = name_index;</span>
          this.length = length;
<span class="line-added">+         this.constant_pool = constant_pool;</span>
      }
  
      /**
<span class="line-modified">!      * Called by objects that are traversing the nodes of the tree implicitely</span>
<span class="line-added">+      * defined by the contents of a Java class. I.e., the hierarchy of methods,</span>
<span class="line-added">+      * fields, attributes, etc. spawns a tree of objects.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param v</span>
<span class="line-added">+      *            Visitor object</span>
       */
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public abstract void accept(Visitor v);</span>
  
      /**
<span class="line-modified">!      * Use copy() if you want to have a deep copy(), i.e., with all references</span>
<span class="line-added">+      * copied correctly.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return shallow copy of this attribute</span>
       */
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public Object clone()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         Attribute attr = null;</span>
<span class="line-added">+         try</span>
<span class="line-added">+         {</span>
<span class="line-added">+             attr = (Attribute) super.clone();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         catch (final CloneNotSupportedException e)</span>
<span class="line-added">+         {</span>
<span class="line-added">+             throw new Error(&quot;Clone Not Supported&quot;); // never happens</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return attr;</span>
      }
  
      /**
<span class="line-modified">!      * @return deep copy of this attribute</span>
       */
<span class="line-modified">!     public abstract Attribute copy(ConstantPool _constant_pool);</span>
<span class="line-modified">! </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Dump attribute to file stream in binary format.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param file</span>
<span class="line-added">+      *            Output file stream</span>
<span class="line-added">+      * @throws IOException</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void dump(final DataOutputStream file) throws IOException</span>
<span class="line-added">+     {</span>
<span class="line-added">+         file.writeShort(name_index);</span>
<span class="line-added">+         file.writeInt(length);</span>
      }
  
      /**
       * @return Constant pool used by this object.
       * @see ConstantPool
       */
<span class="line-modified">!     public final ConstantPool getConstantPool()</span>
<span class="line-added">+     {</span>
          return constant_pool;
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * @return Length of attribute field in bytes.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public final int getLength()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return length;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @return Name of attribute</span>
<span class="line-added">+      * @since 6.0</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public String getName()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);</span>
<span class="line-added">+         return c.getBytes();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @return Name index in constant pool of attribute name.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public final int getNameIndex()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return name_index;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * @return Tag of attribute, i.e., its type. Value may not be altered, thus there is no setTag() method.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public final byte getTag()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return tag;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * @param constant_pool Constant pool to be used for this object.
       * @see ConstantPool
       */
<span class="line-modified">!     public final void setConstantPool(final ConstantPool constant_pool)</span>
<span class="line-added">+     {</span>
          this.constant_pool = constant_pool;
      }
  
      /**
<span class="line-modified">!      * @param length length in bytes.</span>
       */
<span class="line-modified">!     public final void setLength(final int length)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         this.length = length;</span>
      }
  
      /**
<span class="line-modified">!      * @param name_index of attribute.</span>
       */
<span class="line-modified">!     public final void setNameIndex(final int name_index)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         this.name_index = name_index;</span>
<span class="line-added">+     }</span>
  
      /**
       * @return attribute name.
       */
      @Override
<span class="line-modified">!     public String toString()</span>
<span class="line-added">+     {</span>
          return Const.getAttributeName(tag);
      }
  }
</pre>
<center><a href="Annotations.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AttributeReader.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/FieldOrMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Field.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InnerClass.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/FieldOrMethod.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,11 ***</span>
  import com.sun.org.apache.bcel.internal.Const;
  
  /**
   * Abstract super class for fields and methods.
   *
<span class="line-modified">!  * @version $Id: FieldOrMethod.java 1750029 2016-06-23 22:14:38Z sebb $</span>
   */
  public abstract class FieldOrMethod extends AccessFlags implements Cloneable, Node {
      private int name_index; // Points to field name in constant pool
      private int signature_index; // Points to encoded signature
      private Attribute[] attributes; // Collection of attributes
<span class="line-new-header">--- 27,11 ---</span>
  import com.sun.org.apache.bcel.internal.Const;
  
  /**
   * Abstract super class for fields and methods.
   *
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public abstract class FieldOrMethod extends AccessFlags implements Cloneable, Node {
      private int name_index; // Points to field name in constant pool
      private int signature_index; // Points to encoded signature
      private Attribute[] attributes; // Collection of attributes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,53 ***</span>
      private boolean searchedForSignatureAttribute = false;
  
      FieldOrMethod() {
      }
  
      /**
       * Initialize from another object. Note that both objects use the same
       * references (shallow copy). Use clone() for a physical copy.
       */
      protected FieldOrMethod(final FieldOrMethod c) {
          this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(),
                  c.getAttributes(), c.getConstantPool());
      }
  
      /**
       * Construct object from file stream.
       *
       * @param file Input stream
       * @throws IOException
       * @throws ClassFormatException
<span class="line-modified">!      * @deprecated (6.0) Use</span>
<span class="line-removed">-      * {@link #FieldOrMethod(java.io.DataInput, ConstantPool)} instead.</span>
       */
      @java.lang.Deprecated
<span class="line-modified">!     protected FieldOrMethod(final DataInputStream file,</span>
<span class="line-modified">!             final ConstantPool constant_pool) throws IOException,</span>
              ClassFormatException {
          this((DataInput) file, constant_pool);
      }
  
      /**
       * Construct object from file stream.
<span class="line-removed">-      *</span>
       * @param file Input stream
       * @throws IOException
       * @throws ClassFormatException
       */
<span class="line-modified">!     protected FieldOrMethod(final DataInput file,</span>
<span class="line-modified">!             final ConstantPool constant_pool) throws IOException, ClassFormatException {</span>
          this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null,
                  constant_pool);
<span class="line-modified">!         attributes_count = file.readUnsignedShort();</span>
          attributes = new Attribute[attributes_count];
          for (int i = 0; i &lt; attributes_count; i++) {
              attributes[i] = Attribute.readAttribute(file, constant_pool);
          }
      }
  
      /**
       * @param access_flags Access rights of method
       * @param name_index Points to field name in constant pool
       * @param signature_index Points to encoded signature
       * @param attributes Collection of attributes
<span class="line-new-header">--- 46,55 ---</span>
      private boolean searchedForSignatureAttribute = false;
  
      FieldOrMethod() {
      }
  
<span class="line-added">+ </span>
      /**
       * Initialize from another object. Note that both objects use the same
       * references (shallow copy). Use clone() for a physical copy.
       */
      protected FieldOrMethod(final FieldOrMethod c) {
          this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(),
                  c.getAttributes(), c.getConstantPool());
      }
  
<span class="line-added">+ </span>
      /**
       * Construct object from file stream.
       *
       * @param file Input stream
       * @throws IOException
       * @throws ClassFormatException
<span class="line-modified">!      * @deprecated (6.0) Use {@link #FieldOrMethod(java.io.DataInput, ConstantPool)} instead.</span>
       */
      @java.lang.Deprecated
<span class="line-modified">!     protected FieldOrMethod(final DataInputStream file, final ConstantPool constant_pool)</span>
<span class="line-modified">!             throws IOException,</span>
              ClassFormatException {
          this((DataInput) file, constant_pool);
      }
  
      /**
       * Construct object from file stream.
       * @param file Input stream
       * @throws IOException
       * @throws ClassFormatException
       */
<span class="line-modified">!     protected FieldOrMethod(final DataInput file, final ConstantPool constant_pool)</span>
<span class="line-modified">!             throws IOException, ClassFormatException {</span>
          this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null,
                  constant_pool);
<span class="line-modified">!         final int attributes_count = file.readUnsignedShort();</span>
          attributes = new Attribute[attributes_count];
          for (int i = 0; i &lt; attributes_count; i++) {
              attributes[i] = Attribute.readAttribute(file, constant_pool);
          }
<span class="line-added">+         this.attributes_count = attributes_count; // init deprecated field</span>
      }
  
<span class="line-added">+ </span>
      /**
       * @param access_flags Access rights of method
       * @param name_index Points to field name in constant pool
       * @param signature_index Points to encoded signature
       * @param attributes Collection of attributes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,10 ***</span>
<span class="line-new-header">--- 107,11 ---</span>
          this.signature_index = signature_index;
          this.constant_pool = constant_pool;
          setAttributes(attributes);
      }
  
<span class="line-added">+ </span>
      /**
       * Dump object to file stream on binary format.
       *
       * @param file Output file stream
       * @throws IOException
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,108 ***</span>
      public final void dump(final DataOutputStream file) throws IOException {
          file.writeShort(super.getAccessFlags());
          file.writeShort(name_index);
          file.writeShort(signature_index);
          file.writeShort(attributes_count);
<span class="line-modified">! </span>
<span class="line-modified">!         for(int i=0; i &lt; attributes_count; i++) {</span>
<span class="line-modified">!             attributes[i].dump(file);</span>
          }
      }
  
      /**
       * @return Collection of object attributes.
       */
      public final Attribute[] getAttributes() {
          return attributes;
      }
  
      /**
       * @param attributes Collection of object attributes.
       */
<span class="line-modified">!     public final void setAttributes(final Attribute[] attributes) {</span>
          this.attributes = attributes;
<span class="line-modified">!         this.attributes_count = attributes != null ? attributes.length : 0;</span>
      }
  
      /**
       * @return Constant pool used by this object.
       */
      public final ConstantPool getConstantPool() {
          return constant_pool;
      }
  
      /**
       * @param constant_pool Constant pool to be used for this object.
       */
<span class="line-modified">!     public final void setConstantPool(final ConstantPool constant_pool) {</span>
          this.constant_pool = constant_pool;
      }
  
      /**
       * @return Index in constant pool of object&#39;s name.
       */
      public final int getNameIndex() {
          return name_index;
      }
  
      /**
       * @param name_index Index in constant pool of object&#39;s name.
       */
<span class="line-modified">!     public final void setNameIndex(final int name_index) {</span>
          this.name_index = name_index;
      }
  
      /**
       * @return Index in constant pool of field signature.
       */
      public final int getSignatureIndex() {
          return signature_index;
      }
  
      /**
       * @param signature_index Index in constant pool of field signature.
       */
<span class="line-modified">!     public final void setSignatureIndex(final int signature_index) {</span>
          this.signature_index = signature_index;
      }
  
      /**
       * @return Name of object, i.e., method name or field name
       */
      public final String getName() {
          ConstantUtf8 c;
          c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
          return c.getBytes();
      }
  
      /**
       * @return String representation of object&#39;s type signature (java style)
       */
      public final String getSignature() {
          ConstantUtf8 c;
          c = (ConstantUtf8) constant_pool.getConstant(signature_index, Const.CONSTANT_Utf8);
          return c.getBytes();
      }
  
      /**
       * @return deep copy of this field
       */
<span class="line-modified">!     protected FieldOrMethod copy_(final ConstantPool _constant_pool) {</span>
          FieldOrMethod c = null;
  
          try {
<span class="line-modified">!             c = (FieldOrMethod) clone();</span>
<span class="line-modified">!         } catch (final CloneNotSupportedException e) {</span>
              // ignored, but will cause NPE ...
          }
  
<span class="line-modified">!         c.constant_pool = constant_pool;</span>
<span class="line-modified">!         c.attributes = new Attribute[attributes_count];</span>
<span class="line-modified">!         c.attributes_count = attributes_count;</span>
  
<span class="line-modified">!         for (int i = 0; i &lt; attributes_count; i++) {</span>
              c.attributes[i] = attributes[i].copy(constant_pool);
          }
  
          return c;
      }
<span class="line-new-header">--- 119,120 ---</span>
      public final void dump(final DataOutputStream file) throws IOException {
          file.writeShort(super.getAccessFlags());
          file.writeShort(name_index);
          file.writeShort(signature_index);
          file.writeShort(attributes_count);
<span class="line-modified">!         if (attributes != null) {</span>
<span class="line-modified">!             for (final Attribute attribute : attributes) {</span>
<span class="line-modified">!                 attribute.dump(file);</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @return Collection of object attributes.
       */
      public final Attribute[] getAttributes() {
          return attributes;
      }
  
<span class="line-added">+ </span>
      /**
       * @param attributes Collection of object attributes.
       */
<span class="line-modified">!     public final void setAttributes( final Attribute[] attributes ) {</span>
          this.attributes = attributes;
<span class="line-modified">!         this.attributes_count = attributes != null ? attributes.length : 0; // init deprecated field</span>
      }
  
<span class="line-added">+ </span>
      /**
       * @return Constant pool used by this object.
       */
      public final ConstantPool getConstantPool() {
          return constant_pool;
      }
  
<span class="line-added">+ </span>
      /**
       * @param constant_pool Constant pool to be used for this object.
       */
<span class="line-modified">!     public final void setConstantPool( final ConstantPool constant_pool ) {</span>
          this.constant_pool = constant_pool;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Index in constant pool of object&#39;s name.
       */
      public final int getNameIndex() {
          return name_index;
      }
  
<span class="line-added">+ </span>
      /**
       * @param name_index Index in constant pool of object&#39;s name.
       */
<span class="line-modified">!     public final void setNameIndex( final int name_index ) {</span>
          this.name_index = name_index;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Index in constant pool of field signature.
       */
      public final int getSignatureIndex() {
          return signature_index;
      }
  
<span class="line-added">+ </span>
      /**
       * @param signature_index Index in constant pool of field signature.
       */
<span class="line-modified">!     public final void setSignatureIndex( final int signature_index ) {</span>
          this.signature_index = signature_index;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Name of object, i.e., method name or field name
       */
      public final String getName() {
          ConstantUtf8 c;
          c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
          return c.getBytes();
      }
  
<span class="line-added">+ </span>
      /**
       * @return String representation of object&#39;s type signature (java style)
       */
      public final String getSignature() {
          ConstantUtf8 c;
          c = (ConstantUtf8) constant_pool.getConstant(signature_index, Const.CONSTANT_Utf8);
          return c.getBytes();
      }
  
<span class="line-added">+ </span>
      /**
       * @return deep copy of this field
       */
<span class="line-modified">!     protected FieldOrMethod copy_( final ConstantPool _constant_pool ) {</span>
          FieldOrMethod c = null;
  
          try {
<span class="line-modified">!           c = (FieldOrMethod)clone();</span>
<span class="line-modified">!         } catch(final CloneNotSupportedException e) {</span>
              // ignored, but will cause NPE ...
          }
  
<span class="line-modified">!         c.constant_pool    = constant_pool;</span>
<span class="line-modified">!         c.attributes       = new Attribute[attributes.length];</span>
<span class="line-modified">!         c.attributes_count = attributes_count; // init deprecated field</span>
  
<span class="line-modified">!         for (int i = 0; i &lt; attributes.length; i++) {</span>
              c.attributes[i] = attributes[i].copy(constant_pool);
          }
  
          return c;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,15 ***</span>
       * searches for the attribute only when requested - only searches for it
       * once.
       *
       * @since 6.0
       */
<span class="line-modified">!     public final String getGenericSignature() {</span>
<span class="line-modified">!         if (!searchedForSignatureAttribute) {</span>
              boolean found = false;
<span class="line-modified">!             for (int i = 0; !found &amp;&amp; i &lt; attributes.length; i++) {</span>
<span class="line-modified">!                 if (attributes[i] instanceof Signature) {</span>
                      signatureAttributeString = ((Signature) attributes[i])
                              .getSignature();
                      found = true;
                  }
              }
<span class="line-new-header">--- 257,19 ---</span>
       * searches for the attribute only when requested - only searches for it
       * once.
       *
       * @since 6.0
       */
<span class="line-modified">!     public final String getGenericSignature()</span>
<span class="line-modified">!     {</span>
<span class="line-added">+         if (!searchedForSignatureAttribute)</span>
<span class="line-added">+         {</span>
              boolean found = false;
<span class="line-modified">!             for (int i = 0; !found &amp;&amp; i &lt; attributes.length; i++)</span>
<span class="line-modified">!             {</span>
<span class="line-added">+                 if (attributes[i] instanceof Signature)</span>
<span class="line-added">+                 {</span>
                      signatureAttributeString = ((Signature) attributes[i])
                              .getSignature();
                      found = true;
                  }
              }
</pre>
<center><a href="Field.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InnerClass.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
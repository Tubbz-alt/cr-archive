<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/MethodGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.generic;
  21 
  22 import com.sun.org.apache.bcel.internal.Const;
  23 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
  24 import com.sun.org.apache.bcel.internal.classfile.Annotations;
  25 import com.sun.org.apache.bcel.internal.classfile.Attribute;
  26 import com.sun.org.apache.bcel.internal.classfile.Code;
  27 import com.sun.org.apache.bcel.internal.classfile.CodeException;
  28 import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;
  29 import com.sun.org.apache.bcel.internal.classfile.LineNumber;
  30 import com.sun.org.apache.bcel.internal.classfile.LineNumberTable;
  31 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
  32 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTable;
  33 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTypeTable;
  34 import com.sun.org.apache.bcel.internal.classfile.Method;
  35 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotationEntry;
  36 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotations;
  37 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
  38 import com.sun.org.apache.bcel.internal.classfile.Utility;
  39 import com.sun.org.apache.bcel.internal.util.BCELComparator;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
<a name="2" id="anc2"></a><span class="line-removed">  42 import java.util.Comparator;</span>
  43 import java.util.HashMap;
  44 import java.util.List;
  45 import java.util.Map;
<a name="3" id="anc3"></a>
  46 import java.util.Stack;
  47 
  48 /**
  49  * Template class for building up a method. This is done by defining exception
  50  * handlers, adding thrown exceptions, local variables and attributes, whereas
  51  * the `LocalVariableTable&#39; and `LineNumberTable&#39; attributes will be set
  52  * automatically for the code. Use stripAttributes() if you don&#39;t like this.
  53  *
  54  * While generating code it may be necessary to insert NOP operations. You can
<a name="4" id="anc4"></a><span class="line-modified">  55  * use the `removeNOPs&#39; method to get rid off them. The resulting method object</span>
<span class="line-modified">  56  * can be obtained via the `getMethod()&#39; method.</span>
  57  *
<a name="5" id="anc5"></a><span class="line-modified">  58  * @version $Id: MethodGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
<span class="line-modified">  59  * @see InstructionList</span>
<span class="line-modified">  60  * @see Method</span>
<span class="line-removed">  61  * @LastModified: Oct 2017</span>
  62  */
  63 public class MethodGen extends FieldGenOrMethodGen {
  64 
  65     private String class_name;
  66     private Type[] arg_types;
  67     private String[] arg_names;
  68     private int max_locals;
  69     private int max_stack;
  70     private InstructionList il;
  71     private boolean strip_attributes;
<a name="6" id="anc6"></a>
  72     private final List&lt;LocalVariableGen&gt; variable_vec = new ArrayList&lt;&gt;();
<a name="7" id="anc7"></a><span class="line-removed">  73     private final List&lt;LocalVariableGen&gt; type_vec = new ArrayList&lt;&gt;();</span>
  74     private final List&lt;LineNumberGen&gt; line_number_vec = new ArrayList&lt;&gt;();
  75     private final List&lt;CodeExceptionGen&gt; exception_vec = new ArrayList&lt;&gt;();
  76     private final List&lt;String&gt; throws_vec = new ArrayList&lt;&gt;();
  77     private final List&lt;Attribute&gt; code_attrs_vec = new ArrayList&lt;&gt;();
  78 
  79     private List&lt;AnnotationEntryGen&gt;[] param_annotations; // Array of lists containing AnnotationGen objects
  80     private boolean hasParameterAnnotations = false;
  81     private boolean haveUnpackedParameterAnnotations = false;
  82 
  83     private static BCELComparator bcelComparator = new BCELComparator() {
  84 
  85         @Override
<a name="8" id="anc8"></a><span class="line-modified">  86         public boolean equals(final Object o1, final Object o2) {</span>
  87             final MethodGen THIS = (MethodGen) o1;
  88             final MethodGen THAT = (MethodGen) o2;
<a name="9" id="anc9"></a><span class="line-modified">  89             return THIS.getName().equals(THAT.getName())</span>
<span class="line-modified">  90                     &amp;&amp; THIS.getSignature().equals(THAT.getSignature());</span>
  91         }
  92 
<a name="10" id="anc10"></a>
  93         @Override
<a name="11" id="anc11"></a><span class="line-modified">  94         public int hashCode(final Object o) {</span>
  95             final MethodGen THIS = (MethodGen) o;
  96             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
  97         }
  98     };
  99 
<a name="12" id="anc12"></a>
 100     /**
<a name="13" id="anc13"></a><span class="line-modified"> 101      * Declare method. If the method is non-static the constructor automatically</span>
<span class="line-modified"> 102      * declares a local variable `$this&#39; in slot 0. The actual code is contained</span>
<span class="line-modified"> 103      * in the `il&#39; parameter, which may further manipulated by the user. But he</span>
<span class="line-modified"> 104      * must take care not to remove any instruction (handles) that are still</span>
<span class="line-modified"> 105      * referenced from this object.</span>
 106      *
 107      * For example one may not add a local variable and later remove the
<a name="14" id="anc14"></a><span class="line-modified"> 108      * instructions it refers to without causing havoc. It is safe however if</span>
<span class="line-modified"> 109      * you remove that local variable, too.</span>
 110      *
 111      * @param access_flags access qualifiers
<a name="15" id="anc15"></a><span class="line-modified"> 112      * @param return_type method type</span>
 113      * @param arg_types argument types
<a name="16" id="anc16"></a><span class="line-modified"> 114      * @param arg_names argument names (if this is null, default names will be</span>
<span class="line-modified"> 115      * provided for them)</span>
 116      * @param method_name name of method
<a name="17" id="anc17"></a><span class="line-modified"> 117      * @param class_name class name containing this method (may be null, if you</span>
<span class="line-modified"> 118      * don&#39;t care)</span>
<span class="line-modified"> 119      * @param il instruction list associated with this method, may be null only</span>
<span class="line-removed"> 120      * for abstract or native methods</span>
 121      * @param cp constant pool
 122      */
 123     public MethodGen(final int access_flags, final Type return_type, final Type[] arg_types, String[] arg_names,
 124             final String method_name, final String class_name, final InstructionList il, final ConstantPoolGen cp) {
 125         super(access_flags);
 126         setType(return_type);
 127         setArgumentTypes(arg_types);
 128         setArgumentNames(arg_names);
 129         setName(method_name);
 130         setClassName(class_name);
 131         setInstructionList(il);
 132         setConstantPool(cp);
 133         final boolean abstract_ = isAbstract() || isNative();
 134         InstructionHandle start = null;
<a name="18" id="anc18"></a><span class="line-modified"> 135         InstructionHandle end = null;</span>
 136         if (!abstract_) {
 137             start = il.getStart();
<a name="19" id="anc19"></a><span class="line-modified"> 138             end = il.getEnd();</span>
 139             /* Add local variables, namely the implicit `this&#39; and the arguments
 140              */
 141             if (!isStatic() &amp;&amp; (class_name != null)) { // Instance method -&gt; `this&#39; is local var 0
<a name="20" id="anc20"></a><span class="line-modified"> 142                 addLocalVariable(&quot;this&quot;, ObjectType.getInstance(class_name), start, end);</span>
 143             }
 144         }
 145         if (arg_types != null) {
 146             final int size = arg_types.length;
 147             for (final Type arg_type : arg_types) {
 148                 if (Type.VOID == arg_type) {
 149                     throw new ClassGenException(&quot;&#39;void&#39; is an illegal argument type for a method&quot;);
 150                 }
 151             }
 152             if (arg_names != null) { // Names for variables provided?
 153                 if (size != arg_names.length) {
 154                     throw new ClassGenException(&quot;Mismatch in argument array lengths: &quot; + size
 155                             + &quot; vs. &quot; + arg_names.length);
 156                 }
 157             } else { // Give them dummy names
 158                 arg_names = new String[size];
 159                 for (int i = 0; i &lt; size; i++) {
 160                     arg_names[i] = &quot;arg&quot; + i;
 161                 }
 162                 setArgumentNames(arg_names);
 163             }
 164             if (!abstract_) {
 165                 for (int i = 0; i &lt; size; i++) {
 166                     addLocalVariable(arg_names[i], arg_types[i], start, end);
 167                 }
 168             }
 169         }
 170     }
 171 
<a name="21" id="anc21"></a>
 172     /**
 173      * Instantiate from existing method.
 174      *
 175      * @param m method
 176      * @param class_name class name containing this method
 177      * @param cp constant pool
 178      */
 179     public MethodGen(final Method m, final String class_name, final ConstantPoolGen cp) {
 180         this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
<a name="22" id="anc22"></a><span class="line-modified"> 181                 .getSignature()), null /* may be overridden anyway */, m.getName(), class_name,</span>

 182                 ((m.getAccessFlags() &amp; (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)
<a name="23" id="anc23"></a><span class="line-modified"> 183                 ? new InstructionList(m.getCode().getCode())</span>
<span class="line-modified"> 184                 : null, cp);</span>
 185         final Attribute[] attributes = m.getAttributes();
 186         for (final Attribute attribute : attributes) {
 187             Attribute a = attribute;
 188             if (a instanceof Code) {
 189                 final Code c = (Code) a;
 190                 setMaxStack(c.getMaxStack());
 191                 setMaxLocals(c.getMaxLocals());
 192                 final CodeException[] ces = c.getExceptionTable();
 193                 if (ces != null) {
 194                     for (final CodeException ce : ces) {
 195                         final int type = ce.getCatchType();
 196                         ObjectType c_type = null;
 197                         if (type &gt; 0) {
 198                             final String cen = m.getConstantPool().getConstantString(type,
 199                                     Const.CONSTANT_Class);
<a name="24" id="anc24"></a><span class="line-modified"> 200                             c_type = ObjectType.getInstance(cen);</span>
 201                         }
 202                         final int end_pc = ce.getEndPC();
 203                         final int length = m.getCode().getCode().length;
 204                         InstructionHandle end;
 205                         if (length == end_pc) { // May happen, because end_pc is exclusive
 206                             end = il.getEnd();
 207                         } else {
 208                             end = il.findHandle(end_pc);
 209                             end = end.getPrev(); // Make it inclusive
 210                         }
 211                         addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce
 212                                 .getHandlerPC()), c_type);
 213                     }
 214                 }
 215                 final Attribute[] c_attributes = c.getAttributes();
 216                 for (final Attribute c_attribute : c_attributes) {
 217                     a = c_attribute;
 218                     if (a instanceof LineNumberTable) {
 219                         final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();
 220                         for (final LineNumber l : ln) {
 221                             final InstructionHandle ih = il.findHandle(l.getStartPC());
 222                             if (ih != null) {
 223                                 addLineNumber(ih, l.getLineNumber());
 224                             }
 225                         }
 226                     } else if (a instanceof LocalVariableTable) {
<a name="25" id="anc25"></a><span class="line-modified"> 227                         final LocalVariable[] lv = ((LocalVariableTable) a).getLocalVariableTable();</span>
<span class="line-removed"> 228                         removeLocalVariables();</span>
<span class="line-removed"> 229                         repairHandles(lv, false);</span>
 230                     } else if (a instanceof LocalVariableTypeTable) {
<a name="26" id="anc26"></a><span class="line-modified"> 231                         LocalVariable[] lv = ((LocalVariableTypeTable) a).getLocalVariableTypeTable();</span>
<span class="line-removed"> 232                         removeLocalVariableTypes();</span>
<span class="line-removed"> 233                         repairHandles(lv, true);</span>
 234                     } else {
 235                         addCodeAttribute(a);
 236                     }
 237                 }
 238             } else if (a instanceof ExceptionTable) {
 239                 final String[] names = ((ExceptionTable) a).getExceptionNames();
 240                 for (final String name2 : names) {
 241                     addException(name2);
 242                 }
 243             } else if (a instanceof Annotations) {
 244                 final Annotations runtimeAnnotations = (Annotations) a;
 245                 final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();
 246                 for (final AnnotationEntry element : aes) {
 247                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));
 248                 }
 249             } else {
 250                 addAttribute(a);
 251             }
 252         }
 253     }
 254 
<a name="27" id="anc27"></a><span class="line-removed"> 255     private void repairHandles(final LocalVariable[] lv, boolean isLVT) {</span>
<span class="line-removed"> 256         for (int k = 0; k &lt; lv.length; k++) {</span>
<span class="line-removed"> 257             LocalVariable l = lv[k];</span>
<span class="line-removed"> 258             InstructionHandle start = il.findHandle(l.getStartPC());</span>
<span class="line-removed"> 259             InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());</span>
<span class="line-removed"> 260             // Repair malformed handles</span>
<span class="line-removed"> 261             if (null == start) {</span>
<span class="line-removed"> 262                 start = il.getStart();</span>
<span class="line-removed"> 263             }</span>
<span class="line-removed"> 264             if (null == end) {</span>
<span class="line-removed"> 265                 end = il.getEnd();</span>
<span class="line-removed"> 266             }</span>
<span class="line-removed"> 267             if (isLVT) {</span>
<span class="line-removed"> 268                 addLocalVariableType(l.getName(), Type.getType(l.getSignature()),</span>
<span class="line-removed"> 269                         l.getIndex(), start, end);</span>
<span class="line-removed"> 270             } else {</span>
<span class="line-removed"> 271                 addLocalVariable(l.getName(), Type.getType(l.getSignature()),</span>
<span class="line-removed"> 272                         l.getIndex(), start, end);</span>
<span class="line-removed"> 273             }</span>
<span class="line-removed"> 274         }</span>
<span class="line-removed"> 275     }</span>
<span class="line-removed"> 276 </span>
 277     /**
 278      * Adds a local variable to this method.
 279      *
 280      * @param name variable name
 281      * @param type variable type
<a name="28" id="anc28"></a><span class="line-modified"> 282      * @param slot the index of the local variable, if type is long or double,</span>
<span class="line-modified"> 283      * the next available index is slot+2</span>
 284      * @param start from where the variable is valid
 285      * @param end until where the variable is valid
<a name="29" id="anc29"></a>
 286      * @return new local variable object
 287      * @see LocalVariable
 288      */
<a name="30" id="anc30"></a><span class="line-modified"> 289     public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot,</span>
<span class="line-modified"> 290             final InstructionHandle start, final InstructionHandle end) {</span>
<span class="line-removed"> 291 </span>
 292         final byte t = type.getType();
 293         if (t != Const.T_ADDRESS) {
 294             final int add = type.getSize();
 295             if (slot + add &gt; max_locals) {
 296                 max_locals = slot + add;
 297             }
<a name="31" id="anc31"></a><span class="line-modified"> 298             final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end);</span>
 299             int i;
 300             if ((i = variable_vec.indexOf(l)) &gt;= 0) {
 301                 variable_vec.set(i, l);
 302             } else {
 303                 variable_vec.add(l);
 304             }
 305             return l;
 306         }
 307         throw new IllegalArgumentException(&quot;Can not use &quot; + type
 308                 + &quot; as type for local variable&quot;);
 309     }
 310 
<a name="32" id="anc32"></a>

















 311     /**
 312      * Adds a local variable to this method and assigns an index automatically.
 313      *
 314      * @param name variable name
 315      * @param type variable type
<a name="33" id="anc33"></a><span class="line-modified"> 316      * @param start from where the variable is valid, if this is null, it is</span>
<span class="line-modified"> 317      * valid from the start</span>
<span class="line-modified"> 318      * @param end until where the variable is valid, if this is null, it is</span>
<span class="line-modified"> 319      * valid to the end</span>
 320      * @return new local variable object
 321      * @see LocalVariable
 322      */
<a name="34" id="anc34"></a><span class="line-modified"> 323     public LocalVariableGen addLocalVariable(final String name, final Type type,</span>
<span class="line-modified"> 324             final InstructionHandle start, final InstructionHandle end) {</span>
 325         return addLocalVariable(name, type, max_locals, start, end);
 326     }
 327 
<a name="35" id="anc35"></a>
 328     /**
 329      * Remove a local variable, its slot will not be reused, if you do not use
 330      * addLocalVariable with an explicit index argument.
 331      */
 332     public void removeLocalVariable(final LocalVariableGen l) {
 333         variable_vec.remove(l);
 334     }
 335 
<a name="36" id="anc36"></a>
 336     /**
 337      * Remove all local variables.
 338      */
 339     public void removeLocalVariables() {
 340         variable_vec.clear();
 341     }
 342 
<a name="37" id="anc37"></a>
 343     /*
 344      * If the range of the variable has not been set yet, it will be set to be valid from
 345      * the start to the end of the instruction list.
 346      *
 347      * @return array of declared local variables sorted by index
 348      */
 349     public LocalVariableGen[] getLocalVariables() {
<a name="38" id="anc38"></a><span class="line-modified"> 350         return getLocalVariableOrTypes(false);</span>
<span class="line-modified"> 351     }</span>
<span class="line-modified"> 352 </span>
<span class="line-removed"> 353     /*</span>
<span class="line-removed"> 354      * If the range of the variable has not been set yet, it will be set to be</span>
<span class="line-removed"> 355      * valid from the start to the end of the instruction list.</span>
<span class="line-removed"> 356      *</span>
<span class="line-removed"> 357      * @return array of declared local variable types sorted by index</span>
<span class="line-removed"> 358      */</span>
<span class="line-removed"> 359     private LocalVariableGen[] getLocalVariableTypes() {</span>
<span class="line-removed"> 360         return getLocalVariableOrTypes(true);</span>
<span class="line-removed"> 361     }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363     /*</span>
<span class="line-removed"> 364      * If the range of the variable or type has not been set yet, it will be set</span>
<span class="line-removed"> 365      * to be valid from the start to the end of the instruction list.</span>
<span class="line-removed"> 366      *</span>
<span class="line-removed"> 367      * @return array of declared local variables or types sorted by index</span>
<span class="line-removed"> 368      */</span>
<span class="line-removed"> 369     private LocalVariableGen[] getLocalVariableOrTypes(boolean isLVT) {</span>
<span class="line-removed"> 370         int size = (isLVT) ? type_vec.size() : variable_vec.size();</span>
<span class="line-removed"> 371         LocalVariableGen[] lg = new LocalVariableGen[size];</span>
<span class="line-removed"> 372         if (isLVT) {</span>
<span class="line-removed"> 373             type_vec.toArray(lg);</span>
<span class="line-removed"> 374         } else {</span>
<span class="line-removed"> 375             variable_vec.toArray(lg);</span>
<span class="line-removed"> 376         }</span>
<span class="line-removed"> 377 </span>
 378         for (int i = 0; i &lt; size; i++) {
<a name="39" id="anc39"></a><span class="line-modified"> 379             if (lg[i].getStart() == null) {</span>
 380                 lg[i].setStart(il.getStart());
 381             }
<a name="40" id="anc40"></a><span class="line-modified"> 382 </span>
<span class="line-removed"> 383             if (lg[i].getEnd() == null) {</span>
 384                 lg[i].setEnd(il.getEnd());
 385             }
 386         }
<a name="41" id="anc41"></a><span class="line-removed"> 387 </span>
 388         if (size &gt; 1) {
<a name="42" id="anc42"></a><span class="line-modified"> 389             Arrays.sort(lg, new Comparator&lt;LocalVariableGen&gt;() {</span>
<span class="line-removed"> 390                 @Override</span>
<span class="line-removed"> 391                 public int compare(final LocalVariableGen o1, final LocalVariableGen o2) {</span>
<span class="line-removed"> 392                     return o1.getIndex() - o2.getIndex();</span>
<span class="line-removed"> 393                 }</span>
<span class="line-removed"> 394             });</span>
 395         }
<a name="43" id="anc43"></a><span class="line-removed"> 396 </span>
 397         return lg;
 398     }
 399 
<a name="44" id="anc44"></a>
 400     /**
<a name="45" id="anc45"></a><span class="line-modified"> 401      * @return `LocalVariableTable&#39; attribute of all the local variables of this</span>
<span class="line-removed"> 402      * method.</span>
 403      */
<a name="46" id="anc46"></a><span class="line-modified"> 404     public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {</span>
 405         final LocalVariableGen[] lg = getLocalVariables();
 406         final int size = lg.length;
 407         final LocalVariable[] lv = new LocalVariable[size];
 408         for (int i = 0; i &lt; size; i++) {
 409             lv[i] = lg[i].getLocalVariable(cp);
 410         }
 411         return new LocalVariableTable(cp.addUtf8(&quot;LocalVariableTable&quot;), 2 + lv.length * 10, lv, cp
 412                 .getConstantPool());
 413     }
 414 
 415     /**
<a name="47" id="anc47"></a><span class="line-modified"> 416      * @return `LocalVariableTypeTable&#39; attribute of all the local variable</span>
<span class="line-removed"> 417      * types of this method.</span>
 418      */
<a name="48" id="anc48"></a><span class="line-modified"> 419     public LocalVariableTypeTable getLocalVariableTypeTable(ConstantPoolGen cp) {</span>
<span class="line-modified"> 420         LocalVariableGen[] lg = getLocalVariableTypes();</span>
<span class="line-removed"> 421         int size = lg.length;</span>
<span class="line-removed"> 422         LocalVariable[] lv = new LocalVariable[size];</span>
<span class="line-removed"> 423 </span>
<span class="line-removed"> 424         for (int i = 0; i &lt; size; i++) {</span>
<span class="line-removed"> 425             lv[i] = lg[i].getLocalVariable(cp);</span>
<span class="line-removed"> 426         }</span>
<span class="line-removed"> 427 </span>
<span class="line-removed"> 428         return new LocalVariableTypeTable(cp.addUtf8(&quot;LocalVariableTypeTable&quot;),</span>
<span class="line-removed"> 429                 2 + lv.length * 10, lv, cp.getConstantPool());</span>
<span class="line-removed"> 430     }</span>
<span class="line-removed"> 431 </span>
<span class="line-removed"> 432     /**</span>
<span class="line-removed"> 433      * Adds a local variable type to this method.</span>
<span class="line-removed"> 434      *</span>
<span class="line-removed"> 435      * @param name variable name</span>
<span class="line-removed"> 436      * @param type variable type</span>
<span class="line-removed"> 437      * @param slot the index of the local variable, if type is long or double,</span>
<span class="line-removed"> 438      * the next available index is slot+2</span>
<span class="line-removed"> 439      * @param start from where the variable is valid</span>
<span class="line-removed"> 440      * @param end until where the variable is valid</span>
<span class="line-removed"> 441      * @return new local variable object</span>
<span class="line-removed"> 442      * @see LocalVariable</span>
<span class="line-removed"> 443      */</span>
<span class="line-removed"> 444     private LocalVariableGen addLocalVariableType(String name, Type type, int slot,</span>
<span class="line-removed"> 445             InstructionHandle start,</span>
<span class="line-removed"> 446             InstructionHandle end) {</span>
<span class="line-removed"> 447         byte t = type.getType();</span>
<span class="line-removed"> 448 </span>
<span class="line-removed"> 449         if (t != Const.T_ADDRESS) {</span>
<span class="line-removed"> 450             int add = type.getSize();</span>
<span class="line-removed"> 451 </span>
<span class="line-removed"> 452             if (slot + add &gt; max_locals) {</span>
<span class="line-removed"> 453                 max_locals = slot + add;</span>
<span class="line-removed"> 454             }</span>
<span class="line-removed"> 455 </span>
<span class="line-removed"> 456             LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end);</span>
<span class="line-removed"> 457             int i;</span>
<span class="line-removed"> 458 </span>
<span class="line-removed"> 459             if ((i = type_vec.indexOf(l)) &gt;= 0) // Overwrite if necessary</span>
<span class="line-removed"> 460             {</span>
<span class="line-removed"> 461                 type_vec.set(i, l);</span>
<span class="line-removed"> 462             } else {</span>
<span class="line-removed"> 463                 type_vec.add(l);</span>
<span class="line-removed"> 464             }</span>
<span class="line-removed"> 465 </span>
<span class="line-removed"> 466             return l;</span>
<span class="line-removed"> 467         } else {</span>
<span class="line-removed"> 468             throw new IllegalArgumentException(&quot;Can not use &quot; + type</span>
<span class="line-removed"> 469                     + &quot; as type for local variable&quot;);</span>
<span class="line-removed"> 470         }</span>
<span class="line-removed"> 471     }</span>
<span class="line-removed"> 472 </span>
<span class="line-removed"> 473     /**</span>
<span class="line-removed"> 474      * Remove all local variable types.</span>
<span class="line-removed"> 475      */</span>
<span class="line-removed"> 476     private void removeLocalVariableTypes() {</span>
<span class="line-removed"> 477         type_vec.clear();</span>
 478     }
 479 
 480     /**
 481      * Give an instruction a line number corresponding to the source code line.
 482      *
 483      * @param ih instruction to tag
 484      * @return new line number object
 485      * @see LineNumber
 486      */
<a name="49" id="anc49"></a><span class="line-modified"> 487     public LineNumberGen addLineNumber(final InstructionHandle ih, final int src_line) {</span>
 488         final LineNumberGen l = new LineNumberGen(ih, src_line);
 489         line_number_vec.add(l);
 490         return l;
 491     }
 492 
<a name="50" id="anc50"></a>
 493     /**
 494      * Remove a line number.
 495      */
<a name="51" id="anc51"></a><span class="line-modified"> 496     public void removeLineNumber(final LineNumberGen l) {</span>
 497         line_number_vec.remove(l);
 498     }
 499 
<a name="52" id="anc52"></a>
 500     /**
 501      * Remove all line numbers.
 502      */
 503     public void removeLineNumbers() {
 504         line_number_vec.clear();
 505     }
 506 
<a name="53" id="anc53"></a>
 507     /*
 508      * @return array of line numbers
 509      */
 510     public LineNumberGen[] getLineNumbers() {
 511         final LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
 512         line_number_vec.toArray(lg);
 513         return lg;
 514     }
 515 
<a name="54" id="anc54"></a>
 516     /**
<a name="55" id="anc55"></a><span class="line-modified"> 517      * @return `LineNumberTable&#39; attribute of all the local variables of this</span>
<span class="line-removed"> 518      * method.</span>
 519      */
<a name="56" id="anc56"></a><span class="line-modified"> 520     public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {</span>
 521         final int size = line_number_vec.size();
 522         final LineNumber[] ln = new LineNumber[size];
 523         for (int i = 0; i &lt; size; i++) {
 524             ln[i] = line_number_vec.get(i).getLineNumber();
 525         }
 526         return new LineNumberTable(cp.addUtf8(&quot;LineNumberTable&quot;), 2 + ln.length * 4, ln, cp
 527                 .getConstantPool());
 528     }
 529 
<a name="57" id="anc57"></a>
 530     /**
<a name="58" id="anc58"></a><span class="line-modified"> 531      * Add an exception handler, i.e., specify region where a handler is active</span>
<span class="line-modified"> 532      * and an instruction where the actual handling is done.</span>
 533      *
 534      * @param start_pc Start of region (inclusive)
 535      * @param end_pc End of region (inclusive)
 536      * @param handler_pc Where handling is done
 537      * @param catch_type class type of handled exception or null if any
 538      * exception is handled
 539      * @return new exception handler object
 540      */
<a name="59" id="anc59"></a><span class="line-modified"> 541     public CodeExceptionGen addExceptionHandler(final InstructionHandle start_pc,</span>
<span class="line-modified"> 542             final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type) {</span>
 543         if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
 544             throw new ClassGenException(&quot;Exception handler target is null instruction&quot;);
 545         }
 546         final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
 547         exception_vec.add(c);
 548         return c;
 549     }
 550 
<a name="60" id="anc60"></a>
 551     /**
 552      * Remove an exception handler.
 553      */
<a name="61" id="anc61"></a><span class="line-modified"> 554     public void removeExceptionHandler(final CodeExceptionGen c) {</span>
 555         exception_vec.remove(c);
 556     }
 557 
<a name="62" id="anc62"></a>
 558     /**
 559      * Remove all line numbers.
 560      */
 561     public void removeExceptionHandlers() {
 562         exception_vec.clear();
 563     }
 564 
<a name="63" id="anc63"></a>
 565     /*
 566      * @return array of declared exception handlers
 567      */
 568     public CodeExceptionGen[] getExceptionHandlers() {
 569         final CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
 570         exception_vec.toArray(cg);
 571         return cg;
 572     }
 573 
<a name="64" id="anc64"></a>
 574     /**
 575      * @return code exceptions for `Code&#39; attribute
 576      */
 577     private CodeException[] getCodeExceptions() {
 578         final int size = exception_vec.size();
 579         final CodeException[] c_exc = new CodeException[size];
 580         for (int i = 0; i &lt; size; i++) {
<a name="65" id="anc65"></a><span class="line-modified"> 581             final CodeExceptionGen c = exception_vec.get(i);</span>
 582             c_exc[i] = c.getCodeException(super.getConstantPool());
 583         }
 584         return c_exc;
 585     }
 586 
<a name="66" id="anc66"></a>
 587     /**
 588      * Add an exception possibly thrown by this method.
 589      *
 590      * @param class_name (fully qualified) name of exception
 591      */
<a name="67" id="anc67"></a><span class="line-modified"> 592     public void addException(final String class_name) {</span>
 593         throws_vec.add(class_name);
 594     }
 595 
<a name="68" id="anc68"></a>
 596     /**
 597      * Remove an exception.
 598      */
<a name="69" id="anc69"></a><span class="line-modified"> 599     public void removeException(final String c) {</span>
 600         throws_vec.remove(c);
 601     }
 602 
<a name="70" id="anc70"></a>
 603     /**
 604      * Remove all exceptions.
 605      */
 606     public void removeExceptions() {
 607         throws_vec.clear();
 608     }
 609 
<a name="71" id="anc71"></a>
 610     /*
 611      * @return array of thrown exceptions
 612      */
 613     public String[] getExceptions() {
 614         final String[] e = new String[throws_vec.size()];
 615         throws_vec.toArray(e);
 616         return e;
 617     }
 618 
<a name="72" id="anc72"></a>
 619     /**
<a name="73" id="anc73"></a><span class="line-modified"> 620      * @return `Exceptions&#39; attribute of all the exceptions thrown by this</span>
<span class="line-removed"> 621      * method.</span>
 622      */
<a name="74" id="anc74"></a><span class="line-modified"> 623     private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {</span>
 624         final int size = throws_vec.size();
 625         final int[] ex = new int[size];
 626         for (int i = 0; i &lt; size; i++) {
 627             ex[i] = cp.addClass(throws_vec.get(i));
 628         }
 629         return new ExceptionTable(cp.addUtf8(&quot;Exceptions&quot;), 2 + 2 * size, ex, cp.getConstantPool());
 630     }
 631 
<a name="75" id="anc75"></a>
 632     /**
 633      * Add an attribute to the code. Currently, the JVM knows about the
<a name="76" id="anc76"></a><span class="line-modified"> 634      * LineNumberTable, LocalVariableTable and StackMap attributes, where the</span>
<span class="line-modified"> 635      * former two will be generated automatically and the latter is used for the</span>
<span class="line-modified"> 636      * MIDP only. Other attributes will be ignored by the JVM but do no harm.</span>

 637      *
 638      * @param a attribute to be added
 639      */
<a name="77" id="anc77"></a><span class="line-modified"> 640     public void addCodeAttribute(final Attribute a) {</span>
 641         code_attrs_vec.add(a);
 642     }
 643 
<a name="78" id="anc78"></a>







 644     /**
 645      * Remove a code attribute.
 646      */
<a name="79" id="anc79"></a><span class="line-modified"> 647     public void removeCodeAttribute(final Attribute a) {</span>
 648         code_attrs_vec.remove(a);
 649     }
 650 
<a name="80" id="anc80"></a>
 651     /**
 652      * Remove all code attributes.
 653      */
 654     public void removeCodeAttributes() {
<a name="81" id="anc81"></a>
 655         code_attrs_vec.clear();
 656     }
 657 
<a name="82" id="anc82"></a>
 658     /**
 659      * @return all attributes of this method.
 660      */
 661     public Attribute[] getCodeAttributes() {
 662         final Attribute[] attributes = new Attribute[code_attrs_vec.size()];
 663         code_attrs_vec.toArray(attributes);
 664         return attributes;
 665     }
 666 
 667     /**
 668      * @since 6.0
 669      */
 670     public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<a name="83" id="anc83"></a><span class="line-modified"> 671         final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
 672         for (final Attribute attr : attrs) {
 673             addAttribute(attr);
 674         }
<a name="84" id="anc84"></a><span class="line-modified"> 675     }</span>
 676 
 677     /**
 678      * @since 6.0
 679      */
<a name="85" id="anc85"></a><span class="line-modified"> 680     public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {</span>
<span class="line-modified"> 681         if (!hasParameterAnnotations) {</span>
<span class="line-modified"> 682             return;</span>
<span class="line-modified"> 683         }</span>
<span class="line-modified"> 684         final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, param_annotations);</span>
<span class="line-modified"> 685         if (attrs != null) {</span>
<span class="line-modified"> 686             for (final Attribute attr : attrs) {</span>
<span class="line-modified"> 687                 addAttribute(attr);</span>
<span class="line-modified"> 688             }</span>
<span class="line-modified"> 689         }</span>
<span class="line-modified"> 690     }</span>

 691 
 692     /**
<a name="86" id="anc86"></a><span class="line-modified"> 693      * Get method object. Never forget to call setMaxStack() or</span>
<span class="line-modified"> 694      * setMaxStack(max), respectively, before calling this method (the same</span>
<span class="line-removed"> 695      * applies for max locals).</span>
 696      *
 697      * @return method object
 698      */
 699     public Method getMethod() {
 700         final String signature = getSignature();
 701         final ConstantPoolGen _cp = super.getConstantPool();
 702         final int name_index = _cp.addUtf8(super.getName());
 703         final int signature_index = _cp.addUtf8(signature);
 704         /* Also updates positions of instructions, i.e., their indices
 705          */
 706         byte[] byte_code = null;
 707         if (il != null) {
 708             byte_code = il.getByteCode();
 709         }
 710         LineNumberTable lnt = null;
 711         LocalVariableTable lvt = null;
<a name="87" id="anc87"></a><span class="line-modified"> 712         LocalVariableTypeTable lvtt = null;</span>
<span class="line-removed"> 713 </span>
<span class="line-removed"> 714         /* Create LocalVariableTable, LocalvariableTypeTable, and LineNumberTable</span>
<span class="line-removed"> 715          * attributes (for debuggers, e.g.)</span>
 716          */
 717         if ((variable_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
<a name="88" id="anc88"></a>
 718             addCodeAttribute(lvt = getLocalVariableTable(_cp));
 719         }
<a name="89" id="anc89"></a><span class="line-modified"> 720 </span>
<span class="line-modified"> 721         if ((type_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {</span>
<span class="line-modified"> 722             addCodeAttribute(lvtt = getLocalVariableTypeTable(_cp));</span>



 723         }
<a name="90" id="anc90"></a><span class="line-removed"> 724 </span>
 725         if ((line_number_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
 726             addCodeAttribute(lnt = getLineNumberTable(_cp));
 727         }
 728         final Attribute[] code_attrs = getCodeAttributes();
 729         /* Each attribute causes 6 additional header bytes
 730          */
 731         int attrs_len = 0;
 732         for (final Attribute code_attr : code_attrs) {
 733             attrs_len += code_attr.getLength() + 6;
 734         }
 735         final CodeException[] c_exc = getCodeExceptions();
 736         final int exc_len = c_exc.length * 8; // Every entry takes 8 bytes
 737         Code code = null;
 738         if ((il != null) &amp;&amp; !isAbstract() &amp;&amp; !isNative()) {
 739             // Remove any stale code attribute
 740             final Attribute[] attributes = getAttributes();
 741             for (final Attribute a : attributes) {
 742                 if (a instanceof Code) {
 743                     removeAttribute(a);
 744                 }
 745             }
 746             code = new Code(_cp.addUtf8(&quot;Code&quot;), 8 + byte_code.length + // prologue byte code
 747                     2 + exc_len + // exceptions
 748                     2 + attrs_len, // attributes
 749                     max_stack, max_locals, byte_code, c_exc, code_attrs, _cp.getConstantPool());
 750             addAttribute(code);
 751         }
 752         addAnnotationsAsAttribute(_cp);
 753         addParameterAnnotationsAsAttribute(_cp);
 754         ExceptionTable et = null;
 755         if (throws_vec.size() &gt; 0) {
 756             addAttribute(et = getExceptionTable(_cp));
 757             // Add `Exceptions&#39; if there are &quot;throws&quot; clauses
 758         }
 759         final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp
 760                 .getConstantPool());
 761         // Undo effects of adding attributes
 762         if (lvt != null) {
 763             removeCodeAttribute(lvt);
 764         }
<a name="91" id="anc91"></a><span class="line-modified"> 765         if (lvtt != null) {</span>
<span class="line-modified"> 766             removeCodeAttribute(lvtt);</span>
 767         }
 768         if (lnt != null) {
 769             removeCodeAttribute(lnt);
 770         }
 771         if (code != null) {
 772             removeAttribute(code);
 773         }
 774         if (et != null) {
 775             removeAttribute(et);
 776         }
 777         return m;
 778     }
 779 
<a name="92" id="anc92"></a>


































 780     /**
 781      * Remove all NOPs from the instruction list (if possible) and update every
 782      * object referring to them, i.e., branch instructions, local variables and
 783      * exception handlers.
 784      */
 785     public void removeNOPs() {
 786         if (il != null) {
 787             InstructionHandle next;
 788             /* Check branch instructions.
 789              */
 790             for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {
 791                 next = ih.getNext();
 792                 if ((next != null) &amp;&amp; (ih.getInstruction() instanceof NOP)) {
 793                     try {
 794                         il.delete(ih);
 795                     } catch (final TargetLostException e) {
 796                         for (final InstructionHandle target : e.getTargets()) {
 797                             for (final InstructionTargeter targeter : target.getTargeters()) {
 798                                 targeter.updateTarget(target, next);
 799                             }
 800                         }
 801                     }
 802                 }
 803             }
 804         }
 805     }
 806 
<a name="93" id="anc93"></a>
 807     /**
 808      * Set maximum number of local variables.
 809      */
<a name="94" id="anc94"></a><span class="line-modified"> 810     public void setMaxLocals(final int m) {</span>
 811         max_locals = m;
 812     }
 813 
<a name="95" id="anc95"></a>
 814     public int getMaxLocals() {
 815         return max_locals;
 816     }
 817 
<a name="96" id="anc96"></a>
 818     /**
 819      * Set maximum stack size for this method.
 820      */
<a name="97" id="anc97"></a><span class="line-modified"> 821     public void setMaxStack(final int m) { // TODO could be package-protected?</span>
 822         max_stack = m;
 823     }
 824 
<a name="98" id="anc98"></a>
 825     public int getMaxStack() {
 826         return max_stack;
 827     }
 828 
<a name="99" id="anc99"></a><span class="line-modified"> 829     /**</span>
<span class="line-modified"> 830      * @return class that contains this method</span>
 831      */
 832     public String getClassName() {
 833         return class_name;
 834     }
 835 
<a name="100" id="anc100"></a><span class="line-modified"> 836     public void setClassName(final String class_name) { // TODO could be package-protected?</span>

 837         this.class_name = class_name;
 838     }
 839 
<a name="101" id="anc101"></a><span class="line-modified"> 840     public void setReturnType(final Type return_type) {</span>

 841         setType(return_type);
 842     }
 843 
<a name="102" id="anc102"></a>
 844     public Type getReturnType() {
 845         return getType();
 846     }
 847 
<a name="103" id="anc103"></a><span class="line-modified"> 848     public void setArgumentTypes(final Type[] arg_types) {</span>

 849         this.arg_types = arg_types;
 850     }
 851 
<a name="104" id="anc104"></a>
 852     public Type[] getArgumentTypes() {
 853         return arg_types.clone();
 854     }
 855 
<a name="105" id="anc105"></a><span class="line-modified"> 856     public void setArgumentType(final int i, final Type type) {</span>

 857         arg_types[i] = type;
 858     }
 859 
<a name="106" id="anc106"></a><span class="line-modified"> 860     public Type getArgumentType(final int i) {</span>

 861         return arg_types[i];
 862     }
 863 
<a name="107" id="anc107"></a><span class="line-modified"> 864     public void setArgumentNames(final String[] arg_names) {</span>

 865         this.arg_names = arg_names;
 866     }
 867 
<a name="108" id="anc108"></a>
 868     public String[] getArgumentNames() {
 869         return arg_names.clone();
 870     }
 871 
<a name="109" id="anc109"></a><span class="line-modified"> 872     public void setArgumentName(final int i, final String name) {</span>

 873         arg_names[i] = name;
 874     }
 875 
<a name="110" id="anc110"></a><span class="line-modified"> 876     public String getArgumentName(final int i) {</span>

 877         return arg_names[i];
 878     }
 879 
<a name="111" id="anc111"></a>
 880     public InstructionList getInstructionList() {
 881         return il;
 882     }
 883 
<a name="112" id="anc112"></a><span class="line-modified"> 884     public void setInstructionList(final InstructionList il) { // TODO could be package-protected?</span>

 885         this.il = il;
 886     }
 887 
<a name="113" id="anc113"></a>
 888     @Override
 889     public String getSignature() {
 890         return Type.getMethodSignature(super.getType(), arg_types);
 891     }
 892 
<a name="114" id="anc114"></a>
 893     /**
 894      * Computes max. stack size by performing control flow analysis.
 895      */
 896     public void setMaxStack() { // TODO could be package-protected? (some tests would need repackaging)
 897         if (il != null) {
 898             max_stack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());
 899         } else {
 900             max_stack = 0;
 901         }
 902     }
 903 
<a name="115" id="anc115"></a>
 904     /**
 905      * Compute maximum number of local variables.
 906      */
 907     public void setMaxLocals() { // TODO could be package-protected? (some tests would need repackaging)
 908         if (il != null) {
 909             int max = isStatic() ? 0 : 1;
 910             if (arg_types != null) {
 911                 for (final Type arg_type : arg_types) {
 912                     max += arg_type.getSize();
 913                 }
 914             }
 915             for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
 916                 final Instruction ins = ih.getInstruction();
 917                 if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)
 918                         || (ins instanceof IINC)) {
 919                     final int index = ((IndexedInstruction) ins).getIndex()
 920                             + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();
 921                     if (index &gt; max) {
 922                         max = index;
 923                     }
 924                 }
 925             }
 926             max_locals = max;
 927         } else {
 928             max_locals = 0;
 929         }
 930     }
 931 
<a name="116" id="anc116"></a><span class="line-modified"> 932     /**</span>
<span class="line-modified"> 933      * Do not/Do produce attributes code attributesLineNumberTable and</span>
 934      * LocalVariableTable, like javac -O
 935      */
<a name="117" id="anc117"></a><span class="line-modified"> 936     public void stripAttributes(final boolean flag) {</span>
 937         strip_attributes = flag;
 938     }
 939 
 940     static final class BranchTarget {
 941 
 942         final InstructionHandle target;
 943         final int stackDepth;
 944 
<a name="118" id="anc118"></a>
 945         BranchTarget(final InstructionHandle target, final int stackDepth) {
 946             this.target = target;
 947             this.stackDepth = stackDepth;
 948         }
 949     }
 950 
 951     static final class BranchStack {
 952 
 953         private final Stack&lt;BranchTarget&gt; branchTargets = new Stack&lt;&gt;();
 954         private final Map&lt;InstructionHandle, BranchTarget&gt; visitedTargets = new HashMap&lt;&gt;();
 955 
<a name="119" id="anc119"></a><span class="line-modified"> 956         public void push(final InstructionHandle target, final int stackDepth) {</span>

 957             if (visited(target)) {
 958                 return;
 959             }
 960             branchTargets.push(visit(target, stackDepth));
 961         }
 962 
<a name="120" id="anc120"></a>
 963         public BranchTarget pop() {
 964             if (!branchTargets.empty()) {
 965                 final BranchTarget bt = branchTargets.pop();
 966                 return bt;
 967             }
 968             return null;
 969         }
 970 
<a name="121" id="anc121"></a><span class="line-modified"> 971         private BranchTarget visit(final InstructionHandle target, final int stackDepth) {</span>

 972             final BranchTarget bt = new BranchTarget(target, stackDepth);
 973             visitedTargets.put(target, bt);
 974             return bt;
 975         }
 976 
<a name="122" id="anc122"></a><span class="line-modified"> 977         private boolean visited(final InstructionHandle target) {</span>

 978             return visitedTargets.get(target) != null;
 979         }
 980     }
 981 
<a name="123" id="anc123"></a>
 982     /**
<a name="124" id="anc124"></a><span class="line-modified"> 983      * Computes stack usage of an instruction list by performing control flow</span>
<span class="line-removed"> 984      * analysis.</span>
 985      *
 986      * @return maximum stack depth used by method
 987      */
<a name="125" id="anc125"></a><span class="line-modified"> 988     public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il,</span>
<span class="line-removed"> 989             final CodeExceptionGen[] et) {</span>
 990         final BranchStack branchTargets = new BranchStack();
 991         /* Initially, populate the branch stack with the exception
 992          * handlers, because these aren&#39;t (necessarily) branched to
 993          * explicitly. in each case, the stack will have depth 1,
 994          * containing the exception object.
 995          */
 996         for (final CodeExceptionGen element : et) {
 997             final InstructionHandle handler_pc = element.getHandlerPC();
 998             if (handler_pc != null) {
 999                 branchTargets.push(handler_pc, 1);
1000             }
1001         }
1002         int stackDepth = 0;
1003         int maxStackDepth = 0;
1004         InstructionHandle ih = il.getStart();
1005         while (ih != null) {
1006             final Instruction instruction = ih.getInstruction();
1007             final short opcode = instruction.getOpcode();
1008             final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);
1009             stackDepth += delta;
1010             if (stackDepth &gt; maxStackDepth) {
1011                 maxStackDepth = stackDepth;
1012             }
1013             // choose the next instruction based on whether current is a branch.
1014             if (instruction instanceof BranchInstruction) {
1015                 final BranchInstruction branch = (BranchInstruction) instruction;
1016                 if (instruction instanceof Select) {
1017                     // explore all of the select&#39;s targets. the default target is handled below.
1018                     final Select select = (Select) branch;
1019                     final InstructionHandle[] targets = select.getTargets();
1020                     for (final InstructionHandle target : targets) {
1021                         branchTargets.push(target, stackDepth);
1022                     }
1023                     // nothing to fall through to.
1024                     ih = null;
1025                 } else if (!(branch instanceof IfInstruction)) {
1026                     // if an instruction that comes back to following PC,
1027                     // push next instruction, with stack depth reduced by 1.
1028                     if (opcode == Const.JSR || opcode == Const.JSR_W) {
1029                         branchTargets.push(ih.getNext(), stackDepth - 1);
1030                     }
1031                     ih = null;
1032                 }
1033                 // for all branches, the target of the branch is pushed on the branch stack.
1034                 // conditional branches have a fall through case, selects don&#39;t, and
1035                 // jsr/jsr_w return to the next instruction.
1036                 branchTargets.push(branch.getTarget(), stackDepth);
1037             } else {
1038                 // check for instructions that terminate the method.
1039                 if (opcode == Const.ATHROW || opcode == Const.RET
1040                         || (opcode &gt;= Const.IRETURN &amp;&amp; opcode &lt;= Const.RETURN)) {
1041                     ih = null;
1042                 }
1043             }
1044             // normal case, go to the next instruction.
1045             if (ih != null) {
1046                 ih = ih.getNext();
1047             }
1048             // if we have no more instructions, see if there are any deferred branches to explore.
1049             if (ih == null) {
1050                 final BranchTarget bt = branchTargets.pop();
1051                 if (bt != null) {
1052                     ih = bt.target;
1053                     stackDepth = bt.stackDepth;
1054                 }
1055             }
1056         }
1057         return maxStackDepth;
1058     }
1059 
1060     private List&lt;MethodObserver&gt; observers;
1061 
<a name="126" id="anc126"></a><span class="line-modified">1062     /**</span>
<span class="line-modified">1063      * Add observer for this object.</span>
1064      */
<a name="127" id="anc127"></a><span class="line-modified">1065     public void addObserver(final MethodObserver o) {</span>
1066         if (observers == null) {
1067             observers = new ArrayList&lt;&gt;();
1068         }
1069         observers.add(o);
1070     }
1071 
<a name="128" id="anc128"></a><span class="line-modified">1072     /**</span>
<span class="line-modified">1073      * Remove observer for this object.</span>
1074      */
<a name="129" id="anc129"></a><span class="line-modified">1075     public void removeObserver(final MethodObserver o) {</span>
1076         if (observers != null) {
1077             observers.remove(o);
1078         }
1079     }
1080 
<a name="130" id="anc130"></a><span class="line-modified">1081     /**</span>
<span class="line-modified">1082      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">1083      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">1084      * user after he has finished editing the object.</span>
1085      */
1086     public void update() {
1087         if (observers != null) {
1088             for (final MethodObserver observer : observers) {
1089                 observer.notify(this);
1090             }
1091         }
1092     }
1093 
<a name="131" id="anc131"></a>
1094     /**
<a name="132" id="anc132"></a><span class="line-modified">1095      * Return string representation close to declaration format, e.g. public</span>
<span class="line-modified">1096      * static void main(String[]) throws IOException&#39;</span>
1097      *
1098      * @return String representation of the method.
1099      */
1100     @Override
1101     public final String toString() {
1102         final String access = Utility.accessToString(super.getAccessFlags());
1103         String signature = Type.getMethodSignature(super.getType(), arg_types);
1104         signature = Utility.methodSignatureToString(signature, super.getName(), access, true,
1105                 getLocalVariableTable(super.getConstantPool()));
1106         final StringBuilder buf = new StringBuilder(signature);
1107         for (final Attribute a : getAttributes()) {
1108             if (!((a instanceof Code) || (a instanceof ExceptionTable))) {
1109                 buf.append(&quot; [&quot;).append(a).append(&quot;]&quot;);
1110             }
1111         }
1112 
1113         if (throws_vec.size() &gt; 0) {
1114             for (final String throwsDescriptor : throws_vec) {
1115                 buf.append(&quot;\n\t\tthrows &quot;).append(throwsDescriptor);
1116             }
1117         }
1118         return buf.toString();
1119     }
1120 
<a name="133" id="anc133"></a><span class="line-modified">1121     /**</span>
<span class="line-modified">1122      * @return deep copy of this method</span>
1123      */
<a name="134" id="anc134"></a><span class="line-modified">1124     public MethodGen copy(final String class_name, final ConstantPoolGen cp) {</span>
1125         final Method m = ((MethodGen) clone()).getMethod();
1126         final MethodGen mg = new MethodGen(m, class_name, super.getConstantPool());
1127         if (super.getConstantPool() != cp) {
1128             mg.setConstantPool(cp);
1129             mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);
1130         }
1131         return mg;
1132     }
1133 
1134     //J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
1135     // is more likely to suggest to the caller it is readonly (which a List does not).
1136     /**
1137      * Return a list of AnnotationGen objects representing parameter annotations
<a name="135" id="anc135"></a><span class="line-removed">1138      *</span>
1139      * @since 6.0
1140      */
1141     public List&lt;AnnotationEntryGen&gt; getAnnotationsOnParameter(final int i) {
1142         ensureExistingParameterAnnotationsUnpacked();
1143         if (!hasParameterAnnotations || i &gt; arg_types.length) {
1144             return null;
1145         }
1146         return param_annotations[i];
1147     }
1148 
1149     /**
1150      * Goes through the attributes on the method and identifies any that are
1151      * RuntimeParameterAnnotations, extracting their contents and storing them
1152      * as parameter annotations. There are two kinds of parameter annotation -
1153      * visible and invisible. Once they have been unpacked, these attributes are
1154      * deleted. (The annotations will be rebuilt as attributes when someone
1155      * builds a Method object out of this MethodGen object).
1156      */
<a name="136" id="anc136"></a><span class="line-modified">1157     private void ensureExistingParameterAnnotationsUnpacked() {</span>

1158         if (haveUnpackedParameterAnnotations) {
1159             return;
1160         }
1161         // Find attributes that contain parameter annotation data
1162         final Attribute[] attrs = getAttributes();
1163         ParameterAnnotations paramAnnVisAttr = null;
1164         ParameterAnnotations paramAnnInvisAttr = null;
1165         for (final Attribute attribute : attrs) {
<a name="137" id="anc137"></a><span class="line-modified">1166             if (attribute instanceof ParameterAnnotations) {</span>

1167                 // Initialize param_annotations
<a name="138" id="anc138"></a><span class="line-modified">1168                 if (!hasParameterAnnotations) {</span>

1169                     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1170                     final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1171                     param_annotations = parmList;
1172                     for (int j = 0; j &lt; arg_types.length; j++) {
1173                         param_annotations[j] = new ArrayList&lt;&gt;();
1174                     }
1175                 }
1176                 hasParameterAnnotations = true;
1177                 final ParameterAnnotations rpa = (ParameterAnnotations) attribute;
1178                 if (rpa instanceof RuntimeVisibleParameterAnnotations) {
1179                     paramAnnVisAttr = rpa;
1180                 } else {
1181                     paramAnnInvisAttr = rpa;
1182                 }
<a name="139" id="anc139"></a><span class="line-modified">1183                 for (int j = 0; j &lt; arg_types.length; j++) {</span>


1184                     // This returns Annotation[] ...
<a name="140" id="anc140"></a><span class="line-modified">1185                     final ParameterAnnotationEntry immutableArray = rpa</span>
<span class="line-removed">1186                             .getParameterAnnotationEntries()[j];</span>
1187                     // ... which needs transforming into an AnnotationGen[] ...
<a name="141" id="anc141"></a><span class="line-modified">1188                     final List&lt;AnnotationEntryGen&gt; mutable</span>
<span class="line-removed">1189                             = makeMutableVersion(immutableArray.getAnnotationEntries());</span>
1190                     // ... then add these to any we already know about
1191                     param_annotations[j].addAll(mutable);
1192                 }
1193             }
1194         }
1195         if (paramAnnVisAttr != null) {
1196             removeAttribute(paramAnnVisAttr);
1197         }
1198         if (paramAnnInvisAttr != null) {
1199             removeAttribute(paramAnnInvisAttr);
1200         }
1201         haveUnpackedParameterAnnotations = true;
1202     }
1203 
<a name="142" id="anc142"></a><span class="line-modified">1204     private List&lt;AnnotationEntryGen&gt; makeMutableVersion(final AnnotationEntry[] mutableArray) {</span>

1205         final List&lt;AnnotationEntryGen&gt; result = new ArrayList&lt;&gt;();
1206         for (final AnnotationEntry element : mutableArray) {
1207             result.add(new AnnotationEntryGen(element, getConstantPool(),
1208                     false));
1209         }
1210         return result;
1211     }
1212 
1213     public void addParameterAnnotation(final int parameterIndex,
<a name="143" id="anc143"></a><span class="line-modified">1214             final AnnotationEntryGen annotation) {</span>

1215         ensureExistingParameterAnnotationsUnpacked();
<a name="144" id="anc144"></a><span class="line-modified">1216         if (!hasParameterAnnotations) {</span>

1217             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1218             final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1219             param_annotations = parmList;
1220             hasParameterAnnotations = true;
1221         }
1222         final List&lt;AnnotationEntryGen&gt; existingAnnotations = param_annotations[parameterIndex];
<a name="145" id="anc145"></a><span class="line-modified">1223         if (existingAnnotations != null) {</span>

1224             existingAnnotations.add(annotation);
<a name="146" id="anc146"></a><span class="line-modified">1225         } else {</span>


1226             final List&lt;AnnotationEntryGen&gt; l = new ArrayList&lt;&gt;();
1227             l.add(annotation);
1228             param_annotations[parameterIndex] = l;
1229         }
1230     }
1231 
1232     /**
1233      * @return Comparison strategy object
1234      */
1235     public static BCELComparator getComparator() {
1236         return bcelComparator;
1237     }
1238 
<a name="147" id="anc147"></a>
1239     /**
1240      * @param comparator Comparison strategy object
1241      */
<a name="148" id="anc148"></a><span class="line-modified">1242     public static void setComparator(final BCELComparator comparator) {</span>
1243         bcelComparator = comparator;
1244     }
1245 
<a name="149" id="anc149"></a>
1246     /**
<a name="150" id="anc150"></a><span class="line-modified">1247      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">1248      * MethodGen objects are said to be equal when their names and signatures</span>
<span class="line-modified">1249      * are equal.</span>
1250      *
1251      * @see java.lang.Object#equals(java.lang.Object)
1252      */
1253     @Override
<a name="151" id="anc151"></a><span class="line-modified">1254     public boolean equals(final Object obj) {</span>
1255         return bcelComparator.equals(this, obj);
1256     }
1257 
<a name="152" id="anc152"></a>
1258     /**
<a name="153" id="anc153"></a><span class="line-modified">1259      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">1260      * return the hashcode of the method&#39;s name XOR signature.</span>
1261      *
1262      * @see java.lang.Object#hashCode()
1263      */
1264     @Override
1265     public int hashCode() {
1266         return bcelComparator.hashCode(this);
1267     }
1268 }
<a name="154" id="anc154"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="154" type="hidden" />
</body>
</html>
diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionList.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionList.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionList.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionList.java
@@ -1,9 +1,9 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
-/*
+ /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
@@ -42,16 +42,17 @@
  * controlled way.
  *
  * A list is finally dumped to a byte code array with <a
  * href="#getByteCode()">getByteCode</a>.
  *
- * @version $Id: InstructionList.java 1749603 2016-06-21 20:50:19Z ggregory $
  * @see Instruction
  * @see InstructionHandle
  * @see BranchHandle
+ * @LastModified: Jan 2020
  */
 public class InstructionList implements Iterable<InstructionHandle> {
+
     private InstructionHandle start = null;
     private InstructionHandle end = null;
     private int length = 0; // number of elements in list
     private int[] byte_positions; // byte code offsets corresponding to instructions
 
@@ -62,30 +63,33 @@
     }
 
     /**
      * Create instruction list containing one instruction.
      *
-     * @param i initial instruction
+     * @param i
+     *            initial instruction
      */
     public InstructionList(final Instruction i) {
         append(i);
     }
 
     /**
      * Create instruction list containing one instruction.
      *
-     * @param i initial instruction
+     * @param i
+     *            initial instruction
      */
     public InstructionList(final BranchInstruction i) {
         append(i);
     }
 
     /**
      * Initialize list with (nonnull) compound instruction. Consumes argument
      * list, i.e., it becomes empty.
      *
-     * @param c compound instruction (list)
+     * @param c
+     *            compound instruction (list)
      */
     public InstructionList(final CompoundInstruction c) {
         append(c.getInstructionList());
     }
 
@@ -98,25 +102,29 @@
 
     /**
      * Find the target instruction (handle) that corresponds to the given target
      * position (byte code offset).
      *
-     * @param ihs array of instruction handles, i.e. il.getInstructionHandles()
-     * @param pos array of positions corresponding to ihs, i.e.
-     * il.getInstructionPositions()
-     * @param count length of arrays
-     * @param target target position to search for
+     * @param ihs
+     *            array of instruction handles, i.e. il.getInstructionHandles()
+     * @param pos
+     *            array of positions corresponding to ihs, i.e. il.getInstructionPositions()
+     * @param count
+     *            length of arrays
+     * @param target
+     *            target position to search for
      * @return target position's instruction handle if available
      */
-    public static InstructionHandle findHandle(final InstructionHandle[] ihs, final int[] pos, final int count, final int target) {
+    public static InstructionHandle findHandle(final InstructionHandle[] ihs,
+            final int[] pos, final int count, final int target) {
         int l = 0;
         int r = count - 1;
         /*
          * Do a binary search since the pos array is orderd.
          */
         do {
-            final int i = (l + r) / 2;
+            final int i = (l + r) >>> 1;
             final int j = pos[i];
             if (j == target) {
                 return ihs[i];
             } else if (target < j) {
                 r = i - 1;
@@ -130,11 +138,12 @@
     /**
      * Get instruction handle for instruction at byte code position pos. This
      * only works properly, if the list is freshly initialized from a byte array
      * or setPositions() has been called before this method.
      *
-     * @param pos byte code position to search for
+     * @param pos
+     *            byte code position to search for
      * @return target position's instruction handle if available
      */
     public InstructionHandle findHandle(final int pos) {
         final int[] positions = byte_positions;
         InstructionHandle ih = start;
@@ -148,11 +157,12 @@
     }
 
     /**
      * Initialize instruction list from byte array.
      *
-     * @param code byte array containing the instructions
+     * @param code
+     *            byte array containing the instructions
      */
     public InstructionList(final byte[] code) {
         int count = 0; // Contains actual length
         int[] pos;
         InstructionHandle[] ihs;
@@ -189,16 +199,15 @@
          * Pass 2: Look for BranchInstruction and update their targets, i.e., convert offsets to instruction handles.
          */
         for (int i = 0; i < count; i++) {
             if (ihs[i] instanceof BranchHandle) {
                 final BranchInstruction bi = (BranchInstruction) ihs[i].getInstruction();
-                int target = bi.getPosition() + bi.getIndex(); /*
+                int target = bi.getPosition() + bi.getIndex();
+                /*
                  * Byte code position: relative -> absolute.
-                 */
-
+                */
                 // Search for target position
-
                 InstructionHandle ih = findHandle(ihs, pos, count, target);
                 if (ih == null) {
                     throw new ClassGenException("Couldn't find target for branch: " + bi);
                 }
                 bi.setTarget(ih); // Update target
@@ -221,14 +230,15 @@
 
     /**
      * Append another list after instruction (handle) ih contained in this list.
      * Consumes argument list, i.e., it becomes empty.
      *
-     * @param ih where to append the instruction list
-     * @param il Instruction list to append to this one
-     * @return instruction handle pointing to the <B>first</B> appended
-     * instruction
+     * @param ih
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to append to this one
+     * @return instruction handle pointing to the <B>first</B> appended instruction
      */
     public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {
         if (il == null) {
             throw new ClassGenException("Appending null InstructionList");
         }
@@ -252,14 +262,15 @@
 
     /**
      * Append another list after instruction i contained in this list. Consumes
      * argument list, i.e., it becomes empty.
      *
-     * @param i where to append the instruction list
-     * @param il Instruction list to append to this one
-     * @return instruction handle pointing to the <B>first</B> appended
-     * instruction
+     * @param i
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to append to this one
+     * @return instruction handle pointing to the <B>first</B> appended instruction
      */
     public InstructionHandle append(final Instruction i, final InstructionList il) {
         InstructionHandle ih;
         if ((ih = findInstruction2(i)) == null) {
             throw new ClassGenException("Instruction " + i + " is not contained in this list.");
@@ -269,11 +280,12 @@
 
     /**
      * Append another list to this one. Consumes argument list, i.e., it becomes
      * empty.
      *
-     * @param il list to append to end of this list
+     * @param il
+     *            list to append to end of this list
      * @return instruction handle of the <B>first</B> appended instruction
      */
     public InstructionHandle append(final InstructionList il) {
         if (il == null) {
             throw new ClassGenException("Appending null InstructionList");
@@ -292,11 +304,12 @@
     }
 
     /**
      * Append an instruction to the end of this list.
      *
-     * @param ih instruction to append
+     * @param ih
+     *            instruction to append
      */
     private void append(final InstructionHandle ih) {
         if (isEmpty()) {
             start = end = ih;
             ih.setNext(ih.setPrev(null));
@@ -304,18 +317,18 @@
             end.setNext(ih);
             ih.setPrev(end);
             ih.setNext(null);
             end = ih;
         }
-
         length++; // Update length
     }
 
     /**
      * Append an instruction to the end of this list.
      *
-     * @param i instruction to append
+     * @param i
+     *            instruction to append
      * @return instruction handle of the appended instruction
      */
     public InstructionHandle append(final Instruction i) {
         final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);
         append(ih);
@@ -323,11 +336,12 @@
     }
 
     /**
      * Append a branch instruction to the end of this list.
      *
-     * @param i branch instruction to append
+     * @param i
+     *            branch instruction to append
      * @return branch instruction handle of the appended instruction
      */
     public BranchHandle append(final BranchInstruction i) {
         final BranchHandle ih = BranchHandle.getBranchHandle(i);
         append(ih);
@@ -336,71 +350,78 @@
 
     /**
      * Append a single instruction j after another instruction i, which must be
      * in this list of course!
      *
-     * @param i Instruction in list
-     * @param j Instruction to append after i in list
+     * @param i
+     *            Instruction in list
+     * @param j
+     *            Instruction to append after i in list
      * @return instruction handle of the first appended instruction
      */
     public InstructionHandle append(final Instruction i, final Instruction j) {
         return append(i, new InstructionList(j));
     }
 
     /**
      * Append a compound instruction, after instruction i.
      *
-     * @param i Instruction in list
-     * @param c The composite instruction (containing an InstructionList)
+     * @param i
+     *            Instruction in list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first appended instruction
      */
     public InstructionHandle append(final Instruction i, final CompoundInstruction c) {
         return append(i, c.getInstructionList());
     }
 
     /**
      * Append a compound instruction.
      *
-     * @param c The composite instruction (containing an InstructionList)
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first appended instruction
      */
     public InstructionHandle append(final CompoundInstruction c) {
         return append(c.getInstructionList());
     }
 
     /**
      * Append a compound instruction.
      *
-     * @param ih where to append the instruction list
-     * @param c The composite instruction (containing an InstructionList)
+     * @param ih
+     *            where to append the instruction list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first appended instruction
      */
     public InstructionHandle append(final InstructionHandle ih, final CompoundInstruction c) {
         return append(ih, c.getInstructionList());
     }
 
     /**
-     * Append an instruction after instruction (handle) ih contained in this
-     * list.
+     * Append an instruction after instruction (handle) ih contained in this list.
      *
-     * @param ih where to append the instruction list
-     * @param i Instruction to append
-     * @return instruction handle pointing to the <B>first</B> appended
-     * instruction
+     * @param ih
+     *            where to append the instruction list
+     * @param i
+     *            Instruction to append
+     * @return instruction handle pointing to the <B>first</B> appended instruction
      */
     public InstructionHandle append(final InstructionHandle ih, final Instruction i) {
         return append(ih, new InstructionList(i));
     }
 
     /**
-     * Append an instruction after instruction (handle) ih contained in this
-     * list.
+     * Append an instruction after instruction (handle) ih contained in this list.
      *
-     * @param ih where to append the instruction list
-     * @param i Instruction to append
-     * @return instruction handle pointing to the <B>first</B> appended
-     * instruction
+     * @param ih
+     *            where to append the instruction list
+     * @param i
+     *            Instruction to append
+     * @return instruction handle pointing to the <B>first</B> appended instruction
      */
     public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {
         final BranchHandle bh = BranchHandle.getBranchHandle(i);
         final InstructionList il = new InstructionList();
         il.append(bh);
@@ -410,12 +431,14 @@
 
     /**
      * Insert another list before Instruction handle ih contained in this list.
      * Consumes argument list, i.e., it becomes empty.
      *
-     * @param ih where to append the instruction list
-     * @param il Instruction list to insert
+     * @param ih
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to insert
      * @return instruction handle of the first inserted instruction
      */
     public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {
         if (il == null) {
             throw new ClassGenException("Inserting null InstructionList");
@@ -431,20 +454,20 @@
         if (prev != null) {
             prev.setNext(il.start);
         } else {
             start = il.start; // Update start ...
         }
-
         length += il.length; // Update length
         il.clear();
         return ret;
     }
 
     /**
      * Insert another list.
      *
-     * @param il list to insert before start of this list
+     * @param il
+     *            list to insert before start of this list
      * @return instruction handle of the first inserted instruction
      */
     public InstructionHandle insert(final InstructionList il) {
         if (isEmpty()) {
             append(il); // Code is identical for this case
@@ -454,11 +477,12 @@
     }
 
     /**
      * Insert an instruction at start of this list.
      *
-     * @param ih instruction to insert
+     * @param ih
+     *            instruction to insert
      */
     private void insert(final InstructionHandle ih) {
         if (isEmpty()) {
             start = end = ih;
             ih.setNext(ih.setPrev(null));
@@ -466,22 +490,22 @@
             start.setPrev(ih);
             ih.setNext(start);
             ih.setPrev(null);
             start = ih;
         }
-
         length++;
     }
 
     /**
      * Insert another list before Instruction i contained in this list. Consumes
      * argument list, i.e., it becomes empty.
      *
-     * @param i where to append the instruction list
-     * @param il Instruction list to insert
-     * @return instruction handle pointing to the first inserted instruction,
-     * i.e., il.getStart()
+     * @param i
+     *            where to append the instruction list
+     * @param il
+     *            Instruction list to insert
+     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()
      */
     public InstructionHandle insert(final Instruction i, final InstructionList il) {
         InstructionHandle ih;
         if ((ih = findInstruction1(i)) == null) {
             throw new ClassGenException("Instruction " + i + " is not contained in this list.");
@@ -490,11 +514,12 @@
     }
 
     /**
      * Insert an instruction at start of this list.
      *
-     * @param i instruction to insert
+     * @param i
+     *            instruction to insert
      * @return instruction handle of the inserted instruction
      */
     public InstructionHandle insert(final Instruction i) {
         final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);
         insert(ih);
@@ -502,11 +527,12 @@
     }
 
     /**
      * Insert a branch instruction at start of this list.
      *
-     * @param i branch instruction to insert
+     * @param i
+     *            branch instruction to insert
      * @return branch instruction handle of the appended instruction
      */
     public BranchHandle insert(final BranchInstruction i) {
         final BranchHandle ih = BranchHandle.getBranchHandle(i);
         insert(ih);
@@ -515,68 +541,77 @@
 
     /**
      * Insert a single instruction j before another instruction i, which must be
      * in this list of course!
      *
-     * @param i Instruction in list
-     * @param j Instruction to insert before i in list
+     * @param i
+     *            Instruction in list
+     * @param j
+     *            Instruction to insert before i in list
      * @return instruction handle of the first inserted instruction
      */
     public InstructionHandle insert(final Instruction i, final Instruction j) {
         return insert(i, new InstructionList(j));
     }
 
     /**
      * Insert a compound instruction before instruction i.
      *
-     * @param i Instruction in list
-     * @param c The composite instruction (containing an InstructionList)
+     * @param i
+     *            Instruction in list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first inserted instruction
      */
     public InstructionHandle insert(final Instruction i, final CompoundInstruction c) {
         return insert(i, c.getInstructionList());
     }
 
     /**
      * Insert a compound instruction.
      *
-     * @param c The composite instruction (containing an InstructionList)
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first inserted instruction
      */
     public InstructionHandle insert(final CompoundInstruction c) {
         return insert(c.getInstructionList());
     }
 
     /**
-     * Insert an instruction before instruction (handle) ih contained in this
-     * list.
+     * Insert an instruction before instruction (handle) ih contained in this list.
      *
-     * @param ih where to insert to the instruction list
-     * @param i Instruction to insert
+     * @param ih
+     *            where to insert to the instruction list
+     * @param i
+     *            Instruction to insert
      * @return instruction handle of the first inserted instruction
      */
     public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {
         return insert(ih, new InstructionList(i));
     }
 
     /**
      * Insert a compound instruction.
      *
-     * @param ih where to insert the instruction list
-     * @param c The composite instruction (containing an InstructionList)
+     * @param ih
+     *            where to insert the instruction list
+     * @param c
+     *            The composite instruction (containing an InstructionList)
      * @return instruction handle of the first inserted instruction
      */
     public InstructionHandle insert(final InstructionHandle ih, final CompoundInstruction c) {
         return insert(ih, c.getInstructionList());
     }
 
     /**
-     * Insert an instruction before instruction (handle) ih contained in this
-     * list.
+     * Insert an instruction before instruction (handle) ih contained in this list.
      *
-     * @param ih where to insert to the instruction list
-     * @param i Instruction to insert
+     * @param ih
+     *            where to insert to the instruction list
+     * @param i
+     *            Instruction to insert
      * @return instruction handle of the first inserted instruction
      */
     public BranchHandle insert(final InstructionHandle ih, final BranchInstruction i) {
         final BranchHandle bh = BranchHandle.getBranchHandle(i);
         final InstructionList il = new InstructionList();
@@ -586,18 +621,22 @@
     }
 
     /**
      * Take all instructions (handles) from "start" to "end" and append them
      * after the new location "target". Of course, "end" must be after "start"
-     * and target must not be located withing this range. If you want to move
-     * something to the start of the list use null as value for target.<br>
+     * and target must not be located within this range. If you want to move
+     * something to the start of the list use null as value for target.
+     * <p>
      * Any instruction targeters pointing to handles within the block, keep
      * their targets.
      *
-     * @param start of moved block
-     * @param end of moved block
-     * @param target of moved block
+     * @param start
+     *            of moved block
+     * @param end
+     *            of moved block
+     * @param target
+     *            of moved block
      */
     public void move(final InstructionHandle start, final InstructionHandle end, final InstructionHandle target) {
         // Step 1: Check constraints
         if ((start == null) || (end == null)) {
             throw new ClassGenException("Invalid null handle: From " + start + " to " + end);
@@ -647,24 +686,28 @@
     }
 
     /**
      * Move a single instruction (handle) to a new location.
      *
-     * @param ih moved instruction
-     * @param target new location of moved instruction
+     * @param ih
+     *            moved instruction
+     * @param target
+     *            new location of moved instruction
      */
     public void move(final InstructionHandle ih, final InstructionHandle target) {
         move(ih, ih, target);
     }
 
     /**
      * Remove from instruction `prev' to instruction `next' both contained in
      * this list. Throws TargetLostException when one of the removed instruction
      * handles is still being targeted.
      *
-     * @param prev where to start deleting (predecessor, exclusive)
-     * @param next where to end deleting (successor, exclusive)
+     * @param prev
+     *            where to start deleting (predecessor, exclusive)
+     * @param next
+     *            where to end deleting (successor, exclusive)
      */
     private void remove(final InstructionHandle prev, InstructionHandle next) throws TargetLostException {
         InstructionHandle first;
         InstructionHandle last; // First and last deleted instruction
         if ((prev == null) && (next == null)) {
@@ -715,21 +758,22 @@
 
     /**
      * Remove instruction from this list. The corresponding Instruction handles
      * must not be reused!
      *
-     * @param ih instruction (handle) to remove
+     * @param ih
+     *            instruction (handle) to remove
      */
     public void delete(final InstructionHandle ih) throws TargetLostException {
         remove(ih.getPrev(), ih.getNext());
     }
 
     /**
-     * Remove instruction from this list. The corresponding Instruction handles
-     * must not be reused!
+     * Remove instruction from this list. The corresponding Instruction handles must not be reused!
      *
-     * @param i instruction to remove
+     * @param i
+     *            instruction to remove
      */
     public void delete(final Instruction i) throws TargetLostException {
         InstructionHandle ih;
         if ((ih = findInstruction1(i)) == null) {
             throw new ClassGenException("Instruction " + i + " is not contained in this list.");
@@ -741,12 +785,14 @@
      * Remove instructions from instruction `from' to instruction `to' contained
      * in this list. The user must ensure that `from' is an instruction before
      * `to', or risk havoc. The corresponding Instruction handles must not be
      * reused!
      *
-     * @param from where to start deleting (inclusive)
-     * @param to where to end deleting (inclusive)
+     * @param from
+     *            where to start deleting (inclusive)
+     * @param to
+     *            where to end deleting (inclusive)
      */
     public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {
         remove(from.getPrev(), to.getNext());
     }
 
@@ -754,12 +800,14 @@
      * Remove instructions from instruction `from' to instruction `to' contained
      * in this list. The user must ensure that `from' is an instruction before
      * `to', or risk havoc. The corresponding Instruction handles must not be
      * reused!
      *
-     * @param from where to start deleting (inclusive)
-     * @param to where to end deleting (inclusive)
+     * @param from
+     *            where to start deleting (inclusive)
+     * @param to
+     *            where to end deleting (inclusive)
      */
     public void delete(final Instruction from, final Instruction to) throws TargetLostException {
         InstructionHandle from_ih;
         InstructionHandle to_ih;
         if ((from_ih = findInstruction1(from)) == null) {
@@ -772,11 +820,12 @@
     }
 
     /**
      * Search for given Instruction reference, start at beginning of list.
      *
-     * @param i instruction to search for
+     * @param i
+     *            instruction to search for
      * @return instruction found on success, null otherwise
      */
     private InstructionHandle findInstruction1(final Instruction i) {
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             if (ih.getInstruction() == i) {
@@ -787,11 +836,12 @@
     }
 
     /**
      * Search for given Instruction reference, start at end of list
      *
-     * @param i instruction to search for
+     * @param i
+     *            instruction to search for
      * @return instruction found on success, null otherwise
      */
     private InstructionHandle findInstruction2(final Instruction i) {
         for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {
             if (ih.getInstruction() == i) {
@@ -823,12 +873,12 @@
 
     /**
      * Give all instructions their position number (offset in byte stream),
      * i.e., make the list ready to be dumped.
      *
-     * @param check Perform sanity checks, e.g. if all targeted instructions
-     * really belong to this list
+     * @param check
+     *            Perform sanity checks, e.g. if all targeted instructions really belong to this list
      */
     public void setPositions(final boolean check) { // called by code in other packages
         int max_additional_bytes = 0;
         int additional_bytes = 0;
         int index = 0;
@@ -841,57 +891,55 @@
             for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
                 final Instruction i = ih.getInstruction();
                 if (i instanceof BranchInstruction) { // target instruction within list?
                     Instruction inst = ((BranchInstruction) i).getTarget().getInstruction();
                     if (!contains(inst)) {
-                        throw new ClassGenException("Branch target of " +
-                                Const.getOpcodeName(i.getOpcode()) + ":" +
-                                inst + " not in instruction list");
+                        throw new ClassGenException("Branch target of "
+                                + Const.getOpcodeName(i.getOpcode()) + ":"
+                                + inst + " not in instruction list");
                     }
                     if (i instanceof Select) {
                         final InstructionHandle[] targets = ((Select) i).getTargets();
                         for (final InstructionHandle target : targets) {
                             inst = target.getInstruction();
                             if (!contains(inst)) {
-                                throw new ClassGenException("Branch target of " +
-                                        Const.getOpcodeName(i.getOpcode()) + ":" +
-                                        inst + " not in instruction list");
+                                throw new ClassGenException("Branch target of "
+                                        + Const.getOpcodeName(i.getOpcode()) + ":"
+                                        + inst + " not in instruction list");
                             }
                         }
                     }
                     if (!(ih instanceof BranchHandle)) {
                         throw new ClassGenException(
-                                "Branch instruction " +
-                                        Const.getOpcodeName(i.getOpcode()) + ":" +
-                                        inst + " not contained in BranchHandle.");
+                                "Branch instruction "
+                                + Const.getOpcodeName(i.getOpcode()) + ":"
+                                + inst + " not contained in BranchHandle.");
                     }
                 }
             }
         }
         /*
          * Pass 1: Set position numbers and sum up the maximum number of bytes an instruction may be shifted.
          */
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
-
             final Instruction i = ih.getInstruction();
             ih.setPosition(index);
             pos[count++] = index;
-
             /*
              * Get an estimate about how many additional bytes may be added,
              * because BranchInstructions may have variable length depending on the target offset
              * (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).
              */
             switch (i.getOpcode()) {
                 case Const.JSR:
                 case Const.GOTO:
                     max_additional_bytes += 2;
-                    break;
+                break;
                 case Const.TABLESWITCH:
                 case Const.LOOKUPSWITCH:
                     max_additional_bytes += 3;
-                    break;
+                break;
             }
             index += i.getLength();
         }
 
         /* Pass 2: Expand the variable-length (Branch)Instructions depending on
@@ -906,21 +954,16 @@
          * preceding expansions), like pass 1.
          */
         index = count = 0;
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             final Instruction i = ih.getInstruction();
-
             ih.setPosition(index);
             pos[count++] = index;
             index += i.getLength();
         }
-        if (length == count) {
-            byte_positions = pos;
-        } else {
-            byte_positions = new int[count]; // Trim to proper size
-            System.arraycopy(pos, 0, byte_positions, 0, count);
-        }
+        byte_positions = new int[count]; // Trim to proper size
+        System.arraycopy(pos, 0, byte_positions, 0, count);
     }
 
     /**
      * When everything is finished, use this method to convert the instruction
      * list into an array of bytes.
@@ -965,11 +1008,12 @@
     public String toString() {
         return toString(true);
     }
 
     /**
-     * @param verbose toggle output format
+     * @param verbose
+     *            toggle output format
      * @return String containing all instructions in this list.
      */
     public String toString(final boolean verbose) {
         final StringBuilder buf = new StringBuilder();
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
@@ -1038,11 +1082,12 @@
      */
     public InstructionList copy() {
         final Map<InstructionHandle, InstructionHandle> map = new HashMap<>();
         final InstructionList il = new InstructionList();
         /*
-         * Pass 1: Make copies of all instructions, append them to the new list and associate old instruction references with the new ones, i.e., a 1:1 mapping.
+         * Pass 1: Make copies of all instructions, append them to the new list
+         * and associate old instruction references with the new ones, i.e., a 1:1 mapping.
          */
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             final Instruction i = ih.getInstruction();
             final Instruction c = i.copy(); // Use clone for shallow copy
             if (c instanceof BranchInstruction) {
@@ -1146,15 +1191,16 @@
 
     /**
      * Redirect all references from old_target to new_target, i.e., update
      * targets of branch instructions.
      *
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
+     * @param old_target
+     *            the old target instruction handle
+     * @param new_target
+     *            the new target instruction handle
      */
-    public void redirectBranches(final InstructionHandle old_target,
-            final InstructionHandle new_target) {
+    public void redirectBranches(final InstructionHandle old_target, final InstructionHandle new_target) {
         for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {
             final Instruction i = ih.getInstruction();
             if (i instanceof BranchInstruction) {
                 final BranchInstruction b = (BranchInstruction) i;
                 final InstructionHandle target = b.getTarget();
@@ -1174,17 +1220,19 @@
     }
 
     /**
      * Redirect all references of local variables from old_target to new_target.
      *
-     * @param lg array of local variables
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
+     * @param lg
+     *            array of local variables
+     * @param old_target
+     *            the old target instruction handle
+     * @param new_target
+     *            the new target instruction handle
      * @see MethodGen
      */
-    public void redirectLocalVariables(final LocalVariableGen[] lg,
-            final InstructionHandle old_target, final InstructionHandle new_target) {
+    public void redirectLocalVariables(final LocalVariableGen[] lg, final InstructionHandle old_target, final InstructionHandle new_target) {
         for (final LocalVariableGen element : lg) {
             final InstructionHandle start = element.getStart();
             final InstructionHandle end = element.getEnd();
             if (start == old_target) {
                 element.setStart(new_target);
@@ -1194,16 +1242,18 @@
             }
         }
     }
 
     /**
-     * Redirect all references of exception handlers from old_target to
-     * new_target.
+     * Redirect all references of exception handlers from old_target to new_target.
      *
-     * @param exceptions array of exception handlers
-     * @param old_target the old target instruction handle
-     * @param new_target the new target instruction handle
+     * @param exceptions
+     *            array of exception handlers
+     * @param old_target
+     *            the old target instruction handle
+     * @param new_target
+     *            the new target instruction handle
      * @see MethodGen
      */
     public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions,
             final InstructionHandle old_target, final InstructionHandle new_target) {
         for (final CodeExceptionGen exception : exceptions) {

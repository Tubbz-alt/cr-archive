<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/util/BCELifier.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BCELFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ByteSequence.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/util/BCELifier.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 import com.sun.org.apache.bcel.internal.Const;
 30 import com.sun.org.apache.bcel.internal.Repository;
 31 import com.sun.org.apache.bcel.internal.classfile.ClassParser;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantValue;
 33 import com.sun.org.apache.bcel.internal.classfile.Field;
 34 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 35 import com.sun.org.apache.bcel.internal.classfile.Method;
 36 import com.sun.org.apache.bcel.internal.classfile.Utility;
 37 import com.sun.org.apache.bcel.internal.generic.ArrayType;
 38 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 39 import com.sun.org.apache.bcel.internal.generic.MethodGen;
 40 import com.sun.org.apache.bcel.internal.generic.Type;
 41 
 42 /**
 43  * This class takes a given JavaClass object and converts it to a
 44  * Java program that creates that very class using BCEL. This
 45  * gives new users of BCEL a useful example showing how things
 46  * are done with BCEL. It does not cover all features of BCEL,
 47  * but tries to mimic hand-written code as close as possible.
 48  *
<span class="line-removed"> 49  * @version $Id: BCELifier.java 1750228 2016-06-25 21:47:44Z ggregory $</span>
 50  */
 51 public class BCELifier extends com.sun.org.apache.bcel.internal.classfile.EmptyVisitor {
 52 
 53     /**
 54      * Enum corresponding to flag source.
 55      */
 56     public enum FLAGS {
 57         UNKNOWN,
 58         CLASS,
 59         METHOD,
 60     }
 61 
 62     // The base package name for imports; assumes Const is at the top level
 63     // N.B we use the class so renames will be detected by the compiler/IDE
 64     private static final String BASE_PACKAGE = Const.class.getPackage().getName();
 65     private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+&quot;.&quot;;
 66 
 67     private final JavaClass _clazz;
 68     private final PrintWriter _out;
 69     private final ConstantPoolGen _cp;
</pre>
<hr />
<pre>
 96             class_name = class_name.substring(package_name.length() + 1);
 97             _out.println(&quot;package &quot; + package_name + &quot;;&quot;);
 98             _out.println();
 99         }
100         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.generic.*;&quot;);
101         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.classfile.*;&quot;);
102         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.*;&quot;);
103         _out.println(&quot;import java.io.*;&quot;);
104         _out.println();
105         _out.println(&quot;public class &quot; + class_name + &quot;Creator {&quot;);
106         _out.println(&quot;  private InstructionFactory _factory;&quot;);
107         _out.println(&quot;  private ConstantPoolGen    _cp;&quot;);
108         _out.println(&quot;  private ClassGen           _cg;&quot;);
109         _out.println();
110         _out.println(&quot;  public &quot; + class_name + &quot;Creator() {&quot;);
111         _out.println(&quot;    _cg = new ClassGen(\&quot;&quot;
112                 + ((&quot;&quot;.equals(package_name)) ? class_name : package_name + &quot;.&quot; + class_name)
113                 + &quot;\&quot;, \&quot;&quot; + super_name + &quot;\&quot;, &quot; + &quot;\&quot;&quot; + clazz.getSourceFileName() + &quot;\&quot;, &quot;
114                 + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + &quot;, &quot;
115                 + &quot;new String[] { &quot; + inter + &quot; });&quot;);


116         _out.println();
117         _out.println(&quot;    _cp = _cg.getConstantPool();&quot;);
118         _out.println(&quot;    _factory = new InstructionFactory(_cg, _cp);&quot;);
119         _out.println(&quot;  }&quot;);
120         _out.println();
121         printCreate();
122         final Field[] fields = clazz.getFields();
123         if (fields.length &gt; 0) {
124             _out.println(&quot;  private void createFields() {&quot;);
125             _out.println(&quot;    FieldGen field;&quot;);
126             for (final Field field : fields) {
127                 field.accept(this);
128             }
129             _out.println(&quot;  }&quot;);
130             _out.println();
131         }
132         final Method[] methods = clazz.getMethods();
133         for (int i = 0; i &lt; methods.length; i++) {
134             _out.println(&quot;  private void createMethod_&quot; + i + &quot;() {&quot;);
135             methods[i].accept(this);
</pre>
<hr />
<pre>
199         _out.println(&quot;    il.dispose();&quot;);
200     }
201 
202 
203     static String printFlags( final int flags ) {
204         return printFlags(flags, FLAGS.UNKNOWN);
205     }
206 
207     /**
208      * Return a string with the flag settings
209      * @param flags the flags field to interpret
210      * @param location the item type
211      * @return the formatted string
212      * @since 6.0 made public
213      */
214     public static String printFlags( final int flags, final FLAGS location ) {
215         if (flags == 0) {
216             return &quot;0&quot;;
217         }
218         final StringBuilder buf = new StringBuilder();
<span class="line-modified">219         for (int i = 0, pow = 1; pow &lt;= Const.MAX_ACC_FLAG; i++) {</span>
220             if ((flags &amp; pow) != 0) {
221                 if ((pow == Const.ACC_SYNCHRONIZED) &amp;&amp; (location == FLAGS.CLASS)) {
222                     buf.append(CONSTANT_PREFIX+&quot;ACC_SUPER | &quot;);
223                 } else if ((pow == Const.ACC_VOLATILE) &amp;&amp; (location == FLAGS.METHOD)) {
224                     buf.append(CONSTANT_PREFIX+&quot;ACC_BRIDGE | &quot;);
225                 } else if ((pow == Const.ACC_TRANSIENT) &amp;&amp; (location == FLAGS.METHOD)) {
226                     buf.append(CONSTANT_PREFIX+&quot;ACC_VARARGS | &quot;);
227                 } else {
228                     if (i &lt; Const.ACCESS_NAMES_LENGTH) {
229                         buf.append(CONSTANT_PREFIX+&quot;ACC_&quot;)
230                                 .append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH))
231                                 .append( &quot; | &quot;);
232                     } else {
233                         buf.append(String.format (CONSTANT_PREFIX+&quot;ACC_BIT %x | &quot;, pow));
234                     }
235                 }
236             }
237             pow &lt;&lt;= 1;
238         }
239         final String str = buf.toString();
</pre>
<hr />
<pre>
267         if (t &lt;= Const.T_VOID) {
268             return &quot;Type.&quot; + Const.getTypeName(t).toUpperCase(Locale.ENGLISH);
269         } else if (type.toString().equals(&quot;java.lang.String&quot;)) {
270             return &quot;Type.STRING&quot;;
271         } else if (type.toString().equals(&quot;java.lang.Object&quot;)) {
272             return &quot;Type.OBJECT&quot;;
273         } else if (type.toString().equals(&quot;java.lang.StringBuffer&quot;)) {
274             return &quot;Type.STRINGBUFFER&quot;;
275         } else if (type instanceof ArrayType) {
276             final ArrayType at = (ArrayType) type;
277             return &quot;new ArrayType(&quot; + printType(at.getBasicType()) + &quot;, &quot; + at.getDimensions()
278                     + &quot;)&quot;;
279         } else {
280             return &quot;new ObjectType(\&quot;&quot; + Utility.signatureToString(signature, false) + &quot;\&quot;)&quot;;
281         }
282     }
283 
284 
285     /** Default main method
286      */
<span class="line-modified">287     public static void _main( final String[] argv ) throws Exception {</span>
288         if (argv.length != 1) {
289             System.out.println(&quot;Usage: BCELifier classname&quot;);
290             System.out.println(&quot;\tThe class must exist on the classpath&quot;);
291             return;
292         }
293         final JavaClass java_class = getJavaClass(argv[0]);
294         final BCELifier bcelifier = new BCELifier(java_class, System.out);
295         bcelifier.start();
296     }
297 
298 
299     // Needs to be accessible from unit test code
300     static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {
301         JavaClass java_class;
302         if ((java_class = Repository.lookupClass(name)) == null) {
303             java_class = new ClassParser(name).parse(); // May throw IOException
304         }
305         return java_class;
306     }
307 }
</pre>
</td>
<td>
<hr />
<pre>
 29 import com.sun.org.apache.bcel.internal.Const;
 30 import com.sun.org.apache.bcel.internal.Repository;
 31 import com.sun.org.apache.bcel.internal.classfile.ClassParser;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantValue;
 33 import com.sun.org.apache.bcel.internal.classfile.Field;
 34 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 35 import com.sun.org.apache.bcel.internal.classfile.Method;
 36 import com.sun.org.apache.bcel.internal.classfile.Utility;
 37 import com.sun.org.apache.bcel.internal.generic.ArrayType;
 38 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 39 import com.sun.org.apache.bcel.internal.generic.MethodGen;
 40 import com.sun.org.apache.bcel.internal.generic.Type;
 41 
 42 /**
 43  * This class takes a given JavaClass object and converts it to a
 44  * Java program that creates that very class using BCEL. This
 45  * gives new users of BCEL a useful example showing how things
 46  * are done with BCEL. It does not cover all features of BCEL,
 47  * but tries to mimic hand-written code as close as possible.
 48  *

 49  */
 50 public class BCELifier extends com.sun.org.apache.bcel.internal.classfile.EmptyVisitor {
 51 
 52     /**
 53      * Enum corresponding to flag source.
 54      */
 55     public enum FLAGS {
 56         UNKNOWN,
 57         CLASS,
 58         METHOD,
 59     }
 60 
 61     // The base package name for imports; assumes Const is at the top level
 62     // N.B we use the class so renames will be detected by the compiler/IDE
 63     private static final String BASE_PACKAGE = Const.class.getPackage().getName();
 64     private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+&quot;.&quot;;
 65 
 66     private final JavaClass _clazz;
 67     private final PrintWriter _out;
 68     private final ConstantPoolGen _cp;
</pre>
<hr />
<pre>
 95             class_name = class_name.substring(package_name.length() + 1);
 96             _out.println(&quot;package &quot; + package_name + &quot;;&quot;);
 97             _out.println();
 98         }
 99         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.generic.*;&quot;);
100         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.classfile.*;&quot;);
101         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.*;&quot;);
102         _out.println(&quot;import java.io.*;&quot;);
103         _out.println();
104         _out.println(&quot;public class &quot; + class_name + &quot;Creator {&quot;);
105         _out.println(&quot;  private InstructionFactory _factory;&quot;);
106         _out.println(&quot;  private ConstantPoolGen    _cp;&quot;);
107         _out.println(&quot;  private ClassGen           _cg;&quot;);
108         _out.println();
109         _out.println(&quot;  public &quot; + class_name + &quot;Creator() {&quot;);
110         _out.println(&quot;    _cg = new ClassGen(\&quot;&quot;
111                 + ((&quot;&quot;.equals(package_name)) ? class_name : package_name + &quot;.&quot; + class_name)
112                 + &quot;\&quot;, \&quot;&quot; + super_name + &quot;\&quot;, &quot; + &quot;\&quot;&quot; + clazz.getSourceFileName() + &quot;\&quot;, &quot;
113                 + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + &quot;, &quot;
114                 + &quot;new String[] { &quot; + inter + &quot; });&quot;);
<span class="line-added">115         _out.println(&quot;    _cg.setMajor(&quot; + clazz.getMajor() +&quot;);&quot;);</span>
<span class="line-added">116         _out.println(&quot;    _cg.setMinor(&quot; + clazz.getMinor() +&quot;);&quot;);</span>
117         _out.println();
118         _out.println(&quot;    _cp = _cg.getConstantPool();&quot;);
119         _out.println(&quot;    _factory = new InstructionFactory(_cg, _cp);&quot;);
120         _out.println(&quot;  }&quot;);
121         _out.println();
122         printCreate();
123         final Field[] fields = clazz.getFields();
124         if (fields.length &gt; 0) {
125             _out.println(&quot;  private void createFields() {&quot;);
126             _out.println(&quot;    FieldGen field;&quot;);
127             for (final Field field : fields) {
128                 field.accept(this);
129             }
130             _out.println(&quot;  }&quot;);
131             _out.println();
132         }
133         final Method[] methods = clazz.getMethods();
134         for (int i = 0; i &lt; methods.length; i++) {
135             _out.println(&quot;  private void createMethod_&quot; + i + &quot;() {&quot;);
136             methods[i].accept(this);
</pre>
<hr />
<pre>
200         _out.println(&quot;    il.dispose();&quot;);
201     }
202 
203 
204     static String printFlags( final int flags ) {
205         return printFlags(flags, FLAGS.UNKNOWN);
206     }
207 
208     /**
209      * Return a string with the flag settings
210      * @param flags the flags field to interpret
211      * @param location the item type
212      * @return the formatted string
213      * @since 6.0 made public
214      */
215     public static String printFlags( final int flags, final FLAGS location ) {
216         if (flags == 0) {
217             return &quot;0&quot;;
218         }
219         final StringBuilder buf = new StringBuilder();
<span class="line-modified">220         for (int i = 0, pow = 1; pow &lt;= Const.MAX_ACC_FLAG_I; i++) {</span>
221             if ((flags &amp; pow) != 0) {
222                 if ((pow == Const.ACC_SYNCHRONIZED) &amp;&amp; (location == FLAGS.CLASS)) {
223                     buf.append(CONSTANT_PREFIX+&quot;ACC_SUPER | &quot;);
224                 } else if ((pow == Const.ACC_VOLATILE) &amp;&amp; (location == FLAGS.METHOD)) {
225                     buf.append(CONSTANT_PREFIX+&quot;ACC_BRIDGE | &quot;);
226                 } else if ((pow == Const.ACC_TRANSIENT) &amp;&amp; (location == FLAGS.METHOD)) {
227                     buf.append(CONSTANT_PREFIX+&quot;ACC_VARARGS | &quot;);
228                 } else {
229                     if (i &lt; Const.ACCESS_NAMES_LENGTH) {
230                         buf.append(CONSTANT_PREFIX+&quot;ACC_&quot;)
231                                 .append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH))
232                                 .append( &quot; | &quot;);
233                     } else {
234                         buf.append(String.format (CONSTANT_PREFIX+&quot;ACC_BIT %x | &quot;, pow));
235                     }
236                 }
237             }
238             pow &lt;&lt;= 1;
239         }
240         final String str = buf.toString();
</pre>
<hr />
<pre>
268         if (t &lt;= Const.T_VOID) {
269             return &quot;Type.&quot; + Const.getTypeName(t).toUpperCase(Locale.ENGLISH);
270         } else if (type.toString().equals(&quot;java.lang.String&quot;)) {
271             return &quot;Type.STRING&quot;;
272         } else if (type.toString().equals(&quot;java.lang.Object&quot;)) {
273             return &quot;Type.OBJECT&quot;;
274         } else if (type.toString().equals(&quot;java.lang.StringBuffer&quot;)) {
275             return &quot;Type.STRINGBUFFER&quot;;
276         } else if (type instanceof ArrayType) {
277             final ArrayType at = (ArrayType) type;
278             return &quot;new ArrayType(&quot; + printType(at.getBasicType()) + &quot;, &quot; + at.getDimensions()
279                     + &quot;)&quot;;
280         } else {
281             return &quot;new ObjectType(\&quot;&quot; + Utility.signatureToString(signature, false) + &quot;\&quot;)&quot;;
282         }
283     }
284 
285 
286     /** Default main method
287      */
<span class="line-modified">288     public static void main( final String[] argv ) throws Exception {</span>
289         if (argv.length != 1) {
290             System.out.println(&quot;Usage: BCELifier classname&quot;);
291             System.out.println(&quot;\tThe class must exist on the classpath&quot;);
292             return;
293         }
294         final JavaClass java_class = getJavaClass(argv[0]);
295         final BCELifier bcelifier = new BCELifier(java_class, System.out);
296         bcelifier.start();
297     }
298 
299 
300     // Needs to be accessible from unit test code
301     static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {
302         JavaClass java_class;
303         if ((java_class = Repository.lookupClass(name)) == null) {
304             java_class = new ClassParser(name).parse(); // May throw IOException
305         }
306         return java_class;
307     }
308 }
</pre>
</td>
</tr>
</table>
<center><a href="BCELFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ByteSequence.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
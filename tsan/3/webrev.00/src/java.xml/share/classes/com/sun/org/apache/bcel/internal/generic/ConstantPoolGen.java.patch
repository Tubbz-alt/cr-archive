diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -38,20 +38,21 @@
 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 import com.sun.org.apache.bcel.internal.classfile.ConstantString;
 import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
 
 /**
- * This class is used to build up a constant pool. The user adds constants via
- * `addXXX' methods, `addString', `addClass', etc.. These methods return an
- * index into the constant pool. Finally, `getFinalConstantPool()' returns the
- * constant pool built up. Intermediate versions of the constant pool can be
+ * This class is used to build up a constant pool. The user adds
+ * constants via `addXXX' methods, `addString', `addClass',
+ * etc.. These methods return an index into the constant
+ * pool. Finally, `getFinalConstantPool()' returns the constant pool
+ * built up. Intermediate versions of the constant pool can be
  * obtained with `getConstantPool()'. A constant pool has capacity for
- * Constants.MAX_SHORT entries. Note that the first (0) is used by the JVM and
- * that Double and Long constants need two slots.
+ * Constants.MAX_SHORT entries. Note that the first (0) is used by the
+ * JVM and that Double and Long constants need two slots.
  *
- * @version $Id: ConstantPoolGen.java 1749603 2016-06-21 20:50:19Z ggregory $
  * @see Constant
+ * @LastModified: Jan 2020
  */
 public class ConstantPoolGen {
 
     private static final int DEFAULT_BUFFER_SIZE = 256;
     private int size;
@@ -65,15 +66,17 @@
 
     private static class Index {
 
         final int index;
 
+
         Index(final int i) {
             index = i;
         }
     }
 
+
     /**
      * Initialize with given array of constants.
      *
      * @param cs array of given constants, new ones will be appended
      */
@@ -86,10 +89,11 @@
         System.arraycopy(cs, 0, constants, 0, cs.length);
         if (cs.length > 0) {
             index = cs.length;
         }
 
+
         for (int i = 1; i < index; i++) {
             final Constant c = constants[i];
             if (c instanceof ConstantString) {
                 final ConstantString s = (ConstantString) c;
                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
@@ -132,11 +136,11 @@
                 if (c instanceof ConstantInvokeDynamic) {
                     class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());
                     // since name can't begin with digit, can  use
                     // METHODREF_DELIM with out fear of duplicates.
                 } else {
-                    final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
+                final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
                     u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
                     class_name = u8.getBytes().replace('/', '.');
                 }
 
                 final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
@@ -175,33 +179,39 @@
                 // nothing to do
             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {
                 // TODO should this be handled somehow?
             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {
                 // TODO should this be handled somehow?
+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {
+                // TODO should this be handled somehow?
+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {
+                // TODO should this be handled somehow?
             } else {
                 assert false : "Unexpected constant type: " + c.getClass().getName();
             }
         }
     }
 
+
     /**
      * Initialize with given constant pool.
      */
     public ConstantPoolGen(final ConstantPool cp) {
         this(cp.getConstantPool());
     }
 
+
     /**
      * Create empty constant pool.
      */
     public ConstantPoolGen() {
         size = DEFAULT_BUFFER_SIZE;
         constants = new Constant[size];
     }
 
-    /**
-     * Resize internal array of constants.
+
+    /** Resize internal array of constants.
      */
     protected void adjustSize() {
         if (index + 3 >= size) {
             final Constant[] cs = constants;
             size *= 2;
@@ -210,29 +220,30 @@
         }
     }
 
     private final Map<String, Index> string_table = new HashMap<>();
 
+
     /**
      * Look for ConstantString in ConstantPool containing String `str'.
      *
      * @param str String to search for
      * @return index on success, -1 otherwise
      */
-    public int lookupString(final String str) {
+    public int lookupString( final String str ) {
         final Index index = string_table.get(str);
         return (index != null) ? index.index : -1;
     }
 
+
     /**
-     * Add a new String constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new String constant to the ConstantPool, if it is not already in there.
      *
      * @param str String to add
      * @return index of entry
      */
-    public int addString(final String str) {
+    public int addString( final String str ) {
         int ret;
         if ((ret = lookupString(str)) != -1) {
             return ret; // Already in CP
         }
         final int utf8 = addUtf8(str);
@@ -246,22 +257,24 @@
         return ret;
     }
 
     private final Map<String, Index> class_table = new HashMap<>();
 
+
     /**
      * Look for ConstantClass in ConstantPool named `str'.
      *
      * @param str String to search for
      * @return index on success, -1 otherwise
      */
-    public int lookupClass(final String str) {
+    public int lookupClass( final String str ) {
         final Index index = class_table.get(str.replace('.', '/'));
         return (index != null) ? index.index : -1;
     }
 
-    private int addClass_(final String clazz) {
+
+    private int addClass_( final String clazz ) {
         int ret;
         if ((ret = lookupClass(clazz)) != -1) {
             return ret; // Already in CP
         }
         adjustSize();
@@ -272,49 +285,52 @@
             class_table.put(clazz, new Index(ret));
         }
         return ret;
     }
 
+
     /**
-     * Add a new Class reference to the ConstantPool, if it is not already in
-     * there.
+     * Add a new Class reference to the ConstantPool, if it is not already in there.
      *
      * @param str Class to add
      * @return index of entry
      */
-    public int addClass(final String str) {
+    public int addClass( final String str ) {
         return addClass_(str.replace('.', '/'));
     }
 
+
     /**
      * Add a new Class reference to the ConstantPool for a given type.
      *
      * @param type Class to add
      * @return index of entry
      */
-    public int addClass(final ObjectType type) {
+    public int addClass( final ObjectType type ) {
         return addClass(type.getClassName());
     }
 
+
     /**
-     * Add a reference to an array class (e.g. String[][]) as needed by
-     * MULTIANEWARRAY instruction, e.g. to the ConstantPool.
+     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY
+     * instruction, e.g. to the ConstantPool.
      *
      * @param type type of array class
      * @return index of entry
      */
-    public int addArrayClass(final ArrayType type) {
+    public int addArrayClass( final ArrayType type ) {
         return addClass_(type.getSignature());
     }
 
+
     /**
      * Look for ConstantInteger in ConstantPool.
      *
      * @param n integer number to look for
      * @return index on success, -1 otherwise
      */
-    public int lookupInteger(final int n) {
+    public int lookupInteger( final int n ) {
         for (int i = 1; i < index; i++) {
             if (constants[i] instanceof ConstantInteger) {
                 final ConstantInteger c = (ConstantInteger) constants[i];
                 if (c.getBytes() == n) {
                     return i;
@@ -322,35 +338,36 @@
             }
         }
         return -1;
     }
 
+
     /**
-     * Add a new Integer constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new Integer constant to the ConstantPool, if it is not already in there.
      *
      * @param n integer number to add
      * @return index of entry
      */
-    public int addInteger(final int n) {
+    public int addInteger( final int n ) {
         int ret;
         if ((ret = lookupInteger(n)) != -1) {
             return ret; // Already in CP
         }
         adjustSize();
         ret = index;
         constants[index++] = new ConstantInteger(n);
         return ret;
     }
 
+
     /**
      * Look for ConstantFloat in ConstantPool.
      *
      * @param n Float number to look for
      * @return index on success, -1 otherwise
      */
-    public int lookupFloat(final float n) {
+    public int lookupFloat( final float n ) {
         final int bits = Float.floatToIntBits(n);
         for (int i = 1; i < index; i++) {
             if (constants[i] instanceof ConstantFloat) {
                 final ConstantFloat c = (ConstantFloat) constants[i];
                 if (Float.floatToIntBits(c.getBytes()) == bits) {
@@ -359,18 +376,18 @@
             }
         }
         return -1;
     }
 
+
     /**
-     * Add a new Float constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new Float constant to the ConstantPool, if it is not already in there.
      *
      * @param n Float number to add
      * @return index of entry
      */
-    public int addFloat(final float n) {
+    public int addFloat( final float n ) {
         int ret;
         if ((ret = lookupFloat(n)) != -1) {
             return ret; // Already in CP
         }
         adjustSize();
@@ -379,29 +396,30 @@
         return ret;
     }
 
     private final Map<String, Index> utf8_table = new HashMap<>();
 
+
     /**
      * Look for ConstantUtf8 in ConstantPool.
      *
      * @param n Utf8 string to look for
      * @return index on success, -1 otherwise
      */
-    public int lookupUtf8(final String n) {
+    public int lookupUtf8( final String n ) {
         final Index index = utf8_table.get(n);
         return (index != null) ? index.index : -1;
     }
 
+
     /**
-     * Add a new Utf8 constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.
      *
      * @param n Utf8 string to add
      * @return index of entry
      */
-    public int addUtf8(final String n) {
+    public int addUtf8( final String n ) {
         int ret;
         if ((ret = lookupUtf8(n)) != -1) {
             return ret; // Already in CP
         }
         adjustSize();
@@ -411,17 +429,18 @@
             utf8_table.put(n, new Index(ret));
         }
         return ret;
     }
 
+
     /**
      * Look for ConstantLong in ConstantPool.
      *
      * @param n Long number to look for
      * @return index on success, -1 otherwise
      */
-    public int lookupLong(final long n) {
+    public int lookupLong( final long n ) {
         for (int i = 1; i < index; i++) {
             if (constants[i] instanceof ConstantLong) {
                 final ConstantLong c = (ConstantLong) constants[i];
                 if (c.getBytes() == n) {
                     return i;
@@ -429,18 +448,18 @@
             }
         }
         return -1;
     }
 
+
     /**
-     * Add a new long constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new long constant to the ConstantPool, if it is not already in there.
      *
      * @param n Long number to add
      * @return index of entry
      */
-    public int addLong(final long n) {
+    public int addLong( final long n ) {
         int ret;
         if ((ret = lookupLong(n)) != -1) {
             return ret; // Already in CP
         }
         adjustSize();
@@ -448,17 +467,18 @@
         constants[index] = new ConstantLong(n);
         index += 2; // Wastes one entry according to spec
         return ret;
     }
 
+
     /**
      * Look for ConstantDouble in ConstantPool.
      *
      * @param n Double number to look for
      * @return index on success, -1 otherwise
      */
-    public int lookupDouble(final double n) {
+    public int lookupDouble( final double n ) {
         final long bits = Double.doubleToLongBits(n);
         for (int i = 1; i < index; i++) {
             if (constants[i] instanceof ConstantDouble) {
                 final ConstantDouble c = (ConstantDouble) constants[i];
                 if (Double.doubleToLongBits(c.getBytes()) == bits) {
@@ -467,18 +487,18 @@
             }
         }
         return -1;
     }
 
+
     /**
-     * Add a new double constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new double constant to the ConstantPool, if it is not already in there.
      *
      * @param n Double number to add
      * @return index of entry
      */
-    public int addDouble(final double n) {
+    public int addDouble( final double n ) {
         int ret;
         if ((ret = lookupDouble(n)) != -1) {
             return ret; // Already in CP
         }
         adjustSize();
@@ -488,31 +508,33 @@
         return ret;
     }
 
     private final Map<String, Index> n_a_t_table = new HashMap<>();
 
+
     /**
      * Look for ConstantNameAndType in ConstantPool.
      *
      * @param name of variable/method
      * @param signature of variable/method
      * @return index on success, -1 otherwise
      */
-    public int lookupNameAndType(final String name, final String signature) {
+    public int lookupNameAndType( final String name, final String signature ) {
         final Index _index = n_a_t_table.get(name + NAT_DELIM + signature);
         return (_index != null) ? _index.index : -1;
     }
 
+
     /**
      * Add a new NameAndType constant to the ConstantPool if it is not already
      * in there.
      *
      * @param name Name string to add
      * @param signature signature string to add
      * @return index of entry
      */
-    public int addNameAndType(final String name, final String signature) {
+    public int addNameAndType( final String name, final String signature ) {
         int ret;
         int name_index;
         int signature_index;
         if ((ret = lookupNameAndType(name, signature)) != -1) {
             return ret; // Already in CP
@@ -529,38 +551,41 @@
         return ret;
     }
 
     private final Map<String, Index> cp_table = new HashMap<>();
 
+
     /**
      * Look for ConstantMethodref in ConstantPool.
      *
      * @param class_name Where to find method
      * @param method_name Guess what
      * @param signature return and argument types
      * @return index on success, -1 otherwise
      */
-    public int lookupMethodref(final String class_name, final String method_name, final String signature) {
+    public int lookupMethodref( final String class_name, final String method_name, final String signature ) {
         final Index index = cp_table.get(class_name + METHODREF_DELIM + method_name
                 + METHODREF_DELIM + signature);
         return (index != null) ? index.index : -1;
     }
 
-    public int lookupMethodref(final MethodGen method) {
+
+    public int lookupMethodref( final MethodGen method ) {
         return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());
     }
 
+
     /**
-     * Add a new Methodref constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new Methodref constant to the ConstantPool, if it is not already
+     * in there.
      *
      * @param class_name class name string to add
      * @param method_name method name string to add
      * @param signature method signature string to add
      * @return index of entry
      */
-    public int addMethodref(final String class_name, final String method_name, final String signature) {
+    public int addMethodref( final String class_name, final String method_name, final String signature ) {
         int ret;
         int class_index;
         int name_and_type_index;
         if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {
             return ret; // Already in CP
@@ -575,43 +600,47 @@
             cp_table.put(key, new Index(ret));
         }
         return ret;
     }
 
-    public int addMethodref(final MethodGen method) {
+
+    public int addMethodref( final MethodGen method ) {
         return addMethodref(method.getClassName(), method.getName(), method.getSignature());
     }
 
+
     /**
      * Look for ConstantInterfaceMethodref in ConstantPool.
      *
      * @param class_name Where to find method
      * @param method_name Guess what
      * @param signature return and argument types
      * @return index on success, -1 otherwise
      */
-    public int lookupInterfaceMethodref(final String class_name, final String method_name, final String signature) {
+    public int lookupInterfaceMethodref( final String class_name, final String method_name, final String signature ) {
         final Index index = cp_table.get(class_name + IMETHODREF_DELIM + method_name
                 + IMETHODREF_DELIM + signature);
         return (index != null) ? index.index : -1;
     }
 
-    public int lookupInterfaceMethodref(final MethodGen method) {
+
+    public int lookupInterfaceMethodref( final MethodGen method ) {
         return lookupInterfaceMethodref(method.getClassName(), method.getName(), method
                 .getSignature());
     }
 
+
     /**
-     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not
-     * already in there.
+     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already
+     * in there.
      *
      * @param class_name class name string to add
      * @param method_name method name string to add
      * @param signature signature string to add
      * @return index of entry
      */
-    public int addInterfaceMethodref(final String class_name, final String method_name, final String signature) {
+    public int addInterfaceMethodref( final String class_name, final String method_name, final String signature ) {
         int ret;
         int class_index;
         int name_and_type_index;
         if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {
             return ret; // Already in CP
@@ -626,38 +655,41 @@
             cp_table.put(key, new Index(ret));
         }
         return ret;
     }
 
-    public int addInterfaceMethodref(final MethodGen method) {
+
+    public int addInterfaceMethodref( final MethodGen method ) {
         return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());
     }
 
+
     /**
      * Look for ConstantFieldref in ConstantPool.
      *
      * @param class_name Where to find method
      * @param field_name Guess what
      * @param signature return and argument types
      * @return index on success, -1 otherwise
      */
-    public int lookupFieldref(final String class_name, final String field_name, final String signature) {
+    public int lookupFieldref( final String class_name, final String field_name, final String signature ) {
         final Index index = cp_table.get(class_name + FIELDREF_DELIM + field_name
                 + FIELDREF_DELIM + signature);
         return (index != null) ? index.index : -1;
     }
 
+
     /**
-     * Add a new Fieldref constant to the ConstantPool, if it is not already in
-     * there.
+     * Add a new Fieldref constant to the ConstantPool, if it is not already
+     * in there.
      *
      * @param class_name class name string to add
      * @param field_name field name string to add
      * @param signature signature string to add
      * @return index of entry
      */
-    public int addFieldref(final String class_name, final String field_name, final String signature) {
+    public int addFieldref( final String class_name, final String field_name, final String signature ) {
         int ret;
         int class_index;
         int name_and_type_index;
         if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {
             return ret; // Already in CP
@@ -672,51 +704,57 @@
             cp_table.put(key, new Index(ret));
         }
         return ret;
     }
 
+
     /**
      * @param i index in constant pool
      * @return constant pool entry at index i
      */
-    public Constant getConstant(final int i) {
+    public Constant getConstant( final int i ) {
         return constants[i];
     }
 
+
     /**
      * Use with care!
      *
      * @param i index in constant pool
      * @param c new constant pool entry at index i
      */
-    public void setConstant(final int i, final Constant c) {
+    public void setConstant( final int i, final Constant c ) {
         constants[i] = c;
     }
 
+
     /**
      * @return intermediate constant pool
      */
     public ConstantPool getConstantPool() {
         return new ConstantPool(constants);
     }
 
+
     /**
      * @return current size of constant pool
      */
     public int getSize() {
         return index;
     }
 
+
     /**
      * @return constant pool with proper length
      */
     public ConstantPool getFinalConstantPool() {
         final Constant[] cs = new Constant[index];
         System.arraycopy(constants, 0, cs, 0, index);
         return new ConstantPool(cs);
     }
 
+
     /**
      * @return String representation.
      */
     @Override
     public String toString() {
@@ -725,14 +763,14 @@
             buf.append(i).append(")").append(constants[i]).append("\n");
         }
         return buf.toString();
     }
 
-    /**
-     * Import constant from another ConstantPool and return new index.
+
+    /** Import constant from another ConstantPool and return new index.
      */
-    public int addConstant(final Constant c, final ConstantPoolGen cp) {
+    public int addConstant( final Constant c, final ConstantPoolGen cp ) {
         final Constant[] constants = cp.getConstantPool().getConstantPool();
         switch (c.getTag()) {
             case Const.CONSTANT_String: {
                 final ConstantString s = (ConstantString) c;
                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];

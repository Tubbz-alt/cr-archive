<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/FieldGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FSUB.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FieldGenOrMethodGen.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/FieldGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 19,10 ***</span>
<span class="line-new-header">--- 19,11 ---</span>
   */
  package com.sun.org.apache.bcel.internal.generic;
  
  import java.util.ArrayList;
  import java.util.List;
<span class="line-added">+ import java.util.Objects;</span>
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
  import com.sun.org.apache.bcel.internal.classfile.Annotations;
  import com.sun.org.apache.bcel.internal.classfile.Attribute;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,160 ***</span>
  import com.sun.org.apache.bcel.internal.classfile.Field;
  import com.sun.org.apache.bcel.internal.classfile.Utility;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  
  /**
<span class="line-modified">!  * Template class for building up a field. The only extraordinary thing one can</span>
<span class="line-modified">!  * do is to add a constant value attribute to a field (which must of course be</span>
<span class="line-modified">!  * compatible with to the declared type).</span>
   *
<span class="line-removed">-  * @version $Id: FieldGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   * @see Field
   */
  public class FieldGen extends FieldGenOrMethodGen {
  
      private Object value = null;
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals(final Object o1, final Object o2) {</span>
              final FieldGen THIS = (FieldGen) o1;
              final FieldGen THAT = (FieldGen) o2;
<span class="line-modified">!             return THIS.getName().equals(THAT.getName())</span>
<span class="line-modified">!                     &amp;&amp; THIS.getSignature().equals(THAT.getSignature());</span>
          }
  
          @Override
<span class="line-modified">!         public int hashCode(final Object o) {</span>
              final FieldGen THIS = (FieldGen) o;
              return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
          }
      };
  
      /**
<span class="line-modified">!      * Declare a field. If it is static (isStatic() == true) and has a basic</span>
<span class="line-modified">!      * type like int or String it may have an initial value associated with it</span>
<span class="line-modified">!      * as defined by setInitValue().</span>
       *
       * @param access_flags access qualifiers
<span class="line-modified">!      * @param type field type</span>
       * @param name field name
       * @param cp constant pool
       */
      public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {
          super(access_flags);
          setType(type);
          setName(name);
          setConstantPool(cp);
      }
  
      /**
       * Instantiate from existing field.
       *
       * @param field Field object
<span class="line-modified">!      * @param cp constant pool (must contain the same entries as the field&#39;s</span>
<span class="line-removed">-      * constant pool)</span>
       */
      public FieldGen(final Field field, final ConstantPoolGen cp) {
          this(field.getAccessFlags(), Type.getType(field.getSignature()), field.getName(), cp);
          final Attribute[] attrs = field.getAttributes();
          for (final Attribute attr : attrs) {
              if (attr instanceof ConstantValue) {
                  setValue(((ConstantValue) attr).getConstantValueIndex());
              } else if (attr instanceof Annotations) {
<span class="line-modified">!                 final Annotations runtimeAnnotations = (Annotations) attr;</span>
                  final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();
                  for (final AnnotationEntry element : annotationEntries) {
<span class="line-modified">!                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));</span>
                  }
              } else {
                  addAttribute(attr);
              }
          }
      }
  
<span class="line-modified">!     private void setValue(final int index) {</span>
          final ConstantPool cp = super.getConstantPool().getConstantPool();
          final Constant c = cp.getConstant(index);
          value = ((ConstantObject) c).getConstantValue(cp);
      }
  
      /**
<span class="line-modified">!      * Set (optional) initial value of field, otherwise it will be set to</span>
<span class="line-modified">!      * null/0/false by the JVM automatically.</span>
       */
<span class="line-modified">!     public void setInitValue(final String str) {</span>
<span class="line-modified">!         checkType(ObjectType.getInstance(&quot;java.lang.String&quot;));</span>
          if (str != null) {
              value = str;
          }
      }
  
<span class="line-modified">!     public void setInitValue(final long l) {</span>
          checkType(Type.LONG);
          if (l != 0L) {
<span class="line-modified">!             value = l;</span>
          }
      }
  
<span class="line-modified">!     public void setInitValue(final int i) {</span>
          checkType(Type.INT);
          if (i != 0) {
<span class="line-modified">!             value = i;</span>
          }
      }
  
<span class="line-modified">!     public void setInitValue(final short s) {</span>
          checkType(Type.SHORT);
          if (s != 0) {
<span class="line-modified">!             value = (int) s;</span>
          }
      }
  
<span class="line-modified">!     public void setInitValue(final char c) {</span>
          checkType(Type.CHAR);
          if (c != 0) {
<span class="line-modified">!             value = (int) c;</span>
          }
      }
  
<span class="line-modified">!     public void setInitValue(final byte b) {</span>
          checkType(Type.BYTE);
          if (b != 0) {
<span class="line-modified">!             value = (int) b;</span>
          }
      }
  
<span class="line-modified">!     public void setInitValue(final boolean b) {</span>
          checkType(Type.BOOLEAN);
          if (b) {
<span class="line-modified">!             value = 1;</span>
          }
      }
  
<span class="line-modified">!     public void setInitValue(final float f) {</span>
          checkType(Type.FLOAT);
          if (f != 0.0) {
              value = f;
          }
      }
  
<span class="line-modified">!     public void setInitValue(final double d) {</span>
          checkType(Type.DOUBLE);
          if (d != 0.0) {
              value = d;
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Remove any initial value.</span>
       */
      public void cancelInitValue() {
          value = null;
      }
  
<span class="line-modified">!     private void checkType(final Type atype) {</span>
          final Type superType = super.getType();
          if (superType == null) {
              throw new ClassGenException(&quot;You haven&#39;t defined the type of the field yet&quot;);
          }
          if (!isFinal()) {
<span class="line-new-header">--- 34,173 ---</span>
  import com.sun.org.apache.bcel.internal.classfile.Field;
  import com.sun.org.apache.bcel.internal.classfile.Utility;
  import com.sun.org.apache.bcel.internal.util.BCELComparator;
  
  /**
<span class="line-modified">!  * Template class for building up a field.  The only extraordinary thing</span>
<span class="line-modified">!  * one can do is to add a constant value attribute to a field (which must of</span>
<span class="line-modified">!  * course be compatible with to the declared type).</span>
   *
   * @see Field
<span class="line-added">+  * @LastModified: Jan 2020</span>
   */
  public class FieldGen extends FieldGenOrMethodGen {
  
      private Object value = null;
      private static BCELComparator bcelComparator = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals( final Object o1, final Object o2 ) {</span>
              final FieldGen THIS = (FieldGen) o1;
              final FieldGen THAT = (FieldGen) o2;
<span class="line-modified">!             return Objects.equals(THIS.getName(), THAT.getName())</span>
<span class="line-modified">!                     &amp;&amp; Objects.equals(THIS.getSignature(), THAT.getSignature());</span>
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public int hashCode( final Object o ) {</span>
              final FieldGen THIS = (FieldGen) o;
              return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
          }
      };
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Declare a field. If it is static (isStatic() == true) and has a</span>
<span class="line-modified">!      * basic type like int or String it may have an initial value</span>
<span class="line-modified">!      * associated with it as defined by setInitValue().</span>
       *
       * @param access_flags access qualifiers
<span class="line-modified">!      * @param type  field type</span>
       * @param name field name
       * @param cp constant pool
       */
      public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {
          super(access_flags);
          setType(type);
          setName(name);
          setConstantPool(cp);
      }
  
<span class="line-added">+ </span>
      /**
       * Instantiate from existing field.
       *
       * @param field Field object
<span class="line-modified">!      * @param cp constant pool (must contain the same entries as the field&#39;s constant pool)</span>
       */
      public FieldGen(final Field field, final ConstantPoolGen cp) {
          this(field.getAccessFlags(), Type.getType(field.getSignature()), field.getName(), cp);
          final Attribute[] attrs = field.getAttributes();
          for (final Attribute attr : attrs) {
              if (attr instanceof ConstantValue) {
                  setValue(((ConstantValue) attr).getConstantValueIndex());
              } else if (attr instanceof Annotations) {
<span class="line-modified">!                 final Annotations runtimeAnnotations = (Annotations)attr;</span>
                  final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();
                  for (final AnnotationEntry element : annotationEntries) {
<span class="line-modified">!                     addAnnotationEntry(new AnnotationEntryGen(element,cp,false));</span>
                  }
              } else {
                  addAttribute(attr);
              }
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private void setValue( final int index ) {</span>
          final ConstantPool cp = super.getConstantPool().getConstantPool();
          final Constant c = cp.getConstant(index);
          value = ((ConstantObject) c).getConstantValue(cp);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Set (optional) initial value of field, otherwise it will be set to null/0/false</span>
<span class="line-modified">!      * by the JVM automatically.</span>
       */
<span class="line-modified">!     public void setInitValue( final String str ) {</span>
<span class="line-modified">!         checkType(  ObjectType.getInstance(&quot;java.lang.String&quot;));</span>
          if (str != null) {
              value = str;
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final long l ) {</span>
          checkType(Type.LONG);
          if (l != 0L) {
<span class="line-modified">!             value = Long.valueOf(l);</span>
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final int i ) {</span>
          checkType(Type.INT);
          if (i != 0) {
<span class="line-modified">!             value = Integer.valueOf(i);</span>
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final short s ) {</span>
          checkType(Type.SHORT);
          if (s != 0) {
<span class="line-modified">!             value = Integer.valueOf(s);</span>
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final char c ) {</span>
          checkType(Type.CHAR);
          if (c != 0) {
<span class="line-modified">!             value = Integer.valueOf(c);</span>
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final byte b ) {</span>
          checkType(Type.BYTE);
          if (b != 0) {
<span class="line-modified">!             value = Integer.valueOf(b);</span>
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final boolean b ) {</span>
          checkType(Type.BOOLEAN);
          if (b) {
<span class="line-modified">!             value = Integer.valueOf(1);</span>
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final float f ) {</span>
          checkType(Type.FLOAT);
          if (f != 0.0) {
              value = f;
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setInitValue( final double d ) {</span>
          checkType(Type.DOUBLE);
          if (d != 0.0) {
              value = d;
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Remove any initial value.</span>
       */
      public void cancelInitValue() {
          value = null;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private void checkType( final Type atype ) {</span>
          final Type superType = super.getType();
          if (superType == null) {
              throw new ClassGenException(&quot;You haven&#39;t defined the type of the field yet&quot;);
          }
          if (!isFinal()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 195,10 ***</span>
<span class="line-new-header">--- 209,11 ---</span>
          if (!superType.equals(atype)) {
              throw new ClassGenException(&quot;Types are not compatible: &quot; + superType + &quot; vs. &quot; + atype);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Get field object after having set up all necessary values.
       */
      public Field getField() {
          final String signature = getSignature();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,15 ***</span>
          return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),
                  super.getConstantPool().getConstantPool()); // sic
      }
  
      private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified">!         final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
          for (final Attribute attr : attrs) {
              addAttribute(attr);
          }
<span class="line-modified">!     }</span>
  
      private int addConstant() {
          switch (super.getType().getType()) { // sic
              case Const.T_INT:
              case Const.T_CHAR:
<span class="line-new-header">--- 229,16 ---</span>
          return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),
                  super.getConstantPool().getConstantPool()); // sic
      }
  
      private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified">!           final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
          for (final Attribute attr : attrs) {
              addAttribute(attr);
          }
<span class="line-modified">!       }</span>
<span class="line-added">+ </span>
  
      private int addConstant() {
          switch (super.getType().getType()) { // sic
              case Const.T_INT:
              case Const.T_CHAR:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,59 ***</span>
              default:
                  throw new RuntimeException(&quot;Oops: Unhandled : &quot; + super.getType().getType()); // sic
          }
      }
  
      @Override
      public String getSignature() {
          return super.getType().getSignature();
      }
  
      private List&lt;FieldObserver&gt; observers;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add observer for this object.</span>
       */
<span class="line-modified">!     public void addObserver(final FieldObserver o) {</span>
          if (observers == null) {
              observers = new ArrayList&lt;&gt;();
          }
          observers.add(o);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Remove observer for this object.</span>
       */
<span class="line-modified">!     public void removeObserver(final FieldObserver o) {</span>
          if (observers != null) {
              observers.remove(o);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">!      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">!      * user after he has finished editing the object.</span>
       */
      public void update() {
          if (observers != null) {
<span class="line-modified">!             for (final FieldObserver observer : observers) {</span>
                  observer.notify(this);
              }
          }
      }
  
      public String getInitValue() {
          if (value != null) {
              return value.toString();
          }
          return null;
      }
  
      /**
<span class="line-modified">!      * Return string representation close to declaration format, `public static</span>
<span class="line-modified">!      * final short MAX = 100&#39;, e.g..</span>
       *
       * @return String representation of field
       */
      @Override
      public final String toString() {
<span class="line-new-header">--- 257,62 ---</span>
              default:
                  throw new RuntimeException(&quot;Oops: Unhandled : &quot; + super.getType().getType()); // sic
          }
      }
  
<span class="line-added">+ </span>
      @Override
      public String getSignature() {
          return super.getType().getSignature();
      }
  
      private List&lt;FieldObserver&gt; observers;
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Add observer for this object.</span>
       */
<span class="line-modified">!     public void addObserver( final FieldObserver o ) {</span>
          if (observers == null) {
              observers = new ArrayList&lt;&gt;();
          }
          observers.add(o);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Remove observer for this object.</span>
       */
<span class="line-modified">!     public void removeObserver( final FieldObserver o ) {</span>
          if (observers != null) {
              observers.remove(o);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">!      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">!      * called by the user after he has finished editing the object.</span>
       */
      public void update() {
          if (observers != null) {
<span class="line-modified">!             for (final FieldObserver observer : observers ) {</span>
                  observer.notify(this);
              }
          }
      }
  
<span class="line-added">+ </span>
      public String getInitValue() {
          if (value != null) {
              return value.toString();
          }
          return null;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return string representation close to declaration format,</span>
<span class="line-modified">!      * `public static final short MAX = 100&#39;, e.g..</span>
       *
       * @return String representation of field
       */
      @Override
      public final String toString() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,48 ***</span>
              buf.append(&quot; = &quot;).append(value);
          }
          return buf.toString();
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return deep copy of this field</span>
       */
<span class="line-modified">!     public FieldGen copy(final ConstantPoolGen cp) {</span>
          final FieldGen fg = (FieldGen) clone();
          fg.setConstantPool(cp);
          return fg;
      }
  
      /**
       * @return Comparison strategy object
       */
      public static BCELComparator getComparator() {
          return bcelComparator;
      }
  
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator(final BCELComparator comparator) {</span>
          bcelComparator = comparator;
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">!      * FieldGen objects are said to be equal when their names and signatures are</span>
<span class="line-modified">!      * equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals(final Object obj) {</span>
          return bcelComparator.equals(this, obj);
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">!      * return the hashcode of the field&#39;s name XOR signature.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
<span class="line-new-header">--- 330,52 ---</span>
              buf.append(&quot; = &quot;).append(value);
          }
          return buf.toString();
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return deep copy of this field</span>
       */
<span class="line-modified">!     public FieldGen copy( final ConstantPoolGen cp ) {</span>
          final FieldGen fg = (FieldGen) clone();
          fg.setConstantPool(cp);
          return fg;
      }
  
<span class="line-added">+ </span>
      /**
       * @return Comparison strategy object
       */
      public static BCELComparator getComparator() {
          return bcelComparator;
      }
  
<span class="line-added">+ </span>
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator( final BCELComparator comparator ) {</span>
          bcelComparator = comparator;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default two FieldGen objects are said to be equal when</span>
<span class="line-modified">!      * their names and signatures are equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals( final Object obj ) {</span>
          return bcelComparator.equals(this, obj);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default return the hashcode of the field&#39;s name XOR signature.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
</pre>
<center><a href="FSUB.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FieldGenOrMethodGen.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
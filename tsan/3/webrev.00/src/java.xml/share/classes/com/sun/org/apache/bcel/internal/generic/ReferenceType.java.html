<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ReferenceType.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.Const;
 24 import com.sun.org.apache.bcel.internal.Repository;
 25 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 26 
 27 /**
 28  * Super class for object and array types.
 29  *
 30  */
 31 public abstract class ReferenceType extends Type {
 32 
 33     protected ReferenceType(final byte t, final String s) {
 34         super(t, s);
 35     }
 36 
 37 
 38     /** Class is non-abstract but not instantiable from the outside
 39      */
 40     ReferenceType() {
 41         super(Const.T_OBJECT, &quot;&lt;null object&gt;&quot;);
 42     }
 43 
 44 
 45     /**
 46      * Return true iff this type is castable to another type t as defined in
 47      * the JVM specification.  The case where this is Type.NULL is not
 48      * defined (see the CHECKCAST definition in the JVM specification).
 49      * However, because e.g. CHECKCAST doesn&#39;t throw a
 50      * ClassCastException when casting a null reference to any Object,
 51      * true is returned in this case.
 52      *
 53      * @throws ClassNotFoundException if any classes or interfaces required
 54      *  to determine assignment compatibility can&#39;t be found
 55      */
 56     public boolean isCastableTo( final Type t ) throws ClassNotFoundException {
 57         if (this.equals(Type.NULL)) {
 58             return t instanceof ReferenceType; // If this is ever changed in isAssignmentCompatible()
 59         }
 60         return isAssignmentCompatibleWith(t);
 61         /* Yes, it&#39;s true: It&#39;s the same definition.
 62          * See vmspec2 AASTORE / CHECKCAST definitions.
 63          */
 64     }
 65 
 66 
 67     /**
 68      * Return true iff this is assignment compatible with another type t
 69      * as defined in the JVM specification; see the AASTORE definition
 70      * there.
 71      * @throws ClassNotFoundException if any classes or interfaces required
 72      *  to determine assignment compatibility can&#39;t be found
 73      */
 74     public boolean isAssignmentCompatibleWith( final Type t ) throws ClassNotFoundException {
 75         if (!(t instanceof ReferenceType)) {
 76             return false;
 77         }
 78         final ReferenceType T = (ReferenceType) t;
 79         if (this.equals(Type.NULL)) {
 80             return true; // This is not explicitely stated, but clear. Isn&#39;t it?
 81         }
 82         /* If this is a class type then
 83          */
 84         if ((this instanceof ObjectType) &amp;&amp; (((ObjectType) this).referencesClassExact())) {
 85             /* If T is a class type, then this must be the same class as T,
 86              or this must be a subclass of T;
 87              */
 88             if ((T instanceof ObjectType) &amp;&amp; (((ObjectType) T).referencesClassExact())) {
 89                 if (this.equals(T)) {
 90                     return true;
 91                 }
 92                 if (Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T)
 93                         .getClassName())) {
 94                     return true;
 95                 }
 96             }
 97             /* If T is an interface type, this must implement interface T.
 98              */
 99             if ((T instanceof ObjectType) &amp;&amp; (((ObjectType) T).referencesInterfaceExact())) {
100                 if (Repository.implementationOf(((ObjectType) this).getClassName(),
101                         ((ObjectType) T).getClassName())) {
102                     return true;
103                 }
104             }
105         }
106         /* If this is an interface type, then:
107          */
108         if ((this instanceof ObjectType) &amp;&amp; (((ObjectType) this).referencesInterfaceExact())) {
109             /* If T is a class type, then T must be Object (2.4.7).
110              */
111             if ((T instanceof ObjectType) &amp;&amp; (((ObjectType) T).referencesClassExact())) {
112                 if (T.equals(Type.OBJECT)) {
113                     return true;
114                 }
115             }
116             /* If T is an interface type, then T must be the same interface
117              * as this or a superinterface of this (2.13.2).
118              */
119             if ((T instanceof ObjectType) &amp;&amp; (((ObjectType) T).referencesInterfaceExact())) {
120                 if (this.equals(T)) {
121                     return true;
122                 }
123                 if (Repository.implementationOf(((ObjectType) this).getClassName(),
124                         ((ObjectType) T).getClassName())) {
125                     return true;
126                 }
127             }
128         }
129         /* If this is an array type, namely, the type SC[], that is, an
130          * array of components of type SC, then:
131          */
132         if (this instanceof ArrayType) {
133             /* If T is a class type, then T must be Object (2.4.7).
134              */
135             if ((T instanceof ObjectType) &amp;&amp; (((ObjectType) T).referencesClassExact())) {
136                 if (T.equals(Type.OBJECT)) {
137                     return true;
138                 }
139             }
140             /* If T is an array type TC[], that is, an array of components
141              * of type TC, then one of the following must be true:
142              */
143             if (T instanceof ArrayType) {
144                 /* TC and SC are the same primitive type (2.4.1).
145                  */
146                 final Type sc = ((ArrayType) this).getElementType();
147                 final Type tc = ((ArrayType) T).getElementType();
148                 if (sc instanceof BasicType &amp;&amp; tc instanceof BasicType &amp;&amp; sc.equals(tc)) {
149                     return true;
150                 }
151                 /* TC and SC are reference types (2.4.6), and type SC is
152                  * assignable to TC by these runtime rules.
153                  */
154                 if (tc instanceof ReferenceType &amp;&amp; sc instanceof ReferenceType
155                         &amp;&amp; ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {
156                     return true;
157                 }
158             }
159             /* If T is an interface type, T must be one of the interfaces implemented by arrays (2.15). */
160             // TODO: Check if this is still valid or find a way to dynamically find out which
161             // interfaces arrays implement. However, as of the JVM specification edition 2, there
162             // are at least two different pages where assignment compatibility is defined and
163             // on one of them &quot;interfaces implemented by arrays&quot; is exchanged with &quot;&#39;Cloneable&#39; or
164             // &#39;java.io.Serializable&#39;&quot;
165             if ((T instanceof ObjectType) &amp;&amp; (((ObjectType) T).referencesInterfaceExact())) {
166                 for (final String element : Const.getInterfacesImplementedByArrays()) {
167                     if (T.equals(ObjectType.getInstance(element))) {
168                         return true;
169                     }
170                 }
171             }
172         }
173         return false; // default.
174     }
175 
176 
177     /**
178      * This commutative operation returns the first common superclass (narrowest ReferenceType
179      * referencing a class, not an interface).
180      * If one of the types is a superclass of the other, the former is returned.
181      * If &quot;this&quot; is Type.NULL, then t is returned.
182      * If t is Type.NULL, then &quot;this&quot; is returned.
183      * If &quot;this&quot; equals t [&#39;this.equals(t)&#39;] &quot;this&quot; is returned.
184      * If &quot;this&quot; or t is an ArrayType, then Type.OBJECT is returned;
185      * unless their dimensions match. Then an ArrayType of the same
186      * number of dimensions is returned, with its basic type being the
187      * first common super class of the basic types of &quot;this&quot; and t.
188      * If &quot;this&quot; or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.
189      * If not all of the two classes&#39; superclasses cannot be found, &quot;null&quot; is returned.
190      * See the JVM specification edition 2, &quot;4.9.2 The Bytecode Verifier&quot;.
191      *
192      * @throws ClassNotFoundException on failure to find superclasses of this
193      *  type, or the type passed as a parameter
194      */
195     public ReferenceType getFirstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {
196         if (this.equals(Type.NULL)) {
197             return t;
198         }
199         if (t.equals(Type.NULL)) {
200             return this;
201         }
202         if (this.equals(t)) {
203             return this;
204             /*
205              * TODO: Above sounds a little arbitrary. On the other hand, there is
206              * no object referenced by Type.NULL so we can also say all the objects
207              * referenced by Type.NULL were derived from java.lang.Object.
208              * However, the Java Language&#39;s &quot;instanceof&quot; operator proves us wrong:
209              * &quot;null&quot; is not referring to an instance of java.lang.Object :)
210              */
211         }
212         /* This code is from a bug report by Konstantin Shagin &lt;konst@cs.technion.ac.il&gt; */
213         if ((this instanceof ArrayType) &amp;&amp; (t instanceof ArrayType)) {
214             final ArrayType arrType1 = (ArrayType) this;
215             final ArrayType arrType2 = (ArrayType) t;
216             if ((arrType1.getDimensions() == arrType2.getDimensions())
217                     &amp;&amp; arrType1.getBasicType() instanceof ObjectType
218                     &amp;&amp; arrType2.getBasicType() instanceof ObjectType) {
219                 return new ArrayType(((ObjectType) arrType1.getBasicType())
220                         .getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()), arrType1
221                         .getDimensions());
222             }
223         }
224         if ((this instanceof ArrayType) || (t instanceof ArrayType)) {
225             return Type.OBJECT;
226             // TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?
227         }
228         if (((this instanceof ObjectType) &amp;&amp; ((ObjectType) this).referencesInterfaceExact())
229                 || ((t instanceof ObjectType) &amp;&amp; ((ObjectType) t).referencesInterfaceExact())) {
230             return Type.OBJECT;
231             // TODO: The above line is correct comparing to the vmspec2. But one could
232             // make class file verification a bit stronger here by using the notion of
233             // superinterfaces or even castability or assignment compatibility.
234         }
235         // this and t are ObjectTypes, see above.
236         final ObjectType thiz = (ObjectType) this;
237         final ObjectType other = (ObjectType) t;
238         final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());
239         final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());
240         if ((thiz_sups == null) || (other_sups == null)) {
241             return null;
242         }
243         // Waaahh...
244         final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];
245         final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];
246         System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);
247         System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);
248         this_sups[0] = Repository.lookupClass(thiz.getClassName());
249         t_sups[0] = Repository.lookupClass(other.getClassName());
250         for (final JavaClass t_sup : t_sups) {
251             for (final JavaClass this_sup : this_sups) {
252                 if (this_sup.equals(t_sup)) {
253                     return ObjectType.getInstance(this_sup.getClassName());
254                 }
255             }
256         }
257         // Huh? Did you ask for Type.OBJECT&#39;s superclass??
258         return null;
259     }
260 
261     /**
262      * This commutative operation returns the first common superclass (narrowest ReferenceType
263      * referencing a class, not an interface).
264      * If one of the types is a superclass of the other, the former is returned.
265      * If &quot;this&quot; is Type.NULL, then t is returned.
266      * If t is Type.NULL, then &quot;this&quot; is returned.
267      * If &quot;this&quot; equals t [&#39;this.equals(t)&#39;] &quot;this&quot; is returned.
268      * If &quot;this&quot; or t is an ArrayType, then Type.OBJECT is returned.
269      * If &quot;this&quot; or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.
270      * If not all of the two classes&#39; superclasses cannot be found, &quot;null&quot; is returned.
271      * See the JVM specification edition 2, &quot;4.9.2 The Bytecode Verifier&quot;.
272      *
273      * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has
274      *             slightly changed semantics.
275      * @throws ClassNotFoundException on failure to find superclasses of this
276      *  type, or the type passed as a parameter
277      */
278     @Deprecated
279     public ReferenceType firstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {
280         if (this.equals(Type.NULL)) {
281             return t;
282         }
283         if (t.equals(Type.NULL)) {
284             return this;
285         }
286         if (this.equals(t)) {
287             return this;
288             /*
289              * TODO: Above sounds a little arbitrary. On the other hand, there is
290              * no object referenced by Type.NULL so we can also say all the objects
291              * referenced by Type.NULL were derived from java.lang.Object.
292              * However, the Java Language&#39;s &quot;instanceof&quot; operator proves us wrong:
293              * &quot;null&quot; is not referring to an instance of java.lang.Object :)
294              */
295         }
296         if ((this instanceof ArrayType) || (t instanceof ArrayType)) {
297             return Type.OBJECT;
298             // TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?
299         }
300         if (((this instanceof ObjectType) &amp;&amp; ((ObjectType) this).referencesInterface())
301                 || ((t instanceof ObjectType) &amp;&amp; ((ObjectType) t).referencesInterface())) {
302             return Type.OBJECT;
303             // TODO: The above line is correct comparing to the vmspec2. But one could
304             // make class file verification a bit stronger here by using the notion of
305             // superinterfaces or even castability or assignment compatibility.
306         }
307         // this and t are ObjectTypes, see above.
308         final ObjectType thiz = (ObjectType) this;
309         final ObjectType other = (ObjectType) t;
310         final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());
311         final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());
312         if ((thiz_sups == null) || (other_sups == null)) {
313             return null;
314         }
315         // Waaahh...
316         final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];
317         final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];
318         System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);
319         System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);
320         this_sups[0] = Repository.lookupClass(thiz.getClassName());
321         t_sups[0] = Repository.lookupClass(other.getClassName());
322         for (final JavaClass t_sup : t_sups) {
323             for (final JavaClass this_sup : this_sups) {
324                 if (this_sup.equals(t_sup)) {
325                     return ObjectType.getInstance(this_sup.getClassName());
326                 }
327             }
328         }
329         // Huh? Did you ask for Type.OBJECT&#39;s superclass??
330         return null;
331     }
332 }
    </pre>
  </body>
</html>
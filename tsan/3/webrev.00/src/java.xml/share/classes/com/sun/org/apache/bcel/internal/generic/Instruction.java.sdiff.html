<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Instruction.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IndexedInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionComparator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Instruction.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 27 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 28 
 29 /**
 30  * Abstract super class for all Java byte codes.
 31  *
<span class="line-modified"> 32  * @version $Id: Instruction.java 1750029 2016-06-23 22:14:38Z sebb $</span>
 33  */
 34 public abstract class Instruction implements Cloneable {
 35 
 36     private short length = 1; // Length of instruction in bytes
 37     private short opcode = -1; // Opcode number
 38 
 39     private static InstructionComparator cmp = InstructionComparator.DEFAULT;
 40 

 41     /**
<span class="line-modified"> 42      * Empty constructor needed for the Class.newInstance() statement in</span>
<span class="line-modified"> 43      * Instruction.readInstruction(). Not to be used otherwise.</span>
 44      */
 45     Instruction() {
 46     }
 47 

 48     public Instruction(final short opcode, final short length) {
 49         this.length = length;
 50         this.opcode = opcode;
 51     }
 52 

 53     /**
 54      * Dump instruction as byte code to stream out.
<span class="line-removed"> 55      *</span>
 56      * @param out Output stream
 57      */
<span class="line-modified"> 58     public void dump(final DataOutputStream out) throws IOException {</span>
 59         out.writeByte(opcode); // Common for all instructions
 60     }
 61 
<span class="line-modified"> 62     /**</span>
<span class="line-modified"> 63      * @return name of instruction, i.e., opcode name</span>
 64      */
 65     public String getName() {
 66         return Const.getOpcodeName(opcode);
 67     }
 68 

 69     /**
 70      * Long output format:
 71      *
<span class="line-modified"> 72      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot; &quot;(&quot;&amp;lt;length of</span>
<span class="line-modified"> 73      * instruction&amp;gt;&quot;)&quot;</span>
 74      *
 75      * @param verbose long/short format switch
 76      * @return mnemonic for instruction
 77      */
<span class="line-modified"> 78     public String toString(final boolean verbose) {</span>
 79         if (verbose) {
 80             return getName() + &quot;[&quot; + opcode + &quot;](&quot; + length + &quot;)&quot;;
 81         }
 82         return getName();
 83     }
 84 

 85     /**
 86      * @return mnemonic for instruction in verbose format
 87      */
 88     @Override
 89     public String toString() {
 90         return toString(true);
 91     }
 92 

 93     /**
 94      * @return mnemonic for instruction with sumbolic references resolved
 95      */
<span class="line-modified"> 96     public String toString(final ConstantPool cp) {</span>
 97         return toString(false);
 98     }
 99 

100     /**
<span class="line-modified">101      * Use with caution, since `BranchInstruction&#39;s have a `target&#39; reference</span>
<span class="line-modified">102      * which is not copied correctly (only basic types are). This also applies</span>
<span class="line-modified">103      * for `Select&#39; instructions with their multiple branch targets.</span>
104      *
105      * @see BranchInstruction
106      * @return (shallow) copy of an instruction
107      */
108     public Instruction copy() {
109         Instruction i = null;
110         // &quot;Constant&quot; instruction, no need to duplicate
111         if (InstructionConst.getInstruction(this.getOpcode()) != null) {
112             i = this;
113         } else {
114             try {
115                 i = (Instruction) clone();
116             } catch (final CloneNotSupportedException e) {
117                 System.err.println(e);
118             }
119         }
120         return i;
121     }
122 

123     /**
124      * Read needed data (e.g. index) from file.
125      *
126      * @param bytes byte sequence to read from
127      * @param wide &quot;wide&quot; instruction flag
<span class="line-modified">128      * @throws IOException may be thrown if the implementation needs to read</span>
<span class="line-removed">129      * data from the file</span>
130      */
<span class="line-modified">131     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {</span>
132     }
133 

134     /**
135      * Read an instruction from (byte code) input stream and return the
136      * appropiate object.
137      * &lt;p&gt;
138      * If the Instruction is defined in {@link InstructionConst}, then the
139      * singleton instance is returned.
<span class="line-removed">140      *</span>
141      * @param bytes input stream bytes
142      * @return instruction object being read
143      * @see InstructionConst#getInstruction(int)
144      */
145     // @since 6.0 no longer final
<span class="line-modified">146     public static Instruction readInstruction(final ByteSequence bytes) throws IOException {</span>
147         boolean wide = false;
148         short opcode = (short) bytes.readUnsignedByte();
149         Instruction obj = null;
150         if (opcode == Const.WIDE) { // Read next opcode after wide byte
151             wide = true;
152             opcode = (short) bytes.readUnsignedByte();
153         }
154         final Instruction instruction = InstructionConst.getInstruction(opcode);
155         if (instruction != null) {
156             return instruction; // Used predefined immutable object, if available
157         }
158 
159         switch (opcode) {
160             case Const.BIPUSH:
161                 obj = new BIPUSH();
162                 break;
163             case Const.SIPUSH:
164                 obj = new SIPUSH();
165                 break;
166             case Const.LDC:
</pre>
<hr />
<pre>
446                 obj = new IMPDEP1();
447                 break;
448             case Const.IMPDEP2:
449                 obj = new IMPDEP2();
450                 break;
451             default:
452                 throw new ClassGenException(&quot;Illegal opcode detected: &quot; + opcode);
453 
454         }
455 
456         if (wide
457                 &amp;&amp; !((obj instanceof LocalVariableInstruction) || (obj instanceof IINC) || (obj instanceof RET))) {
458             throw new ClassGenException(&quot;Illegal opcode after wide: &quot; + opcode);
459         }
460         obj.setOpcode(opcode);
461         obj.initFromFile(bytes, wide); // Do further initializations, if any
462         return obj;
463     }
464 
465     /**
<span class="line-modified">466      * This method also gives right results for instructions whose effect on the</span>
<span class="line-modified">467      * stack depends on the constant pool entry they reference.</span>
<span class="line-modified">468      *</span>
<span class="line-modified">469      * @return Number of words consumed from stack by this instruction, or</span>
<span class="line-modified">470      * Constants.UNPREDICTABLE, if this can not be computed statically</span>
471      */
<span class="line-modified">472     public int consumeStack(final ConstantPoolGen cpg) {</span>
473         return Const.getConsumeStack(opcode);
474     }
475 

476     /**
<span class="line-modified">477      * This method also gives right results for instructions whose effect on the</span>
<span class="line-modified">478      * stack depends on the constant pool entry they reference.</span>
<span class="line-modified">479      *</span>
<span class="line-modified">480      * @return Number of words produced onto stack by this instruction, or</span>
<span class="line-modified">481      * Constants.UNPREDICTABLE, if this can not be computed statically</span>
482      */
<span class="line-modified">483     public int produceStack(final ConstantPoolGen cpg) {</span>
484         return Const.getProduceStack(opcode);
485     }
486 

487     /**
488      * @return this instructions opcode
489      */
490     public short getOpcode() {
491         return opcode;
492     }
493 

494     /**
495      * @return length (in bytes) of instruction
496      */
497     public int getLength() {
498         return length;
499     }
500 

501     /**
502      * Needed in readInstruction and subclasses in this package
503      */
<span class="line-modified">504     final void setOpcode(final short opcode) {</span>
505         this.opcode = opcode;
506     }
507 

508     /**
509      * Needed in readInstruction and subclasses in this package
<span class="line-removed">510      *</span>
511      * @since 6.0
512      */
<span class="line-modified">513     final void setLength(final int length) {</span>
514         this.length = (short) length; // TODO check range?
515     }
516 
<span class="line-modified">517     /**</span>
<span class="line-modified">518      * Some instructions may be reused, so don&#39;t do anything by default.</span>
519      */
520     void dispose() {
521     }
522 

523     /**
<span class="line-modified">524      * Call corresponding visitor method(s). The order is: Call visitor methods</span>
<span class="line-modified">525      * of implemented interfaces first, then call methods according to the class</span>
<span class="line-modified">526      * hierarchy in descending order, i.e., the most specific visitXXX() call</span>
<span class="line-modified">527      * comes last.</span>
528      *
529      * @param v Visitor object
530      */
<span class="line-modified">531     public abstract void accept(Visitor v);</span>
532 
<span class="line-modified">533     /**</span>
<span class="line-modified">534      * Get Comparator object used in the equals() method to determine equality</span>
<span class="line-modified">535      * of instructions.</span>
536      *
537      * @return currently used comparator for equals()
<span class="line-modified">538      * @deprecated (6.0) use the built in comparator, or wrap this class in</span>
<span class="line-removed">539      * another object that implements these methods</span>
540      */
541     @Deprecated
542     public static InstructionComparator getComparator() {
543         return cmp;
544     }
545 
<span class="line-modified">546     /**</span>
<span class="line-modified">547      * Set comparator to be used for equals().</span>
<span class="line-modified">548      *</span>
<span class="line-removed">549      * @deprecated (6.0) use the built in comparator, or wrap this class in</span>
<span class="line-removed">550      * another object that implements these methods</span>
551      */
552     @Deprecated
<span class="line-modified">553     public static void setComparator(final InstructionComparator c) {</span>
554         cmp = c;
555     }
556 
<span class="line-modified">557     /**</span>
<span class="line-modified">558      * Check for equality, delegated to comparator</span>
<span class="line-removed">559      *</span>
560      * @return true if that is an Instruction and has the same opcode
561      */
562     @Override
<span class="line-modified">563     public boolean equals(final Object that) {</span>
564         return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;
565     }
566 
<span class="line-modified">567     /**</span>
<span class="line-removed">568      * calculate the hashCode of this object</span>
<span class="line-removed">569      *</span>
570      * @return the hashCode
571      * @since 6.0
572      */
573     @Override
574     public int hashCode() {
575         return opcode;
576     }
577 
578     /**
579      * Check if the value can fit in a byte (signed)
<span class="line-removed">580      *</span>
581      * @param value the value to check
582      * @return true if the value is in range
583      * @since 6.0
584      */
585     public static boolean isValidByte(final int value) {
586         return value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE;
587     }
588 
589     /**
590      * Check if the value can fit in a short (signed)
<span class="line-removed">591      *</span>
592      * @param value the value to check
593      * @return true if the value is in range
594      * @since 6.0
595      */
596     public static boolean isValidShort(final int value) {
597         return value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE;
598     }
599 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 27 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 28 
 29 /**
 30  * Abstract super class for all Java byte codes.
 31  *
<span class="line-modified"> 32  * @LastModified: Jan 2020</span>
 33  */
 34 public abstract class Instruction implements Cloneable {
 35 
 36     private short length = 1; // Length of instruction in bytes
 37     private short opcode = -1; // Opcode number
 38 
 39     private static InstructionComparator cmp = InstructionComparator.DEFAULT;
 40 
<span class="line-added"> 41 </span>
 42     /**
<span class="line-modified"> 43      * Empty constructor needed for Instruction.readInstruction.</span>
<span class="line-modified"> 44      * Not to be used otherwise.</span>
 45      */
 46     Instruction() {
 47     }
 48 
<span class="line-added"> 49 </span>
 50     public Instruction(final short opcode, final short length) {
 51         this.length = length;
 52         this.opcode = opcode;
 53     }
 54 
<span class="line-added"> 55 </span>
 56     /**
 57      * Dump instruction as byte code to stream out.

 58      * @param out Output stream
 59      */
<span class="line-modified"> 60     public void dump( final DataOutputStream out ) throws IOException {</span>
 61         out.writeByte(opcode); // Common for all instructions
 62     }
 63 
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65     /** @return name of instruction, i.e., opcode name</span>
 66      */
 67     public String getName() {
 68         return Const.getOpcodeName(opcode);
 69     }
 70 
<span class="line-added"> 71 </span>
 72     /**
 73      * Long output format:
 74      *
<span class="line-modified"> 75      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot;</span>
<span class="line-modified"> 76      * &quot;(&quot;&amp;lt;length of instruction&amp;gt;&quot;)&quot;</span>
 77      *
 78      * @param verbose long/short format switch
 79      * @return mnemonic for instruction
 80      */
<span class="line-modified"> 81     public String toString( final boolean verbose ) {</span>
 82         if (verbose) {
 83             return getName() + &quot;[&quot; + opcode + &quot;](&quot; + length + &quot;)&quot;;
 84         }
 85         return getName();
 86     }
 87 
<span class="line-added"> 88 </span>
 89     /**
 90      * @return mnemonic for instruction in verbose format
 91      */
 92     @Override
 93     public String toString() {
 94         return toString(true);
 95     }
 96 
<span class="line-added"> 97 </span>
 98     /**
 99      * @return mnemonic for instruction with sumbolic references resolved
100      */
<span class="line-modified">101     public String toString( final ConstantPool cp ) {</span>
102         return toString(false);
103     }
104 
<span class="line-added">105 </span>
106     /**
<span class="line-modified">107      * Use with caution, since `BranchInstruction&#39;s have a `target&#39; reference which</span>
<span class="line-modified">108      * is not copied correctly (only basic types are). This also applies for</span>
<span class="line-modified">109      * `Select&#39; instructions with their multiple branch targets.</span>
110      *
111      * @see BranchInstruction
112      * @return (shallow) copy of an instruction
113      */
114     public Instruction copy() {
115         Instruction i = null;
116         // &quot;Constant&quot; instruction, no need to duplicate
117         if (InstructionConst.getInstruction(this.getOpcode()) != null) {
118             i = this;
119         } else {
120             try {
121                 i = (Instruction) clone();
122             } catch (final CloneNotSupportedException e) {
123                 System.err.println(e);
124             }
125         }
126         return i;
127     }
128 
<span class="line-added">129 </span>
130     /**
131      * Read needed data (e.g. index) from file.
132      *
133      * @param bytes byte sequence to read from
134      * @param wide &quot;wide&quot; instruction flag
<span class="line-modified">135      * @throws IOException may be thrown if the implementation needs to read data from the file</span>

136      */
<span class="line-modified">137     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
138     }
139 
<span class="line-added">140 </span>
141     /**
142      * Read an instruction from (byte code) input stream and return the
143      * appropiate object.
144      * &lt;p&gt;
145      * If the Instruction is defined in {@link InstructionConst}, then the
146      * singleton instance is returned.

147      * @param bytes input stream bytes
148      * @return instruction object being read
149      * @see InstructionConst#getInstruction(int)
150      */
151     // @since 6.0 no longer final
<span class="line-modified">152     public static Instruction readInstruction( final ByteSequence bytes ) throws IOException {</span>
153         boolean wide = false;
154         short opcode = (short) bytes.readUnsignedByte();
155         Instruction obj = null;
156         if (opcode == Const.WIDE) { // Read next opcode after wide byte
157             wide = true;
158             opcode = (short) bytes.readUnsignedByte();
159         }
160         final Instruction instruction = InstructionConst.getInstruction(opcode);
161         if (instruction != null) {
162             return instruction; // Used predefined immutable object, if available
163         }
164 
165         switch (opcode) {
166             case Const.BIPUSH:
167                 obj = new BIPUSH();
168                 break;
169             case Const.SIPUSH:
170                 obj = new SIPUSH();
171                 break;
172             case Const.LDC:
</pre>
<hr />
<pre>
452                 obj = new IMPDEP1();
453                 break;
454             case Const.IMPDEP2:
455                 obj = new IMPDEP2();
456                 break;
457             default:
458                 throw new ClassGenException(&quot;Illegal opcode detected: &quot; + opcode);
459 
460         }
461 
462         if (wide
463                 &amp;&amp; !((obj instanceof LocalVariableInstruction) || (obj instanceof IINC) || (obj instanceof RET))) {
464             throw new ClassGenException(&quot;Illegal opcode after wide: &quot; + opcode);
465         }
466         obj.setOpcode(opcode);
467         obj.initFromFile(bytes, wide); // Do further initializations, if any
468         return obj;
469     }
470 
471     /**
<span class="line-modified">472      * This method also gives right results for instructions whose</span>
<span class="line-modified">473      * effect on the stack depends on the constant pool entry they</span>
<span class="line-modified">474      * reference.</span>
<span class="line-modified">475      *  @return Number of words consumed from stack by this instruction,</span>
<span class="line-modified">476      * or Constants.UNPREDICTABLE, if this can not be computed statically</span>
477      */
<span class="line-modified">478     public int consumeStack( final ConstantPoolGen cpg ) {</span>
479         return Const.getConsumeStack(opcode);
480     }
481 
<span class="line-added">482 </span>
483     /**
<span class="line-modified">484      * This method also gives right results for instructions whose</span>
<span class="line-modified">485      * effect on the stack depends on the constant pool entry they</span>
<span class="line-modified">486      * reference.</span>
<span class="line-modified">487      * @return Number of words produced onto stack by this instruction,</span>
<span class="line-modified">488      * or Constants.UNPREDICTABLE, if this can not be computed statically</span>
489      */
<span class="line-modified">490     public int produceStack( final ConstantPoolGen cpg ) {</span>
491         return Const.getProduceStack(opcode);
492     }
493 
<span class="line-added">494 </span>
495     /**
496      * @return this instructions opcode
497      */
498     public short getOpcode() {
499         return opcode;
500     }
501 
<span class="line-added">502 </span>
503     /**
504      * @return length (in bytes) of instruction
505      */
506     public int getLength() {
507         return length;
508     }
509 
<span class="line-added">510 </span>
511     /**
512      * Needed in readInstruction and subclasses in this package
513      */
<span class="line-modified">514     final void setOpcode( final short opcode ) {</span>
515         this.opcode = opcode;
516     }
517 
<span class="line-added">518 </span>
519     /**
520      * Needed in readInstruction and subclasses in this package

521      * @since 6.0
522      */
<span class="line-modified">523     final void setLength( final int length ) {</span>
524         this.length = (short) length; // TODO check range?
525     }
526 
<span class="line-modified">527 </span>
<span class="line-modified">528     /** Some instructions may be reused, so don&#39;t do anything by default.</span>
529      */
530     void dispose() {
531     }
532 
<span class="line-added">533 </span>
534     /**
<span class="line-modified">535      * Call corresponding visitor method(s). The order is:</span>
<span class="line-modified">536      * Call visitor methods of implemented interfaces first, then</span>
<span class="line-modified">537      * call methods according to the class hierarchy in descending order,</span>
<span class="line-modified">538      * i.e., the most specific visitXXX() call comes last.</span>
539      *
540      * @param v Visitor object
541      */
<span class="line-modified">542     public abstract void accept( Visitor v );</span>
543 
<span class="line-modified">544 </span>
<span class="line-modified">545     /** Get Comparator object used in the equals() method to determine</span>
<span class="line-modified">546      * equality of instructions.</span>
547      *
548      * @return currently used comparator for equals()
<span class="line-modified">549      * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods</span>

550      */
551     @Deprecated
552     public static InstructionComparator getComparator() {
553         return cmp;
554     }
555 
<span class="line-modified">556 </span>
<span class="line-modified">557     /** Set comparator to be used for equals().</span>
<span class="line-modified">558       * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods</span>


559      */
560     @Deprecated
<span class="line-modified">561     public static void setComparator( final InstructionComparator c ) {</span>
562         cmp = c;
563     }
564 
<span class="line-modified">565 </span>
<span class="line-modified">566     /** Check for equality, delegated to comparator</span>

567      * @return true if that is an Instruction and has the same opcode
568      */
569     @Override
<span class="line-modified">570     public boolean equals( final Object that ) {</span>
571         return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;
572     }
573 
<span class="line-modified">574     /** calculate the hashCode of this object</span>


575      * @return the hashCode
576      * @since 6.0
577      */
578     @Override
579     public int hashCode() {
580         return opcode;
581     }
582 
583     /**
584      * Check if the value can fit in a byte (signed)

585      * @param value the value to check
586      * @return true if the value is in range
587      * @since 6.0
588      */
589     public static boolean isValidByte(final int value) {
590         return value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE;
591     }
592 
593     /**
594      * Check if the value can fit in a short (signed)

595      * @param value the value to check
596      * @return true if the value is in range
597      * @since 6.0
598      */
599     public static boolean isValidShort(final int value) {
600         return value &gt;= Short.MIN_VALUE &amp;&amp; value &lt;= Short.MAX_VALUE;
601     }
602 }
</pre>
</td>
</tr>
</table>
<center><a href="IndexedInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionComparator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
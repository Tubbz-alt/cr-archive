diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/LineNumberTable.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/LineNumberTable.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/LineNumberTable.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/LineNumberTable.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -24,17 +24,17 @@
 import java.io.DataOutputStream;
 import java.io.IOException;
 import jdk.xml.internal.SecuritySupport;
 
 /**
- * This class represents a table of line numbers for debugging purposes. This
- * attribute is used by the <em>Code</em> attribute. It contains pairs of PCs
- * and line numbers.
+ * This class represents a table of line numbers for debugging
+ * purposes. This attribute is used by the <em>Code</em> attribute. It
+ * contains pairs of PCs and line numbers.
  *
- * @version $Id: LineNumberTable.java 1749603 2016-06-21 20:50:19Z ggregory $
- * @see Code
+ * @see     Code
  * @see LineNumber
+ * @LastModified: Jan 2020
  */
 public final class LineNumberTable extends Attribute {
 
     private static final int MAX_LINE_LENGTH = 72;
     private LineNumber[] line_number_table; // Table of line/numbers pairs
@@ -61,16 +61,15 @@
         this.line_number_table = line_number_table;
     }
 
     /**
      * Construct object from input stream.
-     *
      * @param name_index Index of name
      * @param length Content length in bytes
      * @param input Input stream
      * @param constant_pool Array of constants
-     * @throws IOEXception if an I/O Exception occurs in readUnsignedShort
+     * @throws IOException if an I/O Exception occurs in readUnsignedShort
      */
     LineNumberTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)
             throws IOException {
         this(name_index, length, (LineNumber[]) null, constant_pool);
         final int line_number_table_length = input.readUnsignedShort();
@@ -86,48 +85,48 @@
      * fields, attributes, etc. spawns a tree of objects.
      *
      * @param v Visitor object
      */
     @Override
-    public void accept(final Visitor v) {
+    public void accept( final Visitor v ) {
         v.visitLineNumberTable(this);
     }
 
     /**
      * Dump line number table attribute to file stream in binary format.
      *
      * @param file Output file stream
-     * @throws IOEXception if an I/O Exception occurs in writeShort
+     * @throws IOException if an I/O Exception occurs in writeShort
      */
     @Override
-    public final void dump(final DataOutputStream file) throws IOException {
+    public void dump( final DataOutputStream file ) throws IOException {
         super.dump(file);
         file.writeShort(line_number_table.length);
         for (final LineNumber lineNumber : line_number_table) {
             lineNumber.dump(file);
         }
     }
 
     /**
      * @return Array of (pc offset, line number) pairs.
      */
-    public final LineNumber[] getLineNumberTable() {
+    public LineNumber[] getLineNumberTable() {
         return line_number_table;
     }
 
     /**
      * @param line_number_table the line number entries for this table
      */
-    public final void setLineNumberTable(final LineNumber[] line_number_table) {
+    public void setLineNumberTable( final LineNumber[] line_number_table ) {
         this.line_number_table = line_number_table;
     }
 
     /**
      * @return String representation.
      */
     @Override
-    public final String toString() {
+    public String toString() {
         final StringBuilder buf = new StringBuilder();
         final StringBuilder line = new StringBuilder();
 
         for (int i = 0; i < line_number_table.length; i++) {
             line.append(line_number_table[i].toString());
@@ -148,22 +147,22 @@
      * Map byte code positions to source code lines.
      *
      * @param pos byte code offset
      * @return corresponding line in source code
      */
-    public int getSourceLine(final int pos) {
+    public int getSourceLine( final int pos ) {
         int l = 0;
         int r = line_number_table.length - 1;
         if (r < 0) {
             return -1;
         }
         int min_index = -1;
         int min = -1;
         /* Do a binary search since the array is ordered.
          */
         do {
-            final int i = (l + r) / 2;
+            final int i = (l + r) >>> 1;
             final int j = line_number_table[i].getStartPC();
             if (j == pos) {
                 return line_number_table[i].getLineNumber();
             } else if (pos < j) {
                 r = i - 1;
@@ -190,11 +189,11 @@
 
     /**
      * @return deep copy of this attribute
      */
     @Override
-    public Attribute copy(final ConstantPool _constant_pool) {
+    public Attribute copy( final ConstantPool _constant_pool ) {
         // TODO could use the lower level constructor and thereby allow
         // line_number_table to be made final
         final LineNumberTable c = (LineNumberTable) clone();
         c.line_number_table = new LineNumber[line_number_table.length];
         for (int i = 0; i < line_number_table.length; i++) {
@@ -202,9 +201,9 @@
         }
         c.setConstantPool(_constant_pool);
         return c;
     }
 
-    public final int getTableLength() {
+    public int getTableLength() {
         return line_number_table == null ? 0 : line_number_table.length;
     }
 }

diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -24,32 +24,32 @@
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
+import java.util.Objects;
+import java.util.StringTokenizer;
 import java.util.List;
 import java.util.Set;
-import java.util.StringTokenizer;
 import java.util.TreeSet;
 
 import com.sun.org.apache.bcel.internal.Const;
 import com.sun.org.apache.bcel.internal.generic.Type;
 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 import com.sun.org.apache.bcel.internal.util.ClassQueue;
 import com.sun.org.apache.bcel.internal.util.SyntheticRepository;
-import jdk.xml.internal.SecuritySupport;
 
 /**
- * Represents a Java class, i.e., the data structures, constant pool, fields,
- * methods and commands contained in a Java .class file. See <a
- * href="http://docs.oracle.com/javase/specs/">JVM specification</a> for
- * details. The intent of this class is to represent a parsed or otherwise
- * existing class file. Those interested in programatically generating classes
+ * Represents a Java class, i.e., the data structures, constant pool,
+ * fields, methods and commands contained in a Java .class file.
+ * See <a href="http://docs.oracle.com/javase/specs/">JVM specification</a> for details.
+ * The intent of this class is to represent a parsed or otherwise existing
+ * class file.  Those interested in programatically generating classes
  * should see the <a href="../generic/ClassGen.html">ClassGen</a> class.
- *
- * @version $Id: JavaClass.java 1750227 2016-06-25 21:47:10Z ggregory $
+
  * @see com.sun.org.apache.bcel.internal.generic.ClassGen
+ * @LastModified: Jan 2020
  */
 public class JavaClass extends AccessFlags implements Cloneable, Node, Comparable<JavaClass> {
 
     private String file_name;
     private String package_name;
@@ -72,33 +72,37 @@
     private boolean isNested = false;
     private boolean computedNestedTypeStatus = false;
     public static final byte HEAP = 1;
     public static final byte FILE = 2;
     public static final byte ZIP = 3;
+    private static final boolean debug = false;
 
     private static BCELComparator bcelComparator = new BCELComparator() {
 
         @Override
-        public boolean equals(final Object o1, final Object o2) {
+        public boolean equals( final Object o1, final Object o2 ) {
             final JavaClass THIS = (JavaClass) o1;
             final JavaClass THAT = (JavaClass) o2;
-            return THIS.getClassName().equals(THAT.getClassName());
+            return Objects.equals(THIS.getClassName(), THAT.getClassName());
         }
 
+
         @Override
-        public int hashCode(final Object o) {
+        public int hashCode( final Object o ) {
             final JavaClass THIS = (JavaClass) o;
             return THIS.getClassName().hashCode();
         }
     };
     /**
-     * In cases where we go ahead and create something, use the default
-     * SyntheticRepository, because we don't know any better.
+     * In cases where we go ahead and create something,
+     * use the default SyntheticRepository, because we
+     * don't know any better.
      */
     private transient com.sun.org.apache.bcel.internal.util.Repository repository
             = SyntheticRepository.getInstance();
 
+
     /**
      * Constructor gets all contents as arguments.
      *
      * @param class_name_index Index into constant pool referencing a
      * ConstantClass that represents this class.
@@ -175,10 +179,11 @@
             final String str = constant_pool.getConstantString(interfaces[i], Const.CONSTANT_Class);
             interface_names[i] = Utility.compactClassName(str, false);
         }
     }
 
+
     /**
      * Constructor gets all contents as arguments.
      *
      * @param class_name_index Class name
      * @param superclass_name_index Superclass name
@@ -198,22 +203,33 @@
             final Method[] methods, final Attribute[] attributes) {
         this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
                 constant_pool, interfaces, fields, methods, attributes, HEAP);
     }
 
+
     /**
-     * Called by objects that are traversing the nodes of the tree implicitly
+     * Called by objects that are traversing the nodes of the tree implicitely
      * defined by the contents of a Java class. I.e., the hierarchy of methods,
      * fields, attributes, etc. spawns a tree of objects.
      *
      * @param v Visitor object
      */
     @Override
-    public void accept(final Visitor v) {
+    public void accept( final Visitor v ) {
         v.visitJavaClass(this);
     }
 
+
+    /* Print debug information depending on `JavaClass.debug'
+     */
+    static void Debug( final String str ) {
+        if (debug) {
+            System.out.println(str);
+        }
+    }
+
+
     /**
      * Dump class to a file.
      *
      * @param file Output file
      * @throws IOException
@@ -221,30 +237,32 @@
     public void dump(final File file) throws IOException {
         final String parent = file.getParent();
         if (parent != null) {
             final File dir = new File(parent);
             if (!dir.mkdirs()) { // either was not created or already existed
-                if (!SecuritySupport.isDirectory(dir)) {
+                if (!dir.isDirectory()) {
                     throw new IOException("Could not create the directory " + dir);
                 }
             }
         }
         try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {
             dump(dos);
         }
     }
 
+
     /**
      * Dump class to a file named file_name.
      *
      * @param _file_name Output file name
      * @throws IOException
      */
-    public void dump(final String _file_name) throws IOException {
+    public void dump( final String _file_name ) throws IOException {
         dump(new File(_file_name));
     }
 
+
     /**
      * @return class in binary format
      */
     public byte[] getBytes() {
         final ByteArrayOutputStream s = new ByteArrayOutputStream();
@@ -261,27 +279,29 @@
             }
         }
         return s.toByteArray();
     }
 
+
     /**
      * Dump Java class to output stream in binary format.
      *
      * @param file Output stream
      * @throws IOException
      */
-    public void dump(final OutputStream file) throws IOException {
+    public void dump( final OutputStream file ) throws IOException {
         dump(new DataOutputStream(file));
     }
 
+
     /**
      * Dump Java class to output stream in binary format.
      *
      * @param file Output stream
      * @throws IOException
      */
-    private void dump(final DataOutputStream file) throws IOException {
+    public void dump( final DataOutputStream file ) throws IOException {
         file.writeInt(Const.JVM_CLASSFILE_MAGIC);
         file.writeShort(minor);
         file.writeShort(major);
         constant_pool.dump(file);
         file.writeShort(super.getAccessFlags());
@@ -308,10 +328,11 @@
             file.writeShort(0);
         }
         file.flush();
     }
 
+
     /**
      * @return Attributes of the class.
      */
     public Attribute[] getAttributes() {
         return attributes;
@@ -334,230 +355,258 @@
      */
     public String getClassName() {
         return class_name;
     }
 
+
     /**
      * @return Package name.
      */
     public String getPackageName() {
         return package_name;
     }
 
+
     /**
      * @return Class name index.
      */
     public int getClassNameIndex() {
         return class_name_index;
     }
 
+
     /**
      * @return Constant pool.
      */
     public ConstantPool getConstantPool() {
         return constant_pool;
     }
 
+
     /**
-     * @return Fields, i.e., variables of the class. Like the JVM spec mandates
-     * for the classfile format, these fields are those specific to this class,
-     * and not those of the superclass or superinterfaces.
+     * @return Fields, i.e., variables of the class. Like the JVM spec
+     * mandates for the classfile format, these fields are those specific to
+     * this class, and not those of the superclass or superinterfaces.
      */
     public Field[] getFields() {
         return fields;
     }
 
+
     /**
      * @return File name of class, aka SourceFile attribute value
      */
     public String getFileName() {
         return file_name;
     }
 
+
     /**
      * @return Names of implemented interfaces.
      */
     public String[] getInterfaceNames() {
         return interface_names;
     }
 
+
     /**
      * @return Indices in constant pool of implemented interfaces.
      */
     public int[] getInterfaceIndices() {
         return interfaces;
     }
 
+
     /**
      * @return Major number of class file version.
      */
     public int getMajor() {
         return major;
     }
 
+
     /**
      * @return Methods of the class.
      */
     public Method[] getMethods() {
         return methods;
     }
 
+
     /**
-     * @return A {@link Method} corresponding to java.lang.reflect.Method if any
+     * @return A {@link Method} corresponding to
+     * java.lang.reflect.Method if any
      */
-    public Method getMethod(final java.lang.reflect.Method m) {
+    public Method getMethod( final java.lang.reflect.Method m ) {
         for (final Method method : methods) {
             if (m.getName().equals(method.getName()) && (m.getModifiers() == method.getModifiers())
                     && Type.getSignature(m).equals(method.getSignature())) {
                 return method;
             }
         }
         return null;
     }
 
+
     /**
      * @return Minor number of class file version.
      */
     public int getMinor() {
         return minor;
     }
 
+
     /**
      * @return sbsolute path to file where this class was read from
      */
     public String getSourceFileName() {
         return source_file_name;
     }
 
+
     /**
-     * returns the super class name of this class. In the case that this class
-     * is java.lang.Object, it will return itself (java.lang.Object). This is
-     * probably incorrect but isn't fixed at this time to not break existing
-     * clients.
+     * returns the super class name of this class. In the case that this class is
+     * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect
+     * but isn't fixed at this time to not break existing clients.
      *
      * @return Superclass name.
      */
     public String getSuperclassName() {
         return superclass_name;
     }
 
+
     /**
      * @return Class name index.
      */
     public int getSuperclassNameIndex() {
         return superclass_name_index;
     }
 
     /**
      * @param attributes .
      */
-    public void setAttributes(final Attribute[] attributes) {
+    public void setAttributes( final Attribute[] attributes ) {
         this.attributes = attributes;
     }
 
+
     /**
      * @param class_name .
      */
-    public void setClassName(final String class_name) {
+    public void setClassName( final String class_name ) {
         this.class_name = class_name;
     }
 
+
     /**
      * @param class_name_index .
      */
-    public void setClassNameIndex(final int class_name_index) {
+    public void setClassNameIndex( final int class_name_index ) {
         this.class_name_index = class_name_index;
     }
 
+
     /**
      * @param constant_pool .
      */
-    public void setConstantPool(final ConstantPool constant_pool) {
+    public void setConstantPool( final ConstantPool constant_pool ) {
         this.constant_pool = constant_pool;
     }
 
+
     /**
      * @param fields .
      */
-    public void setFields(final Field[] fields) {
+    public void setFields( final Field[] fields ) {
         this.fields = fields;
     }
 
+
     /**
      * Set File name of class, aka SourceFile attribute value
      */
-    public void setFileName(final String file_name) {
+    public void setFileName( final String file_name ) {
         this.file_name = file_name;
     }
 
+
     /**
      * @param interface_names .
      */
-    public void setInterfaceNames(final String[] interface_names) {
+    public void setInterfaceNames( final String[] interface_names ) {
         this.interface_names = interface_names;
     }
 
+
     /**
      * @param interfaces .
      */
-    public void setInterfaces(final int[] interfaces) {
+    public void setInterfaces( final int[] interfaces ) {
         this.interfaces = interfaces;
     }
 
+
     /**
      * @param major .
      */
-    public void setMajor(final int major) {
+    public void setMajor( final int major ) {
         this.major = major;
     }
 
+
     /**
      * @param methods .
      */
-    public void setMethods(final Method[] methods) {
+    public void setMethods( final Method[] methods ) {
         this.methods = methods;
     }
 
+
     /**
      * @param minor .
      */
-    public void setMinor(final int minor) {
+    public void setMinor( final int minor ) {
         this.minor = minor;
     }
 
+
     /**
      * Set absolute path to file this class was read from.
      */
-    public void setSourceFileName(final String source_file_name) {
+    public void setSourceFileName( final String source_file_name ) {
         this.source_file_name = source_file_name;
     }
 
+
     /**
      * @param superclass_name .
      */
-    public void setSuperclassName(final String superclass_name) {
+    public void setSuperclassName( final String superclass_name ) {
         this.superclass_name = superclass_name;
     }
 
+
     /**
      * @param superclass_name_index .
      */
-    public void setSuperclassNameIndex(final int superclass_name_index) {
+    public void setSuperclassNameIndex( final int superclass_name_index ) {
         this.superclass_name_index = superclass_name_index;
     }
 
+
     /**
      * @return String representing class contents.
      */
     @Override
     public String toString() {
         String access = Utility.accessToString(super.getAccessFlags(), true);
         access = access.isEmpty() ? "" : (access + " ");
         final StringBuilder buf = new StringBuilder(128);
         buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(" ").append(
                 class_name).append(" extends ").append(
-                        Utility.compactClassName(superclass_name, false)).append('\n');
+                Utility.compactClassName(superclass_name, false)).append('\n');
         final int size = interfaces.length;
         if (size > 0) {
             buf.append("implements\t\t");
             for (int i = 0; i < size; i++) {
                 buf.append(interface_names[i]);
@@ -565,11 +614,11 @@
                     buf.append(", ");
                 }
             }
             buf.append('\n');
         }
-        buf.append("filename\t\t").append(file_name).append('\n');
+        buf.append("file name\t\t").append(file_name).append('\n');
         buf.append("compiled from\t\t").append(source_file_name).append('\n');
         buf.append("compiler version\t").append(major).append(".").append(minor).append('\n');
         buf.append("access flags\t\t").append(super.getAccessFlags()).append('\n');
         buf.append("constant pool\t\t").append(constant_pool.getLength()).append(" entries\n");
         buf.append("ACC_SUPER flag\t\t").append(isSuper()).append("\n");
@@ -578,11 +627,11 @@
             for (final Attribute attribute : attributes) {
                 buf.append(indent(attribute));
             }
         }
         final AnnotationEntry[] annotations = getAnnotationEntries();
-        if (annotations != null && annotations.length > 0) {
+        if (annotations!=null && annotations.length>0) {
             buf.append("\nAnnotation(s):\n");
             for (final AnnotationEntry annotation : annotations) {
                 buf.append(indent(annotation));
             }
         }
@@ -599,19 +648,21 @@
             }
         }
         return buf.toString();
     }
 
-    private static String indent(final Object obj) {
+
+    private static String indent( final Object obj ) {
         final StringTokenizer tok = new StringTokenizer(obj.toString(), "\n");
         final StringBuilder buf = new StringBuilder();
         while (tok.hasMoreTokens()) {
             buf.append("\t").append(tok.nextToken()).append("\n");
         }
         return buf.toString();
     }
 
+
     /**
      * @return deep copy of this class
      */
     public JavaClass copy() {
         JavaClass c = null;
@@ -636,14 +687,16 @@
             // TODO should this throw?
         }
         return c;
     }
 
+
     public final boolean isSuper() {
         return (super.getAccessFlags() & Const.ACC_SUPER) != 0;
     }
 
+
     public final boolean isClass() {
         return (super.getAccessFlags() & Const.ACC_INTERFACE) == 0;
     }
 
     /**
@@ -665,66 +718,66 @@
     private void computeNestedTypeStatus() {
         if (computedNestedTypeStatus) {
             return;
         }
         for (final Attribute attribute : this.attributes) {
-            if (attribute instanceof InnerClasses) {
-                final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();
-                for (final InnerClass innerClasse : innerClasses) {
-                    boolean innerClassAttributeRefersToMe = false;
-                    String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),
-                            Const.CONSTANT_Class);
-                    inner_class_name = Utility.compactClassName(inner_class_name);
-                    if (inner_class_name.equals(getClassName())) {
-                        innerClassAttributeRefersToMe = true;
-                    }
-                    if (innerClassAttributeRefersToMe) {
-                        this.isNested = true;
-                        if (innerClasse.getInnerNameIndex() == 0) {
-                            this.isAnonymous = true;
-                        }
-                    }
-                }
-            }
+              if (attribute instanceof InnerClasses) {
+                  final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();
+                  for (final InnerClass innerClasse : innerClasses) {
+                      boolean innerClassAttributeRefersToMe = false;
+                      String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),
+                                 Const.CONSTANT_Class);
+                      inner_class_name = Utility.compactClassName(inner_class_name, false);
+                      if (inner_class_name.equals(getClassName())) {
+                          innerClassAttributeRefersToMe = true;
+                      }
+                      if (innerClassAttributeRefersToMe) {
+                          this.isNested = true;
+                          if (innerClasse.getInnerNameIndex() == 0) {
+                              this.isAnonymous = true;
+                          }
+                      }
+                  }
+              }
         }
         this.computedNestedTypeStatus = true;
     }
 
-    /**
-     * @return returns either HEAP (generated), FILE, or ZIP
+
+    /** @return returns either HEAP (generated), FILE, or ZIP
      */
     public final byte getSource() {
         return source;
     }
 
+
+    /********************* New repository functionality *********************/
     /**
-     * ******************* New repository functionality ********************
-     */
-    /**
-     * Gets the ClassRepository which holds its definition. By default this is
-     * the same as SyntheticRepository.getInstance();
+     * Gets the ClassRepository which holds its definition. By default
+     * this is the same as SyntheticRepository.getInstance();
      */
     public com.sun.org.apache.bcel.internal.util.Repository getRepository() {
         return repository;
     }
 
+
     /**
-     * Sets the ClassRepository which loaded the JavaClass. Should be called
-     * immediately after parsing is done.
+     * Sets the ClassRepository which loaded the JavaClass.
+     * Should be called immediately after parsing is done.
      */
-    public void setRepository(final com.sun.org.apache.bcel.internal.util.Repository repository) {
+    public void setRepository( final com.sun.org.apache.bcel.internal.util.Repository repository ) { // TODO make protected?
         this.repository = repository;
     }
 
-    /**
-     * Equivalent to runtime "instanceof" operator.
+
+    /** Equivalent to runtime "instanceof" operator.
      *
      * @return true if this JavaClass is derived from the super class
-     * @throws ClassNotFoundException if superclasses or superinterfaces of this
-     * object can't be found
+     * @throws ClassNotFoundException if superclasses or superinterfaces
+     *   of this object can't be found
      */
-    public final boolean instanceOf(final JavaClass super_class) throws ClassNotFoundException {
+    public final boolean instanceOf( final JavaClass super_class ) throws ClassNotFoundException {
         if (this.equals(super_class)) {
             return true;
         }
         final JavaClass[] super_classes = getSuperClasses();
         for (final JavaClass super_classe : super_classes) {
@@ -736,16 +789,17 @@
             return implementationOf(super_class);
         }
         return false;
     }
 
+
     /**
      * @return true, if this class is an implementation of interface inter
-     * @throws ClassNotFoundException if superclasses or superinterfaces of this
-     * class can't be found
+     * @throws ClassNotFoundException if superclasses or superinterfaces
+     *   of this class can't be found
      */
-    public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {
+    public boolean implementationOf( final JavaClass inter ) throws ClassNotFoundException {
         if (!inter.isInterface()) {
             throw new IllegalArgumentException(inter.getClassName() + " is no interface");
         }
         if (this.equals(inter)) {
             return true;
@@ -757,22 +811,24 @@
             }
         }
         return false;
     }
 
+
     /**
-     * @return the superclass for this JavaClass object, or null if this is
-     * java.lang.Object
+     * @return the superclass for this JavaClass object, or null if this
+     * is java.lang.Object
      * @throws ClassNotFoundException if the superclass can't be found
      */
     public JavaClass getSuperClass() throws ClassNotFoundException {
         if ("java.lang.Object".equals(getClassName())) {
             return null;
         }
         return repository.loadClass(getSuperclassName());
     }
 
+
     /**
      * @return list of super classes of this class in ascending order, i.e.,
      * java.lang.Object is always the last element
      * @throws ClassNotFoundException if any of the superclasses can't be found
      */
@@ -783,10 +839,11 @@
             allSuperClasses.add(clazz);
         }
         return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);
     }
 
+
     /**
      * Get interfaces directly implemented by this JavaClass.
      */
     public JavaClass[] getInterfaces() throws ClassNotFoundException {
         final String[] _interfaces = getInterfaceNames();
@@ -795,10 +852,11 @@
             classes[i] = repository.loadClass(_interfaces[i]);
         }
         return classes;
     }
 
+
     /**
      * Get all interfaces implemented by this JavaClass (transitively).
      */
     public JavaClass[] getAllInterfaces() throws ClassNotFoundException {
         final ClassQueue queue = new ClassQueue();
@@ -820,49 +878,54 @@
             }
         }
         return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
     }
 
+
     /**
      * @return Comparison strategy object
      */
     public static BCELComparator getComparator() {
         return bcelComparator;
     }
 
+
     /**
      * @param comparator Comparison strategy object
      */
-    public static void setComparator(final BCELComparator comparator) {
+    public static void setComparator( final BCELComparator comparator ) {
         bcelComparator = comparator;
     }
 
+
     /**
-     * Return value as defined by given BCELComparator strategy. By default two
-     * JavaClass objects are said to be equal when their class names are equal.
+     * Return value as defined by given BCELComparator strategy.
+     * By default two JavaClass objects are said to be equal when
+     * their class names are equal.
      *
      * @see java.lang.Object#equals(java.lang.Object)
      */
     @Override
-    public boolean equals(final Object obj) {
+    public boolean equals( final Object obj ) {
         return bcelComparator.equals(this, obj);
     }
 
+
     /**
-     * Return the natural ordering of two JavaClasses. This ordering is based on
-     * the class name
-     *
+     * Return the natural ordering of two JavaClasses.
+     * This ordering is based on the class name
      * @since 6.0
      */
     @Override
-    public int compareTo(final JavaClass obj) {
+    public int compareTo( final JavaClass obj ) {
         return getClassName().compareTo(obj.getClassName());
     }
 
+
     /**
-     * Return value as defined by given BCELComparator strategy. By default
-     * return the hashcode of the class name.
+     * Return value as defined by given BCELComparator strategy.
+     * By default return the hashcode of the class name.
      *
      * @see java.lang.Object#hashCode()
      */
     @Override
     public int hashCode() {

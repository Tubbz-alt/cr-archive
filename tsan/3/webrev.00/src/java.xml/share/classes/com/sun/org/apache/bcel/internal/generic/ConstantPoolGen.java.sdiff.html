<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompoundInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantPushInstruction.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.HashMap;
 23 import java.util.Map;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.Constant;
 27 import com.sun.org.apache.bcel.internal.classfile.ConstantCP;
 28 import com.sun.org.apache.bcel.internal.classfile.ConstantClass;
 29 import com.sun.org.apache.bcel.internal.classfile.ConstantDouble;
 30 import com.sun.org.apache.bcel.internal.classfile.ConstantFieldref;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantFloat;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantInteger;
 33 import com.sun.org.apache.bcel.internal.classfile.ConstantInterfaceMethodref;
 34 import com.sun.org.apache.bcel.internal.classfile.ConstantInvokeDynamic;
 35 import com.sun.org.apache.bcel.internal.classfile.ConstantLong;
 36 import com.sun.org.apache.bcel.internal.classfile.ConstantMethodref;
 37 import com.sun.org.apache.bcel.internal.classfile.ConstantNameAndType;
 38 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 39 import com.sun.org.apache.bcel.internal.classfile.ConstantString;
 40 import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
 41 
 42 /**
<span class="line-modified"> 43  * This class is used to build up a constant pool. The user adds constants via</span>
<span class="line-modified"> 44  * `addXXX&#39; methods, `addString&#39;, `addClass&#39;, etc.. These methods return an</span>
<span class="line-modified"> 45  * index into the constant pool. Finally, `getFinalConstantPool()&#39; returns the</span>
<span class="line-modified"> 46  * constant pool built up. Intermediate versions of the constant pool can be</span>

 47  * obtained with `getConstantPool()&#39;. A constant pool has capacity for
<span class="line-modified"> 48  * Constants.MAX_SHORT entries. Note that the first (0) is used by the JVM and</span>
<span class="line-modified"> 49  * that Double and Long constants need two slots.</span>
 50  *
<span class="line-removed"> 51  * @version $Id: ConstantPoolGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 52  * @see Constant

 53  */
 54 public class ConstantPoolGen {
 55 
 56     private static final int DEFAULT_BUFFER_SIZE = 256;
 57     private int size;
 58     private Constant[] constants;
 59     private int index = 1; // First entry (0) used by JVM
 60 
 61     private static final String METHODREF_DELIM = &quot;:&quot;;
 62     private static final String IMETHODREF_DELIM = &quot;#&quot;;
 63     private static final String FIELDREF_DELIM = &quot;&amp;&quot;;
 64     private static final String NAT_DELIM = &quot;%&quot;; // Name and Type
 65 
 66     private static class Index {
 67 
 68         final int index;
 69 

 70         Index(final int i) {
 71             index = i;
 72         }
 73     }
 74 

 75     /**
 76      * Initialize with given array of constants.
 77      *
 78      * @param cs array of given constants, new ones will be appended
 79      */
 80     public ConstantPoolGen(final Constant[] cs) {
 81         final StringBuilder sb = new StringBuilder(DEFAULT_BUFFER_SIZE);
 82 
 83         size = Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64);
 84         constants = new Constant[size];
 85 
 86         System.arraycopy(cs, 0, constants, 0, cs.length);
 87         if (cs.length &gt; 0) {
 88             index = cs.length;
 89         }
 90 

 91         for (int i = 1; i &lt; index; i++) {
 92             final Constant c = constants[i];
 93             if (c instanceof ConstantString) {
 94                 final ConstantString s = (ConstantString) c;
 95                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
 96                 final String key = u8.getBytes();
 97                 if (!string_table.containsKey(key)) {
 98                     string_table.put(key, new Index(i));
 99                 }
100             } else if (c instanceof ConstantClass) {
101                 final ConstantClass s = (ConstantClass) c;
102                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
103                 final String key = u8.getBytes();
104                 if (!class_table.containsKey(key)) {
105                     class_table.put(key, new Index(i));
106                 }
107             } else if (c instanceof ConstantNameAndType) {
108                 final ConstantNameAndType n = (ConstantNameAndType) c;
109                 final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
110                 final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
</pre>
<hr />
<pre>
117 
118                 if (!n_a_t_table.containsKey(key)) {
119                     n_a_t_table.put(key, new Index(i));
120                 }
121             } else if (c instanceof ConstantUtf8) {
122                 final ConstantUtf8 u = (ConstantUtf8) c;
123                 final String key = u.getBytes();
124                 if (!utf8_table.containsKey(key)) {
125                     utf8_table.put(key, new Index(i));
126                 }
127             } else if (c instanceof ConstantCP) {
128                 final ConstantCP m = (ConstantCP) c;
129                 String class_name;
130                 ConstantUtf8 u8;
131 
132                 if (c instanceof ConstantInvokeDynamic) {
133                     class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());
134                     // since name can&#39;t begin with digit, can  use
135                     // METHODREF_DELIM with out fear of duplicates.
136                 } else {
<span class="line-modified">137                     final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];</span>
138                     u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
139                     class_name = u8.getBytes().replace(&#39;/&#39;, &#39;.&#39;);
140                 }
141 
142                 final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
143                 u8 = (ConstantUtf8) constants[n.getNameIndex()];
144                 final String method_name = u8.getBytes();
145                 u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
146                 final String signature = u8.getBytes();
147 
148                 String delim = METHODREF_DELIM;
149                 if (c instanceof ConstantInterfaceMethodref) {
150                     delim = IMETHODREF_DELIM;
151                 } else if (c instanceof ConstantFieldref) {
152                     delim = FIELDREF_DELIM;
153                 }
154 
155                 sb.append(class_name);
156                 sb.append(delim);
157                 sb.append(method_name);
</pre>
<hr />
<pre>
160                 final String key = sb.toString();
161                 sb.delete(0, sb.length());
162 
163                 if (!cp_table.containsKey(key)) {
164                     cp_table.put(key, new Index(i));
165                 }
166             } else if (c == null) { // entries may be null
167                 // nothing to do
168             } else if (c instanceof ConstantInteger) {
169                 // nothing to do
170             } else if (c instanceof ConstantLong) {
171                 // nothing to do
172             } else if (c instanceof ConstantFloat) {
173                 // nothing to do
174             } else if (c instanceof ConstantDouble) {
175                 // nothing to do
176             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {
177                 // TODO should this be handled somehow?
178             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {
179                 // TODO should this be handled somehow?




180             } else {
181                 assert false : &quot;Unexpected constant type: &quot; + c.getClass().getName();
182             }
183         }
184     }
185 

186     /**
187      * Initialize with given constant pool.
188      */
189     public ConstantPoolGen(final ConstantPool cp) {
190         this(cp.getConstantPool());
191     }
192 

193     /**
194      * Create empty constant pool.
195      */
196     public ConstantPoolGen() {
197         size = DEFAULT_BUFFER_SIZE;
198         constants = new Constant[size];
199     }
200 
<span class="line-modified">201     /**</span>
<span class="line-modified">202      * Resize internal array of constants.</span>
203      */
204     protected void adjustSize() {
205         if (index + 3 &gt;= size) {
206             final Constant[] cs = constants;
207             size *= 2;
208             constants = new Constant[size];
209             System.arraycopy(cs, 0, constants, 0, index);
210         }
211     }
212 
213     private final Map&lt;String, Index&gt; string_table = new HashMap&lt;&gt;();
214 

215     /**
216      * Look for ConstantString in ConstantPool containing String `str&#39;.
217      *
218      * @param str String to search for
219      * @return index on success, -1 otherwise
220      */
<span class="line-modified">221     public int lookupString(final String str) {</span>
222         final Index index = string_table.get(str);
223         return (index != null) ? index.index : -1;
224     }
225 

226     /**
<span class="line-modified">227      * Add a new String constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">228      * there.</span>
229      *
230      * @param str String to add
231      * @return index of entry
232      */
<span class="line-modified">233     public int addString(final String str) {</span>
234         int ret;
235         if ((ret = lookupString(str)) != -1) {
236             return ret; // Already in CP
237         }
238         final int utf8 = addUtf8(str);
239         adjustSize();
240         final ConstantString s = new ConstantString(utf8);
241         ret = index;
242         constants[index++] = s;
243         if (!string_table.containsKey(str)) {
244             string_table.put(str, new Index(ret));
245         }
246         return ret;
247     }
248 
249     private final Map&lt;String, Index&gt; class_table = new HashMap&lt;&gt;();
250 

251     /**
252      * Look for ConstantClass in ConstantPool named `str&#39;.
253      *
254      * @param str String to search for
255      * @return index on success, -1 otherwise
256      */
<span class="line-modified">257     public int lookupClass(final String str) {</span>
258         final Index index = class_table.get(str.replace(&#39;.&#39;, &#39;/&#39;));
259         return (index != null) ? index.index : -1;
260     }
261 
<span class="line-modified">262     private int addClass_(final String clazz) {</span>

263         int ret;
264         if ((ret = lookupClass(clazz)) != -1) {
265             return ret; // Already in CP
266         }
267         adjustSize();
268         final ConstantClass c = new ConstantClass(addUtf8(clazz));
269         ret = index;
270         constants[index++] = c;
271         if (!class_table.containsKey(clazz)) {
272             class_table.put(clazz, new Index(ret));
273         }
274         return ret;
275     }
276 

277     /**
<span class="line-modified">278      * Add a new Class reference to the ConstantPool, if it is not already in</span>
<span class="line-removed">279      * there.</span>
280      *
281      * @param str Class to add
282      * @return index of entry
283      */
<span class="line-modified">284     public int addClass(final String str) {</span>
285         return addClass_(str.replace(&#39;.&#39;, &#39;/&#39;));
286     }
287 

288     /**
289      * Add a new Class reference to the ConstantPool for a given type.
290      *
291      * @param type Class to add
292      * @return index of entry
293      */
<span class="line-modified">294     public int addClass(final ObjectType type) {</span>
295         return addClass(type.getClassName());
296     }
297 

298     /**
<span class="line-modified">299      * Add a reference to an array class (e.g. String[][]) as needed by</span>
<span class="line-modified">300      * MULTIANEWARRAY instruction, e.g. to the ConstantPool.</span>
301      *
302      * @param type type of array class
303      * @return index of entry
304      */
<span class="line-modified">305     public int addArrayClass(final ArrayType type) {</span>
306         return addClass_(type.getSignature());
307     }
308 

309     /**
310      * Look for ConstantInteger in ConstantPool.
311      *
312      * @param n integer number to look for
313      * @return index on success, -1 otherwise
314      */
<span class="line-modified">315     public int lookupInteger(final int n) {</span>
316         for (int i = 1; i &lt; index; i++) {
317             if (constants[i] instanceof ConstantInteger) {
318                 final ConstantInteger c = (ConstantInteger) constants[i];
319                 if (c.getBytes() == n) {
320                     return i;
321                 }
322             }
323         }
324         return -1;
325     }
326 

327     /**
<span class="line-modified">328      * Add a new Integer constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">329      * there.</span>
330      *
331      * @param n integer number to add
332      * @return index of entry
333      */
<span class="line-modified">334     public int addInteger(final int n) {</span>
335         int ret;
336         if ((ret = lookupInteger(n)) != -1) {
337             return ret; // Already in CP
338         }
339         adjustSize();
340         ret = index;
341         constants[index++] = new ConstantInteger(n);
342         return ret;
343     }
344 

345     /**
346      * Look for ConstantFloat in ConstantPool.
347      *
348      * @param n Float number to look for
349      * @return index on success, -1 otherwise
350      */
<span class="line-modified">351     public int lookupFloat(final float n) {</span>
352         final int bits = Float.floatToIntBits(n);
353         for (int i = 1; i &lt; index; i++) {
354             if (constants[i] instanceof ConstantFloat) {
355                 final ConstantFloat c = (ConstantFloat) constants[i];
356                 if (Float.floatToIntBits(c.getBytes()) == bits) {
357                     return i;
358                 }
359             }
360         }
361         return -1;
362     }
363 

364     /**
<span class="line-modified">365      * Add a new Float constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">366      * there.</span>
367      *
368      * @param n Float number to add
369      * @return index of entry
370      */
<span class="line-modified">371     public int addFloat(final float n) {</span>
372         int ret;
373         if ((ret = lookupFloat(n)) != -1) {
374             return ret; // Already in CP
375         }
376         adjustSize();
377         ret = index;
378         constants[index++] = new ConstantFloat(n);
379         return ret;
380     }
381 
382     private final Map&lt;String, Index&gt; utf8_table = new HashMap&lt;&gt;();
383 

384     /**
385      * Look for ConstantUtf8 in ConstantPool.
386      *
387      * @param n Utf8 string to look for
388      * @return index on success, -1 otherwise
389      */
<span class="line-modified">390     public int lookupUtf8(final String n) {</span>
391         final Index index = utf8_table.get(n);
392         return (index != null) ? index.index : -1;
393     }
394 

395     /**
<span class="line-modified">396      * Add a new Utf8 constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">397      * there.</span>
398      *
399      * @param n Utf8 string to add
400      * @return index of entry
401      */
<span class="line-modified">402     public int addUtf8(final String n) {</span>
403         int ret;
404         if ((ret = lookupUtf8(n)) != -1) {
405             return ret; // Already in CP
406         }
407         adjustSize();
408         ret = index;
409         constants[index++] = new ConstantUtf8(n);
410         if (!utf8_table.containsKey(n)) {
411             utf8_table.put(n, new Index(ret));
412         }
413         return ret;
414     }
415 

416     /**
417      * Look for ConstantLong in ConstantPool.
418      *
419      * @param n Long number to look for
420      * @return index on success, -1 otherwise
421      */
<span class="line-modified">422     public int lookupLong(final long n) {</span>
423         for (int i = 1; i &lt; index; i++) {
424             if (constants[i] instanceof ConstantLong) {
425                 final ConstantLong c = (ConstantLong) constants[i];
426                 if (c.getBytes() == n) {
427                     return i;
428                 }
429             }
430         }
431         return -1;
432     }
433 

434     /**
<span class="line-modified">435      * Add a new long constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">436      * there.</span>
437      *
438      * @param n Long number to add
439      * @return index of entry
440      */
<span class="line-modified">441     public int addLong(final long n) {</span>
442         int ret;
443         if ((ret = lookupLong(n)) != -1) {
444             return ret; // Already in CP
445         }
446         adjustSize();
447         ret = index;
448         constants[index] = new ConstantLong(n);
449         index += 2; // Wastes one entry according to spec
450         return ret;
451     }
452 

453     /**
454      * Look for ConstantDouble in ConstantPool.
455      *
456      * @param n Double number to look for
457      * @return index on success, -1 otherwise
458      */
<span class="line-modified">459     public int lookupDouble(final double n) {</span>
460         final long bits = Double.doubleToLongBits(n);
461         for (int i = 1; i &lt; index; i++) {
462             if (constants[i] instanceof ConstantDouble) {
463                 final ConstantDouble c = (ConstantDouble) constants[i];
464                 if (Double.doubleToLongBits(c.getBytes()) == bits) {
465                     return i;
466                 }
467             }
468         }
469         return -1;
470     }
471 

472     /**
<span class="line-modified">473      * Add a new double constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">474      * there.</span>
475      *
476      * @param n Double number to add
477      * @return index of entry
478      */
<span class="line-modified">479     public int addDouble(final double n) {</span>
480         int ret;
481         if ((ret = lookupDouble(n)) != -1) {
482             return ret; // Already in CP
483         }
484         adjustSize();
485         ret = index;
486         constants[index] = new ConstantDouble(n);
487         index += 2; // Wastes one entry according to spec
488         return ret;
489     }
490 
491     private final Map&lt;String, Index&gt; n_a_t_table = new HashMap&lt;&gt;();
492 

493     /**
494      * Look for ConstantNameAndType in ConstantPool.
495      *
496      * @param name of variable/method
497      * @param signature of variable/method
498      * @return index on success, -1 otherwise
499      */
<span class="line-modified">500     public int lookupNameAndType(final String name, final String signature) {</span>
501         final Index _index = n_a_t_table.get(name + NAT_DELIM + signature);
502         return (_index != null) ? _index.index : -1;
503     }
504 

505     /**
506      * Add a new NameAndType constant to the ConstantPool if it is not already
507      * in there.
508      *
509      * @param name Name string to add
510      * @param signature signature string to add
511      * @return index of entry
512      */
<span class="line-modified">513     public int addNameAndType(final String name, final String signature) {</span>
514         int ret;
515         int name_index;
516         int signature_index;
517         if ((ret = lookupNameAndType(name, signature)) != -1) {
518             return ret; // Already in CP
519         }
520         adjustSize();
521         name_index = addUtf8(name);
522         signature_index = addUtf8(signature);
523         ret = index;
524         constants[index++] = new ConstantNameAndType(name_index, signature_index);
525         final String key = name + NAT_DELIM + signature;
526         if (!n_a_t_table.containsKey(key)) {
527             n_a_t_table.put(key, new Index(ret));
528         }
529         return ret;
530     }
531 
532     private final Map&lt;String, Index&gt; cp_table = new HashMap&lt;&gt;();
533 

534     /**
535      * Look for ConstantMethodref in ConstantPool.
536      *
537      * @param class_name Where to find method
538      * @param method_name Guess what
539      * @param signature return and argument types
540      * @return index on success, -1 otherwise
541      */
<span class="line-modified">542     public int lookupMethodref(final String class_name, final String method_name, final String signature) {</span>
543         final Index index = cp_table.get(class_name + METHODREF_DELIM + method_name
544                 + METHODREF_DELIM + signature);
545         return (index != null) ? index.index : -1;
546     }
547 
<span class="line-modified">548     public int lookupMethodref(final MethodGen method) {</span>

549         return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());
550     }
551 

552     /**
<span class="line-modified">553      * Add a new Methodref constant to the ConstantPool, if it is not already in</span>
<span class="line-modified">554      * there.</span>
555      *
556      * @param class_name class name string to add
557      * @param method_name method name string to add
558      * @param signature method signature string to add
559      * @return index of entry
560      */
<span class="line-modified">561     public int addMethodref(final String class_name, final String method_name, final String signature) {</span>
562         int ret;
563         int class_index;
564         int name_and_type_index;
565         if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {
566             return ret; // Already in CP
567         }
568         adjustSize();
569         name_and_type_index = addNameAndType(method_name, signature);
570         class_index = addClass(class_name);
571         ret = index;
572         constants[index++] = new ConstantMethodref(class_index, name_and_type_index);
573         final String key = class_name + METHODREF_DELIM + method_name + METHODREF_DELIM + signature;
574         if (!cp_table.containsKey(key)) {
575             cp_table.put(key, new Index(ret));
576         }
577         return ret;
578     }
579 
<span class="line-modified">580     public int addMethodref(final MethodGen method) {</span>

581         return addMethodref(method.getClassName(), method.getName(), method.getSignature());
582     }
583 

584     /**
585      * Look for ConstantInterfaceMethodref in ConstantPool.
586      *
587      * @param class_name Where to find method
588      * @param method_name Guess what
589      * @param signature return and argument types
590      * @return index on success, -1 otherwise
591      */
<span class="line-modified">592     public int lookupInterfaceMethodref(final String class_name, final String method_name, final String signature) {</span>
593         final Index index = cp_table.get(class_name + IMETHODREF_DELIM + method_name
594                 + IMETHODREF_DELIM + signature);
595         return (index != null) ? index.index : -1;
596     }
597 
<span class="line-modified">598     public int lookupInterfaceMethodref(final MethodGen method) {</span>

599         return lookupInterfaceMethodref(method.getClassName(), method.getName(), method
600                 .getSignature());
601     }
602 

603     /**
<span class="line-modified">604      * Add a new InterfaceMethodref constant to the ConstantPool, if it is not</span>
<span class="line-modified">605      * already in there.</span>
606      *
607      * @param class_name class name string to add
608      * @param method_name method name string to add
609      * @param signature signature string to add
610      * @return index of entry
611      */
<span class="line-modified">612     public int addInterfaceMethodref(final String class_name, final String method_name, final String signature) {</span>
613         int ret;
614         int class_index;
615         int name_and_type_index;
616         if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {
617             return ret; // Already in CP
618         }
619         adjustSize();
620         class_index = addClass(class_name);
621         name_and_type_index = addNameAndType(method_name, signature);
622         ret = index;
623         constants[index++] = new ConstantInterfaceMethodref(class_index, name_and_type_index);
624         final String key = class_name + IMETHODREF_DELIM + method_name + IMETHODREF_DELIM + signature;
625         if (!cp_table.containsKey(key)) {
626             cp_table.put(key, new Index(ret));
627         }
628         return ret;
629     }
630 
<span class="line-modified">631     public int addInterfaceMethodref(final MethodGen method) {</span>

632         return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());
633     }
634 

635     /**
636      * Look for ConstantFieldref in ConstantPool.
637      *
638      * @param class_name Where to find method
639      * @param field_name Guess what
640      * @param signature return and argument types
641      * @return index on success, -1 otherwise
642      */
<span class="line-modified">643     public int lookupFieldref(final String class_name, final String field_name, final String signature) {</span>
644         final Index index = cp_table.get(class_name + FIELDREF_DELIM + field_name
645                 + FIELDREF_DELIM + signature);
646         return (index != null) ? index.index : -1;
647     }
648 

649     /**
<span class="line-modified">650      * Add a new Fieldref constant to the ConstantPool, if it is not already in</span>
<span class="line-modified">651      * there.</span>
652      *
653      * @param class_name class name string to add
654      * @param field_name field name string to add
655      * @param signature signature string to add
656      * @return index of entry
657      */
<span class="line-modified">658     public int addFieldref(final String class_name, final String field_name, final String signature) {</span>
659         int ret;
660         int class_index;
661         int name_and_type_index;
662         if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {
663             return ret; // Already in CP
664         }
665         adjustSize();
666         class_index = addClass(class_name);
667         name_and_type_index = addNameAndType(field_name, signature);
668         ret = index;
669         constants[index++] = new ConstantFieldref(class_index, name_and_type_index);
670         final String key = class_name + FIELDREF_DELIM + field_name + FIELDREF_DELIM + signature;
671         if (!cp_table.containsKey(key)) {
672             cp_table.put(key, new Index(ret));
673         }
674         return ret;
675     }
676 

677     /**
678      * @param i index in constant pool
679      * @return constant pool entry at index i
680      */
<span class="line-modified">681     public Constant getConstant(final int i) {</span>
682         return constants[i];
683     }
684 

685     /**
686      * Use with care!
687      *
688      * @param i index in constant pool
689      * @param c new constant pool entry at index i
690      */
<span class="line-modified">691     public void setConstant(final int i, final Constant c) {</span>
692         constants[i] = c;
693     }
694 

695     /**
696      * @return intermediate constant pool
697      */
698     public ConstantPool getConstantPool() {
699         return new ConstantPool(constants);
700     }
701 

702     /**
703      * @return current size of constant pool
704      */
705     public int getSize() {
706         return index;
707     }
708 

709     /**
710      * @return constant pool with proper length
711      */
712     public ConstantPool getFinalConstantPool() {
713         final Constant[] cs = new Constant[index];
714         System.arraycopy(constants, 0, cs, 0, index);
715         return new ConstantPool(cs);
716     }
717 

718     /**
719      * @return String representation.
720      */
721     @Override
722     public String toString() {
723         final StringBuilder buf = new StringBuilder();
724         for (int i = 1; i &lt; index; i++) {
725             buf.append(i).append(&quot;)&quot;).append(constants[i]).append(&quot;\n&quot;);
726         }
727         return buf.toString();
728     }
729 
<span class="line-modified">730     /**</span>
<span class="line-modified">731      * Import constant from another ConstantPool and return new index.</span>
732      */
<span class="line-modified">733     public int addConstant(final Constant c, final ConstantPoolGen cp) {</span>
734         final Constant[] constants = cp.getConstantPool().getConstantPool();
735         switch (c.getTag()) {
736             case Const.CONSTANT_String: {
737                 final ConstantString s = (ConstantString) c;
738                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
739                 return addString(u8.getBytes());
740             }
741             case Const.CONSTANT_Class: {
742                 final ConstantClass s = (ConstantClass) c;
743                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
744                 return addClass(u8.getBytes());
745             }
746             case Const.CONSTANT_NameAndType: {
747                 final ConstantNameAndType n = (ConstantNameAndType) c;
748                 final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
749                 final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
750                 return addNameAndType(u8.getBytes(), u8_2.getBytes());
751             }
752             case Const.CONSTANT_Utf8:
753                 return addUtf8(((ConstantUtf8) c).getBytes());
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.HashMap;
 23 import java.util.Map;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.Constant;
 27 import com.sun.org.apache.bcel.internal.classfile.ConstantCP;
 28 import com.sun.org.apache.bcel.internal.classfile.ConstantClass;
 29 import com.sun.org.apache.bcel.internal.classfile.ConstantDouble;
 30 import com.sun.org.apache.bcel.internal.classfile.ConstantFieldref;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantFloat;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantInteger;
 33 import com.sun.org.apache.bcel.internal.classfile.ConstantInterfaceMethodref;
 34 import com.sun.org.apache.bcel.internal.classfile.ConstantInvokeDynamic;
 35 import com.sun.org.apache.bcel.internal.classfile.ConstantLong;
 36 import com.sun.org.apache.bcel.internal.classfile.ConstantMethodref;
 37 import com.sun.org.apache.bcel.internal.classfile.ConstantNameAndType;
 38 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 39 import com.sun.org.apache.bcel.internal.classfile.ConstantString;
 40 import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
 41 
 42 /**
<span class="line-modified"> 43  * This class is used to build up a constant pool. The user adds</span>
<span class="line-modified"> 44  * constants via `addXXX&#39; methods, `addString&#39;, `addClass&#39;,</span>
<span class="line-modified"> 45  * etc.. These methods return an index into the constant</span>
<span class="line-modified"> 46  * pool. Finally, `getFinalConstantPool()&#39; returns the constant pool</span>
<span class="line-added"> 47  * built up. Intermediate versions of the constant pool can be</span>
 48  * obtained with `getConstantPool()&#39;. A constant pool has capacity for
<span class="line-modified"> 49  * Constants.MAX_SHORT entries. Note that the first (0) is used by the</span>
<span class="line-modified"> 50  * JVM and that Double and Long constants need two slots.</span>
 51  *

 52  * @see Constant
<span class="line-added"> 53  * @LastModified: Jan 2020</span>
 54  */
 55 public class ConstantPoolGen {
 56 
 57     private static final int DEFAULT_BUFFER_SIZE = 256;
 58     private int size;
 59     private Constant[] constants;
 60     private int index = 1; // First entry (0) used by JVM
 61 
 62     private static final String METHODREF_DELIM = &quot;:&quot;;
 63     private static final String IMETHODREF_DELIM = &quot;#&quot;;
 64     private static final String FIELDREF_DELIM = &quot;&amp;&quot;;
 65     private static final String NAT_DELIM = &quot;%&quot;; // Name and Type
 66 
 67     private static class Index {
 68 
 69         final int index;
 70 
<span class="line-added"> 71 </span>
 72         Index(final int i) {
 73             index = i;
 74         }
 75     }
 76 
<span class="line-added"> 77 </span>
 78     /**
 79      * Initialize with given array of constants.
 80      *
 81      * @param cs array of given constants, new ones will be appended
 82      */
 83     public ConstantPoolGen(final Constant[] cs) {
 84         final StringBuilder sb = new StringBuilder(DEFAULT_BUFFER_SIZE);
 85 
 86         size = Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64);
 87         constants = new Constant[size];
 88 
 89         System.arraycopy(cs, 0, constants, 0, cs.length);
 90         if (cs.length &gt; 0) {
 91             index = cs.length;
 92         }
 93 
<span class="line-added"> 94 </span>
 95         for (int i = 1; i &lt; index; i++) {
 96             final Constant c = constants[i];
 97             if (c instanceof ConstantString) {
 98                 final ConstantString s = (ConstantString) c;
 99                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
100                 final String key = u8.getBytes();
101                 if (!string_table.containsKey(key)) {
102                     string_table.put(key, new Index(i));
103                 }
104             } else if (c instanceof ConstantClass) {
105                 final ConstantClass s = (ConstantClass) c;
106                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
107                 final String key = u8.getBytes();
108                 if (!class_table.containsKey(key)) {
109                     class_table.put(key, new Index(i));
110                 }
111             } else if (c instanceof ConstantNameAndType) {
112                 final ConstantNameAndType n = (ConstantNameAndType) c;
113                 final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
114                 final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
</pre>
<hr />
<pre>
121 
122                 if (!n_a_t_table.containsKey(key)) {
123                     n_a_t_table.put(key, new Index(i));
124                 }
125             } else if (c instanceof ConstantUtf8) {
126                 final ConstantUtf8 u = (ConstantUtf8) c;
127                 final String key = u.getBytes();
128                 if (!utf8_table.containsKey(key)) {
129                     utf8_table.put(key, new Index(i));
130                 }
131             } else if (c instanceof ConstantCP) {
132                 final ConstantCP m = (ConstantCP) c;
133                 String class_name;
134                 ConstantUtf8 u8;
135 
136                 if (c instanceof ConstantInvokeDynamic) {
137                     class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());
138                     // since name can&#39;t begin with digit, can  use
139                     // METHODREF_DELIM with out fear of duplicates.
140                 } else {
<span class="line-modified">141                 final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];</span>
142                     u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
143                     class_name = u8.getBytes().replace(&#39;/&#39;, &#39;.&#39;);
144                 }
145 
146                 final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
147                 u8 = (ConstantUtf8) constants[n.getNameIndex()];
148                 final String method_name = u8.getBytes();
149                 u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
150                 final String signature = u8.getBytes();
151 
152                 String delim = METHODREF_DELIM;
153                 if (c instanceof ConstantInterfaceMethodref) {
154                     delim = IMETHODREF_DELIM;
155                 } else if (c instanceof ConstantFieldref) {
156                     delim = FIELDREF_DELIM;
157                 }
158 
159                 sb.append(class_name);
160                 sb.append(delim);
161                 sb.append(method_name);
</pre>
<hr />
<pre>
164                 final String key = sb.toString();
165                 sb.delete(0, sb.length());
166 
167                 if (!cp_table.containsKey(key)) {
168                     cp_table.put(key, new Index(i));
169                 }
170             } else if (c == null) { // entries may be null
171                 // nothing to do
172             } else if (c instanceof ConstantInteger) {
173                 // nothing to do
174             } else if (c instanceof ConstantLong) {
175                 // nothing to do
176             } else if (c instanceof ConstantFloat) {
177                 // nothing to do
178             } else if (c instanceof ConstantDouble) {
179                 // nothing to do
180             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {
181                 // TODO should this be handled somehow?
182             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {
183                 // TODO should this be handled somehow?
<span class="line-added">184             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {</span>
<span class="line-added">185                 // TODO should this be handled somehow?</span>
<span class="line-added">186             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {</span>
<span class="line-added">187                 // TODO should this be handled somehow?</span>
188             } else {
189                 assert false : &quot;Unexpected constant type: &quot; + c.getClass().getName();
190             }
191         }
192     }
193 
<span class="line-added">194 </span>
195     /**
196      * Initialize with given constant pool.
197      */
198     public ConstantPoolGen(final ConstantPool cp) {
199         this(cp.getConstantPool());
200     }
201 
<span class="line-added">202 </span>
203     /**
204      * Create empty constant pool.
205      */
206     public ConstantPoolGen() {
207         size = DEFAULT_BUFFER_SIZE;
208         constants = new Constant[size];
209     }
210 
<span class="line-modified">211 </span>
<span class="line-modified">212     /** Resize internal array of constants.</span>
213      */
214     protected void adjustSize() {
215         if (index + 3 &gt;= size) {
216             final Constant[] cs = constants;
217             size *= 2;
218             constants = new Constant[size];
219             System.arraycopy(cs, 0, constants, 0, index);
220         }
221     }
222 
223     private final Map&lt;String, Index&gt; string_table = new HashMap&lt;&gt;();
224 
<span class="line-added">225 </span>
226     /**
227      * Look for ConstantString in ConstantPool containing String `str&#39;.
228      *
229      * @param str String to search for
230      * @return index on success, -1 otherwise
231      */
<span class="line-modified">232     public int lookupString( final String str ) {</span>
233         final Index index = string_table.get(str);
234         return (index != null) ? index.index : -1;
235     }
236 
<span class="line-added">237 </span>
238     /**
<span class="line-modified">239      * Add a new String constant to the ConstantPool, if it is not already in there.</span>

240      *
241      * @param str String to add
242      * @return index of entry
243      */
<span class="line-modified">244     public int addString( final String str ) {</span>
245         int ret;
246         if ((ret = lookupString(str)) != -1) {
247             return ret; // Already in CP
248         }
249         final int utf8 = addUtf8(str);
250         adjustSize();
251         final ConstantString s = new ConstantString(utf8);
252         ret = index;
253         constants[index++] = s;
254         if (!string_table.containsKey(str)) {
255             string_table.put(str, new Index(ret));
256         }
257         return ret;
258     }
259 
260     private final Map&lt;String, Index&gt; class_table = new HashMap&lt;&gt;();
261 
<span class="line-added">262 </span>
263     /**
264      * Look for ConstantClass in ConstantPool named `str&#39;.
265      *
266      * @param str String to search for
267      * @return index on success, -1 otherwise
268      */
<span class="line-modified">269     public int lookupClass( final String str ) {</span>
270         final Index index = class_table.get(str.replace(&#39;.&#39;, &#39;/&#39;));
271         return (index != null) ? index.index : -1;
272     }
273 
<span class="line-modified">274 </span>
<span class="line-added">275     private int addClass_( final String clazz ) {</span>
276         int ret;
277         if ((ret = lookupClass(clazz)) != -1) {
278             return ret; // Already in CP
279         }
280         adjustSize();
281         final ConstantClass c = new ConstantClass(addUtf8(clazz));
282         ret = index;
283         constants[index++] = c;
284         if (!class_table.containsKey(clazz)) {
285             class_table.put(clazz, new Index(ret));
286         }
287         return ret;
288     }
289 
<span class="line-added">290 </span>
291     /**
<span class="line-modified">292      * Add a new Class reference to the ConstantPool, if it is not already in there.</span>

293      *
294      * @param str Class to add
295      * @return index of entry
296      */
<span class="line-modified">297     public int addClass( final String str ) {</span>
298         return addClass_(str.replace(&#39;.&#39;, &#39;/&#39;));
299     }
300 
<span class="line-added">301 </span>
302     /**
303      * Add a new Class reference to the ConstantPool for a given type.
304      *
305      * @param type Class to add
306      * @return index of entry
307      */
<span class="line-modified">308     public int addClass( final ObjectType type ) {</span>
309         return addClass(type.getClassName());
310     }
311 
<span class="line-added">312 </span>
313     /**
<span class="line-modified">314      * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY</span>
<span class="line-modified">315      * instruction, e.g. to the ConstantPool.</span>
316      *
317      * @param type type of array class
318      * @return index of entry
319      */
<span class="line-modified">320     public int addArrayClass( final ArrayType type ) {</span>
321         return addClass_(type.getSignature());
322     }
323 
<span class="line-added">324 </span>
325     /**
326      * Look for ConstantInteger in ConstantPool.
327      *
328      * @param n integer number to look for
329      * @return index on success, -1 otherwise
330      */
<span class="line-modified">331     public int lookupInteger( final int n ) {</span>
332         for (int i = 1; i &lt; index; i++) {
333             if (constants[i] instanceof ConstantInteger) {
334                 final ConstantInteger c = (ConstantInteger) constants[i];
335                 if (c.getBytes() == n) {
336                     return i;
337                 }
338             }
339         }
340         return -1;
341     }
342 
<span class="line-added">343 </span>
344     /**
<span class="line-modified">345      * Add a new Integer constant to the ConstantPool, if it is not already in there.</span>

346      *
347      * @param n integer number to add
348      * @return index of entry
349      */
<span class="line-modified">350     public int addInteger( final int n ) {</span>
351         int ret;
352         if ((ret = lookupInteger(n)) != -1) {
353             return ret; // Already in CP
354         }
355         adjustSize();
356         ret = index;
357         constants[index++] = new ConstantInteger(n);
358         return ret;
359     }
360 
<span class="line-added">361 </span>
362     /**
363      * Look for ConstantFloat in ConstantPool.
364      *
365      * @param n Float number to look for
366      * @return index on success, -1 otherwise
367      */
<span class="line-modified">368     public int lookupFloat( final float n ) {</span>
369         final int bits = Float.floatToIntBits(n);
370         for (int i = 1; i &lt; index; i++) {
371             if (constants[i] instanceof ConstantFloat) {
372                 final ConstantFloat c = (ConstantFloat) constants[i];
373                 if (Float.floatToIntBits(c.getBytes()) == bits) {
374                     return i;
375                 }
376             }
377         }
378         return -1;
379     }
380 
<span class="line-added">381 </span>
382     /**
<span class="line-modified">383      * Add a new Float constant to the ConstantPool, if it is not already in there.</span>

384      *
385      * @param n Float number to add
386      * @return index of entry
387      */
<span class="line-modified">388     public int addFloat( final float n ) {</span>
389         int ret;
390         if ((ret = lookupFloat(n)) != -1) {
391             return ret; // Already in CP
392         }
393         adjustSize();
394         ret = index;
395         constants[index++] = new ConstantFloat(n);
396         return ret;
397     }
398 
399     private final Map&lt;String, Index&gt; utf8_table = new HashMap&lt;&gt;();
400 
<span class="line-added">401 </span>
402     /**
403      * Look for ConstantUtf8 in ConstantPool.
404      *
405      * @param n Utf8 string to look for
406      * @return index on success, -1 otherwise
407      */
<span class="line-modified">408     public int lookupUtf8( final String n ) {</span>
409         final Index index = utf8_table.get(n);
410         return (index != null) ? index.index : -1;
411     }
412 
<span class="line-added">413 </span>
414     /**
<span class="line-modified">415      * Add a new Utf8 constant to the ConstantPool, if it is not already in there.</span>

416      *
417      * @param n Utf8 string to add
418      * @return index of entry
419      */
<span class="line-modified">420     public int addUtf8( final String n ) {</span>
421         int ret;
422         if ((ret = lookupUtf8(n)) != -1) {
423             return ret; // Already in CP
424         }
425         adjustSize();
426         ret = index;
427         constants[index++] = new ConstantUtf8(n);
428         if (!utf8_table.containsKey(n)) {
429             utf8_table.put(n, new Index(ret));
430         }
431         return ret;
432     }
433 
<span class="line-added">434 </span>
435     /**
436      * Look for ConstantLong in ConstantPool.
437      *
438      * @param n Long number to look for
439      * @return index on success, -1 otherwise
440      */
<span class="line-modified">441     public int lookupLong( final long n ) {</span>
442         for (int i = 1; i &lt; index; i++) {
443             if (constants[i] instanceof ConstantLong) {
444                 final ConstantLong c = (ConstantLong) constants[i];
445                 if (c.getBytes() == n) {
446                     return i;
447                 }
448             }
449         }
450         return -1;
451     }
452 
<span class="line-added">453 </span>
454     /**
<span class="line-modified">455      * Add a new long constant to the ConstantPool, if it is not already in there.</span>

456      *
457      * @param n Long number to add
458      * @return index of entry
459      */
<span class="line-modified">460     public int addLong( final long n ) {</span>
461         int ret;
462         if ((ret = lookupLong(n)) != -1) {
463             return ret; // Already in CP
464         }
465         adjustSize();
466         ret = index;
467         constants[index] = new ConstantLong(n);
468         index += 2; // Wastes one entry according to spec
469         return ret;
470     }
471 
<span class="line-added">472 </span>
473     /**
474      * Look for ConstantDouble in ConstantPool.
475      *
476      * @param n Double number to look for
477      * @return index on success, -1 otherwise
478      */
<span class="line-modified">479     public int lookupDouble( final double n ) {</span>
480         final long bits = Double.doubleToLongBits(n);
481         for (int i = 1; i &lt; index; i++) {
482             if (constants[i] instanceof ConstantDouble) {
483                 final ConstantDouble c = (ConstantDouble) constants[i];
484                 if (Double.doubleToLongBits(c.getBytes()) == bits) {
485                     return i;
486                 }
487             }
488         }
489         return -1;
490     }
491 
<span class="line-added">492 </span>
493     /**
<span class="line-modified">494      * Add a new double constant to the ConstantPool, if it is not already in there.</span>

495      *
496      * @param n Double number to add
497      * @return index of entry
498      */
<span class="line-modified">499     public int addDouble( final double n ) {</span>
500         int ret;
501         if ((ret = lookupDouble(n)) != -1) {
502             return ret; // Already in CP
503         }
504         adjustSize();
505         ret = index;
506         constants[index] = new ConstantDouble(n);
507         index += 2; // Wastes one entry according to spec
508         return ret;
509     }
510 
511     private final Map&lt;String, Index&gt; n_a_t_table = new HashMap&lt;&gt;();
512 
<span class="line-added">513 </span>
514     /**
515      * Look for ConstantNameAndType in ConstantPool.
516      *
517      * @param name of variable/method
518      * @param signature of variable/method
519      * @return index on success, -1 otherwise
520      */
<span class="line-modified">521     public int lookupNameAndType( final String name, final String signature ) {</span>
522         final Index _index = n_a_t_table.get(name + NAT_DELIM + signature);
523         return (_index != null) ? _index.index : -1;
524     }
525 
<span class="line-added">526 </span>
527     /**
528      * Add a new NameAndType constant to the ConstantPool if it is not already
529      * in there.
530      *
531      * @param name Name string to add
532      * @param signature signature string to add
533      * @return index of entry
534      */
<span class="line-modified">535     public int addNameAndType( final String name, final String signature ) {</span>
536         int ret;
537         int name_index;
538         int signature_index;
539         if ((ret = lookupNameAndType(name, signature)) != -1) {
540             return ret; // Already in CP
541         }
542         adjustSize();
543         name_index = addUtf8(name);
544         signature_index = addUtf8(signature);
545         ret = index;
546         constants[index++] = new ConstantNameAndType(name_index, signature_index);
547         final String key = name + NAT_DELIM + signature;
548         if (!n_a_t_table.containsKey(key)) {
549             n_a_t_table.put(key, new Index(ret));
550         }
551         return ret;
552     }
553 
554     private final Map&lt;String, Index&gt; cp_table = new HashMap&lt;&gt;();
555 
<span class="line-added">556 </span>
557     /**
558      * Look for ConstantMethodref in ConstantPool.
559      *
560      * @param class_name Where to find method
561      * @param method_name Guess what
562      * @param signature return and argument types
563      * @return index on success, -1 otherwise
564      */
<span class="line-modified">565     public int lookupMethodref( final String class_name, final String method_name, final String signature ) {</span>
566         final Index index = cp_table.get(class_name + METHODREF_DELIM + method_name
567                 + METHODREF_DELIM + signature);
568         return (index != null) ? index.index : -1;
569     }
570 
<span class="line-modified">571 </span>
<span class="line-added">572     public int lookupMethodref( final MethodGen method ) {</span>
573         return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());
574     }
575 
<span class="line-added">576 </span>
577     /**
<span class="line-modified">578      * Add a new Methodref constant to the ConstantPool, if it is not already</span>
<span class="line-modified">579      * in there.</span>
580      *
581      * @param class_name class name string to add
582      * @param method_name method name string to add
583      * @param signature method signature string to add
584      * @return index of entry
585      */
<span class="line-modified">586     public int addMethodref( final String class_name, final String method_name, final String signature ) {</span>
587         int ret;
588         int class_index;
589         int name_and_type_index;
590         if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {
591             return ret; // Already in CP
592         }
593         adjustSize();
594         name_and_type_index = addNameAndType(method_name, signature);
595         class_index = addClass(class_name);
596         ret = index;
597         constants[index++] = new ConstantMethodref(class_index, name_and_type_index);
598         final String key = class_name + METHODREF_DELIM + method_name + METHODREF_DELIM + signature;
599         if (!cp_table.containsKey(key)) {
600             cp_table.put(key, new Index(ret));
601         }
602         return ret;
603     }
604 
<span class="line-modified">605 </span>
<span class="line-added">606     public int addMethodref( final MethodGen method ) {</span>
607         return addMethodref(method.getClassName(), method.getName(), method.getSignature());
608     }
609 
<span class="line-added">610 </span>
611     /**
612      * Look for ConstantInterfaceMethodref in ConstantPool.
613      *
614      * @param class_name Where to find method
615      * @param method_name Guess what
616      * @param signature return and argument types
617      * @return index on success, -1 otherwise
618      */
<span class="line-modified">619     public int lookupInterfaceMethodref( final String class_name, final String method_name, final String signature ) {</span>
620         final Index index = cp_table.get(class_name + IMETHODREF_DELIM + method_name
621                 + IMETHODREF_DELIM + signature);
622         return (index != null) ? index.index : -1;
623     }
624 
<span class="line-modified">625 </span>
<span class="line-added">626     public int lookupInterfaceMethodref( final MethodGen method ) {</span>
627         return lookupInterfaceMethodref(method.getClassName(), method.getName(), method
628                 .getSignature());
629     }
630 
<span class="line-added">631 </span>
632     /**
<span class="line-modified">633      * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already</span>
<span class="line-modified">634      * in there.</span>
635      *
636      * @param class_name class name string to add
637      * @param method_name method name string to add
638      * @param signature signature string to add
639      * @return index of entry
640      */
<span class="line-modified">641     public int addInterfaceMethodref( final String class_name, final String method_name, final String signature ) {</span>
642         int ret;
643         int class_index;
644         int name_and_type_index;
645         if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {
646             return ret; // Already in CP
647         }
648         adjustSize();
649         class_index = addClass(class_name);
650         name_and_type_index = addNameAndType(method_name, signature);
651         ret = index;
652         constants[index++] = new ConstantInterfaceMethodref(class_index, name_and_type_index);
653         final String key = class_name + IMETHODREF_DELIM + method_name + IMETHODREF_DELIM + signature;
654         if (!cp_table.containsKey(key)) {
655             cp_table.put(key, new Index(ret));
656         }
657         return ret;
658     }
659 
<span class="line-modified">660 </span>
<span class="line-added">661     public int addInterfaceMethodref( final MethodGen method ) {</span>
662         return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());
663     }
664 
<span class="line-added">665 </span>
666     /**
667      * Look for ConstantFieldref in ConstantPool.
668      *
669      * @param class_name Where to find method
670      * @param field_name Guess what
671      * @param signature return and argument types
672      * @return index on success, -1 otherwise
673      */
<span class="line-modified">674     public int lookupFieldref( final String class_name, final String field_name, final String signature ) {</span>
675         final Index index = cp_table.get(class_name + FIELDREF_DELIM + field_name
676                 + FIELDREF_DELIM + signature);
677         return (index != null) ? index.index : -1;
678     }
679 
<span class="line-added">680 </span>
681     /**
<span class="line-modified">682      * Add a new Fieldref constant to the ConstantPool, if it is not already</span>
<span class="line-modified">683      * in there.</span>
684      *
685      * @param class_name class name string to add
686      * @param field_name field name string to add
687      * @param signature signature string to add
688      * @return index of entry
689      */
<span class="line-modified">690     public int addFieldref( final String class_name, final String field_name, final String signature ) {</span>
691         int ret;
692         int class_index;
693         int name_and_type_index;
694         if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {
695             return ret; // Already in CP
696         }
697         adjustSize();
698         class_index = addClass(class_name);
699         name_and_type_index = addNameAndType(field_name, signature);
700         ret = index;
701         constants[index++] = new ConstantFieldref(class_index, name_and_type_index);
702         final String key = class_name + FIELDREF_DELIM + field_name + FIELDREF_DELIM + signature;
703         if (!cp_table.containsKey(key)) {
704             cp_table.put(key, new Index(ret));
705         }
706         return ret;
707     }
708 
<span class="line-added">709 </span>
710     /**
711      * @param i index in constant pool
712      * @return constant pool entry at index i
713      */
<span class="line-modified">714     public Constant getConstant( final int i ) {</span>
715         return constants[i];
716     }
717 
<span class="line-added">718 </span>
719     /**
720      * Use with care!
721      *
722      * @param i index in constant pool
723      * @param c new constant pool entry at index i
724      */
<span class="line-modified">725     public void setConstant( final int i, final Constant c ) {</span>
726         constants[i] = c;
727     }
728 
<span class="line-added">729 </span>
730     /**
731      * @return intermediate constant pool
732      */
733     public ConstantPool getConstantPool() {
734         return new ConstantPool(constants);
735     }
736 
<span class="line-added">737 </span>
738     /**
739      * @return current size of constant pool
740      */
741     public int getSize() {
742         return index;
743     }
744 
<span class="line-added">745 </span>
746     /**
747      * @return constant pool with proper length
748      */
749     public ConstantPool getFinalConstantPool() {
750         final Constant[] cs = new Constant[index];
751         System.arraycopy(constants, 0, cs, 0, index);
752         return new ConstantPool(cs);
753     }
754 
<span class="line-added">755 </span>
756     /**
757      * @return String representation.
758      */
759     @Override
760     public String toString() {
761         final StringBuilder buf = new StringBuilder();
762         for (int i = 1; i &lt; index; i++) {
763             buf.append(i).append(&quot;)&quot;).append(constants[i]).append(&quot;\n&quot;);
764         }
765         return buf.toString();
766     }
767 
<span class="line-modified">768 </span>
<span class="line-modified">769     /** Import constant from another ConstantPool and return new index.</span>
770      */
<span class="line-modified">771     public int addConstant( final Constant c, final ConstantPoolGen cp ) {</span>
772         final Constant[] constants = cp.getConstantPool().getConstantPool();
773         switch (c.getTag()) {
774             case Const.CONSTANT_String: {
775                 final ConstantString s = (ConstantString) c;
776                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
777                 return addString(u8.getBytes());
778             }
779             case Const.CONSTANT_Class: {
780                 final ConstantClass s = (ConstantClass) c;
781                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
782                 return addClass(u8.getBytes());
783             }
784             case Const.CONSTANT_NameAndType: {
785                 final ConstantNameAndType n = (ConstantNameAndType) c;
786                 final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
787                 final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
788                 return addNameAndType(u8.getBytes(), u8_2.getBytes());
789             }
790             case Const.CONSTANT_Utf8:
791                 return addUtf8(((ConstantUtf8) c).getBytes());
</pre>
</td>
</tr>
</table>
<center><a href="CompoundInstruction.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ConstantPushInstruction.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
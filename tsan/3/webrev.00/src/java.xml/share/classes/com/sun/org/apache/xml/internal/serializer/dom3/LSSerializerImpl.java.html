<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/dom3/LSSerializerImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one
   6  * or more contributor license agreements. See the NOTICE file
   7  * distributed with this work for additional information
   8  * regarding copyright ownership. The ASF licenses this file
   9  * to you under the Apache License, Version 2.0 (the  &quot;License&quot;);
  10  * you may not use this file except in compliance with the License.
  11  * You may obtain a copy of the License at
  12  *
  13  *     http://www.apache.org/licenses/LICENSE-2.0
  14  *
  15  * Unless required by applicable law or agreed to in writing, software
  16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  18  * See the License for the specific language governing permissions and
  19  * limitations under the License.
  20  */
  21 
  22 package com.sun.org.apache.xml.internal.serializer.dom3;
  23 
  24 import java.io.File;
  25 import java.io.FileOutputStream;
  26 import java.io.OutputStream;
  27 import java.io.OutputStreamWriter;
  28 import java.io.StringWriter;
  29 import java.io.UnsupportedEncodingException;
  30 import java.io.Writer;
  31 import java.net.HttpURLConnection;
  32 import java.net.URL;
  33 import java.net.URLConnection;
  34 import java.util.Properties;
  35 
  36 import com.sun.org.apache.xml.internal.serializer.DOM3Serializer;
  37 import com.sun.org.apache.xml.internal.serializer.Encodings;
  38 import com.sun.org.apache.xml.internal.serializer.Serializer;
  39 import com.sun.org.apache.xml.internal.serializer.ToXMLStream;
  40 import com.sun.org.apache.xml.internal.serializer.OutputPropertiesFactory;
  41 import com.sun.org.apache.xml.internal.serializer.SerializerFactory;
  42 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
  43 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
  44 import com.sun.org.apache.xml.internal.serializer.utils.SystemIDResolver;
  45 import org.w3c.dom.DOMConfiguration;
  46 import org.w3c.dom.DOMError;
  47 import org.w3c.dom.DOMErrorHandler;
  48 import org.w3c.dom.DOMException;
  49 import org.w3c.dom.DOMStringList;
  50 import org.w3c.dom.Document;
  51 import org.w3c.dom.Node;
  52 import org.w3c.dom.ls.LSException;
  53 import org.w3c.dom.ls.LSOutput;
  54 import org.w3c.dom.ls.LSSerializer;
  55 import org.w3c.dom.ls.LSSerializerFilter;
  56 
  57 
  58 /**
  59  * Implemenatation of DOM Level 3 org.w3c.ls.LSSerializer and
  60  * org.w3c.dom.ls.DOMConfiguration.  Serialization is achieved by delegating
  61  * serialization calls to &lt;CODE&gt;org.apache.xml.serializer.ToStream&lt;/CODE&gt; or
  62  * one of its derived classes depending on the serialization method, while walking
  63  * the DOM in DOM3TreeWalker.
  64  * @see &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/load-save.html#LS-LSSerializer&quot;&gt;org.w3c.dom.ls.LSSerializer&lt;/a&gt;
  65  * @see &lt;a href=&quot;http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMConfiguration&quot;&gt;org.w3c.dom.DOMConfiguration&lt;/a&gt;
  66  *
  67  * @version $Id:
  68  *
  69  * @xsl.usage internal
  70  * @LastModified: Aug 2019
  71  */
  72 final public class LSSerializerImpl implements DOMConfiguration, LSSerializer {
  73 
  74     /** private data members */
  75     private Serializer fXMLSerializer = null;
  76 
  77     // Tracks DOMConfiguration features.
  78     protected int fFeatures = 0;
  79 
  80     // Common DOM serializer
  81     private  DOM3Serializer fDOMSerializer = null;
  82 
  83     // A filter set on the LSSerializer
  84     private LSSerializerFilter fSerializerFilter = null;
  85 
  86     // Stores the nodeArg parameter to speed up multiple writes of the same node.
  87     private Node fVisitedNode = null;
  88 
  89     // The end-of-line character sequence used in serialization.  &quot;\n&quot; is whats used on the web.
  90     private String fEndOfLine = &quot;\n&quot;;
  91 
  92     // The DOMErrorhandler.
  93     private DOMErrorHandler fDOMErrorHandler = null;
  94 
  95     // The Configuration parameter to pass to the Underlying serilaizer.
  96     private Properties fDOMConfigProperties = null;
  97 
  98     // The encoding to use during serialization.
  99     private String fEncoding;
 100 
 101     // ************************************************************************
 102     // DOM Level 3 DOM Configuration parameter names
 103     // ************************************************************************
 104     // Parameter canonical-form, true [optional] - NOT SUPPORTED
 105     private final static int CANONICAL = 0x1 &lt;&lt; 0;
 106 
 107     // Parameter cdata-sections, true [required] (default)
 108     private final static int CDATA = 0x1 &lt;&lt; 1;
 109 
 110     // Parameter check-character-normalization, true [optional] - NOT SUPPORTED
 111     private final static int CHARNORMALIZE = 0x1 &lt;&lt; 2;
 112 
 113     // Parameter comments, true [required] (default)
 114     private final static int COMMENTS = 0x1 &lt;&lt; 3;
 115 
 116     // Parameter datatype-normalization, true [optional] - NOT SUPPORTED
 117     private final static int DTNORMALIZE = 0x1 &lt;&lt; 4;
 118 
 119     // Parameter element-content-whitespace, true [required] (default) - value - false [optional] NOT SUPPORTED
 120     private final static int ELEM_CONTENT_WHITESPACE = 0x1 &lt;&lt; 5;
 121 
 122     // Parameter entities, true [required] (default)
 123     private final static int ENTITIES = 0x1 &lt;&lt; 6;
 124 
 125     // Parameter infoset, true [required] (default), false has no effect --&gt; True has no effect for the serializer
 126     private final static int INFOSET = 0x1 &lt;&lt; 7;
 127 
 128     // Parameter namespaces, true [required] (default)
 129     private final static int NAMESPACES = 0x1 &lt;&lt; 8;
 130 
 131     // Parameter namespace-declarations, true [required] (default)
 132     private final static int NAMESPACEDECLS = 0x1 &lt;&lt; 9;
 133 
 134     // Parameter normalize-characters, true [optional] - NOT SUPPORTED
 135     private final static int NORMALIZECHARS = 0x1 &lt;&lt; 10;
 136 
 137     // Parameter split-cdata-sections, true [required] (default)
 138     private final static int SPLITCDATA = 0x1 &lt;&lt; 11;
 139 
 140     // Parameter validate, true [optional] - NOT SUPPORTED
 141     private final static int VALIDATE = 0x1 &lt;&lt; 12;
 142 
 143     // Parameter validate-if-schema, true [optional] - NOT SUPPORTED
 144     private final static int SCHEMAVALIDATE = 0x1 &lt;&lt; 13;
 145 
 146     // Parameter split-cdata-sections, true [required] (default)
 147     private final static int WELLFORMED = 0x1 &lt;&lt; 14;
 148 
 149     // Parameter discard-default-content, true [required] (default)
 150     // Not sure how this will be used in level 2 Documents
 151     private final static int DISCARDDEFAULT = 0x1 &lt;&lt; 15;
 152 
 153     // Parameter format-pretty-print, true [optional]
 154     private final static int PRETTY_PRINT = 0x1 &lt;&lt; 16;
 155 
 156     // Parameter ignore-unknown-character-denormalizations, true [required] (default)
 157     // We currently do not support XML 1.1 character normalization
 158     private final static int IGNORE_CHAR_DENORMALIZE = 0x1 &lt;&lt; 17;
 159 
 160     // Parameter discard-default-content, true [required] (default)
 161     private final static int XMLDECL = 0x1 &lt;&lt; 18;
 162     // ************************************************************************
 163 
 164     // Recognized parameters for which atleast one value can be set
 165     private String fRecognizedParameters [] = {
 166             DOMConstants.DOM_CANONICAL_FORM,
 167             DOMConstants.DOM_CDATA_SECTIONS,
 168             DOMConstants.DOM_CHECK_CHAR_NORMALIZATION,
 169             DOMConstants.DOM_COMMENTS,
 170             DOMConstants.DOM_DATATYPE_NORMALIZATION,
 171             DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE,
 172             DOMConstants.DOM_ENTITIES,
 173             DOMConstants.DOM_INFOSET,
 174             DOMConstants.DOM_NAMESPACES,
 175             DOMConstants.DOM_NAMESPACE_DECLARATIONS,
 176             //DOMConstants.DOM_NORMALIZE_CHARACTERS,
 177             DOMConstants.DOM_SPLIT_CDATA,
 178             DOMConstants.DOM_VALIDATE,
 179             DOMConstants.DOM_VALIDATE_IF_SCHEMA,
 180             DOMConstants.DOM_WELLFORMED,
 181             DOMConstants.DOM_DISCARD_DEFAULT_CONTENT,
 182             DOMConstants.DOM_FORMAT_PRETTY_PRINT,
 183             DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS,
 184             DOMConstants.DOM_XMLDECL,
 185             DOMConstants.DOM_ERROR_HANDLER
 186     };
 187 
 188 
 189     /**
 190      * Constructor:  Creates a LSSerializerImpl object.  The underlying
 191      * XML 1.0 or XML 1.1 org.apache.xml.serializer.Serializer object is
 192      * created and initialized the first time any of the write methods are
 193      * invoked to serialize the Node.  Subsequent write methods on the same
 194      * LSSerializerImpl object will use the previously created Serializer object.
 195      */
 196     public LSSerializerImpl () {
 197         // set default parameters
 198         fFeatures |= CDATA;
 199         fFeatures |= COMMENTS;
 200         fFeatures |= ELEM_CONTENT_WHITESPACE;
 201         fFeatures |= ENTITIES;
 202         fFeatures |= NAMESPACES;
 203         fFeatures |= NAMESPACEDECLS;
 204         fFeatures |= SPLITCDATA;
 205         fFeatures |= WELLFORMED;
 206         fFeatures |= DISCARDDEFAULT;
 207         fFeatures |= XMLDECL;
 208 
 209         // New OutputFormat properties
 210         fDOMConfigProperties = new Properties();
 211 
 212         // Initialize properties to be passed on the underlying serializer
 213         initializeSerializerProps();
 214 
 215         // Read output_xml.properties and System Properties to initialize properties
 216         Properties  configProps = OutputPropertiesFactory.getDefaultMethodProperties(&quot;xml&quot;);
 217 
 218         // change xml version from 1.0 to 1.1
 219         //configProps.setProperty(&quot;version&quot;, &quot;1.1&quot;);
 220 
 221         // Get a serializer that seriailizes according to the properties,
 222         // which in this case is to xml
 223         fXMLSerializer = new ToXMLStream(null);
 224         fXMLSerializer.setOutputFormat(configProps);
 225 
 226         // Initialize Serializer
 227         fXMLSerializer.setOutputFormat(fDOMConfigProperties);
 228     }
 229 
 230     /**
 231      * Initializes the underlying serializer&#39;s configuration depending on the
 232      * default DOMConfiguration parameters. This method must be called before a
 233      * node is to be serialized.
 234      *
 235      * @xsl.usage internal
 236      */
 237     public void initializeSerializerProps () {
 238         // canonical-form
 239         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 240                 + DOMConstants.DOM_CANONICAL_FORM, DOMConstants.DOM3_DEFAULT_FALSE);
 241 
 242         // cdata-sections
 243         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 244                 + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_DEFAULT_TRUE);
 245 
 246         // &quot;check-character-normalization&quot;
 247         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 248                 + DOMConstants.DOM_CHECK_CHAR_NORMALIZATION,
 249                 DOMConstants.DOM3_DEFAULT_FALSE);
 250 
 251         // comments
 252         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 253                 + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_DEFAULT_TRUE);
 254 
 255         // datatype-normalization
 256         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 257                 + DOMConstants.DOM_DATATYPE_NORMALIZATION,
 258                 DOMConstants.DOM3_DEFAULT_FALSE);
 259 
 260         // element-content-whitespace
 261         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 262                 + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE,
 263                 DOMConstants.DOM3_DEFAULT_TRUE);
 264 
 265         // entities
 266         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 267                 + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_DEFAULT_TRUE);
 268 
 269         // error-handler
 270         // Should we set our default ErrorHandler
 271         /*
 272          * if (fDOMConfig.getParameter(Constants.DOM_ERROR_HANDLER) != null) {
 273          * fDOMErrorHandler =
 274          * (DOMErrorHandler)fDOMConfig.getParameter(Constants.DOM_ERROR_HANDLER); }
 275          */
 276 
 277         // infoset
 278         if ((fFeatures &amp; INFOSET) != 0) {
 279             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 280                     + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_DEFAULT_TRUE);
 281             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 282                     + DOMConstants.DOM_NAMESPACE_DECLARATIONS,
 283                     DOMConstants.DOM3_DEFAULT_TRUE);
 284             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 285                     + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_DEFAULT_TRUE);
 286             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 287                     + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE,
 288                     DOMConstants.DOM3_DEFAULT_TRUE);
 289             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 290                     + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_DEFAULT_TRUE);
 291             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 292                     + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_DEFAULT_FALSE);
 293             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 294                     + DOMConstants.DOM_CDATA_SECTIONS,
 295                     DOMConstants.DOM3_DEFAULT_FALSE);
 296             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 297                     + DOMConstants.DOM_VALIDATE_IF_SCHEMA,
 298                     DOMConstants.DOM3_DEFAULT_FALSE);
 299             fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 300                     + DOMConstants.DOM_DATATYPE_NORMALIZATION,
 301                     DOMConstants.DOM3_DEFAULT_FALSE);
 302         }
 303 
 304         // namespaces
 305         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 306                 + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_DEFAULT_TRUE);
 307 
 308         // namespace-declarations
 309         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 310                 + DOMConstants.DOM_NAMESPACE_DECLARATIONS,
 311                 DOMConstants.DOM3_DEFAULT_TRUE);
 312 
 313         // normalize-characters
 314         /*
 315         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 316                 + DOMConstants.DOM_NORMALIZE_CHARACTERS,
 317                 DOMConstants.DOM3_DEFAULT_FALSE);
 318         */
 319 
 320         // split-cdata-sections
 321         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 322                 + DOMConstants.DOM_SPLIT_CDATA, DOMConstants.DOM3_DEFAULT_TRUE);
 323 
 324         // validate
 325         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 326                 + DOMConstants.DOM_VALIDATE, DOMConstants.DOM3_DEFAULT_FALSE);
 327 
 328         // validate-if-schema
 329         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 330                 + DOMConstants.DOM_VALIDATE_IF_SCHEMA,
 331                 DOMConstants.DOM3_DEFAULT_FALSE);
 332 
 333         // well-formed
 334         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 335                 + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_DEFAULT_TRUE);
 336 
 337         // pretty-print
 338         fDOMConfigProperties.setProperty(
 339                 DOMConstants.S_XSL_OUTPUT_INDENT,
 340                 DOMConstants.DOM3_DEFAULT_FALSE);
 341         fDOMConfigProperties.setProperty(
 342                 OutputPropertiesFactory.S_KEY_INDENT_AMOUNT, Integer.toString(4));
 343 
 344         //
 345 
 346         // discard-default-content
 347         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 348                 + DOMConstants.DOM_DISCARD_DEFAULT_CONTENT,
 349                 DOMConstants.DOM3_DEFAULT_TRUE);
 350 
 351         // xml-declaration
 352         fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, &quot;no&quot;);
 353 
 354     }
 355 
 356     // ************************************************************************
 357     // DOMConfiguraiton implementation
 358     // ************************************************************************
 359 
 360     /**
 361      * Checks if setting a parameter to a specific value is supported.
 362      *
 363      * @see org.w3c.dom.DOMConfiguration#canSetParameter(java.lang.String, java.lang.Object)
 364      * @since DOM Level 3
 365      * @param name A String containing the DOMConfiguration parameter name.
 366      * @param value An Object specifying the value of the corresponding parameter.
 367      */
 368     public boolean canSetParameter(String name, Object value) {
 369         if (value instanceof Boolean){
 370             if ( name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS)
 371                     || name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS)
 372                     || name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES)
 373                     || name.equalsIgnoreCase(DOMConstants.DOM_INFOSET)
 374                     || name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE)
 375                     || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES)
 376                     || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS)
 377                     || name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA)
 378                     || name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED)
 379                     || name.equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT)
 380                     || name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT)
 381                     || name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)){
 382                 // both values supported
 383                 return true;
 384             }
 385             else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)
 386                     || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION)
 387                     || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)
 388                     || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)
 389                     || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)
 390                     // || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)
 391                     ) {
 392                 // true is not supported
 393                 return !((Boolean)value).booleanValue();
 394             }
 395             else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {
 396                 // false is not supported
 397                 return ((Boolean)value).booleanValue();
 398             }
 399         }
 400         else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER) &amp;&amp;
 401                 value == null || value instanceof DOMErrorHandler){
 402             return true;
 403         }
 404         return false;
 405     }
 406     /**
 407      * This method returns the value of a parameter if known.
 408      *
 409      * @see org.w3c.dom.DOMConfiguration#getParameter(java.lang.String)
 410      *
 411      * @param name A String containing the DOMConfiguration parameter name
 412      *             whose value is to be returned.
 413      * @return Object The value of the parameter if known.
 414      */
 415     public Object getParameter(String name) throws DOMException {
 416 
 417         if(name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)){
 418                       return null;
 419         } else if (name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS)) {
 420             return ((fFeatures &amp; COMMENTS) != 0) ? Boolean.TRUE : Boolean.FALSE;
 421         } else if (name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS)) {
 422             return ((fFeatures &amp; CDATA) != 0) ? Boolean.TRUE : Boolean.FALSE;
 423         } else if (name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES)) {
 424             return ((fFeatures &amp; ENTITIES) != 0) ? Boolean.TRUE : Boolean.FALSE;
 425         } else if (name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES)) {
 426             return ((fFeatures &amp; NAMESPACES) != 0) ? Boolean.TRUE : Boolean.FALSE;
 427         } else if (name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS)) {
 428             return ((fFeatures &amp; NAMESPACEDECLS) != 0) ? Boolean.TRUE : Boolean.FALSE;
 429         } else if (name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA)) {
 430             return ((fFeatures &amp; SPLITCDATA) != 0) ? Boolean.TRUE : Boolean.FALSE;
 431         } else if (name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED)) {
 432             return ((fFeatures &amp; WELLFORMED) != 0) ? Boolean.TRUE : Boolean.FALSE;
 433         }  else if (name.equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT)) {
 434             return ((fFeatures &amp; DISCARDDEFAULT) != 0) ? Boolean.TRUE : Boolean.FALSE;
 435         } else if (name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT)) {
 436             return ((fFeatures &amp; PRETTY_PRINT) != 0) ? Boolean.TRUE : Boolean.FALSE;
 437         } else if (name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)) {
 438             return ((fFeatures &amp; XMLDECL) != 0) ? Boolean.TRUE : Boolean.FALSE;
 439         } else if (name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE)) {
 440             return ((fFeatures &amp; ELEM_CONTENT_WHITESPACE) != 0) ? Boolean.TRUE : Boolean.FALSE;
 441         } else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {
 442             return Boolean.TRUE;
 443         } else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)
 444                 || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION)
 445                 || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)
 446                 // || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)
 447                 || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)
 448                 || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)) {
 449             return Boolean.FALSE;
 450         } else if (name.equalsIgnoreCase(DOMConstants.DOM_INFOSET)){
 451             if ((fFeatures &amp; ENTITIES) == 0 &amp;&amp;
 452                     (fFeatures &amp; CDATA) == 0 &amp;&amp;
 453                     (fFeatures &amp; ELEM_CONTENT_WHITESPACE) != 0 &amp;&amp;
 454                     (fFeatures &amp; NAMESPACES) != 0 &amp;&amp;
 455                     (fFeatures &amp; NAMESPACEDECLS) != 0 &amp;&amp;
 456                     (fFeatures &amp; WELLFORMED) != 0 &amp;&amp;
 457                     (fFeatures &amp; COMMENTS) != 0) {
 458                 return Boolean.TRUE;
 459             }
 460             return Boolean.FALSE;
 461         } else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER)) {
 462             return fDOMErrorHandler;
 463         } else if (
 464                 name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_LOCATION)
 465                 || name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_TYPE)) {
 466             return null;
 467         } else {
 468             // Here we have to add the Xalan specific DOM Message Formatter
 469             String msg = Utils.messages.createMessage(
 470                     MsgKey.ER_FEATURE_NOT_FOUND,
 471                     new Object[] { name });
 472             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 473         }
 474     }
 475 
 476     /**
 477      * This method returns a of the parameters supported by this DOMConfiguration object
 478      * and for which at least one value can be set by the application
 479      *
 480      * @see org.w3c.dom.DOMConfiguration#getParameterNames()
 481      *
 482      * @return DOMStringList A list of DOMConfiguration parameters recognized
 483      *                       by the serializer
 484      */
 485     public DOMStringList getParameterNames() {
 486         return new DOMStringListImpl(fRecognizedParameters);
 487     }
 488 
 489     /**
 490      * This method sets the value of the named parameter.
 491      *
 492      * @see org.w3c.dom.DOMConfiguration#setParameter(java.lang.String, java.lang.Object)
 493      *
 494      * @param name A String containing the DOMConfiguration parameter name.
 495      * @param value An Object contaiing the parameters value to set.
 496      */
 497     public void setParameter(String name, Object value) throws DOMException {
 498         // If the value is a boolean
 499         if (value instanceof Boolean) {
 500             boolean state = ((Boolean) value).booleanValue();
 501 
 502             if (name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS)) {
 503                 fFeatures = state ? fFeatures | COMMENTS : fFeatures
 504                         &amp; ~COMMENTS;
 505                 // comments
 506                 if (state) {
 507                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 508                             + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_EXPLICIT_TRUE);
 509                 } else {
 510                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 511                             + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_EXPLICIT_FALSE);
 512                 }
 513             } else if (name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS)) {
 514                 fFeatures =  state ? fFeatures | CDATA : fFeatures
 515                         &amp; ~CDATA;
 516                 // cdata-sections
 517                 if (state) {
 518                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 519                             + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_EXPLICIT_TRUE);
 520                 } else {
 521                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 522                             + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_EXPLICIT_FALSE);
 523                 }
 524             } else if (name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES)) {
 525                 fFeatures = state ? fFeatures | ENTITIES : fFeatures
 526                         &amp; ~ENTITIES;
 527                 // entities
 528                 if (state) {
 529                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 530                             + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_EXPLICIT_TRUE);
 531                 } else {
 532                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 533                             + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_EXPLICIT_FALSE);
 534                 }
 535             } else if (name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES)) {
 536                 fFeatures = state ? fFeatures | NAMESPACES : fFeatures
 537                         &amp; ~NAMESPACES;
 538                 // namespaces
 539                 if (state) {
 540                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 541                             + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_EXPLICIT_TRUE);
 542                 } else {
 543                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 544                             + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_EXPLICIT_FALSE);
 545                 }
 546             } else if (name
 547                     .equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS)) {
 548                 fFeatures = state ? fFeatures | NAMESPACEDECLS
 549                         : fFeatures &amp; ~NAMESPACEDECLS;
 550                 // namespace-declarations
 551                 if (state) {
 552                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 553                             + DOMConstants.DOM_NAMESPACE_DECLARATIONS, DOMConstants.DOM3_EXPLICIT_TRUE);
 554                 } else {
 555                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 556                             + DOMConstants.DOM_NAMESPACE_DECLARATIONS, DOMConstants.DOM3_EXPLICIT_FALSE);
 557                 }
 558             } else if (name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA)) {
 559                 fFeatures = state ? fFeatures | SPLITCDATA : fFeatures
 560                         &amp; ~SPLITCDATA;
 561                 // split-cdata-sections
 562                 if (state) {
 563                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 564                             + DOMConstants.DOM_SPLIT_CDATA, DOMConstants.DOM3_EXPLICIT_TRUE);
 565                 } else {
 566                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 567                             + DOMConstants.DOM_SPLIT_CDATA, DOMConstants.DOM3_EXPLICIT_FALSE);
 568                 }
 569             } else if (name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED)) {
 570                 fFeatures = state ? fFeatures | WELLFORMED : fFeatures
 571                         &amp; ~WELLFORMED;
 572                 // well-formed
 573                 if (state) {
 574                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 575                             + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_EXPLICIT_TRUE);
 576                 } else {
 577                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 578                             + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_EXPLICIT_FALSE);
 579                 }
 580             } else if (name
 581                     .equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT)) {
 582                 fFeatures = state ? fFeatures | DISCARDDEFAULT
 583                         : fFeatures &amp; ~DISCARDDEFAULT;
 584                 // discard-default-content
 585                 if (state) {
 586                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 587                             + DOMConstants.DOM_DISCARD_DEFAULT_CONTENT, DOMConstants.DOM3_EXPLICIT_TRUE);
 588                 } else {
 589                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 590                             + DOMConstants.DOM_DISCARD_DEFAULT_CONTENT, DOMConstants.DOM3_EXPLICIT_FALSE);
 591                 }
 592             } else if (name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT)) {
 593                 fFeatures = state ? fFeatures | PRETTY_PRINT : fFeatures
 594                         &amp; ~PRETTY_PRINT;
 595                 if (state) {
 596                     fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_INDENT,DOMConstants.DOM3_EXPLICIT_TRUE);
 597                     fDOMConfigProperties.setProperty(OutputPropertiesFactory.S_KEY_INDENT_AMOUNT, Integer.toString(4));
 598                 } else {
 599                     fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_INDENT,DOMConstants.DOM3_EXPLICIT_FALSE);
 600                 }
 601             } else if (name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)) {
 602                 fFeatures = state ? fFeatures | XMLDECL : fFeatures
 603                         &amp; ~XMLDECL;
 604                 if (state) {
 605                     fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, &quot;no&quot;);
 606                 } else {
 607                     fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, &quot;yes&quot;);
 608                 }
 609             } else if (name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE)) {
 610                 fFeatures = state ? fFeatures | ELEM_CONTENT_WHITESPACE : fFeatures
 611                         &amp; ~ELEM_CONTENT_WHITESPACE;
 612                 // element-content-whitespace
 613                 if (state) {
 614                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 615                             + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE, DOMConstants.DOM3_EXPLICIT_TRUE);
 616                 } else {
 617                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 618                             + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE, DOMConstants.DOM3_EXPLICIT_FALSE);
 619                 }
 620             } else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {
 621                 // false is not supported
 622                 if (!state) {
 623                     // Here we have to add the Xalan specific DOM Message Formatter
 624                     String msg = Utils.messages.createMessage(
 625                             MsgKey.ER_FEATURE_NOT_SUPPORTED,
 626                             new Object[] { name });
 627                     throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 628                 } else {
 629                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 630                             + DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS, DOMConstants.DOM3_EXPLICIT_TRUE);
 631                 }
 632             } else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)
 633                     || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)
 634                     || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)
 635                     || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION)
 636                     || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)
 637                     // || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)
 638                     ) {
 639                 // true is not supported
 640                 if (state) {
 641                     String msg = Utils.messages.createMessage(
 642                             MsgKey.ER_FEATURE_NOT_SUPPORTED,
 643                             new Object[] { name });
 644                     throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 645                 } else {
 646                     if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)) {
 647                         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 648                                 + DOMConstants.DOM_CANONICAL_FORM, DOMConstants.DOM3_EXPLICIT_FALSE);
 649                     } else if (name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)) {
 650                         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 651                                 + DOMConstants.DOM_VALIDATE_IF_SCHEMA, DOMConstants.DOM3_EXPLICIT_FALSE);
 652                     } else if (name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)) {
 653                         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 654                                 + DOMConstants.DOM_VALIDATE, DOMConstants.DOM3_EXPLICIT_FALSE);
 655                     } else if (name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)) {
 656                         fDOMConfigProperties.setProperty(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION
 657                                 + DOMConstants.DOM_CHECK_CHAR_NORMALIZATION, DOMConstants.DOM3_EXPLICIT_FALSE);
 658                     } else if (name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)) {
 659                         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 660                                 + DOMConstants.DOM_DATATYPE_NORMALIZATION, DOMConstants.DOM3_EXPLICIT_FALSE);
 661                     } /* else if (name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)) {
 662                         fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 663                                 + DOMConstants.DOM_NORMALIZE_CHARACTERS, DOMConstants.DOM3_EXPLICIT_FALSE);
 664                     } */
 665                 }
 666             } else if (name.equalsIgnoreCase(DOMConstants.DOM_INFOSET)) {
 667                 if (state) {
 668                     fFeatures &amp;= ~ENTITIES;
 669                     fFeatures &amp;= ~CDATA;
 670                     fFeatures &amp;= ~SCHEMAVALIDATE;
 671                     fFeatures &amp;= ~DTNORMALIZE;
 672                     fFeatures |= NAMESPACES;
 673                     fFeatures |= NAMESPACEDECLS;
 674                     fFeatures |= WELLFORMED;
 675                     fFeatures |= ELEM_CONTENT_WHITESPACE;
 676                     fFeatures |= COMMENTS;
 677 
 678                     // infoset
 679                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 680                             + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_EXPLICIT_TRUE);
 681                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 682                             + DOMConstants.DOM_NAMESPACE_DECLARATIONS, DOMConstants.DOM3_EXPLICIT_TRUE);
 683                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 684                             + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_EXPLICIT_TRUE);
 685                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 686                             + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE, DOMConstants.DOM3_EXPLICIT_TRUE);
 687                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 688                             + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_EXPLICIT_TRUE);
 689 
 690                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 691                             + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_EXPLICIT_FALSE);
 692 
 693                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 694                             + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_EXPLICIT_FALSE);
 695                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 696                             + DOMConstants.DOM_VALIDATE_IF_SCHEMA, DOMConstants.DOM3_EXPLICIT_FALSE);
 697                     fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS
 698                             + DOMConstants.DOM_DATATYPE_NORMALIZATION, DOMConstants.DOM3_EXPLICIT_FALSE);
 699                 }
 700             } else if (name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)) {
 701                 String msg = Utils.messages.createMessage(
 702                     MsgKey.ER_FEATURE_NOT_SUPPORTED,
 703                     new Object[] { name });
 704                 throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 705             } else {
 706                 // Setting this to false has no effect
 707             }
 708         } // If the parameter value is not a boolean
 709         else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER)) {
 710             if (value == null || value instanceof DOMErrorHandler) {
 711                 fDOMErrorHandler = (DOMErrorHandler)value;
 712             } else {
 713                 String msg = Utils.messages.createMessage(
 714                         MsgKey.ER_TYPE_MISMATCH_ERR,
 715                         new Object[] { name });
 716                 throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
 717             }
 718         } else if (
 719                 name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_LOCATION)
 720                 || name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_TYPE)
 721                 || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)
 722                 &amp;&amp; value != null) {
 723             String msg = Utils.messages.createMessage(
 724                     MsgKey.ER_FEATURE_NOT_SUPPORTED,
 725                     new Object[] { name });
 726             throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
 727         } else {
 728             String msg = Utils.messages.createMessage(
 729                     MsgKey.ER_FEATURE_NOT_FOUND,
 730                     new Object[] { name });
 731             throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 732         }
 733     }
 734     // ************************************************************************
 735 
 736 
 737     // ************************************************************************
 738     // DOMConfiguraiton implementation
 739     // ************************************************************************
 740 
 741     /**
 742      * Returns the DOMConfiguration of the LSSerializer.
 743      *
 744      * @see org.w3c.dom.ls.LSSerializer#getDomConfig()
 745      * @since DOM Level 3
 746      * @return A DOMConfiguration object.
 747      */
 748     public DOMConfiguration getDomConfig() {
 749         return (DOMConfiguration)this;
 750     }
 751 
 752     /**
 753      * Returns the DOMConfiguration of the LSSerializer.
 754      *
 755      * @see org.w3c.dom.ls.LSSerializer#getFilter()
 756      * @since DOM Level 3
 757      * @return A LSSerializerFilter object.
 758      */
 759     public LSSerializerFilter getFilter() {
 760         return fSerializerFilter;
 761     }
 762 
 763     /**
 764      * Returns the End-Of-Line sequence of characters to be used in the XML
 765      * being serialized.  If none is set a default &quot;\n&quot; is returned.
 766      *
 767      * @see org.w3c.dom.ls.LSSerializer#getNewLine()
 768      * @since DOM Level 3
 769      * @return A String containing the end-of-line character sequence  used in
 770      * serialization.
 771      */
 772     public String getNewLine() {
 773         return fEndOfLine;
 774     }
 775 
 776     /**
 777      * Set a LSSerilizerFilter on the LSSerializer.  When set, the filter is
 778      * called before each node is serialized which depending on its implemention
 779      * determines if the node is to be serialized or not.
 780      *
 781      * @see org.w3c.dom.ls.LSSerializer#setFilter
 782      * @since DOM Level 3
 783      * @param filter A LSSerializerFilter to be applied to the stream to serialize.
 784      */
 785     public void setFilter(LSSerializerFilter filter) {
 786         fSerializerFilter = filter;
 787     }
 788 
 789     /**
 790      * Sets the End-Of-Line sequence of characters to be used in the XML
 791      * being serialized.  Setting this attribute to null will reset its
 792      * value to the default value i.e. &quot;\n&quot;.
 793      *
 794      * @see org.w3c.dom.ls.LSSerializer#setNewLine
 795      * @since DOM Level 3
 796      * @param newLine a String that is the end-of-line character sequence to be used in
 797      * serialization.
 798      */
 799     public void setNewLine(String newLine) {
 800         fEndOfLine = newLine !=null? newLine: fEndOfLine;
 801     }
 802 
 803     /**
 804      * Serializes the specified node to the specified LSOutput and returns true if the Node
 805      * was successfully serialized.
 806      *
 807      * @see org.w3c.dom.ls.LSSerializer#write(org.w3c.dom.Node, org.w3c.dom.ls.LSOutput)
 808      * @since DOM Level 3
 809      * @param nodeArg The Node to serialize.
 810      * @throws org.w3c.dom.ls.LSException SERIALIZE_ERR: Raised if the
 811      * LSSerializer was unable to serialize the node.
 812      *
 813      */
 814     public boolean write(Node nodeArg, LSOutput destination) throws LSException {
 815         // If the destination is null
 816         if (destination == null) {
 817             String msg = Utils.messages
 818             .createMessage(
 819                     MsgKey.ER_NO_OUTPUT_SPECIFIED,
 820                     null);
 821             if (fDOMErrorHandler != null) {
 822                 fDOMErrorHandler.handleError(new DOMErrorImpl(
 823                         DOMError.SEVERITY_FATAL_ERROR, msg,
 824                         MsgKey.ER_NO_OUTPUT_SPECIFIED));
 825             }
 826             throw new LSException(LSException.SERIALIZE_ERR, msg);
 827         }
 828 
 829         // If nodeArg is null, return false.  Should we throw and LSException instead?
 830         if (nodeArg == null ) {
 831             return false;
 832         }
 833 
 834         // Obtain a reference to the serializer to use
 835         // Serializer serializer = getXMLSerializer(xmlVersion);
 836         Serializer serializer = fXMLSerializer;
 837         serializer.reset();
 838 
 839         // If the node has not been seen
 840         if ( nodeArg != fVisitedNode) {
 841             // Determine the XML Document version of the Node
 842             String xmlVersion = getXMLVersion(nodeArg);
 843 
 844             // Determine the encoding: 1.LSOutput.encoding, 2.Document.inputEncoding, 3.Document.xmlEncoding.
 845             fEncoding = destination.getEncoding();
 846             if (fEncoding == null ) {
 847                 fEncoding = getInputEncoding(nodeArg);
 848                 fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null? &quot;UTF-8&quot;: getXMLEncoding(nodeArg);
 849             }
 850 
 851             // If the encoding is not recognized throw an exception.
 852             // Note: The serializer defaults to UTF-8 when created
 853             if (!Encodings.isRecognizedEncoding(fEncoding)) {
 854                 String msg = Utils.messages
 855                 .createMessage(
 856                         MsgKey.ER_UNSUPPORTED_ENCODING,
 857                         null);
 858                 if (fDOMErrorHandler != null) {
 859                     fDOMErrorHandler.handleError(new DOMErrorImpl(
 860                             DOMError.SEVERITY_FATAL_ERROR, msg,
 861                             MsgKey.ER_UNSUPPORTED_ENCODING));
 862                 }
 863                 throw new LSException(LSException.SERIALIZE_ERR, msg);
 864             }
 865 
 866             serializer.getOutputFormat().setProperty(&quot;version&quot;, xmlVersion);
 867 
 868             // Set the output encoding and xml version properties
 869             fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);
 870             fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);
 871 
 872             // If the node to be serialized is not a Document, Element, or Entity
 873             // node
 874             // then the XML declaration, or text declaration, should be never be
 875             // serialized.
 876             if ( (nodeArg.getNodeType() != Node.DOCUMENT_NODE
 877                     || nodeArg.getNodeType() != Node.ELEMENT_NODE
 878                     || nodeArg.getNodeType() != Node.ENTITY_NODE)
 879                     &amp;&amp; ((fFeatures &amp; XMLDECL) != 0)) {
 880                 fDOMConfigProperties.setProperty(
 881                         DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL,
 882                         DOMConstants.DOM3_DEFAULT_FALSE);
 883             }
 884 
 885             fVisitedNode = nodeArg;
 886         }
 887 
 888         // Update the serializer properties
 889         fXMLSerializer.setOutputFormat(fDOMConfigProperties);
 890 
 891         //
 892         try {
 893 
 894             // The LSSerializer will use the LSOutput object to determine
 895             // where to serialize the output to in the following order the
 896             // first one that is not null and not an empty string will be
 897             // used: 1.LSOutput.characterStream, 2.LSOutput.byteStream,
 898             // 3. LSOutput.systemId
 899             // 1.LSOutput.characterStream
 900             Writer writer = destination.getCharacterStream();
 901             if (writer == null ) {
 902 
 903                 // 2.LSOutput.byteStream
 904                 OutputStream outputStream = destination.getByteStream();
 905                 if ( outputStream == null) {
 906 
 907                     // 3. LSOutput.systemId
 908                     String uri = destination.getSystemId();
 909                     if (uri == null) {
 910                         String msg = Utils.messages
 911                         .createMessage(
 912                                 MsgKey.ER_NO_OUTPUT_SPECIFIED,
 913                                 null);
 914                         if (fDOMErrorHandler != null) {
 915                             fDOMErrorHandler.handleError(new DOMErrorImpl(
 916                                     DOMError.SEVERITY_FATAL_ERROR, msg,
 917                                     MsgKey.ER_NO_OUTPUT_SPECIFIED));
 918                         }
 919                         throw new LSException(LSException.SERIALIZE_ERR, msg);
 920 
 921                     } else {
 922                         // Expand the System Id and obtain an absolute URI for it.
 923                         String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);
 924 
 925                         URL url = new URL(absoluteURI);
 926                         OutputStream urlOutStream = null;
 927                         String protocol = url.getProtocol();
 928                         String host = url.getHost();
 929 
 930                         // For file protocols, there is no need to use a URL to get its
 931                         // corresponding OutputStream
 932 
 933                         // Scheme names consist of a sequence of characters. The lower case
 934                         // letters &quot;a&quot;--&quot;z&quot;, digits, and the characters plus (&quot;+&quot;), period
 935                         // (&quot;.&quot;), and hyphen (&quot;-&quot;) are allowed. For resiliency, programs
 936                         // interpreting URLs should treat upper case letters as equivalent to
 937                         // lower case in scheme names (e.g., allow &quot;HTTP&quot; as well as &quot;http&quot;).
 938                         if (protocol.equalsIgnoreCase(&quot;file&quot;)
 939                                 &amp;&amp; (host == null || host.length() == 0 || host.equals(&quot;localhost&quot;))) {
 940                             // do we also need to check for host.equals(hostname)
 941                             urlOutStream = new FileOutputStream(new File(url.getPath()));
 942 
 943                         } else {
 944                             // This should support URL&#39;s whose schemes are mentioned in
 945                             // RFC1738 other than file
 946 
 947                             URLConnection urlCon = url.openConnection();
 948                             urlCon.setDoInput(false);
 949                             urlCon.setDoOutput(true);
 950                             urlCon.setUseCaches(false);
 951                             urlCon.setAllowUserInteraction(false);
 952 
 953                             // When writing to a HTTP URI, a HTTP PUT is performed.
 954                             if (urlCon instanceof HttpURLConnection) {
 955                                 HttpURLConnection httpCon = (HttpURLConnection) urlCon;
 956                                 httpCon.setRequestMethod(&quot;PUT&quot;);
 957                             }
 958                             urlOutStream = urlCon.getOutputStream();
 959                         }
 960                         // set the OutputStream to that obtained from the systemId
 961                         serializer.setWriter(new OutputStreamWriter(urlOutStream));
 962                     }
 963                 } else {
 964                     // 2.LSOutput.byteStream
 965                     serializer.setWriter(new OutputStreamWriter(outputStream, fEncoding));
 966                 }
 967             } else {
 968                 // 1.LSOutput.characterStream
 969                 serializer.setWriter(writer);
 970             }
 971 
 972             // The associated media type by default is set to text/xml on
 973             // org.apache.xml.serializer.SerializerBase.
 974 
 975             // Get a reference to the serializer then lets you serilize a DOM
 976             // Use this hack till Xalan support JAXP1.3
 977             if (fDOMSerializer == null) {
 978                fDOMSerializer = (DOM3Serializer)serializer.asDOM3Serializer();
 979             }
 980 
 981             // Set the error handler on the DOM3Serializer interface implementation
 982             if (fDOMErrorHandler != null) {
 983                 fDOMSerializer.setErrorHandler(fDOMErrorHandler);
 984             }
 985 
 986             // Set the filter on the DOM3Serializer interface implementation
 987             if (fSerializerFilter != null) {
 988                 fDOMSerializer.setNodeFilter(fSerializerFilter);
 989             }
 990 
 991             // Set the NewLine character to be used
 992             fDOMSerializer.setNewLine(fEndOfLine);
 993 
 994             // Serializer your DOM, where node is an org.w3c.dom.Node
 995             // Assuming that Xalan&#39;s serializer can serialize any type of DOM node
 996             fDOMSerializer.serializeDOM3(nodeArg);
 997 
 998         } catch( UnsupportedEncodingException ue) {
 999 
1000             String msg = Utils.messages
1001             .createMessage(
1002                     MsgKey.ER_UNSUPPORTED_ENCODING,
1003                     null);
1004             if (fDOMErrorHandler != null) {
1005                 fDOMErrorHandler.handleError(new DOMErrorImpl(
1006                         DOMError.SEVERITY_FATAL_ERROR, msg,
1007                         MsgKey.ER_UNSUPPORTED_ENCODING, ue));
1008             }
1009             throw new LSException(LSException.SERIALIZE_ERR, ue.getMessage());
1010         } catch (LSException lse) {
1011             // Rethrow LSException.
1012             throw lse;
1013         } catch (RuntimeException e) {
1014             e.printStackTrace();
1015             throw new LSException(LSException.SERIALIZE_ERR, e!=null?e.getMessage():&quot;NULL Exception&quot;) ;
1016         }  catch (Exception e) {
1017             if (fDOMErrorHandler != null) {
1018                 fDOMErrorHandler.handleError(new DOMErrorImpl(
1019                         DOMError.SEVERITY_FATAL_ERROR, e.getMessage(),
1020                         null, e));
1021             }
1022             e.printStackTrace();
1023             throw new LSException(LSException.SERIALIZE_ERR, e.toString());
1024         }
1025         return true;
1026     }
1027 
1028     /**
1029      * Serializes the specified node and returns a String with the serialized
1030      * data to the caller.
1031      *
1032      * @see org.w3c.dom.ls.LSSerializer#writeToString(org.w3c.dom.Node)
1033      * @since DOM Level 3
1034      * @param nodeArg The Node to serialize.
1035      * @throws org.w3c.dom.ls.LSException SERIALIZE_ERR: Raised if the
1036      * LSSerializer was unable to serialize the node.
1037      *
1038      */
1039     public String writeToString(Node nodeArg) throws DOMException, LSException {
1040         // return null is nodeArg is null.  Should an Exception be thrown instead?
1041         if (nodeArg == null) {
1042             return null;
1043         }
1044 
1045         // Should we reset the serializer configuration before each write operation?
1046         // Obtain a reference to the serializer to use
1047         Serializer serializer = fXMLSerializer;
1048         serializer.reset();
1049 
1050         if (nodeArg != fVisitedNode){
1051             // Determine the XML Document version of the Node
1052             String xmlVersion = getXMLVersion(nodeArg);
1053 
1054             serializer.getOutputFormat().setProperty(&quot;version&quot;, xmlVersion);
1055 
1056             // Set the output encoding and xml version properties
1057             fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);
1058             fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, &quot;UTF-16&quot;);
1059 
1060             // If the node to be serialized is not a Document, Element, or Entity
1061             // node
1062             // then the XML declaration, or text declaration, should be never be
1063             // serialized.
1064             if  ((nodeArg.getNodeType() != Node.DOCUMENT_NODE
1065                     || nodeArg.getNodeType() != Node.ELEMENT_NODE
1066                     || nodeArg.getNodeType() != Node.ENTITY_NODE)
1067                     &amp;&amp; ((fFeatures &amp; XMLDECL) != 0)) {
1068                 fDOMConfigProperties.setProperty(
1069                         DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL,
1070                         DOMConstants.DOM3_DEFAULT_FALSE);
1071             }
1072 
1073             fVisitedNode = nodeArg;
1074         }
1075         // Update the serializer properties
1076         fXMLSerializer.setOutputFormat(fDOMConfigProperties);
1077 
1078         // StringWriter to Output to
1079         StringWriter output = new StringWriter();
1080 
1081         //
1082         try {
1083 
1084             // Set the Serializer&#39;s Writer to a StringWriter
1085             serializer.setWriter(output);
1086 
1087             // Get a reference to the serializer then lets you serilize a DOM
1088             // Use this hack till Xalan support JAXP1.3
1089             if (fDOMSerializer == null) {
1090                 fDOMSerializer = (DOM3Serializer)serializer.asDOM3Serializer();
1091             }
1092 
1093             // Set the error handler on the DOM3Serializer interface implementation
1094             if (fDOMErrorHandler != null) {
1095                 fDOMSerializer.setErrorHandler(fDOMErrorHandler);
1096             }
1097 
1098             // Set the filter on the DOM3Serializer interface implementation
1099             if (fSerializerFilter != null) {
1100                 fDOMSerializer.setNodeFilter(fSerializerFilter);
1101             }
1102 
1103             // Set the NewLine character to be used
1104             fDOMSerializer.setNewLine(fEndOfLine);
1105 
1106             // Serializer your DOM, where node is an org.w3c.dom.Node
1107             fDOMSerializer.serializeDOM3(nodeArg);
1108         } catch (LSException lse) {
1109             // Rethrow LSException.
1110             throw lse;
1111         } catch (RuntimeException e) {
1112             e.printStackTrace();
1113             throw new LSException(LSException.SERIALIZE_ERR, e.toString());
1114         }  catch (Exception e) {
1115             if (fDOMErrorHandler != null) {
1116                 fDOMErrorHandler.handleError(new DOMErrorImpl(
1117                         DOMError.SEVERITY_FATAL_ERROR, e.getMessage(),
1118                         null, e));
1119             }
1120             e.printStackTrace();
1121             throw new LSException(LSException.SERIALIZE_ERR, e.toString());
1122         }
1123 
1124         // return the serialized string
1125         return output.toString();
1126     }
1127 
1128     /**
1129      * Serializes the specified node to the specified URI and returns true if the Node
1130      * was successfully serialized.
1131      *
1132      * @see org.w3c.dom.ls.LSSerializer#writeToURI(org.w3c.dom.Node, String)
1133      * @since DOM Level 3
1134      * @param nodeArg The Node to serialize.
1135      * @throws org.w3c.dom.ls.LSException SERIALIZE_ERR: Raised if the
1136      * LSSerializer was unable to serialize the node.
1137      *
1138      */
1139     public boolean writeToURI(Node nodeArg, String uri) throws LSException {
1140         // If nodeArg is null, return false.  Should we throw and LSException instead?
1141         if (nodeArg == null ) {
1142             return false;
1143         }
1144 
1145         // Obtain a reference to the serializer to use
1146         Serializer serializer = fXMLSerializer;
1147         serializer.reset();
1148 
1149         if (nodeArg != fVisitedNode) {
1150             // Determine the XML Document version of the Node
1151             String xmlVersion = getXMLVersion(nodeArg);
1152 
1153             // Determine the encoding: 1.LSOutput.encoding,
1154             // 2.Document.inputEncoding, 3.Document.xmlEncoding.
1155             fEncoding = getInputEncoding(nodeArg);
1156             if (fEncoding == null ) {
1157                 fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null? &quot;UTF-8&quot;: getXMLEncoding(nodeArg);
1158             }
1159 
1160             serializer.getOutputFormat().setProperty(&quot;version&quot;, xmlVersion);
1161 
1162             // Set the output encoding and xml version properties
1163             fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);
1164             fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);
1165 
1166             // If the node to be serialized is not a Document, Element, or Entity
1167             // node
1168             // then the XML declaration, or text declaration, should be never be
1169             // serialized.
1170             if ( (nodeArg.getNodeType() != Node.DOCUMENT_NODE
1171                     || nodeArg.getNodeType() != Node.ELEMENT_NODE
1172                     || nodeArg.getNodeType() != Node.ENTITY_NODE)
1173                     &amp;&amp; ((fFeatures &amp; XMLDECL) != 0))  {
1174                 fDOMConfigProperties.setProperty(
1175                         DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL,
1176                         DOMConstants.DOM3_DEFAULT_FALSE);
1177             }
1178 
1179             fVisitedNode = nodeArg;
1180         }
1181 
1182         // Update the serializer properties
1183         fXMLSerializer.setOutputFormat(fDOMConfigProperties);
1184 
1185         //
1186         try {
1187             // If the specified encoding is not supported an
1188             // &quot;unsupported-encoding&quot; fatal error is raised. ??
1189             if (uri == null) {
1190                 String msg = Utils.messages.createMessage(
1191                         MsgKey.ER_NO_OUTPUT_SPECIFIED, null);
1192                 if (fDOMErrorHandler != null) {
1193                     fDOMErrorHandler.handleError(new DOMErrorImpl(
1194                             DOMError.SEVERITY_FATAL_ERROR, msg,
1195                             MsgKey.ER_NO_OUTPUT_SPECIFIED));
1196                 }
1197                 throw new LSException(LSException.SERIALIZE_ERR, msg);
1198 
1199             } else {
1200                 // REVISIT: Can this be used to get an absolute expanded URI
1201                 String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);
1202 
1203                 URL url = new URL(absoluteURI);
1204                 OutputStream urlOutStream = null;
1205                 String protocol = url.getProtocol();
1206                 String host = url.getHost();
1207 
1208                 // For file protocols, there is no need to use a URL to get its
1209                 // corresponding OutputStream
1210 
1211                 // Scheme names consist of a sequence of characters. The lower
1212                 // case letters &quot;a&quot;--&quot;z&quot;, digits, and the characters plus (&quot;+&quot;),
1213                 // period (&quot;.&quot;), and hyphen (&quot;-&quot;) are allowed. For resiliency,
1214                 // programs interpreting URLs should treat upper case letters as
1215                 // equivalent to lower case in scheme names
1216                 // (e.g., allow &quot;HTTP&quot; as well as &quot;http&quot;).
1217                 if (protocol.equalsIgnoreCase(&quot;file&quot;)
1218                         &amp;&amp; (host == null || host.length() == 0 || host
1219                                 .equals(&quot;localhost&quot;))) {
1220                     // do we also need to check for host.equals(hostname)
1221                     urlOutStream = new FileOutputStream(new File(url.getPath()));
1222 
1223                 } else {
1224                     // This should support URL&#39;s whose schemes are mentioned in
1225                     // RFC1738 other than file
1226 
1227                     URLConnection urlCon = url.openConnection();
1228                     urlCon.setDoInput(false);
1229                     urlCon.setDoOutput(true);
1230                     urlCon.setUseCaches(false);
1231                     urlCon.setAllowUserInteraction(false);
1232 
1233                     // When writing to a HTTP URI, a HTTP PUT is performed.
1234                     if (urlCon instanceof HttpURLConnection) {
1235                         HttpURLConnection httpCon = (HttpURLConnection) urlCon;
1236                         httpCon.setRequestMethod(&quot;PUT&quot;);
1237                     }
1238                     urlOutStream = urlCon.getOutputStream();
1239                 }
1240                 // set the OutputStream to that obtained from the systemId
1241                 serializer.setWriter(new OutputStreamWriter(urlOutStream, fEncoding));
1242             }
1243 
1244             // Get a reference to the serializer then lets you serilize a DOM
1245             // Use this hack till Xalan support JAXP1.3
1246             if (fDOMSerializer == null) {
1247                 fDOMSerializer = (DOM3Serializer)serializer.asDOM3Serializer();
1248             }
1249 
1250             // Set the error handler on the DOM3Serializer interface implementation
1251             if (fDOMErrorHandler != null) {
1252                 fDOMSerializer.setErrorHandler(fDOMErrorHandler);
1253             }
1254 
1255             // Set the filter on the DOM3Serializer interface implementation
1256             if (fSerializerFilter != null) {
1257                 fDOMSerializer.setNodeFilter(fSerializerFilter);
1258             }
1259 
1260             // Set the NewLine character to be used
1261             fDOMSerializer.setNewLine(fEndOfLine);
1262 
1263             // Serializer your DOM, where node is an org.w3c.dom.Node
1264             // Assuming that Xalan&#39;s serializer can serialize any type of DOM
1265             // node
1266             fDOMSerializer.serializeDOM3(nodeArg);
1267 
1268         } catch (LSException lse) {
1269             // Rethrow LSException.
1270             throw lse;
1271         } catch (RuntimeException e) {
1272             e.printStackTrace();
1273             throw new LSException(LSException.SERIALIZE_ERR, e.toString());
1274         }  catch (Exception e) {
1275             if (fDOMErrorHandler != null) {
1276                 fDOMErrorHandler.handleError(new DOMErrorImpl(
1277                         DOMError.SEVERITY_FATAL_ERROR, e.getMessage(),
1278                         null, e));
1279             }
1280             e.printStackTrace();
1281             throw new LSException(LSException.SERIALIZE_ERR, e.toString());
1282         }
1283 
1284         return true;
1285     }
1286     // ************************************************************************
1287 
1288 
1289     // ************************************************************************
1290     // Implementaion methods
1291     // ************************************************************************
1292 
1293     /**
1294      * Determines the XML Version of the Document Node to serialize.  If the Document Node
1295      * is not a DOM Level 3 Node, then the default version returned is 1.0.
1296      *
1297      * @param  nodeArg The Node to serialize
1298      * @return A String containing the version pseudo-attribute of the XMLDecl.
1299      * @throws Throwable if the DOM implementation does not implement Document.getXmlVersion()
1300      */
1301     //protected String getXMLVersion(Node nodeArg) throws Throwable {
1302     protected String getXMLVersion(Node nodeArg) {
1303         Document doc = null;
1304 
1305         // Determine the XML Version of the document
1306         if (nodeArg != null) {
1307             if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {
1308                 // The Document node is the Node argument
1309                 doc = (Document)nodeArg;
1310             } else {
1311                 // The Document node is the Node argument&#39;s ownerDocument
1312                 doc = nodeArg.getOwnerDocument();
1313             }
1314 
1315             // Determine the DOM Version.
1316             if (doc != null &amp;&amp; doc.getImplementation().hasFeature(&quot;Core&quot;,&quot;3.0&quot;)) {
1317                 try {
1318                     return doc.getXmlVersion();
1319                 } catch (AbstractMethodError e) {
1320                     //ignore, impl does not support the method
1321                 }
1322             }
1323         }
1324         // The version will be treated as &quot;1.0&quot; which may result in
1325         // an ill-formed document being serialized.
1326         // If nodeArg does not have an ownerDocument, treat this as XML 1.0
1327         return &quot;1.0&quot;;
1328     }
1329 
1330     /**
1331      * Determines the XML Encoding of the Document Node to serialize.  If the Document Node
1332      * is not a DOM Level 3 Node, then the default encoding &quot;UTF-8&quot; is returned.
1333      *
1334      * @param  nodeArg The Node to serialize
1335      * @return A String containing the encoding pseudo-attribute of the XMLDecl.
1336      * @throws Throwable if the DOM implementation does not implement Document.getXmlEncoding()
1337      */
1338     protected String getXMLEncoding(Node nodeArg) {
1339         Document doc = null;
1340 
1341         // Determine the XML Encoding of the document
1342         if (nodeArg != null) {
1343             if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {
1344                 // The Document node is the Node argument
1345                 doc = (Document)nodeArg;
1346             } else {
1347                 // The Document node is the Node argument&#39;s ownerDocument
1348                 doc = nodeArg.getOwnerDocument();
1349             }
1350 
1351             // Determine the XML Version.
1352             if (doc != null &amp;&amp; doc.getImplementation().hasFeature(&quot;Core&quot;,&quot;3.0&quot;)) {
1353                 return doc.getXmlEncoding();
1354             }
1355         }
1356         // The default encoding is UTF-8 except for the writeToString method
1357         return &quot;UTF-8&quot;;
1358     }
1359 
1360     /**
1361      * Determines the Input Encoding of the Document Node to serialize.  If the Document Node
1362      * is not a DOM Level 3 Node, then null is returned.
1363      *
1364      * @param  nodeArg The Node to serialize
1365      * @return A String containing the input encoding.
1366      */
1367     protected String getInputEncoding(Node nodeArg)  {
1368         Document doc = null;
1369 
1370         // Determine the Input Encoding of the document
1371         if (nodeArg != null) {
1372             if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {
1373                 // The Document node is the Node argument
1374                 doc = (Document)nodeArg;
1375             } else {
1376                 // The Document node is the Node argument&#39;s ownerDocument
1377                 doc = nodeArg.getOwnerDocument();
1378             }
1379 
1380             // Determine the DOM Version.
1381             if (doc != null &amp;&amp; doc.getImplementation().hasFeature(&quot;Core&quot;,&quot;3.0&quot;)) {
1382                 return doc.getInputEncoding();
1383             }
1384         }
1385         // The default encoding returned is null
1386         return null;
1387     }
1388 
1389     /**
1390      * This method returns the LSSerializer&#39;s error handler.
1391      *
1392      * @return Returns the fDOMErrorHandler.
1393      */
1394     public DOMErrorHandler getErrorHandler() {
1395         return fDOMErrorHandler;
1396     }
1397 
1398 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/StackMapEntry.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StackMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackMapType.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/StackMapEntry.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.classfile;
 23 
 24 import java.io.DataInput;
 25 import java.io.DataOutputStream;
 26 import java.io.IOException;
 27 import com.sun.org.apache.bcel.internal.Const;
 28 
 29 /**
 30  * This class represents a stack map entry recording the types of
 31  * local variables and the the of stack items at a given byte code offset.
 32  * See CLDC specification 5.3.1.2
 33  *
<span class="line-removed"> 34  * @version $Id: StackMapEntry.java 1750029 2016-06-23 22:14:38Z sebb $</span>
 35  * @see     StackMap
 36  * @see     StackMapType
 37  */
 38 public final class StackMapEntry implements Node, Cloneable
 39 {
 40 
 41     private int frame_type;
 42     private int byte_code_offset;
 43     private StackMapType[] types_of_locals;
 44     private StackMapType[] types_of_stack_items;
 45     private ConstantPool constant_pool;
 46 
 47 
 48     /**
 49      * Construct object from input stream.
 50      *
 51      * @param input Input stream
 52      * @throws IOException
 53      */
<span class="line-modified"> 54     StackMapEntry(final DataInput input, final ConstantPool constant_pool) throws IOException {</span>
<span class="line-modified"> 55         this(input.readByte() &amp; 0xFF, -1, null, null, constant_pool);</span>
 56 
 57         if (frame_type &gt;= Const.SAME_FRAME &amp;&amp; frame_type &lt;= Const.SAME_FRAME_MAX) {
 58             byte_code_offset = frame_type - Const.SAME_FRAME;
 59         } else if (frame_type &gt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &amp;&amp;
 60                    frame_type &lt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
 61             byte_code_offset = frame_type - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;
 62             types_of_stack_items = new StackMapType[1];
<span class="line-modified"> 63             types_of_stack_items[0] = new StackMapType(input, constant_pool);</span>
 64         } else if (frame_type == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
 65             byte_code_offset = input.readShort();
 66             types_of_stack_items = new StackMapType[1];
<span class="line-modified"> 67             types_of_stack_items[0] = new StackMapType(input, constant_pool);</span>
 68         } else if (frame_type &gt;= Const.CHOP_FRAME &amp;&amp; frame_type &lt;= Const.CHOP_FRAME_MAX) {
 69             byte_code_offset = input.readShort();
 70         } else if (frame_type == Const.SAME_FRAME_EXTENDED) {
 71             byte_code_offset = input.readShort();
 72         } else if (frame_type &gt;= Const.APPEND_FRAME &amp;&amp; frame_type &lt;= Const.APPEND_FRAME_MAX) {
 73             byte_code_offset = input.readShort();
 74             final int number_of_locals = frame_type - 251;
 75             types_of_locals = new StackMapType[number_of_locals];
 76             for (int i = 0; i &lt; number_of_locals; i++) {
<span class="line-modified"> 77                 types_of_locals[i] = new StackMapType(input, constant_pool);</span>
 78             }
 79         } else if (frame_type == Const.FULL_FRAME) {
 80             byte_code_offset = input.readShort();
 81             final int number_of_locals = input.readShort();
 82             types_of_locals = new StackMapType[number_of_locals];
 83             for (int i = 0; i &lt; number_of_locals; i++) {
<span class="line-modified"> 84                 types_of_locals[i] = new StackMapType(input, constant_pool);</span>
 85             }
 86             final int number_of_stack_items = input.readShort();
 87             types_of_stack_items = new StackMapType[number_of_stack_items];
 88             for (int i = 0; i &lt; number_of_stack_items; i++) {
<span class="line-modified"> 89                 types_of_stack_items[i] = new StackMapType(input, constant_pool);</span>
 90             }
 91         } else {
 92             /* Can&#39;t happen */
 93             throw new ClassFormatException (&quot;Invalid frame type found while parsing stack map table: &quot; + frame_type);
 94         }
 95     }
 96 
 97     /**
 98      * DO NOT USE
 99      *
<span class="line-modified">100      * @param byte_code_offset</span>
<span class="line-modified">101      * @param number_of_locals NOT USED</span>
<span class="line-modified">102      * @param types_of_locals array of {@link StackMapType}s of locals</span>
<span class="line-modified">103      * @param number_of_stack_items NOT USED</span>
<span class="line-modified">104      * @param types_of_stack_items array ot {@link StackMapType}s of stack items</span>
<span class="line-modified">105      * @param constant_pool the constant pool</span>
106      * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)}
107      * instead
108      */
109     @java.lang.Deprecated
<span class="line-modified">110     public StackMapEntry(final int byte_code_offset, final int number_of_locals,</span>
<span class="line-modified">111             final StackMapType[] types_of_locals, final int number_of_stack_items,</span>
<span class="line-modified">112             final StackMapType[] types_of_stack_items, final ConstantPool constant_pool) {</span>
<span class="line-modified">113         this.byte_code_offset = byte_code_offset;</span>
<span class="line-modified">114         this.types_of_locals = types_of_locals != null ? types_of_locals : new StackMapType[0];</span>
<span class="line-modified">115         this.types_of_stack_items = types_of_stack_items != null ? types_of_stack_items : new StackMapType[0];</span>
<span class="line-modified">116         this.constant_pool = constant_pool;</span>
117     }
118 
119     /**
120      * Create an instance
121      *
122      * @param tag the frame_type to use
<span class="line-modified">123      * @param byte_code_offset</span>
<span class="line-modified">124      * @param types_of_locals array of {@link StackMapType}s of locals</span>
<span class="line-modified">125      * @param types_of_stack_items array ot {@link StackMapType}s of stack items</span>
<span class="line-modified">126      * @param constant_pool the constant pool</span>
127      */
<span class="line-modified">128     public StackMapEntry(final int tag, final int byte_code_offset,</span>
<span class="line-modified">129             final StackMapType[] types_of_locals,</span>
<span class="line-modified">130             final StackMapType[] types_of_stack_items, final ConstantPool constant_pool) {</span>
131         this.frame_type = tag;
<span class="line-modified">132         this.byte_code_offset = byte_code_offset;</span>
<span class="line-modified">133         this.types_of_locals = types_of_locals != null ? types_of_locals : new StackMapType[0];</span>
<span class="line-modified">134         this.types_of_stack_items = types_of_stack_items != null ? types_of_stack_items : new StackMapType[0];</span>
<span class="line-modified">135         this.constant_pool = constant_pool;</span>
136     }
137 
138 
139     /**
140      * Dump stack map entry
141      *
142      * @param file Output file stream
143      * @throws IOException
144      */
<span class="line-modified">145     public final void dump( final DataOutputStream file ) throws IOException {</span>
146         file.write(frame_type);
147         if (frame_type &gt;= Const.SAME_FRAME &amp;&amp; frame_type &lt;= Const.SAME_FRAME_MAX) {
148             // nothing to be done
149         } else if (frame_type &gt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &amp;&amp;
150                    frame_type &lt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
151             types_of_stack_items[0].dump(file);
152         } else if (frame_type == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
153             file.writeShort(byte_code_offset);
154             types_of_stack_items[0].dump(file);
155         } else if (frame_type &gt;= Const.CHOP_FRAME &amp;&amp; frame_type &lt;= Const.CHOP_FRAME_MAX) {
156             file.writeShort(byte_code_offset);
157         } else if (frame_type == Const.SAME_FRAME_EXTENDED) {
158             file.writeShort(byte_code_offset);
159         } else if (frame_type &gt;= Const.APPEND_FRAME &amp;&amp; frame_type &lt;= Const.APPEND_FRAME_MAX) {
160             file.writeShort(byte_code_offset);
161             for (final StackMapType type : types_of_locals) {
162                 type.dump(file);
163             }
164         } else if (frame_type == Const.FULL_FRAME) {
165             file.writeShort(byte_code_offset);
166             file.writeShort(types_of_locals.length);
167             for (final StackMapType type : types_of_locals) {
168                 type.dump(file);
169             }
170             file.writeShort(types_of_stack_items.length);
171             for (final StackMapType type : types_of_stack_items) {
172                 type.dump(file);
173             }
174         } else {
175             /* Can&#39;t happen */
176             throw new ClassFormatException (&quot;Invalid Stack map table tag: &quot; + frame_type);
177         }
178     }
179 
180 
181     /**
182      * @return String representation.
183      */
184     @Override
<span class="line-modified">185     public final String toString() {</span>
186         final StringBuilder buf = new StringBuilder(64);
187         buf.append(&quot;(&quot;);
188         if (frame_type &gt;= Const.SAME_FRAME &amp;&amp; frame_type &lt;= Const.SAME_FRAME_MAX) {
189             buf.append(&quot;SAME&quot;);
190         } else if (frame_type &gt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &amp;&amp;
191                   frame_type &lt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
192             buf.append(&quot;SAME_LOCALS_1_STACK&quot;);
193         } else if (frame_type == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
194             buf.append(&quot;SAME_LOCALS_1_STACK_EXTENDED&quot;);
195         } else if (frame_type &gt;= Const.CHOP_FRAME &amp;&amp; frame_type &lt;= Const.CHOP_FRAME_MAX) {
196             buf.append(&quot;CHOP &quot;).append(String.valueOf(251-frame_type));
197         } else if (frame_type == Const.SAME_FRAME_EXTENDED) {
198             buf.append(&quot;SAME_EXTENDED&quot;);
199         } else if (frame_type &gt;= Const.APPEND_FRAME &amp;&amp; frame_type &lt;= Const.APPEND_FRAME_MAX) {
200             buf.append(&quot;APPEND &quot;).append(String.valueOf(frame_type-251));
201         } else if (frame_type == Const.FULL_FRAME) {
202             buf.append(&quot;FULL&quot;);
203         } else {
204             buf.append(&quot;UNKNOWN (&quot;).append(frame_type).append(&quot;)&quot;);
205         }
</pre>
<hr />
<pre>
409         return e;
410     }
411 
412 
413     /**
414      * Called by objects that are traversing the nodes of the tree implicitely
415      * defined by the contents of a Java class. I.e., the hierarchy of methods,
416      * fields, attributes, etc. spawns a tree of objects.
417      *
418      * @param v Visitor object
419      */
420     @Override
421     public void accept( final Visitor v ) {
422         v.visitStackMapEntry(this);
423     }
424 
425 
426     /**
427      * @return Constant pool used by this object.
428      */
<span class="line-modified">429     public final ConstantPool getConstantPool() {</span>
430         return constant_pool;
431     }
432 
433 
434     /**
435      * @param constant_pool Constant pool to be used for this object.
436      */
<span class="line-modified">437     public final void setConstantPool( final ConstantPool constant_pool ) {</span>
438         this.constant_pool = constant_pool;
439     }
440 }
</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.classfile;
 23 
 24 import java.io.DataInput;
 25 import java.io.DataOutputStream;
 26 import java.io.IOException;
 27 import com.sun.org.apache.bcel.internal.Const;
 28 
 29 /**
 30  * This class represents a stack map entry recording the types of
 31  * local variables and the the of stack items at a given byte code offset.
 32  * See CLDC specification 5.3.1.2
 33  *

 34  * @see     StackMap
 35  * @see     StackMapType
 36  */
 37 public final class StackMapEntry implements Node, Cloneable
 38 {
 39 
 40     private int frame_type;
 41     private int byte_code_offset;
 42     private StackMapType[] types_of_locals;
 43     private StackMapType[] types_of_stack_items;
 44     private ConstantPool constant_pool;
 45 
 46 
 47     /**
 48      * Construct object from input stream.
 49      *
 50      * @param input Input stream
 51      * @throws IOException
 52      */
<span class="line-modified"> 53     StackMapEntry(final DataInput input, final ConstantPool constantPool) throws IOException {</span>
<span class="line-modified"> 54         this(input.readByte() &amp; 0xFF, -1, null, null, constantPool);</span>
 55 
 56         if (frame_type &gt;= Const.SAME_FRAME &amp;&amp; frame_type &lt;= Const.SAME_FRAME_MAX) {
 57             byte_code_offset = frame_type - Const.SAME_FRAME;
 58         } else if (frame_type &gt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &amp;&amp;
 59                    frame_type &lt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
 60             byte_code_offset = frame_type - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;
 61             types_of_stack_items = new StackMapType[1];
<span class="line-modified"> 62             types_of_stack_items[0] = new StackMapType(input, constantPool);</span>
 63         } else if (frame_type == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
 64             byte_code_offset = input.readShort();
 65             types_of_stack_items = new StackMapType[1];
<span class="line-modified"> 66             types_of_stack_items[0] = new StackMapType(input, constantPool);</span>
 67         } else if (frame_type &gt;= Const.CHOP_FRAME &amp;&amp; frame_type &lt;= Const.CHOP_FRAME_MAX) {
 68             byte_code_offset = input.readShort();
 69         } else if (frame_type == Const.SAME_FRAME_EXTENDED) {
 70             byte_code_offset = input.readShort();
 71         } else if (frame_type &gt;= Const.APPEND_FRAME &amp;&amp; frame_type &lt;= Const.APPEND_FRAME_MAX) {
 72             byte_code_offset = input.readShort();
 73             final int number_of_locals = frame_type - 251;
 74             types_of_locals = new StackMapType[number_of_locals];
 75             for (int i = 0; i &lt; number_of_locals; i++) {
<span class="line-modified"> 76                 types_of_locals[i] = new StackMapType(input, constantPool);</span>
 77             }
 78         } else if (frame_type == Const.FULL_FRAME) {
 79             byte_code_offset = input.readShort();
 80             final int number_of_locals = input.readShort();
 81             types_of_locals = new StackMapType[number_of_locals];
 82             for (int i = 0; i &lt; number_of_locals; i++) {
<span class="line-modified"> 83                 types_of_locals[i] = new StackMapType(input, constantPool);</span>
 84             }
 85             final int number_of_stack_items = input.readShort();
 86             types_of_stack_items = new StackMapType[number_of_stack_items];
 87             for (int i = 0; i &lt; number_of_stack_items; i++) {
<span class="line-modified"> 88                 types_of_stack_items[i] = new StackMapType(input, constantPool);</span>
 89             }
 90         } else {
 91             /* Can&#39;t happen */
 92             throw new ClassFormatException (&quot;Invalid frame type found while parsing stack map table: &quot; + frame_type);
 93         }
 94     }
 95 
 96     /**
 97      * DO NOT USE
 98      *
<span class="line-modified"> 99      * @param byteCodeOffset</span>
<span class="line-modified">100      * @param numberOfLocals NOT USED</span>
<span class="line-modified">101      * @param typesOfLocals array of {@link StackMapType}s of locals</span>
<span class="line-modified">102      * @param numberOfStackItems NOT USED</span>
<span class="line-modified">103      * @param typesOfStackItems array ot {@link StackMapType}s of stack items</span>
<span class="line-modified">104      * @param constantPool the constant pool</span>
105      * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)}
106      * instead
107      */
108     @java.lang.Deprecated
<span class="line-modified">109     public StackMapEntry(final int byteCodeOffset, final int numberOfLocals,</span>
<span class="line-modified">110             final StackMapType[] typesOfLocals, final int numberOfStackItems,</span>
<span class="line-modified">111             final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {</span>
<span class="line-modified">112         this.byte_code_offset = byteCodeOffset;</span>
<span class="line-modified">113         this.types_of_locals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];</span>
<span class="line-modified">114         this.types_of_stack_items = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];</span>
<span class="line-modified">115         this.constant_pool = constantPool;</span>
116     }
117 
118     /**
119      * Create an instance
120      *
121      * @param tag the frame_type to use
<span class="line-modified">122      * @param byteCodeOffset</span>
<span class="line-modified">123      * @param typesOfLocals array of {@link StackMapType}s of locals</span>
<span class="line-modified">124      * @param typesOfStackItems array ot {@link StackMapType}s of stack items</span>
<span class="line-modified">125      * @param constantPool the constant pool</span>
126      */
<span class="line-modified">127     public StackMapEntry(final int tag, final int byteCodeOffset,</span>
<span class="line-modified">128             final StackMapType[] typesOfLocals,</span>
<span class="line-modified">129             final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {</span>
130         this.frame_type = tag;
<span class="line-modified">131         this.byte_code_offset = byteCodeOffset;</span>
<span class="line-modified">132         this.types_of_locals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];</span>
<span class="line-modified">133         this.types_of_stack_items = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];</span>
<span class="line-modified">134         this.constant_pool = constantPool;</span>
135     }
136 
137 
138     /**
139      * Dump stack map entry
140      *
141      * @param file Output file stream
142      * @throws IOException
143      */
<span class="line-modified">144     public void dump( final DataOutputStream file ) throws IOException {</span>
145         file.write(frame_type);
146         if (frame_type &gt;= Const.SAME_FRAME &amp;&amp; frame_type &lt;= Const.SAME_FRAME_MAX) {
147             // nothing to be done
148         } else if (frame_type &gt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &amp;&amp;
149                    frame_type &lt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
150             types_of_stack_items[0].dump(file);
151         } else if (frame_type == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
152             file.writeShort(byte_code_offset);
153             types_of_stack_items[0].dump(file);
154         } else if (frame_type &gt;= Const.CHOP_FRAME &amp;&amp; frame_type &lt;= Const.CHOP_FRAME_MAX) {
155             file.writeShort(byte_code_offset);
156         } else if (frame_type == Const.SAME_FRAME_EXTENDED) {
157             file.writeShort(byte_code_offset);
158         } else if (frame_type &gt;= Const.APPEND_FRAME &amp;&amp; frame_type &lt;= Const.APPEND_FRAME_MAX) {
159             file.writeShort(byte_code_offset);
160             for (final StackMapType type : types_of_locals) {
161                 type.dump(file);
162             }
163         } else if (frame_type == Const.FULL_FRAME) {
164             file.writeShort(byte_code_offset);
165             file.writeShort(types_of_locals.length);
166             for (final StackMapType type : types_of_locals) {
167                 type.dump(file);
168             }
169             file.writeShort(types_of_stack_items.length);
170             for (final StackMapType type : types_of_stack_items) {
171                 type.dump(file);
172             }
173         } else {
174             /* Can&#39;t happen */
175             throw new ClassFormatException (&quot;Invalid Stack map table tag: &quot; + frame_type);
176         }
177     }
178 
179 
180     /**
181      * @return String representation.
182      */
183     @Override
<span class="line-modified">184     public String toString() {</span>
185         final StringBuilder buf = new StringBuilder(64);
186         buf.append(&quot;(&quot;);
187         if (frame_type &gt;= Const.SAME_FRAME &amp;&amp; frame_type &lt;= Const.SAME_FRAME_MAX) {
188             buf.append(&quot;SAME&quot;);
189         } else if (frame_type &gt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &amp;&amp;
190                   frame_type &lt;= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {
191             buf.append(&quot;SAME_LOCALS_1_STACK&quot;);
192         } else if (frame_type == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
193             buf.append(&quot;SAME_LOCALS_1_STACK_EXTENDED&quot;);
194         } else if (frame_type &gt;= Const.CHOP_FRAME &amp;&amp; frame_type &lt;= Const.CHOP_FRAME_MAX) {
195             buf.append(&quot;CHOP &quot;).append(String.valueOf(251-frame_type));
196         } else if (frame_type == Const.SAME_FRAME_EXTENDED) {
197             buf.append(&quot;SAME_EXTENDED&quot;);
198         } else if (frame_type &gt;= Const.APPEND_FRAME &amp;&amp; frame_type &lt;= Const.APPEND_FRAME_MAX) {
199             buf.append(&quot;APPEND &quot;).append(String.valueOf(frame_type-251));
200         } else if (frame_type == Const.FULL_FRAME) {
201             buf.append(&quot;FULL&quot;);
202         } else {
203             buf.append(&quot;UNKNOWN (&quot;).append(frame_type).append(&quot;)&quot;);
204         }
</pre>
<hr />
<pre>
408         return e;
409     }
410 
411 
412     /**
413      * Called by objects that are traversing the nodes of the tree implicitely
414      * defined by the contents of a Java class. I.e., the hierarchy of methods,
415      * fields, attributes, etc. spawns a tree of objects.
416      *
417      * @param v Visitor object
418      */
419     @Override
420     public void accept( final Visitor v ) {
421         v.visitStackMapEntry(this);
422     }
423 
424 
425     /**
426      * @return Constant pool used by this object.
427      */
<span class="line-modified">428     public ConstantPool getConstantPool() {</span>
429         return constant_pool;
430     }
431 
432 
433     /**
434      * @param constant_pool Constant pool to be used for this object.
435      */
<span class="line-modified">436     public void setConstantPool( final ConstantPool constant_pool ) {</span>
437         this.constant_pool = constant_pool;
438     }
439 }
</pre>
</td>
</tr>
</table>
<center><a href="StackMap.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackMapType.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
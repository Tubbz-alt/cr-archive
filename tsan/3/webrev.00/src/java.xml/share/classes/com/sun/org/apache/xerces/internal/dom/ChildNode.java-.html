<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ChildNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.xerces.internal.dom;
 23 
 24 import org.w3c.dom.Node;
 25 
 26 /**
 27  * ChildNode inherits from NodeImpl and adds the capability of being a child by
 28  * having references to its previous and next siblings.
 29  *
 30  * @xerces.internal
 31  *
 32  */
 33 public abstract class ChildNode
 34     extends NodeImpl {
 35 
 36     //
 37     // Constants
 38     //
 39 
 40     /** Serialization version. */
 41     static final long serialVersionUID = -6112455738802414002L;
 42 
 43     transient StringBuffer fBufferStr = null;
 44 
 45     //
 46     // Data
 47     //
 48 
 49     /** Previous sibling. */
 50     protected ChildNode previousSibling;
 51 
 52     /** Next sibling. */
 53     protected ChildNode nextSibling;
 54 
 55     //
 56     // Constructors
 57     //
 58 
 59     /**
 60      * No public constructor; only subclasses of Node should be
 61      * instantiated, and those normally via a Document&#39;s factory methods
 62      * &lt;p&gt;
 63      * Every Node knows what Document it belongs to.
 64      */
 65     protected ChildNode(CoreDocumentImpl ownerDocument) {
 66         super(ownerDocument);
 67     } // &lt;init&gt;(CoreDocumentImpl)
 68 
 69     /** Constructor for serialization. */
 70     public ChildNode() {}
 71 
 72     //
 73     // Node methods
 74     //
 75 
 76     /**
 77      * Returns a duplicate of a given node. You can consider this a
 78      * generic &quot;copy constructor&quot; for nodes. The newly returned object should
 79      * be completely independent of the source object&#39;s subtree, so changes
 80      * in one after the clone has been made will not affect the other.
 81      * &lt;P&gt;
 82      * Note: since we never have any children deep is meaningless here,
 83      * ParentNode overrides this behavior.
 84      * @see ParentNode
 85      *
 86      * &lt;p&gt;
 87      * Example: Cloning a Text node will copy both the node and the text it
 88      * contains.
 89      * &lt;p&gt;
 90      * Example: Cloning something that has children -- Element or Attr, for
 91      * example -- will _not_ clone those children unless a &quot;deep clone&quot;
 92      * has been requested. A shallow clone of an Attr node will yield an
 93      * empty Attr of the same name.
 94      * &lt;p&gt;
 95      * NOTE: Clones will always be read/write, even if the node being cloned
 96      * is read-only, to permit applications using only the DOM API to obtain
 97      * editable copies of locked portions of the tree.
 98      */
 99     public Node cloneNode(boolean deep) {
100 
101         ChildNode newnode = (ChildNode) super.cloneNode(deep);
102 
103         // Need to break the association w/ original kids
104         newnode.previousSibling = null;
105         newnode.nextSibling     = null;
106         newnode.isFirstChild(false);
107 
108         return newnode;
109 
110     } // cloneNode(boolean):Node
111 
112     /**
113      * Returns the parent node of this node
114      */
115     public Node getParentNode() {
116         // if we have an owner, ownerNode is our parent, otherwise it&#39;s
117         // our ownerDocument and we don&#39;t have a parent
118         return isOwned() ? ownerNode : null;
119     }
120 
121     /*
122      * same as above but returns internal type
123      */
124     final NodeImpl parentNode() {
125         // if we have an owner, ownerNode is our parent, otherwise it&#39;s
126         // our ownerDocument and we don&#39;t have a parent
127         return isOwned() ? ownerNode : null;
128     }
129 
130     /** The next child of this node&#39;s parent, or null if none */
131     public Node getNextSibling() {
132         return nextSibling;
133     }
134 
135     /** The previous child of this node&#39;s parent, or null if none */
136     public Node getPreviousSibling() {
137         // if we are the firstChild, previousSibling actually refers to our
138         // parent&#39;s lastChild, but we hide that
139         return isFirstChild() ? null : previousSibling;
140     }
141 
142     /*
143      * same as above but returns internal type
144      */
145     final ChildNode previousSibling() {
146         // if we are the firstChild, previousSibling actually refers to our
147         // parent&#39;s lastChild, but we hide that
148         return isFirstChild() ? null : previousSibling;
149     }
150 
151 } // class ChildNode
    </pre>
  </body>
</html>
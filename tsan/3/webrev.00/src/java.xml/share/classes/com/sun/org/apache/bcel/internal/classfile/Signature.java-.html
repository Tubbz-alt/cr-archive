<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/Signature.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.classfile;
 23 
 24 import java.io.ByteArrayInputStream;
 25 import java.io.DataInput;
 26 import java.io.DataOutputStream;
 27 import java.io.IOException;
 28 
 29 import com.sun.org.apache.bcel.internal.Const;
 30 
 31 /**
 32  * This class is derived from &lt;em&gt;Attribute&lt;/em&gt; and represents a reference
 33  * to a GJ attribute.
 34  *
 35  * @version $Id: Signature.java 1749603 2016-06-21 20:50:19Z ggregory $
 36  * @see     Attribute
 37  */
 38 public final class Signature extends Attribute {
 39 
 40     private int signature_index;
 41 
 42 
 43     /**
 44      * Initialize from another object. Note that both objects use the same
 45      * references (shallow copy). Use clone() for a physical copy.
 46      */
 47     public Signature(final Signature c) {
 48         this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());
 49     }
 50 
 51 
 52     /**
 53      * Construct object from file stream.
 54      * @param name_index Index in constant pool to CONSTANT_Utf8
 55      * @param length Content length in bytes
 56      * @param input Input stream
 57      * @param constant_pool Array of constants
 58      * @throws IOException
 59      */
 60     Signature(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)
 61             throws IOException {
 62         this(name_index, length, input.readUnsignedShort(), constant_pool);
 63     }
 64 
 65 
 66     /**
 67      * @param name_index Index in constant pool to CONSTANT_Utf8
 68      * @param length Content length in bytes
 69      * @param signature_index Index in constant pool to CONSTANT_Utf8
 70      * @param constant_pool Array of constants
 71      */
 72     public Signature(final int name_index, final int length, final int signature_index, final ConstantPool constant_pool) {
 73         super(Const.ATTR_SIGNATURE, name_index, length, constant_pool);
 74         this.signature_index = signature_index;
 75     }
 76 
 77 
 78     /**
 79      * Called by objects that are traversing the nodes of the tree implicitely
 80      * defined by the contents of a Java class. I.e., the hierarchy of methods,
 81      * fields, attributes, etc. spawns a tree of objects.
 82      *
 83      * @param v Visitor object
 84      */
 85     @Override
 86     public void accept( final Visitor v ) {
 87         //System.err.println(&quot;Visiting non-standard Signature object&quot;);
 88         v.visitSignature(this);
 89     }
 90 
 91 
 92     /**
 93      * Dump source file attribute to file stream in binary format.
 94      *
 95      * @param file Output file stream
 96      * @throws IOException
 97      */
 98     @Override
 99     public final void dump( final DataOutputStream file ) throws IOException {
100         super.dump(file);
101         file.writeShort(signature_index);
102     }
103 
104 
105     /**
106      * @return Index in constant pool of source file name.
107      */
108     public final int getSignatureIndex() {
109         return signature_index;
110     }
111 
112 
113     /**
114      * @param signature_index the index info the constant pool of this signature
115      */
116     public final void setSignatureIndex( final int signature_index ) {
117         this.signature_index = signature_index;
118     }
119 
120 
121     /**
122      * @return GJ signature.
123      */
124     public final String getSignature() {
125         final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(signature_index,
126                 Const.CONSTANT_Utf8);
127         return c.getBytes();
128     }
129 
130     /**
131      * Extends ByteArrayInputStream to make &#39;unreading&#39; chars possible.
132      */
133     private static final class MyByteArrayInputStream extends ByteArrayInputStream {
134 
135         MyByteArrayInputStream(final String data) {
136             super(data.getBytes());
137         }
138 
139 
140         final String getData() {
141             return new String(buf);
142         }
143 
144 
145         final void unread() {
146             if (pos &gt; 0) {
147                 pos--;
148             }
149         }
150     }
151 
152 
153     private static boolean identStart( final int ch ) {
154         return ch == &#39;T&#39; || ch == &#39;L&#39;;
155     }
156 
157 
158     private static void matchIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {
159         int ch;
160         if ((ch = in.read()) == -1) {
161             throw new RuntimeException(&quot;Illegal signature: &quot; + in.getData()
162                     + &quot; no ident, reaching EOF&quot;);
163         }
164         //System.out.println(&quot;return from ident:&quot; + (char)ch);
165         if (!identStart(ch)) {
166             final StringBuilder buf2 = new StringBuilder();
167             int count = 1;
168             while (Character.isJavaIdentifierPart((char) ch)) {
169                 buf2.append((char) ch);
170                 count++;
171                 ch = in.read();
172             }
173             if (ch == &#39;:&#39;) { // Ok, formal parameter
174                 in.skip(&quot;Ljava/lang/Object&quot;.length());
175                 buf.append(buf2);
176                 ch = in.read();
177                 in.unread();
178                 //System.out.println(&quot;so far:&quot; + buf2 + &quot;:next:&quot; +(char)ch);
179             } else {
180                 for (int i = 0; i &lt; count; i++) {
181                     in.unread();
182                 }
183             }
184             return;
185         }
186         final StringBuilder buf2 = new StringBuilder();
187         ch = in.read();
188         do {
189             buf2.append((char) ch);
190             ch = in.read();
191             //System.out.println(&quot;within ident:&quot;+ (char)ch);
192         } while ((ch != -1) &amp;&amp; (Character.isJavaIdentifierPart((char) ch) || (ch == &#39;/&#39;)));
193         buf.append(buf2.toString().replace(&#39;/&#39;, &#39;.&#39;));
194         //System.out.println(&quot;regular return ident:&quot;+ (char)ch + &quot;:&quot; + buf2);
195         if (ch != -1) {
196             in.unread();
197         }
198     }
199 
200 
201     private static void matchGJIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {
202         int ch;
203         matchIdent(in, buf);
204         ch = in.read();
205         if ((ch == &#39;&lt;&#39;) || ch == &#39;(&#39;) { // Parameterized or method
206             //System.out.println(&quot;Enter &lt;&quot;);
207             buf.append((char) ch);
208             matchGJIdent(in, buf);
209             while (((ch = in.read()) != &#39;&gt;&#39;) &amp;&amp; (ch != &#39;)&#39;)) { // List of parameters
210                 if (ch == -1) {
211                     throw new RuntimeException(&quot;Illegal signature: &quot; + in.getData()
212                             + &quot; reaching EOF&quot;);
213                 }
214                 //System.out.println(&quot;Still no &gt;&quot;);
215                 buf.append(&quot;, &quot;);
216                 in.unread();
217                 matchGJIdent(in, buf); // Recursive call
218             }
219             //System.out.println(&quot;Exit &gt;&quot;);
220             buf.append((char) ch);
221         } else {
222             in.unread();
223         }
224         ch = in.read();
225         if (identStart(ch)) {
226             in.unread();
227             matchGJIdent(in, buf);
228         } else if (ch == &#39;)&#39;) {
229             in.unread();
230             return;
231         } else if (ch != &#39;;&#39;) {
232             throw new RuntimeException(&quot;Illegal signature: &quot; + in.getData() + &quot; read &quot; + (char) ch);
233         }
234     }
235 
236 
237     public static String translate( final String s ) {
238         //System.out.println(&quot;Sig:&quot; + s);
239         final StringBuilder buf = new StringBuilder();
240         matchGJIdent(new MyByteArrayInputStream(s), buf);
241         return buf.toString();
242     }
243 
244 
245     // @since 6.0 is no longer final
246     public static boolean isFormalParameterList( final String s ) {
247         return s.startsWith(&quot;&lt;&quot;) &amp;&amp; (s.indexOf(&#39;:&#39;) &gt; 0);
248     }
249 
250 
251     // @since 6.0 is no longer final
252     public static boolean isActualParameterList( final String s ) {
253         return s.startsWith(&quot;L&quot;) &amp;&amp; s.endsWith(&quot;&gt;;&quot;);
254     }
255 
256 
257     /**
258      * @return String representation
259      */
260     @Override
261     public final String toString() {
262         final String s = getSignature();
263         return &quot;Signature: &quot; + s;
264     }
265 
266 
267     /**
268      * @return deep copy of this attribute
269      */
270     @Override
271     public Attribute copy( final ConstantPool _constant_pool ) {
272         return (Attribute) clone();
273     }
274 }
    </pre>
  </body>
</html>
diff a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -20,25 +20,21 @@
 
 package com.sun.org.apache.xerces.internal.dom;
 
 
 
-import com.sun.org.apache.xerces.internal.dom.AbortException;
 import com.sun.org.apache.xerces.internal.impl.Constants;
 import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
-import com.sun.org.apache.xerces.internal.impl.dtd.DTDGrammar;
-import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDDescription;
+import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDLoader;
 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator;
 import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
 import com.sun.org.apache.xerces.internal.impl.xs.util.SimpleLocator;
-import com.sun.org.apache.xerces.internal.parsers.XMLGrammarPreparser;
 import com.sun.org.apache.xerces.internal.util.AugmentationsImpl;
 import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
 import com.sun.org.apache.xerces.internal.util.XML11Char;
 import com.sun.org.apache.xerces.internal.util.XMLChar;
-import com.sun.org.apache.xerces.internal.util.XMLGrammarPoolImpl;
 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
 import com.sun.org.apache.xerces.internal.xni.Augmentations;
 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
 import com.sun.org.apache.xerces.internal.xni.QName;
 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
@@ -46,19 +42,16 @@
 import com.sun.org.apache.xerces.internal.xni.XMLLocator;
 import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
 import com.sun.org.apache.xerces.internal.xni.XMLString;
 import com.sun.org.apache.xerces.internal.xni.XNIException;
 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
-import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarPool;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;
-import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
 import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
 import java.io.IOException;
-import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Vector;
 import org.w3c.dom.Attr;
 import org.w3c.dom.Comment;
@@ -94,11 +87,11 @@
  *
  * @xerces.experimental
  *
  * @author Elena Litani, IBM
  * @author Neeraj Bajaj, Sun Microsystems, inc.
- * @LastModified: Nov 2017
+ * @LastModified: Apr 2019
  */
 public class DOMNormalizer implements XMLDocumentHandler {
 
     //
     // constants
@@ -153,20 +146,23 @@
     /** DOM Locator -  for namespace fixup algorithm */
     protected final DOMLocatorImpl fLocator = new DOMLocatorImpl();
 
     /** for setting the PSVI */
     protected Node fCurrentNode = null;
-    private QName fAttrQName = new QName();
+    private final QName fAttrQName = new QName();
 
     // attribute value normalization
     final XMLString fNormalizedValue = new XMLString(new char[16], 0, 0);
 
     //DTD validator
     private XMLDTDValidator fDTDValidator;
 
-    //Check if element content is all "ignorable whitespace"
-    private boolean allWhitespace = false;
+    /** Empty string to pass to the validator. **/
+    public static final XMLString EMPTY_STRING = new XMLString();
+
+    // Check if element content is all "ignorable whitespace"
+    private boolean fAllWhitespace = false;
 
     // Constructor
     //
 
     public DOMNormalizer(){}
@@ -175,79 +171,110 @@
 
     /**
      * Normalizes document.
      * Note: reset() must be called before this method.
      */
-        protected void normalizeDocument(CoreDocumentImpl document, DOMConfigurationImpl config) {
+    protected void normalizeDocument(CoreDocumentImpl document, DOMConfigurationImpl config) {
+
+        fDocument = document;
+        fConfiguration = config;
+        fAllWhitespace = false;
+        fNamespaceValidation = false;
 
-                fDocument = document;
-                fConfiguration = config;
+        String xmlVersion = fDocument.getXmlVersion();
+        String schemaType = null;
+        String [] schemaLocations = null;
 
-                // intialize and reset DOMNormalizer component
-                //
-                fSymbolTable = (SymbolTable) fConfiguration.getProperty(DOMConfigurationImpl.SYMBOL_TABLE);
-                // reset namespace context
-                fNamespaceContext.reset();
-                fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);
+        // intialize and reset DOMNormalizer component
+        //
+        fSymbolTable = (SymbolTable) fConfiguration.getProperty(DOMConfigurationImpl.SYMBOL_TABLE);
+        // reset namespace context
+        fNamespaceContext.reset();
+        fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, null);
 
-                if ((fConfiguration.features & DOMConfigurationImpl.VALIDATE) != 0) {
+        if ((fConfiguration.features & DOMConfigurationImpl.VALIDATE) != 0) {
             String schemaLang = (String)fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_LANGUAGE);
 
-            if(schemaLang != null && schemaLang.equals(Constants.NS_XMLSCHEMA)) {
-                        fValidationHandler =
-                                CoreDOMImplementationImpl.singleton.getValidator(XMLGrammarDescription.XML_SCHEMA);
+            if (schemaLang != null && schemaLang.equals(Constants.NS_XMLSCHEMA)) {
+                schemaType = XMLGrammarDescription.XML_SCHEMA;
+                fValidationHandler = CoreDOMImplementationImpl.singleton.getValidator(schemaType, xmlVersion);
                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA, true);
                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA_FULL_CHECKING, true);
                 // report fatal error on DOM Level 1 nodes
                 fNamespaceValidation = true;
 
                 // check if we need to fill in PSVI
                 fPSVI = ((fConfiguration.features & DOMConfigurationImpl.PSVI) !=0)?true:false;
             }
+            else {
+                schemaType = XMLGrammarDescription.XML_DTD;
+                if (schemaLang != null) {
+                    schemaLocations = (String []) fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_SOURCE);
+                }
+                fConfiguration.setDTDValidatorFactory(xmlVersion);
+                fValidationHandler = CoreDOMImplementationImpl.singleton.getValidator(schemaType, xmlVersion);
+                fPSVI = false;
+            }
 
-                        fConfiguration.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);
+            fConfiguration.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);
 
             // reset ID table
             fDocument.clearIdentifiers();
 
-            if(fValidationHandler != null)
-            // reset schema validator
+            if (fValidationHandler != null) {
+                // reset the validation handler
                 ((XMLComponent) fValidationHandler).reset(fConfiguration);
+            }
+        }
+        else {
+            fValidationHandler = null;
+        }
 
-                }
-
-                fErrorHandler = (DOMErrorHandler) fConfiguration.getParameter(Constants.DOM_ERROR_HANDLER);
-                if (fValidationHandler != null) {
-                        fValidationHandler.setDocumentHandler(this);
-                        fValidationHandler.startDocument(
+        fErrorHandler = (DOMErrorHandler) fConfiguration.getParameter(Constants.DOM_ERROR_HANDLER);
+        if (fValidationHandler != null) {
+            fValidationHandler.setDocumentHandler(this);
+            fValidationHandler.startDocument(
                     new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,
-                                                -1, -1 ), fDocument.encoding, fNamespaceContext, null);
-
-                }
-                try {
-                        Node kid, next;
-                        for (kid = fDocument.getFirstChild(); kid != null; kid = next) {
-                                next = kid.getNextSibling();
-                                kid = normalizeNode(kid);
-                                if (kid != null) { // don't advance
-                                        next = kid;
-                                }
-                        }
+                            -1, -1 ), fDocument.encoding, fNamespaceContext, null);
+            fValidationHandler.xmlDecl(fDocument.getXmlVersion(),
+                    fDocument.getXmlEncoding(), fDocument.getXmlStandalone() ? "yes" : "no", null);
+        }
+        try {
+            if (schemaType == XMLGrammarDescription.XML_DTD) {
+                processDTD(xmlVersion, schemaLocations != null ? schemaLocations[0] : null);
+            }
 
-                        // release resources
-                        if (fValidationHandler != null) {
-                                fValidationHandler.endDocument(null);
-                                CoreDOMImplementationImpl.singleton.releaseValidator(
-                                        XMLGrammarDescription.XML_SCHEMA, fValidationHandler);
-                                fValidationHandler = null;
-                        }
-                } catch (AbortException e) {
-                    return;
+            Node kid, next;
+            for (kid = fDocument.getFirstChild(); kid != null; kid = next) {
+                next = kid.getNextSibling();
+                kid = normalizeNode(kid);
+                if (kid != null) { // don't advance
+                    next = kid;
                 }
+            }
 
+            // release resources
+            if (fValidationHandler != null) {
+                fValidationHandler.endDocument(null);
+                fValidationHandler.setDocumentHandler(null);
+                CoreDOMImplementationImpl.singleton.releaseValidator(schemaType, xmlVersion, fValidationHandler);
+                fValidationHandler = null;
+            }
         }
-
+        catch (RuntimeException e) {
+            // release resources
+            if (fValidationHandler != null) {
+                fValidationHandler.setDocumentHandler(null);
+                CoreDOMImplementationImpl.singleton.releaseValidator(schemaType, xmlVersion, fValidationHandler);
+                fValidationHandler = null;
+            }
+            if (e instanceof AbortException) {
+                return; // processing aborted by the user
+            }
+            throw e; // otherwise re-throw.
+        }
+    }
 
     /**
      *
      * This method acts as if the document was going through a save
      * and load cycle, putting the document in a "normal" form. The actual result
@@ -271,20 +298,11 @@
         switch (type) {
         case Node.DOCUMENT_TYPE_NODE: {
                 if (DEBUG_ND) {
                     System.out.println("==>normalizeNode:{doctype}");
                 }
-                DocumentTypeImpl docType = (DocumentTypeImpl)node;
-                fDTDValidator = (XMLDTDValidator)CoreDOMImplementationImpl.singleton.getValidator(XMLGrammarDescription.XML_DTD);
-                fDTDValidator.setDocumentHandler(this);
-                fConfiguration.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY, createGrammarPool(docType));
-                fDTDValidator.reset(fConfiguration);
-                fDTDValidator.startDocument(
-                        new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,
-                            -1, -1 ), fDocument.encoding, fNamespaceContext, null);
-                fDTDValidator.doctypeDecl(docType.getName(), docType.getPublicId(), docType.getSystemId(), null);
-                //REVISIT: well-formness encoding info
+                // REVISIT: well-formedness encoding info
                 break;
             }
 
         case Node.ELEMENT_NODE: {
                 if (DEBUG_ND) {
@@ -295,11 +313,11 @@
                 //application has set the value of well-formed features to true
                 if (fDocument.errorChecking) {
                     if ( ((fConfiguration.features & DOMConfigurationImpl.WELLFORMED) != 0) &&
                             fDocument.isXMLVersionChanged()){
                         if (fNamespaceValidation){
-                            wellformed = CoreDocumentImpl.isValidQName(node.getPrefix() , node.getLocalName(), fDocument.isXML11Version()) ;
+                            wellformed = CoreDocumentImpl.isValidQName(node.getPrefix() , node.getLocalName(), fDocument.isXML11Version());
                         }
                         else {
                             wellformed = CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
                         }
                         if (!wellformed){
@@ -327,17 +345,25 @@
                     // fix namespaces
                     // normalize attribute values
                     // remove default attributes
                     namespaceFixUp(elem, attributes);
 
-                    if ((fConfiguration.features & DOMConfigurationImpl.NSDECL) == 0 && attributes != null ) {
-                        for (int i = 0; i < attributes.getLength(); ++i) {
-                            Attr att = (Attr)attributes.getItem(i);
-                            if (XMLSymbols.PREFIX_XMLNS.equals(att.getPrefix()) ||
-                                XMLSymbols.PREFIX_XMLNS.equals(att.getName())) {
-                                elem.removeAttributeNode(att);
-                                --i;
+                    if ((fConfiguration.features & DOMConfigurationImpl.NSDECL) == 0) {
+                        // Namespace declarations may have been added by namespace fix-up. Need
+                        // to fetch the AttributeMap again if it contained no attributes prior
+                        // to namespace fix-up.
+                        if (attributes == null) {
+                            attributes = (elem.hasAttributes()) ? (AttributeMap) elem.getAttributes() : null;
+                        }
+                        if (attributes != null) {
+                            for (int i = 0; i < attributes.getLength(); ++i) {
+                                Attr att = (Attr)attributes.getItem(i);
+                                if (XMLSymbols.PREFIX_XMLNS.equals(att.getPrefix()) ||
+                                        XMLSymbols.PREFIX_XMLNS.equals(att.getName())) {
+                                    elem.removeAttributeNode(att);
+                                    --i;
+                                }
                             }
                         }
                     }
 
                 } else {
@@ -345,20 +371,25 @@
                         for ( int i=0; i<attributes.getLength(); ++i ) {
                             Attr attr = (Attr)attributes.item(i);
                             //removeDefault(attr, attributes);
                             attr.normalize();
                             if (fDocument.errorChecking && ((fConfiguration.features & DOMConfigurationImpl.WELLFORMED) != 0)){
-                                    isAttrValueWF(fErrorHandler, fError, fLocator, attributes, (AttrImpl)attr, attr.getValue(), fDocument.isXML11Version());
-                                if (fDocument.isXMLVersionChanged()){
-                                    wellformed=CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
-                                    if (!wellformed){
-                                                            String msg = DOMMessageFormatter.formatMessage(
-                                                              DOMMessageFormatter.DOM_DOMAIN,
-                                                              "wf-invalid-character-in-node-name",
-                                                               new Object[]{"Attr",node.getNodeName()});
-                                                            reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
-                                                                "wf-invalid-character-in-node-name");
+                                    isAttrValueWF(fErrorHandler, fError, fLocator, attributes, attr, attr.getValue(), fDocument.isXML11Version());
+                                if (fDocument.isXMLVersionChanged()) {
+                                    if (fNamespaceValidation){
+                                        wellformed = CoreDocumentImpl.isValidQName(node.getPrefix(), node.getLocalName(), fDocument.isXML11Version());
+                                    }
+                                    else {
+                                        wellformed = CoreDocumentImpl.isXMLName(node.getNodeName(), fDocument.isXML11Version());
+                                    }
+                                    if (!wellformed) {
+                                        String msg = DOMMessageFormatter.formatMessage(
+                                          DOMMessageFormatter.DOM_DOMAIN,
+                                          "wf-invalid-character-in-node-name",
+                                           new Object[]{"Attr",node.getNodeName()});
+                                        reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
+                                            "wf-invalid-character-in-node-name");
                                     }
                                 }
                             }
                         }
                     }
@@ -377,30 +408,16 @@
                     fCurrentNode = node;
                     // call re-validation handler
                     fValidationHandler.startElement(fQName, fAttrProxy, null);
                 }
 
-                if (fDTDValidator != null) {
-                    // REVISIT: possible solutions to discard default content are:
-                    //         either we pass some flag to XML Schema validator
-                    //         or rely on the PSVI information.
-                    fAttrProxy.setAttributes(attributes, fDocument, elem);
-                    updateQName(elem, fQName); // updates global qname
-                    // set error node in the dom error wrapper
-                    // so if error occurs we can report an error node
-                    fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
-                    fCurrentNode = node;
-                    // call re-validation handler
-                    fDTDValidator.startElement(fQName, fAttrProxy, null);
-                }
-
                 // normalize children
                 Node kid, next;
                 for (kid = elem.getFirstChild(); kid != null; kid = next) {
                     next = kid.getNextSibling();
                     kid = normalizeNode(kid);
-                    if (kid !=null) {
+                    if (kid != null) {
                         next = kid;  // don't advance
                     }
                 }
                 if (DEBUG_ND) {
                     // normalized subtree
@@ -410,31 +427,20 @@
                         System.out.println(kid.getNodeName() +"["+kid.getNodeValue()+"]");
                     }
 
                 }
 
-
                 if (fValidationHandler != null) {
                     updateQName(elem, fQName); // updates global qname
                     //
                     // set error node in the dom error wrapper
                     // so if error occurs we can report an error node
                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
                     fCurrentNode = node;
                     fValidationHandler.endElement(fQName, null);
                 }
 
-                if (fDTDValidator != null) {
-                    updateQName(elem, fQName); // updates global qname
-                    //
-                    // set error node in the dom error wrapper
-                    // so if error occurs we can report an error node
-                    fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
-                    fCurrentNode = node;
-                    fDTDValidator.endElement(fQName, null);
-                }
-
                 // pop namespace context
                 fNamespaceContext.popContext();
 
                 break;
             }
@@ -463,10 +469,17 @@
                         String commentdata = ((Comment)node).getData();
                         // check comments for invalid xml chracter as per the version
                         // of the document
                         isCommentWF(fErrorHandler, fError, fLocator, commentdata, fDocument.isXML11Version());
                     }
+                    if (fValidationHandler != null) {
+                        // Don't bother filling an XMLString with the text of the comment.
+                        // We only send the comment event to the validator handler so that
+                        // when  the schema-type is DTD an error will be reported for a
+                        // comment appearing in EMPTY content.
+                        fValidationHandler.comment(EMPTY_STRING, null);
+                    }
                 }//end-else if comment node is not to be removed.
                                 break;
             }
         case Node.ENTITY_REFERENCE_NODE: {
                 if (DEBUG_ND) {
@@ -529,20 +542,10 @@
                     fCurrentNode = node;
                     fValidationHandler.startCDATA(null);
                     fValidationHandler.characterData(node.getNodeValue(), null);
                     fValidationHandler.endCDATA(null);
                 }
-
-                if (fDTDValidator != null) {
-                    // set error node in the dom error wrapper
-                    // so if error occurs we can report an error node
-                    fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
-                    fCurrentNode = node;
-                    fDTDValidator.startCDATA(null);
-                    fDTDValidator.characterData(node.getNodeValue(), null);
-                    fDTDValidator.endCDATA(null);
-                }
                 String value = node.getNodeValue();
 
                 if ((fConfiguration.features & DOMConfigurationImpl.SPLITCDATA) != 0) {
                     int index;
                     Node parent = node.getParentNode();
@@ -603,46 +606,41 @@
                     // 2. comments is false, and next child is comment
                     // 3. cdata is false, and next child is cdata
 
                     short nextType = (next != null)?next.getNodeType():-1;
                     if (nextType == -1 || !(((fConfiguration.features & DOMConfigurationImpl.ENTITIES) == 0 &&
-                           nextType == Node.ENTITY_NODE) ||
-                          ((fConfiguration.features & DOMConfigurationImpl.COMMENTS) == 0 &&
-                           nextType == Node.COMMENT_NODE) ||
-                          ((fConfiguration.features & DOMConfigurationImpl.CDATA) == 0) &&
-                          nextType == Node.CDATA_SECTION_NODE)) {
-                              if (fDocument.errorChecking && ((fConfiguration.features & DOMConfigurationImpl.WELLFORMED) != 0) ){
-                                  isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());
-                              }
-                              if (fValidationHandler != null) {
-                                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
-                                     fCurrentNode = node;
-                                     fValidationHandler.characterData(node.getNodeValue(), null);
-                                     if (DEBUG_ND) {
-                                         System.out.println("=====>characterData(),"+nextType);
-
-                                     }
-                              }
-                              if (fDTDValidator != null) {
-                                  fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
-                                  fCurrentNode = node;
-                                  fDTDValidator.characterData(node.getNodeValue(), null);
-                                  if (DEBUG_ND) {
-                                      System.out.println("=====>characterData(),"+nextType);
-
-                                  }
-                                  if(allWhitespace) {
-                                      allWhitespace = false;
-                                      ((TextImpl)node).setIgnorableWhitespace(true);
-                                  }
-                              }
+                            nextType == Node.ENTITY_NODE) ||
+                            ((fConfiguration.features & DOMConfigurationImpl.COMMENTS) == 0 &&
+                                    nextType == Node.COMMENT_NODE) ||
+                                    ((fConfiguration.features & DOMConfigurationImpl.CDATA) == 0) &&
+                                    nextType == Node.CDATA_SECTION_NODE)) {
+                        if (fDocument.errorChecking && ((fConfiguration.features & DOMConfigurationImpl.WELLFORMED) != 0) ){
+                            isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());
+                        }
+                        if (fValidationHandler != null) {
+                            fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
+                            fCurrentNode = node;
+                            fValidationHandler.characterData(node.getNodeValue(), null);
+                            if (!fNamespaceValidation) {
+                                if (fAllWhitespace) {
+                                    fAllWhitespace = false;
+                                    ((TextImpl)node).setIgnorableWhitespace(true);
+                                }
+                                else {
+                                    ((TextImpl)node).setIgnorableWhitespace(false);
+                                }
+                            }
+                            if (DEBUG_ND) {
+                                System.out.println("=====>characterData(),"+nextType);
+                            }
+                        }
                     }
                     else {
-                            if (DEBUG_ND) {
-                                System.out.println("=====>don't send characters(),"+nextType);
+                        if (DEBUG_ND) {
+                            System.out.println("=====>don't send characters(),"+nextType);
 
-                            }
+                        }
                     }
                 }
                 break;
             }
         case Node.PROCESSING_INSTRUCTION_NODE: {
@@ -672,46 +670,70 @@
                 //2. check PI data
                 //processing isntruction data may have certain characters
                 //which may not be valid XML character
                 isXMLCharWF(fErrorHandler, fError, fLocator, pinode.getData(), fDocument.isXML11Version());
             }
+
+            if (fValidationHandler != null) {
+                // Don't bother filling an XMLString with the data section of the
+                // processing instruction. We only send the processing instruction
+                // event to the validator handler so that when the schema-type is
+                // DTD an error will be reported for a processing instruction
+                // appearing in EMPTY content.
+                fValidationHandler.processingInstruction(((ProcessingInstruction) node).getTarget(), EMPTY_STRING, null);
+            }
         }//end case Node.PROCESSING_INSTRUCTION_NODE
 
         }//end of switch
         return null;
     }//normalizeNode
 
-    private XMLGrammarPool createGrammarPool(DocumentTypeImpl docType) {
-
-        XMLGrammarPoolImpl pool = new XMLGrammarPoolImpl();
+    private void processDTD(String xmlVersion, String schemaLocation) {
 
-        XMLGrammarPreparser preParser = new XMLGrammarPreparser(fSymbolTable);
-        preParser.registerPreparser(XMLGrammarDescription.XML_DTD, null);
-        preParser.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE, true);
-        preParser.setFeature(Constants.XERCES_FEATURE_PREFIX + Constants.VALIDATION_FEATURE, true);
-        preParser.setProperty(Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY, pool);
+        String rootName = null;
+        String publicId = null;
+        String systemId = schemaLocation;
+        String baseSystemId = fDocument.getDocumentURI();
+        String internalSubset = null;
 
-        String internalSubset = docType.getInternalSubset();
-        XMLInputSource is = new XMLInputSource(docType.getPublicId(), docType.getSystemId(), null, false);
+        DocumentType docType = fDocument.getDoctype();
+        if (docType != null) {
+            rootName = docType.getName();
+            publicId = docType.getPublicId();
+            if (systemId == null || systemId.length() == 0) {
+                systemId = docType.getSystemId();
+            }
+            internalSubset = docType.getInternalSubset();
+        }
+        // If the DOM doesn't have a DocumentType node we may still
+        // be able to fetch a DTD if the application provided a URI
+        else {
+            Element elem = fDocument.getDocumentElement();
+            if (elem == null) return;
+            rootName = elem.getNodeName();
+            if (systemId == null || systemId.length() == 0) return;
+        }
 
-        if(internalSubset != null)
-            is.setCharacterStream(new StringReader(internalSubset));
+        XMLDTDLoader loader = null;
         try {
-            DTDGrammar g = (DTDGrammar)preParser.preparseGrammar(XMLGrammarDescription.XML_DTD, is);
-            ((XMLDTDDescription)g.getGrammarDescription()).setRootName(docType.getName());
-            is.setCharacterStream(null);
-            g = (DTDGrammar)preParser.preparseGrammar(XMLGrammarDescription.XML_DTD, is);
-            ((XMLDTDDescription)g.getGrammarDescription()).setRootName(docType.getName());
-
-        } catch (XNIException e) {
-        } catch (IOException e) {
+            fValidationHandler.doctypeDecl(rootName, publicId, systemId, null);
+            loader = CoreDOMImplementationImpl.singleton.getDTDLoader(xmlVersion);
+            loader.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);
+            loader.setEntityResolver(fConfiguration.getEntityResolver());
+            loader.setErrorHandler(fConfiguration.getErrorHandler());
+            loader.loadGrammarWithContext((XMLDTDValidator) fValidationHandler, rootName,
+                    publicId, systemId, baseSystemId, internalSubset);
         }
-
-        return pool;
-    }
-
-
+        // REVISIT: Should probably report this exception to the error handler.
+        catch (IOException e) {
+        }
+        finally {
+            if (loader != null) {
+                CoreDOMImplementationImpl.singleton.releaseDTDLoader(xmlVersion, loader);
+            }
+        }
+    } // processDTD(String, String)
 
     protected final void expandEntityRef (Node parent, Node reference){
         Node kid, next;
         for (kid = reference.getFirstChild(); kid != null; kid = next) {
             next = kid.getNextSibling();
@@ -738,34 +760,19 @@
         //    -->
         //   <xsl:body xmlns:xsl="http://bound"/>
         //
         // ------------------------------------
 
-        String value, name, uri, prefix;
+        String value, uri, prefix;
         if (attributes != null) {
 
             // Record all valid local declarations
             for (int k = 0; k < attributes.getLength(); ++k) {
                 Attr attr = (Attr)attributes.getItem(k);
-
-                //do the name check only when version of the document was changed &
-                //application has set the value of well-formed features to true
-                if (fDocument.errorChecking && ((fConfiguration.features & DOMConfigurationImpl.WELLFORMED) != 0) &&
-                    fDocument.isXMLVersionChanged()) {
-                    //checkQName does checking based on the version of the document
-                    fDocument.checkQName(attr.getPrefix() , attr.getLocalName()) ;
-                }
-
                 uri = attr.getNamespaceURI();
                 if (uri != null && uri.equals(NamespaceContext.XMLNS_URI)) {
                     // namespace attribute
-
-                    // "namespace-declarations" == false; Discard all namespace declaration attributes
-                    if ((fConfiguration.features & DOMConfigurationImpl.NSDECL) == 0) {
-                        continue;
-                    }
-
                     value = attr.getNodeValue();
                     if (value == null) {
                         value=XMLSymbols.EMPTY_STRING;
                     }
 
@@ -796,11 +803,11 @@
                             //removeDefault (attr, attributes);
                             continue;
                         } else { // (localpart == fXmlnsSymbol && prefix == fEmptySymbol)  -- xmlns
                             // empty prefix is always bound ("" or some string)
                             value = fSymbolTable.addSymbol(value);
-                            fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, value);
+                            fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, value.length() != 0 ? value : null);
                             //removeDefault (attr, attributes);
                             continue;
                         }
                     }  // end-else: valid declaration
                 } // end-if: namespace attribute
@@ -824,16 +831,11 @@
         // check if prefix/namespace is correct for current element
         // ---------------------------------------------------------
 
         uri = element.getNamespaceURI();
         prefix = element.getPrefix();
-
-        // "namespace-declarations" == false? Discard all namespace declaration attributes
-        if ((fConfiguration.features & DOMConfigurationImpl.NSDECL) == 0) {
-            // no namespace declaration == no namespace URI, semantics are to keep prefix
-            uri = null;
-        } else if (uri != null) {  // Element has a namespace
+        if (uri != null) {  // Element has a namespace
             uri = fSymbolTable.addSymbol(uri);
             prefix = (prefix == null ||
                       prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
             if (fNamespaceContext.getURI(prefix) == uri) {
                 // The xmlns:prefix=namespace or xmlns="default" was declared at parent.
@@ -868,12 +870,12 @@
                 uri = fNamespaceContext.getURI(XMLSymbols.EMPTY_STRING);
                 if (uri !=null && uri.length() > 0) {
                     // undeclare default namespace declaration (before that element
                     // bound to non-zero length uir), but adding xmlns="" decl
                     addNamespaceDecl (XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING, element);
-                    fLocalNSBinder.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);
-                    fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING);
+                    fLocalNSBinder.declarePrefix(XMLSymbols.EMPTY_STRING, null);
+                    fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, null);
                 }
             }
         }
 
         // -----------------------------------------
@@ -892,16 +894,39 @@
                     System.out.println("==>[ns-fixup] process attribute: "+attr.getNodeName());
                 }
                 // normalize attribute value
                 attr.normalize();
                 value = attr.getValue();
-                name = attr.getNodeName();
                 uri = attr.getNamespaceURI();
 
                 // make sure that value is never null.
                 if (value == null) {
-                    value=XMLSymbols.EMPTY_STRING;
+                    value = XMLSymbols.EMPTY_STRING;
+                }
+
+                //---------------------------------------
+                // check if value of the attribute is namespace well-formed
+                //---------------------------------------
+                if (fDocument.errorChecking && ((fConfiguration.features & DOMConfigurationImpl.WELLFORMED) != 0)) {
+                    isAttrValueWF(fErrorHandler, fError, fLocator, attributes, attr, value, fDocument.isXML11Version());
+                    if (fDocument.isXMLVersionChanged()) {
+                        boolean wellformed;
+                        if (fNamespaceValidation){
+                            wellformed = CoreDocumentImpl.isValidQName(attr.getPrefix(), attr.getLocalName(), fDocument.isXML11Version());
+                        }
+                        else {
+                            wellformed = CoreDocumentImpl.isXMLName(attr.getNodeName(), fDocument.isXML11Version());
+                        }
+                        if (!wellformed) {
+                            String msg = DOMMessageFormatter.formatMessage(
+                                    DOMMessageFormatter.DOM_DOMAIN,
+                                    "wf-invalid-character-in-node-name",
+                                    new Object[]{"Attr", attr.getNodeName()});
+                            reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
+                            "wf-invalid-character-in-node-name");
+                        }
+                    }
                 }
 
                 if (uri != null) {  // attribute has namespace !=null
                     prefix = attr.getPrefix();
                     prefix = (prefix == null ||
@@ -914,27 +939,10 @@
                     // REVISIT: can we assume that "uri" is from some symbol
                     // table, and compare by reference? -SG
                     if (uri != null && uri.equals(NamespaceContext.XMLNS_URI)) {
                         continue;
                     }
-                    //---------------------------------------
-                    // check if value of the attribute is namespace well-formed
-                    //---------------------------------------
-                    if (fDocument.errorChecking && ((fConfiguration.features & DOMConfigurationImpl.WELLFORMED) != 0)) {
-                            isAttrValueWF(fErrorHandler, fError, fLocator, attributes, (AttrImpl)attr, attr.getValue(), fDocument.isXML11Version());
-                            if (fDocument.isXMLVersionChanged()){
-                                boolean wellformed=CoreDocumentImpl.isXMLName(attr.getNodeName() , fDocument.isXML11Version());
-                                if (!wellformed){
-                                                        String msg = DOMMessageFormatter.formatMessage(
-                                                            DOMMessageFormatter.DOM_DOMAIN,
-                                                            "wf-invalid-character-in-node-name",
-                                                            new Object[]{"Attribute", attr.getNodeName()});
-                                        reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
-                                            "wf-invalid-character-in-node-name");
-                                }
-                        }
-                    }
 
                     // ---------------------------------------
                     // remove default attributes
                     // ---------------------------------------
                     /*
@@ -946,11 +954,10 @@
                     //value = normalizeAttributeValue(value, attr);
 
                     // reset id-attributes
                     ((AttrImpl)attr).setIdAttribute(false);
 
-
                     uri = fSymbolTable.addSymbol(uri);
 
                     // find if for this prefix a URI was already declared
                     String declaredURI =  fNamespaceContext.getURI(prefix);
 
@@ -960,11 +967,10 @@
                         // attribute prefix is not declared
                         // OR
                         // conflict: attribute has a prefix that conficlicts with a binding
                         //           already active in scope
 
-                        name  = attr.getNodeName();
                         // Find if any prefix for attributes namespace URI is available
                         // in the scope
                         String declaredPrefix = fNamespaceContext.getPrefix(uri);
                         if (declaredPrefix !=null && declaredPrefix !=XMLSymbols.EMPTY_STRING) {
 
@@ -1445,64 +1451,67 @@
     implements XMLAttributes {
         protected AttributeMap fAttributes;
         protected CoreDocumentImpl fDocument;
         protected ElementImpl fElement;
 
-        protected final Vector<Augmentations> fAugmentations = new Vector<>(5);
-
+        protected Vector<String> fDTDTypes = new Vector<>(5);
+        protected Vector<Augmentations> fAugmentations = new Vector<>(5);
 
         public void setAttributes(AttributeMap attributes, CoreDocumentImpl doc, ElementImpl elem) {
             fDocument = doc;
             fAttributes = attributes;
             fElement = elem;
             if (attributes != null) {
                 int length = attributes.getLength();
-
+                fDTDTypes.setSize(length);
                 fAugmentations.setSize(length);
                 // REVISIT: this implementation does not store any value in augmentations
                 //          and basically not keeping augs in parallel to attributes map
                 //          untill all attributes are added (default attributes)
                 for (int i = 0; i < length; i++) {
                     fAugmentations.setElementAt(new AugmentationsImpl(), i);
                 }
-            } else {
+            }
+            else {
+                fDTDTypes.setSize(0);
                 fAugmentations.setSize(0);
             }
         }
 
 
-                /**
+        /**
          * This method adds default declarations
                  * @see com.sun.org.apache.xerces.internal.xni.XMLAttributes#addAttribute(QName, String, String)
-                 */
-                public int addAttribute(QName qname, String attrType, String attrValue) {
-                        int index = fElement.getXercesAttribute(qname.uri, qname.localpart);
-                        // add defaults to the tree
-                        if (index < 0) {
+         */
+        public int addAttribute(QName qname, String attrType, String attrValue) {
+            int index = fElement.getXercesAttribute(qname.uri, qname.localpart);
+            // add defaults to the tree
+            if (index < 0) {
                 // the default attribute was removed by a user and needed to
                 // be added back
-                                AttrImpl attr = (AttrImpl)
-                                        ((CoreDocumentImpl) fElement.getOwnerDocument()).createAttributeNS(
-                                                qname.uri,
-                                                qname.rawname,
-                                                qname.localpart);
+                AttrImpl attr = (AttrImpl)
+                    ((CoreDocumentImpl) fElement.getOwnerDocument()).createAttributeNS(
+                        qname.uri,
+                        qname.rawname,
+                        qname.localpart);
                 // REVISIT: the following should also update ID table
                 attr.setNodeValue(attrValue);
                 index = fElement.setXercesAttributeNode(attr);
+                fDTDTypes.insertElementAt(attrType, index);
                 fAugmentations.insertElementAt(new AugmentationsImpl(), index);
                 attr.setSpecified(false);
-                        }
-                        else {
+            }
+            else {
                 // default attribute is in the tree
                 // we don't need to do anything since prefix was already fixed
                 // at the namespace fixup time and value must be same value, otherwise
                 // attribute will be treated as specified and we will never reach
                 // this method.
 
             }
             return index;
-                }
+        }
 
 
         public void removeAllAttributes(){
             // REVISIT: implement
         }
@@ -1521,74 +1530,95 @@
         public int getIndex(String qName){
             // REVISIT: implement
             return -1;
         }
 
-        public int getIndex(String uri, String localPart){
+        public int getIndex(String uri, String localPart) {
             // REVISIT: implement
             return -1;
         }
 
-        public void setName(int attrIndex, QName attrName){
+        public void setName(int attrIndex, QName attrName) {
             // REVISIT: implement
         }
 
-        public void getName(int attrIndex, QName attrName){
-            if (fAttributes !=null) {
+        public void getName(int attrIndex, QName attrName) {
+            if (fAttributes != null) {
                 updateQName((Node)fAttributes.getItem(attrIndex), attrName);
             }
         }
 
-        public String getPrefix(int index){
-            // REVISIT: implement
+        public String getPrefix(int index) {
+            if (fAttributes != null) {
+                Node node = (Node) fAttributes.getItem(index);
+                String prefix = node.getPrefix();
+                prefix = (prefix != null && prefix.length() != 0) ? fSymbolTable.addSymbol(prefix) : null;
+                return prefix;
+            }
             return null;
         }
 
-
-        public String getURI(int index){
-            // REVISIT: implement
+        public String getURI(int index) {
+            if (fAttributes != null) {
+                Node node = (Node) fAttributes.getItem(index);
+                String namespace = node.getNamespaceURI();
+                namespace = (namespace != null) ? fSymbolTable.addSymbol(namespace) : null;
+                return namespace;
+            }
             return null;
         }
 
 
-        public String getLocalName(int index){
-            // REVISIT: implement
+        public String getLocalName(int index) {
+            if (fAttributes != null) {
+                Node node = (Node) fAttributes.getItem(index);
+                String localName = node.getLocalName();
+                localName = (localName != null) ? fSymbolTable.addSymbol(localName) : null;
+                return localName;
+            }
             return null;
         }
 
-
-        public String getQName(int index){
-            // REVISIT: implement
+        public String getQName(int index) {
+            if (fAttributes != null) {
+                Node node = (Node) fAttributes.getItem(index);
+                String rawname = fSymbolTable.addSymbol(node.getNodeName());
+                return rawname;
+            }
             return null;
         }
 
          public QName getQualifiedName(int index){
             //return fAttributes.item(index).ge);
             return null;
         }
 
-        public void setType(int attrIndex, String attrType){
-            // REVISIT: implement
+        public void setType(int attrIndex, String attrType) {
+            fDTDTypes.setElementAt(attrType, attrIndex);
         }
 
-
-        public String getType(int index){
-            return "CDATA";
+        public String getType(int index) {
+            String type = fDTDTypes.elementAt(index);
+            return (type != null) ? getReportableType(type) : "CDATA";
         }
 
-
-        public String getType(String qName){
+        public String getType(String qName) {
             return "CDATA";
         }
 
-
-        public String getType(String uri, String localName){
+        public String getType(String uri, String localName) {
             return "CDATA";
         }
 
+        private String getReportableType(String type) {
+            if (type.charAt(0) == '(') {
+                return "NMTOKEN";
+            }
+            return type;
+        }
 
-        public void setValue(int attrIndex, String attrValue){
+        public void setValue(int attrIndex, String attrValue) {
             // REVISIT: is this desired behaviour?
             // The values are updated in the case datatype-normalization is turned on
             // in this case we need to make sure that specified attributes stay specified
 
             if (fAttributes != null){
@@ -1607,38 +1637,33 @@
         public String getValue(int index){
             return (fAttributes !=null)?fAttributes.item(index).getNodeValue():"";
 
         }
 
-
         public String getValue(String qName){
             // REVISIT: implement
             return null;
         }
 
-
         public String getValue(String uri, String localName){
             if (fAttributes != null) {
                 Node node =  fAttributes.getNamedItemNS(uri, localName);
                 return(node != null)? node.getNodeValue():null;
             }
             return null;
         }
 
-
         public void setNonNormalizedValue(int attrIndex, String attrValue){
             // REVISIT: implement
 
         }
 
-
         public String getNonNormalizedValue(int attrIndex){
             // REVISIT: implement
             return null;
         }
 
-
         public void setSpecified(int attrIndex, boolean specified){
             AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
             attr.setSpecified(specified);
         }
 
@@ -1786,62 +1811,89 @@
      * @param augs       Additional information that may include infoset augmentations
      *
      * @exception XNIException
      *                   Thrown by handler to signal an error.
      */
-        public void startElement(QName element, XMLAttributes attributes, Augmentations augs)
-                throws XNIException {
-                Element currentElement = (Element) fCurrentNode;
-                int attrCount = attributes.getLength();
+    public void startElement(QName element, XMLAttributes attributes, Augmentations augs)
+        throws XNIException {
+        Element currentElement = (Element) fCurrentNode;
+        int attrCount = attributes.getLength();
         if (DEBUG_EVENTS) {
             System.out.println("==>startElement: " +element+
-            " attrs.length="+attrCount);
+                    " attrs.length="+attrCount);
         }
 
-                for (int i = 0; i < attrCount; i++) {
-                        attributes.getName(i, fAttrQName);
-                        Attr attr = null;
+        for (int i = 0; i < attrCount; i++) {
+            attributes.getName(i, fAttrQName);
+            Attr attr = null;
 
-                        attr = currentElement.getAttributeNodeNS(fAttrQName.uri, fAttrQName.localpart);
+            attr = currentElement.getAttributeNodeNS(fAttrQName.uri, fAttrQName.localpart);
+            if (attr == null) {
+                // Must be a non-namespace aware DOM Level 1 node.
+                attr = currentElement.getAttributeNode(fAttrQName.rawname);
+            }
             AttributePSVI attrPSVI =
-                                (AttributePSVI) attributes.getAugmentations(i).getItem(Constants.ATTRIBUTE_PSVI);
+                (AttributePSVI) attributes.getAugmentations(i).getItem(Constants.ATTRIBUTE_PSVI);
 
-                        if (attrPSVI != null) {
+            if (attrPSVI != null) {
                 //REVISIT: instead we should be using augmentations:
                 // to set/retrieve Id attributes
                 XSTypeDefinition decl = attrPSVI.getMemberTypeDefinition();
                 boolean id = false;
-                if (decl != null){
+                if (decl != null) {
                     id = ((XSSimpleType)decl).isIDType();
-                } else{
+                }
+                else {
                     decl = attrPSVI.getTypeDefinition();
-                    if (decl !=null){
-                       id = ((XSSimpleType)decl).isIDType();
+                    if (decl != null) {
+                        id = ((XSSimpleType)decl).isIDType();
                     }
                 }
-                if (id){
+                if (id) {
                     ((ElementImpl)currentElement).setIdAttributeNode(attr, true);
                 }
 
-                                if (fPSVI) {
-                                        ((PSVIAttrNSImpl) attr).setPSVI(attrPSVI);
-                                }
-                                if ((fConfiguration.features & DOMConfigurationImpl.DTNORMALIZATION) != 0) {
-                                        // datatype-normalization
-                                        // NOTE: The specified value MUST be set after we set
-                                        //       the node value because that turns the "specified"
-                                        //       flag to "true" which may overwrite a "false"
-                                        //       value from the attribute list.
-                                        boolean specified = attr.getSpecified();
-                                        attr.setValue(attrPSVI.getSchemaValue().getNormalizedValue());
-                                        if (!specified) {
-                                                ((AttrImpl) attr).setSpecified(specified);
-                                        }
-                                }
+                if (fPSVI) {
+                    ((PSVIAttrNSImpl) attr).setPSVI(attrPSVI);
+                }
+
+                // Updating the TypeInfo for this attribute.
+                ((AttrImpl) attr).setType(decl);
+
+                if ((fConfiguration.features & DOMConfigurationImpl.DTNORMALIZATION) != 0) {
+                    // datatype-normalization
+                    // NOTE: The specified value MUST be set after we set
+                    //       the node value because that turns the "specified"
+                    //       flag to "true" which may overwrite a "false"
+                    //       value from the attribute list.
+                    final String normalizedValue = attrPSVI.getSchemaValue().getNormalizedValue();
+                    if (normalizedValue != null) {
+                        boolean specified = attr.getSpecified();
+                        attr.setValue(normalizedValue);
+                        if (!specified) {
+                            ((AttrImpl) attr).setSpecified(specified);
                         }
+                    }
+                }
+            }
+            else { // DTD
+                String type = null;
+                boolean isDeclared = Boolean.TRUE.equals(attributes.getAugmentations(i).getItem (Constants.ATTRIBUTE_DECLARED));
+                // For DOM Level 3 TypeInfo, the type name must
+                // be null if this attribute has not been declared
+                // in the DTD.
+                if (isDeclared) {
+                    type = attributes.getType(i);
+                    if ("ID".equals (type)) {
+                        ((ElementImpl) currentElement).setIdAttributeNode(attr, true);
+                    }
                 }
+                // Updating the TypeInfo for this attribute.
+                ((AttrImpl) attr).setType(type);
+            }
         }
+    }
 
 
     /**
      * An empty element.
      *
@@ -1946,11 +1998,11 @@
      *
      * @exception XNIException
      *                   Thrown by handler to signal an error.
      */
     public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException{
-        allWhitespace = true;
+        fAllWhitespace = true;
     }
 
     /**
      * The end of an element.
      *
@@ -1958,42 +2010,55 @@
      * @param augs    Additional information that may include infoset augmentations
      *
      * @exception XNIException
      *                   Thrown by handler to signal an error.
      */
-        public void endElement(QName element, Augmentations augs) throws XNIException {
-                if (DEBUG_EVENTS) {
-                        System.out.println("==>endElement: " + element);
-                }
+    public void endElement(QName element, Augmentations augs) throws XNIException {
+        if (DEBUG_EVENTS) {
+            System.out.println("==>endElement: " + element);
+        }
 
-        if(augs != null) {
-                ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);
-                if (elementPSVI != null) {
-                        ElementImpl elementNode = (ElementImpl) fCurrentNode;
-                        if (fPSVI) {
-                                ((PSVIElementNSImpl) fCurrentNode).setPSVI(elementPSVI);
-                        }
-                        // include element default content (if one is available)
-                        String normalizedValue = elementPSVI.getSchemaValue().getNormalizedValue();
-                        if ((fConfiguration.features & DOMConfigurationImpl.DTNORMALIZATION) != 0) {
+        if (augs != null) {
+            ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);
+            if (elementPSVI != null) {
+                ElementImpl elementNode = (ElementImpl) fCurrentNode;
+                if (fPSVI) {
+                    ((PSVIElementNSImpl) fCurrentNode).setPSVI(elementPSVI);
+                }
+                // Updating the TypeInfo for this element.
+                if (elementNode instanceof ElementNSImpl) {
+                    XSTypeDefinition type = elementPSVI.getMemberTypeDefinition();
+                    if (type == null) {
+                        type = elementPSVI.getTypeDefinition();
+                    }
+                    ((ElementNSImpl) elementNode).setType(type);
+                }
+                // include element default content (if one is available)
+                String normalizedValue = elementPSVI.getSchemaValue().getNormalizedValue();
+                if ((fConfiguration.features & DOMConfigurationImpl.DTNORMALIZATION) != 0) {
                     if (normalizedValue !=null)
-                                    elementNode.setTextContent(normalizedValue);
-                        }
-                        else {
-                                // NOTE: this is a hack: it is possible that DOM had an empty element
-                                // and validator sent default value using characters(), which we don't
-                                // implement. Thus, here we attempt to add the default value.
-                                String text = elementNode.getTextContent();
-                                if (text.length() == 0) {
-                                        // default content could be provided
+                        elementNode.setTextContent(normalizedValue);
+                }
+                else {
+                    // NOTE: this is a hack: it is possible that DOM had an empty element
+                    // and validator sent default value using characters(), which we don't
+                    // implement. Thus, here we attempt to add the default value.
+                    String text = elementNode.getTextContent();
+                    if (text.length() == 0) {
+                        // default content could be provided
                         if (normalizedValue !=null)
                             elementNode.setTextContent(normalizedValue);
-                                }
-                        }
+                    }
                 }
+                return;
+            }
         }
+        // DTD; elements have no type.
+        if (fCurrentNode instanceof ElementNSImpl) {
+            ((ElementNSImpl) fCurrentNode).setType(null);
         }
+    }
 
 
     /**
      * The start of a CDATA section.
      *

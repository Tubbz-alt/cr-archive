<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/FieldGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FSUB.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FieldGenOrMethodGen.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/FieldGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;

 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 27 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 28 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 29 import com.sun.org.apache.bcel.internal.classfile.Constant;
 30 import com.sun.org.apache.bcel.internal.classfile.ConstantObject;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantValue;
 33 import com.sun.org.apache.bcel.internal.classfile.Field;
 34 import com.sun.org.apache.bcel.internal.classfile.Utility;
 35 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 36 
 37 /**
<span class="line-modified"> 38  * Template class for building up a field. The only extraordinary thing one can</span>
<span class="line-modified"> 39  * do is to add a constant value attribute to a field (which must of course be</span>
<span class="line-modified"> 40  * compatible with to the declared type).</span>
 41  *
<span class="line-removed"> 42  * @version $Id: FieldGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 43  * @see Field

 44  */
 45 public class FieldGen extends FieldGenOrMethodGen {
 46 
 47     private Object value = null;
 48     private static BCELComparator bcelComparator = new BCELComparator() {
 49 
 50         @Override
<span class="line-modified"> 51         public boolean equals(final Object o1, final Object o2) {</span>
 52             final FieldGen THIS = (FieldGen) o1;
 53             final FieldGen THAT = (FieldGen) o2;
<span class="line-modified"> 54             return THIS.getName().equals(THAT.getName())</span>
<span class="line-modified"> 55                     &amp;&amp; THIS.getSignature().equals(THAT.getSignature());</span>
 56         }
 57 

 58         @Override
<span class="line-modified"> 59         public int hashCode(final Object o) {</span>
 60             final FieldGen THIS = (FieldGen) o;
 61             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
 62         }
 63     };
 64 

 65     /**
<span class="line-modified"> 66      * Declare a field. If it is static (isStatic() == true) and has a basic</span>
<span class="line-modified"> 67      * type like int or String it may have an initial value associated with it</span>
<span class="line-modified"> 68      * as defined by setInitValue().</span>
 69      *
 70      * @param access_flags access qualifiers
<span class="line-modified"> 71      * @param type field type</span>
 72      * @param name field name
 73      * @param cp constant pool
 74      */
 75     public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {
 76         super(access_flags);
 77         setType(type);
 78         setName(name);
 79         setConstantPool(cp);
 80     }
 81 

 82     /**
 83      * Instantiate from existing field.
 84      *
 85      * @param field Field object
<span class="line-modified"> 86      * @param cp constant pool (must contain the same entries as the field&#39;s</span>
<span class="line-removed"> 87      * constant pool)</span>
 88      */
 89     public FieldGen(final Field field, final ConstantPoolGen cp) {
 90         this(field.getAccessFlags(), Type.getType(field.getSignature()), field.getName(), cp);
 91         final Attribute[] attrs = field.getAttributes();
 92         for (final Attribute attr : attrs) {
 93             if (attr instanceof ConstantValue) {
 94                 setValue(((ConstantValue) attr).getConstantValueIndex());
 95             } else if (attr instanceof Annotations) {
<span class="line-modified"> 96                 final Annotations runtimeAnnotations = (Annotations) attr;</span>
 97                 final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();
 98                 for (final AnnotationEntry element : annotationEntries) {
<span class="line-modified"> 99                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));</span>
100                 }
101             } else {
102                 addAttribute(attr);
103             }
104         }
105     }
106 
<span class="line-modified">107     private void setValue(final int index) {</span>

108         final ConstantPool cp = super.getConstantPool().getConstantPool();
109         final Constant c = cp.getConstant(index);
110         value = ((ConstantObject) c).getConstantValue(cp);
111     }
112 

113     /**
<span class="line-modified">114      * Set (optional) initial value of field, otherwise it will be set to</span>
<span class="line-modified">115      * null/0/false by the JVM automatically.</span>
116      */
<span class="line-modified">117     public void setInitValue(final String str) {</span>
<span class="line-modified">118         checkType(ObjectType.getInstance(&quot;java.lang.String&quot;));</span>
119         if (str != null) {
120             value = str;
121         }
122     }
123 
<span class="line-modified">124     public void setInitValue(final long l) {</span>

125         checkType(Type.LONG);
126         if (l != 0L) {
<span class="line-modified">127             value = l;</span>
128         }
129     }
130 
<span class="line-modified">131     public void setInitValue(final int i) {</span>

132         checkType(Type.INT);
133         if (i != 0) {
<span class="line-modified">134             value = i;</span>
135         }
136     }
137 
<span class="line-modified">138     public void setInitValue(final short s) {</span>

139         checkType(Type.SHORT);
140         if (s != 0) {
<span class="line-modified">141             value = (int) s;</span>
142         }
143     }
144 
<span class="line-modified">145     public void setInitValue(final char c) {</span>

146         checkType(Type.CHAR);
147         if (c != 0) {
<span class="line-modified">148             value = (int) c;</span>
149         }
150     }
151 
<span class="line-modified">152     public void setInitValue(final byte b) {</span>

153         checkType(Type.BYTE);
154         if (b != 0) {
<span class="line-modified">155             value = (int) b;</span>
156         }
157     }
158 
<span class="line-modified">159     public void setInitValue(final boolean b) {</span>

160         checkType(Type.BOOLEAN);
161         if (b) {
<span class="line-modified">162             value = 1;</span>
163         }
164     }
165 
<span class="line-modified">166     public void setInitValue(final float f) {</span>

167         checkType(Type.FLOAT);
168         if (f != 0.0) {
169             value = f;
170         }
171     }
172 
<span class="line-modified">173     public void setInitValue(final double d) {</span>

174         checkType(Type.DOUBLE);
175         if (d != 0.0) {
176             value = d;
177         }
178     }
179 
<span class="line-modified">180     /**</span>
<span class="line-modified">181      * Remove any initial value.</span>
182      */
183     public void cancelInitValue() {
184         value = null;
185     }
186 
<span class="line-modified">187     private void checkType(final Type atype) {</span>

188         final Type superType = super.getType();
189         if (superType == null) {
190             throw new ClassGenException(&quot;You haven&#39;t defined the type of the field yet&quot;);
191         }
192         if (!isFinal()) {
193             throw new ClassGenException(&quot;Only final fields may have an initial value!&quot;);
194         }
195         if (!superType.equals(atype)) {
196             throw new ClassGenException(&quot;Types are not compatible: &quot; + superType + &quot; vs. &quot; + atype);
197         }
198     }
199 

200     /**
201      * Get field object after having set up all necessary values.
202      */
203     public Field getField() {
204         final String signature = getSignature();
205         final int name_index = super.getConstantPool().addUtf8(super.getName());
206         final int signature_index = super.getConstantPool().addUtf8(signature);
207         if (value != null) {
208             checkType(super.getType());
209             final int index = addConstant();
210             addAttribute(new ConstantValue(super.getConstantPool().addUtf8(&quot;ConstantValue&quot;), 2, index,
211                     super.getConstantPool().getConstantPool())); // sic
212         }
213         addAnnotationsAsAttribute(super.getConstantPool());
214         return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),
215                 super.getConstantPool().getConstantPool()); // sic
216     }
217 
218     private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified">219         final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
220         for (final Attribute attr : attrs) {
221             addAttribute(attr);
222         }
<span class="line-modified">223     }</span>

224 
225     private int addConstant() {
226         switch (super.getType().getType()) { // sic
227             case Const.T_INT:
228             case Const.T_CHAR:
229             case Const.T_BYTE:
230             case Const.T_BOOLEAN:
231             case Const.T_SHORT:
232                 return super.getConstantPool().addInteger(((Integer) value));
233             case Const.T_FLOAT:
234                 return super.getConstantPool().addFloat(((Float) value));
235             case Const.T_DOUBLE:
236                 return super.getConstantPool().addDouble(((Double) value));
237             case Const.T_LONG:
238                 return super.getConstantPool().addLong(((Long) value));
239             case Const.T_REFERENCE:
240                 return super.getConstantPool().addString((String) value);
241             default:
242                 throw new RuntimeException(&quot;Oops: Unhandled : &quot; + super.getType().getType()); // sic
243         }
244     }
245 

246     @Override
247     public String getSignature() {
248         return super.getType().getSignature();
249     }
250 
251     private List&lt;FieldObserver&gt; observers;
252 
<span class="line-modified">253     /**</span>
<span class="line-modified">254      * Add observer for this object.</span>
255      */
<span class="line-modified">256     public void addObserver(final FieldObserver o) {</span>
257         if (observers == null) {
258             observers = new ArrayList&lt;&gt;();
259         }
260         observers.add(o);
261     }
262 
<span class="line-modified">263     /**</span>
<span class="line-modified">264      * Remove observer for this object.</span>
265      */
<span class="line-modified">266     public void removeObserver(final FieldObserver o) {</span>
267         if (observers != null) {
268             observers.remove(o);
269         }
270     }
271 
<span class="line-modified">272     /**</span>
<span class="line-modified">273      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">274      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">275      * user after he has finished editing the object.</span>
276      */
277     public void update() {
278         if (observers != null) {
<span class="line-modified">279             for (final FieldObserver observer : observers) {</span>
280                 observer.notify(this);
281             }
282         }
283     }
284 

285     public String getInitValue() {
286         if (value != null) {
287             return value.toString();
288         }
289         return null;
290     }
291 

292     /**
<span class="line-modified">293      * Return string representation close to declaration format, `public static</span>
<span class="line-modified">294      * final short MAX = 100&#39;, e.g..</span>
295      *
296      * @return String representation of field
297      */
298     @Override
299     public final String toString() {
300         String name;
301         String signature;
302         String access; // Short cuts to constant pool
303         access = Utility.accessToString(super.getAccessFlags());
304         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
305         signature = super.getType().toString();
306         name = getName();
307         final StringBuilder buf = new StringBuilder(32); // CHECKSTYLE IGNORE MagicNumber
308         buf.append(access).append(signature).append(&quot; &quot;).append(name);
309         final String value = getInitValue();
310         if (value != null) {
311             buf.append(&quot; = &quot;).append(value);
312         }
313         return buf.toString();
314     }
315 
<span class="line-modified">316     /**</span>
<span class="line-modified">317      * @return deep copy of this field</span>
318      */
<span class="line-modified">319     public FieldGen copy(final ConstantPoolGen cp) {</span>
320         final FieldGen fg = (FieldGen) clone();
321         fg.setConstantPool(cp);
322         return fg;
323     }
324 

325     /**
326      * @return Comparison strategy object
327      */
328     public static BCELComparator getComparator() {
329         return bcelComparator;
330     }
331 

332     /**
333      * @param comparator Comparison strategy object
334      */
<span class="line-modified">335     public static void setComparator(final BCELComparator comparator) {</span>
336         bcelComparator = comparator;
337     }
338 

339     /**
<span class="line-modified">340      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">341      * FieldGen objects are said to be equal when their names and signatures are</span>
<span class="line-modified">342      * equal.</span>
343      *
344      * @see java.lang.Object#equals(java.lang.Object)
345      */
346     @Override
<span class="line-modified">347     public boolean equals(final Object obj) {</span>
348         return bcelComparator.equals(this, obj);
349     }
350 

351     /**
<span class="line-modified">352      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">353      * return the hashcode of the field&#39;s name XOR signature.</span>
354      *
355      * @see java.lang.Object#hashCode()
356      */
357     @Override
358     public int hashCode() {
359         return bcelComparator.hashCode(this);
360     }
361 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
<span class="line-added"> 24 import java.util.Objects;</span>
 25 
 26 import com.sun.org.apache.bcel.internal.Const;
 27 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
 28 import com.sun.org.apache.bcel.internal.classfile.Annotations;
 29 import com.sun.org.apache.bcel.internal.classfile.Attribute;
 30 import com.sun.org.apache.bcel.internal.classfile.Constant;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantObject;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 33 import com.sun.org.apache.bcel.internal.classfile.ConstantValue;
 34 import com.sun.org.apache.bcel.internal.classfile.Field;
 35 import com.sun.org.apache.bcel.internal.classfile.Utility;
 36 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 37 
 38 /**
<span class="line-modified"> 39  * Template class for building up a field.  The only extraordinary thing</span>
<span class="line-modified"> 40  * one can do is to add a constant value attribute to a field (which must of</span>
<span class="line-modified"> 41  * course be compatible with to the declared type).</span>
 42  *

 43  * @see Field
<span class="line-added"> 44  * @LastModified: Jan 2020</span>
 45  */
 46 public class FieldGen extends FieldGenOrMethodGen {
 47 
 48     private Object value = null;
 49     private static BCELComparator bcelComparator = new BCELComparator() {
 50 
 51         @Override
<span class="line-modified"> 52         public boolean equals( final Object o1, final Object o2 ) {</span>
 53             final FieldGen THIS = (FieldGen) o1;
 54             final FieldGen THAT = (FieldGen) o2;
<span class="line-modified"> 55             return Objects.equals(THIS.getName(), THAT.getName())</span>
<span class="line-modified"> 56                     &amp;&amp; Objects.equals(THIS.getSignature(), THAT.getSignature());</span>
 57         }
 58 
<span class="line-added"> 59 </span>
 60         @Override
<span class="line-modified"> 61         public int hashCode( final Object o ) {</span>
 62             final FieldGen THIS = (FieldGen) o;
 63             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
 64         }
 65     };
 66 
<span class="line-added"> 67 </span>
 68     /**
<span class="line-modified"> 69      * Declare a field. If it is static (isStatic() == true) and has a</span>
<span class="line-modified"> 70      * basic type like int or String it may have an initial value</span>
<span class="line-modified"> 71      * associated with it as defined by setInitValue().</span>
 72      *
 73      * @param access_flags access qualifiers
<span class="line-modified"> 74      * @param type  field type</span>
 75      * @param name field name
 76      * @param cp constant pool
 77      */
 78     public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {
 79         super(access_flags);
 80         setType(type);
 81         setName(name);
 82         setConstantPool(cp);
 83     }
 84 
<span class="line-added"> 85 </span>
 86     /**
 87      * Instantiate from existing field.
 88      *
 89      * @param field Field object
<span class="line-modified"> 90      * @param cp constant pool (must contain the same entries as the field&#39;s constant pool)</span>

 91      */
 92     public FieldGen(final Field field, final ConstantPoolGen cp) {
 93         this(field.getAccessFlags(), Type.getType(field.getSignature()), field.getName(), cp);
 94         final Attribute[] attrs = field.getAttributes();
 95         for (final Attribute attr : attrs) {
 96             if (attr instanceof ConstantValue) {
 97                 setValue(((ConstantValue) attr).getConstantValueIndex());
 98             } else if (attr instanceof Annotations) {
<span class="line-modified"> 99                 final Annotations runtimeAnnotations = (Annotations)attr;</span>
100                 final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();
101                 for (final AnnotationEntry element : annotationEntries) {
<span class="line-modified">102                     addAnnotationEntry(new AnnotationEntryGen(element,cp,false));</span>
103                 }
104             } else {
105                 addAttribute(attr);
106             }
107         }
108     }
109 
<span class="line-modified">110 </span>
<span class="line-added">111     private void setValue( final int index ) {</span>
112         final ConstantPool cp = super.getConstantPool().getConstantPool();
113         final Constant c = cp.getConstant(index);
114         value = ((ConstantObject) c).getConstantValue(cp);
115     }
116 
<span class="line-added">117 </span>
118     /**
<span class="line-modified">119      * Set (optional) initial value of field, otherwise it will be set to null/0/false</span>
<span class="line-modified">120      * by the JVM automatically.</span>
121      */
<span class="line-modified">122     public void setInitValue( final String str ) {</span>
<span class="line-modified">123         checkType(  ObjectType.getInstance(&quot;java.lang.String&quot;));</span>
124         if (str != null) {
125             value = str;
126         }
127     }
128 
<span class="line-modified">129 </span>
<span class="line-added">130     public void setInitValue( final long l ) {</span>
131         checkType(Type.LONG);
132         if (l != 0L) {
<span class="line-modified">133             value = Long.valueOf(l);</span>
134         }
135     }
136 
<span class="line-modified">137 </span>
<span class="line-added">138     public void setInitValue( final int i ) {</span>
139         checkType(Type.INT);
140         if (i != 0) {
<span class="line-modified">141             value = Integer.valueOf(i);</span>
142         }
143     }
144 
<span class="line-modified">145 </span>
<span class="line-added">146     public void setInitValue( final short s ) {</span>
147         checkType(Type.SHORT);
148         if (s != 0) {
<span class="line-modified">149             value = Integer.valueOf(s);</span>
150         }
151     }
152 
<span class="line-modified">153 </span>
<span class="line-added">154     public void setInitValue( final char c ) {</span>
155         checkType(Type.CHAR);
156         if (c != 0) {
<span class="line-modified">157             value = Integer.valueOf(c);</span>
158         }
159     }
160 
<span class="line-modified">161 </span>
<span class="line-added">162     public void setInitValue( final byte b ) {</span>
163         checkType(Type.BYTE);
164         if (b != 0) {
<span class="line-modified">165             value = Integer.valueOf(b);</span>
166         }
167     }
168 
<span class="line-modified">169 </span>
<span class="line-added">170     public void setInitValue( final boolean b ) {</span>
171         checkType(Type.BOOLEAN);
172         if (b) {
<span class="line-modified">173             value = Integer.valueOf(1);</span>
174         }
175     }
176 
<span class="line-modified">177 </span>
<span class="line-added">178     public void setInitValue( final float f ) {</span>
179         checkType(Type.FLOAT);
180         if (f != 0.0) {
181             value = f;
182         }
183     }
184 
<span class="line-modified">185 </span>
<span class="line-added">186     public void setInitValue( final double d ) {</span>
187         checkType(Type.DOUBLE);
188         if (d != 0.0) {
189             value = d;
190         }
191     }
192 
<span class="line-modified">193 </span>
<span class="line-modified">194     /** Remove any initial value.</span>
195      */
196     public void cancelInitValue() {
197         value = null;
198     }
199 
<span class="line-modified">200 </span>
<span class="line-added">201     private void checkType( final Type atype ) {</span>
202         final Type superType = super.getType();
203         if (superType == null) {
204             throw new ClassGenException(&quot;You haven&#39;t defined the type of the field yet&quot;);
205         }
206         if (!isFinal()) {
207             throw new ClassGenException(&quot;Only final fields may have an initial value!&quot;);
208         }
209         if (!superType.equals(atype)) {
210             throw new ClassGenException(&quot;Types are not compatible: &quot; + superType + &quot; vs. &quot; + atype);
211         }
212     }
213 
<span class="line-added">214 </span>
215     /**
216      * Get field object after having set up all necessary values.
217      */
218     public Field getField() {
219         final String signature = getSignature();
220         final int name_index = super.getConstantPool().addUtf8(super.getName());
221         final int signature_index = super.getConstantPool().addUtf8(signature);
222         if (value != null) {
223             checkType(super.getType());
224             final int index = addConstant();
225             addAttribute(new ConstantValue(super.getConstantPool().addUtf8(&quot;ConstantValue&quot;), 2, index,
226                     super.getConstantPool().getConstantPool())); // sic
227         }
228         addAnnotationsAsAttribute(super.getConstantPool());
229         return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),
230                 super.getConstantPool().getConstantPool()); // sic
231     }
232 
233     private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<span class="line-modified">234           final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
235         for (final Attribute attr : attrs) {
236             addAttribute(attr);
237         }
<span class="line-modified">238       }</span>
<span class="line-added">239 </span>
240 
241     private int addConstant() {
242         switch (super.getType().getType()) { // sic
243             case Const.T_INT:
244             case Const.T_CHAR:
245             case Const.T_BYTE:
246             case Const.T_BOOLEAN:
247             case Const.T_SHORT:
248                 return super.getConstantPool().addInteger(((Integer) value));
249             case Const.T_FLOAT:
250                 return super.getConstantPool().addFloat(((Float) value));
251             case Const.T_DOUBLE:
252                 return super.getConstantPool().addDouble(((Double) value));
253             case Const.T_LONG:
254                 return super.getConstantPool().addLong(((Long) value));
255             case Const.T_REFERENCE:
256                 return super.getConstantPool().addString((String) value);
257             default:
258                 throw new RuntimeException(&quot;Oops: Unhandled : &quot; + super.getType().getType()); // sic
259         }
260     }
261 
<span class="line-added">262 </span>
263     @Override
264     public String getSignature() {
265         return super.getType().getSignature();
266     }
267 
268     private List&lt;FieldObserver&gt; observers;
269 
<span class="line-modified">270 </span>
<span class="line-modified">271     /** Add observer for this object.</span>
272      */
<span class="line-modified">273     public void addObserver( final FieldObserver o ) {</span>
274         if (observers == null) {
275             observers = new ArrayList&lt;&gt;();
276         }
277         observers.add(o);
278     }
279 
<span class="line-modified">280 </span>
<span class="line-modified">281     /** Remove observer for this object.</span>
282      */
<span class="line-modified">283     public void removeObserver( final FieldObserver o ) {</span>
284         if (observers != null) {
285             observers.remove(o);
286         }
287     }
288 
<span class="line-modified">289 </span>
<span class="line-modified">290     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">291      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">292      * called by the user after he has finished editing the object.</span>
293      */
294     public void update() {
295         if (observers != null) {
<span class="line-modified">296             for (final FieldObserver observer : observers ) {</span>
297                 observer.notify(this);
298             }
299         }
300     }
301 
<span class="line-added">302 </span>
303     public String getInitValue() {
304         if (value != null) {
305             return value.toString();
306         }
307         return null;
308     }
309 
<span class="line-added">310 </span>
311     /**
<span class="line-modified">312      * Return string representation close to declaration format,</span>
<span class="line-modified">313      * `public static final short MAX = 100&#39;, e.g..</span>
314      *
315      * @return String representation of field
316      */
317     @Override
318     public final String toString() {
319         String name;
320         String signature;
321         String access; // Short cuts to constant pool
322         access = Utility.accessToString(super.getAccessFlags());
323         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
324         signature = super.getType().toString();
325         name = getName();
326         final StringBuilder buf = new StringBuilder(32); // CHECKSTYLE IGNORE MagicNumber
327         buf.append(access).append(signature).append(&quot; &quot;).append(name);
328         final String value = getInitValue();
329         if (value != null) {
330             buf.append(&quot; = &quot;).append(value);
331         }
332         return buf.toString();
333     }
334 
<span class="line-modified">335 </span>
<span class="line-modified">336     /** @return deep copy of this field</span>
337      */
<span class="line-modified">338     public FieldGen copy( final ConstantPoolGen cp ) {</span>
339         final FieldGen fg = (FieldGen) clone();
340         fg.setConstantPool(cp);
341         return fg;
342     }
343 
<span class="line-added">344 </span>
345     /**
346      * @return Comparison strategy object
347      */
348     public static BCELComparator getComparator() {
349         return bcelComparator;
350     }
351 
<span class="line-added">352 </span>
353     /**
354      * @param comparator Comparison strategy object
355      */
<span class="line-modified">356     public static void setComparator( final BCELComparator comparator ) {</span>
357         bcelComparator = comparator;
358     }
359 
<span class="line-added">360 </span>
361     /**
<span class="line-modified">362      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">363      * By default two FieldGen objects are said to be equal when</span>
<span class="line-modified">364      * their names and signatures are equal.</span>
365      *
366      * @see java.lang.Object#equals(java.lang.Object)
367      */
368     @Override
<span class="line-modified">369     public boolean equals( final Object obj ) {</span>
370         return bcelComparator.equals(this, obj);
371     }
372 
<span class="line-added">373 </span>
374     /**
<span class="line-modified">375      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">376      * By default return the hashcode of the field&#39;s name XOR signature.</span>
377      *
378      * @see java.lang.Object#hashCode()
379      */
380     @Override
381     public int hashCode() {
382         return bcelComparator.hashCode(this);
383     }
384 }
</pre>
</td>
</tr>
</table>
<center><a href="FSUB.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="FieldGenOrMethodGen.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/CodeExceptionGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.classfile.CodeException;
 24 
 25 /**
<a name="1" id="anc1"></a><span class="line-modified"> 26  * This class represents an exception handler, i.e., specifies the  region where</span>
 27  * a handler is active and an instruction where the actual handling is done.
 28  * pool as parameters. Opposed to the JVM specification the end of the handled
 29  * region is set to be inclusive, i.e. all instructions between start and end
 30  * are protected including the start and end instructions (handles) themselves.
 31  * The end of the region is automatically mapped to be exclusive when calling
 32  * getCodeException(), i.e., there is no difference semantically.
 33  *
<a name="2" id="anc2"></a><span class="line-modified"> 34  * @see     MethodGen</span>
<span class="line-modified"> 35  * @see     CodeException</span>
<span class="line-modified"> 36  * @see     InstructionHandle</span>

 37  */
 38 public final class CodeExceptionGen implements InstructionTargeter, Cloneable {
 39 
 40     private InstructionHandle start_pc;
 41     private InstructionHandle end_pc;
 42     private InstructionHandle handler_pc;
 43     private ObjectType catch_type;
 44 
<a name="3" id="anc3"></a><span class="line-added"> 45 </span>
 46     /**
<a name="4" id="anc4"></a><span class="line-modified"> 47      * Add an exception handler, i.e., specify region where a handler is active and an</span>
<span class="line-modified"> 48      * instruction where the actual handling is done.</span>
 49      *
 50      * @param start_pc Start of handled region (inclusive)
 51      * @param end_pc End of handled region (inclusive)
 52      * @param handler_pc Where handling is done
 53      * @param catch_type which exception is handled, null for ANY
 54      */
 55     public CodeExceptionGen(final InstructionHandle start_pc, final InstructionHandle end_pc,
 56             final InstructionHandle handler_pc, final ObjectType catch_type) {
 57         setStartPC(start_pc);
 58         setEndPC(end_pc);
 59         setHandlerPC(handler_pc);
 60         this.catch_type = catch_type;
 61     }
 62 
<a name="5" id="anc5"></a><span class="line-added"> 63 </span>
 64     /**
 65      * Get CodeException object.&lt;BR&gt;
 66      *
<a name="6" id="anc6"></a><span class="line-modified"> 67      * This relies on that the instruction list has already been dumped</span>
<span class="line-modified"> 68      * to byte code or or that the `setPositions&#39; methods has been</span>
<span class="line-modified"> 69      * called for the instruction list.</span>
 70      *
 71      * @param cp constant pool
 72      */
<a name="7" id="anc7"></a><span class="line-modified"> 73     public CodeException getCodeException( final ConstantPoolGen cp ) {</span>
 74         return new CodeException(start_pc.getPosition(), end_pc.getPosition()
 75                 + end_pc.getInstruction().getLength(), handler_pc.getPosition(),
 76                 (catch_type == null) ? 0 : cp.addClass(catch_type));
 77     }
 78 
 79 
 80     /* Set start of handler
 81      * @param start_pc Start of handled region (inclusive)
 82      */
<a name="8" id="anc8"></a><span class="line-modified"> 83     public void setStartPC( final InstructionHandle start_pc ) { // TODO could be package-protected?</span>
 84         BranchInstruction.notifyTarget(this.start_pc, start_pc, this);
 85         this.start_pc = start_pc;
 86     }
 87 
 88 
 89     /* Set end of handler
 90      * @param end_pc End of handled region (inclusive)
 91      */
<a name="9" id="anc9"></a><span class="line-modified"> 92     public void setEndPC( final InstructionHandle end_pc ) { // TODO could be package-protected?</span>
 93         BranchInstruction.notifyTarget(this.end_pc, end_pc, this);
 94         this.end_pc = end_pc;
 95     }
 96 
 97 
 98     /* Set handler code
 99      * @param handler_pc Start of handler
100      */
<a name="10" id="anc10"></a><span class="line-modified">101     public void setHandlerPC( final InstructionHandle handler_pc ) { // TODO could be package-protected?</span>
102         BranchInstruction.notifyTarget(this.handler_pc, handler_pc, this);
103         this.handler_pc = handler_pc;
104     }
105 
<a name="11" id="anc11"></a><span class="line-added">106 </span>
107     /**
108      * @param old_ih old target, either start or end
109      * @param new_ih new target
110      */
111     @Override
<a name="12" id="anc12"></a><span class="line-modified">112     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
113         boolean targeted = false;
114         if (start_pc == old_ih) {
115             targeted = true;
116             setStartPC(new_ih);
117         }
118         if (end_pc == old_ih) {
119             targeted = true;
120             setEndPC(new_ih);
121         }
122         if (handler_pc == old_ih) {
123             targeted = true;
124             setHandlerPC(new_ih);
125         }
126         if (!targeted) {
127             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start_pc + &quot;, &quot;
128                     + end_pc + &quot;, &quot; + handler_pc + &quot;}&quot;);
129         }
130     }
131 
<a name="13" id="anc13"></a><span class="line-added">132 </span>
133     /**
134      * @return true, if ih is target of this handler
135      */
136     @Override
<a name="14" id="anc14"></a><span class="line-modified">137     public boolean containsTarget( final InstructionHandle ih ) {</span>
138         return (start_pc == ih) || (end_pc == ih) || (handler_pc == ih);
139     }
140 
<a name="15" id="anc15"></a><span class="line-modified">141 </span>
<span class="line-modified">142     /** Sets the type of the Exception to catch. Set &#39;null&#39; for ANY. */</span>
<span class="line-modified">143     public void setCatchType( final ObjectType catch_type ) {</span>

144         this.catch_type = catch_type;
145     }
146 
<a name="16" id="anc16"></a><span class="line-modified">147 </span>
<span class="line-modified">148     /** Gets the type of the Exception to catch, &#39;null&#39; for ANY. */</span>

149     public ObjectType getCatchType() {
150         return catch_type;
151     }
152 
<a name="17" id="anc17"></a><span class="line-modified">153 </span>
<span class="line-modified">154     /** @return start of handled region (inclusive)</span>
155      */
156     public InstructionHandle getStartPC() {
157         return start_pc;
158     }
159 
<a name="18" id="anc18"></a><span class="line-modified">160 </span>
<span class="line-modified">161     /** @return end of handled region (inclusive)</span>
162      */
163     public InstructionHandle getEndPC() {
164         return end_pc;
165     }
166 
<a name="19" id="anc19"></a><span class="line-modified">167 </span>
<span class="line-modified">168     /** @return start of handler</span>
169      */
170     public InstructionHandle getHandlerPC() {
171         return handler_pc;
172     }
173 
<a name="20" id="anc20"></a><span class="line-added">174 </span>
175     @Override
176     public String toString() {
177         return &quot;CodeExceptionGen(&quot; + start_pc + &quot;, &quot; + end_pc + &quot;, &quot; + handler_pc + &quot;)&quot;;
178     }
179 
<a name="21" id="anc21"></a><span class="line-added">180 </span>
181     @Override
182     public Object clone() {
183         try {
184             return super.clone();
185         } catch (final CloneNotSupportedException e) {
186             throw new Error(&quot;Clone Not Supported&quot;); // never happens
187         }
188     }
189 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
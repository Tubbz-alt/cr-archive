<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstructionConst.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionHandle.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,64 ***</span>
  package com.sun.org.apache.bcel.internal.generic;
  
  import com.sun.org.apache.bcel.internal.Const;
  
  /**
<span class="line-modified">!  * Instances of this class may be used, e.g., to generate typed versions of</span>
<span class="line-modified">!  * instructions. Its main purpose is to be used as the byte code generating</span>
<span class="line-modified">!  * backend of a compiler. You can subclass it to add your own create methods.</span>
   * &lt;p&gt;
<span class="line-modified">!  * Note: The static createXXX methods return singleton instances from the</span>
<span class="line-modified">!  * {@link InstructionConst} class.</span>
   *
<span class="line-removed">-  * @version $Id: InstructionFactory.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   * @see Const
   * @see InstructionConst
<span class="line-modified">!  * @LastModified: Nov 2017</span>
   */
  public class InstructionFactory {
  
      // N.N. These must agree with the order of Constants.T_CHAR through T_LONG
      private static final String[] short_names = {
<span class="line-modified">!         &quot;C&quot;, &quot;F&quot;, &quot;D&quot;, &quot;B&quot;, &quot;S&quot;, &quot;I&quot;, &quot;L&quot;</span>
      };
  
      private ClassGen cg;
      private ConstantPoolGen cp;
  
      public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {
          this.cg = cg;
          this.cp = cp;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Initialize with ClassGen object</span>
       */
      public InstructionFactory(final ClassGen cg) {
          this(cg, cg.getConstantPool());
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Initialize just with ConstantPoolGen object</span>
       */
      public InstructionFactory(final ConstantPoolGen cp) {
          this(null, cp);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Create an invoke instruction. (Except for invokedynamic.)</span>
       *
       * @param class_name name of the called class
       * @param name name of the called method
       * @param ret_type return type of method
       * @param arg_types argument types of method
<span class="line-modified">!      * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC,</span>
<span class="line-modified">!      * INVOKEVIRTUAL, or INVOKESPECIAL</span>
       * @see Const
       */
<span class="line-modified">!     public InvokeInstruction createInvoke(final String class_name, final String name, final Type ret_type,</span>
<span class="line-modified">!             final Type[] arg_types, final short kind) {</span>
          int index;
          int nargs = 0;
          final String signature = Type.getMethodSignature(ret_type, arg_types);
          for (final Type arg_type : arg_types) {
              nargs += arg_type.getSize();
<span class="line-new-header">--- 20,64 ---</span>
  package com.sun.org.apache.bcel.internal.generic;
  
  import com.sun.org.apache.bcel.internal.Const;
  
  /**
<span class="line-modified">!  * Instances of this class may be used, e.g., to generate typed</span>
<span class="line-modified">!  * versions of instructions. Its main purpose is to be used as the</span>
<span class="line-modified">!  * byte code generating backend of a compiler. You can subclass it to</span>
<span class="line-added">+  * add your own create methods.</span>
   * &lt;p&gt;
<span class="line-modified">!  * Note: The static createXXX methods return singleton instances</span>
<span class="line-modified">!  * from the {@link InstructionConst} class.</span>
   *
   * @see Const
   * @see InstructionConst
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public class InstructionFactory {
  
      // N.N. These must agree with the order of Constants.T_CHAR through T_LONG
      private static final String[] short_names = {
<span class="line-modified">!             &quot;C&quot;, &quot;F&quot;, &quot;D&quot;, &quot;B&quot;, &quot;S&quot;, &quot;I&quot;, &quot;L&quot;</span>
      };
  
      private ClassGen cg;
      private ConstantPoolGen cp;
  
      public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {
          this.cg = cg;
          this.cp = cp;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Initialize with ClassGen object</span>
       */
      public InstructionFactory(final ClassGen cg) {
          this(cg, cg.getConstantPool());
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Initialize just with ConstantPoolGen object</span>
       */
      public InstructionFactory(final ConstantPoolGen cp) {
          this(null, cp);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Create an invoke instruction. (Except for invokedynamic.)</span>
       *
       * @param class_name name of the called class
       * @param name name of the called method
       * @param ret_type return type of method
       * @param arg_types argument types of method
<span class="line-modified">!      * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,</span>
<span class="line-modified">!      * or INVOKESPECIAL</span>
       * @see Const
       */
<span class="line-modified">!     public InvokeInstruction createInvoke( final String class_name, final String name,</span>
<span class="line-modified">!             final Type ret_type, final Type[] arg_types, final short kind ) {</span>
          int index;
          int nargs = 0;
          final String signature = Type.getMethodSignature(ret_type, arg_types);
          for (final Type arg_type : arg_types) {
              nargs += arg_type.getSize();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,58 ***</span>
              default:
                  throw new RuntimeException(&quot;Oops: Unknown invoke kind: &quot; + kind);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Create an invokedynamic instruction.</span>
       *
       * @param bootstrap_index index into the bootstrap_methods array
       * @param name name of the called method
       * @param ret_type return type of method
       * @param arg_types argument types of method
       * @see Constants
       */
<span class="line-modified">!     /*</span>
<span class="line-modified">!      * createInvokeDynamic only needed if instrumention code wants to generate</span>
<span class="line-modified">!      * a new invokedynamic instruction.  I don&#39;t think we need.  (markro)</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,</span>
<span class="line-modified">!      Type[] arg_types) {</span>
<span class="line-modified">!      int index;</span>
<span class="line-modified">!      int nargs = 0;</span>
<span class="line-modified">!      String signature = Type.getMethodSignature(ret_type, arg_types);</span>
<span class="line-modified">!      for (int i = 0; i &lt; arg_types.length; i++) {</span>
<span class="line-modified">!      nargs += arg_types[i].getSize();</span>
<span class="line-modified">!      }</span>
<span class="line-modified">!      // UNDONE - needs to be added to ConstantPoolGen</span>
<span class="line-modified">!      //index = cp.addInvokeDynamic(bootstrap_index, name, signature);</span>
<span class="line-modified">!      index = 0;</span>
<span class="line-modified">!      return new INVOKEDYNAMIC(index);</span>
<span class="line-modified">!      }</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Create a call to the most popular System.out.println() method.</span>
       *
       * @param s the string to print
       */
<span class="line-modified">!     public InstructionList createPrintln(final String s) {</span>
          final InstructionList il = new InstructionList();
          final int out = cp.addFieldref(&quot;java.lang.System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
          final int println = cp.addMethodref(&quot;java.io.PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;);
          il.append(new GETSTATIC(out));
          il.append(new PUSH(cp, s));
          il.append(new INVOKEVIRTUAL(println));
          return il;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Uses PUSH to push a constant value onto the stack.</span>
<span class="line-removed">-      *</span>
       * @param value must be of type Number, Boolean, Character or String
       */
<span class="line-modified">!     public Instruction createConstant(final Object value) {</span>
          PUSH push;
          if (value instanceof Number) {
              push = new PUSH(cp, (Number) value);
          } else if (value instanceof String) {
              push = new PUSH(cp, (String) value);
<span class="line-new-header">--- 101,56 ---</span>
              default:
                  throw new RuntimeException(&quot;Oops: Unknown invoke kind: &quot; + kind);
          }
      }
  
<span class="line-modified">!     /** Create an invokedynamic instruction.</span>
       *
       * @param bootstrap_index index into the bootstrap_methods array
       * @param name name of the called method
       * @param ret_type return type of method
       * @param arg_types argument types of method
       * @see Constants
       */
<span class="line-modified">! /*</span>
<span class="line-modified">!  * createInvokeDynamic only needed if instrumention code wants to generate</span>
<span class="line-modified">!  * a new invokedynamic instruction.  I don&#39;t think we need.  (markro)</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!     public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,</span>
<span class="line-modified">!             Type[] arg_types) {</span>
<span class="line-modified">!         int index;</span>
<span class="line-modified">!         int nargs = 0;</span>
<span class="line-modified">!         String signature = Type.getMethodSignature(ret_type, arg_types);</span>
<span class="line-modified">!         for (int i = 0; i &lt; arg_types.length; i++) {</span>
<span class="line-modified">!             nargs += arg_types[i].getSize();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // UNDONE - needs to be added to ConstantPoolGen</span>
<span class="line-modified">!         //index = cp.addInvokeDynamic(bootstrap_index, name, signature);</span>
<span class="line-modified">!         index = 0;</span>
<span class="line-modified">!         return new INVOKEDYNAMIC(index);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /** Create a call to the most popular System.out.println() method.</span>
       *
       * @param s the string to print
       */
<span class="line-modified">!     public InstructionList createPrintln( final String s ) {</span>
          final InstructionList il = new InstructionList();
          final int out = cp.addFieldref(&quot;java.lang.System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
          final int println = cp.addMethodref(&quot;java.io.PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;);
          il.append(new GETSTATIC(out));
          il.append(new PUSH(cp, s));
          il.append(new INVOKEVIRTUAL(println));
          return il;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Uses PUSH to push a constant value onto the stack.</span>
       * @param value must be of type Number, Boolean, Character or String
       */
<span class="line-modified">!     public Instruction createConstant( final Object value ) {</span>
          PUSH push;
          if (value instanceof Number) {
              push = new PUSH(cp, (Number) value);
          } else if (value instanceof String) {
              push = new PUSH(cp, (String) value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 171,65 ***</span>
          final Type[] arg_types;
          final Type result_type;
          final String class_name;
          final String name;
  
          MethodObject(final String c, final String n, final Type r, final Type[] a) {
              class_name = c;
              name = n;
              result_type = r;
              arg_types = a;
          }
      }
  
<span class="line-modified">!     private InvokeInstruction createInvoke(final MethodObject m, final short kind) {</span>
          return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);
      }
  
      private static final MethodObject[] append_mos = {
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.STRING</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.OBJECT</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         null,</span>
<span class="line-modified">!         null, // indices 2, 3</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.BOOLEAN</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.CHAR</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.FLOAT</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.DOUBLE</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.INT</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(byte)</span>
<span class="line-modified">!         new Type[]{</span>
<span class="line-modified">!             Type.INT</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(short)</span>
<span class="line-modified">!         new Type[]{</span>
<span class="line-modified">!             Type.INT</span>
<span class="line-modified">!         }),</span>
<span class="line-modified">!         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">!             Type.LONG</span>
<span class="line-modified">!         })</span>
      };
  
<span class="line-modified">!     private static boolean isString(final Type type) {</span>
<span class="line-modified">!         return (type instanceof ObjectType)</span>
<span class="line-modified">!                 &amp;&amp; ((ObjectType) type).getClassName().equals(&quot;java.lang.String&quot;);</span>
      }
  
<span class="line-modified">!     public Instruction createAppend(final Type type) {</span>
          final byte t = type.getType();
          if (isString(type)) {
              return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);
          }
          switch (t) {
<span class="line-new-header">--- 169,69 ---</span>
          final Type[] arg_types;
          final Type result_type;
          final String class_name;
          final String name;
  
<span class="line-added">+ </span>
          MethodObject(final String c, final String n, final Type r, final Type[] a) {
              class_name = c;
              name = n;
              result_type = r;
              arg_types = a;
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private InvokeInstruction createInvoke( final MethodObject m, final short kind ) {</span>
          return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);
      }
  
      private static final MethodObject[] append_mos = {
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.STRING</span>
<span class="line-modified">!             }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.OBJECT</span>
<span class="line-modified">!             }),</span>
<span class="line-modified">!             null,</span>
<span class="line-modified">!             null, // indices 2, 3</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.BOOLEAN</span>
<span class="line-modified">!             }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.CHAR</span>
<span class="line-modified">!             }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.FLOAT</span>
<span class="line-modified">!             }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.DOUBLE</span>
<span class="line-modified">!             }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.INT</span>
<span class="line-modified">!             }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(byte)</span>
<span class="line-modified">!                     new Type[] {</span>
<span class="line-modified">!                         Type.INT</span>
<span class="line-modified">!                     }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(short)</span>
<span class="line-modified">!                     new Type[] {</span>
<span class="line-modified">!                         Type.INT</span>
<span class="line-modified">!                     }),</span>
<span class="line-modified">!             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">!                 Type.LONG</span>
<span class="line-modified">!             })</span>
      };
  
<span class="line-modified">! </span>
<span class="line-modified">!     private static boolean isString( final Type type ) {</span>
<span class="line-modified">!         return (type instanceof ObjectType) &amp;&amp;</span>
<span class="line-added">+               ((ObjectType) type).getClassName().equals(&quot;java.lang.String&quot;);</span>
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public Instruction createAppend( final Type type ) {</span>
          final byte t = type.getType();
          if (isString(type)) {
              return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);
          }
          switch (t) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 248,20 ***</span>
              default:
                  throw new RuntimeException(&quot;Oops: No append for this type? &quot; + type);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Create a field instruction.</span>
       *
       * @param class_name name of the accessed class
       * @param name name of the referenced field
<span class="line-modified">!      * @param type type of field</span>
       * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC
       * @see Const
       */
<span class="line-modified">!     public FieldInstruction createFieldAccess(final String class_name, final String name, final Type type, final short kind) {</span>
          int index;
          final String signature = type.getSignature();
          index = cp.addFieldref(class_name, name, signature);
          switch (kind) {
              case Const.GETFIELD:
<span class="line-new-header">--- 250,21 ---</span>
              default:
                  throw new RuntimeException(&quot;Oops: No append for this type? &quot; + type);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Create a field instruction.</span>
       *
       * @param class_name name of the accessed class
       * @param name name of the referenced field
<span class="line-modified">!      * @param type  type of field</span>
       * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC
       * @see Const
       */
<span class="line-modified">!     public FieldInstruction createFieldAccess( final String class_name,</span>
<span class="line-added">+             final String name, final Type type, final short kind ) {</span>
          int index;
          final String signature = type.getSignature();
          index = cp.addFieldref(class_name, name, signature);
          switch (kind) {
              case Const.GETFIELD:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,21 ***</span>
              default:
                  throw new RuntimeException(&quot;Oops: Unknown getfield kind:&quot; + kind);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Create reference to `this&#39;</span>
       */
      public static Instruction createThis() {
          return new ALOAD(0);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Create typed return</span>
       */
<span class="line-modified">!     public static ReturnInstruction createReturn(final Type type) {</span>
          switch (type.getType()) {
              case Const.T_ARRAY:
              case Const.T_OBJECT:
                  return InstructionConst.ARETURN;
              case Const.T_INT:
<span class="line-new-header">--- 278,21 ---</span>
              default:
                  throw new RuntimeException(&quot;Oops: Unknown getfield kind:&quot; + kind);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Create reference to `this&#39;</span>
       */
      public static Instruction createThis() {
          return new ALOAD(0);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Create typed return</span>
       */
<span class="line-modified">!     public static ReturnInstruction createReturn( final Type type ) {</span>
          switch (type.getType()) {
              case Const.T_ARRAY:
              case Const.T_OBJECT:
                  return InstructionConst.ARETURN;
              case Const.T_INT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 309,11 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid type: &quot; + type);
          }
      }
  
<span class="line-modified">!     private static ArithmeticInstruction createBinaryIntOp(final char first, final String op) {</span>
          switch (first) {
              case &#39;-&#39;:
                  return InstructionConst.ISUB;
              case &#39;+&#39;:
                  return InstructionConst.IADD;
<span class="line-new-header">--- 312,12 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid type: &quot; + type);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private static ArithmeticInstruction createBinaryIntOp( final char first, final String op ) {</span>
          switch (first) {
              case &#39;-&#39;:
                  return InstructionConst.ISUB;
              case &#39;+&#39;:
                  return InstructionConst.IADD;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,11 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
<span class="line-modified">!     private static ArithmeticInstruction createBinaryLongOp(final char first, final String op) {</span>
          switch (first) {
              case &#39;-&#39;:
                  return InstructionConst.LSUB;
              case &#39;+&#39;:
                  return InstructionConst.LADD;
<span class="line-new-header">--- 340,12 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private static ArithmeticInstruction createBinaryLongOp( final char first, final String op ) {</span>
          switch (first) {
              case &#39;-&#39;:
                  return InstructionConst.LSUB;
              case &#39;+&#39;:
                  return InstructionConst.LADD;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 363,11 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
<span class="line-modified">!     private static ArithmeticInstruction createBinaryFloatOp(final char op) {</span>
          switch (op) {
              case &#39;-&#39;:
                  return InstructionConst.FSUB;
              case &#39;+&#39;:
                  return InstructionConst.FADD;
<span class="line-new-header">--- 368,12 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private static ArithmeticInstruction createBinaryFloatOp( final char op ) {</span>
          switch (op) {
              case &#39;-&#39;:
                  return InstructionConst.FSUB;
              case &#39;+&#39;:
                  return InstructionConst.FADD;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 380,11 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
<span class="line-modified">!     private static ArithmeticInstruction createBinaryDoubleOp(final char op) {</span>
          switch (op) {
              case &#39;-&#39;:
                  return InstructionConst.DSUB;
              case &#39;+&#39;:
                  return InstructionConst.DADD;
<span class="line-new-header">--- 386,12 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     private static ArithmeticInstruction createBinaryDoubleOp( final char op ) {</span>
          switch (op) {
              case &#39;-&#39;:
                  return InstructionConst.DSUB;
              case &#39;+&#39;:
                  return InstructionConst.DADD;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,16 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
      /**
       * Create binary operation for simple basic types, such as int and float.
       *
       * @param op operation, such as &quot;+&quot;, &quot;*&quot;, &quot;&amp;lt;&amp;lt;&quot;, etc.
       */
<span class="line-modified">!     public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {</span>
          final char first = op.charAt(0);
          switch (type.getType()) {
              case Const.T_BYTE:
              case Const.T_SHORT:
              case Const.T_INT:
<span class="line-new-header">--- 404,17 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid operand &quot; + op);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Create binary operation for simple basic types, such as int and float.
       *
       * @param op operation, such as &quot;+&quot;, &quot;*&quot;, &quot;&amp;lt;&amp;lt;&quot;, etc.
       */
<span class="line-modified">!     public static ArithmeticInstruction createBinaryOperation( final String op, final Type type ) {</span>
          final char first = op.charAt(0);
          switch (type.getType()) {
              case Const.T_BYTE:
              case Const.T_SHORT:
              case Const.T_INT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 421,42 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createPop(final int size) {</span>
          return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;
      }
  
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createDup(final int size) {</span>
          return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;
      }
  
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createDup_2(final int size) {</span>
          return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;
      }
  
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createDup_1(final int size) {</span>
          return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;
      }
  
      /**
       * @param index index of local variable
       */
<span class="line-modified">!     public static LocalVariableInstruction createStore(final Type type, final int index) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_CHAR:
              case Const.T_BYTE:
              case Const.T_SHORT:
<span class="line-new-header">--- 429,47 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createPop( final int size ) {</span>
          return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;
      }
  
<span class="line-added">+ </span>
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createDup( final int size ) {</span>
          return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;
      }
  
<span class="line-added">+ </span>
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createDup_2( final int size ) {</span>
          return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;
      }
  
<span class="line-added">+ </span>
      /**
       * @param size size of operand, either 1 (int, e.g.) or 2 (double)
       */
<span class="line-modified">!     public static StackInstruction createDup_1( final int size ) {</span>
          return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;
      }
  
<span class="line-added">+ </span>
      /**
       * @param index index of local variable
       */
<span class="line-modified">!     public static LocalVariableInstruction createStore( final Type type, final int index ) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_CHAR:
              case Const.T_BYTE:
              case Const.T_SHORT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,14 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
      /**
       * @param index index of local variable
       */
<span class="line-modified">!     public static LocalVariableInstruction createLoad(final Type type, final int index) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_CHAR:
              case Const.T_BYTE:
              case Const.T_SHORT:
<span class="line-new-header">--- 487,15 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @param index index of local variable
       */
<span class="line-modified">!     public static LocalVariableInstruction createLoad( final Type type, final int index ) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_CHAR:
              case Const.T_BYTE:
              case Const.T_SHORT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,14 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
      /**
       * @param type type of elements of array, i.e., array.getElementType()
       */
<span class="line-modified">!     public static ArrayInstruction createArrayLoad(final Type type) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_BYTE:
                  return InstructionConst.BALOAD;
              case Const.T_CHAR:
<span class="line-new-header">--- 513,15 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @param type type of elements of array, i.e., array.getElementType()
       */
<span class="line-modified">!     public static ArrayInstruction createArrayLoad( final Type type ) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_BYTE:
                  return InstructionConst.BALOAD;
              case Const.T_CHAR:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,14 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
      /**
       * @param type type of elements of array, i.e., array.getElementType()
       */
<span class="line-modified">!     public static ArrayInstruction createArrayStore(final Type type) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_BYTE:
                  return InstructionConst.BASTORE;
              case Const.T_CHAR:
<span class="line-new-header">--- 542,15 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid type &quot; + type);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @param type type of elements of array, i.e., array.getElementType()
       */
<span class="line-modified">!     public static ArrayInstruction createArrayStore( final Type type ) {</span>
          switch (type.getType()) {
              case Const.T_BOOLEAN:
              case Const.T_BYTE:
                  return InstructionConst.BASTORE;
              case Const.T_CHAR:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 560,11 ***</span>
      /**
       * Create conversion operation for two stack operands, this may be an I2C,
       * instruction, e.g., if the operands are basic types and CHECKCAST if they
       * are reference types.
       */
<span class="line-modified">!     public Instruction createCast(final Type src_type, final Type dest_type) {</span>
          if ((src_type instanceof BasicType) &amp;&amp; (dest_type instanceof BasicType)) {
              final byte dest = dest_type.getType();
              byte src = src_type.getType();
              if (dest == Const.T_LONG
                      &amp;&amp; (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
<span class="line-new-header">--- 576,11 ---</span>
      /**
       * Create conversion operation for two stack operands, this may be an I2C,
       * instruction, e.g., if the operands are basic types and CHECKCAST if they
       * are reference types.
       */
<span class="line-modified">!     public Instruction createCast( final Type src_type, final Type dest_type ) {</span>
          if ((src_type instanceof BasicType) &amp;&amp; (dest_type instanceof BasicType)) {
              final byte dest = dest_type.getType();
              byte src = src_type.getType();
              if (dest == Const.T_LONG
                      &amp;&amp; (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 587,55 ***</span>
          } else {
              throw new RuntimeException(&quot;Can not cast &quot; + src_type + &quot; to &quot; + dest_type);
          }
      }
  
<span class="line-modified">!     public GETFIELD createGetField(final String class_name, final String name, final Type t) {</span>
          return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">!     public GETSTATIC createGetStatic(final String class_name, final String name, final Type t) {</span>
          return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">!     public PUTFIELD createPutField(final String class_name, final String name, final Type t) {</span>
          return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">!     public PUTSTATIC createPutStatic(final String class_name, final String name, final Type t) {</span>
          return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">!     public CHECKCAST createCheckCast(final ReferenceType t) {</span>
          if (t instanceof ArrayType) {
              return new CHECKCAST(cp.addArrayClass((ArrayType) t));
          }
          return new CHECKCAST(cp.addClass((ObjectType) t));
      }
  
<span class="line-modified">!     public INSTANCEOF createInstanceOf(final ReferenceType t) {</span>
          if (t instanceof ArrayType) {
              return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
          }
          return new INSTANCEOF(cp.addClass((ObjectType) t));
      }
  
<span class="line-modified">!     public NEW createNew(final ObjectType t) {</span>
          return new NEW(cp.addClass(t));
      }
  
<span class="line-modified">!     public NEW createNew(final String s) {</span>
          return createNew(ObjectType.getInstance(s));
      }
  
      /**
       * Create new array of given size and type.
       *
       * @return an instruction that creates the corresponding array at runtime,
       * i.e. is an AllocationInstruction
       */
<span class="line-modified">!     public Instruction createNewArray(final Type t, final short dim) {</span>
          if (dim == 1) {
              if (t instanceof ObjectType) {
                  return new ANEWARRAY(cp.addClass((ObjectType) t));
              } else if (t instanceof ArrayType) {
                  return new ANEWARRAY(cp.addArrayClass((ArrayType) t));
<span class="line-new-header">--- 603,63 ---</span>
          } else {
              throw new RuntimeException(&quot;Can not cast &quot; + src_type + &quot; to &quot; + dest_type);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public GETFIELD createGetField( final String class_name, final String name, final Type t ) {</span>
          return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public GETSTATIC createGetStatic( final String class_name, final String name, final Type t ) {</span>
          return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public PUTFIELD createPutField( final String class_name, final String name, final Type t ) {</span>
          return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public PUTSTATIC createPutStatic( final String class_name, final String name, final Type t ) {</span>
          return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public CHECKCAST createCheckCast( final ReferenceType t ) {</span>
          if (t instanceof ArrayType) {
              return new CHECKCAST(cp.addArrayClass((ArrayType) t));
          }
          return new CHECKCAST(cp.addClass((ObjectType) t));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public INSTANCEOF createInstanceOf( final ReferenceType t ) {</span>
          if (t instanceof ArrayType) {
              return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
          }
          return new INSTANCEOF(cp.addClass((ObjectType) t));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public NEW createNew( final ObjectType t ) {</span>
          return new NEW(cp.addClass(t));
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public NEW createNew( final String s ) {</span>
          return createNew(ObjectType.getInstance(s));
      }
  
      /**
       * Create new array of given size and type.
       *
       * @return an instruction that creates the corresponding array at runtime,
       * i.e. is an AllocationInstruction
       */
<span class="line-modified">!     public Instruction createNewArray( final Type t, final short dim ) {</span>
          if (dim == 1) {
              if (t instanceof ObjectType) {
                  return new ANEWARRAY(cp.addClass((ObjectType) t));
              } else if (t instanceof ArrayType) {
                  return new ANEWARRAY(cp.addArrayClass((ArrayType) t));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 653,11 ***</span>
      }
  
      /**
       * Create &quot;null&quot; value for reference types, 0 for basic types like int
       */
<span class="line-modified">!     public static Instruction createNull(final Type type) {</span>
          switch (type.getType()) {
              case Const.T_ARRAY:
              case Const.T_OBJECT:
                  return InstructionConst.ACONST_NULL;
              case Const.T_INT:
<span class="line-new-header">--- 677,11 ---</span>
      }
  
      /**
       * Create &quot;null&quot; value for reference types, 0 for basic types like int
       */
<span class="line-modified">!     public static Instruction createNull( final Type type ) {</span>
          switch (type.getType()) {
              case Const.T_ARRAY:
              case Const.T_OBJECT:
                  return InstructionConst.ACONST_NULL;
              case Const.T_INT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 681,11 ***</span>
  
      /**
       * Create branch instruction by given opcode, except LOOKUPSWITCH and
       * TABLESWITCH. For those you should use the SWITCH compound instruction.
       */
<span class="line-modified">!     public static BranchInstruction createBranchInstruction(final short opcode, final InstructionHandle target) {</span>
          switch (opcode) {
              case Const.IFEQ:
                  return new IFEQ(target);
              case Const.IFNE:
                  return new IFNE(target);
<span class="line-new-header">--- 705,12 ---</span>
  
      /**
       * Create branch instruction by given opcode, except LOOKUPSWITCH and
       * TABLESWITCH. For those you should use the SWITCH compound instruction.
       */
<span class="line-modified">!     public static BranchInstruction createBranchInstruction( final short opcode,</span>
<span class="line-added">+             final InstructionHandle target ) {</span>
          switch (opcode) {
              case Const.IFEQ:
                  return new IFEQ(target);
              case Const.IFNE:
                  return new IFNE(target);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 728,21 ***</span>
              default:
                  throw new RuntimeException(&quot;Invalid opcode: &quot; + opcode);
          }
      }
  
<span class="line-modified">!     public void setClassGen(final ClassGen c) {</span>
          cg = c;
      }
  
      public ClassGen getClassGen() {
          return cg;
      }
  
<span class="line-modified">!     public void setConstantPool(final ConstantPoolGen c) {</span>
          cp = c;
      }
  
      public ConstantPoolGen getConstantPool() {
          return cp;
      }
  }
<span class="line-new-header">--- 753,25 ---</span>
              default:
                  throw new RuntimeException(&quot;Invalid opcode: &quot; + opcode);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setClassGen( final ClassGen c ) {</span>
          cg = c;
      }
  
<span class="line-added">+ </span>
      public ClassGen getClassGen() {
          return cg;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setConstantPool( final ConstantPoolGen c ) {</span>
          cp = c;
      }
  
<span class="line-added">+ </span>
      public ConstantPoolGen getConstantPool() {
          return cp;
      }
  }
</pre>
<center><a href="InstructionConst.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionHandle.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.Collection;
 23 import java.util.HashMap;
 24 import java.util.HashSet;
 25 import java.util.Map;
 26 import java.util.Set;
 27 
 28 import com.sun.org.apache.bcel.internal.classfile.Utility;
 29 
 30 /**
 31  * Instances of this class give users a handle to the instructions contained in
 32  * an InstructionList. Instruction objects may be used more than once within a
 33  * list, this is useful because it saves memory and may be much faster.
 34  *
<a name="2" id="anc2"></a><span class="line-modified"> 35  * Within an InstructionList an InstructionHandle object is wrapped around all</span>
<span class="line-modified"> 36  * instructions, i.e., it implements a cell in a doubly-linked list. From the</span>
<span class="line-modified"> 37  * outside only the next and the previous instruction (handle) are accessible.</span>
<span class="line-modified"> 38  * One can traverse the list via an Enumeration returned by</span>

 39  * InstructionList.elements().
 40  *
<a name="3" id="anc3"></a><span class="line-removed"> 41  * @version $Id: InstructionHandle.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 42  * @see Instruction
 43  * @see BranchHandle
 44  * @see InstructionList
<a name="4" id="anc4"></a>
 45  */
 46 public class InstructionHandle {
 47 
 48     private InstructionHandle next;
 49     private InstructionHandle prev;
 50     private Instruction instruction;
 51 
 52     private int i_position = -1; // byte code offset of instruction
 53 
 54     private Set&lt;InstructionTargeter&gt; targeters;
 55     private Map&lt;Object, Object&gt; attributes;
 56 
<a name="5" id="anc5"></a>










 57     public final InstructionHandle getNext() {
 58         return next;
 59     }
 60 
<a name="6" id="anc6"></a>
 61     public final InstructionHandle getPrev() {
 62         return prev;
 63     }
 64 
<a name="7" id="anc7"></a>
 65     public final Instruction getInstruction() {
 66         return instruction;
 67     }
 68 
<a name="8" id="anc8"></a>
 69     /**
<a name="9" id="anc9"></a><span class="line-modified"> 70      * Replace current instruction contained in this handle. Old instruction is</span>
<span class="line-modified"> 71      * disposed using Instruction.dispose().</span>
 72      */
<a name="10" id="anc10"></a><span class="line-modified"> 73     public void setInstruction(final Instruction i) { // Overridden in BranchHandle TODO could be package-protected?</span>
 74         if (i == null) {
 75             throw new ClassGenException(&quot;Assigning null to handle&quot;);
 76         }
 77         if ((this.getClass() != BranchHandle.class) &amp;&amp; (i instanceof BranchInstruction)) {
 78             throw new ClassGenException(&quot;Assigning branch instruction &quot; + i + &quot; to plain handle&quot;);
 79         }
 80         if (instruction != null) {
 81             instruction.dispose();
 82         }
 83         instruction = i;
 84     }
 85 
<a name="11" id="anc11"></a>
 86     /**
<a name="12" id="anc12"></a><span class="line-modified"> 87      * Temporarily swap the current instruction, without disturbing anything.</span>
<span class="line-modified"> 88      * Meant to be used by a debugger, implementing breakpoints. Current</span>
<span class="line-modified"> 89      * instruction is returned.</span>
 90      * &lt;p&gt;
 91      * Warning: if this is used on a BranchHandle then some methods such as
<a name="13" id="anc13"></a><span class="line-modified"> 92      * getPosition() will still refer to the original cached instruction,</span>
<span class="line-modified"> 93      * whereas other BH methods may affect the cache and the replacement</span>
<span class="line-removed"> 94      * instruction.</span>
 95      */
 96     // See BCEL-273
 97     // TODO remove this method in any redesign of BCEL
<a name="14" id="anc14"></a><span class="line-modified"> 98     public Instruction swapInstruction(final Instruction i) {</span>
 99         final Instruction oldInstruction = instruction;
100         instruction = i;
101         return oldInstruction;
102     }
103 
104 
<a name="15" id="anc15"></a><span class="line-modified">105     /*private*/</span>
<span class="line-removed">106     protected InstructionHandle(final Instruction i) {</span>
107         setInstruction(i);
108     }
109 
<a name="16" id="anc16"></a><span class="line-modified">110     private static InstructionHandle ih_list = null; // List of reusable handles</span>
<span class="line-removed">111 </span>
<span class="line-removed">112     /**</span>
<span class="line-removed">113      * Factory method.</span>
114      */
<a name="17" id="anc17"></a><span class="line-modified">115     static InstructionHandle getInstructionHandle(final Instruction i) {</span>
<span class="line-modified">116         if (ih_list == null) {</span>
<span class="line-removed">117             return new InstructionHandle(i);</span>
<span class="line-removed">118         }</span>
<span class="line-removed">119         final InstructionHandle ih = ih_list;</span>
<span class="line-removed">120         ih_list = ih.next;</span>
<span class="line-removed">121         ih.setInstruction(i);</span>
<span class="line-removed">122         return ih;</span>
123     }
124 
<a name="18" id="anc18"></a>
125     /**
<a name="19" id="anc19"></a><span class="line-modified">126      * Called by InstructionList.setPositions when setting the position for</span>
<span class="line-modified">127      * every instruction. In the presence of variable length instructions</span>
<span class="line-modified">128      * `setPositions()&#39; performs multiple passes over the instruction list to</span>
<span class="line-modified">129      * calculate the correct (byte) positions and offsets by calling this</span>
<span class="line-removed">130      * function.</span>
131      *
<a name="20" id="anc20"></a><span class="line-modified">132      * @param offset additional offset caused by preceding (variable length)</span>
<span class="line-modified">133      * instructions</span>
<span class="line-modified">134      * @param max_offset the maximum offset that may be caused by these</span>
<span class="line-removed">135      * instructions</span>
<span class="line-removed">136      * @return additional offset caused by possible change of this instruction&#39;s</span>
<span class="line-removed">137      * length</span>
138      */
<a name="21" id="anc21"></a><span class="line-modified">139     protected int updatePosition(final int offset, final int max_offset) {</span>
140         i_position += offset;
141         return 0;
142     }
143 
<a name="22" id="anc22"></a><span class="line-modified">144     /**</span>
<span class="line-modified">145      * @return the position, i.e., the byte code offset of the contained</span>
<span class="line-modified">146      * instruction. This is accurate only after InstructionList.setPositions()</span>
<span class="line-modified">147      * has been called.</span>
148      */
149     public int getPosition() {
150         return i_position;
151     }
152 
<a name="23" id="anc23"></a><span class="line-modified">153     /**</span>
<span class="line-modified">154      * Set the position, i.e., the byte code offset of the contained</span>
155      * instruction.
156      */
<a name="24" id="anc24"></a><span class="line-modified">157     void setPosition(final int pos) {</span>
158         i_position = pos;
159     }
160 
<a name="25" id="anc25"></a><span class="line-removed">161     /**</span>
<span class="line-removed">162      * Overridden in BranchHandle</span>
<span class="line-removed">163      */</span>
<span class="line-removed">164     protected void addHandle() {</span>
<span class="line-removed">165         next = ih_list;</span>
<span class="line-removed">166         ih_list = this;</span>
<span class="line-removed">167     }</span>
168 
169     /**
<a name="26" id="anc26"></a><span class="line-modified">170      * Delete contents, i.e., remove user access and make handle reusable.</span>
171      */
172     void dispose() {
173         next = prev = null;
174         instruction.dispose();
175         instruction = null;
176         i_position = -1;
177         attributes = null;
178         removeAllTargeters();
<a name="27" id="anc27"></a><span class="line-removed">179         addHandle();</span>
180     }
181 
<a name="28" id="anc28"></a><span class="line-modified">182     /**</span>
<span class="line-modified">183      * Remove all targeters, if any.</span>
184      */
185     public void removeAllTargeters() {
186         if (targeters != null) {
187             targeters.clear();
188         }
189     }
190 
<a name="29" id="anc29"></a>
191     /**
192      * Denote this handle isn&#39;t referenced anymore by t.
193      */
<a name="30" id="anc30"></a><span class="line-modified">194     public void removeTargeter(final InstructionTargeter t) {</span>
195         if (targeters != null) {
196             targeters.remove(t);
197         }
198     }
199 
<a name="31" id="anc31"></a>
200     /**
201      * Denote this handle is being referenced by t.
202      */
<a name="32" id="anc32"></a><span class="line-modified">203     public void addTargeter(final InstructionTargeter t) {</span>
204         if (targeters == null) {
205             targeters = new HashSet&lt;&gt;();
206         }
207         //if(!targeters.contains(t))
208         targeters.add(t);
209     }
210 
<a name="33" id="anc33"></a>
211     public boolean hasTargeters() {
212         return (targeters != null) &amp;&amp; (targeters.size() &gt; 0);
213     }
214 
<a name="34" id="anc34"></a>
215     /**
216      * @return null, if there are no targeters
217      */
218     public InstructionTargeter[] getTargeters() {
219         if (!hasTargeters()) {
220             return new InstructionTargeter[0];
221         }
222         final InstructionTargeter[] t = new InstructionTargeter[targeters.size()];
223         targeters.toArray(t);
224         return t;
225     }
226 
<a name="35" id="anc35"></a><span class="line-modified">227     /**</span>
<span class="line-modified">228      * @return a (verbose) string representation of the contained instruction.</span>
229      */
<a name="36" id="anc36"></a><span class="line-modified">230     public String toString(final boolean verbose) {</span>
231         return Utility.format(i_position, 4, false, &#39; &#39;) + &quot;: &quot; + instruction.toString(verbose);
232     }
233 
<a name="37" id="anc37"></a><span class="line-modified">234     /**</span>
<span class="line-modified">235      * @return a string representation of the contained instruction.</span>
236      */
237     @Override
238     public String toString() {
239         return toString(true);
240     }
241 
<a name="38" id="anc38"></a><span class="line-modified">242     /**</span>
<span class="line-modified">243      * Add an attribute to an instruction handle.</span>
244      *
245      * @param key the key object to store/retrieve the attribute
246      * @param attr the attribute to associate with this handle
247      */
<a name="39" id="anc39"></a><span class="line-modified">248     public void addAttribute(final Object key, final Object attr) {</span>
249         if (attributes == null) {
250             attributes = new HashMap&lt;&gt;(3);
251         }
252         attributes.put(key, attr);
253     }
254 
<a name="40" id="anc40"></a><span class="line-modified">255     /**</span>
<span class="line-modified">256      * Delete an attribute of an instruction handle.</span>
257      *
258      * @param key the key object to retrieve the attribute
259      */
<a name="41" id="anc41"></a><span class="line-modified">260     public void removeAttribute(final Object key) {</span>
261         if (attributes != null) {
262             attributes.remove(key);
263         }
264     }
265 
<a name="42" id="anc42"></a><span class="line-modified">266     /**</span>
<span class="line-modified">267      * Get attribute of an instruction handle.</span>
268      *
269      * @param key the key object to store/retrieve the attribute
270      */
<a name="43" id="anc43"></a><span class="line-modified">271     public Object getAttribute(final Object key) {</span>
272         if (attributes != null) {
273             return attributes.get(key);
274         }
275         return null;
276     }
277 
<a name="44" id="anc44"></a><span class="line-modified">278     /**</span>
<span class="line-modified">279      * @return all attributes associated with this handle</span>
280      */
281     public Collection&lt;Object&gt; getAttributes() {
282         if (attributes == null) {
283             attributes = new HashMap&lt;&gt;(3);
284         }
285         return attributes.values();
286     }
287 
<a name="45" id="anc45"></a><span class="line-modified">288     /**</span>
<span class="line-modified">289      * Convenience method, simply calls accept() on the contained instruction.</span>
290      *
291      * @param v Visitor object
292      */
<a name="46" id="anc46"></a><span class="line-modified">293     public void accept(final Visitor v) {</span>
294         instruction.accept(v);
295     }
296 
<a name="47" id="anc47"></a>
297     /**
298      * @param next the next to set
299      * @ since 6.0
300      */
301     final InstructionHandle setNext(final InstructionHandle next) {
302         this.next = next;
303         return next;
304     }
305 
<a name="48" id="anc48"></a>
306     /**
307      * @param prev the prev to set
308      * @ since 6.0
309      */
310     final InstructionHandle setPrev(final InstructionHandle prev) {
311         this.prev = prev;
312         return prev;
313     }
314 }
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>
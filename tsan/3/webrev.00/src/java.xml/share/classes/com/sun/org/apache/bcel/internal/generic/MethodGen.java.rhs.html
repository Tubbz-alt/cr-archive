<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/MethodGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.generic;
  21 
  22 import com.sun.org.apache.bcel.internal.Const;
  23 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
  24 import com.sun.org.apache.bcel.internal.classfile.Annotations;
  25 import com.sun.org.apache.bcel.internal.classfile.Attribute;
  26 import com.sun.org.apache.bcel.internal.classfile.Code;
  27 import com.sun.org.apache.bcel.internal.classfile.CodeException;
  28 import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;
  29 import com.sun.org.apache.bcel.internal.classfile.LineNumber;
  30 import com.sun.org.apache.bcel.internal.classfile.LineNumberTable;
  31 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
  32 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTable;
  33 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTypeTable;
  34 import com.sun.org.apache.bcel.internal.classfile.Method;
  35 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotationEntry;
  36 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotations;
  37 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
  38 import com.sun.org.apache.bcel.internal.classfile.Utility;
  39 import com.sun.org.apache.bcel.internal.util.BCELComparator;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
<a name="2" id="anc2"></a>
  42 import java.util.HashMap;
  43 import java.util.List;
  44 import java.util.Map;
<a name="3" id="anc3"></a><span class="line-added">  45 import java.util.Objects;</span>
  46 import java.util.Stack;
  47 
  48 /**
  49  * Template class for building up a method. This is done by defining exception
  50  * handlers, adding thrown exceptions, local variables and attributes, whereas
  51  * the `LocalVariableTable&#39; and `LineNumberTable&#39; attributes will be set
  52  * automatically for the code. Use stripAttributes() if you don&#39;t like this.
  53  *
  54  * While generating code it may be necessary to insert NOP operations. You can
<a name="4" id="anc4"></a><span class="line-modified">  55  * use the `removeNOPs&#39; method to get rid off them.</span>
<span class="line-modified">  56  * The resulting method object can be obtained via the `getMethod()&#39; method.</span>
  57  *
<a name="5" id="anc5"></a><span class="line-modified">  58  * @see     InstructionList</span>
<span class="line-modified">  59  * @see     Method</span>
<span class="line-modified">  60  * @LastModified: Jan 2020</span>

  61  */
  62 public class MethodGen extends FieldGenOrMethodGen {
  63 
  64     private String class_name;
  65     private Type[] arg_types;
  66     private String[] arg_names;
  67     private int max_locals;
  68     private int max_stack;
  69     private InstructionList il;
  70     private boolean strip_attributes;
<a name="6" id="anc6"></a><span class="line-added">  71     private LocalVariableTypeTable local_variable_type_table = null;</span>
  72     private final List&lt;LocalVariableGen&gt; variable_vec = new ArrayList&lt;&gt;();
<a name="7" id="anc7"></a>
  73     private final List&lt;LineNumberGen&gt; line_number_vec = new ArrayList&lt;&gt;();
  74     private final List&lt;CodeExceptionGen&gt; exception_vec = new ArrayList&lt;&gt;();
  75     private final List&lt;String&gt; throws_vec = new ArrayList&lt;&gt;();
  76     private final List&lt;Attribute&gt; code_attrs_vec = new ArrayList&lt;&gt;();
  77 
  78     private List&lt;AnnotationEntryGen&gt;[] param_annotations; // Array of lists containing AnnotationGen objects
  79     private boolean hasParameterAnnotations = false;
  80     private boolean haveUnpackedParameterAnnotations = false;
  81 
  82     private static BCELComparator bcelComparator = new BCELComparator() {
  83 
  84         @Override
<a name="8" id="anc8"></a><span class="line-modified">  85         public boolean equals( final Object o1, final Object o2 ) {</span>
  86             final MethodGen THIS = (MethodGen) o1;
  87             final MethodGen THAT = (MethodGen) o2;
<a name="9" id="anc9"></a><span class="line-modified">  88             return Objects.equals(THIS.getName(), THAT.getName())</span>
<span class="line-modified">  89                     &amp;&amp; Objects.equals(THIS.getSignature(), THAT.getSignature());</span>
  90         }
  91 
<a name="10" id="anc10"></a><span class="line-added">  92 </span>
  93         @Override
<a name="11" id="anc11"></a><span class="line-modified">  94         public int hashCode( final Object o ) {</span>
  95             final MethodGen THIS = (MethodGen) o;
  96             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
  97         }
  98     };
  99 
<a name="12" id="anc12"></a><span class="line-added"> 100 </span>
 101     /**
<a name="13" id="anc13"></a><span class="line-modified"> 102      * Declare method. If the method is non-static the constructor</span>
<span class="line-modified"> 103      * automatically declares a local variable `$this&#39; in slot 0. The</span>
<span class="line-modified"> 104      * actual code is contained in the `il&#39; parameter, which may further</span>
<span class="line-modified"> 105      * manipulated by the user. But he must take care not to remove any</span>
<span class="line-modified"> 106      * instruction (handles) that are still referenced from this object.</span>
 107      *
 108      * For example one may not add a local variable and later remove the
<a name="14" id="anc14"></a><span class="line-modified"> 109      * instructions it refers to without causing havoc. It is safe</span>
<span class="line-modified"> 110      * however if you remove that local variable, too.</span>
 111      *
 112      * @param access_flags access qualifiers
<a name="15" id="anc15"></a><span class="line-modified"> 113      * @param return_type  method type</span>
 114      * @param arg_types argument types
<a name="16" id="anc16"></a><span class="line-modified"> 115      * @param arg_names argument names (if this is null, default names will be provided</span>
<span class="line-modified"> 116      * for them)</span>
 117      * @param method_name name of method
<a name="17" id="anc17"></a><span class="line-modified"> 118      * @param class_name class name containing this method (may be null, if you don&#39;t care)</span>
<span class="line-modified"> 119      * @param il instruction list associated with this method, may be null only for</span>
<span class="line-modified"> 120      * abstract or native methods</span>

 121      * @param cp constant pool
 122      */
 123     public MethodGen(final int access_flags, final Type return_type, final Type[] arg_types, String[] arg_names,
 124             final String method_name, final String class_name, final InstructionList il, final ConstantPoolGen cp) {
 125         super(access_flags);
 126         setType(return_type);
 127         setArgumentTypes(arg_types);
 128         setArgumentNames(arg_names);
 129         setName(method_name);
 130         setClassName(class_name);
 131         setInstructionList(il);
 132         setConstantPool(cp);
 133         final boolean abstract_ = isAbstract() || isNative();
 134         InstructionHandle start = null;
<a name="18" id="anc18"></a><span class="line-modified"> 135         final InstructionHandle end = null;</span>
 136         if (!abstract_) {
 137             start = il.getStart();
<a name="19" id="anc19"></a><span class="line-modified"> 138             // end == null =&gt; live to end of method</span>
 139             /* Add local variables, namely the implicit `this&#39; and the arguments
 140              */
 141             if (!isStatic() &amp;&amp; (class_name != null)) { // Instance method -&gt; `this&#39; is local var 0
<a name="20" id="anc20"></a><span class="line-modified"> 142                 addLocalVariable(&quot;this&quot;,  ObjectType.getInstance(class_name), start, end);</span>
 143             }
 144         }
 145         if (arg_types != null) {
 146             final int size = arg_types.length;
 147             for (final Type arg_type : arg_types) {
 148                 if (Type.VOID == arg_type) {
 149                     throw new ClassGenException(&quot;&#39;void&#39; is an illegal argument type for a method&quot;);
 150                 }
 151             }
 152             if (arg_names != null) { // Names for variables provided?
 153                 if (size != arg_names.length) {
 154                     throw new ClassGenException(&quot;Mismatch in argument array lengths: &quot; + size
 155                             + &quot; vs. &quot; + arg_names.length);
 156                 }
 157             } else { // Give them dummy names
 158                 arg_names = new String[size];
 159                 for (int i = 0; i &lt; size; i++) {
 160                     arg_names[i] = &quot;arg&quot; + i;
 161                 }
 162                 setArgumentNames(arg_names);
 163             }
 164             if (!abstract_) {
 165                 for (int i = 0; i &lt; size; i++) {
 166                     addLocalVariable(arg_names[i], arg_types[i], start, end);
 167                 }
 168             }
 169         }
 170     }
 171 
<a name="21" id="anc21"></a><span class="line-added"> 172 </span>
 173     /**
 174      * Instantiate from existing method.
 175      *
 176      * @param m method
 177      * @param class_name class name containing this method
 178      * @param cp constant pool
 179      */
 180     public MethodGen(final Method m, final String class_name, final ConstantPoolGen cp) {
 181         this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
<a name="22" id="anc22"></a><span class="line-modified"> 182                 .getSignature()), null /* may be overridden anyway */</span>
<span class="line-added"> 183         , m.getName(), class_name,</span>
 184                 ((m.getAccessFlags() &amp; (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)
<a name="23" id="anc23"></a><span class="line-modified"> 185                         ? new InstructionList(m.getCode().getCode())</span>
<span class="line-modified"> 186                         : null, cp);</span>
 187         final Attribute[] attributes = m.getAttributes();
 188         for (final Attribute attribute : attributes) {
 189             Attribute a = attribute;
 190             if (a instanceof Code) {
 191                 final Code c = (Code) a;
 192                 setMaxStack(c.getMaxStack());
 193                 setMaxLocals(c.getMaxLocals());
 194                 final CodeException[] ces = c.getExceptionTable();
 195                 if (ces != null) {
 196                     for (final CodeException ce : ces) {
 197                         final int type = ce.getCatchType();
 198                         ObjectType c_type = null;
 199                         if (type &gt; 0) {
 200                             final String cen = m.getConstantPool().getConstantString(type,
 201                                     Const.CONSTANT_Class);
<a name="24" id="anc24"></a><span class="line-modified"> 202                             c_type =  ObjectType.getInstance(cen);</span>
 203                         }
 204                         final int end_pc = ce.getEndPC();
 205                         final int length = m.getCode().getCode().length;
 206                         InstructionHandle end;
 207                         if (length == end_pc) { // May happen, because end_pc is exclusive
 208                             end = il.getEnd();
 209                         } else {
 210                             end = il.findHandle(end_pc);
 211                             end = end.getPrev(); // Make it inclusive
 212                         }
 213                         addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce
 214                                 .getHandlerPC()), c_type);
 215                     }
 216                 }
 217                 final Attribute[] c_attributes = c.getAttributes();
 218                 for (final Attribute c_attribute : c_attributes) {
 219                     a = c_attribute;
 220                     if (a instanceof LineNumberTable) {
 221                         final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();
 222                         for (final LineNumber l : ln) {
 223                             final InstructionHandle ih = il.findHandle(l.getStartPC());
 224                             if (ih != null) {
 225                                 addLineNumber(ih, l.getLineNumber());
 226                             }
 227                         }
 228                     } else if (a instanceof LocalVariableTable) {
<a name="25" id="anc25"></a><span class="line-modified"> 229                         updateLocalVariableTable((LocalVariableTable) a);</span>


 230                     } else if (a instanceof LocalVariableTypeTable) {
<a name="26" id="anc26"></a><span class="line-modified"> 231                         this.local_variable_type_table = (LocalVariableTypeTable) a.copy(cp.getConstantPool());</span>


 232                     } else {
 233                         addCodeAttribute(a);
 234                     }
 235                 }
 236             } else if (a instanceof ExceptionTable) {
 237                 final String[] names = ((ExceptionTable) a).getExceptionNames();
 238                 for (final String name2 : names) {
 239                     addException(name2);
 240                 }
 241             } else if (a instanceof Annotations) {
 242                 final Annotations runtimeAnnotations = (Annotations) a;
 243                 final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();
 244                 for (final AnnotationEntry element : aes) {
 245                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));
 246                 }
 247             } else {
 248                 addAttribute(a);
 249             }
 250         }
 251     }
 252 
<a name="27" id="anc27"></a>





















 253     /**
 254      * Adds a local variable to this method.
 255      *
 256      * @param name variable name
 257      * @param type variable type
<a name="28" id="anc28"></a><span class="line-modified"> 258      * @param slot the index of the local variable, if type is long or double, the next available</span>
<span class="line-modified"> 259      * index is slot+2</span>
 260      * @param start from where the variable is valid
 261      * @param end until where the variable is valid
<a name="29" id="anc29"></a><span class="line-added"> 262      * @param orig_index the index of the local variable prior to any modifications</span>
 263      * @return new local variable object
 264      * @see LocalVariable
 265      */
<a name="30" id="anc30"></a><span class="line-modified"> 266     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,</span>
<span class="line-modified"> 267             final InstructionHandle start, final InstructionHandle end, final int orig_index ) {</span>

 268         final byte t = type.getType();
 269         if (t != Const.T_ADDRESS) {
 270             final int add = type.getSize();
 271             if (slot + add &gt; max_locals) {
 272                 max_locals = slot + add;
 273             }
<a name="31" id="anc31"></a><span class="line-modified"> 274             final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);</span>
 275             int i;
 276             if ((i = variable_vec.indexOf(l)) &gt;= 0) {
 277                 variable_vec.set(i, l);
 278             } else {
 279                 variable_vec.add(l);
 280             }
 281             return l;
 282         }
 283         throw new IllegalArgumentException(&quot;Can not use &quot; + type
 284                 + &quot; as type for local variable&quot;);
 285     }
 286 
<a name="32" id="anc32"></a><span class="line-added"> 287 </span>
<span class="line-added"> 288     /**</span>
<span class="line-added"> 289      * Adds a local variable to this method.</span>
<span class="line-added"> 290      *</span>
<span class="line-added"> 291      * @param name variable name</span>
<span class="line-added"> 292      * @param type variable type</span>
<span class="line-added"> 293      * @param slot the index of the local variable, if type is long or double, the next available</span>
<span class="line-added"> 294      * index is slot+2</span>
<span class="line-added"> 295      * @param start from where the variable is valid</span>
<span class="line-added"> 296      * @param end until where the variable is valid</span>
<span class="line-added"> 297      * @return new local variable object</span>
<span class="line-added"> 298      * @see LocalVariable</span>
<span class="line-added"> 299      */</span>
<span class="line-added"> 300     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,</span>
<span class="line-added"> 301             final InstructionHandle start, final InstructionHandle end ) {</span>
<span class="line-added"> 302         return addLocalVariable(name, type, slot, start, end, slot);</span>
<span class="line-added"> 303     }</span>
<span class="line-added"> 304 </span>
 305     /**
 306      * Adds a local variable to this method and assigns an index automatically.
 307      *
 308      * @param name variable name
 309      * @param type variable type
<a name="33" id="anc33"></a><span class="line-modified"> 310      * @param start from where the variable is valid, if this is null,</span>
<span class="line-modified"> 311      * it is valid from the start</span>
<span class="line-modified"> 312      * @param end until where the variable is valid, if this is null,</span>
<span class="line-modified"> 313      * it is valid to the end</span>
 314      * @return new local variable object
 315      * @see LocalVariable
 316      */
<a name="34" id="anc34"></a><span class="line-modified"> 317     public LocalVariableGen addLocalVariable( final String name, final Type type, final InstructionHandle start,</span>
<span class="line-modified"> 318             final InstructionHandle end ) {</span>
 319         return addLocalVariable(name, type, max_locals, start, end);
 320     }
 321 
<a name="35" id="anc35"></a><span class="line-added"> 322 </span>
 323     /**
 324      * Remove a local variable, its slot will not be reused, if you do not use
 325      * addLocalVariable with an explicit index argument.
 326      */
 327     public void removeLocalVariable(final LocalVariableGen l) {
 328         variable_vec.remove(l);
 329     }
 330 
<a name="36" id="anc36"></a><span class="line-added"> 331 </span>
 332     /**
 333      * Remove all local variables.
 334      */
 335     public void removeLocalVariables() {
 336         variable_vec.clear();
 337     }
 338 
<a name="37" id="anc37"></a><span class="line-added"> 339 </span>
 340     /*
 341      * If the range of the variable has not been set yet, it will be set to be valid from
 342      * the start to the end of the instruction list.
 343      *
 344      * @return array of declared local variables sorted by index
 345      */
 346     public LocalVariableGen[] getLocalVariables() {
<a name="38" id="anc38"></a><span class="line-modified"> 347         final int size = variable_vec.size();</span>
<span class="line-modified"> 348         final LocalVariableGen[] lg = new LocalVariableGen[size];</span>
<span class="line-modified"> 349         variable_vec.toArray(lg);</span>

























 350         for (int i = 0; i &lt; size; i++) {
<a name="39" id="anc39"></a><span class="line-modified"> 351             if ((lg[i].getStart() == null) &amp;&amp; (il != null)) {</span>
 352                 lg[i].setStart(il.getStart());
 353             }
<a name="40" id="anc40"></a><span class="line-modified"> 354             if ((lg[i].getEnd() == null) &amp;&amp; (il != null)) {</span>

 355                 lg[i].setEnd(il.getEnd());
 356             }
 357         }
<a name="41" id="anc41"></a>
 358         if (size &gt; 1) {
<a name="42" id="anc42"></a><span class="line-modified"> 359             Arrays.sort(lg, (o1, o2) -&gt; o1.getIndex() - o2.getIndex());</span>





 360         }
<a name="43" id="anc43"></a>
 361         return lg;
 362     }
 363 
<a name="44" id="anc44"></a><span class="line-added"> 364 </span>
 365     /**
<a name="45" id="anc45"></a><span class="line-modified"> 366      * @return `LocalVariableTable&#39; attribute of all the local variables of this method.</span>

 367      */
<a name="46" id="anc46"></a><span class="line-modified"> 368     public LocalVariableTable getLocalVariableTable( final ConstantPoolGen cp ) {</span>
 369         final LocalVariableGen[] lg = getLocalVariables();
 370         final int size = lg.length;
 371         final LocalVariable[] lv = new LocalVariable[size];
 372         for (int i = 0; i &lt; size; i++) {
 373             lv[i] = lg[i].getLocalVariable(cp);
 374         }
 375         return new LocalVariableTable(cp.addUtf8(&quot;LocalVariableTable&quot;), 2 + lv.length * 10, lv, cp
 376                 .getConstantPool());
 377     }
 378 
 379     /**
<a name="47" id="anc47"></a><span class="line-modified"> 380      * @return `LocalVariableTypeTable&#39; attribute of this method.</span>

 381      */
<a name="48" id="anc48"></a><span class="line-modified"> 382     public LocalVariableTypeTable getLocalVariableTypeTable() {</span>
<span class="line-modified"> 383         return local_variable_type_table;</span>

























































 384     }
 385 
 386     /**
 387      * Give an instruction a line number corresponding to the source code line.
 388      *
 389      * @param ih instruction to tag
 390      * @return new line number object
 391      * @see LineNumber
 392      */
<a name="49" id="anc49"></a><span class="line-modified"> 393     public LineNumberGen addLineNumber( final InstructionHandle ih, final int src_line ) {</span>
 394         final LineNumberGen l = new LineNumberGen(ih, src_line);
 395         line_number_vec.add(l);
 396         return l;
 397     }
 398 
<a name="50" id="anc50"></a><span class="line-added"> 399 </span>
 400     /**
 401      * Remove a line number.
 402      */
<a name="51" id="anc51"></a><span class="line-modified"> 403     public void removeLineNumber( final LineNumberGen l ) {</span>
 404         line_number_vec.remove(l);
 405     }
 406 
<a name="52" id="anc52"></a><span class="line-added"> 407 </span>
 408     /**
 409      * Remove all line numbers.
 410      */
 411     public void removeLineNumbers() {
 412         line_number_vec.clear();
 413     }
 414 
<a name="53" id="anc53"></a><span class="line-added"> 415 </span>
 416     /*
 417      * @return array of line numbers
 418      */
 419     public LineNumberGen[] getLineNumbers() {
 420         final LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
 421         line_number_vec.toArray(lg);
 422         return lg;
 423     }
 424 
<a name="54" id="anc54"></a><span class="line-added"> 425 </span>
 426     /**
<a name="55" id="anc55"></a><span class="line-modified"> 427      * @return `LineNumberTable&#39; attribute of all the local variables of this method.</span>

 428      */
<a name="56" id="anc56"></a><span class="line-modified"> 429     public LineNumberTable getLineNumberTable( final ConstantPoolGen cp ) {</span>
 430         final int size = line_number_vec.size();
 431         final LineNumber[] ln = new LineNumber[size];
 432         for (int i = 0; i &lt; size; i++) {
 433             ln[i] = line_number_vec.get(i).getLineNumber();
 434         }
 435         return new LineNumberTable(cp.addUtf8(&quot;LineNumberTable&quot;), 2 + ln.length * 4, ln, cp
 436                 .getConstantPool());
 437     }
 438 
<a name="57" id="anc57"></a><span class="line-added"> 439 </span>
 440     /**
<a name="58" id="anc58"></a><span class="line-modified"> 441      * Add an exception handler, i.e., specify region where a handler is active and an</span>
<span class="line-modified"> 442      * instruction where the actual handling is done.</span>
 443      *
 444      * @param start_pc Start of region (inclusive)
 445      * @param end_pc End of region (inclusive)
 446      * @param handler_pc Where handling is done
 447      * @param catch_type class type of handled exception or null if any
 448      * exception is handled
 449      * @return new exception handler object
 450      */
<a name="59" id="anc59"></a><span class="line-modified"> 451     public CodeExceptionGen addExceptionHandler( final InstructionHandle start_pc,</span>
<span class="line-modified"> 452             final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type ) {</span>
 453         if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
 454             throw new ClassGenException(&quot;Exception handler target is null instruction&quot;);
 455         }
 456         final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
 457         exception_vec.add(c);
 458         return c;
 459     }
 460 
<a name="60" id="anc60"></a><span class="line-added"> 461 </span>
 462     /**
 463      * Remove an exception handler.
 464      */
<a name="61" id="anc61"></a><span class="line-modified"> 465     public void removeExceptionHandler( final CodeExceptionGen c ) {</span>
 466         exception_vec.remove(c);
 467     }
 468 
<a name="62" id="anc62"></a><span class="line-added"> 469 </span>
 470     /**
 471      * Remove all line numbers.
 472      */
 473     public void removeExceptionHandlers() {
 474         exception_vec.clear();
 475     }
 476 
<a name="63" id="anc63"></a><span class="line-added"> 477 </span>
 478     /*
 479      * @return array of declared exception handlers
 480      */
 481     public CodeExceptionGen[] getExceptionHandlers() {
 482         final CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
 483         exception_vec.toArray(cg);
 484         return cg;
 485     }
 486 
<a name="64" id="anc64"></a><span class="line-added"> 487 </span>
 488     /**
 489      * @return code exceptions for `Code&#39; attribute
 490      */
 491     private CodeException[] getCodeExceptions() {
 492         final int size = exception_vec.size();
 493         final CodeException[] c_exc = new CodeException[size];
 494         for (int i = 0; i &lt; size; i++) {
<a name="65" id="anc65"></a><span class="line-modified"> 495             final CodeExceptionGen c =  exception_vec.get(i);</span>
 496             c_exc[i] = c.getCodeException(super.getConstantPool());
 497         }
 498         return c_exc;
 499     }
 500 
<a name="66" id="anc66"></a><span class="line-added"> 501 </span>
 502     /**
 503      * Add an exception possibly thrown by this method.
 504      *
 505      * @param class_name (fully qualified) name of exception
 506      */
<a name="67" id="anc67"></a><span class="line-modified"> 507     public void addException( final String class_name ) {</span>
 508         throws_vec.add(class_name);
 509     }
 510 
<a name="68" id="anc68"></a><span class="line-added"> 511 </span>
 512     /**
 513      * Remove an exception.
 514      */
<a name="69" id="anc69"></a><span class="line-modified"> 515     public void removeException( final String c ) {</span>
 516         throws_vec.remove(c);
 517     }
 518 
<a name="70" id="anc70"></a><span class="line-added"> 519 </span>
 520     /**
 521      * Remove all exceptions.
 522      */
 523     public void removeExceptions() {
 524         throws_vec.clear();
 525     }
 526 
<a name="71" id="anc71"></a><span class="line-added"> 527 </span>
 528     /*
 529      * @return array of thrown exceptions
 530      */
 531     public String[] getExceptions() {
 532         final String[] e = new String[throws_vec.size()];
 533         throws_vec.toArray(e);
 534         return e;
 535     }
 536 
<a name="72" id="anc72"></a><span class="line-added"> 537 </span>
 538     /**
<a name="73" id="anc73"></a><span class="line-modified"> 539      * @return `Exceptions&#39; attribute of all the exceptions thrown by this method.</span>

 540      */
<a name="74" id="anc74"></a><span class="line-modified"> 541     private ExceptionTable getExceptionTable( final ConstantPoolGen cp ) {</span>
 542         final int size = throws_vec.size();
 543         final int[] ex = new int[size];
 544         for (int i = 0; i &lt; size; i++) {
 545             ex[i] = cp.addClass(throws_vec.get(i));
 546         }
 547         return new ExceptionTable(cp.addUtf8(&quot;Exceptions&quot;), 2 + 2 * size, ex, cp.getConstantPool());
 548     }
 549 
<a name="75" id="anc75"></a><span class="line-added"> 550 </span>
 551     /**
 552      * Add an attribute to the code. Currently, the JVM knows about the
<a name="76" id="anc76"></a><span class="line-modified"> 553      * LineNumberTable, LocalVariableTable and StackMap attributes,</span>
<span class="line-modified"> 554      * where the former two will be generated automatically and the</span>
<span class="line-modified"> 555      * latter is used for the MIDP only. Other attributes will be</span>
<span class="line-added"> 556      * ignored by the JVM but do no harm.</span>
 557      *
 558      * @param a attribute to be added
 559      */
<a name="77" id="anc77"></a><span class="line-modified"> 560     public void addCodeAttribute( final Attribute a ) {</span>
 561         code_attrs_vec.add(a);
 562     }
 563 
<a name="78" id="anc78"></a><span class="line-added"> 564 </span>
<span class="line-added"> 565     /**</span>
<span class="line-added"> 566      * Remove the LocalVariableTypeTable</span>
<span class="line-added"> 567      */</span>
<span class="line-added"> 568     public void removeLocalVariableTypeTable( ) {</span>
<span class="line-added"> 569         local_variable_type_table = null;</span>
<span class="line-added"> 570     }</span>
<span class="line-added"> 571 </span>
 572     /**
 573      * Remove a code attribute.
 574      */
<a name="79" id="anc79"></a><span class="line-modified"> 575     public void removeCodeAttribute( final Attribute a ) {</span>
 576         code_attrs_vec.remove(a);
 577     }
 578 
<a name="80" id="anc80"></a><span class="line-added"> 579 </span>
 580     /**
 581      * Remove all code attributes.
 582      */
 583     public void removeCodeAttributes() {
<a name="81" id="anc81"></a><span class="line-added"> 584         local_variable_type_table = null;</span>
 585         code_attrs_vec.clear();
 586     }
 587 
<a name="82" id="anc82"></a><span class="line-added"> 588 </span>
 589     /**
 590      * @return all attributes of this method.
 591      */
 592     public Attribute[] getCodeAttributes() {
 593         final Attribute[] attributes = new Attribute[code_attrs_vec.size()];
 594         code_attrs_vec.toArray(attributes);
 595         return attributes;
 596     }
 597 
 598     /**
 599      * @since 6.0
 600      */
 601     public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
<a name="83" id="anc83"></a><span class="line-modified"> 602           final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());</span>
 603         for (final Attribute attr : attrs) {
 604             addAttribute(attr);
 605         }
<a name="84" id="anc84"></a><span class="line-modified"> 606       }</span>
 607 
 608     /**
 609      * @since 6.0
 610      */
<a name="85" id="anc85"></a><span class="line-modified"> 611       public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {</span>
<span class="line-modified"> 612           if (!hasParameterAnnotations) {</span>
<span class="line-modified"> 613               return;</span>
<span class="line-modified"> 614           }</span>
<span class="line-modified"> 615           final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp,param_annotations);</span>
<span class="line-modified"> 616           if (attrs != null) {</span>
<span class="line-modified"> 617               for (final Attribute attr : attrs) {</span>
<span class="line-modified"> 618                   addAttribute(attr);</span>
<span class="line-modified"> 619               }</span>
<span class="line-modified"> 620           }</span>
<span class="line-modified"> 621       }</span>
<span class="line-added"> 622 </span>
 623 
 624     /**
<a name="86" id="anc86"></a><span class="line-modified"> 625      * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,</span>
<span class="line-modified"> 626      * before calling this method (the same applies for max locals).</span>

 627      *
 628      * @return method object
 629      */
 630     public Method getMethod() {
 631         final String signature = getSignature();
 632         final ConstantPoolGen _cp = super.getConstantPool();
 633         final int name_index = _cp.addUtf8(super.getName());
 634         final int signature_index = _cp.addUtf8(signature);
 635         /* Also updates positions of instructions, i.e., their indices
 636          */
 637         byte[] byte_code = null;
 638         if (il != null) {
 639             byte_code = il.getByteCode();
 640         }
 641         LineNumberTable lnt = null;
 642         LocalVariableTable lvt = null;
<a name="87" id="anc87"></a><span class="line-modified"> 643         /* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)</span>



 644          */
 645         if ((variable_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
<a name="88" id="anc88"></a><span class="line-added"> 646             updateLocalVariableTable(getLocalVariableTable(_cp));</span>
 647             addCodeAttribute(lvt = getLocalVariableTable(_cp));
 648         }
<a name="89" id="anc89"></a><span class="line-modified"> 649         if (local_variable_type_table != null) {</span>
<span class="line-modified"> 650             // LocalVariable length in LocalVariableTypeTable is not updated automatically. It&#39;s a difference with LocalVariableTable.</span>
<span class="line-modified"> 651             if (lvt != null) {</span>
<span class="line-added"> 652                 adjustLocalVariableTypeTable(lvt);</span>
<span class="line-added"> 653             }</span>
<span class="line-added"> 654             addCodeAttribute(local_variable_type_table);</span>
 655         }
<a name="90" id="anc90"></a>
 656         if ((line_number_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
 657             addCodeAttribute(lnt = getLineNumberTable(_cp));
 658         }
 659         final Attribute[] code_attrs = getCodeAttributes();
 660         /* Each attribute causes 6 additional header bytes
 661          */
 662         int attrs_len = 0;
 663         for (final Attribute code_attr : code_attrs) {
 664             attrs_len += code_attr.getLength() + 6;
 665         }
 666         final CodeException[] c_exc = getCodeExceptions();
 667         final int exc_len = c_exc.length * 8; // Every entry takes 8 bytes
 668         Code code = null;
 669         if ((il != null) &amp;&amp; !isAbstract() &amp;&amp; !isNative()) {
 670             // Remove any stale code attribute
 671             final Attribute[] attributes = getAttributes();
 672             for (final Attribute a : attributes) {
 673                 if (a instanceof Code) {
 674                     removeAttribute(a);
 675                 }
 676             }
 677             code = new Code(_cp.addUtf8(&quot;Code&quot;), 8 + byte_code.length + // prologue byte code
 678                     2 + exc_len + // exceptions
 679                     2 + attrs_len, // attributes
 680                     max_stack, max_locals, byte_code, c_exc, code_attrs, _cp.getConstantPool());
 681             addAttribute(code);
 682         }
 683         addAnnotationsAsAttribute(_cp);
 684         addParameterAnnotationsAsAttribute(_cp);
 685         ExceptionTable et = null;
 686         if (throws_vec.size() &gt; 0) {
 687             addAttribute(et = getExceptionTable(_cp));
 688             // Add `Exceptions&#39; if there are &quot;throws&quot; clauses
 689         }
 690         final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp
 691                 .getConstantPool());
 692         // Undo effects of adding attributes
 693         if (lvt != null) {
 694             removeCodeAttribute(lvt);
 695         }
<a name="91" id="anc91"></a><span class="line-modified"> 696         if (local_variable_type_table != null) {</span>
<span class="line-modified"> 697             removeCodeAttribute(local_variable_type_table);</span>
 698         }
 699         if (lnt != null) {
 700             removeCodeAttribute(lnt);
 701         }
 702         if (code != null) {
 703             removeAttribute(code);
 704         }
 705         if (et != null) {
 706             removeAttribute(et);
 707         }
 708         return m;
 709     }
 710 
<a name="92" id="anc92"></a><span class="line-added"> 711     private void updateLocalVariableTable(final LocalVariableTable a) {</span>
<span class="line-added"> 712         final LocalVariable[] lv = a.getLocalVariableTable();</span>
<span class="line-added"> 713         removeLocalVariables();</span>
<span class="line-added"> 714         for (final LocalVariable l : lv) {</span>
<span class="line-added"> 715             InstructionHandle start = il.findHandle(l.getStartPC());</span>
<span class="line-added"> 716             final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());</span>
<span class="line-added"> 717             // Repair malformed handles</span>
<span class="line-added"> 718             if (null == start) {</span>
<span class="line-added"> 719                 start = il.getStart();</span>
<span class="line-added"> 720             }</span>
<span class="line-added"> 721             // end == null =&gt; live to end of method</span>
<span class="line-added"> 722             // Since we are recreating the LocalVaraible, we must</span>
<span class="line-added"> 723             // propagate the orig_index to new copy.</span>
<span class="line-added"> 724             addLocalVariable(l.getName(), Type.getType(l.getSignature()), l</span>
<span class="line-added"> 725                     .getIndex(), start, end, l.getOrigIndex());</span>
<span class="line-added"> 726         }</span>
<span class="line-added"> 727     }</span>
<span class="line-added"> 728 </span>
<span class="line-added"> 729     private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {</span>
<span class="line-added"> 730         final LocalVariable[] lv = lvt.getLocalVariableTable();</span>
<span class="line-added"> 731         final LocalVariable[] lvg = local_variable_type_table.getLocalVariableTypeTable();</span>
<span class="line-added"> 732 </span>
<span class="line-added"> 733         for (final LocalVariable element : lvg) {</span>
<span class="line-added"> 734             for (final LocalVariable l : lv) {</span>
<span class="line-added"> 735                 if (element.getName().equals(l.getName()) &amp;&amp; element.getIndex() == l.getOrigIndex()) {</span>
<span class="line-added"> 736                     element.setLength(l.getLength());</span>
<span class="line-added"> 737                     element.setStartPC(l.getStartPC());</span>
<span class="line-added"> 738                     element.setIndex(l.getIndex());</span>
<span class="line-added"> 739                     break;</span>
<span class="line-added"> 740                 }</span>
<span class="line-added"> 741             }</span>
<span class="line-added"> 742         }</span>
<span class="line-added"> 743     }</span>
<span class="line-added"> 744 </span>
<span class="line-added"> 745 </span>
 746     /**
 747      * Remove all NOPs from the instruction list (if possible) and update every
 748      * object referring to them, i.e., branch instructions, local variables and
 749      * exception handlers.
 750      */
 751     public void removeNOPs() {
 752         if (il != null) {
 753             InstructionHandle next;
 754             /* Check branch instructions.
 755              */
 756             for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {
 757                 next = ih.getNext();
 758                 if ((next != null) &amp;&amp; (ih.getInstruction() instanceof NOP)) {
 759                     try {
 760                         il.delete(ih);
 761                     } catch (final TargetLostException e) {
 762                         for (final InstructionHandle target : e.getTargets()) {
 763                             for (final InstructionTargeter targeter : target.getTargeters()) {
 764                                 targeter.updateTarget(target, next);
 765                             }
 766                         }
 767                     }
 768                 }
 769             }
 770         }
 771     }
 772 
<a name="93" id="anc93"></a><span class="line-added"> 773 </span>
 774     /**
 775      * Set maximum number of local variables.
 776      */
<a name="94" id="anc94"></a><span class="line-modified"> 777     public void setMaxLocals( final int m ) {</span>
 778         max_locals = m;
 779     }
 780 
<a name="95" id="anc95"></a><span class="line-added"> 781 </span>
 782     public int getMaxLocals() {
 783         return max_locals;
 784     }
 785 
<a name="96" id="anc96"></a><span class="line-added"> 786 </span>
 787     /**
 788      * Set maximum stack size for this method.
 789      */
<a name="97" id="anc97"></a><span class="line-modified"> 790     public void setMaxStack( final int m ) { // TODO could be package-protected?</span>
 791         max_stack = m;
 792     }
 793 
<a name="98" id="anc98"></a><span class="line-added"> 794 </span>
 795     public int getMaxStack() {
 796         return max_stack;
 797     }
 798 
<a name="99" id="anc99"></a><span class="line-modified"> 799 </span>
<span class="line-modified"> 800     /** @return class that contains this method</span>
 801      */
 802     public String getClassName() {
 803         return class_name;
 804     }
 805 
<a name="100" id="anc100"></a><span class="line-modified"> 806 </span>
<span class="line-added"> 807     public void setClassName( final String class_name ) { // TODO could be package-protected?</span>
 808         this.class_name = class_name;
 809     }
 810 
<a name="101" id="anc101"></a><span class="line-modified"> 811 </span>
<span class="line-added"> 812     public void setReturnType( final Type return_type ) {</span>
 813         setType(return_type);
 814     }
 815 
<a name="102" id="anc102"></a><span class="line-added"> 816 </span>
 817     public Type getReturnType() {
 818         return getType();
 819     }
 820 
<a name="103" id="anc103"></a><span class="line-modified"> 821 </span>
<span class="line-added"> 822     public void setArgumentTypes( final Type[] arg_types ) {</span>
 823         this.arg_types = arg_types;
 824     }
 825 
<a name="104" id="anc104"></a><span class="line-added"> 826 </span>
 827     public Type[] getArgumentTypes() {
 828         return arg_types.clone();
 829     }
 830 
<a name="105" id="anc105"></a><span class="line-modified"> 831 </span>
<span class="line-added"> 832     public void setArgumentType( final int i, final Type type ) {</span>
 833         arg_types[i] = type;
 834     }
 835 
<a name="106" id="anc106"></a><span class="line-modified"> 836 </span>
<span class="line-added"> 837     public Type getArgumentType( final int i ) {</span>
 838         return arg_types[i];
 839     }
 840 
<a name="107" id="anc107"></a><span class="line-modified"> 841 </span>
<span class="line-added"> 842     public void setArgumentNames( final String[] arg_names ) {</span>
 843         this.arg_names = arg_names;
 844     }
 845 
<a name="108" id="anc108"></a><span class="line-added"> 846 </span>
 847     public String[] getArgumentNames() {
 848         return arg_names.clone();
 849     }
 850 
<a name="109" id="anc109"></a><span class="line-modified"> 851 </span>
<span class="line-added"> 852     public void setArgumentName( final int i, final String name ) {</span>
 853         arg_names[i] = name;
 854     }
 855 
<a name="110" id="anc110"></a><span class="line-modified"> 856 </span>
<span class="line-added"> 857     public String getArgumentName( final int i ) {</span>
 858         return arg_names[i];
 859     }
 860 
<a name="111" id="anc111"></a><span class="line-added"> 861 </span>
 862     public InstructionList getInstructionList() {
 863         return il;
 864     }
 865 
<a name="112" id="anc112"></a><span class="line-modified"> 866 </span>
<span class="line-added"> 867     public void setInstructionList( final InstructionList il ) { // TODO could be package-protected?</span>
 868         this.il = il;
 869     }
 870 
<a name="113" id="anc113"></a><span class="line-added"> 871 </span>
 872     @Override
 873     public String getSignature() {
 874         return Type.getMethodSignature(super.getType(), arg_types);
 875     }
 876 
<a name="114" id="anc114"></a><span class="line-added"> 877 </span>
 878     /**
 879      * Computes max. stack size by performing control flow analysis.
 880      */
 881     public void setMaxStack() { // TODO could be package-protected? (some tests would need repackaging)
 882         if (il != null) {
 883             max_stack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());
 884         } else {
 885             max_stack = 0;
 886         }
 887     }
 888 
<a name="115" id="anc115"></a><span class="line-added"> 889 </span>
 890     /**
 891      * Compute maximum number of local variables.
 892      */
 893     public void setMaxLocals() { // TODO could be package-protected? (some tests would need repackaging)
 894         if (il != null) {
 895             int max = isStatic() ? 0 : 1;
 896             if (arg_types != null) {
 897                 for (final Type arg_type : arg_types) {
 898                     max += arg_type.getSize();
 899                 }
 900             }
 901             for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
 902                 final Instruction ins = ih.getInstruction();
 903                 if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)
 904                         || (ins instanceof IINC)) {
 905                     final int index = ((IndexedInstruction) ins).getIndex()
 906                             + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();
 907                     if (index &gt; max) {
 908                         max = index;
 909                     }
 910                 }
 911             }
 912             max_locals = max;
 913         } else {
 914             max_locals = 0;
 915         }
 916     }
 917 
<a name="116" id="anc116"></a><span class="line-modified"> 918 </span>
<span class="line-modified"> 919     /** Do not/Do produce attributes code attributesLineNumberTable and</span>
 920      * LocalVariableTable, like javac -O
 921      */
<a name="117" id="anc117"></a><span class="line-modified"> 922     public void stripAttributes( final boolean flag ) {</span>
 923         strip_attributes = flag;
 924     }
 925 
 926     static final class BranchTarget {
 927 
 928         final InstructionHandle target;
 929         final int stackDepth;
 930 
<a name="118" id="anc118"></a><span class="line-added"> 931 </span>
 932         BranchTarget(final InstructionHandle target, final int stackDepth) {
 933             this.target = target;
 934             this.stackDepth = stackDepth;
 935         }
 936     }
 937 
 938     static final class BranchStack {
 939 
 940         private final Stack&lt;BranchTarget&gt; branchTargets = new Stack&lt;&gt;();
 941         private final Map&lt;InstructionHandle, BranchTarget&gt; visitedTargets = new HashMap&lt;&gt;();
 942 
<a name="119" id="anc119"></a><span class="line-modified"> 943 </span>
<span class="line-added"> 944         public void push( final InstructionHandle target, final int stackDepth ) {</span>
 945             if (visited(target)) {
 946                 return;
 947             }
 948             branchTargets.push(visit(target, stackDepth));
 949         }
 950 
<a name="120" id="anc120"></a><span class="line-added"> 951 </span>
 952         public BranchTarget pop() {
 953             if (!branchTargets.empty()) {
 954                 final BranchTarget bt = branchTargets.pop();
 955                 return bt;
 956             }
 957             return null;
 958         }
 959 
<a name="121" id="anc121"></a><span class="line-modified"> 960 </span>
<span class="line-added"> 961         private BranchTarget visit( final InstructionHandle target, final int stackDepth ) {</span>
 962             final BranchTarget bt = new BranchTarget(target, stackDepth);
 963             visitedTargets.put(target, bt);
 964             return bt;
 965         }
 966 
<a name="122" id="anc122"></a><span class="line-modified"> 967 </span>
<span class="line-added"> 968         private boolean visited( final InstructionHandle target ) {</span>
 969             return visitedTargets.get(target) != null;
 970         }
 971     }
 972 
<a name="123" id="anc123"></a><span class="line-added"> 973 </span>
 974     /**
<a name="124" id="anc124"></a><span class="line-modified"> 975      * Computes stack usage of an instruction list by performing control flow analysis.</span>

 976      *
 977      * @return maximum stack depth used by method
 978      */
<a name="125" id="anc125"></a><span class="line-modified"> 979     public static int getMaxStack( final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et ) {</span>

 980         final BranchStack branchTargets = new BranchStack();
 981         /* Initially, populate the branch stack with the exception
 982          * handlers, because these aren&#39;t (necessarily) branched to
 983          * explicitly. in each case, the stack will have depth 1,
 984          * containing the exception object.
 985          */
 986         for (final CodeExceptionGen element : et) {
 987             final InstructionHandle handler_pc = element.getHandlerPC();
 988             if (handler_pc != null) {
 989                 branchTargets.push(handler_pc, 1);
 990             }
 991         }
 992         int stackDepth = 0;
 993         int maxStackDepth = 0;
 994         InstructionHandle ih = il.getStart();
 995         while (ih != null) {
 996             final Instruction instruction = ih.getInstruction();
 997             final short opcode = instruction.getOpcode();
 998             final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);
 999             stackDepth += delta;
1000             if (stackDepth &gt; maxStackDepth) {
1001                 maxStackDepth = stackDepth;
1002             }
1003             // choose the next instruction based on whether current is a branch.
1004             if (instruction instanceof BranchInstruction) {
1005                 final BranchInstruction branch = (BranchInstruction) instruction;
1006                 if (instruction instanceof Select) {
1007                     // explore all of the select&#39;s targets. the default target is handled below.
1008                     final Select select = (Select) branch;
1009                     final InstructionHandle[] targets = select.getTargets();
1010                     for (final InstructionHandle target : targets) {
1011                         branchTargets.push(target, stackDepth);
1012                     }
1013                     // nothing to fall through to.
1014                     ih = null;
1015                 } else if (!(branch instanceof IfInstruction)) {
1016                     // if an instruction that comes back to following PC,
1017                     // push next instruction, with stack depth reduced by 1.
1018                     if (opcode == Const.JSR || opcode == Const.JSR_W) {
1019                         branchTargets.push(ih.getNext(), stackDepth - 1);
1020                     }
1021                     ih = null;
1022                 }
1023                 // for all branches, the target of the branch is pushed on the branch stack.
1024                 // conditional branches have a fall through case, selects don&#39;t, and
1025                 // jsr/jsr_w return to the next instruction.
1026                 branchTargets.push(branch.getTarget(), stackDepth);
1027             } else {
1028                 // check for instructions that terminate the method.
1029                 if (opcode == Const.ATHROW || opcode == Const.RET
1030                         || (opcode &gt;= Const.IRETURN &amp;&amp; opcode &lt;= Const.RETURN)) {
1031                     ih = null;
1032                 }
1033             }
1034             // normal case, go to the next instruction.
1035             if (ih != null) {
1036                 ih = ih.getNext();
1037             }
1038             // if we have no more instructions, see if there are any deferred branches to explore.
1039             if (ih == null) {
1040                 final BranchTarget bt = branchTargets.pop();
1041                 if (bt != null) {
1042                     ih = bt.target;
1043                     stackDepth = bt.stackDepth;
1044                 }
1045             }
1046         }
1047         return maxStackDepth;
1048     }
1049 
1050     private List&lt;MethodObserver&gt; observers;
1051 
<a name="126" id="anc126"></a><span class="line-modified">1052 </span>
<span class="line-modified">1053     /** Add observer for this object.</span>
1054      */
<a name="127" id="anc127"></a><span class="line-modified">1055     public void addObserver( final MethodObserver o ) {</span>
1056         if (observers == null) {
1057             observers = new ArrayList&lt;&gt;();
1058         }
1059         observers.add(o);
1060     }
1061 
<a name="128" id="anc128"></a><span class="line-modified">1062 </span>
<span class="line-modified">1063     /** Remove observer for this object.</span>
1064      */
<a name="129" id="anc129"></a><span class="line-modified">1065     public void removeObserver( final MethodObserver o ) {</span>
1066         if (observers != null) {
1067             observers.remove(o);
1068         }
1069     }
1070 
<a name="130" id="anc130"></a><span class="line-modified">1071 </span>
<span class="line-modified">1072     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">1073      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">1074      * called by the user after he has finished editing the object.</span>
1075      */
1076     public void update() {
1077         if (observers != null) {
1078             for (final MethodObserver observer : observers) {
1079                 observer.notify(this);
1080             }
1081         }
1082     }
1083 
<a name="131" id="anc131"></a><span class="line-added">1084 </span>
1085     /**
<a name="132" id="anc132"></a><span class="line-modified">1086      * Return string representation close to declaration format,</span>
<span class="line-modified">1087      * `public static void main(String[]) throws IOException&#39;, e.g.</span>
1088      *
1089      * @return String representation of the method.
1090      */
1091     @Override
1092     public final String toString() {
1093         final String access = Utility.accessToString(super.getAccessFlags());
1094         String signature = Type.getMethodSignature(super.getType(), arg_types);
1095         signature = Utility.methodSignatureToString(signature, super.getName(), access, true,
1096                 getLocalVariableTable(super.getConstantPool()));
1097         final StringBuilder buf = new StringBuilder(signature);
1098         for (final Attribute a : getAttributes()) {
1099             if (!((a instanceof Code) || (a instanceof ExceptionTable))) {
1100                 buf.append(&quot; [&quot;).append(a).append(&quot;]&quot;);
1101             }
1102         }
1103 
1104         if (throws_vec.size() &gt; 0) {
1105             for (final String throwsDescriptor : throws_vec) {
1106                 buf.append(&quot;\n\t\tthrows &quot;).append(throwsDescriptor);
1107             }
1108         }
1109         return buf.toString();
1110     }
1111 
<a name="133" id="anc133"></a><span class="line-modified">1112 </span>
<span class="line-modified">1113     /** @return deep copy of this method</span>
1114      */
<a name="134" id="anc134"></a><span class="line-modified">1115     public MethodGen copy( final String class_name, final ConstantPoolGen cp ) {</span>
1116         final Method m = ((MethodGen) clone()).getMethod();
1117         final MethodGen mg = new MethodGen(m, class_name, super.getConstantPool());
1118         if (super.getConstantPool() != cp) {
1119             mg.setConstantPool(cp);
1120             mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);
1121         }
1122         return mg;
1123     }
1124 
1125     //J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
1126     // is more likely to suggest to the caller it is readonly (which a List does not).
1127     /**
1128      * Return a list of AnnotationGen objects representing parameter annotations
<a name="135" id="anc135"></a>
1129      * @since 6.0
1130      */
1131     public List&lt;AnnotationEntryGen&gt; getAnnotationsOnParameter(final int i) {
1132         ensureExistingParameterAnnotationsUnpacked();
1133         if (!hasParameterAnnotations || i &gt; arg_types.length) {
1134             return null;
1135         }
1136         return param_annotations[i];
1137     }
1138 
1139     /**
1140      * Goes through the attributes on the method and identifies any that are
1141      * RuntimeParameterAnnotations, extracting their contents and storing them
1142      * as parameter annotations. There are two kinds of parameter annotation -
1143      * visible and invisible. Once they have been unpacked, these attributes are
1144      * deleted. (The annotations will be rebuilt as attributes when someone
1145      * builds a Method object out of this MethodGen object).
1146      */
<a name="136" id="anc136"></a><span class="line-modified">1147     private void ensureExistingParameterAnnotationsUnpacked()</span>
<span class="line-added">1148     {</span>
1149         if (haveUnpackedParameterAnnotations) {
1150             return;
1151         }
1152         // Find attributes that contain parameter annotation data
1153         final Attribute[] attrs = getAttributes();
1154         ParameterAnnotations paramAnnVisAttr = null;
1155         ParameterAnnotations paramAnnInvisAttr = null;
1156         for (final Attribute attribute : attrs) {
<a name="137" id="anc137"></a><span class="line-modified">1157             if (attribute instanceof ParameterAnnotations)</span>
<span class="line-added">1158             {</span>
1159                 // Initialize param_annotations
<a name="138" id="anc138"></a><span class="line-modified">1160                 if (!hasParameterAnnotations)</span>
<span class="line-added">1161                 {</span>
1162                     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1163                     final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1164                     param_annotations = parmList;
1165                     for (int j = 0; j &lt; arg_types.length; j++) {
1166                         param_annotations[j] = new ArrayList&lt;&gt;();
1167                     }
1168                 }
1169                 hasParameterAnnotations = true;
1170                 final ParameterAnnotations rpa = (ParameterAnnotations) attribute;
1171                 if (rpa instanceof RuntimeVisibleParameterAnnotations) {
1172                     paramAnnVisAttr = rpa;
1173                 } else {
1174                     paramAnnInvisAttr = rpa;
1175                 }
<a name="139" id="anc139"></a><span class="line-modified">1176                 final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();</span>
<span class="line-added">1177                 for (int j = 0; j &lt; parameterAnnotationEntries.length; j++)</span>
<span class="line-added">1178                 {</span>
1179                     // This returns Annotation[] ...
<a name="140" id="anc140"></a><span class="line-modified">1180                     final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];</span>

1181                     // ... which needs transforming into an AnnotationGen[] ...
<a name="141" id="anc141"></a><span class="line-modified">1182                     final List&lt;AnnotationEntryGen&gt; mutable = makeMutableVersion(immutableArray.getAnnotationEntries());</span>

1183                     // ... then add these to any we already know about
1184                     param_annotations[j].addAll(mutable);
1185                 }
1186             }
1187         }
1188         if (paramAnnVisAttr != null) {
1189             removeAttribute(paramAnnVisAttr);
1190         }
1191         if (paramAnnInvisAttr != null) {
1192             removeAttribute(paramAnnInvisAttr);
1193         }
1194         haveUnpackedParameterAnnotations = true;
1195     }
1196 
<a name="142" id="anc142"></a><span class="line-modified">1197     private List&lt;AnnotationEntryGen&gt; makeMutableVersion(final AnnotationEntry[] mutableArray)</span>
<span class="line-added">1198     {</span>
1199         final List&lt;AnnotationEntryGen&gt; result = new ArrayList&lt;&gt;();
1200         for (final AnnotationEntry element : mutableArray) {
1201             result.add(new AnnotationEntryGen(element, getConstantPool(),
1202                     false));
1203         }
1204         return result;
1205     }
1206 
1207     public void addParameterAnnotation(final int parameterIndex,
<a name="143" id="anc143"></a><span class="line-modified">1208             final AnnotationEntryGen annotation)</span>
<span class="line-added">1209     {</span>
1210         ensureExistingParameterAnnotationsUnpacked();
<a name="144" id="anc144"></a><span class="line-modified">1211         if (!hasParameterAnnotations)</span>
<span class="line-added">1212         {</span>
1213             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1214             final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1215             param_annotations = parmList;
1216             hasParameterAnnotations = true;
1217         }
1218         final List&lt;AnnotationEntryGen&gt; existingAnnotations = param_annotations[parameterIndex];
<a name="145" id="anc145"></a><span class="line-modified">1219         if (existingAnnotations != null)</span>
<span class="line-added">1220         {</span>
1221             existingAnnotations.add(annotation);
<a name="146" id="anc146"></a><span class="line-modified">1222         }</span>
<span class="line-added">1223         else</span>
<span class="line-added">1224         {</span>
1225             final List&lt;AnnotationEntryGen&gt; l = new ArrayList&lt;&gt;();
1226             l.add(annotation);
1227             param_annotations[parameterIndex] = l;
1228         }
1229     }
1230 
1231     /**
1232      * @return Comparison strategy object
1233      */
1234     public static BCELComparator getComparator() {
1235         return bcelComparator;
1236     }
1237 
<a name="147" id="anc147"></a><span class="line-added">1238 </span>
1239     /**
1240      * @param comparator Comparison strategy object
1241      */
<a name="148" id="anc148"></a><span class="line-modified">1242     public static void setComparator( final BCELComparator comparator ) {</span>
1243         bcelComparator = comparator;
1244     }
1245 
<a name="149" id="anc149"></a><span class="line-added">1246 </span>
1247     /**
<a name="150" id="anc150"></a><span class="line-modified">1248      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">1249      * By default two MethodGen objects are said to be equal when</span>
<span class="line-modified">1250      * their names and signatures are equal.</span>
1251      *
1252      * @see java.lang.Object#equals(java.lang.Object)
1253      */
1254     @Override
<a name="151" id="anc151"></a><span class="line-modified">1255     public boolean equals( final Object obj ) {</span>
1256         return bcelComparator.equals(this, obj);
1257     }
1258 
<a name="152" id="anc152"></a><span class="line-added">1259 </span>
1260     /**
<a name="153" id="anc153"></a><span class="line-modified">1261      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">1262      * By default return the hashcode of the method&#39;s name XOR signature.</span>
1263      *
1264      * @see java.lang.Object#hashCode()
1265      */
1266     @Override
1267     public int hashCode() {
1268         return bcelComparator.hashCode(this);
1269     }
1270 }
<a name="154" id="anc154"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="154" type="hidden" />
</body>
</html>
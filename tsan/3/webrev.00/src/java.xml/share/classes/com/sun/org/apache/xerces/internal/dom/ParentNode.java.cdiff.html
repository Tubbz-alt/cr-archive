<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PSVIDOMImplementationImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TextImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ParentNode.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,10 ***</span>
<span class="line-new-header">--- 66,11 ---</span>
   * @xerces.internal
   *
   * @author Arnaud  Le Hors, IBM
   * @author Joe Kesselman, IBM
   * @author Andy Clark, IBM
<span class="line-added">+  * @LastModified: Apr 2019</span>
   */
  public abstract class ParentNode
      extends ChildNode {
  
      /** Serialization version. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,22 ***</span>
  
      /**
       * NON-DOM
       * set the ownerDocument of this node and its children
       */
<span class="line-modified">!     void setOwnerDocument(CoreDocumentImpl doc) {</span>
          if (needsSyncChildren()) {
              synchronizeChildren();
          }
<span class="line-removed">-        for (ChildNode child = firstChild;</span>
<span class="line-removed">-              child != null; child = child.nextSibling) {</span>
<span class="line-removed">-              child.setOwnerDocument(doc);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         /* setting the owner document of self, after it&#39;s children makes the</span>
<span class="line-removed">-            data of children available to the new document. */</span>
          super.setOwnerDocument(doc);
          ownerDocument = doc;
      }
  
      /**
       * Test whether this node has any children. Convenience shorthand
       * for (Node.getFirstChild()!=null)
<span class="line-new-header">--- 173,20 ---</span>
  
      /**
       * NON-DOM
       * set the ownerDocument of this node and its children
       */
<span class="line-modified">!     protected void setOwnerDocument(CoreDocumentImpl doc) {</span>
          if (needsSyncChildren()) {
              synchronizeChildren();
          }
          super.setOwnerDocument(doc);
          ownerDocument = doc;
<span class="line-added">+         for (ChildNode child = firstChild;</span>
<span class="line-added">+         child != null; child = child.nextSibling) {</span>
<span class="line-added">+             child.setOwnerDocument(doc);</span>
<span class="line-added">+         }</span>
      }
  
      /**
       * Test whether this node has any children. Convenience shorthand
       * for (Node.getFirstChild()!=null)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,20 ***</span>
              }
  
              // Prevent cycles in the tree
              // newChild cannot be ancestor of this Node,
              // and actually cannot be this
<span class="line-modified">!             if (ownerDocument.ancestorChecking) {</span>
<span class="line-modified">!                 boolean treeSafe = true;</span>
<span class="line-modified">!                 for (NodeImpl a = this; treeSafe &amp;&amp; a != null; a = a.parentNode())</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!                     treeSafe = newChild != a;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 if(!treeSafe) {</span>
<span class="line-modified">!                     throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,</span>
<span class="line-removed">-                                 DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));</span>
<span class="line-removed">-                 }</span>
              }
          }
  
          // notify document
          ownerDocument.insertingNode(this, replace);
<span class="line-new-header">--- 365,18 ---</span>
              }
  
              // Prevent cycles in the tree
              // newChild cannot be ancestor of this Node,
              // and actually cannot be this
<span class="line-modified">!             boolean treeSafe = true;</span>
<span class="line-modified">!             for (NodeImpl a = this; treeSafe &amp;&amp; a != null; a = a.parentNode())</span>
<span class="line-modified">!             {</span>
<span class="line-modified">!                 treeSafe = newChild != a;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             if(!treeSafe) {</span>
<span class="line-modified">!                 throw new DOMException(DOMException.HIERARCHY_REQUEST_ERR,</span>
<span class="line-modified">!                             DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;HIERARCHY_REQUEST_ERR&quot;, null));</span>
              }
          }
  
          // notify document
          ownerDocument.insertingNode(this, replace);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,21 ***</span>
          ChildNode oldInternal = (ChildNode) oldChild;
  
          // notify document
          ownerDocument.removingNode(this, oldInternal, replace);
  
          // update cached length if we have any
          if (fNodeListCache != null) {
              if (fNodeListCache.fLength != -1) {
                  fNodeListCache.fLength--;
              }
              if (fNodeListCache.fChildIndex != -1) {
                  // if the removed node is the cached node
                  // move the cache to its (soon former) previous sibling
                  if (fNodeListCache.fChild == oldInternal) {
                      fNodeListCache.fChildIndex--;
<span class="line-modified">!                     fNodeListCache.fChild = oldInternal.previousSibling();</span>
                  } else {
                      // otherwise just invalidate the cache
                      fNodeListCache.fChildIndex = -1;
                  }
              }
<span class="line-new-header">--- 504,24 ---</span>
          ChildNode oldInternal = (ChildNode) oldChild;
  
          // notify document
          ownerDocument.removingNode(this, oldInternal, replace);
  
<span class="line-added">+         // Save previous sibling for normalization checking.</span>
<span class="line-added">+         final ChildNode oldPreviousSibling = oldInternal.previousSibling();</span>
<span class="line-added">+ </span>
          // update cached length if we have any
          if (fNodeListCache != null) {
              if (fNodeListCache.fLength != -1) {
                  fNodeListCache.fLength--;
              }
              if (fNodeListCache.fChildIndex != -1) {
                  // if the removed node is the cached node
                  // move the cache to its (soon former) previous sibling
                  if (fNodeListCache.fChild == oldInternal) {
                      fNodeListCache.fChildIndex--;
<span class="line-modified">!                     fNodeListCache.fChild = oldPreviousSibling;</span>
                  } else {
                      // otherwise just invalidate the cache
                      fNodeListCache.fChildIndex = -1;
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 548,13 ***</span>
                  // removing some other child in the middle
                  next.previousSibling = prev;
              }
          }
  
<span class="line-removed">-         // Save previous sibling for normalization checking.</span>
<span class="line-removed">-         ChildNode oldPreviousSibling = oldInternal.previousSibling();</span>
<span class="line-removed">- </span>
          // Remove oldInternal&#39;s references to tree
          oldInternal.ownerNode       = ownerDocument;
          oldInternal.isOwned(false);
          oldInternal.nextSibling     = null;
          oldInternal.previousSibling = null;
<span class="line-new-header">--- 548,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,24 ***</span>
          if (child != null) {
              Node next = child.getNextSibling();
              if (next == null) {
                  return hasTextContent(child) ? ((NodeImpl) child).getTextContent() : &quot;&quot;;
              }
<span class="line-modified">!             if (fBufferStr == null){</span>
<span class="line-modified">!                 fBufferStr = new StringBuffer();</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-             else {</span>
<span class="line-removed">-                 fBufferStr.setLength(0);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             getTextContent(fBufferStr);</span>
<span class="line-removed">-             return fBufferStr.toString();</span>
          }
          return &quot;&quot;;
      }
  
<span class="line-modified">!     // internal method taking a StringBuffer in parameter</span>
<span class="line-modified">!     void getTextContent(StringBuffer buf) throws DOMException {</span>
          Node child = getFirstChild();
          while (child != null) {
              if (hasTextContent(child)) {
                  ((NodeImpl) child).getTextContent(buf);
              }
<span class="line-new-header">--- 619,19 ---</span>
          if (child != null) {
              Node next = child.getNextSibling();
              if (next == null) {
                  return hasTextContent(child) ? ((NodeImpl) child).getTextContent() : &quot;&quot;;
              }
<span class="line-modified">!             StringBuilder buf = new StringBuilder();</span>
<span class="line-modified">!             getTextContent(buf);</span>
<span class="line-modified">!             return buf.toString();</span>
          }
          return &quot;&quot;;
      }
  
<span class="line-modified">!     // internal method taking a StringBuilder in parameter</span>
<span class="line-modified">!     void getTextContent(StringBuilder buf) throws DOMException {</span>
          Node child = getFirstChild();
          while (child != null) {
              if (hasTextContent(child)) {
                  ((NodeImpl) child).getTextContent(buf);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 682,10 ***</span>
<span class="line-new-header">--- 674,13 ---</span>
       * @return int
       */
      private int nodeListGetLength() {
  
          if (fNodeListCache == null) {
<span class="line-added">+             if (needsSyncChildren()) {</span>
<span class="line-added">+                 synchronizeChildren();</span>
<span class="line-added">+             }</span>
              // get rid of trivial cases
              if (firstChild == null) {
                  return 0;
              }
              if (firstChild == lastChild()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,10 ***</span>
<span class="line-new-header">--- 726,13 ---</span>
       * @param index int
       */
      private Node nodeListItem(int index) {
  
          if (fNodeListCache == null) {
<span class="line-added">+             if (needsSyncChildren()) {</span>
<span class="line-added">+                 synchronizeChildren();</span>
<span class="line-added">+             }</span>
              // get rid of trivial case
              if (firstChild == lastChild()) {
                  return index == 0 ? firstChild : null;
              }
              // otherwise request a cache object
</pre>
<hr />
<pre>
<span class="line-old-header">*** 868,11 ***</span>
          // better than another. Performance may vary greatly depending on
          // the implementations involved. This one should work fine for us.
          Node child1 = getFirstChild();
          Node child2 = arg.getFirstChild();
          while (child1 != null &amp;&amp; child2 != null) {
<span class="line-modified">!             if (!((NodeImpl) child1).isEqualNode(child2)) {</span>
                  return false;
              }
              child1 = child1.getNextSibling();
              child2 = child2.getNextSibling();
          }
<span class="line-new-header">--- 866,11 ---</span>
          // better than another. Performance may vary greatly depending on
          // the implementations involved. This one should work fine for us.
          Node child1 = getFirstChild();
          Node child2 = arg.getFirstChild();
          while (child1 != null &amp;&amp; child2 != null) {
<span class="line-modified">!             if (!child1.isEqualNode(child2)) {</span>
                  return false;
              }
              child1 = child1.getNextSibling();
              child2 = child2.getNextSibling();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 995,11 ***</span>
      //
  
      /** Serialize object. */
      private void writeObject(ObjectOutputStream out) throws IOException {
  
<span class="line-modified">!         // synchronize chilren</span>
          if (needsSyncChildren()) {
              synchronizeChildren();
          }
          // write object
          out.defaultWriteObject();
<span class="line-new-header">--- 993,11 ---</span>
      //
  
      /** Serialize object. */
      private void writeObject(ObjectOutputStream out) throws IOException {
  
<span class="line-modified">!         // synchronize children</span>
          if (needsSyncChildren()) {
              synchronizeChildren();
          }
          // write object
          out.defaultWriteObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1020,11 ***</span>
      } // readObject(ObjectInputStream)
  
      /*
       * a class to store some user data along with its handler
       */
<span class="line-modified">!     protected class UserDataRecord implements Serializable {</span>
          /** Serialization version. */
          private static final long serialVersionUID = 3258126977134310455L;
  
          Object fData;
          UserDataHandler fHandler;
<span class="line-new-header">--- 1018,11 ---</span>
      } // readObject(ObjectInputStream)
  
      /*
       * a class to store some user data along with its handler
       */
<span class="line-modified">!     class UserDataRecord implements Serializable {</span>
          /** Serialization version. */
          private static final long serialVersionUID = 3258126977134310455L;
  
          Object fData;
          UserDataHandler fHandler;
</pre>
<center><a href="PSVIDOMImplementationImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TextImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
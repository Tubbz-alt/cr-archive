<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InnerClasses.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LineNumber.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/JavaClass.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.classfile;
 21 
 22 import java.io.ByteArrayOutputStream;
 23 import java.io.DataOutputStream;
 24 import java.io.File;
 25 import java.io.FileOutputStream;
 26 import java.io.IOException;
 27 import java.io.OutputStream;
 28 import java.util.ArrayList;


 29 import java.util.List;
 30 import java.util.Set;
<span class="line-removed"> 31 import java.util.StringTokenizer;</span>
 32 import java.util.TreeSet;
 33 
 34 import com.sun.org.apache.bcel.internal.Const;
 35 import com.sun.org.apache.bcel.internal.generic.Type;
 36 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 37 import com.sun.org.apache.bcel.internal.util.ClassQueue;
 38 import com.sun.org.apache.bcel.internal.util.SyntheticRepository;
<span class="line-removed"> 39 import jdk.xml.internal.SecuritySupport;</span>
 40 
 41 /**
<span class="line-modified"> 42  * Represents a Java class, i.e., the data structures, constant pool, fields,</span>
<span class="line-modified"> 43  * methods and commands contained in a Java .class file. See &lt;a</span>
<span class="line-modified"> 44  * href=&quot;http://docs.oracle.com/javase/specs/&quot;&gt;JVM specification&lt;/a&gt; for</span>
<span class="line-modified"> 45  * details. The intent of this class is to represent a parsed or otherwise</span>
<span class="line-modified"> 46  * existing class file. Those interested in programatically generating classes</span>
 47  * should see the &lt;a href=&quot;../generic/ClassGen.html&quot;&gt;ClassGen&lt;/a&gt; class.
<span class="line-modified"> 48  *</span>
<span class="line-removed"> 49  * @version $Id: JavaClass.java 1750227 2016-06-25 21:47:10Z ggregory $</span>
 50  * @see com.sun.org.apache.bcel.internal.generic.ClassGen

 51  */
 52 public class JavaClass extends AccessFlags implements Cloneable, Node, Comparable&lt;JavaClass&gt; {
 53 
 54     private String file_name;
 55     private String package_name;
 56     private String source_file_name = &quot;&lt;Unknown&gt;&quot;;
 57     private int class_name_index;
 58     private int superclass_name_index;
 59     private String class_name;
 60     private String superclass_name;
 61     private int major;
 62     private int minor; // Compiler version
 63     private ConstantPool constant_pool; // Constant pool
 64     private int[] interfaces; // implemented interfaces
 65     private String[] interface_names;
 66     private Field[] fields; // Fields, i.e., variables of class
 67     private Method[] methods; // methods defined in the class
 68     private Attribute[] attributes; // attributes defined in the class
 69     private AnnotationEntry[] annotations;   // annotations defined on the class
 70     private byte source = HEAP; // Generated in memory
 71     private boolean isAnonymous = false;
 72     private boolean isNested = false;
 73     private boolean computedNestedTypeStatus = false;
 74     public static final byte HEAP = 1;
 75     public static final byte FILE = 2;
 76     public static final byte ZIP = 3;

 77 
 78     private static BCELComparator bcelComparator = new BCELComparator() {
 79 
 80         @Override
<span class="line-modified"> 81         public boolean equals(final Object o1, final Object o2) {</span>
 82             final JavaClass THIS = (JavaClass) o1;
 83             final JavaClass THAT = (JavaClass) o2;
<span class="line-modified"> 84             return THIS.getClassName().equals(THAT.getClassName());</span>
 85         }
 86 

 87         @Override
<span class="line-modified"> 88         public int hashCode(final Object o) {</span>
 89             final JavaClass THIS = (JavaClass) o;
 90             return THIS.getClassName().hashCode();
 91         }
 92     };
 93     /**
<span class="line-modified"> 94      * In cases where we go ahead and create something, use the default</span>
<span class="line-modified"> 95      * SyntheticRepository, because we don&#39;t know any better.</span>

 96      */
 97     private transient com.sun.org.apache.bcel.internal.util.Repository repository
 98             = SyntheticRepository.getInstance();
 99 

100     /**
101      * Constructor gets all contents as arguments.
102      *
103      * @param class_name_index Index into constant pool referencing a
104      * ConstantClass that represents this class.
105      * @param superclass_name_index Index into constant pool referencing a
106      * ConstantClass that represents this class&#39;s superclass.
107      * @param file_name File name
108      * @param major Major compiler version
109      * @param minor Minor compiler version
110      * @param access_flags Access rights defined by bit flags
111      * @param constant_pool Array of constants
112      * @param interfaces Implemented interfaces
113      * @param fields Class fields
114      * @param methods Class methods
115      * @param attributes Class attributes
116      * @param source Read from file or generated in memory?
117      */
118     public JavaClass(final int class_name_index, final int superclass_name_index,
119             final String file_name, final int major, final int minor, final int access_flags,
</pre>
<hr />
<pre>
160         if (index &lt; 0) {
161             package_name = &quot;&quot;;
162         } else {
163             package_name = class_name.substring(0, index);
164         }
165         if (superclass_name_index &gt; 0) {
166             // May be zero -&gt; class is java.lang.Object
167             superclass_name = constant_pool.getConstantString(superclass_name_index,
168                     Const.CONSTANT_Class);
169             superclass_name = Utility.compactClassName(superclass_name, false);
170         } else {
171             superclass_name = &quot;java.lang.Object&quot;;
172         }
173         interface_names = new String[interfaces.length];
174         for (int i = 0; i &lt; interfaces.length; i++) {
175             final String str = constant_pool.getConstantString(interfaces[i], Const.CONSTANT_Class);
176             interface_names[i] = Utility.compactClassName(str, false);
177         }
178     }
179 

180     /**
181      * Constructor gets all contents as arguments.
182      *
183      * @param class_name_index Class name
184      * @param superclass_name_index Superclass name
185      * @param file_name File name
186      * @param major Major compiler version
187      * @param minor Minor compiler version
188      * @param access_flags Access rights defined by bit flags
189      * @param constant_pool Array of constants
190      * @param interfaces Implemented interfaces
191      * @param fields Class fields
192      * @param methods Class methods
193      * @param attributes Class attributes
194      */
195     public JavaClass(final int class_name_index, final int superclass_name_index,
196             final String file_name, final int major, final int minor, final int access_flags,
197             final ConstantPool constant_pool, final int[] interfaces, final Field[] fields,
198             final Method[] methods, final Attribute[] attributes) {
199         this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
200                 constant_pool, interfaces, fields, methods, attributes, HEAP);
201     }
202 

203     /**
<span class="line-modified">204      * Called by objects that are traversing the nodes of the tree implicitly</span>
205      * defined by the contents of a Java class. I.e., the hierarchy of methods,
206      * fields, attributes, etc. spawns a tree of objects.
207      *
208      * @param v Visitor object
209      */
210     @Override
<span class="line-modified">211     public void accept(final Visitor v) {</span>
212         v.visitJavaClass(this);
213     }
214 










215     /**
216      * Dump class to a file.
217      *
218      * @param file Output file
219      * @throws IOException
220      */
221     public void dump(final File file) throws IOException {
222         final String parent = file.getParent();
223         if (parent != null) {
224             final File dir = new File(parent);
225             if (!dir.mkdirs()) { // either was not created or already existed
<span class="line-modified">226                 if (!SecuritySupport.isDirectory(dir)) {</span>
227                     throw new IOException(&quot;Could not create the directory &quot; + dir);
228                 }
229             }
230         }
231         try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {
232             dump(dos);
233         }
234     }
235 

236     /**
237      * Dump class to a file named file_name.
238      *
239      * @param _file_name Output file name
240      * @throws IOException
241      */
<span class="line-modified">242     public void dump(final String _file_name) throws IOException {</span>
243         dump(new File(_file_name));
244     }
245 

246     /**
247      * @return class in binary format
248      */
249     public byte[] getBytes() {
250         final ByteArrayOutputStream s = new ByteArrayOutputStream();
251         final DataOutputStream ds = new DataOutputStream(s);
252         try {
253             dump(ds);
254         } catch (final IOException e) {
255             System.err.println(&quot;Error dumping class: &quot; + e.getMessage());
256         } finally {
257             try {
258                 ds.close();
259             } catch (final IOException e2) {
260                 System.err.println(&quot;Error dumping class: &quot; + e2.getMessage());
261             }
262         }
263         return s.toByteArray();
264     }
265 

266     /**
267      * Dump Java class to output stream in binary format.
268      *
269      * @param file Output stream
270      * @throws IOException
271      */
<span class="line-modified">272     public void dump(final OutputStream file) throws IOException {</span>
273         dump(new DataOutputStream(file));
274     }
275 

276     /**
277      * Dump Java class to output stream in binary format.
278      *
279      * @param file Output stream
280      * @throws IOException
281      */
<span class="line-modified">282     private void dump(final DataOutputStream file) throws IOException {</span>
283         file.writeInt(Const.JVM_CLASSFILE_MAGIC);
284         file.writeShort(minor);
285         file.writeShort(major);
286         constant_pool.dump(file);
287         file.writeShort(super.getAccessFlags());
288         file.writeShort(class_name_index);
289         file.writeShort(superclass_name_index);
290         file.writeShort(interfaces.length);
291         for (final int interface1 : interfaces) {
292             file.writeShort(interface1);
293         }
294         file.writeShort(fields.length);
295         for (final Field field : fields) {
296             field.dump(file);
297         }
298         file.writeShort(methods.length);
299         for (final Method method : methods) {
300             method.dump(file);
301         }
302         if (attributes != null) {
303             file.writeShort(attributes.length);
304             for (final Attribute attribute : attributes) {
305                 attribute.dump(file);
306             }
307         } else {
308             file.writeShort(0);
309         }
310         file.flush();
311     }
312 

313     /**
314      * @return Attributes of the class.
315      */
316     public Attribute[] getAttributes() {
317         return attributes;
318     }
319 
320     /**
321      * @return Annotations on the class
322      * @since 6.0
323      */
324     public AnnotationEntry[] getAnnotationEntries() {
325         if (annotations == null) {
326             annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
327         }
328 
329         return annotations;
330     }
331 
332     /**
333      * @return Class name.
334      */
335     public String getClassName() {
336         return class_name;
337     }
338 

339     /**
340      * @return Package name.
341      */
342     public String getPackageName() {
343         return package_name;
344     }
345 

346     /**
347      * @return Class name index.
348      */
349     public int getClassNameIndex() {
350         return class_name_index;
351     }
352 

353     /**
354      * @return Constant pool.
355      */
356     public ConstantPool getConstantPool() {
357         return constant_pool;
358     }
359 

360     /**
<span class="line-modified">361      * @return Fields, i.e., variables of the class. Like the JVM spec mandates</span>
<span class="line-modified">362      * for the classfile format, these fields are those specific to this class,</span>
<span class="line-modified">363      * and not those of the superclass or superinterfaces.</span>
364      */
365     public Field[] getFields() {
366         return fields;
367     }
368 

369     /**
370      * @return File name of class, aka SourceFile attribute value
371      */
372     public String getFileName() {
373         return file_name;
374     }
375 

376     /**
377      * @return Names of implemented interfaces.
378      */
379     public String[] getInterfaceNames() {
380         return interface_names;
381     }
382 

383     /**
384      * @return Indices in constant pool of implemented interfaces.
385      */
386     public int[] getInterfaceIndices() {
387         return interfaces;
388     }
389 

390     /**
391      * @return Major number of class file version.
392      */
393     public int getMajor() {
394         return major;
395     }
396 

397     /**
398      * @return Methods of the class.
399      */
400     public Method[] getMethods() {
401         return methods;
402     }
403 

404     /**
<span class="line-modified">405      * @return A {@link Method} corresponding to java.lang.reflect.Method if any</span>

406      */
<span class="line-modified">407     public Method getMethod(final java.lang.reflect.Method m) {</span>
408         for (final Method method : methods) {
409             if (m.getName().equals(method.getName()) &amp;&amp; (m.getModifiers() == method.getModifiers())
410                     &amp;&amp; Type.getSignature(m).equals(method.getSignature())) {
411                 return method;
412             }
413         }
414         return null;
415     }
416 

417     /**
418      * @return Minor number of class file version.
419      */
420     public int getMinor() {
421         return minor;
422     }
423 

424     /**
425      * @return sbsolute path to file where this class was read from
426      */
427     public String getSourceFileName() {
428         return source_file_name;
429     }
430 

431     /**
<span class="line-modified">432      * returns the super class name of this class. In the case that this class</span>
<span class="line-modified">433      * is java.lang.Object, it will return itself (java.lang.Object). This is</span>
<span class="line-modified">434      * probably incorrect but isn&#39;t fixed at this time to not break existing</span>
<span class="line-removed">435      * clients.</span>
436      *
437      * @return Superclass name.
438      */
439     public String getSuperclassName() {
440         return superclass_name;
441     }
442 

443     /**
444      * @return Class name index.
445      */
446     public int getSuperclassNameIndex() {
447         return superclass_name_index;
448     }
449 
450     /**
451      * @param attributes .
452      */
<span class="line-modified">453     public void setAttributes(final Attribute[] attributes) {</span>
454         this.attributes = attributes;
455     }
456 

457     /**
458      * @param class_name .
459      */
<span class="line-modified">460     public void setClassName(final String class_name) {</span>
461         this.class_name = class_name;
462     }
463 

464     /**
465      * @param class_name_index .
466      */
<span class="line-modified">467     public void setClassNameIndex(final int class_name_index) {</span>
468         this.class_name_index = class_name_index;
469     }
470 

471     /**
472      * @param constant_pool .
473      */
<span class="line-modified">474     public void setConstantPool(final ConstantPool constant_pool) {</span>
475         this.constant_pool = constant_pool;
476     }
477 

478     /**
479      * @param fields .
480      */
<span class="line-modified">481     public void setFields(final Field[] fields) {</span>
482         this.fields = fields;
483     }
484 

485     /**
486      * Set File name of class, aka SourceFile attribute value
487      */
<span class="line-modified">488     public void setFileName(final String file_name) {</span>
489         this.file_name = file_name;
490     }
491 

492     /**
493      * @param interface_names .
494      */
<span class="line-modified">495     public void setInterfaceNames(final String[] interface_names) {</span>
496         this.interface_names = interface_names;
497     }
498 

499     /**
500      * @param interfaces .
501      */
<span class="line-modified">502     public void setInterfaces(final int[] interfaces) {</span>
503         this.interfaces = interfaces;
504     }
505 

506     /**
507      * @param major .
508      */
<span class="line-modified">509     public void setMajor(final int major) {</span>
510         this.major = major;
511     }
512 

513     /**
514      * @param methods .
515      */
<span class="line-modified">516     public void setMethods(final Method[] methods) {</span>
517         this.methods = methods;
518     }
519 

520     /**
521      * @param minor .
522      */
<span class="line-modified">523     public void setMinor(final int minor) {</span>
524         this.minor = minor;
525     }
526 

527     /**
528      * Set absolute path to file this class was read from.
529      */
<span class="line-modified">530     public void setSourceFileName(final String source_file_name) {</span>
531         this.source_file_name = source_file_name;
532     }
533 

534     /**
535      * @param superclass_name .
536      */
<span class="line-modified">537     public void setSuperclassName(final String superclass_name) {</span>
538         this.superclass_name = superclass_name;
539     }
540 

541     /**
542      * @param superclass_name_index .
543      */
<span class="line-modified">544     public void setSuperclassNameIndex(final int superclass_name_index) {</span>
545         this.superclass_name_index = superclass_name_index;
546     }
547 

548     /**
549      * @return String representing class contents.
550      */
551     @Override
552     public String toString() {
553         String access = Utility.accessToString(super.getAccessFlags(), true);
554         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
555         final StringBuilder buf = new StringBuilder(128);
556         buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(&quot; &quot;).append(
557                 class_name).append(&quot; extends &quot;).append(
<span class="line-modified">558                         Utility.compactClassName(superclass_name, false)).append(&#39;\n&#39;);</span>
559         final int size = interfaces.length;
560         if (size &gt; 0) {
561             buf.append(&quot;implements\t\t&quot;);
562             for (int i = 0; i &lt; size; i++) {
563                 buf.append(interface_names[i]);
564                 if (i &lt; size - 1) {
565                     buf.append(&quot;, &quot;);
566                 }
567             }
568             buf.append(&#39;\n&#39;);
569         }
<span class="line-modified">570         buf.append(&quot;filename\t\t&quot;).append(file_name).append(&#39;\n&#39;);</span>
571         buf.append(&quot;compiled from\t\t&quot;).append(source_file_name).append(&#39;\n&#39;);
572         buf.append(&quot;compiler version\t&quot;).append(major).append(&quot;.&quot;).append(minor).append(&#39;\n&#39;);
573         buf.append(&quot;access flags\t\t&quot;).append(super.getAccessFlags()).append(&#39;\n&#39;);
574         buf.append(&quot;constant pool\t\t&quot;).append(constant_pool.getLength()).append(&quot; entries\n&quot;);
575         buf.append(&quot;ACC_SUPER flag\t\t&quot;).append(isSuper()).append(&quot;\n&quot;);
576         if (attributes.length &gt; 0) {
577             buf.append(&quot;\nAttribute(s):\n&quot;);
578             for (final Attribute attribute : attributes) {
579                 buf.append(indent(attribute));
580             }
581         }
582         final AnnotationEntry[] annotations = getAnnotationEntries();
<span class="line-modified">583         if (annotations != null &amp;&amp; annotations.length &gt; 0) {</span>
584             buf.append(&quot;\nAnnotation(s):\n&quot;);
585             for (final AnnotationEntry annotation : annotations) {
586                 buf.append(indent(annotation));
587             }
588         }
589         if (fields.length &gt; 0) {
590             buf.append(&quot;\n&quot;).append(fields.length).append(&quot; fields:\n&quot;);
591             for (final Field field : fields) {
592                 buf.append(&quot;\t&quot;).append(field).append(&#39;\n&#39;);
593             }
594         }
595         if (methods.length &gt; 0) {
596             buf.append(&quot;\n&quot;).append(methods.length).append(&quot; methods:\n&quot;);
597             for (final Method method : methods) {
598                 buf.append(&quot;\t&quot;).append(method).append(&#39;\n&#39;);
599             }
600         }
601         return buf.toString();
602     }
603 
<span class="line-modified">604     private static String indent(final Object obj) {</span>

605         final StringTokenizer tok = new StringTokenizer(obj.toString(), &quot;\n&quot;);
606         final StringBuilder buf = new StringBuilder();
607         while (tok.hasMoreTokens()) {
608             buf.append(&quot;\t&quot;).append(tok.nextToken()).append(&quot;\n&quot;);
609         }
610         return buf.toString();
611     }
612 

613     /**
614      * @return deep copy of this class
615      */
616     public JavaClass copy() {
617         JavaClass c = null;
618         try {
619             c = (JavaClass) clone();
620             c.constant_pool = constant_pool.copy();
621             c.interfaces = interfaces.clone();
622             c.interface_names = interface_names.clone();
623             c.fields = new Field[fields.length];
624             for (int i = 0; i &lt; fields.length; i++) {
625                 c.fields[i] = fields[i].copy(c.constant_pool);
626             }
627             c.methods = new Method[methods.length];
628             for (int i = 0; i &lt; methods.length; i++) {
629                 c.methods[i] = methods[i].copy(c.constant_pool);
630             }
631             c.attributes = new Attribute[attributes.length];
632             for (int i = 0; i &lt; attributes.length; i++) {
633                 c.attributes[i] = attributes[i].copy(c.constant_pool);
634             }
635         } catch (final CloneNotSupportedException e) {
636             // TODO should this throw?
637         }
638         return c;
639     }
640 

641     public final boolean isSuper() {
642         return (super.getAccessFlags() &amp; Const.ACC_SUPER) != 0;
643     }
644 

645     public final boolean isClass() {
646         return (super.getAccessFlags() &amp; Const.ACC_INTERFACE) == 0;
647     }
648 
649     /**
650      * @since 6.0
651      */
652     public final boolean isAnonymous() {
653         computeNestedTypeStatus();
654         return this.isAnonymous;
655     }
656 
657     /**
658      * @since 6.0
659      */
660     public final boolean isNested() {
661         computeNestedTypeStatus();
662         return this.isNested;
663     }
664 
665     private void computeNestedTypeStatus() {
666         if (computedNestedTypeStatus) {
667             return;
668         }
669         for (final Attribute attribute : this.attributes) {
<span class="line-modified">670             if (attribute instanceof InnerClasses) {</span>
<span class="line-modified">671                 final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();</span>
<span class="line-modified">672                 for (final InnerClass innerClasse : innerClasses) {</span>
<span class="line-modified">673                     boolean innerClassAttributeRefersToMe = false;</span>
<span class="line-modified">674                     String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),</span>
<span class="line-modified">675                             Const.CONSTANT_Class);</span>
<span class="line-modified">676                     inner_class_name = Utility.compactClassName(inner_class_name);</span>
<span class="line-modified">677                     if (inner_class_name.equals(getClassName())) {</span>
<span class="line-modified">678                         innerClassAttributeRefersToMe = true;</span>
<span class="line-modified">679                     }</span>
<span class="line-modified">680                     if (innerClassAttributeRefersToMe) {</span>
<span class="line-modified">681                         this.isNested = true;</span>
<span class="line-modified">682                         if (innerClasse.getInnerNameIndex() == 0) {</span>
<span class="line-modified">683                             this.isAnonymous = true;</span>
<span class="line-modified">684                         }</span>
<span class="line-modified">685                     }</span>
<span class="line-modified">686                 }</span>
<span class="line-modified">687             }</span>
688         }
689         this.computedNestedTypeStatus = true;
690     }
691 
<span class="line-modified">692     /**</span>
<span class="line-modified">693      * @return returns either HEAP (generated), FILE, or ZIP</span>
694      */
695     public final byte getSource() {
696         return source;
697     }
698 


699     /**
<span class="line-modified">700      * ******************* New repository functionality ********************</span>
<span class="line-modified">701      */</span>
<span class="line-removed">702     /**</span>
<span class="line-removed">703      * Gets the ClassRepository which holds its definition. By default this is</span>
<span class="line-removed">704      * the same as SyntheticRepository.getInstance();</span>
705      */
706     public com.sun.org.apache.bcel.internal.util.Repository getRepository() {
707         return repository;
708     }
709 

710     /**
<span class="line-modified">711      * Sets the ClassRepository which loaded the JavaClass. Should be called</span>
<span class="line-modified">712      * immediately after parsing is done.</span>
713      */
<span class="line-modified">714     public void setRepository(final com.sun.org.apache.bcel.internal.util.Repository repository) {</span>
715         this.repository = repository;
716     }
717 
<span class="line-modified">718     /**</span>
<span class="line-modified">719      * Equivalent to runtime &quot;instanceof&quot; operator.</span>
720      *
721      * @return true if this JavaClass is derived from the super class
<span class="line-modified">722      * @throws ClassNotFoundException if superclasses or superinterfaces of this</span>
<span class="line-modified">723      * object can&#39;t be found</span>
724      */
<span class="line-modified">725     public final boolean instanceOf(final JavaClass super_class) throws ClassNotFoundException {</span>
726         if (this.equals(super_class)) {
727             return true;
728         }
729         final JavaClass[] super_classes = getSuperClasses();
730         for (final JavaClass super_classe : super_classes) {
731             if (super_classe.equals(super_class)) {
732                 return true;
733             }
734         }
735         if (super_class.isInterface()) {
736             return implementationOf(super_class);
737         }
738         return false;
739     }
740 

741     /**
742      * @return true, if this class is an implementation of interface inter
<span class="line-modified">743      * @throws ClassNotFoundException if superclasses or superinterfaces of this</span>
<span class="line-modified">744      * class can&#39;t be found</span>
745      */
<span class="line-modified">746     public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {</span>
747         if (!inter.isInterface()) {
748             throw new IllegalArgumentException(inter.getClassName() + &quot; is no interface&quot;);
749         }
750         if (this.equals(inter)) {
751             return true;
752         }
753         final JavaClass[] super_interfaces = getAllInterfaces();
754         for (final JavaClass super_interface : super_interfaces) {
755             if (super_interface.equals(inter)) {
756                 return true;
757             }
758         }
759         return false;
760     }
761 

762     /**
<span class="line-modified">763      * @return the superclass for this JavaClass object, or null if this is</span>
<span class="line-modified">764      * java.lang.Object</span>
765      * @throws ClassNotFoundException if the superclass can&#39;t be found
766      */
767     public JavaClass getSuperClass() throws ClassNotFoundException {
768         if (&quot;java.lang.Object&quot;.equals(getClassName())) {
769             return null;
770         }
771         return repository.loadClass(getSuperclassName());
772     }
773 

774     /**
775      * @return list of super classes of this class in ascending order, i.e.,
776      * java.lang.Object is always the last element
777      * @throws ClassNotFoundException if any of the superclasses can&#39;t be found
778      */
779     public JavaClass[] getSuperClasses() throws ClassNotFoundException {
780         JavaClass clazz = this;
781         final List&lt;JavaClass&gt; allSuperClasses = new ArrayList&lt;&gt;();
782         for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {
783             allSuperClasses.add(clazz);
784         }
785         return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);
786     }
787 

788     /**
789      * Get interfaces directly implemented by this JavaClass.
790      */
791     public JavaClass[] getInterfaces() throws ClassNotFoundException {
792         final String[] _interfaces = getInterfaceNames();
793         final JavaClass[] classes = new JavaClass[_interfaces.length];
794         for (int i = 0; i &lt; _interfaces.length; i++) {
795             classes[i] = repository.loadClass(_interfaces[i]);
796         }
797         return classes;
798     }
799 

800     /**
801      * Get all interfaces implemented by this JavaClass (transitively).
802      */
803     public JavaClass[] getAllInterfaces() throws ClassNotFoundException {
804         final ClassQueue queue = new ClassQueue();
805         final Set&lt;JavaClass&gt; allInterfaces = new TreeSet&lt;&gt;();
806         queue.enqueue(this);
807         while (!queue.empty()) {
808             final JavaClass clazz = queue.dequeue();
809             final JavaClass souper = clazz.getSuperClass();
810             final JavaClass[] _interfaces = clazz.getInterfaces();
811             if (clazz.isInterface()) {
812                 allInterfaces.add(clazz);
813             } else {
814                 if (souper != null) {
815                     queue.enqueue(souper);
816                 }
817             }
818             for (final JavaClass _interface : _interfaces) {
819                 queue.enqueue(_interface);
820             }
821         }
822         return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
823     }
824 

825     /**
826      * @return Comparison strategy object
827      */
828     public static BCELComparator getComparator() {
829         return bcelComparator;
830     }
831 

832     /**
833      * @param comparator Comparison strategy object
834      */
<span class="line-modified">835     public static void setComparator(final BCELComparator comparator) {</span>
836         bcelComparator = comparator;
837     }
838 

839     /**
<span class="line-modified">840      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">841      * JavaClass objects are said to be equal when their class names are equal.</span>

842      *
843      * @see java.lang.Object#equals(java.lang.Object)
844      */
845     @Override
<span class="line-modified">846     public boolean equals(final Object obj) {</span>
847         return bcelComparator.equals(this, obj);
848     }
849 

850     /**
<span class="line-modified">851      * Return the natural ordering of two JavaClasses. This ordering is based on</span>
<span class="line-modified">852      * the class name</span>
<span class="line-removed">853      *</span>
854      * @since 6.0
855      */
856     @Override
<span class="line-modified">857     public int compareTo(final JavaClass obj) {</span>
858         return getClassName().compareTo(obj.getClassName());
859     }
860 

861     /**
<span class="line-modified">862      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">863      * return the hashcode of the class name.</span>
864      *
865      * @see java.lang.Object#hashCode()
866      */
867     @Override
868     public int hashCode() {
869         return bcelComparator.hashCode(this);
870     }
871 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.classfile;
 21 
 22 import java.io.ByteArrayOutputStream;
 23 import java.io.DataOutputStream;
 24 import java.io.File;
 25 import java.io.FileOutputStream;
 26 import java.io.IOException;
 27 import java.io.OutputStream;
 28 import java.util.ArrayList;
<span class="line-added"> 29 import java.util.Objects;</span>
<span class="line-added"> 30 import java.util.StringTokenizer;</span>
 31 import java.util.List;
 32 import java.util.Set;

 33 import java.util.TreeSet;
 34 
 35 import com.sun.org.apache.bcel.internal.Const;
 36 import com.sun.org.apache.bcel.internal.generic.Type;
 37 import com.sun.org.apache.bcel.internal.util.BCELComparator;
 38 import com.sun.org.apache.bcel.internal.util.ClassQueue;
 39 import com.sun.org.apache.bcel.internal.util.SyntheticRepository;

 40 
 41 /**
<span class="line-modified"> 42  * Represents a Java class, i.e., the data structures, constant pool,</span>
<span class="line-modified"> 43  * fields, methods and commands contained in a Java .class file.</span>
<span class="line-modified"> 44  * See &lt;a href=&quot;http://docs.oracle.com/javase/specs/&quot;&gt;JVM specification&lt;/a&gt; for details.</span>
<span class="line-modified"> 45  * The intent of this class is to represent a parsed or otherwise existing</span>
<span class="line-modified"> 46  * class file.  Those interested in programatically generating classes</span>
 47  * should see the &lt;a href=&quot;../generic/ClassGen.html&quot;&gt;ClassGen&lt;/a&gt; class.
<span class="line-modified"> 48 </span>

 49  * @see com.sun.org.apache.bcel.internal.generic.ClassGen
<span class="line-added"> 50  * @LastModified: Jan 2020</span>
 51  */
 52 public class JavaClass extends AccessFlags implements Cloneable, Node, Comparable&lt;JavaClass&gt; {
 53 
 54     private String file_name;
 55     private String package_name;
 56     private String source_file_name = &quot;&lt;Unknown&gt;&quot;;
 57     private int class_name_index;
 58     private int superclass_name_index;
 59     private String class_name;
 60     private String superclass_name;
 61     private int major;
 62     private int minor; // Compiler version
 63     private ConstantPool constant_pool; // Constant pool
 64     private int[] interfaces; // implemented interfaces
 65     private String[] interface_names;
 66     private Field[] fields; // Fields, i.e., variables of class
 67     private Method[] methods; // methods defined in the class
 68     private Attribute[] attributes; // attributes defined in the class
 69     private AnnotationEntry[] annotations;   // annotations defined on the class
 70     private byte source = HEAP; // Generated in memory
 71     private boolean isAnonymous = false;
 72     private boolean isNested = false;
 73     private boolean computedNestedTypeStatus = false;
 74     public static final byte HEAP = 1;
 75     public static final byte FILE = 2;
 76     public static final byte ZIP = 3;
<span class="line-added"> 77     private static final boolean debug = false;</span>
 78 
 79     private static BCELComparator bcelComparator = new BCELComparator() {
 80 
 81         @Override
<span class="line-modified"> 82         public boolean equals( final Object o1, final Object o2 ) {</span>
 83             final JavaClass THIS = (JavaClass) o1;
 84             final JavaClass THAT = (JavaClass) o2;
<span class="line-modified"> 85             return Objects.equals(THIS.getClassName(), THAT.getClassName());</span>
 86         }
 87 
<span class="line-added"> 88 </span>
 89         @Override
<span class="line-modified"> 90         public int hashCode( final Object o ) {</span>
 91             final JavaClass THIS = (JavaClass) o;
 92             return THIS.getClassName().hashCode();
 93         }
 94     };
 95     /**
<span class="line-modified"> 96      * In cases where we go ahead and create something,</span>
<span class="line-modified"> 97      * use the default SyntheticRepository, because we</span>
<span class="line-added"> 98      * don&#39;t know any better.</span>
 99      */
100     private transient com.sun.org.apache.bcel.internal.util.Repository repository
101             = SyntheticRepository.getInstance();
102 
<span class="line-added">103 </span>
104     /**
105      * Constructor gets all contents as arguments.
106      *
107      * @param class_name_index Index into constant pool referencing a
108      * ConstantClass that represents this class.
109      * @param superclass_name_index Index into constant pool referencing a
110      * ConstantClass that represents this class&#39;s superclass.
111      * @param file_name File name
112      * @param major Major compiler version
113      * @param minor Minor compiler version
114      * @param access_flags Access rights defined by bit flags
115      * @param constant_pool Array of constants
116      * @param interfaces Implemented interfaces
117      * @param fields Class fields
118      * @param methods Class methods
119      * @param attributes Class attributes
120      * @param source Read from file or generated in memory?
121      */
122     public JavaClass(final int class_name_index, final int superclass_name_index,
123             final String file_name, final int major, final int minor, final int access_flags,
</pre>
<hr />
<pre>
164         if (index &lt; 0) {
165             package_name = &quot;&quot;;
166         } else {
167             package_name = class_name.substring(0, index);
168         }
169         if (superclass_name_index &gt; 0) {
170             // May be zero -&gt; class is java.lang.Object
171             superclass_name = constant_pool.getConstantString(superclass_name_index,
172                     Const.CONSTANT_Class);
173             superclass_name = Utility.compactClassName(superclass_name, false);
174         } else {
175             superclass_name = &quot;java.lang.Object&quot;;
176         }
177         interface_names = new String[interfaces.length];
178         for (int i = 0; i &lt; interfaces.length; i++) {
179             final String str = constant_pool.getConstantString(interfaces[i], Const.CONSTANT_Class);
180             interface_names[i] = Utility.compactClassName(str, false);
181         }
182     }
183 
<span class="line-added">184 </span>
185     /**
186      * Constructor gets all contents as arguments.
187      *
188      * @param class_name_index Class name
189      * @param superclass_name_index Superclass name
190      * @param file_name File name
191      * @param major Major compiler version
192      * @param minor Minor compiler version
193      * @param access_flags Access rights defined by bit flags
194      * @param constant_pool Array of constants
195      * @param interfaces Implemented interfaces
196      * @param fields Class fields
197      * @param methods Class methods
198      * @param attributes Class attributes
199      */
200     public JavaClass(final int class_name_index, final int superclass_name_index,
201             final String file_name, final int major, final int minor, final int access_flags,
202             final ConstantPool constant_pool, final int[] interfaces, final Field[] fields,
203             final Method[] methods, final Attribute[] attributes) {
204         this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,
205                 constant_pool, interfaces, fields, methods, attributes, HEAP);
206     }
207 
<span class="line-added">208 </span>
209     /**
<span class="line-modified">210      * Called by objects that are traversing the nodes of the tree implicitely</span>
211      * defined by the contents of a Java class. I.e., the hierarchy of methods,
212      * fields, attributes, etc. spawns a tree of objects.
213      *
214      * @param v Visitor object
215      */
216     @Override
<span class="line-modified">217     public void accept( final Visitor v ) {</span>
218         v.visitJavaClass(this);
219     }
220 
<span class="line-added">221 </span>
<span class="line-added">222     /* Print debug information depending on `JavaClass.debug&#39;</span>
<span class="line-added">223      */</span>
<span class="line-added">224     static void Debug( final String str ) {</span>
<span class="line-added">225         if (debug) {</span>
<span class="line-added">226             System.out.println(str);</span>
<span class="line-added">227         }</span>
<span class="line-added">228     }</span>
<span class="line-added">229 </span>
<span class="line-added">230 </span>
231     /**
232      * Dump class to a file.
233      *
234      * @param file Output file
235      * @throws IOException
236      */
237     public void dump(final File file) throws IOException {
238         final String parent = file.getParent();
239         if (parent != null) {
240             final File dir = new File(parent);
241             if (!dir.mkdirs()) { // either was not created or already existed
<span class="line-modified">242                 if (!dir.isDirectory()) {</span>
243                     throw new IOException(&quot;Could not create the directory &quot; + dir);
244                 }
245             }
246         }
247         try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {
248             dump(dos);
249         }
250     }
251 
<span class="line-added">252 </span>
253     /**
254      * Dump class to a file named file_name.
255      *
256      * @param _file_name Output file name
257      * @throws IOException
258      */
<span class="line-modified">259     public void dump( final String _file_name ) throws IOException {</span>
260         dump(new File(_file_name));
261     }
262 
<span class="line-added">263 </span>
264     /**
265      * @return class in binary format
266      */
267     public byte[] getBytes() {
268         final ByteArrayOutputStream s = new ByteArrayOutputStream();
269         final DataOutputStream ds = new DataOutputStream(s);
270         try {
271             dump(ds);
272         } catch (final IOException e) {
273             System.err.println(&quot;Error dumping class: &quot; + e.getMessage());
274         } finally {
275             try {
276                 ds.close();
277             } catch (final IOException e2) {
278                 System.err.println(&quot;Error dumping class: &quot; + e2.getMessage());
279             }
280         }
281         return s.toByteArray();
282     }
283 
<span class="line-added">284 </span>
285     /**
286      * Dump Java class to output stream in binary format.
287      *
288      * @param file Output stream
289      * @throws IOException
290      */
<span class="line-modified">291     public void dump( final OutputStream file ) throws IOException {</span>
292         dump(new DataOutputStream(file));
293     }
294 
<span class="line-added">295 </span>
296     /**
297      * Dump Java class to output stream in binary format.
298      *
299      * @param file Output stream
300      * @throws IOException
301      */
<span class="line-modified">302     public void dump( final DataOutputStream file ) throws IOException {</span>
303         file.writeInt(Const.JVM_CLASSFILE_MAGIC);
304         file.writeShort(minor);
305         file.writeShort(major);
306         constant_pool.dump(file);
307         file.writeShort(super.getAccessFlags());
308         file.writeShort(class_name_index);
309         file.writeShort(superclass_name_index);
310         file.writeShort(interfaces.length);
311         for (final int interface1 : interfaces) {
312             file.writeShort(interface1);
313         }
314         file.writeShort(fields.length);
315         for (final Field field : fields) {
316             field.dump(file);
317         }
318         file.writeShort(methods.length);
319         for (final Method method : methods) {
320             method.dump(file);
321         }
322         if (attributes != null) {
323             file.writeShort(attributes.length);
324             for (final Attribute attribute : attributes) {
325                 attribute.dump(file);
326             }
327         } else {
328             file.writeShort(0);
329         }
330         file.flush();
331     }
332 
<span class="line-added">333 </span>
334     /**
335      * @return Attributes of the class.
336      */
337     public Attribute[] getAttributes() {
338         return attributes;
339     }
340 
341     /**
342      * @return Annotations on the class
343      * @since 6.0
344      */
345     public AnnotationEntry[] getAnnotationEntries() {
346         if (annotations == null) {
347             annotations = AnnotationEntry.createAnnotationEntries(getAttributes());
348         }
349 
350         return annotations;
351     }
352 
353     /**
354      * @return Class name.
355      */
356     public String getClassName() {
357         return class_name;
358     }
359 
<span class="line-added">360 </span>
361     /**
362      * @return Package name.
363      */
364     public String getPackageName() {
365         return package_name;
366     }
367 
<span class="line-added">368 </span>
369     /**
370      * @return Class name index.
371      */
372     public int getClassNameIndex() {
373         return class_name_index;
374     }
375 
<span class="line-added">376 </span>
377     /**
378      * @return Constant pool.
379      */
380     public ConstantPool getConstantPool() {
381         return constant_pool;
382     }
383 
<span class="line-added">384 </span>
385     /**
<span class="line-modified">386      * @return Fields, i.e., variables of the class. Like the JVM spec</span>
<span class="line-modified">387      * mandates for the classfile format, these fields are those specific to</span>
<span class="line-modified">388      * this class, and not those of the superclass or superinterfaces.</span>
389      */
390     public Field[] getFields() {
391         return fields;
392     }
393 
<span class="line-added">394 </span>
395     /**
396      * @return File name of class, aka SourceFile attribute value
397      */
398     public String getFileName() {
399         return file_name;
400     }
401 
<span class="line-added">402 </span>
403     /**
404      * @return Names of implemented interfaces.
405      */
406     public String[] getInterfaceNames() {
407         return interface_names;
408     }
409 
<span class="line-added">410 </span>
411     /**
412      * @return Indices in constant pool of implemented interfaces.
413      */
414     public int[] getInterfaceIndices() {
415         return interfaces;
416     }
417 
<span class="line-added">418 </span>
419     /**
420      * @return Major number of class file version.
421      */
422     public int getMajor() {
423         return major;
424     }
425 
<span class="line-added">426 </span>
427     /**
428      * @return Methods of the class.
429      */
430     public Method[] getMethods() {
431         return methods;
432     }
433 
<span class="line-added">434 </span>
435     /**
<span class="line-modified">436      * @return A {@link Method} corresponding to</span>
<span class="line-added">437      * java.lang.reflect.Method if any</span>
438      */
<span class="line-modified">439     public Method getMethod( final java.lang.reflect.Method m ) {</span>
440         for (final Method method : methods) {
441             if (m.getName().equals(method.getName()) &amp;&amp; (m.getModifiers() == method.getModifiers())
442                     &amp;&amp; Type.getSignature(m).equals(method.getSignature())) {
443                 return method;
444             }
445         }
446         return null;
447     }
448 
<span class="line-added">449 </span>
450     /**
451      * @return Minor number of class file version.
452      */
453     public int getMinor() {
454         return minor;
455     }
456 
<span class="line-added">457 </span>
458     /**
459      * @return sbsolute path to file where this class was read from
460      */
461     public String getSourceFileName() {
462         return source_file_name;
463     }
464 
<span class="line-added">465 </span>
466     /**
<span class="line-modified">467      * returns the super class name of this class. In the case that this class is</span>
<span class="line-modified">468      * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect</span>
<span class="line-modified">469      * but isn&#39;t fixed at this time to not break existing clients.</span>

470      *
471      * @return Superclass name.
472      */
473     public String getSuperclassName() {
474         return superclass_name;
475     }
476 
<span class="line-added">477 </span>
478     /**
479      * @return Class name index.
480      */
481     public int getSuperclassNameIndex() {
482         return superclass_name_index;
483     }
484 
485     /**
486      * @param attributes .
487      */
<span class="line-modified">488     public void setAttributes( final Attribute[] attributes ) {</span>
489         this.attributes = attributes;
490     }
491 
<span class="line-added">492 </span>
493     /**
494      * @param class_name .
495      */
<span class="line-modified">496     public void setClassName( final String class_name ) {</span>
497         this.class_name = class_name;
498     }
499 
<span class="line-added">500 </span>
501     /**
502      * @param class_name_index .
503      */
<span class="line-modified">504     public void setClassNameIndex( final int class_name_index ) {</span>
505         this.class_name_index = class_name_index;
506     }
507 
<span class="line-added">508 </span>
509     /**
510      * @param constant_pool .
511      */
<span class="line-modified">512     public void setConstantPool( final ConstantPool constant_pool ) {</span>
513         this.constant_pool = constant_pool;
514     }
515 
<span class="line-added">516 </span>
517     /**
518      * @param fields .
519      */
<span class="line-modified">520     public void setFields( final Field[] fields ) {</span>
521         this.fields = fields;
522     }
523 
<span class="line-added">524 </span>
525     /**
526      * Set File name of class, aka SourceFile attribute value
527      */
<span class="line-modified">528     public void setFileName( final String file_name ) {</span>
529         this.file_name = file_name;
530     }
531 
<span class="line-added">532 </span>
533     /**
534      * @param interface_names .
535      */
<span class="line-modified">536     public void setInterfaceNames( final String[] interface_names ) {</span>
537         this.interface_names = interface_names;
538     }
539 
<span class="line-added">540 </span>
541     /**
542      * @param interfaces .
543      */
<span class="line-modified">544     public void setInterfaces( final int[] interfaces ) {</span>
545         this.interfaces = interfaces;
546     }
547 
<span class="line-added">548 </span>
549     /**
550      * @param major .
551      */
<span class="line-modified">552     public void setMajor( final int major ) {</span>
553         this.major = major;
554     }
555 
<span class="line-added">556 </span>
557     /**
558      * @param methods .
559      */
<span class="line-modified">560     public void setMethods( final Method[] methods ) {</span>
561         this.methods = methods;
562     }
563 
<span class="line-added">564 </span>
565     /**
566      * @param minor .
567      */
<span class="line-modified">568     public void setMinor( final int minor ) {</span>
569         this.minor = minor;
570     }
571 
<span class="line-added">572 </span>
573     /**
574      * Set absolute path to file this class was read from.
575      */
<span class="line-modified">576     public void setSourceFileName( final String source_file_name ) {</span>
577         this.source_file_name = source_file_name;
578     }
579 
<span class="line-added">580 </span>
581     /**
582      * @param superclass_name .
583      */
<span class="line-modified">584     public void setSuperclassName( final String superclass_name ) {</span>
585         this.superclass_name = superclass_name;
586     }
587 
<span class="line-added">588 </span>
589     /**
590      * @param superclass_name_index .
591      */
<span class="line-modified">592     public void setSuperclassNameIndex( final int superclass_name_index ) {</span>
593         this.superclass_name_index = superclass_name_index;
594     }
595 
<span class="line-added">596 </span>
597     /**
598      * @return String representing class contents.
599      */
600     @Override
601     public String toString() {
602         String access = Utility.accessToString(super.getAccessFlags(), true);
603         access = access.isEmpty() ? &quot;&quot; : (access + &quot; &quot;);
604         final StringBuilder buf = new StringBuilder(128);
605         buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(&quot; &quot;).append(
606                 class_name).append(&quot; extends &quot;).append(
<span class="line-modified">607                 Utility.compactClassName(superclass_name, false)).append(&#39;\n&#39;);</span>
608         final int size = interfaces.length;
609         if (size &gt; 0) {
610             buf.append(&quot;implements\t\t&quot;);
611             for (int i = 0; i &lt; size; i++) {
612                 buf.append(interface_names[i]);
613                 if (i &lt; size - 1) {
614                     buf.append(&quot;, &quot;);
615                 }
616             }
617             buf.append(&#39;\n&#39;);
618         }
<span class="line-modified">619         buf.append(&quot;file name\t\t&quot;).append(file_name).append(&#39;\n&#39;);</span>
620         buf.append(&quot;compiled from\t\t&quot;).append(source_file_name).append(&#39;\n&#39;);
621         buf.append(&quot;compiler version\t&quot;).append(major).append(&quot;.&quot;).append(minor).append(&#39;\n&#39;);
622         buf.append(&quot;access flags\t\t&quot;).append(super.getAccessFlags()).append(&#39;\n&#39;);
623         buf.append(&quot;constant pool\t\t&quot;).append(constant_pool.getLength()).append(&quot; entries\n&quot;);
624         buf.append(&quot;ACC_SUPER flag\t\t&quot;).append(isSuper()).append(&quot;\n&quot;);
625         if (attributes.length &gt; 0) {
626             buf.append(&quot;\nAttribute(s):\n&quot;);
627             for (final Attribute attribute : attributes) {
628                 buf.append(indent(attribute));
629             }
630         }
631         final AnnotationEntry[] annotations = getAnnotationEntries();
<span class="line-modified">632         if (annotations!=null &amp;&amp; annotations.length&gt;0) {</span>
633             buf.append(&quot;\nAnnotation(s):\n&quot;);
634             for (final AnnotationEntry annotation : annotations) {
635                 buf.append(indent(annotation));
636             }
637         }
638         if (fields.length &gt; 0) {
639             buf.append(&quot;\n&quot;).append(fields.length).append(&quot; fields:\n&quot;);
640             for (final Field field : fields) {
641                 buf.append(&quot;\t&quot;).append(field).append(&#39;\n&#39;);
642             }
643         }
644         if (methods.length &gt; 0) {
645             buf.append(&quot;\n&quot;).append(methods.length).append(&quot; methods:\n&quot;);
646             for (final Method method : methods) {
647                 buf.append(&quot;\t&quot;).append(method).append(&#39;\n&#39;);
648             }
649         }
650         return buf.toString();
651     }
652 
<span class="line-modified">653 </span>
<span class="line-added">654     private static String indent( final Object obj ) {</span>
655         final StringTokenizer tok = new StringTokenizer(obj.toString(), &quot;\n&quot;);
656         final StringBuilder buf = new StringBuilder();
657         while (tok.hasMoreTokens()) {
658             buf.append(&quot;\t&quot;).append(tok.nextToken()).append(&quot;\n&quot;);
659         }
660         return buf.toString();
661     }
662 
<span class="line-added">663 </span>
664     /**
665      * @return deep copy of this class
666      */
667     public JavaClass copy() {
668         JavaClass c = null;
669         try {
670             c = (JavaClass) clone();
671             c.constant_pool = constant_pool.copy();
672             c.interfaces = interfaces.clone();
673             c.interface_names = interface_names.clone();
674             c.fields = new Field[fields.length];
675             for (int i = 0; i &lt; fields.length; i++) {
676                 c.fields[i] = fields[i].copy(c.constant_pool);
677             }
678             c.methods = new Method[methods.length];
679             for (int i = 0; i &lt; methods.length; i++) {
680                 c.methods[i] = methods[i].copy(c.constant_pool);
681             }
682             c.attributes = new Attribute[attributes.length];
683             for (int i = 0; i &lt; attributes.length; i++) {
684                 c.attributes[i] = attributes[i].copy(c.constant_pool);
685             }
686         } catch (final CloneNotSupportedException e) {
687             // TODO should this throw?
688         }
689         return c;
690     }
691 
<span class="line-added">692 </span>
693     public final boolean isSuper() {
694         return (super.getAccessFlags() &amp; Const.ACC_SUPER) != 0;
695     }
696 
<span class="line-added">697 </span>
698     public final boolean isClass() {
699         return (super.getAccessFlags() &amp; Const.ACC_INTERFACE) == 0;
700     }
701 
702     /**
703      * @since 6.0
704      */
705     public final boolean isAnonymous() {
706         computeNestedTypeStatus();
707         return this.isAnonymous;
708     }
709 
710     /**
711      * @since 6.0
712      */
713     public final boolean isNested() {
714         computeNestedTypeStatus();
715         return this.isNested;
716     }
717 
718     private void computeNestedTypeStatus() {
719         if (computedNestedTypeStatus) {
720             return;
721         }
722         for (final Attribute attribute : this.attributes) {
<span class="line-modified">723               if (attribute instanceof InnerClasses) {</span>
<span class="line-modified">724                   final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();</span>
<span class="line-modified">725                   for (final InnerClass innerClasse : innerClasses) {</span>
<span class="line-modified">726                       boolean innerClassAttributeRefersToMe = false;</span>
<span class="line-modified">727                       String inner_class_name = constant_pool.getConstantString(innerClasse.getInnerClassIndex(),</span>
<span class="line-modified">728                                  Const.CONSTANT_Class);</span>
<span class="line-modified">729                       inner_class_name = Utility.compactClassName(inner_class_name, false);</span>
<span class="line-modified">730                       if (inner_class_name.equals(getClassName())) {</span>
<span class="line-modified">731                           innerClassAttributeRefersToMe = true;</span>
<span class="line-modified">732                       }</span>
<span class="line-modified">733                       if (innerClassAttributeRefersToMe) {</span>
<span class="line-modified">734                           this.isNested = true;</span>
<span class="line-modified">735                           if (innerClasse.getInnerNameIndex() == 0) {</span>
<span class="line-modified">736                               this.isAnonymous = true;</span>
<span class="line-modified">737                           }</span>
<span class="line-modified">738                       }</span>
<span class="line-modified">739                   }</span>
<span class="line-modified">740               }</span>
741         }
742         this.computedNestedTypeStatus = true;
743     }
744 
<span class="line-modified">745 </span>
<span class="line-modified">746     /** @return returns either HEAP (generated), FILE, or ZIP</span>
747      */
748     public final byte getSource() {
749         return source;
750     }
751 
<span class="line-added">752 </span>
<span class="line-added">753     /********************* New repository functionality *********************/</span>
754     /**
<span class="line-modified">755      * Gets the ClassRepository which holds its definition. By default</span>
<span class="line-modified">756      * this is the same as SyntheticRepository.getInstance();</span>



757      */
758     public com.sun.org.apache.bcel.internal.util.Repository getRepository() {
759         return repository;
760     }
761 
<span class="line-added">762 </span>
763     /**
<span class="line-modified">764      * Sets the ClassRepository which loaded the JavaClass.</span>
<span class="line-modified">765      * Should be called immediately after parsing is done.</span>
766      */
<span class="line-modified">767     public void setRepository( final com.sun.org.apache.bcel.internal.util.Repository repository ) { // TODO make protected?</span>
768         this.repository = repository;
769     }
770 
<span class="line-modified">771 </span>
<span class="line-modified">772     /** Equivalent to runtime &quot;instanceof&quot; operator.</span>
773      *
774      * @return true if this JavaClass is derived from the super class
<span class="line-modified">775      * @throws ClassNotFoundException if superclasses or superinterfaces</span>
<span class="line-modified">776      *   of this object can&#39;t be found</span>
777      */
<span class="line-modified">778     public final boolean instanceOf( final JavaClass super_class ) throws ClassNotFoundException {</span>
779         if (this.equals(super_class)) {
780             return true;
781         }
782         final JavaClass[] super_classes = getSuperClasses();
783         for (final JavaClass super_classe : super_classes) {
784             if (super_classe.equals(super_class)) {
785                 return true;
786             }
787         }
788         if (super_class.isInterface()) {
789             return implementationOf(super_class);
790         }
791         return false;
792     }
793 
<span class="line-added">794 </span>
795     /**
796      * @return true, if this class is an implementation of interface inter
<span class="line-modified">797      * @throws ClassNotFoundException if superclasses or superinterfaces</span>
<span class="line-modified">798      *   of this class can&#39;t be found</span>
799      */
<span class="line-modified">800     public boolean implementationOf( final JavaClass inter ) throws ClassNotFoundException {</span>
801         if (!inter.isInterface()) {
802             throw new IllegalArgumentException(inter.getClassName() + &quot; is no interface&quot;);
803         }
804         if (this.equals(inter)) {
805             return true;
806         }
807         final JavaClass[] super_interfaces = getAllInterfaces();
808         for (final JavaClass super_interface : super_interfaces) {
809             if (super_interface.equals(inter)) {
810                 return true;
811             }
812         }
813         return false;
814     }
815 
<span class="line-added">816 </span>
817     /**
<span class="line-modified">818      * @return the superclass for this JavaClass object, or null if this</span>
<span class="line-modified">819      * is java.lang.Object</span>
820      * @throws ClassNotFoundException if the superclass can&#39;t be found
821      */
822     public JavaClass getSuperClass() throws ClassNotFoundException {
823         if (&quot;java.lang.Object&quot;.equals(getClassName())) {
824             return null;
825         }
826         return repository.loadClass(getSuperclassName());
827     }
828 
<span class="line-added">829 </span>
830     /**
831      * @return list of super classes of this class in ascending order, i.e.,
832      * java.lang.Object is always the last element
833      * @throws ClassNotFoundException if any of the superclasses can&#39;t be found
834      */
835     public JavaClass[] getSuperClasses() throws ClassNotFoundException {
836         JavaClass clazz = this;
837         final List&lt;JavaClass&gt; allSuperClasses = new ArrayList&lt;&gt;();
838         for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {
839             allSuperClasses.add(clazz);
840         }
841         return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);
842     }
843 
<span class="line-added">844 </span>
845     /**
846      * Get interfaces directly implemented by this JavaClass.
847      */
848     public JavaClass[] getInterfaces() throws ClassNotFoundException {
849         final String[] _interfaces = getInterfaceNames();
850         final JavaClass[] classes = new JavaClass[_interfaces.length];
851         for (int i = 0; i &lt; _interfaces.length; i++) {
852             classes[i] = repository.loadClass(_interfaces[i]);
853         }
854         return classes;
855     }
856 
<span class="line-added">857 </span>
858     /**
859      * Get all interfaces implemented by this JavaClass (transitively).
860      */
861     public JavaClass[] getAllInterfaces() throws ClassNotFoundException {
862         final ClassQueue queue = new ClassQueue();
863         final Set&lt;JavaClass&gt; allInterfaces = new TreeSet&lt;&gt;();
864         queue.enqueue(this);
865         while (!queue.empty()) {
866             final JavaClass clazz = queue.dequeue();
867             final JavaClass souper = clazz.getSuperClass();
868             final JavaClass[] _interfaces = clazz.getInterfaces();
869             if (clazz.isInterface()) {
870                 allInterfaces.add(clazz);
871             } else {
872                 if (souper != null) {
873                     queue.enqueue(souper);
874                 }
875             }
876             for (final JavaClass _interface : _interfaces) {
877                 queue.enqueue(_interface);
878             }
879         }
880         return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);
881     }
882 
<span class="line-added">883 </span>
884     /**
885      * @return Comparison strategy object
886      */
887     public static BCELComparator getComparator() {
888         return bcelComparator;
889     }
890 
<span class="line-added">891 </span>
892     /**
893      * @param comparator Comparison strategy object
894      */
<span class="line-modified">895     public static void setComparator( final BCELComparator comparator ) {</span>
896         bcelComparator = comparator;
897     }
898 
<span class="line-added">899 </span>
900     /**
<span class="line-modified">901      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">902      * By default two JavaClass objects are said to be equal when</span>
<span class="line-added">903      * their class names are equal.</span>
904      *
905      * @see java.lang.Object#equals(java.lang.Object)
906      */
907     @Override
<span class="line-modified">908     public boolean equals( final Object obj ) {</span>
909         return bcelComparator.equals(this, obj);
910     }
911 
<span class="line-added">912 </span>
913     /**
<span class="line-modified">914      * Return the natural ordering of two JavaClasses.</span>
<span class="line-modified">915      * This ordering is based on the class name</span>

916      * @since 6.0
917      */
918     @Override
<span class="line-modified">919     public int compareTo( final JavaClass obj ) {</span>
920         return getClassName().compareTo(obj.getClassName());
921     }
922 
<span class="line-added">923 </span>
924     /**
<span class="line-modified">925      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">926      * By default return the hashcode of the class name.</span>
927      *
928      * @see java.lang.Object#hashCode()
929      */
930     @Override
931     public int hashCode() {
932         return bcelComparator.hashCode(this);
933     }
934 }
</pre>
</td>
</tr>
</table>
<center><a href="InnerClasses.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LineNumber.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
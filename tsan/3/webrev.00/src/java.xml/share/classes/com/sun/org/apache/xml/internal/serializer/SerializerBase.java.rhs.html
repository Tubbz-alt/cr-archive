<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xml/internal/serializer/SerializerBase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xml.internal.serializer;
  22 
  23 import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
  24 import com.sun.org.apache.xml.internal.serializer.utils.Utils;
  25 import java.io.IOException;
  26 import java.util.HashMap;
  27 import java.util.Set;
<a name="2" id="anc2"></a><span class="line-modified">  28 import javax.xml.transform.ErrorListener;</span>
  29 import javax.xml.transform.OutputKeys;
  30 import javax.xml.transform.SourceLocator;
  31 import javax.xml.transform.Transformer;
  32 import org.xml.sax.Attributes;
  33 import org.xml.sax.ContentHandler;
  34 import org.xml.sax.Locator;
  35 import org.xml.sax.SAXException;
  36 import org.xml.sax.SAXParseException;
  37 import org.xml.sax.ext.Locator2;
  38 
  39 /**
  40  * This class acts as a base class for the XML &quot;serializers&quot;
  41  * and the stream serializers.
  42  * It contains a number of common fields and methods.
  43  *
  44  * @xsl.usage internal
<a name="3" id="anc3"></a><span class="line-added">  45  * @LastModified: Aug 2019</span>
  46  */
  47 public abstract class SerializerBase
  48     implements SerializationHandler, SerializerConstants
  49 {
<a name="4" id="anc4"></a><span class="line-added">  50     protected ErrorListener m_errListener;</span>
  51 
  52     /**
  53      * To fire off the end element trace event
  54      * @param name Name of element
  55      */
  56     protected void fireEndElem(String name)
  57         throws org.xml.sax.SAXException
  58     {
  59         if (m_tracer != null) {
  60             flushMyWriter();
  61             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENDELEMENT,name, (Attributes)null);
  62         }
  63     }
  64 
  65     /**
  66      * Report the characters trace event
  67      * @param chars  content of characters
  68      * @param start  starting index of characters to output
  69      * @param length  number of characters to output
  70      */
  71     protected void fireCharEvent(char[] chars, int start, int length)
  72         throws org.xml.sax.SAXException
  73     {
  74         if (m_tracer != null) {
  75             flushMyWriter();
  76             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_CHARACTERS, chars, start,length);
  77         }
  78     }
  79 
  80     /**
  81      * true if we still need to call startDocumentInternal()
  82      */
  83     protected boolean m_needToCallStartDocument = true;
  84 
  85     /** True if a trailing &quot;]]&gt;&quot; still needs to be written to be
  86      * written out. Used to merge adjacent CDATA sections
  87      */
  88     protected boolean m_cdataTagOpen = false;
  89 
  90     /**
  91      * All the attributes of the current element, collected from
  92      * startPrefixMapping() calls, or addAddtribute() calls, or
  93      * from the SAX attributes in a startElement() call.
  94      */
  95     protected AttributesImplSerializer m_attributes = new AttributesImplSerializer();
  96 
  97     /**
  98      * Tells if we&#39;re in an EntityRef event, true if it&#39;s greater than 0. Use
  99      * integer type to handle nested entity reference, increase m_inEntityRef in
 100      * startEntity, decrease m_inEntityRef in endEntity.
 101      */
 102     protected int m_inEntityRef = 0;
 103 
 104     /** This flag is set while receiving events from the external DTD */
 105     protected boolean m_inExternalDTD = false;
 106 
 107     /**
 108      * The System ID for the doc type.
 109      */
 110     protected String m_doctypeSystem;
 111 
 112     /**
 113      * The public ID for the doc type.
 114      */
 115     protected String m_doctypePublic;
 116 
 117     /**
 118      * Flag to tell that we need to add the doctype decl, which we can&#39;t do
 119      * until the first element is encountered.
 120      */
 121     boolean m_needToOutputDocTypeDecl = true;
 122 
 123     /**
 124      * Tells if we should write the XML declaration.
 125      */
 126     protected boolean m_shouldNotWriteXMLHeader = false;
 127 
 128     /**
 129      * The standalone value for the doctype.
 130      */
 131     private String m_standalone;
 132 
 133     /**
 134      * True if standalone was specified.
 135      */
 136     protected boolean m_standaloneWasSpecified = false;
 137 
 138     /**
 139      * Determine if the output is a standalone.
 140      */
 141     protected boolean m_isStandalone = false;
 142 
 143     /**
 144      * Flag to tell if indenting (pretty-printing) is on.
 145      */
 146     protected boolean m_doIndent = false;
 147 
 148     /**
 149      * Amount to indent.
 150      */
 151     protected int m_indentAmount = 4;
 152 
 153     /**
 154      * Tells the XML version, for writing out to the XML decl.
 155      */
 156     protected String m_version = null;
 157 
 158     /**
 159      * The mediatype.  Not used right now.
 160      */
 161     protected String m_mediatype;
 162 
 163     /**
 164      * The transformer that was around when this output handler was created (if
 165      * any).
 166      */
 167     private Transformer m_transformer;
 168 
 169     /**
 170      * Namespace support, that keeps track of currently defined
 171      * prefix/uri mappings. As processed elements come and go, so do
 172      * the associated mappings for that element.
 173      */
 174     protected NamespaceMappings m_prefixMap;
 175 
 176     /**
 177      * Handle for firing generate events.  This interface may be implemented
 178      * by the referenced transformer object.
 179      */
 180     protected SerializerTrace m_tracer;
 181 
 182     protected SourceLocator m_sourceLocator;
 183 
 184     /**
 185      * The writer to send output to. This field is only used in the ToStream
 186      * serializers, but exists here just so that the fireStartDoc() and
 187      * other fire... methods can flush this writer when tracing.
 188      */
 189     protected java.io.Writer m_writer = null;
 190 
 191     /**
 192      * A reference to &quot;stack frame&quot; corresponding to
 193      * the current element. Such a frame is pushed at a startElement()
 194      * and popped at an endElement(). This frame contains information about
 195      * the element, such as its namespace URI.
 196      */
 197     protected ElemContext m_elemContext = new ElemContext();
 198 
 199     /**
 200      * A utility buffer for converting Strings passed to
 201      * character() methods to character arrays.
 202      * Reusing this buffer means not creating a new character array
 203      * everytime and it runs faster.
 204      */
 205     protected char[] m_charsBuff = new char[60];
 206 
 207     /**
 208      * A utility buffer for converting Strings passed to
 209      * attribute methods to character arrays.
 210      * Reusing this buffer means not creating a new character array
 211      * everytime and it runs faster.
 212      */
 213     protected char[] m_attrBuff = new char[30];
 214 
 215     private Locator m_locator = null;
 216 
 217     protected boolean m_needToCallSetDocumentInfo = true;
 218 
 219     /**
 220      * Receive notification of a comment.
 221      *
 222      * @see ExtendedLexicalHandler#comment(String)
 223      */
 224     public void comment(String data) throws SAXException {
 225         final int length = data.length();
 226         if (length &gt; m_charsBuff.length) {
 227             m_charsBuff = new char[length * 2 + 1];
 228         }
 229         data.getChars(0, length, m_charsBuff, 0);
 230         comment(m_charsBuff, 0, length);
 231     }
 232 
 233     /**
 234      * If at runtime, when the qname of the attribute is
 235      * known, another prefix is specified for the attribute, then we can
 236      * patch or hack the name with this method. For
 237      * a qname of the form &quot;ns?:otherprefix:name&quot;, this function patches the
 238      * qname by simply ignoring &quot;otherprefix&quot;.
 239      * TODO: This method is a HACK! We do not have access to the
 240      * XML file, it sometimes generates a NS prefix of the form &quot;ns?&quot; for
 241      * an attribute.
 242      */
 243     protected String patchName(String qname) {
 244         final int lastColon = qname.lastIndexOf(&#39;:&#39;);
 245 
 246         if (lastColon &gt; 0) {
 247             final int firstColon = qname.indexOf(&#39;:&#39;);
 248             final String prefix = qname.substring(0, firstColon);
 249             final String localName = qname.substring(lastColon + 1);
 250 
 251             // If uri is &quot;&quot; then ignore prefix
 252             final String uri = m_prefixMap.lookupNamespace(prefix);
 253             if (uri != null &amp;&amp; uri.length() == 0) {
 254                 return localName;
 255             } else if (firstColon != lastColon) {
 256                 return prefix + &#39;:&#39; + localName;
 257             }
 258         }
 259         return qname;
 260     }
 261 
 262     /**
 263      * Returns the local name of a qualified name. If the name has no prefix,
 264      * then it works as the identity (SAX2).
 265      * @param qname the qualified name
 266      * @return the name, but excluding any prefix and colon.
 267      */
 268     protected static String getLocalName(String qname) {
 269         final int col = qname.lastIndexOf(&#39;:&#39;);
 270         return (col &gt; 0) ? qname.substring(col + 1) : qname;
 271     }
 272 
 273     /**
 274      * Receive an object for locating the origin of SAX document events.
 275      *
 276      * @param locator An object that can return the location of any SAX document
 277      * event.
 278      *
 279      * Receive an object for locating the origin of SAX document events.
 280      *
 281      * &lt;p&gt;SAX parsers are strongly encouraged (though not absolutely
 282      * required) to supply a locator: if it does so, it must supply
 283      * the locator to the application by invoking this method before
 284      * invoking any of the other methods in the DocumentHandler
 285      * interface.&lt;/p&gt;
 286      *
 287      * &lt;p&gt;The locator allows the application to determine the end
 288      * position of any document-related event, even if the parser is
 289      * not reporting an error.  Typically, the application will
 290      * use this information for reporting its own errors (such as
 291      * character content that does not match an application&#39;s
 292      * business rules).  The information returned by the locator
 293      * is probably not sufficient for use with a search engine.&lt;/p&gt;
 294      *
 295      * &lt;p&gt;Note that the locator will return correct information only
 296      * during the invocation of the events in this interface.  The
 297      * application should not attempt to use it at any other time.&lt;/p&gt;
 298      */
 299     public void setDocumentLocator(Locator locator) {
 300         m_locator = locator;
 301     }
 302 
 303     /**
 304      * Adds the given attribute to the set of collected attributes , but only if
 305      * there is a currently open element.
 306      *
 307      * An element is currently open if a startElement() notification has
 308      * occured but the start of the element has not yet been written to the
 309      * output.  In the stream case this means that we have not yet been forced
 310      * to close the elements opening tag by another notification, such as a
 311      * character notification.
 312      *
 313      * @param uri the URI of the attribute
 314      * @param localName the local name of the attribute
 315      * @param rawName    the qualified name of the attribute
 316      * @param type the type of the attribute (probably CDATA)
 317      * @param value the value of the attribute
 318      * @param XSLAttribute true if this attribute is coming from an xsl:attriute element
 319      * @see ExtendedContentHandler#addAttribute(String, String, String, String, String)
 320      */
 321     public void addAttribute(String uri, String localName, String rawName,
 322                              String type, String value, boolean XSLAttribute)
 323         throws SAXException
 324     {
 325         if (m_elemContext.m_startTagOpen) {
 326             addAttributeAlways(uri, localName, rawName, type, value, XSLAttribute);
 327         }
 328     }
 329 
 330     /**
 331      * Adds the given attribute to the set of attributes, even if there is
 332      * no currently open element. This is useful if a SAX startPrefixMapping()
 333      * should need to add an attribute before the element name is seen.
 334      *
 335      * @param uri the URI of the attribute
 336      * @param localName the local name of the attribute
 337      * @param rawName   the qualified name of the attribute
 338      * @param type the type of the attribute (probably CDATA)
 339      * @param value the value of the attribute
 340      * @param XSLAttribute true if this attribute is coming from an xsl:attribute element
 341      * @return true if the attribute was added,
 342      * false if an existing value was replaced.
 343      */
 344     public boolean addAttributeAlways(String uri, String localName, String rawName,
 345                                       String type, String value, boolean XSLAttribute)
 346     {
 347         boolean was_added;
 348         int index;
 349 
 350         if (localName == null || uri == null || uri.length() == 0)
 351             index = m_attributes.getIndex(rawName);
 352         else {
 353             index = m_attributes.getIndex(uri,localName);
 354         }
 355         if (index &gt;= 0) {
 356             /* We&#39;ve seen the attribute before.
 357              * We may have a null uri or localName, but all
 358              * we really want to re-set is the value anyway.
 359              */
 360             m_attributes.setValue(index,value);
 361             was_added = false;
 362         } else {
 363             // the attribute doesn&#39;t exist yet, create it
 364             m_attributes.addAttribute(uri, localName, rawName, type, value);
 365             was_added = true;
 366         }
 367         return was_added;
 368     }
 369 
 370     /**
 371      *  Adds  the given attribute to the set of collected attributes,
 372      * but only if there is a currently open element.
 373      *
 374      * @param name the attribute&#39;s qualified name
 375      * @param value the value of the attribute
 376      */
 377     public void addAttribute(String name, final String value) {
 378         if (m_elemContext.m_startTagOpen) {
 379             final String patchedName = patchName(name);
 380             final String localName = getLocalName(patchedName);
 381             final String uri = getNamespaceURI(patchedName, false);
 382 
 383             addAttributeAlways(uri,localName, patchedName, &quot;CDATA&quot;, value, false);
 384         }
 385     }
 386 
 387     /**
 388      * Adds the given xsl:attribute to the set of collected attributes,
 389      * but only if there is a currently open element.
 390      *
 391      * @param name the attribute&#39;s qualified name (prefix:localName)
 392      * @param value the value of the attribute
 393      * @param uri the URI that the prefix of the name points to
 394      */
 395     public void addXSLAttribute(String name, final String value, final String uri) {
 396         if (m_elemContext.m_startTagOpen) {
 397             final String patchedName = patchName(name);
 398             final String localName = getLocalName(patchedName);
 399 
 400             addAttributeAlways(uri,localName, patchedName, &quot;CDATA&quot;, value, true);
 401         }
 402     }
 403 
 404     /**
 405      * Add the given attributes to the currently collected ones. These
 406      * attributes are always added, regardless of whether on not an element
 407      * is currently open.
 408      * @param atts List of attributes to add to this list
 409      */
 410     public void addAttributes(Attributes atts) throws SAXException {
 411         int nAtts = atts.getLength();
 412         for (int i = 0; i &lt; nAtts; i++) {
 413             String uri = atts.getURI(i);
 414 
 415             if (null == uri)
 416                 uri = &quot;&quot;;
 417 
 418             addAttributeAlways(
 419                 uri,
 420                 atts.getLocalName(i),
 421                 atts.getQName(i),
 422                 atts.getType(i),
 423                 atts.getValue(i),
 424                 false);
 425         }
 426     }
 427 
 428     /**
 429      * Return a {@link ContentHandler} interface into this serializer.
 430      * If the serializer does not support the {@link ContentHandler}
 431      * interface, it should return null.
 432      *
 433      * @return A {@link ContentHandler} interface into this serializer,
 434      *  or null if the serializer is not SAX 2 capable
 435      * @throws IOException An I/O exception occured
 436      */
 437     public ContentHandler asContentHandler() throws IOException {
 438         return this;
 439     }
 440 
 441     /**
 442      * Report the end of an entity.
 443      *
 444      * @param name The name of the entity that is ending.
 445      * @throws org.xml.sax.SAXException The application may raise an exception.
 446      * @see #startEntity
 447      */
 448     public void endEntity(String name) throws org.xml.sax.SAXException {
 449         if (name.equals(&quot;[dtd]&quot;))
 450             m_inExternalDTD = false;
 451 
 452         if (!m_inExternalDTD)
 453             m_inEntityRef--;
 454 
 455         if (m_tracer != null)
 456             this.fireEndEntity(name);
 457     }
 458 
 459     /**
 460      * This method checks if current node is in entity reference.
 461      *
 462      * @return True if current node is in entity reference.
 463      */
 464     protected boolean isInEntityRef() {
 465         return m_inEntityRef &gt; 0;
 466     }
 467 
 468     /**
 469      * Flush and close the underlying java.io.Writer. This method applies to
 470      * ToStream serializers, not ToSAXHandler serializers.
 471      * @see ToStream
 472      */
 473     public void close() {
 474         // do nothing (base behavior)
 475     }
 476 
 477     /**
 478      * Initialize global variables
 479      */
 480     protected void initCDATA() {
 481         // CDATA stack
 482         // _cdataStack = new Stack();
 483         // _cdataStack.push(new Integer(-1)); // push dummy value
 484     }
 485 
 486     /**
 487      * Returns the character encoding to be used in the output document.
 488      * @return the character encoding to be used in the output document.
 489      */
 490     public String getEncoding() {
 491         return getOutputProperty(OutputKeys.ENCODING);
 492     }
 493 
 494    /**
 495      * Sets the character encoding coming from the xsl:output encoding stylesheet attribute.
 496      * @param m_encoding the character encoding
 497      */
 498     public void setEncoding(String encoding) {
 499         setOutputProperty(OutputKeys.ENCODING,encoding);
 500     }
 501 
 502     /**
 503      * Sets the value coming from the xsl:output omit-xml-declaration stylesheet attribute
 504      * @param b true if the XML declaration is to be omitted from the output
 505      * document.
 506      */
 507     public void setOmitXMLDeclaration(boolean b) {
 508         String val = b ? &quot;yes&quot;:&quot;no&quot;;
 509         setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,val);
 510     }
 511 
 512     /**
 513      * @return true if the XML declaration is to be omitted from the output
 514      * document.
 515      */
 516     public boolean getOmitXMLDeclaration() {
 517         return m_shouldNotWriteXMLHeader;
 518     }
 519 
 520     /**
 521      * Returns the previously set value of the value to be used as the public
 522      * identifier in the document type declaration (DTD).
 523      *
 524      *@return the public identifier to be used in the DOCTYPE declaration in the
 525      * output document.
 526      */
 527     public String getDoctypePublic()
 528     {
 529         return m_doctypePublic;
 530     }
 531 
 532     /** Set the value coming from the xsl:output doctype-public stylesheet attribute.
 533       * @param doctypePublic the public identifier to be used in the DOCTYPE
 534       * declaration in the output document.
 535       */
 536     public void setDoctypePublic(String doctypePublic)
 537     {
 538         setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);
 539     }
 540 
 541 
 542     /**
 543      * Returns the previously set value of the value to be used
 544      * as the system identifier in the document type declaration (DTD).
 545          * @return the system identifier to be used in the DOCTYPE declaration in
 546          * the output document.
 547      *
 548      */
 549     public String getDoctypeSystem()
 550     {
 551         return m_doctypeSystem;
 552     }
 553 
 554     /** Set the value coming from the xsl:output doctype-system stylesheet attribute.
 555       * @param doctypeSystem the system identifier to be used in the DOCTYPE
 556       * declaration in the output document.
 557       */
 558     public void setDoctypeSystem(String doctypeSystem)
 559     {
 560         setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);
 561     }
 562 
 563     /** Set the value coming from the xsl:output doctype-public and doctype-system stylesheet properties
 564      * @param doctypeSystem the system identifier to be used in the DOCTYPE
 565      * declaration in the output document.
 566      * @param doctypePublic the public identifier to be used in the DOCTYPE
 567      * declaration in the output document.
 568      */
 569     public void setDoctype(String doctypeSystem, String doctypePublic)
 570     {
 571         setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);
 572         setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);
 573     }
 574 
 575     /**
 576      * Sets the value coming from the xsl:output standalone stylesheet attribute.
 577      * @param standalone a value of &quot;yes&quot; indicates that the
 578      * &lt;code&gt;standalone&lt;/code&gt; delaration is to be included in the output
 579      * document. This method remembers if the value was explicitly set using
 580      * this method, verses if the value is the default value.
 581      */
 582     public void setStandalone(String standalone) {
 583         setOutputProperty(OutputKeys.STANDALONE, standalone);
 584     }
 585 
 586     /**
 587      * Sets the XSL standalone attribute, but does not remember if this is a
 588      * default or explicite setting.
 589      * @param standalone &quot;yes&quot; | &quot;no&quot;
 590      */
 591     protected void setStandaloneInternal(String standalone) {
 592         if (&quot;yes&quot;.equals(standalone))
 593             m_standalone = &quot;yes&quot;;
 594         else
 595             m_standalone = &quot;no&quot;;
 596 
 597     }
 598 
 599     /**
 600      * Gets the XSL standalone attribute
 601      * @return a value of &quot;yes&quot; if the &lt;code&gt;standalone&lt;/code&gt; delaration is to
 602      * be included in the output document.
 603      *  @see XSLOutputAttributes#getStandalone()
 604      */
 605     public String getStandalone() {
 606         return m_standalone;
 607     }
 608 
 609     /**
 610      * @return true if the output document should be indented to visually
 611      * indicate its structure.
 612      */
 613     public boolean getIndent() {
 614         return m_doIndent;
 615     }
 616     /**
 617      * Gets the mediatype the media-type or MIME type associated with the output
 618      * document.
 619      * @return the mediatype the media-type or MIME type associated with the
 620      * output document.
 621      */
 622     public String getMediaType() {
 623         return m_mediatype;
 624     }
 625 
 626     /**
 627      * Gets the version of the output format.
 628      * @return the version of the output format.
 629      */
 630     public String getVersion() {
 631         return m_version;
 632     }
 633 
 634     /**
 635      * Sets the value coming from the xsl:output version attribute.
 636      * @param version the version of the output format.
 637      * @see SerializationHandler#setVersion(String)
 638      */
 639     public void setVersion(String version) {
 640         setOutputProperty(OutputKeys.VERSION, version);
 641     }
 642 
 643     /**
 644      * Sets the value coming from the xsl:output media-type stylesheet attribute.
 645      * @param mediaType the non-null media-type or MIME type associated with the
 646      * output document.
 647      * @see javax.xml.transform.OutputKeys#MEDIA_TYPE
 648      * @see SerializationHandler#setMediaType(String)
 649      */
 650     public void setMediaType(String mediaType) {
 651         setOutputProperty(OutputKeys.MEDIA_TYPE,mediaType);
 652     }
 653 
 654     /**
 655      * @return the number of spaces to indent for each indentation level.
 656      */
 657     public int getIndentAmount() {
 658         return m_indentAmount;
 659     }
 660 
 661     /**
 662      * Sets the indentation amount.
 663      * @param m_indentAmount The m_indentAmount to set
 664      */
 665     public void setIndentAmount(int m_indentAmount) {
 666         this.m_indentAmount = m_indentAmount;
 667     }
 668 
 669     /**
 670      * Sets the value coming from the xsl:output indent stylesheet
 671      * attribute.
 672      * @param doIndent true if the output document should be indented to
 673      * visually indicate its structure.
 674      * @see XSLOutputAttributes#setIndent(boolean)
 675      */
 676     public void setIndent(boolean doIndent) {
 677         String val = doIndent ? &quot;yes&quot;:&quot;no&quot;;
 678         setOutputProperty(OutputKeys.INDENT,val);
 679     }
 680 
 681     /**
 682      * Sets the isStandalone property
 683      * @param isStandalone true if the ORACLE_IS_STANDALONE is set to yes
 684      * @see OutputPropertiesFactory ORACLE_IS_STANDALONE
 685      */
 686     public void setIsStandalone(boolean isStandalone) {
 687        m_isStandalone = isStandalone;
 688     }
 689 
 690     /**
 691      * This method is used when a prefix/uri namespace mapping
 692      * is indicated after the element was started with a
 693      * startElement() and before and endElement().
 694      * startPrefixMapping(prefix,uri) would be used before the
 695      * startElement() call.
 696      * @param uri the URI of the namespace
 697      * @param prefix the prefix associated with the given URI.
 698      *
 699      * @see ExtendedContentHandler#namespaceAfterStartElement(String, String)
 700      */
 701     public void namespaceAfterStartElement(String uri, String prefix)
 702         throws SAXException
 703     {
 704         // default behavior is to do nothing
 705     }
 706 
 707     /**
 708      * Return a {@link DOMSerializer} interface into this serializer. If the
 709      * serializer does not support the {@link DOMSerializer} interface, it should
 710      * return null.
 711      *
 712      * @return A {@link DOMSerializer} interface into this serializer,  or null
 713      * if the serializer is not DOM capable
 714      * @throws IOException An I/O exception occured
 715      * @see Serializer#asDOMSerializer()
 716      */
 717     public DOMSerializer asDOMSerializer() throws IOException {
 718         return this;
 719     }
 720 
 721     /**
 722      * Tell if two strings are equal, without worry if the first string is null.
 723      *
 724      * @param p String reference, which may be null.
 725      * @param t String reference, which may be null.
 726      *
 727      * @return true if strings are equal.
 728      */
 729     private static final boolean subPartMatch(String p, String t) {
 730         return (p == t) || ((null != p) &amp;&amp; (p.equals(t)));
 731     }
 732 
 733     /**
 734      * Returns the local name of a qualified name.
 735      * If the name has no prefix,
 736      * then it works as the identity (SAX2).
 737      *
 738      * @param qname a qualified name
 739      * @return returns the prefix of the qualified name,
 740      * or null if there is no prefix.
 741      */
 742     protected static final String getPrefixPart(String qname) {
 743         final int col = qname.indexOf(&#39;:&#39;);
 744         return (col &gt; 0) ? qname.substring(0, col) : null;
 745         //return (col &gt; 0) ? qname.substring(0,col) : &quot;&quot;;
 746     }
 747 
 748     /**
 749      * Some users of the serializer may need the current namespace mappings
 750      * @return the current namespace mappings (prefix/uri)
 751      * @see ExtendedContentHandler#getNamespaceMappings()
 752      */
 753     public NamespaceMappings getNamespaceMappings() {
 754         return m_prefixMap;
 755     }
 756 
 757     /**
 758      * Returns the prefix currently pointing to the given URI (if any).
 759      * @param namespaceURI the uri of the namespace in question
 760      * @return a prefix pointing to the given URI (if any).
 761      * @see ExtendedContentHandler#getPrefix(String)
 762      */
 763     public String getPrefix(String namespaceURI) {
 764         String prefix = m_prefixMap.lookupPrefix(namespaceURI);
 765         return prefix;
 766     }
 767 
 768     /**
 769      * Returns the URI of an element or attribute. Note that default namespaces
 770      * do not apply directly to attributes.
 771      * @param qname a qualified name
 772      * @param isElement true if the qualified name is the name of
 773      * an element.
 774      * @return returns the namespace URI associated with the qualified name.
 775      */
 776     public String getNamespaceURI(String qname, boolean isElement) {
 777         String uri = EMPTYSTRING;
 778         int col = qname.lastIndexOf(&#39;:&#39;);
 779         final String prefix = (col &gt; 0) ? qname.substring(0, col) : EMPTYSTRING;
 780 
 781         if (!EMPTYSTRING.equals(prefix) || isElement) {
 782             if (m_prefixMap != null) {
 783                 uri = m_prefixMap.lookupNamespace(prefix);
 784                 if (uri == null &amp;&amp; !prefix.equals(XMLNS_PREFIX)) {
 785                     throw new RuntimeException(
 786                         Utils.messages.createMessage(
 787                             MsgKey.ER_NAMESPACE_PREFIX,
 788                             new Object[] { qname.substring(0, col) }  ));
 789                 }
 790             }
 791         }
 792         return uri;
 793     }
 794 
 795     /**
 796      * Returns the URI of prefix (if any)
 797      *
 798          * @param prefix the prefix whose URI is searched for
 799      * @return the namespace URI currently associated with the
 800      * prefix, null if the prefix is undefined.
 801      */
 802     public String getNamespaceURIFromPrefix(String prefix) {
 803         String uri = null;
 804         if (m_prefixMap != null)
 805             uri = m_prefixMap.lookupNamespace(prefix);
 806         return uri;
 807     }
 808 
 809     /**
 810      * Entity reference event.
 811      *
 812      * @param name Name of entity
 813      *
 814      * @throws org.xml.sax.SAXException
 815      */
 816     public void entityReference(String name) throws org.xml.sax.SAXException {
 817         flushPending();
 818 
 819         startEntity(name);
 820         endEntity(name);
 821 
 822         if (m_tracer != null)
 823             fireEntityReference(name);
 824     }
 825 
 826     /**
 827      * Sets the transformer associated with this serializer
 828      * @param t the transformer associated with this serializer.
 829      * @see SerializationHandler#setTransformer(Transformer)
 830      */
 831     public void setTransformer(Transformer t) {
 832         m_transformer = t;
 833 
 834         // If this transformer object implements the SerializerTrace interface
 835         // then assign m_tracer to the transformer object so it can be used
 836         // to fire trace events.
 837         if ((m_transformer instanceof SerializerTrace) &amp;&amp;
 838             (((SerializerTrace) m_transformer).hasTraceListeners())) {
 839            m_tracer = (SerializerTrace) m_transformer;
 840         } else {
 841            m_tracer = null;
 842         }
 843     }
 844 
 845     /**
 846      * Gets the transformer associated with this serializer
 847      * @return returns the transformer associated with this serializer.
 848      * @see SerializationHandler#getTransformer()
 849      */
 850     public Transformer getTransformer() {
 851         return m_transformer;
 852     }
 853 
 854     /**
 855      * This method gets the nodes value as a String and uses that String as if
 856      * it were an input character notification.
 857      * @param node the Node to serialize
 858      * @throws org.xml.sax.SAXException
 859      */
 860     public void characters(org.w3c.dom.Node node)
 861         throws org.xml.sax.SAXException
 862     {
 863         flushPending();
 864         String data = node.getNodeValue();
 865         if (data != null) {
 866             final int length = data.length();
 867             if (length &gt; m_charsBuff.length) {
 868                 m_charsBuff = new char[length * 2 + 1];
 869             }
 870             data.getChars(0, length, m_charsBuff, 0);
 871             characters(m_charsBuff, 0, length);
 872         }
 873     }
 874 
 875 
 876     /**
 877      * @see org.xml.sax.ErrorHandler#error(SAXParseException)
 878      */
 879     public void error(SAXParseException exc) throws SAXException {
 880     }
 881 
 882     /**
 883      * @see org.xml.sax.ErrorHandler#fatalError(SAXParseException)
 884      */
 885     public void fatalError(SAXParseException exc) throws SAXException {
 886         m_elemContext.m_startTagOpen = false;
 887     }
 888 
 889     /**
 890      * @see org.xml.sax.ErrorHandler#warning(SAXParseException)
 891      */
 892     public void warning(SAXParseException exc) throws SAXException {
 893     }
 894 
 895     /**
 896      * To fire off start entity trace event
 897      * @param name Name of entity
 898      */
 899     protected void fireStartEntity(String name)
 900         throws org.xml.sax.SAXException
 901     {
 902         if (m_tracer != null)
 903         {
 904             flushMyWriter();
 905             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENTITYREF, name);
 906         }
 907     }
 908 
 909     /**
 910      * This method is only used internally when flushing the writer from the
 911      * various fire...() trace events.  Due to the writer being wrapped with
 912      * SerializerTraceWriter it may cause the flush of these trace events:
 913      * EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS
 914      * EVENTTYPE_OUTPUT_CHARACTERS
 915      * which trace the output written to the output stream.
 916      *
 917      */
 918     private void flushMyWriter() {
 919         if (m_writer != null) {
 920             try {
 921                 m_writer.flush();
 922             } catch(IOException ioe) {
 923             }
 924         }
 925     }
 926 
 927     /**
 928      * Report the CDATA trace event
 929      * @param chars  content of CDATA
 930      * @param start  starting index of characters to output
 931      * @param length  number of characters to output
 932      */
 933     protected void fireCDATAEvent(char[] chars, int start, int length)
 934         throws org.xml.sax.SAXException
 935     {
 936         if (m_tracer != null) {
 937             flushMyWriter();
 938             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_CDATA, chars, start,length);
 939         }
 940     }
 941 
 942     /**
 943      * Report the comment trace event
 944      * @param chars  content of comment
 945      * @param start  starting index of comment to output
 946      * @param length  number of characters to output
 947      */
 948     protected void fireCommentEvent(char[] chars, int start, int length)
 949         throws org.xml.sax.SAXException
 950     {
 951         if (m_tracer != null) {
 952             flushMyWriter();
 953             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_COMMENT, new String(chars, start, length));
 954         }
 955     }
 956 
 957 
 958     /**
 959      * To fire off end entity trace event
 960      * @param name Name of entity
 961      */
 962     public void fireEndEntity(String name)
 963         throws org.xml.sax.SAXException
 964     {
 965         if (m_tracer != null)
 966             flushMyWriter();
 967         // we do not need to handle this.
 968     }
 969 
 970     /**
 971      * To fire off start document trace  event
 972      */
 973      protected void fireStartDoc()
 974         throws org.xml.sax.SAXException
 975     {
 976         if (m_tracer != null)
 977         {
 978             flushMyWriter();
 979             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_STARTDOCUMENT);
 980         }
 981     }
 982 
 983 
 984     /**
 985      * To fire off end document trace event
 986      */
 987     protected void fireEndDoc()
 988         throws org.xml.sax.SAXException
 989     {
 990         if (m_tracer != null)
 991         {
 992             flushMyWriter();
 993             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENDDOCUMENT);
 994         }
 995     }
 996 
 997     /**
 998      * Report the start element trace event. This trace method needs to be
 999      * called just before the attributes are cleared.
1000      *
1001      * @param elemName the qualified name of the element
1002      *
1003      */
1004     protected void fireStartElem(String elemName)
1005         throws org.xml.sax.SAXException
1006     {
1007         if (m_tracer != null)
1008         {
1009             flushMyWriter();
1010             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_STARTELEMENT,
1011                 elemName, m_attributes);
1012         }
1013     }
1014 
1015 
1016     /**
1017      * To fire off the end element event
1018      * @param name Name of element
1019      */
1020 //    protected void fireEndElem(String name)
1021 //        throws org.xml.sax.SAXException
1022 //    {
1023 //        if (m_tracer != null)
1024 //            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENDELEMENT,name, (Attributes)null);
1025 //    }
1026 
1027 
1028     /**
1029      * To fire off the PI trace event
1030      * @param name Name of PI
1031      */
1032     protected void fireEscapingEvent(String name, String data)
1033         throws org.xml.sax.SAXException
1034     {
1035 
1036         if (m_tracer != null)
1037         {
1038             flushMyWriter();
1039             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_PI,name, data);
1040         }
1041     }
1042 
1043 
1044     /**
1045      * To fire off the entity reference trace event
1046      * @param name Name of entity reference
1047      */
1048     protected void fireEntityReference(String name)
1049         throws org.xml.sax.SAXException
1050     {
1051         if (m_tracer != null)
1052         {
1053             flushMyWriter();
1054             m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENTITYREF,name, (Attributes)null);
1055         }
1056     }
1057 
1058     /**
1059      * Receive notification of the beginning of a document.
1060      * This method is never a self generated call,
1061      * but only called externally.
1062      *
1063      * &lt;p&gt;The SAX parser will invoke this method only once, before any
1064      * other methods in this interface or in DTDHandler (except for
1065      * setDocumentLocator).&lt;/p&gt;
1066      *
1067      * @throws org.xml.sax.SAXException Any SAX exception, possibly
1068      *            wrapping another exception.
1069      *
1070      * @throws org.xml.sax.SAXException
1071      */
1072     public void startDocument() throws org.xml.sax.SAXException
1073     {
1074 
1075         // if we do get called with startDocument(), handle it right away
1076         startDocumentInternal();
1077         m_needToCallStartDocument = false;
1078         return;
1079     }
1080 
1081     /**
1082      * This method handles what needs to be done at a startDocument() call,
1083      * whether from an external caller, or internally called in the
1084      * serializer.  For historical reasons the serializer is flexible to
1085      * startDocument() not always being called.
1086      * Even if no external call is
1087      * made into startDocument() this method will always be called as a self
1088      * generated internal startDocument, it handles what needs to be done at a
1089      * startDocument() call.
1090      *
1091      * This method exists just to make sure that startDocument() is only ever
1092      * called from an external caller, which in principle is just a matter of
1093      * style.
1094      *
1095      * @throws SAXException
1096      */
1097     protected void startDocumentInternal() throws org.xml.sax.SAXException
1098     {
1099         if (m_tracer != null)
1100             this.fireStartDoc();
1101 
1102     }
1103 
1104     /* This method extracts version and encoding information from SAX events.
1105      */
1106     protected void setDocumentInfo() {
1107         if (m_locator == null)
1108                 return;
1109         try{
1110             String strVersion = ((Locator2)m_locator).getXMLVersion();
1111             if (strVersion != null)
1112                 setVersion(strVersion);
1113             /*String strEncoding = ((Locator2)m_locator).getEncoding();
1114             if (strEncoding != null)
1115                 setEncoding(strEncoding); */
1116 
1117         }catch(ClassCastException e){}
1118     }
1119 
1120     /**
1121      * This method is used to set the source locator, which might be used to
1122      * generated an error message.
1123      * @param locator the source locator
1124      *
1125      * @see ExtendedContentHandler#setSourceLocator(javax.xml.transform.SourceLocator)
1126      */
1127     public void setSourceLocator(SourceLocator locator) {
1128         m_sourceLocator = locator;
1129     }
1130 
1131     /**
1132      * Used only by TransformerSnapshotImpl to restore the serialization
1133      * to a previous state.
1134      *
1135      * @param mappings NamespaceMappings
1136      */
1137     public void setNamespaceMappings(NamespaceMappings mappings) {
1138         m_prefixMap = mappings;
1139     }
1140 
1141     public boolean reset() {
1142         resetSerializerBase();
1143         return true;
1144     }
1145 
1146     /**
1147      * Reset all of the fields owned by SerializerBase
1148      *
1149      */
1150     private void resetSerializerBase() {
1151         this.m_attributes.clear();
1152         this.m_StringOfCDATASections = null;
1153         this.m_elemContext = new ElemContext();
1154         this.m_doctypePublic = null;
1155         this.m_doctypeSystem = null;
1156         this.m_doIndent = false;
1157         this.m_indentAmount = 4;
1158         this.m_inEntityRef = 0;
1159         this.m_inExternalDTD = false;
1160         this.m_mediatype = null;
1161         this.m_needToCallStartDocument = true;
1162         this.m_needToOutputDocTypeDecl = false;
1163         if (this.m_prefixMap != null)
1164             this.m_prefixMap.reset();
1165         this.m_shouldNotWriteXMLHeader = false;
1166         this.m_sourceLocator = null;
1167         this.m_standalone = null;
1168         this.m_standaloneWasSpecified = false;
1169         this.m_tracer = null;
1170         this.m_transformer = null;
1171         this.m_version = null;
1172         // don&#39;t set writer to null, so that it might be re-used
1173         //this.m_writer = null;
1174     }
1175 
1176     /**
1177      * Returns true if the serializer is used for temporary output rather than
1178      * final output.
1179      *
1180      * This concept is made clear in the XSLT 2.0 draft.
1181      */
1182     final boolean inTemporaryOutputState() {
1183         /* This is a hack. We should really be letting the serializer know
1184          * that it is in temporary output state with an explicit call, but
1185          * from a pragmatic point of view (for now anyways) having no output
1186          * encoding at all, not even the default UTF-8 indicates that the
1187          * serializer is being used for temporary RTF.
1188          */
1189         return (getEncoding() == null);
1190 
1191     }
1192 
1193     /**
1194      * This method adds an attribute the the current element,
1195      * but should not be used for an xsl:attribute child.
1196      * @see ExtendedContentHandler#addAttribute(java.lang.String, java.lang.String,
1197      *          java.lang.String, java.lang.String, java.lang.String)
1198      */
1199     public void addAttribute(String uri, String localName, String rawName,
1200                              String type, String value) throws SAXException
1201     {
1202         if (m_elemContext.m_startTagOpen) {
1203             addAttributeAlways(uri, localName, rawName, type, value, false);
1204         }
1205     }
1206 
1207     /**
1208      * @see org.xml.sax.DTDHandler#notationDecl(java.lang.String,
1209      *          java.lang.String, java.lang.String)
1210      */
1211     public void notationDecl(String arg0, String arg1, String arg2)
1212         throws SAXException
1213     {
1214         // This method just provides a definition to satisfy the interface
1215         // A particular sub-class of SerializerBase provides the implementation
1216         // (if desired)
1217     }
1218 
1219     /**
1220      * @see org.xml.sax.DTDHandler#unparsedEntityDecl(java.lang.String,
1221      *          java.lang.String, java.lang.String, java.lang.String)
1222      */
1223     public void unparsedEntityDecl(String arg0, String arg1, String arg2,
1224                                    String arg3) throws SAXException {
1225         // This method just provides a definition to satisfy the interface
1226         // A particular sub-class of SerializerBase provides the implementation
1227         // (if desired)
1228     }
1229 
1230     /**
1231      * If set to false the serializer does not expand DTD entities,
1232      * but leaves them as is, the default value is true.
1233      */
1234     public void setDTDEntityExpansion(boolean expand) {
1235         // This method just provides a definition to satisfy the interface
1236         // A particular sub-class of SerializerBase provides the implementation (if desired)
1237     }
1238 
1239 
1240     /**
1241      * The CDATA section names stored in a whitespace separateed list with
1242      * each element being a word of the form &quot;{uri}localName&quot; This list
1243      * comes from the cdata-section-elements attribute.
1244      *
1245      * This field replaces m_cdataSectionElements Vector.
1246      */
1247     protected String m_StringOfCDATASections = null;
1248 
1249     boolean m_docIsEmpty = true;
1250     void initCdataElems(String s)
1251     {
1252         if (s != null)
1253         {
1254             int max = s.length();
1255 
1256             // true if we are in the middle of a pair of curly braces that delimit a URI
1257             boolean inCurly = false;
1258 
1259             // true if we found a URI but haven&#39;t yet processed the local name
1260             boolean foundURI = false;
1261 
1262             StringBuilder buf = new StringBuilder();
1263             String uri = null;
1264             String localName = null;
1265 
1266             // parse through string, breaking on whitespaces.  I do this instead
1267             // of a tokenizer so I can track whitespace inside of curly brackets,
1268             // which theoretically shouldn&#39;t happen if they contain legal URLs.
1269             for (int i = 0; i &lt; max; i++)
1270             {
1271                 char c = s.charAt(i);
1272 
1273                 if (Character.isWhitespace(c))
1274                 {
1275                     if (!inCurly)
1276                     {
1277                         if (buf.length() &gt; 0)
1278                         {
1279                             localName = buf.toString();
1280                             if (!foundURI)
1281                                 uri = &quot;&quot;;
1282                             addCDATAElement(uri,localName);
1283                             buf.setLength(0);
1284                             foundURI = false;
1285                         }
1286                         continue;
1287                     }
1288                     else
1289                         buf.append(c); // add whitespace to the URI
1290                 }
1291                 else if (&#39;{&#39; == c) // starting a URI
1292                     inCurly = true;
1293                 else if (&#39;}&#39; == c)
1294                 {
1295                     // we just ended a URI
1296                     foundURI = true;
1297                     uri = buf.toString();
1298                     buf.setLength(0);
1299                     inCurly = false;
1300                 }
1301                 else
1302                 {
1303                     // append non-whitespace, non-curly to current URI or localName being gathered.
1304                     buf.append(c);
1305                 }
1306 
1307             }
1308 
1309             if (buf.length() &gt; 0)
1310             {
1311                 // We have one last localName to process.
1312                 localName = buf.toString();
1313                 if (!foundURI)
1314                     uri = &quot;&quot;;
1315                 addCDATAElement(uri,localName);
1316             }
1317         }
1318     }
1319 
1320     protected java.util.HashMap&lt;String, HashMap&lt;String, String&gt;&gt; m_CdataElems = null;
1321     private void addCDATAElement(String uri, String localName)
1322     {
1323         if (m_CdataElems == null) {
1324             m_CdataElems = new java.util.HashMap&lt;&gt;();
1325         }
1326 
1327         HashMap&lt;String,String&gt; h = m_CdataElems.get(localName);
1328         if (h == null) {
1329             h = new HashMap&lt;&gt;();
1330             m_CdataElems.put(localName,h);
1331         }
1332         h.put(uri,uri);
1333 
1334     }
1335 
1336 
1337     /**
1338      * Return true if nothing has been sent to this result tree yet.
1339      * &lt;p&gt;
1340      * This is not a public API.
1341      *
1342      * @xsl.usage internal
1343      */
1344     public boolean documentIsEmpty() {
1345         // If we haven&#39;t called startDocument() yet, then this document is empty
1346         return m_docIsEmpty &amp;&amp; (m_elemContext.m_currentElemDepth == 0);
1347     }
1348 
1349     /**
1350      * Return true if the current element in m_elemContext
1351      * is a CDATA section.
1352      * CDATA sections are specified in the &lt;xsl:output&gt; attribute
1353      * cdata-section-names or in the JAXP equivalent property.
1354      * In any case the format of the value of such a property is:
1355      * &lt;pre&gt;
1356      * &quot;{uri1}localName1 {uri2}localName2 . . . &quot;
1357      * &lt;/pre&gt;
1358      *
1359      * &lt;p&gt;
1360      * This method is not a public API, but is only used internally by the serializer.
1361      */
1362     protected boolean isCdataSection() {
1363         boolean b = false;
1364 
1365         if (null != m_StringOfCDATASections) {
1366             if (m_elemContext.m_elementLocalName == null) {
1367                 String localName =  getLocalName(m_elemContext.m_elementName);
1368                 m_elemContext.m_elementLocalName = localName;
1369             }
1370 
1371             if ( m_elemContext.m_elementURI == null) {
1372 
1373                 m_elemContext.m_elementURI = getElementURI();
1374             }
1375             else if ( m_elemContext.m_elementURI.length() == 0) {
1376                 if ( m_elemContext.m_elementName == null) {
1377                     m_elemContext.m_elementName = m_elemContext.m_elementLocalName;
1378                     // leave URI as &quot;&quot;, meaning in no namespace
1379                 }
1380                 else if (m_elemContext.m_elementLocalName.length() &lt; m_elemContext.m_elementName.length()){
1381                     // We were told the URI was &quot;&quot;, yet the name has a prefix since the name is longer than the localname.
1382                     // So we will fix that incorrect information here.
1383                     m_elemContext.m_elementURI = getElementURI();
1384                 }
1385             }
1386 
1387             HashMap&lt;String, String&gt; h = null;
1388             if (m_CdataElems != null) {
1389                 h = m_CdataElems.get(m_elemContext.m_elementLocalName);
1390             }
1391             if (h != null) {
1392                 Object obj = h.get(m_elemContext.m_elementURI);
1393                 if (obj != null)
1394                     b = true;
1395             }
1396 
1397         }
1398         return b;
1399     }
1400 
1401     /**
1402      * Before this call m_elementContext.m_elementURI is null,
1403      * which means it is not yet known. After this call it
1404      * is non-null, but possibly &quot;&quot; meaning that it is in the
1405      * default namespace.
1406      *
1407      * @return The URI of the element, never null, but possibly &quot;&quot;.
1408      */
1409     private String getElementURI() {
1410         String uri = null;
1411         // At this point in processing we have received all the
1412         // namespace mappings
1413         // As we still don&#39;t know the elements namespace,
1414         // we now figure it out.
1415 
1416         String prefix = getPrefixPart(m_elemContext.m_elementName);
1417 
1418         if (prefix == null) {
1419             // no prefix so lookup the URI of the default namespace
1420             uri = m_prefixMap.lookupNamespace(&quot;&quot;);
1421         } else {
1422             uri = m_prefixMap.lookupNamespace(prefix);
1423         }
1424         if (uri == null) {
1425             // We didn&#39;t find the namespace for the
1426             // prefix ... ouch, that shouldn&#39;t happen.
1427             // This is a hack, we really don&#39;t know
1428             // the namespace
1429             uri = EMPTYSTRING;
1430         }
1431 
1432         return uri;
1433     }
1434 
1435 
1436     /**
1437      * Get the value of an output property,
1438      * the explicit value, if any, otherwise the
1439      * default value, if any, otherwise null.
1440      */
1441     public String getOutputProperty(String name) {
1442         String val = getOutputPropertyNonDefault(name);
1443         // If no explicit value, try to get the default value
1444         if (val == null)
1445             val = getOutputPropertyDefault(name);
1446         return val;
1447 
1448     }
1449     /**
1450      * Get the value of an output property,
1451      * not the default value. If there is a default
1452      * value, but no non-default value this method
1453      * will return null.
1454      * &lt;p&gt;
1455      *
1456      */
1457     public String getOutputPropertyNonDefault(String name) {
1458         return getProp(name,false);
1459     }
1460 
1461     /**
1462      * Return a {@link DOM3Serializer} interface into this serializer. If the
1463      * serializer does not support the {@link DOM3Serializer} interface, it should
1464      * return null.
1465      *
1466      * @return A {@link DOM3Serializer} interface into this serializer,  or null
1467      * if the serializer is not DOM capable
1468      * @throws IOException An I/O exception occured
1469      * @see org.apache.xml.serializer.Serializer#asDOM3Serializer()
1470      */
1471     public Object asDOM3Serializer() throws IOException
1472     {
1473         return new com.sun.org.apache.xml.internal.serializer.dom3.DOM3SerializerImpl(this);
1474     }
1475 
1476     /**
1477      * Get the default value of an xsl:output property,
1478      * which would be null only if no default value exists
1479      * for the property.
1480      */
1481     public String getOutputPropertyDefault(String name) {
1482         return getProp(name, true);
1483     }
1484 
1485     /**
1486      * Set the value for the output property, typically from
1487      * an xsl:output element, but this does not change what
1488      * the default value is.
1489      */
1490     public void setOutputProperty(String name, String val) {
1491         setProp(name,val,false);
1492     }
1493 
1494     /**
1495      * Set the default value for an output property, but this does
1496      * not impact any explicitly set value.
1497      */
1498     public void setOutputPropertyDefault(String name, String val) {
1499         setProp(name,val,true);
1500 
1501     }
1502 
1503     /**
1504      * A mapping of keys to explicitly set values, for example if
1505      * and &lt;xsl:output/&gt; has an &quot;encoding&quot; attribute, this
1506      * map will have what that attribute maps to.
1507      */
1508     private HashMap&lt;String, String&gt; m_OutputProps;
1509 
1510     /**
1511      * A mapping of keys to default values, for example if
1512      * the default value of the encoding is &quot;UTF-8&quot; then this
1513      * map will have that &quot;encoding&quot; maps to &quot;UTF-8&quot;.
1514      */
1515     private HashMap&lt;String, String&gt; m_OutputPropsDefault;
1516 
1517     Set&lt;String&gt; getOutputPropDefaultKeys() {
1518         return m_OutputPropsDefault.keySet();
1519     }
1520 
1521     Set&lt;String&gt; getOutputPropKeys() {
1522         return m_OutputProps.keySet();
1523     }
1524 
1525     private String getProp(String name, boolean defaultVal) {
1526         if (m_OutputProps == null) {
1527             m_OutputProps = new HashMap&lt;&gt;();
1528             m_OutputPropsDefault = new HashMap&lt;&gt;();
1529         }
1530 
1531         String val;
1532         if (defaultVal)
1533             val = m_OutputPropsDefault.get(name);
1534         else
1535             val = m_OutputProps.get(name);
1536 
1537         return val;
1538     }
1539 
1540     /**
1541      *
1542      * @param name The name of the property, e.g. &quot;{http://myprop}indent-tabs&quot; or &quot;indent&quot;.
1543      * @param val The value of the property, e.g. &quot;4&quot;
1544      * @param defaultVal true if this is a default value being set for the property as
1545      * opposed to a user define on, set say explicitly in the stylesheet or via JAXP
1546      */
1547     void setProp(String name, String val, boolean defaultVal) {
1548         if (m_OutputProps == null) {
1549             m_OutputProps = new HashMap&lt;&gt;();
1550             m_OutputPropsDefault = new HashMap&lt;&gt;();
1551         }
1552 
1553         if (defaultVal)
1554             m_OutputPropsDefault.put(name,val);
1555         else {
1556             if (OutputKeys.CDATA_SECTION_ELEMENTS.equals(name) &amp;&amp; val != null) {
1557                 initCdataElems(val);
1558                 String oldVal = m_OutputProps.get(name);
1559                 String newVal;
1560                 if (oldVal == null)
1561                     newVal = oldVal + &#39; &#39; + val;
1562                 else
1563                     newVal = val;
1564                 m_OutputProps.put(name,newVal);
1565             }
1566             else {
1567                 m_OutputProps.put(name,val);
1568             }
1569         }
1570     }
1571 
1572     /**
1573      * Get the first char of the local name
1574      * @param name Either a local name, or a local name
1575      * preceeded by a uri enclosed in curly braces.
1576      */
1577     static char getFirstCharLocName(String name) {
1578         final char first;
1579         int i = name.indexOf(&#39;}&#39;);
1580         if (i &lt; 0)
1581             first = name.charAt(0);
1582         else
1583             first = name.charAt(i+1);
1584         return first;
1585     }
1586 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
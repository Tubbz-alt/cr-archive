<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/TextImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xerces.internal.dom;
 22 
 23 import org.w3c.dom.CharacterData;
 24 import org.w3c.dom.DOMException;
 25 import org.w3c.dom.Node;
 26 import org.w3c.dom.Text;
 27 
 28 /**
 29  * Text nodes hold the non-markup, non-Entity content of
 30  * an Element or Attribute.
 31  * &lt;P&gt;
 32  * When a document is first made available to the DOM, there is only
 33  * one Text object for each block of adjacent plain-text. Users (ie,
 34  * applications) may create multiple adjacent Texts during editing --
 35  * see {@link org.w3c.dom.Element#normalize} for discussion.
 36  * &lt;P&gt;
 37  * Note that CDATASection is a subclass of Text. This is conceptually
 38  * valid, since they&#39;re really just two different ways of quoting
 39  * characters when they&#39;re written out as part of an XML stream.
 40  *
 41  * @xerces.internal
 42  *
 43  * @since  PR-DOM-Level-1-19980818.
 44  * @LastModified: Apr 2019
 45  */
 46 public class TextImpl
 47     extends CharacterDataImpl
 48     implements CharacterData, Text {
 49 
 50     //
 51     // Private Data members
 52     //
 53 
 54 
 55     //
 56     // Constants
 57     //
 58 
 59     /** Serialization version. */
 60     static final long serialVersionUID = -5294980852957403469L;
 61 
 62     //
 63     // Constructors
 64     //
 65 
 66     /** Default constructor */
 67     public TextImpl(){}
 68 
 69     /** Factory constructor. */
 70     public TextImpl(CoreDocumentImpl ownerDoc, String data) {
 71         super(ownerDoc, data);
 72     }
 73 
 74     /**
 75      * NON-DOM: resets node and sets specified values for the current node
 76      *
 77      * @param ownerDoc
 78      * @param data
 79      */
 80     public void setValues(CoreDocumentImpl ownerDoc, String data){
 81 
 82         flags=0;
 83         nextSibling = null;
 84         previousSibling=null;
 85         setOwnerDocument(ownerDoc);
 86         super.data = data;
 87     }
 88     //
 89     // Node methods
 90     //
 91 
 92     /**
 93      * A short integer indicating what type of node this is. The named
 94      * constants for this value are defined in the org.w3c.dom.Node interface.
 95      */
 96     public short getNodeType() {
 97         return Node.TEXT_NODE;
 98     }
 99 
100     /** Returns the node name. */
101     public String getNodeName() {
102         return &quot;#text&quot;;
103     }
104 
105     /**
106      * NON-DOM: Set whether this Text is ignorable whitespace.
107      */
108     public void setIgnorableWhitespace(boolean ignore) {
109 
110         if (needsSyncData()) {
111             synchronizeData();
112         }
113         isIgnorableWhitespace(ignore);
114 
115     } // setIgnorableWhitespace(boolean)
116 
117 
118     /**
119      * DOM L3 Core CR - Experimental
120      *
121      * Returns whether this text node contains
122      * element content whitespace&lt;/a&gt;, often abusively called &quot;ignorable whitespace&quot;.
123      * The text node is determined to contain whitespace in element content
124      * during the load of the document or if validation occurs while using
125      * &lt;code&gt;Document.normalizeDocument()&lt;/code&gt;.
126      * @since DOM Level 3
127      */
128     public boolean isElementContentWhitespace() {
129         // REVISIT: is this implemenation correct?
130         if (needsSyncData()) {
131             synchronizeData();
132         }
133         return internalIsIgnorableWhitespace();
134     }
135 
136 
137     /**
138      * DOM Level 3 WD - Experimental.
139      * Returns all text of &lt;code&gt;Text&lt;/code&gt; nodes logically-adjacent text
140      * nodes to this node, concatenated in document order.
141      * @since DOM Level 3
142      */
143     public String getWholeText(){
144 
145         if (needsSyncData()) {
146             synchronizeData();
147         }
148 
149         StringBuilder buffer = new StringBuilder();
150         if (data != null &amp;&amp; data.length() != 0) {
151             buffer.append(data);
152         }
153 
154         // concatenate text of logically adjacent text nodes to the left of this node in the tree
155         getWholeTextBackward(this.getPreviousSibling(), buffer, this.getParentNode());
156         String temp = buffer.toString();
157 
158         // clear buffer
159         buffer.setLength(0);
160 
161         // concatenate text of logically adjacent text nodes to the right of this node in the tree
162         getWholeTextForward(this.getNextSibling(), buffer, this.getParentNode());
163 
164         return temp + buffer.toString();
165 
166     }
167 
168     /**
169      * internal method taking a StringBuilder in parameter and inserts the
170      * text content at the start of the buffer
171      *
172      * @param buf
173      */
174     protected void insertTextContent(StringBuilder buf) throws DOMException {
175          String content = getNodeValue();
176          if (content != null) {
177              buf.insert(0, content);
178          }
179      }
180 
181     /**
182      * Concatenates the text of all logically-adjacent text nodes to the
183      * right of this node
184      * @param node
185      * @param buffer
186      * @param parent
187      * @return true - if execution was stopped because the type of node
188      *         other than EntityRef, Text, CDATA is encountered, otherwise
189      *         return false
190      */
191     private boolean getWholeTextForward(Node node, StringBuilder buffer, Node parent){
192         // boolean to indicate whether node is a child of an entity reference
193         boolean inEntRef = false;
194 
195         if (parent!=null) {
196                 inEntRef = parent.getNodeType()==Node.ENTITY_REFERENCE_NODE;
197         }
198 
199         while (node != null) {
200             short type = node.getNodeType();
201             if (type == Node.ENTITY_REFERENCE_NODE) {
202                 if (getWholeTextForward(node.getFirstChild(), buffer, node)){
203                     return true;
204                 }
205             }
206             else if (type == Node.TEXT_NODE ||
207                      type == Node.CDATA_SECTION_NODE) {
208                 ((NodeImpl)node).getTextContent(buffer);
209             }
210             else {
211                 return true;
212             }
213 
214             node = node.getNextSibling();
215         }
216 
217         // if the parent node is an entity reference node, must
218         // check nodes to the right of the parent entity reference node for logically adjacent
219         // text nodes
220         if (inEntRef) {
221             getWholeTextForward(parent.getNextSibling(), buffer, parent.getParentNode());
222                         return true;
223         }
224 
225         return false;
226     }
227 
228     /**
229      * Concatenates the text of all logically-adjacent text nodes to the left of
230      * the node
231      * @param node
232      * @param buffer
233      * @param parent
234      * @return true - if execution was stopped because the type of node
235      *         other than EntityRef, Text, CDATA is encountered, otherwise
236      *         return false
237      */
238     private boolean getWholeTextBackward(Node node, StringBuilder buffer, Node parent){
239 
240         // boolean to indicate whether node is a child of an entity reference
241         boolean inEntRef = false;
242         if (parent!=null) {
243                 inEntRef = parent.getNodeType()==Node.ENTITY_REFERENCE_NODE;
244         }
245 
246         while (node != null) {
247             short type = node.getNodeType();
248             if (type == Node.ENTITY_REFERENCE_NODE) {
249                 if (getWholeTextBackward(node.getLastChild(), buffer, node)){
250                     return true;
251                 }
252             }
253             else if (type == Node.TEXT_NODE ||
254                      type == Node.CDATA_SECTION_NODE) {
255                 ((TextImpl)node).insertTextContent(buffer);
256             }
257             else {
258                 return true;
259             }
260 
261             node = node.getPreviousSibling();
262         }
263 
264         // if the parent node is an entity reference node, must
265         // check nodes to the left of the parent entity reference node for logically adjacent
266         // text nodes
267         if (inEntRef) {
268                 getWholeTextBackward(parent.getPreviousSibling(), buffer, parent.getParentNode());
269             return true;
270         }
271 
272         return false;
273     }
274 
275     /**
276      * Replaces the text of the current node and all logically-adjacent text
277      * nodes with the specified text. All logically-adjacent text nodes are
278      * removed including the current node unless it was the recipient of the
279      * replacement text.
280      *
281      * @param content
282      *            The content of the replacing Text node.
283      * @return text - The Text node created with the specified content.
284      * @since DOM Level 3
285      */
286     public Text replaceWholeText(String content) throws DOMException {
287 
288         if (needsSyncData()) {
289             synchronizeData();
290         }
291 
292         //if the content is null
293         Node parent = this.getParentNode();
294         if (content == null || content.length() == 0) {
295             // remove current node
296             if (parent != null) { // check if node in the tree
297                 parent.removeChild(this);
298             }
299             return null;
300         }
301 
302         // make sure we can make the replacement
303         if (ownerDocument().errorChecking) {
304             if (!canModifyPrev(this)) {
305                 throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR,
306                         DOMMessageFormatter.formatMessage(
307                                 DOMMessageFormatter.DOM_DOMAIN,
308                                 &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
309             }
310 
311             // make sure we can make the replacement
312             if (!canModifyNext(this)) {
313                 throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR,
314                         DOMMessageFormatter.formatMessage(
315                                 DOMMessageFormatter.DOM_DOMAIN,
316                                 &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
317             }
318         }
319 
320         //replace the text node
321         Text currentNode = null;
322         if (isReadOnly()) {
323             Text newNode = this.ownerDocument().createTextNode(content);
324             if (parent != null) { // check if node in the tree
325                 parent.insertBefore(newNode, this);
326                 parent.removeChild(this);
327                 currentNode = newNode;
328             } else {
329                 return newNode;
330             }
331         } else {
332             this.setData(content);
333             currentNode = this;
334         }
335 
336         //check logically-adjacent text nodes
337         Node prev = currentNode.getPreviousSibling();
338         while (prev != null) {
339             //If the logically-adjacent next node can be removed
340             //remove it. A logically adjacent node can be removed if
341             //it is a Text or CDATASection node or an EntityReference with
342             //Text and CDATA only children.
343             if ((prev.getNodeType() == Node.TEXT_NODE)
344                     || (prev.getNodeType() == Node.CDATA_SECTION_NODE)
345                     || (prev.getNodeType() == Node.ENTITY_REFERENCE_NODE &amp;&amp; hasTextOnlyChildren(prev))) {
346                 parent.removeChild(prev);
347                 prev = currentNode;
348             } else {
349                 break;
350             }
351             prev = prev.getPreviousSibling();
352         }
353 
354         //check logically-adjacent text nodes
355         Node next = currentNode.getNextSibling();
356         while (next != null) {
357             //If the logically-adjacent next node can be removed
358             //remove it. A logically adjacent node can be removed if
359             //it is a Text or CDATASection node or an EntityReference with
360             //Text and CDATA only children.
361             if ((next.getNodeType() == Node.TEXT_NODE)
362                     || (next.getNodeType() == Node.CDATA_SECTION_NODE)
363                     || (next.getNodeType() == Node.ENTITY_REFERENCE_NODE &amp;&amp; hasTextOnlyChildren(next))) {
364                 parent.removeChild(next);
365                 next = currentNode;
366             } else {
367                 break;
368             }
369             next = next.getNextSibling();
370         }
371 
372         return currentNode;
373     }
374 
375     /**
376      * If any EntityReference to be removed has descendants that are not
377      * EntityReference, Text, or CDATASection nodes, the replaceWholeText method
378      * must fail before performing any modification of the document, raising a
379      * DOMException with the code NO_MODIFICATION_ALLOWED_ERR. Traverse previous
380      * siblings of the node to be replaced. If a previous sibling is an
381      * EntityReference node, get it&#39;s last child. If the last child was a Text
382      * or CDATASection node and its previous siblings are neither a replaceable
383      * EntityReference or Text or CDATASection nodes, return false. IF the last
384      * child was neither Text nor CDATASection nor a replaceable EntityReference
385      * Node, then return true. If the last child was a Text or CDATASection node
386      * any its previous sibling was not or was an EntityReference that did not
387      * contain only Text or CDATASection nodes, return false. Check this
388      * recursively for EntityReference nodes.
389      *
390      * @param node
391      * @return true - can replace text false - can&#39;t replace exception must be
392      *         raised
393      */
394     private boolean canModifyPrev(Node node) {
395         boolean textLastChild = false;
396 
397         Node prev = node.getPreviousSibling();
398 
399         while (prev != null) {
400 
401             short type = prev.getNodeType();
402 
403             if (type == Node.ENTITY_REFERENCE_NODE) {
404                 //If the previous sibling was entityreference
405                 //check if its content is replaceable
406                 Node lastChild = prev.getLastChild();
407 
408                 //if the entity reference has no children
409                 //return false
410                 if (lastChild == null) {
411                     return false;
412                 }
413 
414                 //The replacement text of the entity reference should
415                 //be either only text,cadatsections or replaceable entity
416                 //reference nodes or the last child should be neither of these
417                 while (lastChild != null) {
418                     short lType = lastChild.getNodeType();
419 
420                     if (lType == Node.TEXT_NODE
421                             || lType == Node.CDATA_SECTION_NODE) {
422                         textLastChild = true;
423                     } else if (lType == Node.ENTITY_REFERENCE_NODE) {
424                         if (!canModifyPrev(lastChild)) {
425                             return false;
426                         } else {
427                             //If the EntityReference child contains
428                             //only text, or non-text or ends with a
429                             //non-text node.
430                             textLastChild = true;
431                         }
432                     } else {
433                         //If the last child was replaceable and others are not
434                         //Text or CDataSection or replaceable EntityRef nodes
435                         //return false.
436                         if (textLastChild) {
437                             return false;
438                         } else {
439                             return true;
440                         }
441                     }
442                     lastChild = lastChild.getPreviousSibling();
443                 }
444             } else if (type == Node.TEXT_NODE
445                     || type == Node.CDATA_SECTION_NODE) {
446                 //If the previous sibling was text or cdatasection move to next
447             } else {
448                 //If the previous sibling was anything but text or
449                 //cdatasection or an entity reference, stop search and
450                 //return true
451                 return true;
452             }
453 
454             prev = prev.getPreviousSibling();
455         }
456 
457         return true;
458     }
459 
460     /**
461      * If any EntityReference to be removed has descendants that are not
462      * EntityReference, Text, or CDATASection nodes, the replaceWholeText method
463      * must fail before performing any modification of the document, raising a
464      * DOMException with the code NO_MODIFICATION_ALLOWED_ERR. Traverse previous
465      * siblings of the node to be replaced. If a previous sibling is an
466      * EntityReference node, get it&#39;s last child. If the first child was a Text
467      * or CDATASection node and its next siblings are neither a replaceable
468      * EntityReference or Text or CDATASection nodes, return false. IF the first
469      * child was neither Text nor CDATASection nor a replaceable EntityReference
470      * Node, then return true. If the first child was a Text or CDATASection
471      * node any its next sibling was not or was an EntityReference that did not
472      * contain only Text or CDATASection nodes, return false. Check this
473      * recursively for EntityReference nodes.
474      *
475      * @param node
476      * @return true - can replace text false - can&#39;t replace exception must be
477      *         raised
478      */
479     private boolean canModifyNext(Node node) {
480         boolean textFirstChild = false;
481 
482         Node next = node.getNextSibling();
483         while (next != null) {
484 
485             short type = next.getNodeType();
486 
487             if (type == Node.ENTITY_REFERENCE_NODE) {
488                 //If the previous sibling was entityreference
489                 //check if its content is replaceable
490                 Node firstChild = next.getFirstChild();
491 
492                 //if the entity reference has no children
493                 //return false
494                 if (firstChild == null) {
495                     return false;
496                 }
497 
498                 //The replacement text of the entity reference should
499                 //be either only text,cadatsections or replaceable entity
500                 //reference nodes or the last child should be neither of these
501                 while (firstChild != null) {
502                     short lType = firstChild.getNodeType();
503 
504                     if (lType == Node.TEXT_NODE
505                             || lType == Node.CDATA_SECTION_NODE) {
506                         textFirstChild = true;
507                     } else if (lType == Node.ENTITY_REFERENCE_NODE) {
508                         if (!canModifyNext(firstChild)) {
509                             return false;
510                         } else {
511                             //If the EntityReference child contains
512                             //only text, or non-text or ends with a
513                             //non-text node.
514                             textFirstChild = true;
515                         }
516                     } else {
517                         //If the first child was replaceable text and next
518                         //children are not, then return false
519                         if (textFirstChild) {
520                             return false;
521                         } else {
522                             return true;
523                         }
524                     }
525                     firstChild = firstChild.getNextSibling();
526                 }
527             } else if (type == Node.TEXT_NODE
528                     || type == Node.CDATA_SECTION_NODE) {
529                 //If the previous sibling was text or cdatasection move to next
530             } else {
531                 //If the next sibling was anything but text or
532                 //cdatasection or an entity reference, stop search and
533                 //return true
534                 return true;
535             }
536 
537             next = next.getNextSibling();
538         }
539 
540         return true;
541     }
542 
543     /**
544      * Check if an EntityReference node has Text Only child nodes
545      *
546      * @param node
547      * @return true - Contains text only children
548      */
549     private boolean hasTextOnlyChildren(Node node) {
550 
551         Node child = node;
552 
553         if (child == null) {
554             return false;
555         }
556 
557         child = child.getFirstChild();
558         while (child != null) {
559             int type = child.getNodeType();
560 
561             if (type == Node.ENTITY_REFERENCE_NODE) {
562                 return hasTextOnlyChildren(child);
563             }
564             else if (type != Node.TEXT_NODE
565                     &amp;&amp; type != Node.CDATA_SECTION_NODE
566                     &amp;&amp; type != Node.ENTITY_REFERENCE_NODE) {
567                 return false;
568             }
569             child = child.getNextSibling();
570         }
571         return true;
572     }
573 
574 
575     /**
576      * NON-DOM: Returns whether this Text is ignorable whitespace.
577      */
578     public boolean isIgnorableWhitespace() {
579 
580         if (needsSyncData()) {
581             synchronizeData();
582         }
583         return internalIsIgnorableWhitespace();
584 
585     } // isIgnorableWhitespace():boolean
586 
587 
588     //
589     // Text methods
590     //
591 
592     /**
593      * Break a text node into two sibling nodes. (Note that if the current node
594      * has no parent, they won&#39;t wind up as &quot;siblings&quot; -- they&#39;ll both be
595      * orphans.)
596      *
597      * @param offset
598      *            The offset at which to split. If offset is at the end of the
599      *            available data, the second node will be empty.
600      *
601      * @return A reference to the new node (containing data after the offset
602      *         point). The original node will contain data up to that point.
603      *
604      * @throws DOMException(INDEX_SIZE_ERR)
605      *             if offset is &lt;0 or &gt;length.
606      *
607      * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR)
608      *             if node is read-only.
609      */
610     public Text splitText(int offset)
611         throws DOMException {
612 
613         if (isReadOnly()) {
614             throw new DOMException(
615             DOMException.NO_MODIFICATION_ALLOWED_ERR,
616                 DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;NO_MODIFICATION_ALLOWED_ERR&quot;, null));
617         }
618 
619         if (needsSyncData()) {
620             synchronizeData();
621         }
622         if (offset &lt; 0 || offset &gt; data.length() ) {
623             throw new DOMException(DOMException.INDEX_SIZE_ERR,
624                 DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, &quot;INDEX_SIZE_ERR&quot;, null));
625         }
626 
627         // split text into two separate nodes
628         Text newText =
629             getOwnerDocument().createTextNode(data.substring(offset));
630         setNodeValue(data.substring(0, offset));
631 
632         // insert new text node
633         Node parentNode = getParentNode();
634         if (parentNode != null) {
635             parentNode.insertBefore(newText, nextSibling);
636         }
637 
638         return newText;
639 
640     } // splitText(int):Text
641 
642 
643     /**
644      * NON-DOM (used by DOMParser): Reset data for the node.
645      */
646     public void replaceData (String value){
647         data = value;
648     }
649 
650 
651     /**
652      * NON-DOM (used by DOMParser: Sets data to empty string.
653      *  Returns the value the data was set to.
654      */
655     public String removeData (){
656         String olddata=data;
657         data = &quot;&quot;;
658         return olddata;
659     }
660 
661 } // class TextImpl
    </pre>
  </body>
</html>
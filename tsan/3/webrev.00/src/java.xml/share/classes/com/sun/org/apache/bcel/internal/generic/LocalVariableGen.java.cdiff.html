<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LoadInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LocalVariableInstruction.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,133 ***</span>
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
  
  /**
<span class="line-modified">!  * This class represents a local variable within a method. It contains its</span>
<span class="line-modified">!  * scope, name and type. The generated LocalVariable object can be obtained with</span>
<span class="line-modified">!  * getLocalVariable which needs the instruction list and the constant pool as</span>
<span class="line-modified">!  * parameters.</span>
   *
<span class="line-modified">!  * @version $Id: LocalVariableGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
<span class="line-modified">!  * @see LocalVariable</span>
<span class="line-removed">-  * @see MethodGen</span>
   */
  public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Cloneable {
  
      private int index;
      private String name;
      private Type type;
      private InstructionHandle start;
      private InstructionHandle end;
  
      /**
<span class="line-modified">!      * Generate a local variable that with index `index&#39;. Note that double and</span>
<span class="line-modified">!      * long variables need two indexs. Index indices have to be provided by the</span>
<span class="line-removed">-      * user.</span>
       *
       * @param index index of local variable
       * @param name its name
       * @param type its type
<span class="line-modified">!      * @param start from where the instruction is valid (null means from the</span>
<span class="line-removed">-      * start)</span>
       * @param end until where the instruction is valid (null means to the end)
       */
<span class="line-modified">!     public LocalVariableGen(final int index, final String name, final Type type,</span>
<span class="line-modified">!             final InstructionHandle start, final InstructionHandle end) {</span>
          if ((index &lt; 0) || (index &gt; Const.MAX_SHORT)) {
              throw new ClassGenException(&quot;Invalid index index: &quot; + index);
          }
          this.name = name;
          this.type = type;
          this.index = index;
          setStart(start);
          setEnd(end);
      }
  
      /**
<span class="line-modified">!      * Get LocalVariable object.</span>
       *
<span class="line-modified">!      * This relies on that the instruction list has already been dumped to byte</span>
<span class="line-modified">!      * code or or that the `setPositions&#39; methods has been called for the</span>
<span class="line-removed">-      * instruction list.</span>
       *
<span class="line-modified">!      * Note that for local variables whose scope end at the last instruction of</span>
<span class="line-modified">!      * the method&#39;s code, the JVM specification is ambiguous: both a</span>
<span class="line-modified">!      * start_pc+length ending at the last instruction and start_pc+length ending</span>
<span class="line-modified">!      * at first index beyond the end of the code are valid.</span>
       *
       * @param cp constant pool
       */
<span class="line-modified">!     public LocalVariable getLocalVariable(final ConstantPoolGen cp) {</span>
          int start_pc = 0;
          int length = 0;
          if ((start != null) &amp;&amp; (end != null)) {
              start_pc = start.getPosition();
              length = end.getPosition() - start_pc;
<span class="line-modified">!             if (end.getNext() == null) {</span>
                  length += end.getInstruction().getLength();
              }
          }
          final int name_index = cp.addUtf8(name);
          final int signature_index = cp.addUtf8(type.getSignature());
          return new LocalVariable(start_pc, length, name_index, signature_index, index, cp
<span class="line-modified">!                 .getConstantPool());</span>
      }
  
<span class="line-modified">!     public void setIndex(final int index) {</span>
          this.index = index;
      }
  
      public int getIndex() {
          return index;
      }
  
      @Override
<span class="line-modified">!     public void setName(final String name) {</span>
          this.name = name;
      }
  
      @Override
      public String getName() {
          return name;
      }
  
      @Override
<span class="line-modified">!     public void setType(final Type type) {</span>
          this.type = type;
      }
  
      @Override
      public Type getType() {
          return type;
      }
  
      public InstructionHandle getStart() {
          return start;
      }
  
      public InstructionHandle getEnd() {
          return end;
      }
  
<span class="line-modified">!     public void setStart(final InstructionHandle start) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.start, start, this);
          this.start = start;
      }
  
<span class="line-modified">!     public void setEnd(final InstructionHandle end) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.end, end, this);
          this.end = end;
      }
  
      /**
       * @param old_ih old target, either start or end
       * @param new_ih new target
       */
      @Override
<span class="line-modified">!     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
          boolean targeted = false;
          if (start == old_ih) {
              targeted = true;
              setStart(new_ih);
          }
<span class="line-new-header">--- 22,180 ---</span>
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
  
  /**
<span class="line-modified">!  * Represents a local variable within a method. It contains its</span>
<span class="line-modified">!  * scope, name and type. The generated LocalVariable object can be obtained</span>
<span class="line-modified">!  * with getLocalVariable which needs the instruction list and the constant</span>
<span class="line-modified">!  * pool as parameters.</span>
   *
<span class="line-modified">!  * @see     LocalVariable</span>
<span class="line-modified">!  * @see     MethodGen</span>
   */
  public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Cloneable {
  
      private int index;
      private String name;
      private Type type;
      private InstructionHandle start;
      private InstructionHandle end;
<span class="line-added">+     private int orig_index; // never changes; used to match up with LocalVariableTypeTable entries</span>
<span class="line-added">+     private boolean live_to_end;</span>
<span class="line-added">+ </span>
  
      /**
<span class="line-modified">!      * Generate a local variable that with index `index&#39;. Note that double and long</span>
<span class="line-modified">!      * variables need two indexs. Index indices have to be provided by the user.</span>
       *
       * @param index index of local variable
       * @param name its name
       * @param type its type
<span class="line-modified">!      * @param start from where the instruction is valid (null means from the start)</span>
       * @param end until where the instruction is valid (null means to the end)
       */
<span class="line-modified">!     public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,</span>
<span class="line-modified">!             final InstructionHandle end) {</span>
          if ((index &lt; 0) || (index &gt; Const.MAX_SHORT)) {
              throw new ClassGenException(&quot;Invalid index index: &quot; + index);
          }
          this.name = name;
          this.type = type;
          this.index = index;
          setStart(start);
          setEnd(end);
<span class="line-added">+         this.orig_index = index;</span>
<span class="line-added">+         this.live_to_end = end == null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Generates a local variable that with index `index&#39;. Note that double and long</span>
<span class="line-added">+      * variables need two indexs. Index indices have to be provided by the user.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @param index index of local variable</span>
<span class="line-added">+      * @param name its name</span>
<span class="line-added">+      * @param type its type</span>
<span class="line-added">+      * @param start from where the instruction is valid (null means from the start)</span>
<span class="line-added">+      * @param end until where the instruction is valid (null means to the end)</span>
<span class="line-added">+      * @param orig_index index of local variable prior to any changes to index</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,</span>
<span class="line-added">+             final InstructionHandle end, final int orig_index) {</span>
<span class="line-added">+         this(index, name, type, start, end);</span>
<span class="line-added">+         this.orig_index = orig_index;</span>
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Gets LocalVariable object.</span>
       *
<span class="line-modified">!      * This relies on that the instruction list has already been dumped to byte code or</span>
<span class="line-modified">!      * or that the `setPositions&#39; methods has been called for the instruction list.</span>
       *
<span class="line-modified">!      * Note that due to the conversion from byte code offset to InstructionHandle,</span>
<span class="line-modified">!      * it is impossible to tell the difference between a live range that ends BEFORE</span>
<span class="line-modified">!      * the last insturction of the method or a live range that ends AFTER the last</span>
<span class="line-modified">!      * instruction of the method.  Hence the live_to_end flag to differentiate</span>
<span class="line-added">+      * between these two cases.</span>
       *
       * @param cp constant pool
       */
<span class="line-modified">!     public LocalVariable getLocalVariable( final ConstantPoolGen cp ) {</span>
          int start_pc = 0;
          int length = 0;
          if ((start != null) &amp;&amp; (end != null)) {
              start_pc = start.getPosition();
              length = end.getPosition() - start_pc;
<span class="line-modified">!             if ((end.getNext() == null) &amp;&amp; live_to_end) {</span>
                  length += end.getInstruction().getLength();
              }
          }
          final int name_index = cp.addUtf8(name);
          final int signature_index = cp.addUtf8(type.getSignature());
          return new LocalVariable(start_pc, length, name_index, signature_index, index, cp
<span class="line-modified">!                 .getConstantPool(), orig_index);</span>
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setIndex( final int index ) {</span>
          this.index = index;
      }
  
<span class="line-added">+ </span>
      public int getIndex() {
          return index;
      }
  
<span class="line-added">+ </span>
<span class="line-added">+     public int getOrigIndex() {</span>
<span class="line-added">+         return orig_index;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     public void setLiveToEnd( final boolean live_to_end) {</span>
<span class="line-added">+         this.live_to_end = live_to_end;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     public boolean getLiveToEnd() {</span>
<span class="line-added">+         return live_to_end;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     public void setName( final String name ) {</span>
          this.name = name;
      }
  
<span class="line-added">+ </span>
      @Override
      public String getName() {
          return name;
      }
  
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     public void setType( final Type type ) {</span>
          this.type = type;
      }
  
<span class="line-added">+ </span>
      @Override
      public Type getType() {
          return type;
      }
  
<span class="line-added">+ </span>
      public InstructionHandle getStart() {
          return start;
      }
  
<span class="line-added">+ </span>
      public InstructionHandle getEnd() {
          return end;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setStart( final InstructionHandle start ) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.start, start, this);
          this.start = start;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setEnd( final InstructionHandle end ) { // TODO could be package-protected?</span>
          BranchInstruction.notifyTarget(this.end, end, this);
          this.end = end;
      }
  
<span class="line-added">+ </span>
      /**
       * @param old_ih old target, either start or end
       * @param new_ih new target
       */
      @Override
<span class="line-modified">!     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
          boolean targeted = false;
          if (start == old_ih) {
              targeted = true;
              setStart(new_ih);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,39 ***</span>
  
      /**
       * @return true, if ih is target of this variable
       */
      @Override
<span class="line-modified">!     public boolean containsTarget(final InstructionHandle ih) {</span>
          return (start == ih) || (end == ih);
      }
  
      @Override
      public int hashCode() {
          // If the user changes the name or type, problems with the targeter hashmap will occur.
          // Note: index cannot be part of hash as it may be changed by the user.
          return name.hashCode() ^ type.hashCode();
      }
  
      /**
       * We consider to local variables to be equal, if the use the same index and
       * are valid in the same range.
       */
      @Override
<span class="line-modified">!     public boolean equals(final Object o) {</span>
          if (!(o instanceof LocalVariableGen)) {
              return false;
          }
          final LocalVariableGen l = (LocalVariableGen) o;
          return (l.index == index) &amp;&amp; (l.start == start) &amp;&amp; (l.end == end);
      }
  
      @Override
      public String toString() {
          return &quot;LocalVariableGen(&quot; + name + &quot;, &quot; + type + &quot;, &quot; + start + &quot;, &quot; + end + &quot;)&quot;;
      }
  
      @Override
      public Object clone() {
          try {
              return super.clone();
          } catch (final CloneNotSupportedException e) {
<span class="line-new-header">--- 219,43 ---</span>
  
      /**
       * @return true, if ih is target of this variable
       */
      @Override
<span class="line-modified">!     public boolean containsTarget( final InstructionHandle ih ) {</span>
          return (start == ih) || (end == ih);
      }
  
<span class="line-added">+ </span>
      @Override
      public int hashCode() {
          // If the user changes the name or type, problems with the targeter hashmap will occur.
          // Note: index cannot be part of hash as it may be changed by the user.
          return name.hashCode() ^ type.hashCode();
      }
  
<span class="line-added">+ </span>
      /**
       * We consider to local variables to be equal, if the use the same index and
       * are valid in the same range.
       */
      @Override
<span class="line-modified">!     public boolean equals( final Object o ) {</span>
          if (!(o instanceof LocalVariableGen)) {
              return false;
          }
          final LocalVariableGen l = (LocalVariableGen) o;
          return (l.index == index) &amp;&amp; (l.start == start) &amp;&amp; (l.end == end);
      }
  
<span class="line-added">+ </span>
      @Override
      public String toString() {
          return &quot;LocalVariableGen(&quot; + name + &quot;, &quot; + type + &quot;, &quot; + start + &quot;, &quot; + end + &quot;)&quot;;
      }
  
<span class="line-added">+ </span>
      @Override
      public Object clone() {
          try {
              return super.clone();
          } catch (final CloneNotSupportedException e) {
</pre>
<center><a href="LoadInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LocalVariableInstruction.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
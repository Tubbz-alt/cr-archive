<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TargetLostException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TypedInstruction.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Type.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;
 27 import com.sun.org.apache.bcel.internal.classfile.Utility;
 28 
 29 /**
<span class="line-modified"> 30  * Abstract super class for all possible java types, namely basic types such as</span>
<span class="line-modified"> 31  * int, object types like String and array types, e.g. int[]</span>
 32  *
<span class="line-modified"> 33  * @version $Id: Type.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 34  */
 35 public abstract class Type {
 36 
 37     private final byte type;
 38     private String signature; // signature for the type
 39     /**
 40      * Predefined constants
 41      */
 42     public static final BasicType VOID = new BasicType(Const.T_VOID);
 43     public static final BasicType BOOLEAN = new BasicType(Const.T_BOOLEAN);
 44     public static final BasicType INT = new BasicType(Const.T_INT);
 45     public static final BasicType SHORT = new BasicType(Const.T_SHORT);
 46     public static final BasicType BYTE = new BasicType(Const.T_BYTE);
 47     public static final BasicType LONG = new BasicType(Const.T_LONG);
 48     public static final BasicType DOUBLE = new BasicType(Const.T_DOUBLE);
 49     public static final BasicType FLOAT = new BasicType(Const.T_FLOAT);
 50     public static final BasicType CHAR = new BasicType(Const.T_CHAR);
 51     public static final ObjectType OBJECT = new ObjectType(&quot;java.lang.Object&quot;);
 52     public static final ObjectType CLASS = new ObjectType(&quot;java.lang.Class&quot;);
 53     public static final ObjectType STRING = new ObjectType(&quot;java.lang.String&quot;);
 54     public static final ObjectType STRINGBUFFER = new ObjectType(&quot;java.lang.StringBuffer&quot;);
 55     public static final ObjectType THROWABLE = new ObjectType(&quot;java.lang.Throwable&quot;);
 56     public static final Type[] NO_ARGS = new Type[0]; // EMPTY, so immutable
 57     public static final ReferenceType NULL = new ReferenceType() {
 58     };
 59     public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, &quot;&lt;unknown object&gt;&quot;) {
 60     };
 61 

 62     protected Type(final byte t, final String s) {
 63         type = t;
 64         signature = s;
 65     }
 66 

 67     /**
 68      * @return hashcode of Type
 69      */
 70     @Override
 71     public int hashCode() {
 72         return type ^ signature.hashCode();
 73     }
 74 

 75     /**
 76      * @return whether the Types are equal
 77      */
 78     @Override
 79     public boolean equals(final Object o) {
<span class="line-modified"> 80         if (o instanceof Type) {</span>
<span class="line-modified"> 81             final Type t = (Type) o;</span>
<span class="line-modified"> 82             return (type == t.type) &amp;&amp; signature.equals(t.signature);</span>
<span class="line-modified"> 83         }</span>
<span class="line-modified"> 84         return false;</span>
 85     }
 86 

 87     /**
 88      * @return signature for given type.
 89      */
 90     public String getSignature() {
 91         return signature;
 92     }
 93 

 94     /**
 95      * @return type as defined in Constants
 96      */
 97     public byte getType() {
 98         return type;
 99     }
100 
101     /**
<span class="line-modified">102      * boolean, short and char variable are considered as int in the stack or</span>
<span class="line-modified">103      * local variable area. Returns {@link Type#INT} for</span>
<span class="line-removed">104      * {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise</span>
105      * returns the given type.
<span class="line-removed">106      *</span>
107      * @since 6.0
108      */
109     public Type normalizeForStackOrLocal() {
110         if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {
111             return Type.INT;
112         }
113         return this;
114     }
115 
116     /**
<span class="line-modified">117      * @return stack size of this type (2 for long and double, 0 for void, 1</span>
<span class="line-removed">118      * otherwise)</span>
119      */
120     public int getSize() {
121         switch (type) {
122             case Const.T_DOUBLE:
123             case Const.T_LONG:
124                 return 2;
125             case Const.T_VOID:
126                 return 0;
127             default:
128                 return 1;
129         }
130     }
131 

132     /**
133      * @return Type string, e.g. `int[]&#39;
134      */
135     @Override
136     public String toString() {
137         return ((this.equals(Type.NULL) || (type &gt;= Const.T_UNKNOWN))) ? signature : Utility
138                 .signatureToString(signature, false);
139     }
140 

141     /**
142      * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
143      * becomes (Ljava/lang/String;)[I
144      *
145      * @param return_type what the method returns
146      * @param arg_types what are the argument types
147      * @return method signature for given type(s).
148      */
<span class="line-modified">149     public static String getMethodSignature(final Type return_type, final Type[] arg_types) {</span>
150         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
151         if (arg_types != null) {
152             for (final Type arg_type : arg_types) {
153                 buf.append(arg_type.getSignature());
154             }
155         }
156         buf.append(&#39;)&#39;);
157         buf.append(return_type.getSignature());
158         return buf.toString();
159     }
160 
161     private static final ThreadLocal&lt;Integer&gt; consumed_chars = new ThreadLocal&lt;Integer&gt;() {
162 
163         @Override
164         protected Integer initialValue() {
165             return Integer.valueOf(0);
166         }
167     };//int consumed_chars=0; // Remember position in string, see getArgumentTypes
168 
<span class="line-modified">169     private static int unwrap(final ThreadLocal&lt;Integer&gt; tl) {</span>

170         return tl.get().intValue();
171     }
172 
<span class="line-modified">173     private static void wrap(final ThreadLocal&lt;Integer&gt; tl, final int value) {</span>

174         tl.set(Integer.valueOf(value));
175     }
176 

177     /**
178      * Convert signature to a Type object.
<span class="line-removed">179      *</span>
180      * @param signature signature string such as Ljava/lang/String;
181      * @return type object
182      */
183     // @since 6.0 no longer final
<span class="line-modified">184     public static Type getType(final String signature) throws StringIndexOutOfBoundsException {</span>
185         final byte type = Utility.typeOfSignature(signature);
186         if (type &lt;= Const.T_VOID) {
187             //corrected concurrent private static field acess
188             wrap(consumed_chars, 1);
189             return BasicType.getType(type);
190         } else if (type == Const.T_ARRAY) {
191             int dim = 0;
192             do { // Count dimensions
193                 dim++;
194             } while (signature.charAt(dim) == &#39;[&#39;);
195             // Recurse, but just once, if the signature is ok
196             final Type t = getType(signature.substring(dim));
197             //corrected concurrent private static field acess
198             //  consumed_chars += dim; // update counter - is replaced by
199             final int _temp = unwrap(consumed_chars) + dim;
200             wrap(consumed_chars, _temp);
201             return new ArrayType(t, dim);
202         } else { // type == T_REFERENCE
<span class="line-modified">203             // Utility.signatureToString understands how to parse</span>
<span class="line-modified">204             // generic types.</span>
<span class="line-removed">205             final String parsedSignature = Utility.signatureToString(signature, false);</span>
206             wrap(consumed_chars, parsedSignature.length() + 2); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
207             return ObjectType.getInstance(parsedSignature.replace(&#39;/&#39;, &#39;.&#39;));
208         }
209     }
210 

211     /**
212      * Convert return value of a method (signature) to a Type object.
213      *
214      * @param signature signature string such as (Ljava/lang/String;)V
215      * @return return type
216      */
<span class="line-modified">217     public static Type getReturnType(final String signature) {</span>
218         try {
219             // Read return type after `)&#39;
220             final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
221             return getType(signature.substring(index));
222         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
223             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
224         }
225     }
226 

227     /**
228      * Convert arguments of a method (signature) to an array of Type objects.
<span class="line-removed">229      *</span>
230      * @param signature signature string such as (Ljava/lang/String;)V
231      * @return array of argument types
232      */
<span class="line-modified">233     public static Type[] getArgumentTypes(final String signature) {</span>
234         final List&lt;Type&gt; vec = new ArrayList&lt;&gt;();
235         int index;
236         Type[] types;
<span class="line-modified">237         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">238             if (signature.charAt(0) != &#39;(&#39;) {</span>


239                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
240             }
<span class="line-removed">241             index = 1; // current string position</span>
242             while (signature.charAt(index) != &#39;)&#39;) {
243                 vec.add(getType(signature.substring(index)));
244                 //corrected concurrent private static field acess
245                 index += unwrap(consumed_chars); // update position
246             }
247         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
248             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
249         }
250         types = new Type[vec.size()];
251         vec.toArray(types);
252         return types;
253     }
254 
<span class="line-modified">255     /**</span>
<span class="line-modified">256      * Convert runtime java.lang.Class to BCEL Type object.</span>
<span class="line-removed">257      *</span>
258      * @param cl Java class
259      * @return corresponding Type object
260      */
<span class="line-modified">261     public static Type getType(final java.lang.Class&lt;?&gt; cl) {</span>
262         if (cl == null) {
263             throw new IllegalArgumentException(&quot;Class must not be null&quot;);
264         }
265         /* That&#39;s an amzingly easy case, because getName() returns
266          * the signature. That&#39;s what we would have liked anyway.
267          */
268         if (cl.isArray()) {
269             return getType(cl.getName());
270         } else if (cl.isPrimitive()) {
271             if (cl == Integer.TYPE) {
272                 return INT;
273             } else if (cl == Void.TYPE) {
274                 return VOID;
275             } else if (cl == Double.TYPE) {
276                 return DOUBLE;
277             } else if (cl == Float.TYPE) {
278                 return FLOAT;
279             } else if (cl == Boolean.TYPE) {
280                 return BOOLEAN;
281             } else if (cl == Byte.TYPE) {
282                 return BYTE;
283             } else if (cl == Short.TYPE) {
284                 return SHORT;
285             } else if (cl == Byte.TYPE) {
286                 return BYTE;
287             } else if (cl == Long.TYPE) {
288                 return LONG;
289             } else if (cl == Character.TYPE) {
290                 return CHAR;
291             } else {
292                 throw new IllegalStateException(&quot;Ooops, what primitive type is &quot; + cl);
293             }
294         } else { // &quot;Real&quot; class
295             return ObjectType.getInstance(cl.getName());
296         }
297     }
298 

299     /**
300      * Convert runtime java.lang.Class[] to BCEL Type objects.
<span class="line-removed">301      *</span>
302      * @param classes an array of runtime class objects
303      * @return array of corresponding Type objects
304      */
<span class="line-modified">305     public static Type[] getTypes(final java.lang.Class&lt;?&gt;[] classes) {</span>
306         final Type[] ret = new Type[classes.length];
307         for (int i = 0; i &lt; ret.length; i++) {
308             ret[i] = getType(classes[i]);
309         }
310         return ret;
311     }
312 
<span class="line-modified">313     public static String getSignature(final java.lang.reflect.Method meth) {</span>

314         final StringBuilder sb = new StringBuilder(&quot;(&quot;);
315         final Class&lt;?&gt;[] params = meth.getParameterTypes(); // avoid clone
316         for (final Class&lt;?&gt; param : params) {
317             sb.append(getType(param).getSignature());
318         }
319         sb.append(&quot;)&quot;);
320         sb.append(getType(meth.getReturnType()).getSignature());
321         return sb.toString();
322     }
323 
324     static int size(final int coded) {
325         return coded &amp; 3;
326     }
327 
328     static int consumed(final int coded) {
329         return coded &gt;&gt; 2;
330     }
331 
332     static int encode(final int size, final int consumed) {
333         return consumed &lt;&lt; 2 | size;
334     }
335 
<span class="line-modified">336     static int getArgumentTypesSize(final String signature) {</span>
337         int res = 0;
338         int index;
<span class="line-modified">339         try { // Read all declarations between for `(&#39; and `)&#39;</span>
<span class="line-modified">340             if (signature.charAt(0) != &#39;(&#39;) {</span>


341                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
342             }
<span class="line-removed">343             index = 1; // current string position</span>
344             while (signature.charAt(index) != &#39;)&#39;) {
345                 final int coded = getTypeSize(signature.substring(index));
346                 res += size(coded);
347                 index += consumed(coded);
348             }
349         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
350             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
351         }
352         return res;
353     }
354 
<span class="line-modified">355     static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {</span>
356         final byte type = Utility.typeOfSignature(signature);
357         if (type &lt;= Const.T_VOID) {
358             return encode(BasicType.getType(type).getSize(), 1);
359         } else if (type == Const.T_ARRAY) {
360             int dim = 0;
361             do { // Count dimensions
362                 dim++;
363             } while (signature.charAt(dim) == &#39;[&#39;);
364             // Recurse, but just once, if the signature is ok
365             final int consumed = consumed(getTypeSize(signature.substring(dim)));
366             return encode(1, dim + consumed);
367         } else { // type == T_REFERENCE
368             final int index = signature.indexOf(&#39;;&#39;); // Look for closing `;&#39;
369             if (index &lt; 0) {
370                 throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
371             }
372             return encode(1, index + 1);
373         }
374     }
375 

376     static int getReturnTypeSize(final String signature) {
377         final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
378         return Type.size(getTypeSize(signature.substring(index)));
379     }
380 
381 
382     /*
383      * Currently only used by the ArrayType constructor.
384      * The signature has a complicated dependency on other parameter
385      * so it&#39;s tricky to do it in a call to the super ctor.
386      */
387     void setSignature(final String signature) {
388         this.signature = signature;
389     }
390 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.ArrayList;
 23 import java.util.List;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;
 27 import com.sun.org.apache.bcel.internal.classfile.Utility;
 28 
 29 /**
<span class="line-modified"> 30  * Abstract super class for all possible java types, namely basic types</span>
<span class="line-modified"> 31  * such as int, object types like String and array types, e.g. int[]</span>
 32  *
<span class="line-modified"> 33  * @LastModified: Jan 2020</span>
 34  */
 35 public abstract class Type {
 36 
 37     private final byte type;
 38     private String signature; // signature for the type
 39     /**
 40      * Predefined constants
 41      */
 42     public static final BasicType VOID = new BasicType(Const.T_VOID);
 43     public static final BasicType BOOLEAN = new BasicType(Const.T_BOOLEAN);
 44     public static final BasicType INT = new BasicType(Const.T_INT);
 45     public static final BasicType SHORT = new BasicType(Const.T_SHORT);
 46     public static final BasicType BYTE = new BasicType(Const.T_BYTE);
 47     public static final BasicType LONG = new BasicType(Const.T_LONG);
 48     public static final BasicType DOUBLE = new BasicType(Const.T_DOUBLE);
 49     public static final BasicType FLOAT = new BasicType(Const.T_FLOAT);
 50     public static final BasicType CHAR = new BasicType(Const.T_CHAR);
 51     public static final ObjectType OBJECT = new ObjectType(&quot;java.lang.Object&quot;);
 52     public static final ObjectType CLASS = new ObjectType(&quot;java.lang.Class&quot;);
 53     public static final ObjectType STRING = new ObjectType(&quot;java.lang.String&quot;);
 54     public static final ObjectType STRINGBUFFER = new ObjectType(&quot;java.lang.StringBuffer&quot;);
 55     public static final ObjectType THROWABLE = new ObjectType(&quot;java.lang.Throwable&quot;);
 56     public static final Type[] NO_ARGS = new Type[0]; // EMPTY, so immutable
 57     public static final ReferenceType NULL = new ReferenceType() {
 58     };
 59     public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, &quot;&lt;unknown object&gt;&quot;) {
 60     };
 61 
<span class="line-added"> 62 </span>
 63     protected Type(final byte t, final String s) {
 64         type = t;
 65         signature = s;
 66     }
 67 
<span class="line-added"> 68 </span>
 69     /**
 70      * @return hashcode of Type
 71      */
 72     @Override
 73     public int hashCode() {
 74         return type ^ signature.hashCode();
 75     }
 76 
<span class="line-added"> 77 </span>
 78     /**
 79      * @return whether the Types are equal
 80      */
 81     @Override
 82     public boolean equals(final Object o) {
<span class="line-modified"> 83           if (o instanceof Type) {</span>
<span class="line-modified"> 84               final Type t = (Type)o;</span>
<span class="line-modified"> 85               return (type == t.type) &amp;&amp; signature.equals(t.signature);</span>
<span class="line-modified"> 86           }</span>
<span class="line-modified"> 87           return false;</span>
 88     }
 89 
<span class="line-added"> 90 </span>
 91     /**
 92      * @return signature for given type.
 93      */
 94     public String getSignature() {
 95         return signature;
 96     }
 97 
<span class="line-added"> 98 </span>
 99     /**
100      * @return type as defined in Constants
101      */
102     public byte getType() {
103         return type;
104     }
105 
106     /**
<span class="line-modified">107      * boolean, short and char variable are considered as int in the stack or local variable area.</span>
<span class="line-modified">108      * Returns {@link Type#INT} for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise</span>

109      * returns the given type.

110      * @since 6.0
111      */
112     public Type normalizeForStackOrLocal() {
113         if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {
114             return Type.INT;
115         }
116         return this;
117     }
118 
119     /**
<span class="line-modified">120      * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)</span>

121      */
122     public int getSize() {
123         switch (type) {
124             case Const.T_DOUBLE:
125             case Const.T_LONG:
126                 return 2;
127             case Const.T_VOID:
128                 return 0;
129             default:
130                 return 1;
131         }
132     }
133 
<span class="line-added">134 </span>
135     /**
136      * @return Type string, e.g. `int[]&#39;
137      */
138     @Override
139     public String toString() {
140         return ((this.equals(Type.NULL) || (type &gt;= Const.T_UNKNOWN))) ? signature : Utility
141                 .signatureToString(signature, false);
142     }
143 
<span class="line-added">144 </span>
145     /**
146      * Convert type to Java method signature, e.g. int[] f(java.lang.String x)
147      * becomes (Ljava/lang/String;)[I
148      *
149      * @param return_type what the method returns
150      * @param arg_types what are the argument types
151      * @return method signature for given type(s).
152      */
<span class="line-modified">153     public static String getMethodSignature( final Type return_type, final Type[] arg_types ) {</span>
154         final StringBuilder buf = new StringBuilder(&quot;(&quot;);
155         if (arg_types != null) {
156             for (final Type arg_type : arg_types) {
157                 buf.append(arg_type.getSignature());
158             }
159         }
160         buf.append(&#39;)&#39;);
161         buf.append(return_type.getSignature());
162         return buf.toString();
163     }
164 
165     private static final ThreadLocal&lt;Integer&gt; consumed_chars = new ThreadLocal&lt;Integer&gt;() {
166 
167         @Override
168         protected Integer initialValue() {
169             return Integer.valueOf(0);
170         }
171     };//int consumed_chars=0; // Remember position in string, see getArgumentTypes
172 
<span class="line-modified">173 </span>
<span class="line-added">174     private static int unwrap( final ThreadLocal&lt;Integer&gt; tl ) {</span>
175         return tl.get().intValue();
176     }
177 
<span class="line-modified">178 </span>
<span class="line-added">179     private static void wrap( final ThreadLocal&lt;Integer&gt; tl, final int value ) {</span>
180         tl.set(Integer.valueOf(value));
181     }
182 
<span class="line-added">183 </span>
184     /**
185      * Convert signature to a Type object.

186      * @param signature signature string such as Ljava/lang/String;
187      * @return type object
188      */
189     // @since 6.0 no longer final
<span class="line-modified">190     public static Type getType( final String signature ) throws StringIndexOutOfBoundsException {</span>
191         final byte type = Utility.typeOfSignature(signature);
192         if (type &lt;= Const.T_VOID) {
193             //corrected concurrent private static field acess
194             wrap(consumed_chars, 1);
195             return BasicType.getType(type);
196         } else if (type == Const.T_ARRAY) {
197             int dim = 0;
198             do { // Count dimensions
199                 dim++;
200             } while (signature.charAt(dim) == &#39;[&#39;);
201             // Recurse, but just once, if the signature is ok
202             final Type t = getType(signature.substring(dim));
203             //corrected concurrent private static field acess
204             //  consumed_chars += dim; // update counter - is replaced by
205             final int _temp = unwrap(consumed_chars) + dim;
206             wrap(consumed_chars, _temp);
207             return new ArrayType(t, dim);
208         } else { // type == T_REFERENCE
<span class="line-modified">209             // Utility.typeSignatureToString understands how to parse generic types.</span>
<span class="line-modified">210             final String parsedSignature = Utility.typeSignatureToString(signature, false);</span>

211             wrap(consumed_chars, parsedSignature.length() + 2); // &quot;Lblabla;&quot; `L&#39; and `;&#39; are removed
212             return ObjectType.getInstance(parsedSignature.replace(&#39;/&#39;, &#39;.&#39;));
213         }
214     }
215 
<span class="line-added">216 </span>
217     /**
218      * Convert return value of a method (signature) to a Type object.
219      *
220      * @param signature signature string such as (Ljava/lang/String;)V
221      * @return return type
222      */
<span class="line-modified">223     public static Type getReturnType( final String signature ) {</span>
224         try {
225             // Read return type after `)&#39;
226             final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
227             return getType(signature.substring(index));
228         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
229             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
230         }
231     }
232 
<span class="line-added">233 </span>
234     /**
235      * Convert arguments of a method (signature) to an array of Type objects.

236      * @param signature signature string such as (Ljava/lang/String;)V
237      * @return array of argument types
238      */
<span class="line-modified">239     public static Type[] getArgumentTypes( final String signature ) {</span>
240         final List&lt;Type&gt; vec = new ArrayList&lt;&gt;();
241         int index;
242         Type[] types;
<span class="line-modified">243         try {</span>
<span class="line-modified">244             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added">245             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added">246             if (index &lt;= 0) {</span>
247                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
248             }

249             while (signature.charAt(index) != &#39;)&#39;) {
250                 vec.add(getType(signature.substring(index)));
251                 //corrected concurrent private static field acess
252                 index += unwrap(consumed_chars); // update position
253             }
254         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
255             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
256         }
257         types = new Type[vec.size()];
258         vec.toArray(types);
259         return types;
260     }
261 
<span class="line-modified">262 </span>
<span class="line-modified">263     /** Convert runtime java.lang.Class to BCEL Type object.</span>

264      * @param cl Java class
265      * @return corresponding Type object
266      */
<span class="line-modified">267     public static Type getType( final java.lang.Class&lt;?&gt; cl ) {</span>
268         if (cl == null) {
269             throw new IllegalArgumentException(&quot;Class must not be null&quot;);
270         }
271         /* That&#39;s an amzingly easy case, because getName() returns
272          * the signature. That&#39;s what we would have liked anyway.
273          */
274         if (cl.isArray()) {
275             return getType(cl.getName());
276         } else if (cl.isPrimitive()) {
277             if (cl == Integer.TYPE) {
278                 return INT;
279             } else if (cl == Void.TYPE) {
280                 return VOID;
281             } else if (cl == Double.TYPE) {
282                 return DOUBLE;
283             } else if (cl == Float.TYPE) {
284                 return FLOAT;
285             } else if (cl == Boolean.TYPE) {
286                 return BOOLEAN;
287             } else if (cl == Byte.TYPE) {
288                 return BYTE;
289             } else if (cl == Short.TYPE) {
290                 return SHORT;
291             } else if (cl == Byte.TYPE) {
292                 return BYTE;
293             } else if (cl == Long.TYPE) {
294                 return LONG;
295             } else if (cl == Character.TYPE) {
296                 return CHAR;
297             } else {
298                 throw new IllegalStateException(&quot;Ooops, what primitive type is &quot; + cl);
299             }
300         } else { // &quot;Real&quot; class
301             return ObjectType.getInstance(cl.getName());
302         }
303     }
304 
<span class="line-added">305 </span>
306     /**
307      * Convert runtime java.lang.Class[] to BCEL Type objects.

308      * @param classes an array of runtime class objects
309      * @return array of corresponding Type objects
310      */
<span class="line-modified">311     public static Type[] getTypes( final java.lang.Class&lt;?&gt;[] classes ) {</span>
312         final Type[] ret = new Type[classes.length];
313         for (int i = 0; i &lt; ret.length; i++) {
314             ret[i] = getType(classes[i]);
315         }
316         return ret;
317     }
318 
<span class="line-modified">319 </span>
<span class="line-added">320     public static String getSignature( final java.lang.reflect.Method meth ) {</span>
321         final StringBuilder sb = new StringBuilder(&quot;(&quot;);
322         final Class&lt;?&gt;[] params = meth.getParameterTypes(); // avoid clone
323         for (final Class&lt;?&gt; param : params) {
324             sb.append(getType(param).getSignature());
325         }
326         sb.append(&quot;)&quot;);
327         sb.append(getType(meth.getReturnType()).getSignature());
328         return sb.toString();
329     }
330 
331     static int size(final int coded) {
332         return coded &amp; 3;
333     }
334 
335     static int consumed(final int coded) {
336         return coded &gt;&gt; 2;
337     }
338 
339     static int encode(final int size, final int consumed) {
340         return consumed &lt;&lt; 2 | size;
341     }
342 
<span class="line-modified">343     static int getArgumentTypesSize( final String signature ) {</span>
344         int res = 0;
345         int index;
<span class="line-modified">346         try {</span>
<span class="line-modified">347             // Skip any type arguments to read argument declarations between `(&#39; and `)&#39;</span>
<span class="line-added">348             index = signature.indexOf(&#39;(&#39;) + 1;</span>
<span class="line-added">349             if (index &lt;= 0) {</span>
350                 throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature);
351             }

352             while (signature.charAt(index) != &#39;)&#39;) {
353                 final int coded = getTypeSize(signature.substring(index));
354                 res += size(coded);
355                 index += consumed(coded);
356             }
357         } catch (final StringIndexOutOfBoundsException e) { // Should never occur
358             throw new ClassFormatException(&quot;Invalid method signature: &quot; + signature, e);
359         }
360         return res;
361     }
362 
<span class="line-modified">363     static int getTypeSize( final String signature ) throws StringIndexOutOfBoundsException {</span>
364         final byte type = Utility.typeOfSignature(signature);
365         if (type &lt;= Const.T_VOID) {
366             return encode(BasicType.getType(type).getSize(), 1);
367         } else if (type == Const.T_ARRAY) {
368             int dim = 0;
369             do { // Count dimensions
370                 dim++;
371             } while (signature.charAt(dim) == &#39;[&#39;);
372             // Recurse, but just once, if the signature is ok
373             final int consumed = consumed(getTypeSize(signature.substring(dim)));
374             return encode(1, dim + consumed);
375         } else { // type == T_REFERENCE
376             final int index = signature.indexOf(&#39;;&#39;); // Look for closing `;&#39;
377             if (index &lt; 0) {
378                 throw new ClassFormatException(&quot;Invalid signature: &quot; + signature);
379             }
380             return encode(1, index + 1);
381         }
382     }
383 
<span class="line-added">384 </span>
385     static int getReturnTypeSize(final String signature) {
386         final int index = signature.lastIndexOf(&#39;)&#39;) + 1;
387         return Type.size(getTypeSize(signature.substring(index)));
388     }
389 
390 
391     /*
392      * Currently only used by the ArrayType constructor.
393      * The signature has a complicated dependency on other parameter
394      * so it&#39;s tricky to do it in a call to the super ctor.
395      */
396     void setSignature(final String signature) {
397         this.signature = signature;
398     }
399 }
</pre>
</td>
</tr>
</table>
<center><a href="TargetLostException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="TypedInstruction.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
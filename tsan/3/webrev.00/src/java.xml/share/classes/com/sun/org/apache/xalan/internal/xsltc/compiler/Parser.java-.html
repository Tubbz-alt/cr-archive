<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/Parser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *     http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xalan.internal.xsltc.compiler;
  22 
  23 import com.sun.java_cup.internal.runtime.Symbol;
  24 import com.sun.org.apache.xalan.internal.XalanConstants;
  25 import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
  26 import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
  27 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
  28 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodType;
  29 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.Type;
  30 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.TypeCheckError;
  31 import com.sun.org.apache.xml.internal.serializer.utils.SystemIDResolver;
  32 import java.io.File;
  33 import java.io.IOException;
  34 import java.io.StringReader;
  35 import java.util.ArrayList;
  36 import java.util.HashMap;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Properties;
  41 import java.util.Stack;
  42 import java.util.StringTokenizer;
  43 import javax.xml.XMLConstants;
  44 import javax.xml.catalog.CatalogFeatures;
  45 import jdk.xml.internal.JdkXmlFeatures;
  46 import jdk.xml.internal.JdkXmlUtils;
  47 import jdk.xml.internal.SecuritySupport;
  48 import org.xml.sax.Attributes;
  49 import org.xml.sax.ContentHandler;
  50 import org.xml.sax.InputSource;
  51 import org.xml.sax.Locator;
  52 import org.xml.sax.SAXException;
  53 import org.xml.sax.SAXNotRecognizedException;
  54 import org.xml.sax.SAXNotSupportedException;
  55 import org.xml.sax.XMLReader;
  56 import org.xml.sax.helpers.AttributesImpl;
  57 
  58 /**
  59  * @author Jacek Ambroziak
  60  * @author Santiago Pericas-Geertsen
  61  * @author G. Todd Miller
  62  * @author Morten Jorgensen
  63  * @author Erwin Bolwidt &lt;ejb@klomp.org&gt;
  64  * @LastModified: Nov 2017
  65  */
  66 public class Parser implements Constants, ContentHandler {
  67 
  68     private static final String XSL = &quot;xsl&quot;;           // standard prefix
  69     private static final String TRANSLET = &quot;translet&quot;; // extension prefix
  70 
  71     private Locator _locator = null;
  72 
  73     private XSLTC _xsltc;                  // Reference to the compiler object.
  74     private XPathParser _xpathParser;      // Reference to the XPath parser.
  75     private ArrayList&lt;ErrorMsg&gt; _errors;   // Contains all compilation errors
  76     private ArrayList&lt;ErrorMsg&gt; _warnings; // Contains all compilation warnings
  77 
  78     private Map&lt;String, String&gt;   _instructionClasses; // Maps instructions to classes
  79     private Map&lt;String, String[]&gt; _instructionAttrs;  // reqd and opt attrs
  80     private Map&lt;String, QName&gt;    _qNames;
  81     private Map&lt;String, Map&lt;String, QName&gt;&gt; _namespaces;
  82     private QName       _useAttributeSets;
  83     private QName       _excludeResultPrefixes;
  84     private QName       _extensionElementPrefixes;
  85     private Map&lt;String, Object&gt;   _variableScope;
  86     private Stylesheet  _currentStylesheet;
  87     private SymbolTable _symbolTable; // Maps QNames to syntax-tree nodes
  88     private Output      _output;
  89     private Template    _template;    // Reference to the template being parsed.
  90 
  91     private boolean     _rootNamespaceDef; // Used for validity check
  92 
  93     private SyntaxTreeNode _root;
  94 
  95     private String _target;
  96 
  97     private int _currentImportPrecedence;
  98 
  99     private boolean _overrideDefaultParser;
 100 
 101     public Parser(XSLTC xsltc, boolean useOverrideDefaultParser) {
 102         _xsltc = xsltc;
 103         _overrideDefaultParser = useOverrideDefaultParser;
 104     }
 105 
 106     public void init() {
 107         _qNames              = new HashMap&lt;&gt;(512);
 108         _namespaces          = new HashMap&lt;&gt;();
 109         _instructionClasses  = new HashMap&lt;&gt;();
 110         _instructionAttrs    = new HashMap&lt;&gt;();
 111         _variableScope       = new HashMap&lt;&gt;();
 112         _template            = null;
 113         _errors              = new ArrayList&lt;&gt;();
 114         _warnings            = new ArrayList&lt;&gt;();
 115         _symbolTable         = new SymbolTable();
 116         _xpathParser         = new XPathParser(this);
 117         _currentStylesheet   = null;
 118         _output              = null;
 119         _root                = null;
 120         _rootNamespaceDef    = false;
 121         _currentImportPrecedence = 1;
 122 
 123         initStdClasses();
 124         initInstructionAttrs();
 125         initExtClasses();
 126         initSymbolTable();
 127 
 128         _useAttributeSets =
 129             getQName(XSLT_URI, XSL, &quot;use-attribute-sets&quot;);
 130         _excludeResultPrefixes =
 131             getQName(XSLT_URI, XSL, &quot;exclude-result-prefixes&quot;);
 132         _extensionElementPrefixes =
 133             getQName(XSLT_URI, XSL, &quot;extension-element-prefixes&quot;);
 134     }
 135 
 136     public void setOutput(Output output) {
 137         if (_output != null) {
 138             if (_output.getImportPrecedence() &lt;= output.getImportPrecedence()) {
 139                 output.mergeOutput(_output);
 140                 _output.disable();
 141                 _output = output;
 142             }
 143             else {
 144                 output.disable();
 145             }
 146         }
 147         else {
 148             _output = output;
 149         }
 150     }
 151 
 152     public Output getOutput() {
 153         return _output;
 154     }
 155 
 156     public Properties getOutputProperties() {
 157         return getTopLevelStylesheet().getOutputProperties();
 158     }
 159 
 160     public void addVariable(Variable var) {
 161         addVariableOrParam(var);
 162     }
 163 
 164     public void addParameter(Param param) {
 165         addVariableOrParam(param);
 166     }
 167 
 168     private void addVariableOrParam(VariableBase var) {
 169         Object existing = _variableScope.get(var.getName().getStringRep());
 170         if (existing != null) {
 171             if (existing instanceof Stack) {
 172                 @SuppressWarnings(&quot;unchecked&quot;)
 173                 Stack&lt;VariableBase&gt; stack = (Stack&lt;VariableBase&gt;)existing;
 174                 stack.push(var);
 175             }
 176             else if (existing instanceof VariableBase) {
 177                 Stack&lt;VariableBase&gt; stack = new Stack&lt;&gt;();
 178                 stack.push((VariableBase)existing);
 179                 stack.push(var);
 180                 _variableScope.put(var.getName().getStringRep(), stack);
 181             }
 182         }
 183         else {
 184             _variableScope.put(var.getName().getStringRep(), var);
 185         }
 186     }
 187 
 188     public void removeVariable(QName name) {
 189         Object existing = _variableScope.get(name.getStringRep());
 190         if (existing instanceof Stack) {
 191             @SuppressWarnings(&quot;unchecked&quot;)
 192             Stack&lt;VariableBase&gt; stack = (Stack&lt;VariableBase&gt;)existing;
 193             if (!stack.isEmpty()) stack.pop();
 194             if (!stack.isEmpty()) return;
 195         }
 196         _variableScope.remove(name.getStringRep());
 197     }
 198 
 199     public VariableBase lookupVariable(QName name) {
 200         Object existing = _variableScope.get(name.getStringRep());
 201         if (existing instanceof VariableBase) {
 202             return (VariableBase)existing;
 203         }
 204         else if (existing instanceof Stack) {
 205             @SuppressWarnings(&quot;unchecked&quot;)
 206             Stack&lt;VariableBase&gt; stack = (Stack&lt;VariableBase&gt;)existing;
 207             return stack.peek();
 208         }
 209         return null;
 210     }
 211 
 212     public void setXSLTC(XSLTC xsltc) {
 213         _xsltc = xsltc;
 214     }
 215 
 216     public XSLTC getXSLTC() {
 217         return _xsltc;
 218     }
 219 
 220     public int getCurrentImportPrecedence() {
 221         return _currentImportPrecedence;
 222     }
 223 
 224     public int getNextImportPrecedence() {
 225         return ++_currentImportPrecedence;
 226     }
 227 
 228     public void setCurrentStylesheet(Stylesheet stylesheet) {
 229         _currentStylesheet = stylesheet;
 230     }
 231 
 232     public Stylesheet getCurrentStylesheet() {
 233         return _currentStylesheet;
 234     }
 235 
 236     public Stylesheet getTopLevelStylesheet() {
 237         return _xsltc.getStylesheet();
 238     }
 239 
 240     public QName getQNameSafe(final String stringRep) {
 241         // parse and retrieve namespace
 242         final int colon = stringRep.lastIndexOf(&#39;:&#39;);
 243         if (colon != -1) {
 244             final String prefix = stringRep.substring(0, colon);
 245             final String localname = stringRep.substring(colon + 1);
 246             String namespace = null;
 247 
 248             // Get the namespace uri from the symbol table
 249             if (prefix.equals(XMLNS_PREFIX) == false) {
 250                 namespace = _symbolTable.lookupNamespace(prefix);
 251                 if (namespace == null) namespace = EMPTYSTRING;
 252             }
 253             return getQName(namespace, prefix, localname);
 254         }
 255         else {
 256             final String uri = stringRep.equals(XMLNS_PREFIX) ? null
 257                 : _symbolTable.lookupNamespace(EMPTYSTRING);
 258             return getQName(uri, null, stringRep);
 259         }
 260     }
 261 
 262     public QName getQName(final String stringRep) {
 263         return getQName(stringRep, true, false);
 264     }
 265 
 266     public QName getQNameIgnoreDefaultNs(final String stringRep) {
 267         return getQName(stringRep, true, true);
 268     }
 269 
 270     public QName getQName(final String stringRep, boolean reportError) {
 271         return getQName(stringRep, reportError, false);
 272     }
 273 
 274     private QName getQName(final String stringRep, boolean reportError,
 275         boolean ignoreDefaultNs)
 276     {
 277         // parse and retrieve namespace
 278         final int colon = stringRep.lastIndexOf(&#39;:&#39;);
 279         if (colon != -1) {
 280             final String prefix = stringRep.substring(0, colon);
 281             final String localname = stringRep.substring(colon + 1);
 282             String namespace = null;
 283 
 284             // Get the namespace uri from the symbol table
 285             if (prefix.equals(XMLNS_PREFIX) == false) {
 286                 namespace = _symbolTable.lookupNamespace(prefix);
 287                 if (namespace == null &amp;&amp; reportError) {
 288                     final int line = getLineNumber();
 289                     ErrorMsg err = new ErrorMsg(ErrorMsg.NAMESPACE_UNDEF_ERR,
 290                                                 line, prefix);
 291                     reportError(ERROR, err);
 292                 }
 293             }
 294             return getQName(namespace, prefix, localname);
 295         }
 296         else {
 297             if (stringRep.equals(XMLNS_PREFIX)) {
 298                 ignoreDefaultNs = true;
 299             }
 300             final String defURI = ignoreDefaultNs ? null
 301                                   : _symbolTable.lookupNamespace(EMPTYSTRING);
 302             return getQName(defURI, null, stringRep);
 303         }
 304     }
 305 
 306     public QName getQName(String namespace, String prefix, String localname) {
 307         if (namespace == null || namespace.equals(EMPTYSTRING)) {
 308             QName name = _qNames.get(localname);
 309             if (name == null) {
 310                 name = new QName(null, prefix, localname);
 311                 _qNames.put(localname, name);
 312             }
 313             return name;
 314         }
 315         else {
 316             Map&lt;String, QName&gt; space = _namespaces.get(namespace);
 317             String lexicalQName =
 318                        (prefix == null || prefix.length() == 0)
 319                             ? localname
 320                             : (prefix + &#39;:&#39; + localname);
 321 
 322             if (space == null) {
 323                 final QName name = new QName(namespace, prefix, localname);
 324                 _namespaces.put(namespace, space = new HashMap&lt;&gt;());
 325                 space.put(lexicalQName, name);
 326                 return name;
 327             }
 328             else {
 329                 QName name = space.get(lexicalQName);
 330                 if (name == null) {
 331                     name = new QName(namespace, prefix, localname);
 332                     space.put(lexicalQName, name);
 333                 }
 334                 return name;
 335             }
 336         }
 337     }
 338 
 339     public QName getQName(String scope, String name) {
 340         return getQName(scope + name);
 341     }
 342 
 343     public QName getQName(QName scope, QName name) {
 344         return getQName(scope.toString() + name.toString());
 345     }
 346 
 347     public QName getUseAttributeSets() {
 348         return _useAttributeSets;
 349     }
 350 
 351     public QName getExtensionElementPrefixes() {
 352         return _extensionElementPrefixes;
 353     }
 354 
 355     public QName getExcludeResultPrefixes() {
 356         return _excludeResultPrefixes;
 357     }
 358 
 359     /**
 360      * Create an instance of the &lt;code&gt;Stylesheet&lt;/code&gt; class,
 361      * and then parse, typecheck and compile the instance.
 362      * Must be called after &lt;code&gt;parse()&lt;/code&gt;.
 363      */
 364     public Stylesheet makeStylesheet(SyntaxTreeNode element)
 365         throws CompilerException {
 366         try {
 367             Stylesheet stylesheet;
 368 
 369             if (element instanceof Stylesheet) {
 370                 stylesheet = (Stylesheet)element;
 371             }
 372             else {
 373                 stylesheet = new Stylesheet();
 374                 stylesheet.setSimplified();
 375                 stylesheet.addElement(element);
 376                 stylesheet.setAttributes((AttributesImpl) element.getAttributes());
 377 
 378                 // Map the default NS if not already defined
 379                 if (element.lookupNamespace(EMPTYSTRING) == null) {
 380                     element.addPrefixMapping(EMPTYSTRING, EMPTYSTRING);
 381                 }
 382             }
 383             stylesheet.setParser(this);
 384             return stylesheet;
 385         }
 386         catch (ClassCastException e) {
 387             ErrorMsg err = new ErrorMsg(ErrorMsg.NOT_STYLESHEET_ERR, element);
 388             throw new CompilerException(err.toString());
 389         }
 390     }
 391 
 392     /**
 393      * Instanciates a SAX2 parser and generate the AST from the input.
 394      */
 395     public void createAST(Stylesheet stylesheet) {
 396         try {
 397             if (stylesheet != null) {
 398                 stylesheet.parseContents(this);
 399                 final Iterator&lt;SyntaxTreeNode&gt; elements = stylesheet.elements();
 400                 while (elements.hasNext()) {
 401                     SyntaxTreeNode child = elements.next();
 402                     if (child instanceof Text) {
 403                         final int l = getLineNumber();
 404                         ErrorMsg err =
 405                             new ErrorMsg(ErrorMsg.ILLEGAL_TEXT_NODE_ERR,l,null);
 406                         reportError(ERROR, err);
 407                     }
 408                 }
 409                 if (!errorsFound()) {
 410                     stylesheet.typeCheck(_symbolTable);
 411                 }
 412             }
 413         }
 414         catch (TypeCheckError e) {
 415             reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
 416         }
 417     }
 418 
 419     /**
 420      * Parses a stylesheet and builds the internal abstract syntax tree
 421      * @param reader A SAX2 SAXReader (parser)
 422      * @param input A SAX2 InputSource can be passed to a SAX reader
 423      * @return The root of the abstract syntax tree
 424      */
 425     public SyntaxTreeNode parse(XMLReader reader, InputSource input) {
 426         try {
 427             // Parse the input document and build the abstract syntax tree
 428             reader.setContentHandler(this);
 429             reader.parse(input);
 430             // Find the start of the stylesheet within the tree
 431             return getStylesheet(_root);
 432         }
 433         catch (IOException e) {
 434             if (_xsltc.debug()) e.printStackTrace();
 435             reportError(ERROR,new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
 436         }
 437         catch (SAXException e) {
 438             Throwable ex = e.getException();
 439             if (_xsltc.debug()) {
 440                 e.printStackTrace();
 441                 if (ex != null) ex.printStackTrace();
 442             }
 443             reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
 444         }
 445         catch (CompilerException e) {
 446             if (_xsltc.debug()) e.printStackTrace();
 447             reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
 448         }
 449         catch (Exception e) {
 450             if (_xsltc.debug()) e.printStackTrace();
 451             reportError(ERROR, new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR, e));
 452         }
 453         return null;
 454     }
 455 
 456     /**
 457      * Parses a stylesheet and builds the internal abstract syntax tree
 458      * @param input A SAX2 InputSource can be passed to a SAX reader
 459      * @return The root of the abstract syntax tree
 460      */
 461     public SyntaxTreeNode parse(InputSource input) {
 462         try {
 463             final XMLReader reader = JdkXmlUtils.getXMLReader(_overrideDefaultParser,
 464                     _xsltc.isSecureProcessing());
 465 
 466             JdkXmlUtils.setXMLReaderPropertyIfSupport(reader, XMLConstants.ACCESS_EXTERNAL_DTD,
 467                     _xsltc.getProperty(XMLConstants.ACCESS_EXTERNAL_DTD), true);
 468 
 469 
 470             boolean supportCatalog = true;
 471             boolean useCatalog = _xsltc.getFeature(JdkXmlFeatures.XmlFeature.USE_CATALOG);
 472             try {
 473                 reader.setFeature(JdkXmlUtils.USE_CATALOG, useCatalog);
 474             }
 475             catch (SAXNotRecognizedException | SAXNotSupportedException e) {
 476                 supportCatalog = false;
 477             }
 478 
 479             if (supportCatalog &amp;&amp; useCatalog) {
 480                 try {
 481                     CatalogFeatures cf = (CatalogFeatures)_xsltc.getProperty(JdkXmlFeatures.CATALOG_FEATURES);
 482                         if (cf != null) {
 483                             for (CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {
 484                                 reader.setProperty(f.getPropertyName(), cf.get(f));
 485                             }
 486                         }
 487                 } catch (SAXNotRecognizedException e) {
 488                     //shall not happen for internal settings
 489                 }
 490             }
 491 
 492             String lastProperty = &quot;&quot;;
 493             try {
 494                 XMLSecurityManager securityManager =
 495                         (XMLSecurityManager)_xsltc.getProperty(XalanConstants.SECURITY_MANAGER);
 496                 for (XMLSecurityManager.Limit limit : XMLSecurityManager.Limit.values()) {
 497                     lastProperty = limit.apiProperty();
 498                     reader.setProperty(lastProperty, securityManager.getLimitValueAsString(limit));
 499                 }
 500                 if (securityManager.printEntityCountInfo()) {
 501                     lastProperty = XalanConstants.JDK_ENTITY_COUNT_INFO;
 502                     reader.setProperty(XalanConstants.JDK_ENTITY_COUNT_INFO, XalanConstants.JDK_YES);
 503                 }
 504             } catch (SAXException se) {
 505                 XMLSecurityManager.printWarning(reader.getClass().getName(), lastProperty, se);
 506             }
 507 
 508             // try setting other JDK-impl properties, ignore if not supported
 509             JdkXmlUtils.setXMLReaderPropertyIfSupport(reader, JdkXmlUtils.CDATA_CHUNK_SIZE,
 510                 _xsltc.getProperty(JdkXmlUtils.CDATA_CHUNK_SIZE), false);
 511 
 512             return(parse(reader, input));
 513         }
 514         catch (SAXException e) {
 515             reportError(ERROR, new ErrorMsg(e.getMessage()));
 516         }
 517         return null;
 518     }
 519 
 520     public SyntaxTreeNode getDocumentRoot() {
 521         return _root;
 522     }
 523 
 524     private String _PImedia = null;
 525     private String _PItitle = null;
 526     private String _PIcharset = null;
 527 
 528     /**
 529      * Set the parameters to use to locate the correct &lt;?xml-stylesheet ...?&gt;
 530      * processing instruction in the case where the input document is an
 531      * XML document with one or more references to a stylesheet.
 532      * @param media The media attribute to be matched. May be null, in which
 533      * case the prefered templates will be used (i.e. alternate = no).
 534      * @param title The value of the title attribute to match. May be null.
 535      * @param charset The value of the charset attribute to match. May be null.
 536      */
 537     protected void setPIParameters(String media, String title, String charset) {
 538         _PImedia = media;
 539         _PItitle = title;
 540         _PIcharset = charset;
 541     }
 542 
 543     /**
 544      * Extracts the DOM for the stylesheet. In the case of an embedded
 545      * stylesheet, it extracts the DOM subtree corresponding to the
 546      * embedded stylesheet that has an &#39;id&#39; attribute whose value is the
 547      * same as the value declared in the &lt;?xml-stylesheet...?&gt; processing
 548      * instruction (P.I.). In the xml-stylesheet P.I. the value is labeled
 549      * as the &#39;href&#39; data of the P.I. The extracted DOM representing the
 550      * stylesheet is returned as an Element object.
 551      */
 552     private SyntaxTreeNode getStylesheet(SyntaxTreeNode root)
 553         throws CompilerException {
 554 
 555         // Assume that this is a pure XSL stylesheet if there is not
 556         // &lt;?xml-stylesheet ....?&gt; processing instruction
 557         if (_target == null) {
 558             if (!_rootNamespaceDef) {
 559                 ErrorMsg msg = new ErrorMsg(ErrorMsg.MISSING_XSLT_URI_ERR);
 560                 throw new CompilerException(msg.toString());
 561             }
 562             return(root);
 563         }
 564 
 565         // Find the xsl:stylesheet or xsl:transform with this reference
 566         if (_target.charAt(0) == &#39;#&#39;) {
 567             SyntaxTreeNode element = findStylesheet(root, _target.substring(1));
 568             if (element == null) {
 569                 ErrorMsg msg = new ErrorMsg(ErrorMsg.MISSING_XSLT_TARGET_ERR,
 570                                             _target, root);
 571                 throw new CompilerException(msg.toString());
 572             }
 573             return(element);
 574         }
 575         else {
 576             try {
 577                 String path = _target;
 578                 if (path.indexOf(&quot;:&quot;)==-1) {
 579                     path = &quot;file:&quot; + path;
 580                 }
 581                 path = SystemIDResolver.getAbsoluteURI(path);
 582                 String accessError = SecuritySupport.checkAccess(path,
 583                         (String)_xsltc.getProperty(XMLConstants.ACCESS_EXTERNAL_STYLESHEET),
 584                         XalanConstants.ACCESS_EXTERNAL_ALL);
 585                 if (accessError != null) {
 586                     ErrorMsg msg = new ErrorMsg(ErrorMsg.ACCESSING_XSLT_TARGET_ERR,
 587                             SecuritySupport.sanitizePath(_target), accessError,
 588                             root);
 589                     throw new CompilerException(msg.toString());
 590                 }
 591             } catch (IOException ex) {
 592                 throw new CompilerException(ex);
 593             }
 594 
 595             return(loadExternalStylesheet(_target));
 596         }
 597     }
 598 
 599     /**
 600      * Find a Stylesheet element with a specific ID attribute value.
 601      * This method is used to find a Stylesheet node that is referred
 602      * in a &lt;?xml-stylesheet ... ?&gt; processing instruction.
 603      */
 604     private SyntaxTreeNode findStylesheet(SyntaxTreeNode root, String href) {
 605 
 606         if (root == null) return null;
 607 
 608         if (root instanceof Stylesheet) {
 609             String id = root.getAttribute(&quot;id&quot;);
 610             if (id.equals(href)) return root;
 611         }
 612         List&lt;SyntaxTreeNode&gt; children = root.getContents();
 613         if (children != null) {
 614             final int count = children.size();
 615             for (int i = 0; i &lt; count; i++) {
 616                 SyntaxTreeNode child = children.get(i);
 617                 SyntaxTreeNode node = findStylesheet(child, href);
 618                 if (node != null) return node;
 619             }
 620         }
 621         return null;
 622     }
 623 
 624     /**
 625      * For embedded stylesheets: Load an external file with stylesheet
 626      */
 627     private SyntaxTreeNode loadExternalStylesheet(String location)
 628         throws CompilerException {
 629 
 630         InputSource source;
 631 
 632         // Check if the location is URL or a local file
 633         if ((new File(location)).exists())
 634             source = new InputSource(&quot;file:&quot;+location);
 635         else
 636             source = new InputSource(location);
 637 
 638         SyntaxTreeNode external = parse(source);
 639         return(external);
 640     }
 641 
 642     private void initAttrTable(String elementName, String[] attrs) {
 643         _instructionAttrs.put(getQName(XSLT_URI, XSL, elementName).getStringRep(),
 644                                 attrs);
 645     }
 646 
 647     private void initInstructionAttrs() {
 648         initAttrTable(&quot;template&quot;,
 649             new String[] {&quot;match&quot;, &quot;name&quot;, &quot;priority&quot;, &quot;mode&quot;});
 650         initAttrTable(&quot;stylesheet&quot;,
 651             new String[] {&quot;id&quot;, &quot;version&quot;, &quot;extension-element-prefixes&quot;,
 652                 &quot;exclude-result-prefixes&quot;});
 653         initAttrTable(&quot;transform&quot;,
 654             new String[] {&quot;id&quot;, &quot;version&quot;, &quot;extension-element-prefixes&quot;,
 655                 &quot;exclude-result-prefixes&quot;});
 656         initAttrTable(&quot;text&quot;, new String[] {&quot;disable-output-escaping&quot;});
 657         initAttrTable(&quot;if&quot;, new String[] {&quot;test&quot;});
 658         initAttrTable(&quot;choose&quot;, new String[] {});
 659         initAttrTable(&quot;when&quot;, new String[] {&quot;test&quot;});
 660         initAttrTable(&quot;otherwise&quot;, new String[] {});
 661         initAttrTable(&quot;for-each&quot;, new String[] {&quot;select&quot;});
 662         initAttrTable(&quot;message&quot;, new String[] {&quot;terminate&quot;});
 663         initAttrTable(&quot;number&quot;,
 664             new String[] {&quot;level&quot;, &quot;count&quot;, &quot;from&quot;, &quot;value&quot;, &quot;format&quot;, &quot;lang&quot;,
 665                 &quot;letter-value&quot;, &quot;grouping-separator&quot;, &quot;grouping-size&quot;});
 666                 initAttrTable(&quot;comment&quot;, new String[] {});
 667         initAttrTable(&quot;copy&quot;, new String[] {&quot;use-attribute-sets&quot;});
 668         initAttrTable(&quot;copy-of&quot;, new String[] {&quot;select&quot;});
 669         initAttrTable(&quot;param&quot;, new String[] {&quot;name&quot;, &quot;select&quot;});
 670         initAttrTable(&quot;with-param&quot;, new String[] {&quot;name&quot;, &quot;select&quot;});
 671         initAttrTable(&quot;variable&quot;, new String[] {&quot;name&quot;, &quot;select&quot;});
 672         initAttrTable(&quot;output&quot;,
 673             new String[] {&quot;method&quot;, &quot;version&quot;, &quot;encoding&quot;,
 674                 &quot;omit-xml-declaration&quot;, &quot;standalone&quot;, &quot;doctype-public&quot;,
 675                 &quot;doctype-system&quot;, &quot;cdata-section-elements&quot;, &quot;indent&quot;,
 676                 &quot;media-type&quot;});
 677         initAttrTable(&quot;sort&quot;,
 678            new String[] {&quot;select&quot;, &quot;order&quot;, &quot;case-order&quot;, &quot;lang&quot;, &quot;data-type&quot;});
 679         initAttrTable(&quot;key&quot;, new String[] {&quot;name&quot;, &quot;match&quot;, &quot;use&quot;});
 680         initAttrTable(&quot;fallback&quot;, new String[] {});
 681         initAttrTable(&quot;attribute&quot;, new String[] {&quot;name&quot;, &quot;namespace&quot;});
 682         initAttrTable(&quot;attribute-set&quot;,
 683             new String[] {&quot;name&quot;, &quot;use-attribute-sets&quot;});
 684         initAttrTable(&quot;value-of&quot;,
 685             new String[] {&quot;select&quot;, &quot;disable-output-escaping&quot;});
 686         initAttrTable(&quot;element&quot;,
 687             new String[] {&quot;name&quot;, &quot;namespace&quot;, &quot;use-attribute-sets&quot;});
 688         initAttrTable(&quot;call-template&quot;, new String[] {&quot;name&quot;});
 689         initAttrTable(&quot;apply-templates&quot;, new String[] {&quot;select&quot;, &quot;mode&quot;});
 690         initAttrTable(&quot;apply-imports&quot;, new String[] {});
 691         initAttrTable(&quot;decimal-format&quot;,
 692             new String[] {&quot;name&quot;, &quot;decimal-separator&quot;, &quot;grouping-separator&quot;,
 693                 &quot;infinity&quot;, &quot;minus-sign&quot;, &quot;NaN&quot;, &quot;percent&quot;, &quot;per-mille&quot;,
 694                 &quot;zero-digit&quot;, &quot;digit&quot;, &quot;pattern-separator&quot;});
 695         initAttrTable(&quot;import&quot;, new String[] {&quot;href&quot;});
 696         initAttrTable(&quot;include&quot;, new String[] {&quot;href&quot;});
 697         initAttrTable(&quot;strip-space&quot;, new String[] {&quot;elements&quot;});
 698         initAttrTable(&quot;preserve-space&quot;, new String[] {&quot;elements&quot;});
 699         initAttrTable(&quot;processing-instruction&quot;, new String[] {&quot;name&quot;});
 700         initAttrTable(&quot;namespace-alias&quot;,
 701            new String[] {&quot;stylesheet-prefix&quot;, &quot;result-prefix&quot;});
 702     }
 703 
 704     /**
 705      * Initialize the _instructionClasses map, which maps XSL element
 706      * names to Java classes in this package.
 707      */
 708     private void initStdClasses() {
 709         initStdClass(&quot;template&quot;, &quot;Template&quot;);
 710         initStdClass(&quot;stylesheet&quot;, &quot;Stylesheet&quot;);
 711         initStdClass(&quot;transform&quot;, &quot;Stylesheet&quot;);
 712         initStdClass(&quot;text&quot;, &quot;Text&quot;);
 713         initStdClass(&quot;if&quot;, &quot;If&quot;);
 714         initStdClass(&quot;choose&quot;, &quot;Choose&quot;);
 715         initStdClass(&quot;when&quot;, &quot;When&quot;);
 716         initStdClass(&quot;otherwise&quot;, &quot;Otherwise&quot;);
 717         initStdClass(&quot;for-each&quot;, &quot;ForEach&quot;);
 718         initStdClass(&quot;message&quot;, &quot;Message&quot;);
 719         initStdClass(&quot;number&quot;, &quot;Number&quot;);
 720         initStdClass(&quot;comment&quot;, &quot;Comment&quot;);
 721         initStdClass(&quot;copy&quot;, &quot;Copy&quot;);
 722         initStdClass(&quot;copy-of&quot;, &quot;CopyOf&quot;);
 723         initStdClass(&quot;param&quot;, &quot;Param&quot;);
 724         initStdClass(&quot;with-param&quot;, &quot;WithParam&quot;);
 725         initStdClass(&quot;variable&quot;, &quot;Variable&quot;);
 726         initStdClass(&quot;output&quot;, &quot;Output&quot;);
 727         initStdClass(&quot;sort&quot;, &quot;Sort&quot;);
 728         initStdClass(&quot;key&quot;, &quot;Key&quot;);
 729         initStdClass(&quot;fallback&quot;, &quot;Fallback&quot;);
 730         initStdClass(&quot;attribute&quot;, &quot;XslAttribute&quot;);
 731         initStdClass(&quot;attribute-set&quot;, &quot;AttributeSet&quot;);
 732         initStdClass(&quot;value-of&quot;, &quot;ValueOf&quot;);
 733         initStdClass(&quot;element&quot;, &quot;XslElement&quot;);
 734         initStdClass(&quot;call-template&quot;, &quot;CallTemplate&quot;);
 735         initStdClass(&quot;apply-templates&quot;, &quot;ApplyTemplates&quot;);
 736         initStdClass(&quot;apply-imports&quot;, &quot;ApplyImports&quot;);
 737         initStdClass(&quot;decimal-format&quot;, &quot;DecimalFormatting&quot;);
 738         initStdClass(&quot;import&quot;, &quot;Import&quot;);
 739         initStdClass(&quot;include&quot;, &quot;Include&quot;);
 740         initStdClass(&quot;strip-space&quot;, &quot;Whitespace&quot;);
 741         initStdClass(&quot;preserve-space&quot;, &quot;Whitespace&quot;);
 742         initStdClass(&quot;processing-instruction&quot;, &quot;ProcessingInstruction&quot;);
 743         initStdClass(&quot;namespace-alias&quot;, &quot;NamespaceAlias&quot;);
 744     }
 745 
 746     private void initStdClass(String elementName, String className) {
 747         _instructionClasses.put(getQName(XSLT_URI, XSL, elementName).getStringRep(),
 748                                 COMPILER_PACKAGE + &#39;.&#39; + className);
 749     }
 750 
 751     public boolean elementSupported(String namespace, String localName) {
 752         return(_instructionClasses.get(getQName(namespace, XSL, localName).getStringRep()) != null);
 753     }
 754 
 755     public boolean functionSupported(String fname) {
 756         return(_symbolTable.lookupPrimop(fname) != null);
 757     }
 758 
 759     private void initExtClasses() {
 760         initExtClass(&quot;output&quot;, &quot;TransletOutput&quot;);
 761         initExtClass(REDIRECT_URI, &quot;write&quot;, &quot;TransletOutput&quot;);
 762     }
 763 
 764     private void initExtClass(String elementName, String className) {
 765         _instructionClasses.put(getQName(TRANSLET_URI, TRANSLET, elementName).getStringRep(),
 766                                 COMPILER_PACKAGE + &#39;.&#39; + className);
 767     }
 768 
 769     private void initExtClass(String namespace, String elementName, String className) {
 770         _instructionClasses.put(getQName(namespace, TRANSLET, elementName).getStringRep(),
 771                                 COMPILER_PACKAGE + &#39;.&#39; + className);
 772     }
 773 
 774     /**
 775      * Add primops and base functions to the symbol table.
 776      */
 777     @SuppressWarnings(&quot;unused&quot;)
 778     private void initSymbolTable() {
 779         MethodType I_V  = new MethodType(Type.Int, Type.Void);
 780         MethodType I_R  = new MethodType(Type.Int, Type.Real);
 781         MethodType I_S  = new MethodType(Type.Int, Type.String);
 782         MethodType I_D  = new MethodType(Type.Int, Type.NodeSet);
 783         MethodType R_I  = new MethodType(Type.Real, Type.Int);
 784         MethodType R_V  = new MethodType(Type.Real, Type.Void);
 785         MethodType R_R  = new MethodType(Type.Real, Type.Real);
 786         MethodType R_D  = new MethodType(Type.Real, Type.NodeSet);
 787         MethodType R_O  = new MethodType(Type.Real, Type.Reference);
 788         MethodType I_I  = new MethodType(Type.Int, Type.Int);
 789         MethodType D_O  = new MethodType(Type.NodeSet, Type.Reference);
 790         MethodType D_V  = new MethodType(Type.NodeSet, Type.Void);
 791         MethodType D_S  = new MethodType(Type.NodeSet, Type.String);
 792         MethodType D_D  = new MethodType(Type.NodeSet, Type.NodeSet);
 793         MethodType A_V  = new MethodType(Type.Node, Type.Void);
 794         MethodType S_V  = new MethodType(Type.String, Type.Void);
 795         MethodType S_S  = new MethodType(Type.String, Type.String);
 796         MethodType S_A  = new MethodType(Type.String, Type.Node);
 797         MethodType S_D  = new MethodType(Type.String, Type.NodeSet);
 798         MethodType S_O  = new MethodType(Type.String, Type.Reference);
 799         MethodType B_O  = new MethodType(Type.Boolean, Type.Reference);
 800         MethodType B_V  = new MethodType(Type.Boolean, Type.Void);
 801         MethodType B_B  = new MethodType(Type.Boolean, Type.Boolean);
 802         MethodType B_S  = new MethodType(Type.Boolean, Type.String);
 803         MethodType D_X  = new MethodType(Type.NodeSet, Type.Object);
 804         MethodType R_RR = new MethodType(Type.Real, Type.Real, Type.Real);
 805         MethodType I_II = new MethodType(Type.Int, Type.Int, Type.Int);
 806         MethodType B_RR = new MethodType(Type.Boolean, Type.Real, Type.Real);
 807         MethodType B_II = new MethodType(Type.Boolean, Type.Int, Type.Int);
 808         MethodType S_SS = new MethodType(Type.String, Type.String, Type.String);
 809         MethodType S_DS = new MethodType(Type.String, Type.Real, Type.String);
 810         MethodType S_SR = new MethodType(Type.String, Type.String, Type.Real);
 811         MethodType O_SO = new MethodType(Type.Reference, Type.String, Type.Reference);
 812 
 813         MethodType D_SS =
 814             new MethodType(Type.NodeSet, Type.String, Type.String);
 815         MethodType D_SD =
 816             new MethodType(Type.NodeSet, Type.String, Type.NodeSet);
 817         MethodType B_BB =
 818             new MethodType(Type.Boolean, Type.Boolean, Type.Boolean);
 819         MethodType B_SS =
 820             new MethodType(Type.Boolean, Type.String, Type.String);
 821         MethodType S_SD =
 822             new MethodType(Type.String, Type.String, Type.NodeSet);
 823         MethodType S_DSS =
 824             new MethodType(Type.String, Type.Real, Type.String, Type.String);
 825         MethodType S_SRR =
 826             new MethodType(Type.String, Type.String, Type.Real, Type.Real);
 827         MethodType S_SSS =
 828             new MethodType(Type.String, Type.String, Type.String, Type.String);
 829 
 830         /*
 831          * Standard functions: implemented but not in this table concat().
 832          * When adding a new function make sure to uncomment
 833          * the corresponding line in &lt;tt&gt;FunctionAvailableCall&lt;/tt&gt;.
 834          */
 835 
 836         // The following functions are inlined
 837 
 838         _symbolTable.addPrimop(&quot;current&quot;, A_V);
 839         _symbolTable.addPrimop(&quot;last&quot;, I_V);
 840         _symbolTable.addPrimop(&quot;position&quot;, I_V);
 841         _symbolTable.addPrimop(&quot;true&quot;, B_V);
 842         _symbolTable.addPrimop(&quot;false&quot;, B_V);
 843         _symbolTable.addPrimop(&quot;not&quot;, B_B);
 844         _symbolTable.addPrimop(&quot;name&quot;, S_V);
 845         _symbolTable.addPrimop(&quot;name&quot;, S_A);
 846         _symbolTable.addPrimop(&quot;generate-id&quot;, S_V);
 847         _symbolTable.addPrimop(&quot;generate-id&quot;, S_A);
 848         _symbolTable.addPrimop(&quot;ceiling&quot;, R_R);
 849         _symbolTable.addPrimop(&quot;floor&quot;, R_R);
 850         _symbolTable.addPrimop(&quot;round&quot;, R_R);
 851         _symbolTable.addPrimop(&quot;contains&quot;, B_SS);
 852         _symbolTable.addPrimop(&quot;number&quot;, R_O);
 853         _symbolTable.addPrimop(&quot;number&quot;, R_V);
 854         _symbolTable.addPrimop(&quot;boolean&quot;, B_O);
 855         _symbolTable.addPrimop(&quot;string&quot;, S_O);
 856         _symbolTable.addPrimop(&quot;string&quot;, S_V);
 857         _symbolTable.addPrimop(&quot;translate&quot;, S_SSS);
 858         _symbolTable.addPrimop(&quot;string-length&quot;, I_V);
 859         _symbolTable.addPrimop(&quot;string-length&quot;, I_S);
 860         _symbolTable.addPrimop(&quot;starts-with&quot;, B_SS);
 861         _symbolTable.addPrimop(&quot;format-number&quot;, S_DS);
 862         _symbolTable.addPrimop(&quot;format-number&quot;, S_DSS);
 863         _symbolTable.addPrimop(&quot;unparsed-entity-uri&quot;, S_S);
 864         _symbolTable.addPrimop(&quot;key&quot;, D_SS);
 865         _symbolTable.addPrimop(&quot;key&quot;, D_SD);
 866         _symbolTable.addPrimop(&quot;id&quot;, D_S);
 867         _symbolTable.addPrimop(&quot;id&quot;, D_D);
 868         _symbolTable.addPrimop(&quot;namespace-uri&quot;, S_V);
 869         _symbolTable.addPrimop(&quot;function-available&quot;, B_S);
 870         _symbolTable.addPrimop(&quot;element-available&quot;, B_S);
 871         _symbolTable.addPrimop(&quot;document&quot;, D_S);
 872         _symbolTable.addPrimop(&quot;document&quot;, D_V);
 873 
 874         // The following functions are implemented in the basis library
 875         _symbolTable.addPrimop(&quot;count&quot;, I_D);
 876         _symbolTable.addPrimop(&quot;sum&quot;, R_D);
 877         _symbolTable.addPrimop(&quot;local-name&quot;, S_V);
 878         _symbolTable.addPrimop(&quot;local-name&quot;, S_D);
 879         _symbolTable.addPrimop(&quot;namespace-uri&quot;, S_V);
 880         _symbolTable.addPrimop(&quot;namespace-uri&quot;, S_D);
 881         _symbolTable.addPrimop(&quot;substring&quot;, S_SR);
 882         _symbolTable.addPrimop(&quot;substring&quot;, S_SRR);
 883         _symbolTable.addPrimop(&quot;substring-after&quot;, S_SS);
 884         _symbolTable.addPrimop(&quot;substring-before&quot;, S_SS);
 885         _symbolTable.addPrimop(&quot;normalize-space&quot;, S_V);
 886         _symbolTable.addPrimop(&quot;normalize-space&quot;, S_S);
 887         _symbolTable.addPrimop(&quot;system-property&quot;, S_S);
 888 
 889         // Extensions
 890         _symbolTable.addPrimop(&quot;nodeset&quot;, D_O);
 891         _symbolTable.addPrimop(&quot;objectType&quot;, S_O);
 892         _symbolTable.addPrimop(&quot;cast&quot;, O_SO);
 893 
 894         // Operators +, -, *, /, % defined on real types.
 895         _symbolTable.addPrimop(&quot;+&quot;, R_RR);
 896         _symbolTable.addPrimop(&quot;-&quot;, R_RR);
 897         _symbolTable.addPrimop(&quot;*&quot;, R_RR);
 898         _symbolTable.addPrimop(&quot;/&quot;, R_RR);
 899         _symbolTable.addPrimop(&quot;%&quot;, R_RR);
 900 
 901         // Operators +, -, * defined on integer types.
 902         // Operators / and % are not  defined on integers (may cause exception)
 903         _symbolTable.addPrimop(&quot;+&quot;, I_II);
 904         _symbolTable.addPrimop(&quot;-&quot;, I_II);
 905         _symbolTable.addPrimop(&quot;*&quot;, I_II);
 906 
 907          // Operators &lt;, &lt;= &gt;, &gt;= defined on real types.
 908         _symbolTable.addPrimop(&quot;&lt;&quot;,  B_RR);
 909         _symbolTable.addPrimop(&quot;&lt;=&quot;, B_RR);
 910         _symbolTable.addPrimop(&quot;&gt;&quot;,  B_RR);
 911         _symbolTable.addPrimop(&quot;&gt;=&quot;, B_RR);
 912 
 913         // Operators &lt;, &lt;= &gt;, &gt;= defined on int types.
 914         _symbolTable.addPrimop(&quot;&lt;&quot;,  B_II);
 915         _symbolTable.addPrimop(&quot;&lt;=&quot;, B_II);
 916         _symbolTable.addPrimop(&quot;&gt;&quot;,  B_II);
 917         _symbolTable.addPrimop(&quot;&gt;=&quot;, B_II);
 918 
 919         // Operators &lt;, &lt;= &gt;, &gt;= defined on boolean types.
 920         _symbolTable.addPrimop(&quot;&lt;&quot;,  B_BB);
 921         _symbolTable.addPrimop(&quot;&lt;=&quot;, B_BB);
 922         _symbolTable.addPrimop(&quot;&gt;&quot;,  B_BB);
 923         _symbolTable.addPrimop(&quot;&gt;=&quot;, B_BB);
 924 
 925         // Operators &#39;and&#39; and &#39;or&#39;.
 926         _symbolTable.addPrimop(&quot;or&quot;, B_BB);
 927         _symbolTable.addPrimop(&quot;and&quot;, B_BB);
 928 
 929         // Unary minus.
 930         _symbolTable.addPrimop(&quot;u-&quot;, R_R);
 931         _symbolTable.addPrimop(&quot;u-&quot;, I_I);
 932     }
 933 
 934     public SymbolTable getSymbolTable() {
 935         return _symbolTable;
 936     }
 937 
 938     public Template getTemplate() {
 939         return _template;
 940     }
 941 
 942     public void setTemplate(Template template) {
 943         _template = template;
 944     }
 945 
 946     private int _templateIndex = 0;
 947 
 948     public int getTemplateIndex() {
 949         return(_templateIndex++);
 950     }
 951 
 952     /**
 953      * Creates a new node in the abstract syntax tree. This node can be
 954      *  o) a supported XSLT 1.0 element
 955      *  o) an unsupported XSLT element (post 1.0)
 956      *  o) a supported XSLT extension
 957      *  o) an unsupported XSLT extension
 958      *  o) a literal result element (not an XSLT element and not an extension)
 959      * Unsupported elements do not directly generate an error. We have to wait
 960      * until we have received all child elements of an unsupported element to
 961      * see if any &lt;xsl:fallback&gt; elements exist.
 962      */
 963 
 964     private boolean versionIsOne = true;
 965 
 966     public SyntaxTreeNode makeInstance(String uri, String prefix,
 967         String local, Attributes attributes)
 968     {
 969         SyntaxTreeNode node = null;
 970         QName qname = getQName(uri, prefix, local);
 971         String className = _instructionClasses.get(qname.getStringRep());
 972 
 973         if (className != null) {
 974             try {
 975                 final Class&lt;?&gt; clazz = ObjectFactory.findProviderClass(className, true);
 976                 node = (SyntaxTreeNode)clazz.getDeclaredConstructor().newInstance();
 977                 node.setQName(qname);
 978                 node.setParser(this);
 979                 if (_locator != null) {
 980                     node.setLineNumber(getLineNumber());
 981                 }
 982                 if (node instanceof Stylesheet) {
 983                     _xsltc.setStylesheet((Stylesheet)node);
 984                 }
 985                 checkForSuperfluousAttributes(node, attributes);
 986             }
 987             catch (ClassNotFoundException e) {
 988                 ErrorMsg err = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, node);
 989                 reportError(ERROR, err);
 990             }
 991             catch (Exception e) {
 992                 ErrorMsg err = new ErrorMsg(ErrorMsg.INTERNAL_ERR,
 993                                             e.getMessage(), node);
 994                 reportError(FATAL, err);
 995             }
 996         }
 997         else {
 998             if (uri != null) {
 999                 // Check if the element belongs in our namespace
1000                 if (uri.equals(XSLT_URI)) {
1001                     node = new UnsupportedElement(uri, prefix, local, false);
1002                     UnsupportedElement element = (UnsupportedElement)node;
1003                     ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_XSL_ERR,
1004                                                 getLineNumber(),local);
1005                     element.setErrorMessage(msg);
1006                     if (versionIsOne) {
1007                         reportError(UNSUPPORTED,msg);
1008                     }
1009                 }
1010                 // Check if this is an XSLTC extension element
1011                 else if (uri.equals(TRANSLET_URI)) {
1012                     node = new UnsupportedElement(uri, prefix, local, true);
1013                     UnsupportedElement element = (UnsupportedElement)node;
1014                     ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_EXT_ERR,
1015                                                 getLineNumber(),local);
1016                     element.setErrorMessage(msg);
1017                 }
1018                 // Check if this is an extension of some other XSLT processor
1019                 else {
1020                     Stylesheet sheet = _xsltc.getStylesheet();
1021                     if ((sheet != null) &amp;&amp; (sheet.isExtension(uri))) {
1022                         if (sheet != _parentStack.peek()) {
1023                             node = new UnsupportedElement(uri, prefix, local, true);
1024                             UnsupportedElement elem = (UnsupportedElement)node;
1025                             ErrorMsg msg =
1026                                 new ErrorMsg(ErrorMsg.UNSUPPORTED_EXT_ERR,
1027                                              getLineNumber(),
1028                                              prefix+&quot;:&quot;+local);
1029                             elem.setErrorMessage(msg);
1030                         }
1031                     }
1032                 }
1033             }
1034             if (node == null) {
1035                 node = new LiteralElement();
1036                 node.setLineNumber(getLineNumber());
1037             }
1038         }
1039         if ((node != null) &amp;&amp; (node instanceof LiteralElement)) {
1040             ((LiteralElement)node).setQName(qname);
1041         }
1042         return(node);
1043     }
1044 
1045     /**
1046      * checks the list of attributes against a list of allowed attributes
1047      * for a particular element node.
1048      */
1049     private void checkForSuperfluousAttributes(SyntaxTreeNode node,
1050         Attributes attrs)
1051     {
1052         QName qname = node.getQName();
1053         boolean isStylesheet = (node instanceof Stylesheet);
1054         String[] legal = _instructionAttrs.get(qname.getStringRep());
1055         if (versionIsOne &amp;&amp; legal != null) {
1056             int j;
1057             final int n = attrs.getLength();
1058 
1059             for (int i = 0; i &lt; n; i++) {
1060                 final String attrQName = attrs.getQName(i);
1061 
1062                 if (isStylesheet &amp;&amp; attrQName.equals(&quot;version&quot;)) {
1063                     versionIsOne = attrs.getValue(i).equals(&quot;1.0&quot;);
1064                 }
1065 
1066                 // Ignore if special or if it has a prefix
1067                 if (attrQName.startsWith(&quot;xml&quot;) ||
1068                     attrQName.indexOf(&#39;:&#39;) &gt; 0) continue;
1069 
1070                 for (j = 0; j &lt; legal.length; j++) {
1071                     if (attrQName.equalsIgnoreCase(legal[j])) {
1072                         break;
1073                     }
1074                 }
1075                 if (j == legal.length) {
1076                     final ErrorMsg err =
1077                         new ErrorMsg(ErrorMsg.ILLEGAL_ATTRIBUTE_ERR,
1078                                 attrQName, node);
1079                     // Workaround for the TCK failure ErrorListener.errorTests.error001..
1080                     err.setWarningError(true);
1081                     reportError(WARNING, err);
1082                 }
1083             }
1084         }
1085     }
1086 
1087 
1088     /**
1089      * Parse an XPath expression:
1090      *  @param parent - XSL element where the expression occured
1091      *  @param exp    - textual representation of the expression
1092      */
1093     public Expression parseExpression(SyntaxTreeNode parent, String exp) {
1094         return (Expression)parseTopLevel(parent, &quot;&lt;EXPRESSION&gt;&quot;+exp, null);
1095     }
1096 
1097     /**
1098      * Parse an XPath expression:
1099      *  @param parent - XSL element where the expression occured
1100      *  @param attr   - name of this element&#39;s attribute to get expression from
1101      *  @param def    - default expression (if the attribute was not found)
1102      */
1103     public Expression parseExpression(SyntaxTreeNode parent,
1104                                       String attr, String def) {
1105         // Get the textual representation of the expression (if any)
1106         String exp = parent.getAttribute(attr);
1107         // Use the default expression if none was found
1108         if ((exp.length() == 0) &amp;&amp; (def != null)) exp = def;
1109         // Invoke the XPath parser
1110         return (Expression)parseTopLevel(parent, &quot;&lt;EXPRESSION&gt;&quot;+exp, exp);
1111     }
1112 
1113     /**
1114      * Parse an XPath pattern:
1115      *  @param parent  - XSL element where the pattern occured
1116      *  @param pattern - textual representation of the pattern
1117      */
1118     public Pattern parsePattern(SyntaxTreeNode parent, String pattern) {
1119         return (Pattern)parseTopLevel(parent, &quot;&lt;PATTERN&gt;&quot;+pattern, pattern);
1120     }
1121 
1122     /**
1123      * Parse an XPath pattern:
1124      *  @param parent - XSL element where the pattern occured
1125      *  @param attr   - name of this element&#39;s attribute to get pattern from
1126      *  @param def    - default pattern (if the attribute was not found)
1127      */
1128     public Pattern parsePattern(SyntaxTreeNode parent,
1129                                 String attr, String def) {
1130         // Get the textual representation of the pattern (if any)
1131         String pattern = parent.getAttribute(attr);
1132         // Use the default pattern if none was found
1133         if ((pattern.length() == 0) &amp;&amp; (def != null)) pattern = def;
1134         // Invoke the XPath parser
1135         return (Pattern)parseTopLevel(parent, &quot;&lt;PATTERN&gt;&quot;+pattern, pattern);
1136     }
1137 
1138     /**
1139      * Parse an XPath expression or pattern using the generated XPathParser
1140      * The method will return a Dummy node if the XPath parser fails.
1141      */
1142     private SyntaxTreeNode parseTopLevel(SyntaxTreeNode parent, String text,
1143                                          String expression) {
1144         int line = getLineNumber();
1145 
1146         try {
1147             _xpathParser.setScanner(new XPathLexer(new StringReader(text)));
1148             Symbol result = _xpathParser.parse(expression, line);
1149             if (result != null) {
1150                 final SyntaxTreeNode node = (SyntaxTreeNode)result.value;
1151                 if (node != null) {
1152                     node.setParser(this);
1153                     node.setParent(parent);
1154                     node.setLineNumber(line);
1155                     return node;
1156                 }
1157             }
1158             reportError(ERROR, new ErrorMsg(ErrorMsg.XPATH_PARSER_ERR,
1159                                             expression, parent));
1160         }
1161         catch (Exception e) {
1162             if (_xsltc.debug()) e.printStackTrace();
1163             reportError(ERROR, new ErrorMsg(ErrorMsg.XPATH_PARSER_ERR,
1164                                             expression, parent));
1165         }
1166 
1167         // Return a dummy pattern (which is an expression)
1168         SyntaxTreeNode.Dummy.setParser(this);
1169         return SyntaxTreeNode.Dummy;
1170     }
1171 
1172     /************************ ERROR HANDLING SECTION ************************/
1173 
1174     /**
1175      * Returns true if there were any errors during compilation
1176      */
1177     public boolean errorsFound() {
1178         return _errors.size() &gt; 0;
1179     }
1180 
1181     /**
1182      * Prints all compile-time errors
1183      */
1184     public void printErrors() {
1185         final int size = _errors.size();
1186         if (size &gt; 0) {
1187             System.err.println(new ErrorMsg(ErrorMsg.COMPILER_ERROR_KEY));
1188             for (int i = 0; i &lt; size; i++) {
1189                 System.err.println(&quot;  &quot; + _errors.get(i));
1190             }
1191         }
1192     }
1193 
1194     /**
1195      * Prints all compile-time warnings
1196      */
1197     public void printWarnings() {
1198         final int size = _warnings.size();
1199         if (size &gt; 0) {
1200             System.err.println(new ErrorMsg(ErrorMsg.COMPILER_WARNING_KEY));
1201             for (int i = 0; i &lt; size; i++) {
1202                 System.err.println(&quot;  &quot; + _warnings.get(i));
1203             }
1204         }
1205     }
1206 
1207     /**
1208      * Common error/warning message handler
1209      */
1210     public void reportError(final int category, final ErrorMsg error) {
1211         switch (category) {
1212         case Constants.INTERNAL:
1213             // Unexpected internal errors, such as null-ptr exceptions, etc.
1214             // Immediately terminates compilation, no translet produced
1215             _errors.add(error);
1216             break;
1217         case Constants.UNSUPPORTED:
1218             // XSLT elements that are not implemented and unsupported ext.
1219             // Immediately terminates compilation, no translet produced
1220             _errors.add(error);
1221             break;
1222         case Constants.FATAL:
1223             // Fatal error in the stylesheet input (parsing or content)
1224             // Immediately terminates compilation, no translet produced
1225             _errors.add(error);
1226             break;
1227         case Constants.ERROR:
1228             // Other error in the stylesheet input (parsing or content)
1229             // Does not terminate compilation, no translet produced
1230             _errors.add(error);
1231             break;
1232         case Constants.WARNING:
1233             // Other error in the stylesheet input (content errors only)
1234             // Does not terminate compilation, a translet is produced
1235             _warnings.add(error);
1236             break;
1237         }
1238     }
1239 
1240     public ArrayList&lt;ErrorMsg&gt; getErrors() {
1241         return _errors;
1242     }
1243 
1244     public ArrayList&lt;ErrorMsg&gt; getWarnings() {
1245         return _warnings;
1246     }
1247 
1248     /************************ SAX2 ContentHandler INTERFACE *****************/
1249 
1250     private Stack&lt;SyntaxTreeNode&gt; _parentStack = null;
1251     private Map&lt;String, String&gt; _prefixMapping = null;
1252 
1253     /**
1254      * SAX2: Receive notification of the beginning of a document.
1255      */
1256     public void startDocument() {
1257         _root = null;
1258         _target = null;
1259         _prefixMapping = null;
1260         _parentStack = new Stack&lt;&gt;();
1261     }
1262 
1263     /**
1264      * SAX2: Receive notification of the end of a document.
1265      */
1266     public void endDocument() { }
1267 
1268 
1269     /**
1270      * SAX2: Begin the scope of a prefix-URI Namespace mapping.
1271      *       This has to be passed on to the symbol table!
1272      */
1273     public void startPrefixMapping(String prefix, String uri) {
1274         if (_prefixMapping == null) {
1275             _prefixMapping = new HashMap&lt;&gt;();
1276         }
1277         _prefixMapping.put(prefix, uri);
1278     }
1279 
1280     /**
1281      * SAX2: End the scope of a prefix-URI Namespace mapping.
1282      *       This has to be passed on to the symbol table!
1283      */
1284     public void endPrefixMapping(String prefix) { }
1285 
1286     /**
1287      * SAX2: Receive notification of the beginning of an element.
1288      *       The parser may re-use the attribute list that we&#39;re passed so
1289      *       we clone the attributes in our own Attributes implementation
1290      */
1291     public void startElement(String uri, String localname,
1292                              String qname, Attributes attributes)
1293         throws SAXException {
1294         final int col = qname.lastIndexOf(&#39;:&#39;);
1295         final String prefix = (col == -1) ? null : qname.substring(0, col);
1296 
1297         SyntaxTreeNode element = makeInstance(uri, prefix,
1298                                         localname, attributes);
1299         if (element == null) {
1300             ErrorMsg err = new ErrorMsg(ErrorMsg.ELEMENT_PARSE_ERR,
1301                                         prefix+&#39;:&#39;+localname);
1302             throw new SAXException(err.toString());
1303         }
1304 
1305         // If this is the root element of the XML document we need to make sure
1306         // that it contains a definition of the XSL namespace URI
1307         if (_root == null) {
1308             if ((_prefixMapping == null) ||
1309                 (_prefixMapping.containsValue(Constants.XSLT_URI) == false))
1310                 _rootNamespaceDef = false;
1311             else
1312                 _rootNamespaceDef = true;
1313             _root = element;
1314         }
1315         else {
1316             SyntaxTreeNode parent = _parentStack.peek();
1317 
1318             if (element.getClass().isAssignableFrom(Import.class) &amp;&amp;
1319                     parent.notTypeOf(Import.class)) {
1320                 ErrorMsg err = new ErrorMsg(ErrorMsg.IMPORT_PRECEDE_OTHERS_ERR,
1321                                             prefix+&#39;:&#39;+localname);
1322                 throw new SAXException(err.toString());
1323             }
1324 
1325             parent.addElement(element);
1326             element.setParent(parent);
1327         }
1328         element.setAttributes(new AttributesImpl(attributes));
1329         element.setPrefixMapping(_prefixMapping);
1330 
1331         if (element instanceof Stylesheet) {
1332             // Extension elements and excluded elements have to be
1333             // handled at this point in order to correctly generate
1334             // Fallback elements from &lt;xsl:fallback&gt;s.
1335             getSymbolTable().setCurrentNode(element);
1336             ((Stylesheet)element).declareExtensionPrefixes(this);
1337         }
1338 
1339         _prefixMapping = null;
1340         _parentStack.push(element);
1341     }
1342 
1343     /**
1344      * SAX2: Receive notification of the end of an element.
1345      */
1346     public void endElement(String uri, String localname, String qname) {
1347         _parentStack.pop();
1348     }
1349 
1350     /**
1351      * SAX2: Receive notification of character data.
1352      */
1353     public void characters(char[] ch, int start, int length) {
1354         String string = new String(ch, start, length);
1355         SyntaxTreeNode parent = _parentStack.peek();
1356 
1357         if (string.length() == 0) return;
1358 
1359         // If this text occurs within an &lt;xsl:text&gt; element we append it
1360         // as-is to the existing text element
1361         if (parent instanceof Text) {
1362             ((Text)parent).setText(string);
1363             return;
1364         }
1365 
1366         // Ignore text nodes that occur directly under &lt;xsl:stylesheet&gt;
1367         if (parent instanceof Stylesheet) return;
1368 
1369         SyntaxTreeNode bro = parent.lastChild();
1370         if ((bro != null) &amp;&amp; (bro instanceof Text)) {
1371             Text text = (Text)bro;
1372             if (!text.isTextElement()) {
1373                 if ((length &gt; 1) || ( ((int)ch[0]) &lt; 0x100)) {
1374                     text.setText(string);
1375                     return;
1376                 }
1377             }
1378         }
1379 
1380         // Add it as a regular text node otherwise
1381         parent.addElement(new Text(string));
1382     }
1383 
1384     private String getTokenValue(String token) {
1385         final int start = token.indexOf(&#39;&quot;&#39;);
1386         final int stop = token.lastIndexOf(&#39;&quot;&#39;);
1387         return token.substring(start+1, stop);
1388     }
1389 
1390     /**
1391      * SAX2: Receive notification of a processing instruction.
1392      *       These require special handling for stylesheet PIs.
1393      */
1394     public void processingInstruction(String name, String value) {
1395         // We only handle the &lt;?xml-stylesheet ...?&gt; PI
1396         if ((_target == null) &amp;&amp; (name.equals(&quot;xml-stylesheet&quot;))) {
1397 
1398             String href = null;    // URI of stylesheet found
1399             String media = null;   // Media of stylesheet found
1400             String title = null;   // Title of stylesheet found
1401             String charset = null; // Charset of stylesheet found
1402 
1403             // Get the attributes from the processing instruction
1404             StringTokenizer tokens = new StringTokenizer(value);
1405             while (tokens.hasMoreElements()) {
1406                 String token = (String)tokens.nextElement();
1407                 if (token.startsWith(&quot;href&quot;))
1408                     href = getTokenValue(token);
1409                 else if (token.startsWith(&quot;media&quot;))
1410                     media = getTokenValue(token);
1411                 else if (token.startsWith(&quot;title&quot;))
1412                     title = getTokenValue(token);
1413                 else if (token.startsWith(&quot;charset&quot;))
1414                     charset = getTokenValue(token);
1415             }
1416 
1417             // Set the target to this PI&#39;s href if the parameters are
1418             // null or match the corresponding attributes of this PI.
1419             if ( ((_PImedia == null) || (_PImedia.equals(media))) &amp;&amp;
1420                  ((_PItitle == null) || (_PImedia.equals(title))) &amp;&amp;
1421                  ((_PIcharset == null) || (_PImedia.equals(charset))) ) {
1422                 _target = href;
1423             }
1424         }
1425     }
1426 
1427     /**
1428      * IGNORED - all ignorable whitespace is ignored
1429      */
1430     public void ignorableWhitespace(char[] ch, int start, int length) { }
1431 
1432     /**
1433      * IGNORED - we do not have to do anything with skipped entities
1434      */
1435     public void skippedEntity(String name) { }
1436 
1437     /**
1438      * Store the document locator to later retrieve line numbers of all
1439      * elements from the stylesheet
1440      */
1441     public void setDocumentLocator(Locator locator) {
1442         _locator = locator;
1443     }
1444 
1445     /**
1446      * Get the line number, or zero
1447      * if there is no _locator.
1448      */
1449     private int getLineNumber() {
1450         int line = 0;
1451         if (_locator != null)
1452                 line = _locator.getLineNumber();
1453         return line;
1454     }
1455 
1456 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/ChildNode.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.xerces.internal.dom;
 23 
 24 import org.w3c.dom.Node;
 25 
 26 /**
 27  * ChildNode inherits from NodeImpl and adds the capability of being a child by
 28  * having references to its previous and next siblings.
 29  *
 30  * @xerces.internal
 31  *
 32  */
 33 public abstract class ChildNode
 34     extends NodeImpl {
 35 
 36     //
 37     // Constants
 38     //
 39 
 40     /** Serialization version. */
 41     static final long serialVersionUID = -6112455738802414002L;
 42 
<a name="1" id="anc1"></a>

 43     //
 44     // Data
 45     //
 46 
 47     /** Previous sibling. */
 48     protected ChildNode previousSibling;
 49 
 50     /** Next sibling. */
 51     protected ChildNode nextSibling;
 52 
 53     //
 54     // Constructors
 55     //
 56 
 57     /**
 58      * No public constructor; only subclasses of Node should be
 59      * instantiated, and those normally via a Document&#39;s factory methods
 60      * &lt;p&gt;
 61      * Every Node knows what Document it belongs to.
 62      */
 63     protected ChildNode(CoreDocumentImpl ownerDocument) {
 64         super(ownerDocument);
 65     } // &lt;init&gt;(CoreDocumentImpl)
 66 
 67     /** Constructor for serialization. */
 68     public ChildNode() {}
 69 
 70     //
 71     // Node methods
 72     //
 73 
 74     /**
 75      * Returns a duplicate of a given node. You can consider this a
 76      * generic &quot;copy constructor&quot; for nodes. The newly returned object should
 77      * be completely independent of the source object&#39;s subtree, so changes
 78      * in one after the clone has been made will not affect the other.
 79      * &lt;P&gt;
 80      * Note: since we never have any children deep is meaningless here,
 81      * ParentNode overrides this behavior.
 82      * @see ParentNode
 83      *
 84      * &lt;p&gt;
 85      * Example: Cloning a Text node will copy both the node and the text it
 86      * contains.
 87      * &lt;p&gt;
 88      * Example: Cloning something that has children -- Element or Attr, for
 89      * example -- will _not_ clone those children unless a &quot;deep clone&quot;
 90      * has been requested. A shallow clone of an Attr node will yield an
 91      * empty Attr of the same name.
 92      * &lt;p&gt;
 93      * NOTE: Clones will always be read/write, even if the node being cloned
 94      * is read-only, to permit applications using only the DOM API to obtain
 95      * editable copies of locked portions of the tree.
 96      */
 97     public Node cloneNode(boolean deep) {
 98 
 99         ChildNode newnode = (ChildNode) super.cloneNode(deep);
100 
101         // Need to break the association w/ original kids
102         newnode.previousSibling = null;
103         newnode.nextSibling     = null;
104         newnode.isFirstChild(false);
105 
106         return newnode;
107 
108     } // cloneNode(boolean):Node
109 
110     /**
111      * Returns the parent node of this node
112      */
113     public Node getParentNode() {
114         // if we have an owner, ownerNode is our parent, otherwise it&#39;s
115         // our ownerDocument and we don&#39;t have a parent
116         return isOwned() ? ownerNode : null;
117     }
118 
119     /*
120      * same as above but returns internal type
121      */
122     final NodeImpl parentNode() {
123         // if we have an owner, ownerNode is our parent, otherwise it&#39;s
124         // our ownerDocument and we don&#39;t have a parent
125         return isOwned() ? ownerNode : null;
126     }
127 
128     /** The next child of this node&#39;s parent, or null if none */
129     public Node getNextSibling() {
130         return nextSibling;
131     }
132 
133     /** The previous child of this node&#39;s parent, or null if none */
134     public Node getPreviousSibling() {
135         // if we are the firstChild, previousSibling actually refers to our
136         // parent&#39;s lastChild, but we hide that
137         return isFirstChild() ? null : previousSibling;
138     }
139 
140     /*
141      * same as above but returns internal type
142      */
143     final ChildNode previousSibling() {
144         // if we are the firstChild, previousSibling actually refers to our
145         // parent&#39;s lastChild, but we hide that
146         return isFirstChild() ? null : previousSibling;
147     }
148 
149 } // class ChildNode
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
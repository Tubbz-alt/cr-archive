<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/bcel/internal/util/BCELifier.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.util;
 23 
 24 import java.io.IOException;
 25 import java.io.OutputStream;
 26 import java.io.PrintWriter;
 27 import java.util.Locale;
 28 
 29 import com.sun.org.apache.bcel.internal.Const;
 30 import com.sun.org.apache.bcel.internal.Repository;
 31 import com.sun.org.apache.bcel.internal.classfile.ClassParser;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantValue;
 33 import com.sun.org.apache.bcel.internal.classfile.Field;
 34 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 35 import com.sun.org.apache.bcel.internal.classfile.Method;
 36 import com.sun.org.apache.bcel.internal.classfile.Utility;
 37 import com.sun.org.apache.bcel.internal.generic.ArrayType;
 38 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
 39 import com.sun.org.apache.bcel.internal.generic.MethodGen;
 40 import com.sun.org.apache.bcel.internal.generic.Type;
 41 
 42 /**
 43  * This class takes a given JavaClass object and converts it to a
 44  * Java program that creates that very class using BCEL. This
 45  * gives new users of BCEL a useful example showing how things
 46  * are done with BCEL. It does not cover all features of BCEL,
 47  * but tries to mimic hand-written code as close as possible.
 48  *
 49  */
 50 public class BCELifier extends com.sun.org.apache.bcel.internal.classfile.EmptyVisitor {
 51 
 52     /**
 53      * Enum corresponding to flag source.
 54      */
 55     public enum FLAGS {
 56         UNKNOWN,
 57         CLASS,
 58         METHOD,
 59     }
 60 
 61     // The base package name for imports; assumes Const is at the top level
 62     // N.B we use the class so renames will be detected by the compiler/IDE
 63     private static final String BASE_PACKAGE = Const.class.getPackage().getName();
 64     private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+&quot;.&quot;;
 65 
 66     private final JavaClass _clazz;
 67     private final PrintWriter _out;
 68     private final ConstantPoolGen _cp;
 69 
 70     /** @param clazz Java class to &quot;decompile&quot;
 71      * @param out where to output Java program
 72      */
 73     public BCELifier(final JavaClass clazz, final OutputStream out) {
 74         _clazz = clazz;
 75         _out = new PrintWriter(out);
 76         _cp = new ConstantPoolGen(_clazz.getConstantPool());
 77     }
 78 
 79 
 80     /** Start Java code generation
 81      */
 82     public void start() {
 83         visitJavaClass(_clazz);
 84         _out.flush();
 85     }
 86 
 87 
 88     @Override
 89     public void visitJavaClass( final JavaClass clazz ) {
 90         String class_name = clazz.getClassName();
 91         final String super_name = clazz.getSuperclassName();
 92         final String package_name = clazz.getPackageName();
 93         final String inter = Utility.printArray(clazz.getInterfaceNames(), false, true);
 94         if (!&quot;&quot;.equals(package_name)) {
 95             class_name = class_name.substring(package_name.length() + 1);
 96             _out.println(&quot;package &quot; + package_name + &quot;;&quot;);
 97             _out.println();
 98         }
 99         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.generic.*;&quot;);
100         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.classfile.*;&quot;);
101         _out.println(&quot;import &quot; + BASE_PACKAGE + &quot;.*;&quot;);
102         _out.println(&quot;import java.io.*;&quot;);
103         _out.println();
104         _out.println(&quot;public class &quot; + class_name + &quot;Creator {&quot;);
105         _out.println(&quot;  private InstructionFactory _factory;&quot;);
106         _out.println(&quot;  private ConstantPoolGen    _cp;&quot;);
107         _out.println(&quot;  private ClassGen           _cg;&quot;);
108         _out.println();
109         _out.println(&quot;  public &quot; + class_name + &quot;Creator() {&quot;);
110         _out.println(&quot;    _cg = new ClassGen(\&quot;&quot;
111                 + ((&quot;&quot;.equals(package_name)) ? class_name : package_name + &quot;.&quot; + class_name)
112                 + &quot;\&quot;, \&quot;&quot; + super_name + &quot;\&quot;, &quot; + &quot;\&quot;&quot; + clazz.getSourceFileName() + &quot;\&quot;, &quot;
113                 + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + &quot;, &quot;
114                 + &quot;new String[] { &quot; + inter + &quot; });&quot;);
115         _out.println(&quot;    _cg.setMajor(&quot; + clazz.getMajor() +&quot;);&quot;);
116         _out.println(&quot;    _cg.setMinor(&quot; + clazz.getMinor() +&quot;);&quot;);
117         _out.println();
118         _out.println(&quot;    _cp = _cg.getConstantPool();&quot;);
119         _out.println(&quot;    _factory = new InstructionFactory(_cg, _cp);&quot;);
120         _out.println(&quot;  }&quot;);
121         _out.println();
122         printCreate();
123         final Field[] fields = clazz.getFields();
124         if (fields.length &gt; 0) {
125             _out.println(&quot;  private void createFields() {&quot;);
126             _out.println(&quot;    FieldGen field;&quot;);
127             for (final Field field : fields) {
128                 field.accept(this);
129             }
130             _out.println(&quot;  }&quot;);
131             _out.println();
132         }
133         final Method[] methods = clazz.getMethods();
134         for (int i = 0; i &lt; methods.length; i++) {
135             _out.println(&quot;  private void createMethod_&quot; + i + &quot;() {&quot;);
136             methods[i].accept(this);
137             _out.println(&quot;  }&quot;);
138             _out.println();
139         }
140         printMain();
141         _out.println(&quot;}&quot;);
142     }
143 
144 
145     private void printCreate() {
146         _out.println(&quot;  public void create(OutputStream out) throws IOException {&quot;);
147         final Field[] fields = _clazz.getFields();
148         if (fields.length &gt; 0) {
149             _out.println(&quot;    createFields();&quot;);
150         }
151         final Method[] methods = _clazz.getMethods();
152         for (int i = 0; i &lt; methods.length; i++) {
153             _out.println(&quot;    createMethod_&quot; + i + &quot;();&quot;);
154         }
155         _out.println(&quot;    _cg.getJavaClass().dump(out);&quot;);
156         _out.println(&quot;  }&quot;);
157         _out.println();
158     }
159 
160 
161     private void printMain() {
162         final String class_name = _clazz.getClassName();
163         _out.println(&quot;  public static void main(String[] args) throws Exception {&quot;);
164         _out.println(&quot;    &quot; + class_name + &quot;Creator creator = new &quot; + class_name + &quot;Creator();&quot;);
165         _out.println(&quot;    creator.create(new FileOutputStream(\&quot;&quot; + class_name + &quot;.class\&quot;));&quot;);
166         _out.println(&quot;  }&quot;);
167     }
168 
169 
170     @Override
171     public void visitField( final Field field ) {
172         _out.println();
173         _out.println(&quot;    field = new FieldGen(&quot; + printFlags(field.getAccessFlags()) + &quot;, &quot;
174                 + printType(field.getSignature()) + &quot;, \&quot;&quot; + field.getName() + &quot;\&quot;, _cp);&quot;);
175         final ConstantValue cv = field.getConstantValue();
176         if (cv != null) {
177             final String value = cv.toString();
178             _out.println(&quot;    field.setInitValue(&quot; + value + &quot;)&quot;);
179         }
180         _out.println(&quot;    _cg.addField(field.getField());&quot;);
181     }
182 
183 
184     @Override
185     public void visitMethod( final Method method ) {
186         final MethodGen mg = new MethodGen(method, _clazz.getClassName(), _cp);
187         _out.println(&quot;    InstructionList il = new InstructionList();&quot;);
188         _out.println(&quot;    MethodGen method = new MethodGen(&quot;
189                 + printFlags(method.getAccessFlags(), FLAGS.METHOD) + &quot;, &quot;
190                 + printType(mg.getReturnType()) + &quot;, &quot;
191                 + printArgumentTypes(mg.getArgumentTypes()) + &quot;, &quot;
192                 + &quot;new String[] { &quot; + Utility.printArray(mg.getArgumentNames(), false, true)
193                 + &quot; }, \&quot;&quot; + method.getName() + &quot;\&quot;, \&quot;&quot; + _clazz.getClassName() + &quot;\&quot;, il, _cp);&quot;);
194         _out.println();
195         final BCELFactory factory = new BCELFactory(mg, _out);
196         factory.start();
197         _out.println(&quot;    method.setMaxStack();&quot;);
198         _out.println(&quot;    method.setMaxLocals();&quot;);
199         _out.println(&quot;    _cg.addMethod(method.getMethod());&quot;);
200         _out.println(&quot;    il.dispose();&quot;);
201     }
202 
203 
204     static String printFlags( final int flags ) {
205         return printFlags(flags, FLAGS.UNKNOWN);
206     }
207 
208     /**
209      * Return a string with the flag settings
210      * @param flags the flags field to interpret
211      * @param location the item type
212      * @return the formatted string
213      * @since 6.0 made public
214      */
215     public static String printFlags( final int flags, final FLAGS location ) {
216         if (flags == 0) {
217             return &quot;0&quot;;
218         }
219         final StringBuilder buf = new StringBuilder();
220         for (int i = 0, pow = 1; pow &lt;= Const.MAX_ACC_FLAG_I; i++) {
221             if ((flags &amp; pow) != 0) {
222                 if ((pow == Const.ACC_SYNCHRONIZED) &amp;&amp; (location == FLAGS.CLASS)) {
223                     buf.append(CONSTANT_PREFIX+&quot;ACC_SUPER | &quot;);
224                 } else if ((pow == Const.ACC_VOLATILE) &amp;&amp; (location == FLAGS.METHOD)) {
225                     buf.append(CONSTANT_PREFIX+&quot;ACC_BRIDGE | &quot;);
226                 } else if ((pow == Const.ACC_TRANSIENT) &amp;&amp; (location == FLAGS.METHOD)) {
227                     buf.append(CONSTANT_PREFIX+&quot;ACC_VARARGS | &quot;);
228                 } else {
229                     if (i &lt; Const.ACCESS_NAMES_LENGTH) {
230                         buf.append(CONSTANT_PREFIX+&quot;ACC_&quot;)
231                                 .append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH))
232                                 .append( &quot; | &quot;);
233                     } else {
234                         buf.append(String.format (CONSTANT_PREFIX+&quot;ACC_BIT %x | &quot;, pow));
235                     }
236                 }
237             }
238             pow &lt;&lt;= 1;
239         }
240         final String str = buf.toString();
241         return str.substring(0, str.length() - 3);
242     }
243 
244 
245     static String printArgumentTypes( final Type[] arg_types ) {
246         if (arg_types.length == 0) {
247             return &quot;Type.NO_ARGS&quot;;
248         }
249         final StringBuilder args = new StringBuilder();
250         for (int i = 0; i &lt; arg_types.length; i++) {
251             args.append(printType(arg_types[i]));
252             if (i &lt; arg_types.length - 1) {
253                 args.append(&quot;, &quot;);
254             }
255         }
256         return &quot;new Type[] { &quot; + args.toString() + &quot; }&quot;;
257     }
258 
259 
260     static String printType( final Type type ) {
261         return printType(type.getSignature());
262     }
263 
264 
265     static String printType( final String signature ) {
266         final Type type = Type.getType(signature);
267         final byte t = type.getType();
268         if (t &lt;= Const.T_VOID) {
269             return &quot;Type.&quot; + Const.getTypeName(t).toUpperCase(Locale.ENGLISH);
270         } else if (type.toString().equals(&quot;java.lang.String&quot;)) {
271             return &quot;Type.STRING&quot;;
272         } else if (type.toString().equals(&quot;java.lang.Object&quot;)) {
273             return &quot;Type.OBJECT&quot;;
274         } else if (type.toString().equals(&quot;java.lang.StringBuffer&quot;)) {
275             return &quot;Type.STRINGBUFFER&quot;;
276         } else if (type instanceof ArrayType) {
277             final ArrayType at = (ArrayType) type;
278             return &quot;new ArrayType(&quot; + printType(at.getBasicType()) + &quot;, &quot; + at.getDimensions()
279                     + &quot;)&quot;;
280         } else {
281             return &quot;new ObjectType(\&quot;&quot; + Utility.signatureToString(signature, false) + &quot;\&quot;)&quot;;
282         }
283     }
284 
285 
286     /** Default main method
287      */
288     public static void main( final String[] argv ) throws Exception {
289         if (argv.length != 1) {
290             System.out.println(&quot;Usage: BCELifier classname&quot;);
291             System.out.println(&quot;\tThe class must exist on the classpath&quot;);
292             return;
293         }
294         final JavaClass java_class = getJavaClass(argv[0]);
295         final BCELifier bcelifier = new BCELifier(java_class, System.out);
296         bcelifier.start();
297     }
298 
299 
300     // Needs to be accessible from unit test code
301     static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {
302         JavaClass java_class;
303         if ((java_class = Repository.lookupClass(name)) == null) {
304             java_class = new ClassParser(name).parse(); // May throw IOException
305         }
306         return java_class;
307     }
308 }
    </pre>
  </body>
</html>
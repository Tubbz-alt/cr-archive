<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/TextImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ParentNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../impl/XMLDocumentFragmentScannerImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/TextImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * reserved comment block</span>
<span class="line-removed">  3  * DO NOT REMOVE OR ALTER!</span>
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.xerces.internal.dom;
 23 
</pre>
<hr />
<pre>
 25 import org.w3c.dom.DOMException;
 26 import org.w3c.dom.Node;
 27 import org.w3c.dom.Text;
 28 
 29 /**
 30  * Text nodes hold the non-markup, non-Entity content of
 31  * an Element or Attribute.
 32  * &lt;P&gt;
 33  * When a document is first made available to the DOM, there is only
 34  * one Text object for each block of adjacent plain-text. Users (ie,
 35  * applications) may create multiple adjacent Texts during editing --
 36  * see {@link org.w3c.dom.Element#normalize} for discussion.
 37  * &lt;P&gt;
 38  * Note that CDATASection is a subclass of Text. This is conceptually
 39  * valid, since they&#39;re really just two different ways of quoting
 40  * characters when they&#39;re written out as part of an XML stream.
 41  *
 42  * @xerces.internal
 43  *
 44  * @since  PR-DOM-Level-1-19980818.

 45  */
 46 public class TextImpl
 47     extends CharacterDataImpl
 48     implements CharacterData, Text {
 49 
 50     //
 51     // Private Data members
 52     //
 53 
 54 
 55     //
 56     // Constants
 57     //
 58 
 59     /** Serialization version. */
 60     static final long serialVersionUID = -5294980852957403469L;
 61 
 62     //
 63     // Constructors
 64     //
</pre>
<hr />
<pre>
129         // REVISIT: is this implemenation correct?
130         if (needsSyncData()) {
131             synchronizeData();
132         }
133         return internalIsIgnorableWhitespace();
134     }
135 
136 
137     /**
138      * DOM Level 3 WD - Experimental.
139      * Returns all text of &lt;code&gt;Text&lt;/code&gt; nodes logically-adjacent text
140      * nodes to this node, concatenated in document order.
141      * @since DOM Level 3
142      */
143     public String getWholeText(){
144 
145         if (needsSyncData()) {
146             synchronizeData();
147         }
148 
<span class="line-modified">149         if (fBufferStr == null){</span>
<span class="line-removed">150             fBufferStr = new StringBuffer();</span>
<span class="line-removed">151         }</span>
<span class="line-removed">152         else {</span>
<span class="line-removed">153             fBufferStr.setLength(0);</span>
<span class="line-removed">154         }</span>
155         if (data != null &amp;&amp; data.length() != 0) {
<span class="line-modified">156             fBufferStr.append(data);</span>
157         }
158 
<span class="line-modified">159         //concatenate text of logically adjacent text nodes to the left of this node in the tree</span>
<span class="line-modified">160         getWholeTextBackward(this.getPreviousSibling(), fBufferStr, this.getParentNode());</span>
<span class="line-modified">161         String temp = fBufferStr.toString();</span>
162 
<span class="line-modified">163         //clear buffer</span>
<span class="line-modified">164         fBufferStr.setLength(0);</span>
165 
<span class="line-modified">166         //concatenate text of logically adjacent text nodes to the right of this node in the tree</span>
<span class="line-modified">167         getWholeTextForward(this.getNextSibling(), fBufferStr, this.getParentNode());</span>
168 
<span class="line-modified">169         return temp + fBufferStr.toString();</span>
170 
171     }
172 
173     /**
<span class="line-modified">174      * internal method taking a StringBuffer in parameter and inserts the</span>
175      * text content at the start of the buffer
176      *
177      * @param buf
178      */
<span class="line-modified">179     protected void insertTextContent(StringBuffer buf) throws DOMException {</span>
180          String content = getNodeValue();
181          if (content != null) {
182              buf.insert(0, content);
183          }
184      }
185 
186     /**
187      * Concatenates the text of all logically-adjacent text nodes to the
188      * right of this node
189      * @param node
190      * @param buffer
191      * @param parent
192      * @return true - if execution was stopped because the type of node
193      *         other than EntityRef, Text, CDATA is encountered, otherwise
194      *         return false
195      */
<span class="line-modified">196     private boolean getWholeTextForward(Node node, StringBuffer buffer, Node parent){</span>
197         // boolean to indicate whether node is a child of an entity reference
198         boolean inEntRef = false;
199 
200         if (parent!=null) {
201                 inEntRef = parent.getNodeType()==Node.ENTITY_REFERENCE_NODE;
202         }
203 
204         while (node != null) {
205             short type = node.getNodeType();
206             if (type == Node.ENTITY_REFERENCE_NODE) {
207                 if (getWholeTextForward(node.getFirstChild(), buffer, node)){
208                     return true;
209                 }
210             }
211             else if (type == Node.TEXT_NODE ||
212                      type == Node.CDATA_SECTION_NODE) {
213                 ((NodeImpl)node).getTextContent(buffer);
214             }
215             else {
216                 return true;
</pre>
<hr />
<pre>
223         // check nodes to the right of the parent entity reference node for logically adjacent
224         // text nodes
225         if (inEntRef) {
226             getWholeTextForward(parent.getNextSibling(), buffer, parent.getParentNode());
227                         return true;
228         }
229 
230         return false;
231     }
232 
233     /**
234      * Concatenates the text of all logically-adjacent text nodes to the left of
235      * the node
236      * @param node
237      * @param buffer
238      * @param parent
239      * @return true - if execution was stopped because the type of node
240      *         other than EntityRef, Text, CDATA is encountered, otherwise
241      *         return false
242      */
<span class="line-modified">243     private boolean getWholeTextBackward(Node node, StringBuffer buffer, Node parent){</span>
244 
245         // boolean to indicate whether node is a child of an entity reference
246         boolean inEntRef = false;
247         if (parent!=null) {
248                 inEntRef = parent.getNodeType()==Node.ENTITY_REFERENCE_NODE;
249         }
250 
251         while (node != null) {
252             short type = node.getNodeType();
253             if (type == Node.ENTITY_REFERENCE_NODE) {
254                 if (getWholeTextBackward(node.getLastChild(), buffer, node)){
255                     return true;
256                 }
257             }
258             else if (type == Node.TEXT_NODE ||
259                      type == Node.CDATA_SECTION_NODE) {
260                 ((TextImpl)node).insertTextContent(buffer);
261             }
262             else {
263                 return true;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>

  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xerces.internal.dom;
 22 
</pre>
<hr />
<pre>
 24 import org.w3c.dom.DOMException;
 25 import org.w3c.dom.Node;
 26 import org.w3c.dom.Text;
 27 
 28 /**
 29  * Text nodes hold the non-markup, non-Entity content of
 30  * an Element or Attribute.
 31  * &lt;P&gt;
 32  * When a document is first made available to the DOM, there is only
 33  * one Text object for each block of adjacent plain-text. Users (ie,
 34  * applications) may create multiple adjacent Texts during editing --
 35  * see {@link org.w3c.dom.Element#normalize} for discussion.
 36  * &lt;P&gt;
 37  * Note that CDATASection is a subclass of Text. This is conceptually
 38  * valid, since they&#39;re really just two different ways of quoting
 39  * characters when they&#39;re written out as part of an XML stream.
 40  *
 41  * @xerces.internal
 42  *
 43  * @since  PR-DOM-Level-1-19980818.
<span class="line-added"> 44  * @LastModified: Apr 2019</span>
 45  */
 46 public class TextImpl
 47     extends CharacterDataImpl
 48     implements CharacterData, Text {
 49 
 50     //
 51     // Private Data members
 52     //
 53 
 54 
 55     //
 56     // Constants
 57     //
 58 
 59     /** Serialization version. */
 60     static final long serialVersionUID = -5294980852957403469L;
 61 
 62     //
 63     // Constructors
 64     //
</pre>
<hr />
<pre>
129         // REVISIT: is this implemenation correct?
130         if (needsSyncData()) {
131             synchronizeData();
132         }
133         return internalIsIgnorableWhitespace();
134     }
135 
136 
137     /**
138      * DOM Level 3 WD - Experimental.
139      * Returns all text of &lt;code&gt;Text&lt;/code&gt; nodes logically-adjacent text
140      * nodes to this node, concatenated in document order.
141      * @since DOM Level 3
142      */
143     public String getWholeText(){
144 
145         if (needsSyncData()) {
146             synchronizeData();
147         }
148 
<span class="line-modified">149         StringBuilder buffer = new StringBuilder();</span>





150         if (data != null &amp;&amp; data.length() != 0) {
<span class="line-modified">151             buffer.append(data);</span>
152         }
153 
<span class="line-modified">154         // concatenate text of logically adjacent text nodes to the left of this node in the tree</span>
<span class="line-modified">155         getWholeTextBackward(this.getPreviousSibling(), buffer, this.getParentNode());</span>
<span class="line-modified">156         String temp = buffer.toString();</span>
157 
<span class="line-modified">158         // clear buffer</span>
<span class="line-modified">159         buffer.setLength(0);</span>
160 
<span class="line-modified">161         // concatenate text of logically adjacent text nodes to the right of this node in the tree</span>
<span class="line-modified">162         getWholeTextForward(this.getNextSibling(), buffer, this.getParentNode());</span>
163 
<span class="line-modified">164         return temp + buffer.toString();</span>
165 
166     }
167 
168     /**
<span class="line-modified">169      * internal method taking a StringBuilder in parameter and inserts the</span>
170      * text content at the start of the buffer
171      *
172      * @param buf
173      */
<span class="line-modified">174     protected void insertTextContent(StringBuilder buf) throws DOMException {</span>
175          String content = getNodeValue();
176          if (content != null) {
177              buf.insert(0, content);
178          }
179      }
180 
181     /**
182      * Concatenates the text of all logically-adjacent text nodes to the
183      * right of this node
184      * @param node
185      * @param buffer
186      * @param parent
187      * @return true - if execution was stopped because the type of node
188      *         other than EntityRef, Text, CDATA is encountered, otherwise
189      *         return false
190      */
<span class="line-modified">191     private boolean getWholeTextForward(Node node, StringBuilder buffer, Node parent){</span>
192         // boolean to indicate whether node is a child of an entity reference
193         boolean inEntRef = false;
194 
195         if (parent!=null) {
196                 inEntRef = parent.getNodeType()==Node.ENTITY_REFERENCE_NODE;
197         }
198 
199         while (node != null) {
200             short type = node.getNodeType();
201             if (type == Node.ENTITY_REFERENCE_NODE) {
202                 if (getWholeTextForward(node.getFirstChild(), buffer, node)){
203                     return true;
204                 }
205             }
206             else if (type == Node.TEXT_NODE ||
207                      type == Node.CDATA_SECTION_NODE) {
208                 ((NodeImpl)node).getTextContent(buffer);
209             }
210             else {
211                 return true;
</pre>
<hr />
<pre>
218         // check nodes to the right of the parent entity reference node for logically adjacent
219         // text nodes
220         if (inEntRef) {
221             getWholeTextForward(parent.getNextSibling(), buffer, parent.getParentNode());
222                         return true;
223         }
224 
225         return false;
226     }
227 
228     /**
229      * Concatenates the text of all logically-adjacent text nodes to the left of
230      * the node
231      * @param node
232      * @param buffer
233      * @param parent
234      * @return true - if execution was stopped because the type of node
235      *         other than EntityRef, Text, CDATA is encountered, otherwise
236      *         return false
237      */
<span class="line-modified">238     private boolean getWholeTextBackward(Node node, StringBuilder buffer, Node parent){</span>
239 
240         // boolean to indicate whether node is a child of an entity reference
241         boolean inEntRef = false;
242         if (parent!=null) {
243                 inEntRef = parent.getNodeType()==Node.ENTITY_REFERENCE_NODE;
244         }
245 
246         while (node != null) {
247             short type = node.getNodeType();
248             if (type == Node.ENTITY_REFERENCE_NODE) {
249                 if (getWholeTextBackward(node.getLastChild(), buffer, node)){
250                     return true;
251                 }
252             }
253             else if (type == Node.TEXT_NODE ||
254                      type == Node.CDATA_SECTION_NODE) {
255                 ((TextImpl)node).insertTextContent(buffer);
256             }
257             else {
258                 return true;
</pre>
</td>
</tr>
</table>
<center><a href="ParentNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../impl/XMLDocumentFragmentScannerImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Select.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SWITCH.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackConsumer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Select.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 26 
 27 /**
 28  * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
 29  *
<span class="line-modified"> 30  * &lt;p&gt;</span>
<span class="line-removed"> 31  * We use our super&#39;s &lt;code&gt;target&lt;/code&gt; property as the default target.</span>
 32  *
<span class="line-removed"> 33  * @version $Id: Select.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 34  * @see LOOKUPSWITCH
 35  * @see TABLESWITCH
 36  * @see InstructionList

 37  */
 38 public abstract class Select extends BranchInstruction implements VariableLengthInstruction,
 39         StackConsumer /* @since 6.0 */, StackProducer {
 40 
 41     private int[] match; // matches, i.e., case 1: ... TODO could be package-protected?
 42     private int[] indices; // target offsets TODO could be package-protected?
 43     private InstructionHandle[] targets; // target objects in instruction list TODO could be package-protected?
 44     private int fixed_length; // fixed length defined by subclasses TODO could be package-protected?
 45     private int match_length; // number of cases TODO could be package-protected?
 46     private int padding = 0; // number of pad bytes for alignment TODO could be package-protected?
 47 
 48     /**
<span class="line-modified"> 49      * Empty constructor needed for the Class.newInstance() statement in</span>
<span class="line-modified"> 50      * Instruction.readInstruction(). Not to be used otherwise.</span>
 51      */
 52     Select() {
 53     }
 54 

 55     /**
<span class="line-modified"> 56      * (Match, target) pairs for switch. `Match&#39; and `targets&#39; must have the</span>
<span class="line-modified"> 57      * same length of course.</span>
 58      *
 59      * @param match array of matching values
 60      * @param targets instruction targets
 61      * @param defaultTarget default instruction target
 62      */
 63     Select(final short opcode, final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {
 64         // don&#39;t set default target before instuction is built
 65         super(opcode, null);
 66         this.match = match;
 67         this.targets = targets;
 68         // now it&#39;s safe to set default target
 69         setTarget(defaultTarget);
 70         for (final InstructionHandle target2 : targets) {
 71             notifyTarget(null, target2, this);
 72         }
 73         if ((match_length = match.length) != targets.length) {
<span class="line-modified"> 74             throw new ClassGenException(&quot;Match and target array have not the same length: Match length: &quot;</span>
<span class="line-modified"> 75                     + match.length + &quot; Target length: &quot; + targets.length);</span>
 76         }
 77         indices = new int[match_length];
 78     }
 79 

 80     /**
 81      * Since this is a variable length instruction, it may shift the following
 82      * instructions which then need to update their position.
 83      *
<span class="line-modified"> 84      * Called by InstructionList.setPositions when setting the position for</span>
<span class="line-modified"> 85      * every instruction. In the presence of variable length instructions</span>
<span class="line-modified"> 86      * `setPositions&#39; performs multiple passes over the instruction list to</span>
<span class="line-modified"> 87      * calculate the correct (byte) positions and offsets by calling this</span>
<span class="line-removed"> 88      * function.</span>
 89      *
<span class="line-modified"> 90      * @param offset additional offset caused by preceding (variable length)</span>
<span class="line-modified"> 91      * instructions</span>
<span class="line-modified"> 92      * @param max_offset the maximum offset that may be caused by these</span>
<span class="line-removed"> 93      * instructions</span>
<span class="line-removed"> 94      * @return additional offset caused by possible change of this instruction&#39;s</span>
<span class="line-removed"> 95      * length</span>
 96      */
 97     @Override
<span class="line-modified"> 98     protected int updatePosition(final int offset, final int max_offset) {</span>
 99         setPosition(getPosition() + offset); // Additional offset caused by preceding SWITCHs, GOTOs, etc.
100         final short old_length = (short) super.getLength();
101         /* Alignment on 4-byte-boundary, + 1, because of tag byte.
102          */
103         padding = (4 - ((getPosition() + 1) % 4)) % 4;
104         super.setLength((short) (fixed_length + padding)); // Update length
105         return super.getLength() - old_length;
106     }
107 

108     /**
109      * Dump instruction as byte code to stream out.
<span class="line-removed">110      *</span>
111      * @param out Output stream
112      */
113     @Override
<span class="line-modified">114     public void dump(final DataOutputStream out) throws IOException {</span>
115         out.writeByte(super.getOpcode());
116         for (int i = 0; i &lt; padding; i++) {
117             out.writeByte(0);
118         }
119         super.setIndex(getTargetOffset()); // Write default target offset
120         out.writeInt(super.getIndex());
121     }
122 

123     /**
124      * Read needed data (e.g. index) from file.
125      */
126     @Override
<span class="line-modified">127     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {</span>
128         padding = (4 - (bytes.getIndex() % 4)) % 4; // Compute number of pad bytes
129         for (int i = 0; i &lt; padding; i++) {
130             bytes.readByte();
131         }
132         // Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
133         super.setIndex(bytes.readInt());
134     }
135 

136     /**
137      * @return mnemonic for instruction
138      */
139     @Override
<span class="line-modified">140     public String toString(final boolean verbose) {</span>
141         final StringBuilder buf = new StringBuilder(super.toString(verbose));
142         if (verbose) {
143             for (int i = 0; i &lt; match_length; i++) {
144                 String s = &quot;null&quot;;
145                 if (targets[i] != null) {
146                     s = targets[i].getInstruction().toString();
147                 }
148                 buf.append(&quot;(&quot;).append(match[i]).append(&quot;, &quot;).append(s).append(&quot; = {&quot;).append(
149                         indices[i]).append(&quot;})&quot;);
150             }
151         } else {
152             buf.append(&quot; ...&quot;);
153         }
154         return buf.toString();
155     }
156 

157     /**
158      * Set branch target for `i&#39;th case
159      */
<span class="line-modified">160     public void setTarget(final int i, final InstructionHandle target) { // TODO could be package-protected?</span>
161         notifyTarget(targets[i], target, this);
162         targets[i] = target;
163     }
164 

165     /**
166      * @param old_ih old target
167      * @param new_ih new target
168      */
169     @Override
<span class="line-modified">170     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
171         boolean targeted = false;
172         if (super.getTarget() == old_ih) {
173             targeted = true;
174             setTarget(new_ih);
175         }
176         for (int i = 0; i &lt; targets.length; i++) {
177             if (targets[i] == old_ih) {
178                 targeted = true;
179                 setTarget(i, new_ih);
180             }
181         }
182         if (!targeted) {
183             throw new ClassGenException(&quot;Not targeting &quot; + old_ih);
184         }
185     }
186 

187     /**
188      * @return true, if ih is target of this instruction
189      */
190     @Override
<span class="line-modified">191     public boolean containsTarget(final InstructionHandle ih) {</span>
192         if (super.getTarget() == ih) {
193             return true;
194         }
195         for (final InstructionHandle target2 : targets) {
196             if (target2 == ih) {
197                 return true;
198             }
199         }
200         return false;
201     }
202 

203     @Override
204     protected Object clone() throws CloneNotSupportedException {
205         final Select copy = (Select) super.clone();
206         copy.match = match.clone();
207         copy.indices = indices.clone();
208         copy.targets = targets.clone();
209         return copy;
210     }
211 

212     /**
213      * Inform targets that they&#39;re not targeted anymore.
214      */
215     @Override
216     void dispose() {
217         super.dispose();
218         for (final InstructionHandle target2 : targets) {
219             target2.removeTargeter(this);
220         }
221     }
222 

223     /**
224      * @return array of match indices
225      */
226     public int[] getMatchs() {
227         return match;
228     }
229 

230     /**
231      * @return array of match target offsets
232      */
233     public int[] getIndices() {
234         return indices;
235     }
236 

237     /**
238      * @return array of match targets
239      */
240     public InstructionHandle[] getTargets() {
241         return targets;
242     }
243 
244     /**
245      * @return match entry
246      * @since 6.0
247      */
248     final int getMatch(final int index) {
249         return match[index];
250     }
251 

252     /**
253      * @return index entry from indices
254      * @since 6.0
255      */
256     final int getIndices(final int index) {
257         return indices[index];
258     }
259 
260     /**
261      * @return target entry
262      * @since 6.0
263      */
264     final InstructionHandle getTarget(final int index) {
265         return targets[index];
266     }
267 

268     /**
269      * @return the fixed_length
270      * @since 6.0
271      */
272     final int getFixed_length() {
273         return fixed_length;
274     }
275 

276     /**
277      * @param fixed_length the fixed_length to set
278      * @since 6.0
279      */
280     final void setFixed_length(final int fixed_length) {
281         this.fixed_length = fixed_length;
282     }
283 

284     /**
285      * @return the match_length
286      * @since 6.0
287      */
288     final int getMatch_length() {
289         return match_length;
290     }
291 

292     /**
293      * @param match_length the match_length to set
294      * @since 6.0
295      */
296     final int setMatch_length(final int match_length) {
297         this.match_length = match_length;
298         return match_length;
299     }
300 
301     /**
302      *
303      * @param index
304      * @param value
305      * @since 6.0
306      */
307     final void setMatch(final int index, final int value) {
308         match[index] = value;
309     }
310 
311     /**
</pre>
<hr />
<pre>
327     }
328 
329     /**
330      *
331      * @param array
332      * @since 6.0
333      */
334     final void setTargets(final InstructionHandle[] array) {
335         targets = array;
336     }
337 
338     /**
339      *
340      * @return the padding
341      * @since 6.0
342      */
343     final int getPadding() {
344         return padding;
345     }
346 
<span class="line-modified">347     /**</span>
<span class="line-modified">348      * @since 6.0</span>
<span class="line-removed">349      */</span>
350     final int setIndices(final int i, final int value) {
351         indices[i] = value;
352         return value;  // Allow use in nested calls
353     }
354 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 26 
 27 /**
 28  * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
 29  *
<span class="line-modified"> 30  * &lt;p&gt;We use our super&#39;s &lt;code&gt;target&lt;/code&gt; property as the default target.</span>

 31  *

 32  * @see LOOKUPSWITCH
 33  * @see TABLESWITCH
 34  * @see InstructionList
<span class="line-added"> 35  * @LastModified: Jan 2020</span>
 36  */
 37 public abstract class Select extends BranchInstruction implements VariableLengthInstruction,
 38         StackConsumer /* @since 6.0 */, StackProducer {
 39 
 40     private int[] match; // matches, i.e., case 1: ... TODO could be package-protected?
 41     private int[] indices; // target offsets TODO could be package-protected?
 42     private InstructionHandle[] targets; // target objects in instruction list TODO could be package-protected?
 43     private int fixed_length; // fixed length defined by subclasses TODO could be package-protected?
 44     private int match_length; // number of cases TODO could be package-protected?
 45     private int padding = 0; // number of pad bytes for alignment TODO could be package-protected?
 46 
 47     /**
<span class="line-modified"> 48      * Empty constructor needed for Instruction.readInstruction.</span>
<span class="line-modified"> 49      * Not to be used otherwise.</span>
 50      */
 51     Select() {
 52     }
 53 
<span class="line-added"> 54 </span>
 55     /**
<span class="line-modified"> 56      * (Match, target) pairs for switch.</span>
<span class="line-modified"> 57      * `Match&#39; and `targets&#39; must have the same length of course.</span>
 58      *
 59      * @param match array of matching values
 60      * @param targets instruction targets
 61      * @param defaultTarget default instruction target
 62      */
 63     Select(final short opcode, final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {
 64         // don&#39;t set default target before instuction is built
 65         super(opcode, null);
 66         this.match = match;
 67         this.targets = targets;
 68         // now it&#39;s safe to set default target
 69         setTarget(defaultTarget);
 70         for (final InstructionHandle target2 : targets) {
 71             notifyTarget(null, target2, this);
 72         }
 73         if ((match_length = match.length) != targets.length) {
<span class="line-modified"> 74             throw new ClassGenException(&quot;Match and target array have not the same length: Match length: &quot; +</span>
<span class="line-modified"> 75                 match.length + &quot; Target length: &quot; + targets.length);</span>
 76         }
 77         indices = new int[match_length];
 78     }
 79 
<span class="line-added"> 80 </span>
 81     /**
 82      * Since this is a variable length instruction, it may shift the following
 83      * instructions which then need to update their position.
 84      *
<span class="line-modified"> 85      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified"> 86      * instruction. In the presence of variable length instructions `setPositions&#39;</span>
<span class="line-modified"> 87      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified"> 88      * correct (byte) positions and offsets by calling this function.</span>

 89      *
<span class="line-modified"> 90      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified"> 91      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified"> 92      * @return additional offset caused by possible change of this instruction&#39;s length</span>



 93      */
 94     @Override
<span class="line-modified"> 95     protected int updatePosition( final int offset, final int max_offset ) {</span>
 96         setPosition(getPosition() + offset); // Additional offset caused by preceding SWITCHs, GOTOs, etc.
 97         final short old_length = (short) super.getLength();
 98         /* Alignment on 4-byte-boundary, + 1, because of tag byte.
 99          */
100         padding = (4 - ((getPosition() + 1) % 4)) % 4;
101         super.setLength((short) (fixed_length + padding)); // Update length
102         return super.getLength() - old_length;
103     }
104 
<span class="line-added">105 </span>
106     /**
107      * Dump instruction as byte code to stream out.

108      * @param out Output stream
109      */
110     @Override
<span class="line-modified">111     public void dump( final DataOutputStream out ) throws IOException {</span>
112         out.writeByte(super.getOpcode());
113         for (int i = 0; i &lt; padding; i++) {
114             out.writeByte(0);
115         }
116         super.setIndex(getTargetOffset()); // Write default target offset
117         out.writeInt(super.getIndex());
118     }
119 
<span class="line-added">120 </span>
121     /**
122      * Read needed data (e.g. index) from file.
123      */
124     @Override
<span class="line-modified">125     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
126         padding = (4 - (bytes.getIndex() % 4)) % 4; // Compute number of pad bytes
127         for (int i = 0; i &lt; padding; i++) {
128             bytes.readByte();
129         }
130         // Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
131         super.setIndex(bytes.readInt());
132     }
133 
<span class="line-added">134 </span>
135     /**
136      * @return mnemonic for instruction
137      */
138     @Override
<span class="line-modified">139     public String toString( final boolean verbose ) {</span>
140         final StringBuilder buf = new StringBuilder(super.toString(verbose));
141         if (verbose) {
142             for (int i = 0; i &lt; match_length; i++) {
143                 String s = &quot;null&quot;;
144                 if (targets[i] != null) {
145                     s = targets[i].getInstruction().toString();
146                 }
147                 buf.append(&quot;(&quot;).append(match[i]).append(&quot;, &quot;).append(s).append(&quot; = {&quot;).append(
148                         indices[i]).append(&quot;})&quot;);
149             }
150         } else {
151             buf.append(&quot; ...&quot;);
152         }
153         return buf.toString();
154     }
155 
<span class="line-added">156 </span>
157     /**
158      * Set branch target for `i&#39;th case
159      */
<span class="line-modified">160     public void setTarget( final int i, final InstructionHandle target ) { // TODO could be package-protected?</span>
161         notifyTarget(targets[i], target, this);
162         targets[i] = target;
163     }
164 
<span class="line-added">165 </span>
166     /**
167      * @param old_ih old target
168      * @param new_ih new target
169      */
170     @Override
<span class="line-modified">171     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
172         boolean targeted = false;
173         if (super.getTarget() == old_ih) {
174             targeted = true;
175             setTarget(new_ih);
176         }
177         for (int i = 0; i &lt; targets.length; i++) {
178             if (targets[i] == old_ih) {
179                 targeted = true;
180                 setTarget(i, new_ih);
181             }
182         }
183         if (!targeted) {
184             throw new ClassGenException(&quot;Not targeting &quot; + old_ih);
185         }
186     }
187 
<span class="line-added">188 </span>
189     /**
190      * @return true, if ih is target of this instruction
191      */
192     @Override
<span class="line-modified">193     public boolean containsTarget( final InstructionHandle ih ) {</span>
194         if (super.getTarget() == ih) {
195             return true;
196         }
197         for (final InstructionHandle target2 : targets) {
198             if (target2 == ih) {
199                 return true;
200             }
201         }
202         return false;
203     }
204 
<span class="line-added">205 </span>
206     @Override
207     protected Object clone() throws CloneNotSupportedException {
208         final Select copy = (Select) super.clone();
209         copy.match = match.clone();
210         copy.indices = indices.clone();
211         copy.targets = targets.clone();
212         return copy;
213     }
214 
<span class="line-added">215 </span>
216     /**
217      * Inform targets that they&#39;re not targeted anymore.
218      */
219     @Override
220     void dispose() {
221         super.dispose();
222         for (final InstructionHandle target2 : targets) {
223             target2.removeTargeter(this);
224         }
225     }
226 
<span class="line-added">227 </span>
228     /**
229      * @return array of match indices
230      */
231     public int[] getMatchs() {
232         return match;
233     }
234 
<span class="line-added">235 </span>
236     /**
237      * @return array of match target offsets
238      */
239     public int[] getIndices() {
240         return indices;
241     }
242 
<span class="line-added">243 </span>
244     /**
245      * @return array of match targets
246      */
247     public InstructionHandle[] getTargets() {
248         return targets;
249     }
250 
251     /**
252      * @return match entry
253      * @since 6.0
254      */
255     final int getMatch(final int index) {
256         return match[index];
257     }
258 
<span class="line-added">259 </span>
260     /**
261      * @return index entry from indices
262      * @since 6.0
263      */
264     final int getIndices(final int index) {
265         return indices[index];
266     }
267 
268     /**
269      * @return target entry
270      * @since 6.0
271      */
272     final InstructionHandle getTarget(final int index) {
273         return targets[index];
274     }
275 
<span class="line-added">276 </span>
277     /**
278      * @return the fixed_length
279      * @since 6.0
280      */
281     final int getFixed_length() {
282         return fixed_length;
283     }
284 
<span class="line-added">285 </span>
286     /**
287      * @param fixed_length the fixed_length to set
288      * @since 6.0
289      */
290     final void setFixed_length(final int fixed_length) {
291         this.fixed_length = fixed_length;
292     }
293 
<span class="line-added">294 </span>
295     /**
296      * @return the match_length
297      * @since 6.0
298      */
299     final int getMatch_length() {
300         return match_length;
301     }
302 
<span class="line-added">303 </span>
304     /**
305      * @param match_length the match_length to set
306      * @since 6.0
307      */
308     final int setMatch_length(final int match_length) {
309         this.match_length = match_length;
310         return match_length;
311     }
312 
313     /**
314      *
315      * @param index
316      * @param value
317      * @since 6.0
318      */
319     final void setMatch(final int index, final int value) {
320         match[index] = value;
321     }
322 
323     /**
</pre>
<hr />
<pre>
339     }
340 
341     /**
342      *
343      * @param array
344      * @since 6.0
345      */
346     final void setTargets(final InstructionHandle[] array) {
347         targets = array;
348     }
349 
350     /**
351      *
352      * @return the padding
353      * @since 6.0
354      */
355     final int getPadding() {
356         return padding;
357     }
358 
<span class="line-modified">359 </span>
<span class="line-modified">360     /** @since 6.0 */</span>

361     final int setIndices(final int i, final int value) {
362         indices[i] = value;
363         return value;  // Allow use in nested calls
364     }
365 }
</pre>
</td>
</tr>
</table>
<center><a href="SWITCH.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackConsumer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
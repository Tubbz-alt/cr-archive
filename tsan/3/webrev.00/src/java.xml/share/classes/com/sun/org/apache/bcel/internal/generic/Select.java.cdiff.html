<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Select.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SWITCH.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackConsumer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Select.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,17 ***</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
   *
<span class="line-modified">!  * &lt;p&gt;</span>
<span class="line-removed">-  * We use our super&#39;s &lt;code&gt;target&lt;/code&gt; property as the default target.</span>
   *
<span class="line-removed">-  * @version $Id: Select.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   * @see LOOKUPSWITCH
   * @see TABLESWITCH
   * @see InstructionList
   */
  public abstract class Select extends BranchInstruction implements VariableLengthInstruction,
          StackConsumer /* @since 6.0 */, StackProducer {
  
      private int[] match; // matches, i.e., case 1: ... TODO could be package-protected?
<span class="line-new-header">--- 25,16 ---</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Select - Abstract super class for LOOKUPSWITCH and TABLESWITCH instructions.
   *
<span class="line-modified">!  * &lt;p&gt;We use our super&#39;s &lt;code&gt;target&lt;/code&gt; property as the default target.</span>
   *
   * @see LOOKUPSWITCH
   * @see TABLESWITCH
   * @see InstructionList
<span class="line-added">+  * @LastModified: Jan 2020</span>
   */
  public abstract class Select extends BranchInstruction implements VariableLengthInstruction,
          StackConsumer /* @since 6.0 */, StackProducer {
  
      private int[] match; // matches, i.e., case 1: ... TODO could be package-protected?
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,19 ***</span>
      private int fixed_length; // fixed length defined by subclasses TODO could be package-protected?
      private int match_length; // number of cases TODO could be package-protected?
      private int padding = 0; // number of pad bytes for alignment TODO could be package-protected?
  
      /**
<span class="line-modified">!      * Empty constructor needed for the Class.newInstance() statement in</span>
<span class="line-modified">!      * Instruction.readInstruction(). Not to be used otherwise.</span>
       */
      Select() {
      }
  
      /**
<span class="line-modified">!      * (Match, target) pairs for switch. `Match&#39; and `targets&#39; must have the</span>
<span class="line-modified">!      * same length of course.</span>
       *
       * @param match array of matching values
       * @param targets instruction targets
       * @param defaultTarget default instruction target
       */
<span class="line-new-header">--- 43,20 ---</span>
      private int fixed_length; // fixed length defined by subclasses TODO could be package-protected?
      private int match_length; // number of cases TODO could be package-protected?
      private int padding = 0; // number of pad bytes for alignment TODO could be package-protected?
  
      /**
<span class="line-modified">!      * Empty constructor needed for Instruction.readInstruction.</span>
<span class="line-modified">!      * Not to be used otherwise.</span>
       */
      Select() {
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * (Match, target) pairs for switch.</span>
<span class="line-modified">!      * `Match&#39; and `targets&#39; must have the same length of course.</span>
       *
       * @param match array of matching values
       * @param targets instruction targets
       * @param defaultTarget default instruction target
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,77 ***</span>
          setTarget(defaultTarget);
          for (final InstructionHandle target2 : targets) {
              notifyTarget(null, target2, this);
          }
          if ((match_length = match.length) != targets.length) {
<span class="line-modified">!             throw new ClassGenException(&quot;Match and target array have not the same length: Match length: &quot;</span>
<span class="line-modified">!                     + match.length + &quot; Target length: &quot; + targets.length);</span>
          }
          indices = new int[match_length];
      }
  
      /**
       * Since this is a variable length instruction, it may shift the following
       * instructions which then need to update their position.
       *
<span class="line-modified">!      * Called by InstructionList.setPositions when setting the position for</span>
<span class="line-modified">!      * every instruction. In the presence of variable length instructions</span>
<span class="line-modified">!      * `setPositions&#39; performs multiple passes over the instruction list to</span>
<span class="line-modified">!      * calculate the correct (byte) positions and offsets by calling this</span>
<span class="line-removed">-      * function.</span>
       *
<span class="line-modified">!      * @param offset additional offset caused by preceding (variable length)</span>
<span class="line-modified">!      * instructions</span>
<span class="line-modified">!      * @param max_offset the maximum offset that may be caused by these</span>
<span class="line-removed">-      * instructions</span>
<span class="line-removed">-      * @return additional offset caused by possible change of this instruction&#39;s</span>
<span class="line-removed">-      * length</span>
       */
      @Override
<span class="line-modified">!     protected int updatePosition(final int offset, final int max_offset) {</span>
          setPosition(getPosition() + offset); // Additional offset caused by preceding SWITCHs, GOTOs, etc.
          final short old_length = (short) super.getLength();
          /* Alignment on 4-byte-boundary, + 1, because of tag byte.
           */
          padding = (4 - ((getPosition() + 1) % 4)) % 4;
          super.setLength((short) (fixed_length + padding)); // Update length
          return super.getLength() - old_length;
      }
  
      /**
       * Dump instruction as byte code to stream out.
<span class="line-removed">-      *</span>
       * @param out Output stream
       */
      @Override
<span class="line-modified">!     public void dump(final DataOutputStream out) throws IOException {</span>
          out.writeByte(super.getOpcode());
          for (int i = 0; i &lt; padding; i++) {
              out.writeByte(0);
          }
          super.setIndex(getTargetOffset()); // Write default target offset
          out.writeInt(super.getIndex());
      }
  
      /**
       * Read needed data (e.g. index) from file.
       */
      @Override
<span class="line-modified">!     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {</span>
          padding = (4 - (bytes.getIndex() % 4)) % 4; // Compute number of pad bytes
          for (int i = 0; i &lt; padding; i++) {
              bytes.readByte();
          }
          // Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
          super.setIndex(bytes.readInt());
      }
  
      /**
       * @return mnemonic for instruction
       */
      @Override
<span class="line-modified">!     public String toString(final boolean verbose) {</span>
          final StringBuilder buf = new StringBuilder(super.toString(verbose));
          if (verbose) {
              for (int i = 0; i &lt; match_length; i++) {
                  String s = &quot;null&quot;;
                  if (targets[i] != null) {
<span class="line-new-header">--- 69,76 ---</span>
          setTarget(defaultTarget);
          for (final InstructionHandle target2 : targets) {
              notifyTarget(null, target2, this);
          }
          if ((match_length = match.length) != targets.length) {
<span class="line-modified">!             throw new ClassGenException(&quot;Match and target array have not the same length: Match length: &quot; +</span>
<span class="line-modified">!                 match.length + &quot; Target length: &quot; + targets.length);</span>
          }
          indices = new int[match_length];
      }
  
<span class="line-added">+ </span>
      /**
       * Since this is a variable length instruction, it may shift the following
       * instructions which then need to update their position.
       *
<span class="line-modified">!      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified">!      * instruction. In the presence of variable length instructions `setPositions&#39;</span>
<span class="line-modified">!      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified">!      * correct (byte) positions and offsets by calling this function.</span>
       *
<span class="line-modified">!      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified">!      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified">!      * @return additional offset caused by possible change of this instruction&#39;s length</span>
       */
      @Override
<span class="line-modified">!     protected int updatePosition( final int offset, final int max_offset ) {</span>
          setPosition(getPosition() + offset); // Additional offset caused by preceding SWITCHs, GOTOs, etc.
          final short old_length = (short) super.getLength();
          /* Alignment on 4-byte-boundary, + 1, because of tag byte.
           */
          padding = (4 - ((getPosition() + 1) % 4)) % 4;
          super.setLength((short) (fixed_length + padding)); // Update length
          return super.getLength() - old_length;
      }
  
<span class="line-added">+ </span>
      /**
       * Dump instruction as byte code to stream out.
       * @param out Output stream
       */
      @Override
<span class="line-modified">!     public void dump( final DataOutputStream out ) throws IOException {</span>
          out.writeByte(super.getOpcode());
          for (int i = 0; i &lt; padding; i++) {
              out.writeByte(0);
          }
          super.setIndex(getTargetOffset()); // Write default target offset
          out.writeInt(super.getIndex());
      }
  
<span class="line-added">+ </span>
      /**
       * Read needed data (e.g. index) from file.
       */
      @Override
<span class="line-modified">!     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
          padding = (4 - (bytes.getIndex() % 4)) % 4; // Compute number of pad bytes
          for (int i = 0; i &lt; padding; i++) {
              bytes.readByte();
          }
          // Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)
          super.setIndex(bytes.readInt());
      }
  
<span class="line-added">+ </span>
      /**
       * @return mnemonic for instruction
       */
      @Override
<span class="line-modified">!     public String toString( final boolean verbose ) {</span>
          final StringBuilder buf = new StringBuilder(super.toString(verbose));
          if (verbose) {
              for (int i = 0; i &lt; match_length; i++) {
                  String s = &quot;null&quot;;
                  if (targets[i] != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,24 ***</span>
              buf.append(&quot; ...&quot;);
          }
          return buf.toString();
      }
  
      /**
       * Set branch target for `i&#39;th case
       */
<span class="line-modified">!     public void setTarget(final int i, final InstructionHandle target) { // TODO could be package-protected?</span>
          notifyTarget(targets[i], target, this);
          targets[i] = target;
      }
  
      /**
       * @param old_ih old target
       * @param new_ih new target
       */
      @Override
<span class="line-modified">!     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
          boolean targeted = false;
          if (super.getTarget() == old_ih) {
              targeted = true;
              setTarget(new_ih);
          }
<span class="line-new-header">--- 151,26 ---</span>
              buf.append(&quot; ...&quot;);
          }
          return buf.toString();
      }
  
<span class="line-added">+ </span>
      /**
       * Set branch target for `i&#39;th case
       */
<span class="line-modified">!     public void setTarget( final int i, final InstructionHandle target ) { // TODO could be package-protected?</span>
          notifyTarget(targets[i], target, this);
          targets[i] = target;
      }
  
<span class="line-added">+ </span>
      /**
       * @param old_ih old target
       * @param new_ih new target
       */
      @Override
<span class="line-modified">!     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
          boolean targeted = false;
          if (super.getTarget() == old_ih) {
              targeted = true;
              setTarget(new_ih);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,15 ***</span>
          if (!targeted) {
              throw new ClassGenException(&quot;Not targeting &quot; + old_ih);
          }
      }
  
      /**
       * @return true, if ih is target of this instruction
       */
      @Override
<span class="line-modified">!     public boolean containsTarget(final InstructionHandle ih) {</span>
          if (super.getTarget() == ih) {
              return true;
          }
          for (final InstructionHandle target2 : targets) {
              if (target2 == ih) {
<span class="line-new-header">--- 183,16 ---</span>
          if (!targeted) {
              throw new ClassGenException(&quot;Not targeting &quot; + old_ih);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @return true, if ih is target of this instruction
       */
      @Override
<span class="line-modified">!     public boolean containsTarget( final InstructionHandle ih ) {</span>
          if (super.getTarget() == ih) {
              return true;
          }
          for (final InstructionHandle target2 : targets) {
              if (target2 == ih) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,19 ***</span>
<span class="line-new-header">--- 200,21 ---</span>
              }
          }
          return false;
      }
  
<span class="line-added">+ </span>
      @Override
      protected Object clone() throws CloneNotSupportedException {
          final Select copy = (Select) super.clone();
          copy.match = match.clone();
          copy.indices = indices.clone();
          copy.targets = targets.clone();
          return copy;
      }
  
<span class="line-added">+ </span>
      /**
       * Inform targets that they&#39;re not targeted anymore.
       */
      @Override
      void dispose() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,24 ***</span>
<span class="line-new-header">--- 222,27 ---</span>
          for (final InstructionHandle target2 : targets) {
              target2.removeTargeter(this);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @return array of match indices
       */
      public int[] getMatchs() {
          return match;
      }
  
<span class="line-added">+ </span>
      /**
       * @return array of match target offsets
       */
      public int[] getIndices() {
          return indices;
      }
  
<span class="line-added">+ </span>
      /**
       * @return array of match targets
       */
      public InstructionHandle[] getTargets() {
          return targets;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,10 ***</span>
<span class="line-new-header">--- 254,11 ---</span>
       */
      final int getMatch(final int index) {
          return match[index];
      }
  
<span class="line-added">+ </span>
      /**
       * @return index entry from indices
       * @since 6.0
       */
      final int getIndices(final int index) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,34 ***</span>
<span class="line-new-header">--- 271,38 ---</span>
       */
      final InstructionHandle getTarget(final int index) {
          return targets[index];
      }
  
<span class="line-added">+ </span>
      /**
       * @return the fixed_length
       * @since 6.0
       */
      final int getFixed_length() {
          return fixed_length;
      }
  
<span class="line-added">+ </span>
      /**
       * @param fixed_length the fixed_length to set
       * @since 6.0
       */
      final void setFixed_length(final int fixed_length) {
          this.fixed_length = fixed_length;
      }
  
<span class="line-added">+ </span>
      /**
       * @return the match_length
       * @since 6.0
       */
      final int getMatch_length() {
          return match_length;
      }
  
<span class="line-added">+ </span>
      /**
       * @param match_length the match_length to set
       * @since 6.0
       */
      final int setMatch_length(final int match_length) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,13 ***</span>
       */
      final int getPadding() {
          return padding;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @since 6.0</span>
<span class="line-removed">-      */</span>
      final int setIndices(final int i, final int value) {
          indices[i] = value;
          return value;  // Allow use in nested calls
      }
  }
<span class="line-new-header">--- 354,12 ---</span>
       */
      final int getPadding() {
          return padding;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @since 6.0 */</span>
      final int setIndices(final int i, final int value) {
          indices[i] = value;
          return value;  // Allow use in nested calls
      }
  }
</pre>
<center><a href="SWITCH.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="StackConsumer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
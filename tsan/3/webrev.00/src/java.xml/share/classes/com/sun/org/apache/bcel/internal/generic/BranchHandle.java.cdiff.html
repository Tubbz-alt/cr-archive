<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/BranchHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BasicType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="BranchInstruction.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/BranchHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 21,51 ***</span>
  package com.sun.org.apache.bcel.internal.generic;
  
  /**
   * BranchHandle is returned by specialized InstructionList.append() whenever a
   * BranchInstruction is appended. This is useful when the target of this
<span class="line-modified">!  * instruction is not known at time of creation and must be set later via</span>
<span class="line-modified">!  * setTarget().</span>
   *
   * @see InstructionHandle
   * @see Instruction
   * @see InstructionList
<span class="line-removed">-  * @version $Id: BranchHandle.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   */
  public final class BranchHandle extends InstructionHandle {
  
      // This is also a cache in case the InstructionHandle#swapInstruction() method is used
      // See BCEL-273
      private BranchInstruction bi; // An alias in fact, but saves lots of casts
  
      private BranchHandle(final BranchInstruction i) {
          super(i);
          bi = i;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Factory methods.</span>
       */
<span class="line-modified">!     private static BranchHandle bh_list = null; // List of reusable handles</span>
<span class="line-modified">! </span>
<span class="line-removed">-     static BranchHandle getBranchHandle(final BranchInstruction i) {</span>
<span class="line-removed">-         if (bh_list == null) {</span>
<span class="line-removed">-             return new BranchHandle(i);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         final BranchHandle bh = bh_list;</span>
<span class="line-removed">-         bh_list = (BranchHandle) bh.getNext();</span>
<span class="line-removed">-         bh.setInstruction(i);</span>
<span class="line-removed">-         return bh;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Handle adds itself to the list of resuable handles.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     @Override</span>
<span class="line-removed">-     protected void addHandle() {</span>
<span class="line-removed">-         super.setNext(bh_list);</span>
<span class="line-removed">-         bh_list = this;</span>
      }
  
  
      /* Override InstructionHandle methods: delegate to branch instruction.
       * Through this overriding all access to the private i_position field should
<span class="line-new-header">--- 21,33 ---</span>
  package com.sun.org.apache.bcel.internal.generic;
  
  /**
   * BranchHandle is returned by specialized InstructionList.append() whenever a
   * BranchInstruction is appended. This is useful when the target of this
<span class="line-modified">!  * instruction is not known at time of creation and must be set later</span>
<span class="line-modified">!  * via setTarget().</span>
   *
   * @see InstructionHandle
   * @see Instruction
   * @see InstructionList
   */
  public final class BranchHandle extends InstructionHandle {
  
      // This is also a cache in case the InstructionHandle#swapInstruction() method is used
      // See BCEL-273
      private BranchInstruction bi; // An alias in fact, but saves lots of casts
  
<span class="line-added">+ </span>
      private BranchHandle(final BranchInstruction i) {
          super(i);
          bi = i;
      }
  
<span class="line-modified">!     /** Factory method.</span>
       */
<span class="line-modified">!     static BranchHandle getBranchHandle( final BranchInstruction i ) {</span>
<span class="line-modified">!         return new BranchHandle(i);</span>
      }
  
  
      /* Override InstructionHandle methods: delegate to branch instruction.
       * Through this overriding all access to the private i_position field should
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,51 ***</span>
      @Override
      public int getPosition() {
          return bi.getPosition();
      }
  
      @Override
<span class="line-modified">!     void setPosition(final int pos) {</span>
          // Original code: i_position = bi.position = pos;
          bi.setPosition(pos);
          super.setPosition(pos);
      }
  
      @Override
<span class="line-modified">!     protected int updatePosition(final int offset, final int max_offset) {</span>
          final int x = bi.updatePosition(offset, max_offset);
          super.setPosition(bi.getPosition());
          return x;
      }
  
      /**
       * Pass new target to instruction.
       */
<span class="line-modified">!     public void setTarget(final InstructionHandle ih) {</span>
          bi.setTarget(ih);
      }
  
      /**
       * Update target of instruction.
       */
<span class="line-modified">!     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
          bi.updateTarget(old_ih, new_ih);
      }
  
      /**
       * @return target of instruction.
       */
      public InstructionHandle getTarget() {
          return bi.getTarget();
      }
  
      /**
<span class="line-modified">!      * Set new contents. Old instruction is disposed and may not be used</span>
<span class="line-removed">-      * anymore.</span>
       */
      @Override // This is only done in order to apply the additional type check; could be merged with super impl.
<span class="line-modified">!     public void setInstruction(final Instruction i) { // TODO could be package-protected?</span>
          super.setInstruction(i);
          if (!(i instanceof BranchInstruction)) {
              throw new ClassGenException(&quot;Assigning &quot; + i
                      + &quot; to branch handle which is not a branch instruction&quot;);
          }
<span class="line-new-header">--- 56,56 ---</span>
      @Override
      public int getPosition() {
          return bi.getPosition();
      }
  
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     void setPosition( final int pos ) {</span>
          // Original code: i_position = bi.position = pos;
          bi.setPosition(pos);
          super.setPosition(pos);
      }
  
<span class="line-added">+ </span>
      @Override
<span class="line-modified">!     protected int updatePosition( final int offset, final int max_offset ) {</span>
          final int x = bi.updatePosition(offset, max_offset);
          super.setPosition(bi.getPosition());
          return x;
      }
  
<span class="line-added">+ </span>
      /**
       * Pass new target to instruction.
       */
<span class="line-modified">!     public void setTarget( final InstructionHandle ih ) {</span>
          bi.setTarget(ih);
      }
  
<span class="line-added">+ </span>
      /**
       * Update target of instruction.
       */
<span class="line-modified">!     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
          bi.updateTarget(old_ih, new_ih);
      }
  
<span class="line-added">+ </span>
      /**
       * @return target of instruction.
       */
      public InstructionHandle getTarget() {
          return bi.getTarget();
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Set new contents. Old instruction is disposed and may not be used anymore.</span>
       */
      @Override // This is only done in order to apply the additional type check; could be merged with super impl.
<span class="line-modified">!     public void setInstruction( final Instruction i ) { // TODO could be package-protected?</span>
          super.setInstruction(i);
          if (!(i instanceof BranchInstruction)) {
              throw new ClassGenException(&quot;Assigning &quot; + i
                      + &quot; to branch handle which is not a branch instruction&quot;);
          }
</pre>
<center><a href="BasicType.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="BranchInstruction.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
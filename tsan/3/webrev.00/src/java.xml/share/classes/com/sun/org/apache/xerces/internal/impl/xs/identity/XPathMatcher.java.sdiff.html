<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../XMLSchemaValidator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../traversers/XSDAbstractTraverser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xerces.internal.impl.xs.identity;
 22 
 23 import com.sun.org.apache.xerces.internal.impl.Constants;
 24 import com.sun.org.apache.xerces.internal.impl.xpath.XPath;
 25 import com.sun.org.apache.xerces.internal.util.IntStack;
 26 import com.sun.org.apache.xerces.internal.xni.QName;
 27 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
 28 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
 29 import com.sun.org.apache.xerces.internal.xs.ShortList;
 30 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
 31 import org.xml.sax.SAXException;
 32 
 33 
 34 /**
 35  * XPath matcher.
 36  *
 37  * @xerces.internal
 38  *
 39  * @author Andy Clark, IBM

 40  *
 41  */
 42 public class XPathMatcher {
 43 
 44     //
 45     // Constants
 46     //
 47 
 48     // debugging
 49 
 50     /** Compile to true to debug everything. */
 51     protected static final boolean DEBUG_ALL = false;
 52 
 53     /** Compile to true to debug method callbacks. */
 54     protected static final boolean DEBUG_METHODS = false || DEBUG_ALL;
 55 
 56     /** Compile to true to debug important method callbacks. */
 57     protected static final boolean DEBUG_METHODS2 = false || DEBUG_METHODS || DEBUG_ALL;
 58 
 59     /** Compile to true to debug the &lt;em&gt;really&lt;/em&gt; important methods. */
</pre>
<hr />
<pre>
 71                                                DEBUG_METHODS3 ||
 72                                                DEBUG_MATCH ||
 73                                                DEBUG_STACK;
 74 
 75     // constants describing whether a match was made,
 76     // and if so how.
 77     // matched any way
 78     protected static final int MATCHED = 1;
 79     // matched on the attribute axis
 80     protected static final int MATCHED_ATTRIBUTE = 3;
 81     // matched on the descendant-or-self axixs
 82     protected static final int MATCHED_DESCENDANT = 5;
 83     // matched some previous (ancestor) node on the descendant-or-self-axis, but not this node
 84     protected static final int MATCHED_DESCENDANT_PREVIOUS = 13;
 85 
 86     //
 87     // Data
 88     //
 89 
 90     /** XPath location path. */
<span class="line-modified"> 91     private XPath.LocationPath[] fLocationPaths;</span>
 92 
 93     /** True if XPath has been matched. */
<span class="line-modified"> 94     private int[] fMatched;</span>
 95 
 96     /** The matching string. */
 97     protected Object fMatchedString;
 98 
 99     /** Integer stack of step indexes. */
<span class="line-modified">100     private IntStack[] fStepIndexes;</span>
101 
102     /** Current step. */
<span class="line-modified">103     private int[] fCurrentStep;</span>
104 
105     /**
106      * No match depth. The value of this field will be zero while
107      * matching is successful for the given xpath expression.
108      */
<span class="line-modified">109     private int [] fNoMatchDepth;</span>
110 
111     final QName fQName = new QName();
112 
113 
114     //
115     // Constructors
116     //
117 
118     /**
119      * Constructs an XPath matcher that implements a document fragment
120      * handler.
121      *
122      * @param xpath   The xpath.
123      */
124     public XPathMatcher(XPath xpath) {
125         fLocationPaths = xpath.getLocationPaths();
126         fStepIndexes = new IntStack[fLocationPaths.length];
127         for(int i=0; i&lt;fStepIndexes.length; i++) fStepIndexes[i] = new IntStack();
128         fCurrentStep = new int[fLocationPaths.length];
129         fNoMatchDepth = new int[fLocationPaths.length];
</pre>
<hr />
<pre>
190         for(int i = 0; i &lt; fLocationPaths.length; i++) {
191             fStepIndexes[i].clear();
192             fCurrentStep[i] = 0;
193             fNoMatchDepth[i] = 0;
194             fMatched[i] = 0;
195         }
196 
197 
198     } // startDocumentFragment()
199 
200     /**
201      * The start of an element. If the document specifies the start element
202      * by using an empty tag, then the startElement method will immediately
203      * be followed by the endElement method, with no intervening methods.
204      *
205      * @param element    The name of the element.
206      * @param attributes The element attributes.
207      *
208      * @throws SAXException Thrown by handler to signal an error.
209      */
<span class="line-modified">210     public void startElement(QName element, XMLAttributes attributes){</span>
211         if (DEBUG_METHODS2) {
212             System.out.println(toString()+&quot;#startElement(&quot;+
213                                &quot;element={&quot;+element+&quot;},&quot;+
214                                &quot;attributes=...&quot;+attributes+
215                                &quot;)&quot;);
216         }
217 
<span class="line-modified">218         for(int i = 0; i &lt; fLocationPaths.length; i++) {</span>
219             // push context
220             int startStep = fCurrentStep[i];
221             fStepIndexes[i].push(startStep);
222 
223             // try next xpath, if not matching
224             if ((fMatched[i] &amp; MATCHED_DESCENDANT) == MATCHED || fNoMatchDepth[i] &gt; 0) {
225                 fNoMatchDepth[i]++;
226                 continue;
227             }
228             if((fMatched[i] &amp; MATCHED_DESCENDANT) == MATCHED_DESCENDANT) {
229                 fMatched[i] = MATCHED_DESCENDANT_PREVIOUS;
230             }
231 
232             if (DEBUG_STACK) {
233                 System.out.println(toString()+&quot;: &quot;+fStepIndexes[i]);
234             }
235 
236             // consume self::node() steps
237             XPath.Step[] steps = fLocationPaths[i].steps;
238             while (fCurrentStep[i] &lt; steps.length &amp;&amp;
</pre>
<hr />
<pre>
267             boolean sawDescendant = fCurrentStep[i] &gt; descendantStep;
268             if (fCurrentStep[i] == steps.length) {
269                 if (DEBUG_MATCH) {
270                     System.out.println(toString()+&quot; XPath DIDN&#39;T MATCH!&quot;);
271                 }
272                 fNoMatchDepth[i]++;
273                 if (DEBUG_MATCH) {
274                     System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);
275                 }
276                 continue;
277             }
278 
279             // match child::... step, if haven&#39;t consumed any self::node()
280             if ((fCurrentStep[i] == startStep || fCurrentStep[i] &gt; descendantStep) &amp;&amp;
281                 steps[fCurrentStep[i]].axis.type == XPath.Axis.CHILD) {
282                 XPath.Step step = steps[fCurrentStep[i]];
283                 XPath.NodeTest nodeTest = step.nodeTest;
284                 if (DEBUG_MATCH) {
285                     System.out.println(toString()+&quot; [CHILD] before&quot;);
286                 }
<span class="line-modified">287                 if (nodeTest.type == XPath.NodeTest.QNAME) {</span>
<span class="line-modified">288                     if (!nodeTest.name.equals(element)) {</span>
<span class="line-modified">289                         if(fCurrentStep[i] &gt; descendantStep) {</span>
<span class="line-removed">290                             fCurrentStep[i] = descendantStep;</span>
<span class="line-removed">291                             continue;</span>
<span class="line-removed">292                         }</span>
<span class="line-removed">293                         fNoMatchDepth[i]++;</span>
<span class="line-removed">294                         if (DEBUG_MATCH) {</span>
<span class="line-removed">295                             System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);</span>
<span class="line-removed">296                         }</span>
297                         continue;
298                     }





299                 }
300                 fCurrentStep[i]++;
301                 if (DEBUG_MATCH) {
302                     System.out.println(toString()+&quot; [CHILD] after MATCHED!&quot;);
303                 }
304             }
305             if (fCurrentStep[i] == steps.length) {
<span class="line-modified">306                 if(sawDescendant) {</span>
307                     fCurrentStep[i] = descendantStep;
308                     fMatched[i] = MATCHED_DESCENDANT;
<span class="line-modified">309                 } else {</span>

310                     fMatched[i] = MATCHED;
311                 }
312                 continue;
313             }
314 
315             // match attribute::... step
316             if (fCurrentStep[i] &lt; steps.length &amp;&amp;
317                 steps[fCurrentStep[i]].axis.type == XPath.Axis.ATTRIBUTE) {
318                 if (DEBUG_MATCH) {
319                     System.out.println(toString()+&quot; [ATTRIBUTE] before&quot;);
320                 }
321                 int attrCount = attributes.getLength();
322                 if (attrCount &gt; 0) {
323                     XPath.NodeTest nodeTest = steps[fCurrentStep[i]].nodeTest;
324 
325                     for (int aIndex = 0; aIndex &lt; attrCount; aIndex++) {
326                         attributes.getName(aIndex, fQName);
<span class="line-modified">327                         if (nodeTest.type != XPath.NodeTest.QNAME ||</span>
<span class="line-removed">328                             nodeTest.name.equals(fQName)) {</span>
329                             fCurrentStep[i]++;
330                             if (fCurrentStep[i] == steps.length) {
331                                 fMatched[i] = MATCHED_ATTRIBUTE;
332                                 int j=0;
333                                 for(; j&lt;i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);
334                                 if(j==i) {
335                                     AttributePSVI attrPSVI = (AttributePSVI)attributes.
336                                             getAugmentations(aIndex).getItem(Constants.ATTRIBUTE_PSVI);
337                                     fMatchedString = attrPSVI.getSchemaValue().getActualValue();
338                                     matched(fMatchedString, attrPSVI.getSchemaValue().getActualValueType(),
339                                             attrPSVI.getSchemaValue().getListValueTypes(), false);
340                                 }
341                             }
342                             break;
343                         }
344                     }
345                 }
346                 if ((fMatched[i] &amp; MATCHED) != MATCHED) {
347                     if(fCurrentStep[i] &gt; descendantStep) {
348                         fCurrentStep[i] = descendantStep;
</pre>
<hr />
<pre>
367        * @param element
368        *        name of the element.
369        * @param type
370        *        content type of this element. IOW, the XML schema type
371        *        of the &lt;tt&gt;value&lt;/tt&gt;. Note that this may not be the type declared
372        *        in the element declaration, but it is &quot;the actual type&quot;. For example,
373        *        if the XML is &amp;lt;foo xsi:type=&quot;xs:string&quot;&gt;aaa&amp;lt;/foo&gt;, this
374        *        parameter will be &quot;xs:string&quot;.
375        * @param nillable - nillable
376        *        true if the element declaration is nillable.
377        * @param value - actual value
378        *        the typed value of the content of this element.
379        */
380     public void endElement(QName element, XSTypeDefinition type, boolean nillable,
381             Object value, short valueType, ShortList itemValueType) {
382         if (DEBUG_METHODS2) {
383             System.out.println(toString()+&quot;#endElement(&quot;+
384                                &quot;element={&quot;+element+&quot;},&quot;+
385                                &quot;)&quot;);
386         }
<span class="line-modified">387         for(int i = 0; i&lt;fLocationPaths.length; i++) {</span>
388             // go back a step
389             fCurrentStep[i] = fStepIndexes[i].pop();
390 
391             // don&#39;t do anything, if not matching
392             if (fNoMatchDepth[i] &gt; 0) {
393                 fNoMatchDepth[i]--;
394             }
395 
396             // signal match, if appropriate
397             else {
<span class="line-modified">398                 int j=0;</span>
<span class="line-modified">399                 for(; j&lt;i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);</span>
<span class="line-modified">400                 if ((j&lt;i) || (fMatched[j] == 0) ||</span>
<span class="line-modified">401                         ((fMatched[j] &amp; MATCHED_ATTRIBUTE) == MATCHED_ATTRIBUTE)) {</span>



402                     continue;
403                 }
404                 // only certain kinds of matchers actually
405                 // match element content.  This permits
406                 // them a way to override this to do nothing
407                 // and hopefully save a few operations.
408                 handleContent(type, nillable, value, valueType, itemValueType);
409                 fMatched[i] = 0;
410             }
411 
412             if (DEBUG_STACK) {
413                 System.out.println(toString()+&quot;: &quot;+fStepIndexes[i]);
414             }
415         }
416 
417     } // endElement(QName)
418 
419     //
420     // Object methods
421     //
</pre>
<hr />
<pre>
459 
460     /** Normalizes text. */
461     private String normalize(String s) {
462         StringBuffer str = new StringBuffer();
463         int length = s.length();
464         for (int i = 0; i &lt; length; i++) {
465             char c = s.charAt(i);
466             switch (c) {
467                 case &#39;\n&#39;: {
468                     str.append(&quot;\\n&quot;);
469                     break;
470                 }
471                 default: {
472                     str.append(c);
473                 }
474             }
475         }
476         return str.toString();
477     } // normalize(String):String
478 












479     //
480     // MAIN
481     //
482 
483     // NOTE: The main of this class is here for debugging purposes.
484     //       However, javac (JDK 1.1.8) has an internal compiler
485     //       error when compiling. Jikes has no problem, though.
486     //
487     //       If you want to use this main, use Jikes to compile but
488     //       *never* check in this code to CVS without commenting it
489     //       out. -Ac
490 
491     /** Main program. */
492     /***
493     public static void main(String[] argv) throws XNIException {
494 
495         if (DEBUG_ANY) {
496             for (int i = 0; i &lt; argv.length; i++) {
497                 final String expr = argv[i];
498                 final XPath xpath = new XPath(expr, symbols, null);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 
 21 package com.sun.org.apache.xerces.internal.impl.xs.identity;
 22 
 23 import com.sun.org.apache.xerces.internal.impl.Constants;
 24 import com.sun.org.apache.xerces.internal.impl.xpath.XPath;
 25 import com.sun.org.apache.xerces.internal.util.IntStack;
 26 import com.sun.org.apache.xerces.internal.xni.QName;
 27 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
 28 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
 29 import com.sun.org.apache.xerces.internal.xs.ShortList;
 30 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
 31 import org.xml.sax.SAXException;
 32 
 33 
 34 /**
 35  * XPath matcher.
 36  *
 37  * @xerces.internal
 38  *
 39  * @author Andy Clark, IBM
<span class="line-added"> 40  * @LastModified: July 2019</span>
 41  *
 42  */
 43 public class XPathMatcher {
 44 
 45     //
 46     // Constants
 47     //
 48 
 49     // debugging
 50 
 51     /** Compile to true to debug everything. */
 52     protected static final boolean DEBUG_ALL = false;
 53 
 54     /** Compile to true to debug method callbacks. */
 55     protected static final boolean DEBUG_METHODS = false || DEBUG_ALL;
 56 
 57     /** Compile to true to debug important method callbacks. */
 58     protected static final boolean DEBUG_METHODS2 = false || DEBUG_METHODS || DEBUG_ALL;
 59 
 60     /** Compile to true to debug the &lt;em&gt;really&lt;/em&gt; important methods. */
</pre>
<hr />
<pre>
 72                                                DEBUG_METHODS3 ||
 73                                                DEBUG_MATCH ||
 74                                                DEBUG_STACK;
 75 
 76     // constants describing whether a match was made,
 77     // and if so how.
 78     // matched any way
 79     protected static final int MATCHED = 1;
 80     // matched on the attribute axis
 81     protected static final int MATCHED_ATTRIBUTE = 3;
 82     // matched on the descendant-or-self axixs
 83     protected static final int MATCHED_DESCENDANT = 5;
 84     // matched some previous (ancestor) node on the descendant-or-self-axis, but not this node
 85     protected static final int MATCHED_DESCENDANT_PREVIOUS = 13;
 86 
 87     //
 88     // Data
 89     //
 90 
 91     /** XPath location path. */
<span class="line-modified"> 92     private final XPath.LocationPath[] fLocationPaths;</span>
 93 
 94     /** True if XPath has been matched. */
<span class="line-modified"> 95     private final int[] fMatched;</span>
 96 
 97     /** The matching string. */
 98     protected Object fMatchedString;
 99 
100     /** Integer stack of step indexes. */
<span class="line-modified">101     private final IntStack[] fStepIndexes;</span>
102 
103     /** Current step. */
<span class="line-modified">104     private final int[] fCurrentStep;</span>
105 
106     /**
107      * No match depth. The value of this field will be zero while
108      * matching is successful for the given xpath expression.
109      */
<span class="line-modified">110     private final int [] fNoMatchDepth;</span>
111 
112     final QName fQName = new QName();
113 
114 
115     //
116     // Constructors
117     //
118 
119     /**
120      * Constructs an XPath matcher that implements a document fragment
121      * handler.
122      *
123      * @param xpath   The xpath.
124      */
125     public XPathMatcher(XPath xpath) {
126         fLocationPaths = xpath.getLocationPaths();
127         fStepIndexes = new IntStack[fLocationPaths.length];
128         for(int i=0; i&lt;fStepIndexes.length; i++) fStepIndexes[i] = new IntStack();
129         fCurrentStep = new int[fLocationPaths.length];
130         fNoMatchDepth = new int[fLocationPaths.length];
</pre>
<hr />
<pre>
191         for(int i = 0; i &lt; fLocationPaths.length; i++) {
192             fStepIndexes[i].clear();
193             fCurrentStep[i] = 0;
194             fNoMatchDepth[i] = 0;
195             fMatched[i] = 0;
196         }
197 
198 
199     } // startDocumentFragment()
200 
201     /**
202      * The start of an element. If the document specifies the start element
203      * by using an empty tag, then the startElement method will immediately
204      * be followed by the endElement method, with no intervening methods.
205      *
206      * @param element    The name of the element.
207      * @param attributes The element attributes.
208      *
209      * @throws SAXException Thrown by handler to signal an error.
210      */
<span class="line-modified">211     public void startElement(QName element, XMLAttributes attributes) {</span>
212         if (DEBUG_METHODS2) {
213             System.out.println(toString()+&quot;#startElement(&quot;+
214                                &quot;element={&quot;+element+&quot;},&quot;+
215                                &quot;attributes=...&quot;+attributes+
216                                &quot;)&quot;);
217         }
218 
<span class="line-modified">219         for (int i = 0; i &lt; fLocationPaths.length; i++) {</span>
220             // push context
221             int startStep = fCurrentStep[i];
222             fStepIndexes[i].push(startStep);
223 
224             // try next xpath, if not matching
225             if ((fMatched[i] &amp; MATCHED_DESCENDANT) == MATCHED || fNoMatchDepth[i] &gt; 0) {
226                 fNoMatchDepth[i]++;
227                 continue;
228             }
229             if((fMatched[i] &amp; MATCHED_DESCENDANT) == MATCHED_DESCENDANT) {
230                 fMatched[i] = MATCHED_DESCENDANT_PREVIOUS;
231             }
232 
233             if (DEBUG_STACK) {
234                 System.out.println(toString()+&quot;: &quot;+fStepIndexes[i]);
235             }
236 
237             // consume self::node() steps
238             XPath.Step[] steps = fLocationPaths[i].steps;
239             while (fCurrentStep[i] &lt; steps.length &amp;&amp;
</pre>
<hr />
<pre>
268             boolean sawDescendant = fCurrentStep[i] &gt; descendantStep;
269             if (fCurrentStep[i] == steps.length) {
270                 if (DEBUG_MATCH) {
271                     System.out.println(toString()+&quot; XPath DIDN&#39;T MATCH!&quot;);
272                 }
273                 fNoMatchDepth[i]++;
274                 if (DEBUG_MATCH) {
275                     System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);
276                 }
277                 continue;
278             }
279 
280             // match child::... step, if haven&#39;t consumed any self::node()
281             if ((fCurrentStep[i] == startStep || fCurrentStep[i] &gt; descendantStep) &amp;&amp;
282                 steps[fCurrentStep[i]].axis.type == XPath.Axis.CHILD) {
283                 XPath.Step step = steps[fCurrentStep[i]];
284                 XPath.NodeTest nodeTest = step.nodeTest;
285                 if (DEBUG_MATCH) {
286                     System.out.println(toString()+&quot; [CHILD] before&quot;);
287                 }
<span class="line-modified">288                 if (!matches(nodeTest, element)) {</span>
<span class="line-modified">289                     if (fCurrentStep[i] &gt; descendantStep) {</span>
<span class="line-modified">290                         fCurrentStep[i] = descendantStep;</span>







291                         continue;
292                     }
<span class="line-added">293                     fNoMatchDepth[i]++;</span>
<span class="line-added">294                     if (DEBUG_MATCH) {</span>
<span class="line-added">295                         System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);</span>
<span class="line-added">296                     }</span>
<span class="line-added">297                     continue;</span>
298                 }
299                 fCurrentStep[i]++;
300                 if (DEBUG_MATCH) {
301                     System.out.println(toString()+&quot; [CHILD] after MATCHED!&quot;);
302                 }
303             }
304             if (fCurrentStep[i] == steps.length) {
<span class="line-modified">305                 if (sawDescendant) {</span>
306                     fCurrentStep[i] = descendantStep;
307                     fMatched[i] = MATCHED_DESCENDANT;
<span class="line-modified">308                 }</span>
<span class="line-added">309                 else {</span>
310                     fMatched[i] = MATCHED;
311                 }
312                 continue;
313             }
314 
315             // match attribute::... step
316             if (fCurrentStep[i] &lt; steps.length &amp;&amp;
317                 steps[fCurrentStep[i]].axis.type == XPath.Axis.ATTRIBUTE) {
318                 if (DEBUG_MATCH) {
319                     System.out.println(toString()+&quot; [ATTRIBUTE] before&quot;);
320                 }
321                 int attrCount = attributes.getLength();
322                 if (attrCount &gt; 0) {
323                     XPath.NodeTest nodeTest = steps[fCurrentStep[i]].nodeTest;
324 
325                     for (int aIndex = 0; aIndex &lt; attrCount; aIndex++) {
326                         attributes.getName(aIndex, fQName);
<span class="line-modified">327                         if (matches(nodeTest, fQName)) {</span>

328                             fCurrentStep[i]++;
329                             if (fCurrentStep[i] == steps.length) {
330                                 fMatched[i] = MATCHED_ATTRIBUTE;
331                                 int j=0;
332                                 for(; j&lt;i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);
333                                 if(j==i) {
334                                     AttributePSVI attrPSVI = (AttributePSVI)attributes.
335                                             getAugmentations(aIndex).getItem(Constants.ATTRIBUTE_PSVI);
336                                     fMatchedString = attrPSVI.getSchemaValue().getActualValue();
337                                     matched(fMatchedString, attrPSVI.getSchemaValue().getActualValueType(),
338                                             attrPSVI.getSchemaValue().getListValueTypes(), false);
339                                 }
340                             }
341                             break;
342                         }
343                     }
344                 }
345                 if ((fMatched[i] &amp; MATCHED) != MATCHED) {
346                     if(fCurrentStep[i] &gt; descendantStep) {
347                         fCurrentStep[i] = descendantStep;
</pre>
<hr />
<pre>
366        * @param element
367        *        name of the element.
368        * @param type
369        *        content type of this element. IOW, the XML schema type
370        *        of the &lt;tt&gt;value&lt;/tt&gt;. Note that this may not be the type declared
371        *        in the element declaration, but it is &quot;the actual type&quot;. For example,
372        *        if the XML is &amp;lt;foo xsi:type=&quot;xs:string&quot;&gt;aaa&amp;lt;/foo&gt;, this
373        *        parameter will be &quot;xs:string&quot;.
374        * @param nillable - nillable
375        *        true if the element declaration is nillable.
376        * @param value - actual value
377        *        the typed value of the content of this element.
378        */
379     public void endElement(QName element, XSTypeDefinition type, boolean nillable,
380             Object value, short valueType, ShortList itemValueType) {
381         if (DEBUG_METHODS2) {
382             System.out.println(toString()+&quot;#endElement(&quot;+
383                                &quot;element={&quot;+element+&quot;},&quot;+
384                                &quot;)&quot;);
385         }
<span class="line-modified">386         for (int i = 0; i &lt; fLocationPaths.length; i++) {</span>
387             // go back a step
388             fCurrentStep[i] = fStepIndexes[i].pop();
389 
390             // don&#39;t do anything, if not matching
391             if (fNoMatchDepth[i] &gt; 0) {
392                 fNoMatchDepth[i]--;
393             }
394 
395             // signal match, if appropriate
396             else {
<span class="line-modified">397                 int j = 0;</span>
<span class="line-modified">398                 for(; j &lt; i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);</span>
<span class="line-modified">399                 if ((j &lt; i) || (fMatched[j] == 0)) {</span>
<span class="line-modified">400                     continue;</span>
<span class="line-added">401                 }</span>
<span class="line-added">402                 if ((fMatched[j] &amp; MATCHED_ATTRIBUTE) == MATCHED_ATTRIBUTE) {</span>
<span class="line-added">403                     fMatched[i] = 0;</span>
404                     continue;
405                 }
406                 // only certain kinds of matchers actually
407                 // match element content.  This permits
408                 // them a way to override this to do nothing
409                 // and hopefully save a few operations.
410                 handleContent(type, nillable, value, valueType, itemValueType);
411                 fMatched[i] = 0;
412             }
413 
414             if (DEBUG_STACK) {
415                 System.out.println(toString()+&quot;: &quot;+fStepIndexes[i]);
416             }
417         }
418 
419     } // endElement(QName)
420 
421     //
422     // Object methods
423     //
</pre>
<hr />
<pre>
461 
462     /** Normalizes text. */
463     private String normalize(String s) {
464         StringBuffer str = new StringBuffer();
465         int length = s.length();
466         for (int i = 0; i &lt; length; i++) {
467             char c = s.charAt(i);
468             switch (c) {
469                 case &#39;\n&#39;: {
470                     str.append(&quot;\\n&quot;);
471                     break;
472                 }
473                 default: {
474                     str.append(c);
475                 }
476             }
477         }
478         return str.toString();
479     } // normalize(String):String
480 
<span class="line-added">481     /** Returns true if the given QName matches the node test. **/</span>
<span class="line-added">482     private static boolean matches(XPath.NodeTest nodeTest, QName value) {</span>
<span class="line-added">483         if (nodeTest.type == XPath.NodeTest.QNAME) {</span>
<span class="line-added">484             return nodeTest.name.equals(value);</span>
<span class="line-added">485         }</span>
<span class="line-added">486         if (nodeTest.type == XPath.NodeTest.NAMESPACE) {</span>
<span class="line-added">487             return nodeTest.name.uri == value.uri;</span>
<span class="line-added">488         }</span>
<span class="line-added">489         // XPath.NodeTest.WILDCARD</span>
<span class="line-added">490         return true;</span>
<span class="line-added">491     } // matches(XPath.NodeTest,QName):boolean</span>
<span class="line-added">492 </span>
493     //
494     // MAIN
495     //
496 
497     // NOTE: The main of this class is here for debugging purposes.
498     //       However, javac (JDK 1.1.8) has an internal compiler
499     //       error when compiling. Jikes has no problem, though.
500     //
501     //       If you want to use this main, use Jikes to compile but
502     //       *never* check in this code to CVS without commenting it
503     //       out. -Ac
504 
505     /** Main program. */
506     /***
507     public static void main(String[] argv) throws XNIException {
508 
509         if (DEBUG_ANY) {
510             for (int i = 0; i &lt; argv.length; i++) {
511                 final String expr = argv[i];
512                 final XPath xpath = new XPath(expr, symbols, null);
</pre>
</td>
</tr>
</table>
<center><a href="../XMLSchemaValidator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../traversers/XSDAbstractTraverser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
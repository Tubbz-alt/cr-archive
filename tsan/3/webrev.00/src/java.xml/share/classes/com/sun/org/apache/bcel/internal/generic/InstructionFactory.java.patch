diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -20,64 +20,64 @@
 package com.sun.org.apache.bcel.internal.generic;
 
 import com.sun.org.apache.bcel.internal.Const;
 
 /**
- * Instances of this class may be used, e.g., to generate typed versions of
- * instructions. Its main purpose is to be used as the byte code generating
- * backend of a compiler. You can subclass it to add your own create methods.
+ * Instances of this class may be used, e.g., to generate typed
+ * versions of instructions. Its main purpose is to be used as the
+ * byte code generating backend of a compiler. You can subclass it to
+ * add your own create methods.
  * <p>
- * Note: The static createXXX methods return singleton instances from the
- * {@link InstructionConst} class.
+ * Note: The static createXXX methods return singleton instances
+ * from the {@link InstructionConst} class.
  *
- * @version $Id: InstructionFactory.java 1749603 2016-06-21 20:50:19Z ggregory $
  * @see Const
  * @see InstructionConst
- * @LastModified: Nov 2017
+ * @LastModified: Jan 2020
  */
 public class InstructionFactory {
 
     // N.N. These must agree with the order of Constants.T_CHAR through T_LONG
     private static final String[] short_names = {
-        "C", "F", "D", "B", "S", "I", "L"
+            "C", "F", "D", "B", "S", "I", "L"
     };
 
     private ClassGen cg;
     private ConstantPoolGen cp;
 
     public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {
         this.cg = cg;
         this.cp = cp;
     }
 
-    /**
-     * Initialize with ClassGen object
+
+    /** Initialize with ClassGen object
      */
     public InstructionFactory(final ClassGen cg) {
         this(cg, cg.getConstantPool());
     }
 
-    /**
-     * Initialize just with ConstantPoolGen object
+
+    /** Initialize just with ConstantPoolGen object
      */
     public InstructionFactory(final ConstantPoolGen cp) {
         this(null, cp);
     }
 
-    /**
-     * Create an invoke instruction. (Except for invokedynamic.)
+
+    /** Create an invoke instruction. (Except for invokedynamic.)
      *
      * @param class_name name of the called class
      * @param name name of the called method
      * @param ret_type return type of method
      * @param arg_types argument types of method
-     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC,
-     * INVOKEVIRTUAL, or INVOKESPECIAL
+     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,
+     * or INVOKESPECIAL
      * @see Const
      */
-    public InvokeInstruction createInvoke(final String class_name, final String name, final Type ret_type,
-            final Type[] arg_types, final short kind) {
+    public InvokeInstruction createInvoke( final String class_name, final String name,
+            final Type ret_type, final Type[] arg_types, final short kind ) {
         int index;
         int nargs = 0;
         final String signature = Type.getMethodSignature(ret_type, arg_types);
         for (final Type arg_type : arg_types) {
             nargs += arg_type.getSize();
@@ -101,58 +101,56 @@
             default:
                 throw new RuntimeException("Oops: Unknown invoke kind: " + kind);
         }
     }
 
-    /**
-     * Create an invokedynamic instruction.
+    /** Create an invokedynamic instruction.
      *
      * @param bootstrap_index index into the bootstrap_methods array
      * @param name name of the called method
      * @param ret_type return type of method
      * @param arg_types argument types of method
      * @see Constants
      */
-    /*
-     * createInvokeDynamic only needed if instrumention code wants to generate
-     * a new invokedynamic instruction.  I don't think we need.  (markro)
-     *
-     public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,
-     Type[] arg_types) {
-     int index;
-     int nargs = 0;
-     String signature = Type.getMethodSignature(ret_type, arg_types);
-     for (int i = 0; i < arg_types.length; i++) {
-     nargs += arg_types[i].getSize();
-     }
-     // UNDONE - needs to be added to ConstantPoolGen
-     //index = cp.addInvokeDynamic(bootstrap_index, name, signature);
-     index = 0;
-     return new INVOKEDYNAMIC(index);
-     }
-     */
-    /**
-     * Create a call to the most popular System.out.println() method.
+/*
+ * createInvokeDynamic only needed if instrumention code wants to generate
+ * a new invokedynamic instruction.  I don't think we need.  (markro)
+ *
+    public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,
+            Type[] arg_types) {
+        int index;
+        int nargs = 0;
+        String signature = Type.getMethodSignature(ret_type, arg_types);
+        for (int i = 0; i < arg_types.length; i++) {
+            nargs += arg_types[i].getSize();
+        }
+        // UNDONE - needs to be added to ConstantPoolGen
+        //index = cp.addInvokeDynamic(bootstrap_index, name, signature);
+        index = 0;
+        return new INVOKEDYNAMIC(index);
+    }
+ */
+
+    /** Create a call to the most popular System.out.println() method.
      *
      * @param s the string to print
      */
-    public InstructionList createPrintln(final String s) {
+    public InstructionList createPrintln( final String s ) {
         final InstructionList il = new InstructionList();
         final int out = cp.addFieldref("java.lang.System", "out", "Ljava/io/PrintStream;");
         final int println = cp.addMethodref("java.io.PrintStream", "println", "(Ljava/lang/String;)V");
         il.append(new GETSTATIC(out));
         il.append(new PUSH(cp, s));
         il.append(new INVOKEVIRTUAL(println));
         return il;
     }
 
-    /**
-     * Uses PUSH to push a constant value onto the stack.
-     *
+
+    /** Uses PUSH to push a constant value onto the stack.
      * @param value must be of type Number, Boolean, Character or String
      */
-    public Instruction createConstant(final Object value) {
+    public Instruction createConstant( final Object value ) {
         PUSH push;
         if (value instanceof Number) {
             push = new PUSH(cp, (Number) value);
         } else if (value instanceof String) {
             push = new PUSH(cp, (String) value);
@@ -171,65 +169,69 @@
         final Type[] arg_types;
         final Type result_type;
         final String class_name;
         final String name;
 
+
         MethodObject(final String c, final String n, final Type r, final Type[] a) {
             class_name = c;
             name = n;
             result_type = r;
             arg_types = a;
         }
     }
 
-    private InvokeInstruction createInvoke(final MethodObject m, final short kind) {
+
+    private InvokeInstruction createInvoke( final MethodObject m, final short kind ) {
         return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);
     }
 
     private static final MethodObject[] append_mos = {
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.STRING
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.OBJECT
-        }),
-        null,
-        null, // indices 2, 3
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.BOOLEAN
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.CHAR
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.FLOAT
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.DOUBLE
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.INT
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, // No append(byte)
-        new Type[]{
-            Type.INT
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, // No append(short)
-        new Type[]{
-            Type.INT
-        }),
-        new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[]{
-            Type.LONG
-        })
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.STRING
+            }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.OBJECT
+            }),
+            null,
+            null, // indices 2, 3
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.BOOLEAN
+            }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.CHAR
+            }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.FLOAT
+            }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.DOUBLE
+            }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.INT
+            }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, // No append(byte)
+                    new Type[] {
+                        Type.INT
+                    }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, // No append(short)
+                    new Type[] {
+                        Type.INT
+                    }),
+            new MethodObject("java.lang.StringBuffer", "append", Type.STRINGBUFFER, new Type[] {
+                Type.LONG
+            })
     };
 
-    private static boolean isString(final Type type) {
-        return (type instanceof ObjectType)
-                && ((ObjectType) type).getClassName().equals("java.lang.String");
+
+    private static boolean isString( final Type type ) {
+        return (type instanceof ObjectType) &&
+              ((ObjectType) type).getClassName().equals("java.lang.String");
     }
 
-    public Instruction createAppend(final Type type) {
+
+    public Instruction createAppend( final Type type ) {
         final byte t = type.getType();
         if (isString(type)) {
             return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);
         }
         switch (t) {
@@ -248,20 +250,21 @@
             default:
                 throw new RuntimeException("Oops: No append for this type? " + type);
         }
     }
 
-    /**
-     * Create a field instruction.
+
+    /** Create a field instruction.
      *
      * @param class_name name of the accessed class
      * @param name name of the referenced field
-     * @param type type of field
+     * @param type  type of field
      * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC
      * @see Const
      */
-    public FieldInstruction createFieldAccess(final String class_name, final String name, final Type type, final short kind) {
+    public FieldInstruction createFieldAccess( final String class_name,
+            final String name, final Type type, final short kind ) {
         int index;
         final String signature = type.getSignature();
         index = cp.addFieldref(class_name, name, signature);
         switch (kind) {
             case Const.GETFIELD:
@@ -275,21 +278,21 @@
             default:
                 throw new RuntimeException("Oops: Unknown getfield kind:" + kind);
         }
     }
 
-    /**
-     * Create reference to `this'
+
+    /** Create reference to `this'
      */
     public static Instruction createThis() {
         return new ALOAD(0);
     }
 
-    /**
-     * Create typed return
+
+    /** Create typed return
      */
-    public static ReturnInstruction createReturn(final Type type) {
+    public static ReturnInstruction createReturn( final Type type ) {
         switch (type.getType()) {
             case Const.T_ARRAY:
             case Const.T_OBJECT:
                 return InstructionConst.ARETURN;
             case Const.T_INT:
@@ -309,11 +312,12 @@
             default:
                 throw new RuntimeException("Invalid type: " + type);
         }
     }
 
-    private static ArithmeticInstruction createBinaryIntOp(final char first, final String op) {
+
+    private static ArithmeticInstruction createBinaryIntOp( final char first, final String op ) {
         switch (first) {
             case '-':
                 return InstructionConst.ISUB;
             case '+':
                 return InstructionConst.IADD;
@@ -336,11 +340,12 @@
             default:
                 throw new RuntimeException("Invalid operand " + op);
         }
     }
 
-    private static ArithmeticInstruction createBinaryLongOp(final char first, final String op) {
+
+    private static ArithmeticInstruction createBinaryLongOp( final char first, final String op ) {
         switch (first) {
             case '-':
                 return InstructionConst.LSUB;
             case '+':
                 return InstructionConst.LADD;
@@ -363,11 +368,12 @@
             default:
                 throw new RuntimeException("Invalid operand " + op);
         }
     }
 
-    private static ArithmeticInstruction createBinaryFloatOp(final char op) {
+
+    private static ArithmeticInstruction createBinaryFloatOp( final char op ) {
         switch (op) {
             case '-':
                 return InstructionConst.FSUB;
             case '+':
                 return InstructionConst.FADD;
@@ -380,11 +386,12 @@
             default:
                 throw new RuntimeException("Invalid operand " + op);
         }
     }
 
-    private static ArithmeticInstruction createBinaryDoubleOp(final char op) {
+
+    private static ArithmeticInstruction createBinaryDoubleOp( final char op ) {
         switch (op) {
             case '-':
                 return InstructionConst.DSUB;
             case '+':
                 return InstructionConst.DADD;
@@ -397,16 +404,17 @@
             default:
                 throw new RuntimeException("Invalid operand " + op);
         }
     }
 
+
     /**
      * Create binary operation for simple basic types, such as int and float.
      *
      * @param op operation, such as "+", "*", "&lt;&lt;", etc.
      */
-    public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {
+    public static ArithmeticInstruction createBinaryOperation( final String op, final Type type ) {
         final char first = op.charAt(0);
         switch (type.getType()) {
             case Const.T_BYTE:
             case Const.T_SHORT:
             case Const.T_INT:
@@ -421,42 +429,47 @@
             default:
                 throw new RuntimeException("Invalid type " + type);
         }
     }
 
+
     /**
      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
      */
-    public static StackInstruction createPop(final int size) {
+    public static StackInstruction createPop( final int size ) {
         return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;
     }
 
+
     /**
      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
      */
-    public static StackInstruction createDup(final int size) {
+    public static StackInstruction createDup( final int size ) {
         return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;
     }
 
+
     /**
      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
      */
-    public static StackInstruction createDup_2(final int size) {
+    public static StackInstruction createDup_2( final int size ) {
         return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;
     }
 
+
     /**
      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
      */
-    public static StackInstruction createDup_1(final int size) {
+    public static StackInstruction createDup_1( final int size ) {
         return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;
     }
 
+
     /**
      * @param index index of local variable
      */
-    public static LocalVariableInstruction createStore(final Type type, final int index) {
+    public static LocalVariableInstruction createStore( final Type type, final int index ) {
         switch (type.getType()) {
             case Const.T_BOOLEAN:
             case Const.T_CHAR:
             case Const.T_BYTE:
             case Const.T_SHORT:
@@ -474,14 +487,15 @@
             default:
                 throw new RuntimeException("Invalid type " + type);
         }
     }
 
+
     /**
      * @param index index of local variable
      */
-    public static LocalVariableInstruction createLoad(final Type type, final int index) {
+    public static LocalVariableInstruction createLoad( final Type type, final int index ) {
         switch (type.getType()) {
             case Const.T_BOOLEAN:
             case Const.T_CHAR:
             case Const.T_BYTE:
             case Const.T_SHORT:
@@ -499,14 +513,15 @@
             default:
                 throw new RuntimeException("Invalid type " + type);
         }
     }
 
+
     /**
      * @param type type of elements of array, i.e., array.getElementType()
      */
-    public static ArrayInstruction createArrayLoad(final Type type) {
+    public static ArrayInstruction createArrayLoad( final Type type ) {
         switch (type.getType()) {
             case Const.T_BOOLEAN:
             case Const.T_BYTE:
                 return InstructionConst.BALOAD;
             case Const.T_CHAR:
@@ -527,14 +542,15 @@
             default:
                 throw new RuntimeException("Invalid type " + type);
         }
     }
 
+
     /**
      * @param type type of elements of array, i.e., array.getElementType()
      */
-    public static ArrayInstruction createArrayStore(final Type type) {
+    public static ArrayInstruction createArrayStore( final Type type ) {
         switch (type.getType()) {
             case Const.T_BOOLEAN:
             case Const.T_BYTE:
                 return InstructionConst.BASTORE;
             case Const.T_CHAR:
@@ -560,11 +576,11 @@
     /**
      * Create conversion operation for two stack operands, this may be an I2C,
      * instruction, e.g., if the operands are basic types and CHECKCAST if they
      * are reference types.
      */
-    public Instruction createCast(final Type src_type, final Type dest_type) {
+    public Instruction createCast( final Type src_type, final Type dest_type ) {
         if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {
             final byte dest = dest_type.getType();
             byte src = src_type.getType();
             if (dest == Const.T_LONG
                     && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
@@ -587,55 +603,63 @@
         } else {
             throw new RuntimeException("Can not cast " + src_type + " to " + dest_type);
         }
     }
 
-    public GETFIELD createGetField(final String class_name, final String name, final Type t) {
+
+    public GETFIELD createGetField( final String class_name, final String name, final Type t ) {
         return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));
     }
 
-    public GETSTATIC createGetStatic(final String class_name, final String name, final Type t) {
+
+    public GETSTATIC createGetStatic( final String class_name, final String name, final Type t ) {
         return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
     }
 
-    public PUTFIELD createPutField(final String class_name, final String name, final Type t) {
+
+    public PUTFIELD createPutField( final String class_name, final String name, final Type t ) {
         return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));
     }
 
-    public PUTSTATIC createPutStatic(final String class_name, final String name, final Type t) {
+
+    public PUTSTATIC createPutStatic( final String class_name, final String name, final Type t ) {
         return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
     }
 
-    public CHECKCAST createCheckCast(final ReferenceType t) {
+
+    public CHECKCAST createCheckCast( final ReferenceType t ) {
         if (t instanceof ArrayType) {
             return new CHECKCAST(cp.addArrayClass((ArrayType) t));
         }
         return new CHECKCAST(cp.addClass((ObjectType) t));
     }
 
-    public INSTANCEOF createInstanceOf(final ReferenceType t) {
+
+    public INSTANCEOF createInstanceOf( final ReferenceType t ) {
         if (t instanceof ArrayType) {
             return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
         }
         return new INSTANCEOF(cp.addClass((ObjectType) t));
     }
 
-    public NEW createNew(final ObjectType t) {
+
+    public NEW createNew( final ObjectType t ) {
         return new NEW(cp.addClass(t));
     }
 
-    public NEW createNew(final String s) {
+
+    public NEW createNew( final String s ) {
         return createNew(ObjectType.getInstance(s));
     }
 
     /**
      * Create new array of given size and type.
      *
      * @return an instruction that creates the corresponding array at runtime,
      * i.e. is an AllocationInstruction
      */
-    public Instruction createNewArray(final Type t, final short dim) {
+    public Instruction createNewArray( final Type t, final short dim ) {
         if (dim == 1) {
             if (t instanceof ObjectType) {
                 return new ANEWARRAY(cp.addClass((ObjectType) t));
             } else if (t instanceof ArrayType) {
                 return new ANEWARRAY(cp.addArrayClass((ArrayType) t));
@@ -653,11 +677,11 @@
     }
 
     /**
      * Create "null" value for reference types, 0 for basic types like int
      */
-    public static Instruction createNull(final Type type) {
+    public static Instruction createNull( final Type type ) {
         switch (type.getType()) {
             case Const.T_ARRAY:
             case Const.T_OBJECT:
                 return InstructionConst.ACONST_NULL;
             case Const.T_INT:
@@ -681,11 +705,12 @@
 
     /**
      * Create branch instruction by given opcode, except LOOKUPSWITCH and
      * TABLESWITCH. For those you should use the SWITCH compound instruction.
      */
-    public static BranchInstruction createBranchInstruction(final short opcode, final InstructionHandle target) {
+    public static BranchInstruction createBranchInstruction( final short opcode,
+            final InstructionHandle target ) {
         switch (opcode) {
             case Const.IFEQ:
                 return new IFEQ(target);
             case Const.IFNE:
                 return new IFNE(target);
@@ -728,21 +753,25 @@
             default:
                 throw new RuntimeException("Invalid opcode: " + opcode);
         }
     }
 
-    public void setClassGen(final ClassGen c) {
+
+    public void setClassGen( final ClassGen c ) {
         cg = c;
     }
 
+
     public ClassGen getClassGen() {
         return cg;
     }
 
-    public void setConstantPool(final ConstantPoolGen c) {
+
+    public void setConstantPool( final ConstantPoolGen c ) {
         cp = c;
     }
 
+
     public ConstantPoolGen getConstantPool() {
         return cp;
     }
 }

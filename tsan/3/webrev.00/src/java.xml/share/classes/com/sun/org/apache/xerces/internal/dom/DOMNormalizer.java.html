<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMNormalizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 
  24 
  25 import com.sun.org.apache.xerces.internal.impl.Constants;
  26 import com.sun.org.apache.xerces.internal.impl.RevalidationHandler;
  27 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDLoader;
  28 import com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator;
  29 import com.sun.org.apache.xerces.internal.impl.dv.XSSimpleType;
  30 import com.sun.org.apache.xerces.internal.impl.xs.util.SimpleLocator;
  31 import com.sun.org.apache.xerces.internal.util.AugmentationsImpl;
  32 import com.sun.org.apache.xerces.internal.util.NamespaceSupport;
  33 import com.sun.org.apache.xerces.internal.util.SymbolTable;
  34 import com.sun.org.apache.xerces.internal.util.XML11Char;
  35 import com.sun.org.apache.xerces.internal.util.XMLChar;
  36 import com.sun.org.apache.xerces.internal.util.XMLSymbols;
  37 import com.sun.org.apache.xerces.internal.xni.Augmentations;
  38 import com.sun.org.apache.xerces.internal.xni.NamespaceContext;
  39 import com.sun.org.apache.xerces.internal.xni.QName;
  40 import com.sun.org.apache.xerces.internal.xni.XMLAttributes;
  41 import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
  42 import com.sun.org.apache.xerces.internal.xni.XMLLocator;
  43 import com.sun.org.apache.xerces.internal.xni.XMLResourceIdentifier;
  44 import com.sun.org.apache.xerces.internal.xni.XMLString;
  45 import com.sun.org.apache.xerces.internal.xni.XNIException;
  46 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarDescription;
  47 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
  48 import com.sun.org.apache.xerces.internal.xni.parser.XMLDocumentSource;
  49 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
  50 import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
  51 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
  52 import java.io.IOException;
  53 import java.util.ArrayList;
  54 import java.util.List;
  55 import java.util.Vector;
  56 import org.w3c.dom.Attr;
  57 import org.w3c.dom.Comment;
  58 import org.w3c.dom.DOMError;
  59 import org.w3c.dom.DOMErrorHandler;
  60 import org.w3c.dom.Document;
  61 import org.w3c.dom.DocumentType;
  62 import org.w3c.dom.Element;
  63 import org.w3c.dom.Entity;
  64 import org.w3c.dom.NamedNodeMap;
  65 import org.w3c.dom.Node;
  66 import org.w3c.dom.NodeList;
  67 import org.w3c.dom.ProcessingInstruction;
  68 import org.w3c.dom.Text;
  69 /**
  70  * This class adds implementation for normalizeDocument method.
  71  * It acts as if the document was going through a save and load cycle, putting
  72  * the document in a &quot;normal&quot; form. The actual result depends on the features being set
  73  * and governing what operations actually take place. See setNormalizationFeature for details.
  74  * Noticeably this method normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
  75  * according to the algorithm described below in pseudo code, by adding missing namespace
  76  * declaration attributes and adding or changing namespace prefixes, updates the replacement
  77  * tree of EntityReference nodes, normalizes attribute values, etc.
  78  * Mutation events, when supported, are generated to reflect the changes occuring on the
  79  * document.
  80  * See Namespace normalization for details on how namespace declaration attributes and prefixes
  81  * are normalized.
  82  *
  83  * NOTE: There is an initial support for DOM revalidation with XML Schema as a grammar.
  84  * The tree might not be validated correctly if entityReferences, CDATA sections are
  85  * present in the tree. The PSVI information is not exposed, normalized data (including element
  86  * default content is not available).
  87  *
  88  * @xerces.experimental
  89  *
  90  * @author Elena Litani, IBM
  91  * @author Neeraj Bajaj, Sun Microsystems, inc.
  92  * @LastModified: Apr 2019
  93  */
  94 public class DOMNormalizer implements XMLDocumentHandler {
  95 
  96     //
  97     // constants
  98     //
  99     /** Debug normalize document*/
 100     protected final static boolean DEBUG_ND = false;
 101     /** Debug namespace fix up algorithm*/
 102     protected final static boolean DEBUG = false;
 103     /** Debug document handler events */
 104     protected final static boolean DEBUG_EVENTS = false;
 105 
 106     /** prefix added by namespace fixup algorithm should follow a pattern &quot;NS&quot; + index*/
 107     protected final static String PREFIX = &quot;NS&quot;;
 108 
 109     //
 110     // Data
 111     //
 112     protected DOMConfigurationImpl fConfiguration = null;
 113     protected CoreDocumentImpl fDocument = null;
 114     protected final XMLAttributesProxy fAttrProxy = new XMLAttributesProxy();
 115     protected final QName fQName = new QName();
 116 
 117     /** Validation handler represents validator instance. */
 118     protected RevalidationHandler fValidationHandler;
 119 
 120     /** symbol table */
 121     protected SymbolTable fSymbolTable;
 122     /** error handler. may be null. */
 123     protected DOMErrorHandler fErrorHandler;
 124 
 125     /**
 126      * Cached {@link DOMError} impl.
 127      * The same object is re-used to report multiple errors.
 128      */
 129     private final DOMErrorImpl fError = new DOMErrorImpl();
 130 
 131     // Validation against namespace aware grammar
 132     protected boolean fNamespaceValidation = false;
 133 
 134     // Update PSVI information in the tree
 135     protected boolean fPSVI = false;
 136 
 137     /** The namespace context of this document: stores namespaces in scope */
 138     protected final NamespaceContext fNamespaceContext = new NamespaceSupport();
 139 
 140     /** Stores all namespace bindings on the current element */
 141     protected final NamespaceContext fLocalNSBinder = new NamespaceSupport();
 142 
 143     /** list of attributes */
 144     protected final List&lt;Node&gt; fAttributeList = new ArrayList&lt;&gt;(5);
 145 
 146     /** DOM Locator -  for namespace fixup algorithm */
 147     protected final DOMLocatorImpl fLocator = new DOMLocatorImpl();
 148 
 149     /** for setting the PSVI */
 150     protected Node fCurrentNode = null;
 151     private final QName fAttrQName = new QName();
 152 
 153     // attribute value normalization
 154     final XMLString fNormalizedValue = new XMLString(new char[16], 0, 0);
 155 
 156     //DTD validator
 157     private XMLDTDValidator fDTDValidator;
 158 
 159     /** Empty string to pass to the validator. **/
 160     public static final XMLString EMPTY_STRING = new XMLString();
 161 
 162     // Check if element content is all &quot;ignorable whitespace&quot;
 163     private boolean fAllWhitespace = false;
 164 
 165     // Constructor
 166     //
 167 
 168     public DOMNormalizer(){}
 169 
 170 
 171 
 172     /**
 173      * Normalizes document.
 174      * Note: reset() must be called before this method.
 175      */
 176     protected void normalizeDocument(CoreDocumentImpl document, DOMConfigurationImpl config) {
 177 
 178         fDocument = document;
 179         fConfiguration = config;
 180         fAllWhitespace = false;
 181         fNamespaceValidation = false;
 182 
 183         String xmlVersion = fDocument.getXmlVersion();
 184         String schemaType = null;
 185         String [] schemaLocations = null;
 186 
 187         // intialize and reset DOMNormalizer component
 188         //
 189         fSymbolTable = (SymbolTable) fConfiguration.getProperty(DOMConfigurationImpl.SYMBOL_TABLE);
 190         // reset namespace context
 191         fNamespaceContext.reset();
 192         fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, null);
 193 
 194         if ((fConfiguration.features &amp; DOMConfigurationImpl.VALIDATE) != 0) {
 195             String schemaLang = (String)fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_LANGUAGE);
 196 
 197             if (schemaLang != null &amp;&amp; schemaLang.equals(Constants.NS_XMLSCHEMA)) {
 198                 schemaType = XMLGrammarDescription.XML_SCHEMA;
 199                 fValidationHandler = CoreDOMImplementationImpl.singleton.getValidator(schemaType, xmlVersion);
 200                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA, true);
 201                 fConfiguration.setFeature(DOMConfigurationImpl.SCHEMA_FULL_CHECKING, true);
 202                 // report fatal error on DOM Level 1 nodes
 203                 fNamespaceValidation = true;
 204 
 205                 // check if we need to fill in PSVI
 206                 fPSVI = ((fConfiguration.features &amp; DOMConfigurationImpl.PSVI) !=0)?true:false;
 207             }
 208             else {
 209                 schemaType = XMLGrammarDescription.XML_DTD;
 210                 if (schemaLang != null) {
 211                     schemaLocations = (String []) fConfiguration.getProperty(DOMConfigurationImpl.JAXP_SCHEMA_SOURCE);
 212                 }
 213                 fConfiguration.setDTDValidatorFactory(xmlVersion);
 214                 fValidationHandler = CoreDOMImplementationImpl.singleton.getValidator(schemaType, xmlVersion);
 215                 fPSVI = false;
 216             }
 217 
 218             fConfiguration.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);
 219 
 220             // reset ID table
 221             fDocument.clearIdentifiers();
 222 
 223             if (fValidationHandler != null) {
 224                 // reset the validation handler
 225                 ((XMLComponent) fValidationHandler).reset(fConfiguration);
 226             }
 227         }
 228         else {
 229             fValidationHandler = null;
 230         }
 231 
 232         fErrorHandler = (DOMErrorHandler) fConfiguration.getParameter(Constants.DOM_ERROR_HANDLER);
 233         if (fValidationHandler != null) {
 234             fValidationHandler.setDocumentHandler(this);
 235             fValidationHandler.startDocument(
 236                     new SimpleLocator(fDocument.fDocumentURI, fDocument.fDocumentURI,
 237                             -1, -1 ), fDocument.encoding, fNamespaceContext, null);
 238             fValidationHandler.xmlDecl(fDocument.getXmlVersion(),
 239                     fDocument.getXmlEncoding(), fDocument.getXmlStandalone() ? &quot;yes&quot; : &quot;no&quot;, null);
 240         }
 241         try {
 242             if (schemaType == XMLGrammarDescription.XML_DTD) {
 243                 processDTD(xmlVersion, schemaLocations != null ? schemaLocations[0] : null);
 244             }
 245 
 246             Node kid, next;
 247             for (kid = fDocument.getFirstChild(); kid != null; kid = next) {
 248                 next = kid.getNextSibling();
 249                 kid = normalizeNode(kid);
 250                 if (kid != null) { // don&#39;t advance
 251                     next = kid;
 252                 }
 253             }
 254 
 255             // release resources
 256             if (fValidationHandler != null) {
 257                 fValidationHandler.endDocument(null);
 258                 fValidationHandler.setDocumentHandler(null);
 259                 CoreDOMImplementationImpl.singleton.releaseValidator(schemaType, xmlVersion, fValidationHandler);
 260                 fValidationHandler = null;
 261             }
 262         }
 263         catch (RuntimeException e) {
 264             // release resources
 265             if (fValidationHandler != null) {
 266                 fValidationHandler.setDocumentHandler(null);
 267                 CoreDOMImplementationImpl.singleton.releaseValidator(schemaType, xmlVersion, fValidationHandler);
 268                 fValidationHandler = null;
 269             }
 270             if (e instanceof AbortException) {
 271                 return; // processing aborted by the user
 272             }
 273             throw e; // otherwise re-throw.
 274         }
 275     }
 276 
 277     /**
 278      *
 279      * This method acts as if the document was going through a save
 280      * and load cycle, putting the document in a &quot;normal&quot; form. The actual result
 281      * depends on the features being set and governing what operations actually
 282      * take place. See setNormalizationFeature for details. Noticeably this method
 283      * normalizes Text nodes, makes the document &quot;namespace wellformed&quot;,
 284      * according to the algorithm described below in pseudo code, by adding missing
 285      * namespace declaration attributes and adding or changing namespace prefixes, updates
 286      * the replacement tree of EntityReference nodes,normalizes attribute values, etc.
 287      *
 288      * @param node   Modified node or null. If node is returned, we need
 289      *               to normalize again starting on the node returned.
 290      * @return  the normalized Node
 291      */
 292     protected Node normalizeNode (Node node){
 293 
 294         int type = node.getNodeType();
 295         boolean wellformed;
 296         fLocator.fRelatedNode=node;
 297 
 298         switch (type) {
 299         case Node.DOCUMENT_TYPE_NODE: {
 300                 if (DEBUG_ND) {
 301                     System.out.println(&quot;==&gt;normalizeNode:{doctype}&quot;);
 302                 }
 303                 // REVISIT: well-formedness encoding info
 304                 break;
 305             }
 306 
 307         case Node.ELEMENT_NODE: {
 308                 if (DEBUG_ND) {
 309                     System.out.println(&quot;==&gt;normalizeNode:{element} &quot;+node.getNodeName());
 310                 }
 311 
 312                 //do the name check only when version of the document was changed &amp;
 313                 //application has set the value of well-formed features to true
 314                 if (fDocument.errorChecking) {
 315                     if ( ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;
 316                             fDocument.isXMLVersionChanged()){
 317                         if (fNamespaceValidation){
 318                             wellformed = CoreDocumentImpl.isValidQName(node.getPrefix() , node.getLocalName(), fDocument.isXML11Version());
 319                         }
 320                         else {
 321                             wellformed = CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
 322                         }
 323                         if (!wellformed){
 324                             String msg = DOMMessageFormatter.formatMessage(
 325                                     DOMMessageFormatter.DOM_DOMAIN,
 326                                     &quot;wf-invalid-character-in-node-name&quot;,
 327                                     new Object[]{&quot;Element&quot;, node.getNodeName()});
 328                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 329                             &quot;wf-invalid-character-in-node-name&quot;);
 330                         }
 331                     }
 332                 }
 333                 // push namespace context
 334                 fNamespaceContext.pushContext();
 335                 fLocalNSBinder.reset();
 336 
 337                 ElementImpl elem = (ElementImpl)node;
 338                 if (elem.needsSyncChildren()) {
 339                     elem.synchronizeChildren();
 340                 }
 341                 AttributeMap attributes = (elem.hasAttributes()) ? (AttributeMap) elem.getAttributes() : null;
 342 
 343                 // fix namespaces and remove default attributes
 344                 if ((fConfiguration.features &amp; DOMConfigurationImpl.NAMESPACES) !=0) {
 345                     // fix namespaces
 346                     // normalize attribute values
 347                     // remove default attributes
 348                     namespaceFixUp(elem, attributes);
 349 
 350                     if ((fConfiguration.features &amp; DOMConfigurationImpl.NSDECL) == 0) {
 351                         // Namespace declarations may have been added by namespace fix-up. Need
 352                         // to fetch the AttributeMap again if it contained no attributes prior
 353                         // to namespace fix-up.
 354                         if (attributes == null) {
 355                             attributes = (elem.hasAttributes()) ? (AttributeMap) elem.getAttributes() : null;
 356                         }
 357                         if (attributes != null) {
 358                             for (int i = 0; i &lt; attributes.getLength(); ++i) {
 359                                 Attr att = (Attr)attributes.getItem(i);
 360                                 if (XMLSymbols.PREFIX_XMLNS.equals(att.getPrefix()) ||
 361                                         XMLSymbols.PREFIX_XMLNS.equals(att.getName())) {
 362                                     elem.removeAttributeNode(att);
 363                                     --i;
 364                                 }
 365                             }
 366                         }
 367                     }
 368 
 369                 } else {
 370                     if ( attributes!=null ) {
 371                         for ( int i=0; i&lt;attributes.getLength(); ++i ) {
 372                             Attr attr = (Attr)attributes.item(i);
 373                             //removeDefault(attr, attributes);
 374                             attr.normalize();
 375                             if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
 376                                     isAttrValueWF(fErrorHandler, fError, fLocator, attributes, attr, attr.getValue(), fDocument.isXML11Version());
 377                                 if (fDocument.isXMLVersionChanged()) {
 378                                     if (fNamespaceValidation){
 379                                         wellformed = CoreDocumentImpl.isValidQName(node.getPrefix(), node.getLocalName(), fDocument.isXML11Version());
 380                                     }
 381                                     else {
 382                                         wellformed = CoreDocumentImpl.isXMLName(node.getNodeName(), fDocument.isXML11Version());
 383                                     }
 384                                     if (!wellformed) {
 385                                         String msg = DOMMessageFormatter.formatMessage(
 386                                           DOMMessageFormatter.DOM_DOMAIN,
 387                                           &quot;wf-invalid-character-in-node-name&quot;,
 388                                            new Object[]{&quot;Attr&quot;,node.getNodeName()});
 389                                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 390                                             &quot;wf-invalid-character-in-node-name&quot;);
 391                                     }
 392                                 }
 393                             }
 394                         }
 395                     }
 396                 }
 397 
 398 
 399                 if (fValidationHandler != null) {
 400                     // REVISIT: possible solutions to discard default content are:
 401                     //         either we pass some flag to XML Schema validator
 402                     //         or rely on the PSVI information.
 403                     fAttrProxy.setAttributes(attributes, fDocument, elem);
 404                     updateQName(elem, fQName); // updates global qname
 405                     // set error node in the dom error wrapper
 406                     // so if error occurs we can report an error node
 407                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 408                     fCurrentNode = node;
 409                     // call re-validation handler
 410                     fValidationHandler.startElement(fQName, fAttrProxy, null);
 411                 }
 412 
 413                 // normalize children
 414                 Node kid, next;
 415                 for (kid = elem.getFirstChild(); kid != null; kid = next) {
 416                     next = kid.getNextSibling();
 417                     kid = normalizeNode(kid);
 418                     if (kid != null) {
 419                         next = kid;  // don&#39;t advance
 420                     }
 421                 }
 422                 if (DEBUG_ND) {
 423                     // normalized subtree
 424                     System.out.println(&quot;***The children of {&quot;+node.getNodeName()+&quot;} are normalized&quot;);
 425                     for (kid = elem.getFirstChild(); kid != null; kid = next) {
 426                         next = kid.getNextSibling();
 427                         System.out.println(kid.getNodeName() +&quot;[&quot;+kid.getNodeValue()+&quot;]&quot;);
 428                     }
 429 
 430                 }
 431 
 432                 if (fValidationHandler != null) {
 433                     updateQName(elem, fQName); // updates global qname
 434                     //
 435                     // set error node in the dom error wrapper
 436                     // so if error occurs we can report an error node
 437                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 438                     fCurrentNode = node;
 439                     fValidationHandler.endElement(fQName, null);
 440                 }
 441 
 442                 // pop namespace context
 443                 fNamespaceContext.popContext();
 444 
 445                 break;
 446             }
 447 
 448         case Node.COMMENT_NODE: {
 449                 if (DEBUG_ND) {
 450                     System.out.println(&quot;==&gt;normalizeNode:{comments}&quot;);
 451                 }
 452 
 453                 if ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0) {
 454                     Node prevSibling = node.getPreviousSibling();
 455                     Node parent = node.getParentNode();
 456                     // remove the comment node
 457                     parent.removeChild(node);
 458                     if (prevSibling != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE) {
 459                         Node nextSibling = prevSibling.getNextSibling();
 460                         if (nextSibling != null &amp;&amp; nextSibling.getNodeType() == Node.TEXT_NODE) {
 461                             ((TextImpl)nextSibling).insertData(0, prevSibling.getNodeValue());
 462                             parent.removeChild(prevSibling);
 463                             return nextSibling;
 464                         }
 465                     }
 466                 }//if comment node need not be removed
 467                 else {
 468                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)){
 469                         String commentdata = ((Comment)node).getData();
 470                         // check comments for invalid xml chracter as per the version
 471                         // of the document
 472                         isCommentWF(fErrorHandler, fError, fLocator, commentdata, fDocument.isXML11Version());
 473                     }
 474                     if (fValidationHandler != null) {
 475                         // Don&#39;t bother filling an XMLString with the text of the comment.
 476                         // We only send the comment event to the validator handler so that
 477                         // when  the schema-type is DTD an error will be reported for a
 478                         // comment appearing in EMPTY content.
 479                         fValidationHandler.comment(EMPTY_STRING, null);
 480                     }
 481                 }//end-else if comment node is not to be removed.
 482                                 break;
 483             }
 484         case Node.ENTITY_REFERENCE_NODE: {
 485                 if (DEBUG_ND) {
 486                     System.out.println(&quot;==&gt;normalizeNode:{entityRef} &quot;+node.getNodeName());
 487                 }
 488 
 489                 if ((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0) {
 490                     Node prevSibling = node.getPreviousSibling();
 491                     Node parent = node.getParentNode();
 492                     ((EntityReferenceImpl)node).setReadOnly(false, true);
 493                     expandEntityRef (parent, node);
 494                     parent.removeChild(node);
 495                     Node next = (prevSibling != null)?prevSibling.getNextSibling():parent.getFirstChild();
 496                     // The list of children #text -&gt; &amp;ent;
 497                     // and entity has a first child as a text
 498                     // we should not advance
 499                     if (prevSibling != null &amp;&amp; next != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE &amp;&amp;
 500                         next.getNodeType() == Node.TEXT_NODE) {
 501                         return prevSibling;  // Don&#39;t advance
 502                     }
 503                     return next;
 504                 } else {
 505                     if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) &amp;&amp;
 506                         fDocument.isXMLVersionChanged()){
 507                             CoreDocumentImpl.isXMLName(node.getNodeName() , fDocument.isXML11Version());
 508                     }
 509                     // REVISIT: traverse entity reference and send appropriate calls to the validator
 510                     // (no normalization should be performed for the children).
 511                 }
 512                 break;
 513             }
 514 
 515         case Node.CDATA_SECTION_NODE: {
 516                 if (DEBUG_ND) {
 517                     System.out.println(&quot;==&gt;normalizeNode:{cdata}&quot;);
 518                 }
 519 
 520                 if ((fConfiguration.features &amp; DOMConfigurationImpl.CDATA) == 0) {
 521                     // convert CDATA to TEXT nodes
 522                     Node prevSibling = node.getPreviousSibling();
 523                     if (prevSibling != null &amp;&amp; prevSibling.getNodeType() == Node.TEXT_NODE){
 524                         ((Text)prevSibling).appendData(node.getNodeValue());
 525                         node.getParentNode().removeChild(node);
 526                         return prevSibling; //don&#39;t advance
 527                     }
 528                     else {
 529                         Text text = fDocument.createTextNode(node.getNodeValue());
 530                         Node parent = node.getParentNode();
 531                         node = parent.replaceChild(text, node);
 532                         return text;  //don&#39;t advance
 533 
 534                     }
 535                 }
 536 
 537                 // send characters call for CDATA
 538                 if (fValidationHandler != null) {
 539                     // set error node in the dom error wrapper
 540                     // so if error occurs we can report an error node
 541                     fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 542                     fCurrentNode = node;
 543                     fValidationHandler.startCDATA(null);
 544                     fValidationHandler.characterData(node.getNodeValue(), null);
 545                     fValidationHandler.endCDATA(null);
 546                 }
 547                 String value = node.getNodeValue();
 548 
 549                 if ((fConfiguration.features &amp; DOMConfigurationImpl.SPLITCDATA) != 0) {
 550                     int index;
 551                     Node parent = node.getParentNode();
 552                     if (fDocument.errorChecking) {
 553                         isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());
 554                     }
 555                     while ( (index=value.indexOf(&quot;]]&gt;&quot;)) &gt;= 0 ) {
 556                         node.setNodeValue(value.substring(0, index+2));
 557                         value = value.substring(index +2);
 558 
 559                         Node firstSplitNode = node;
 560                         Node newChild = fDocument.createCDATASection(value);
 561                         parent.insertBefore(newChild, node.getNextSibling());
 562                         node = newChild;
 563                         // issue warning
 564                         fLocator.fRelatedNode = firstSplitNode;
 565                         String msg = DOMMessageFormatter.formatMessage(
 566                             DOMMessageFormatter.DOM_DOMAIN,
 567                             &quot;cdata-sections-splitted&quot;,
 568                              null);
 569                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_WARNING,
 570                             &quot;cdata-sections-splitted&quot;);
 571                     }
 572 
 573                 }
 574                 else if (fDocument.errorChecking) {
 575                     // check well-formedness
 576                     isCDataWF(fErrorHandler, fError, fLocator, value, fDocument.isXML11Version());
 577                 }
 578                 break;
 579             }
 580 
 581         case Node.TEXT_NODE: {
 582                 if (DEBUG_ND) {
 583                     System.out.println(&quot;==&gt;normalizeNode(text):{&quot;+node.getNodeValue()+&quot;}&quot;);
 584                 }
 585                 // If node is a text node, we need to check for one of two
 586                 // conditions:
 587                 //   1) There is an adjacent text node
 588                 //   2) There is no adjacent text node, but node is
 589                 //      an empty text node.
 590                 Node next = node.getNextSibling();
 591                 // If an adjacent text node, merge it with this node
 592                 if ( next!=null &amp;&amp; next.getNodeType() == Node.TEXT_NODE ) {
 593                     ((Text)node).appendData(next.getNodeValue());
 594                     node.getParentNode().removeChild( next );
 595                     // We don&#39;t need to check well-formness here since we are not yet
 596                     // done with this node.
 597 
 598                     return node; // Don&#39;t advance;
 599                 } else if (node.getNodeValue().length()==0) {
 600                     // If kid is empty, remove it
 601                     node.getParentNode().removeChild( node );
 602                 } else {
 603                     // validator.characters() call and well-formness
 604                     // Don&#39;t send characters or check well-formness in the following cases:
 605                     // 1. entities is false, next child is entity reference: expand tree first
 606                     // 2. comments is false, and next child is comment
 607                     // 3. cdata is false, and next child is cdata
 608 
 609                     short nextType = (next != null)?next.getNodeType():-1;
 610                     if (nextType == -1 || !(((fConfiguration.features &amp; DOMConfigurationImpl.ENTITIES) == 0 &amp;&amp;
 611                             nextType == Node.ENTITY_NODE) ||
 612                             ((fConfiguration.features &amp; DOMConfigurationImpl.COMMENTS) == 0 &amp;&amp;
 613                                     nextType == Node.COMMENT_NODE) ||
 614                                     ((fConfiguration.features &amp; DOMConfigurationImpl.CDATA) == 0) &amp;&amp;
 615                                     nextType == Node.CDATA_SECTION_NODE)) {
 616                         if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0) ){
 617                             isXMLCharWF(fErrorHandler, fError, fLocator, node.getNodeValue(), fDocument.isXML11Version());
 618                         }
 619                         if (fValidationHandler != null) {
 620                             fConfiguration.fErrorHandlerWrapper.fCurrentNode = node;
 621                             fCurrentNode = node;
 622                             fValidationHandler.characterData(node.getNodeValue(), null);
 623                             if (!fNamespaceValidation) {
 624                                 if (fAllWhitespace) {
 625                                     fAllWhitespace = false;
 626                                     ((TextImpl)node).setIgnorableWhitespace(true);
 627                                 }
 628                                 else {
 629                                     ((TextImpl)node).setIgnorableWhitespace(false);
 630                                 }
 631                             }
 632                             if (DEBUG_ND) {
 633                                 System.out.println(&quot;=====&gt;characterData(),&quot;+nextType);
 634                             }
 635                         }
 636                     }
 637                     else {
 638                         if (DEBUG_ND) {
 639                             System.out.println(&quot;=====&gt;don&#39;t send characters(),&quot;+nextType);
 640 
 641                         }
 642                     }
 643                 }
 644                 break;
 645             }
 646         case Node.PROCESSING_INSTRUCTION_NODE: {
 647 
 648             //do the well-formed valid PI target name , data check when application has set the value of well-formed feature to true
 649             if (fDocument.errorChecking &amp;&amp; (fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0 ) {
 650                 ProcessingInstruction pinode = (ProcessingInstruction)node ;
 651 
 652                 String target = pinode.getTarget();
 653                 //1.check PI target name
 654                 if(fDocument.isXML11Version()){
 655                     wellformed = XML11Char.isXML11ValidName(target);
 656                 }
 657                 else{
 658                     wellformed = XMLChar.isValidName(target);
 659                 }
 660 
 661                                 if (!wellformed) {
 662                                     String msg = DOMMessageFormatter.formatMessage(
 663                                         DOMMessageFormatter.DOM_DOMAIN,
 664                                         &quot;wf-invalid-character-in-node-name&quot;,
 665                                         new Object[]{&quot;Element&quot;, node.getNodeName()});
 666                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 667                         &quot;wf-invalid-character-in-node-name&quot;);
 668                 }
 669 
 670                 //2. check PI data
 671                 //processing isntruction data may have certain characters
 672                 //which may not be valid XML character
 673                 isXMLCharWF(fErrorHandler, fError, fLocator, pinode.getData(), fDocument.isXML11Version());
 674             }
 675 
 676             if (fValidationHandler != null) {
 677                 // Don&#39;t bother filling an XMLString with the data section of the
 678                 // processing instruction. We only send the processing instruction
 679                 // event to the validator handler so that when the schema-type is
 680                 // DTD an error will be reported for a processing instruction
 681                 // appearing in EMPTY content.
 682                 fValidationHandler.processingInstruction(((ProcessingInstruction) node).getTarget(), EMPTY_STRING, null);
 683             }
 684         }//end case Node.PROCESSING_INSTRUCTION_NODE
 685 
 686         }//end of switch
 687         return null;
 688     }//normalizeNode
 689 
 690     private void processDTD(String xmlVersion, String schemaLocation) {
 691 
 692         String rootName = null;
 693         String publicId = null;
 694         String systemId = schemaLocation;
 695         String baseSystemId = fDocument.getDocumentURI();
 696         String internalSubset = null;
 697 
 698         DocumentType docType = fDocument.getDoctype();
 699         if (docType != null) {
 700             rootName = docType.getName();
 701             publicId = docType.getPublicId();
 702             if (systemId == null || systemId.length() == 0) {
 703                 systemId = docType.getSystemId();
 704             }
 705             internalSubset = docType.getInternalSubset();
 706         }
 707         // If the DOM doesn&#39;t have a DocumentType node we may still
 708         // be able to fetch a DTD if the application provided a URI
 709         else {
 710             Element elem = fDocument.getDocumentElement();
 711             if (elem == null) return;
 712             rootName = elem.getNodeName();
 713             if (systemId == null || systemId.length() == 0) return;
 714         }
 715 
 716         XMLDTDLoader loader = null;
 717         try {
 718             fValidationHandler.doctypeDecl(rootName, publicId, systemId, null);
 719             loader = CoreDOMImplementationImpl.singleton.getDTDLoader(xmlVersion);
 720             loader.setFeature(DOMConfigurationImpl.XERCES_VALIDATION, true);
 721             loader.setEntityResolver(fConfiguration.getEntityResolver());
 722             loader.setErrorHandler(fConfiguration.getErrorHandler());
 723             loader.loadGrammarWithContext((XMLDTDValidator) fValidationHandler, rootName,
 724                     publicId, systemId, baseSystemId, internalSubset);
 725         }
 726         // REVISIT: Should probably report this exception to the error handler.
 727         catch (IOException e) {
 728         }
 729         finally {
 730             if (loader != null) {
 731                 CoreDOMImplementationImpl.singleton.releaseDTDLoader(xmlVersion, loader);
 732             }
 733         }
 734     } // processDTD(String, String)
 735 
 736     protected final void expandEntityRef (Node parent, Node reference){
 737         Node kid, next;
 738         for (kid = reference.getFirstChild(); kid != null; kid = next) {
 739             next = kid.getNextSibling();
 740             parent.insertBefore(kid, reference);
 741         }
 742     }
 743 
 744     // fix namespaces
 745     // normalize attribute values
 746     // remove default attributes
 747     // check attribute names if the version of the document changed.
 748 
 749     protected final void namespaceFixUp (ElementImpl element, AttributeMap attributes){
 750         if (DEBUG) {
 751             System.out.println(&quot;[ns-fixup] element:&quot; +element.getNodeName()+
 752                                &quot; uri: &quot;+element.getNamespaceURI());
 753         }
 754 
 755         // ------------------------------------
 756         // pick up local namespace declarations
 757         // &lt;xsl:stylesheet xmlns:xsl=&quot;http://xslt&quot;&gt;
 758         //   &lt;!-- add the following via DOM
 759         //          body is bound to http://xslt
 760         //    --&gt;
 761         //   &lt;xsl:body xmlns:xsl=&quot;http://bound&quot;/&gt;
 762         //
 763         // ------------------------------------
 764 
 765         String value, uri, prefix;
 766         if (attributes != null) {
 767 
 768             // Record all valid local declarations
 769             for (int k = 0; k &lt; attributes.getLength(); ++k) {
 770                 Attr attr = (Attr)attributes.getItem(k);
 771                 uri = attr.getNamespaceURI();
 772                 if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 773                     // namespace attribute
 774                     value = attr.getNodeValue();
 775                     if (value == null) {
 776                         value=XMLSymbols.EMPTY_STRING;
 777                     }
 778 
 779                     // Check for invalid namespace declaration:
 780                     if (fDocument.errorChecking &amp;&amp; value.equals(NamespaceContext.XMLNS_URI)) {
 781                         //A null value for locale is passed to formatMessage,
 782                         //which means that the default locale will be used
 783                         fLocator.fRelatedNode = attr;
 784                         String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,&quot;CantBindXMLNS&quot;,null );
 785                         reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR, &quot;CantBindXMLNS&quot;);
 786                     } else {
 787                         // XML 1.0 Attribute value normalization
 788                         // value = normalizeAttributeValue(value, attr);
 789                         prefix = attr.getPrefix();
 790                         prefix = (prefix == null ||
 791                                   prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 792                         String localpart = fSymbolTable.addSymbol( attr.getLocalName());
 793                         if (prefix == XMLSymbols.PREFIX_XMLNS) { //xmlns:prefix
 794 
 795                             value = fSymbolTable.addSymbol(value);
 796                             if (value.length() != 0) {
 797                                 fNamespaceContext.declarePrefix(localpart, value);
 798                             } else {
 799                                 // REVISIT: issue error on invalid declarations
 800                                 //          xmlns:foo = &quot;&quot;
 801 
 802                             }
 803                             //removeDefault (attr, attributes);
 804                             continue;
 805                         } else { // (localpart == fXmlnsSymbol &amp;&amp; prefix == fEmptySymbol)  -- xmlns
 806                             // empty prefix is always bound (&quot;&quot; or some string)
 807                             value = fSymbolTable.addSymbol(value);
 808                             fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, value.length() != 0 ? value : null);
 809                             //removeDefault (attr, attributes);
 810                             continue;
 811                         }
 812                     }  // end-else: valid declaration
 813                 } // end-if: namespace attribute
 814             }
 815         }
 816 
 817 
 818 
 819         // ---------------------------------------------------------
 820         // Fix up namespaces for element: per DOM L3
 821         // Need to consider the following cases:
 822         //
 823         // case 1: &lt;xsl:stylesheet xmlns:xsl=&quot;http://xsl&quot;&gt;
 824         // We create another element body bound to the &quot;http://xsl&quot; namespace
 825         // as well as namespace attribute rebounding xsl to another namespace.
 826         // &lt;xsl:body xmlns:xsl=&quot;http://another&quot;&gt;
 827         // Need to make sure that the new namespace decl value is changed to
 828         // &quot;http://xsl&quot;
 829         //
 830         // ---------------------------------------------------------
 831         // check if prefix/namespace is correct for current element
 832         // ---------------------------------------------------------
 833 
 834         uri = element.getNamespaceURI();
 835         prefix = element.getPrefix();
 836         if (uri != null) {  // Element has a namespace
 837             uri = fSymbolTable.addSymbol(uri);
 838             prefix = (prefix == null ||
 839                       prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 840             if (fNamespaceContext.getURI(prefix) == uri) {
 841                 // The xmlns:prefix=namespace or xmlns=&quot;default&quot; was declared at parent.
 842                 // The binder always stores mapping of empty prefix to &quot;&quot;.
 843             } else {
 844                 // the prefix is either undeclared
 845                 // or
 846                 // conflict: the prefix is bound to another URI
 847                 addNamespaceDecl(prefix, uri, element);
 848                 fLocalNSBinder.declarePrefix(prefix, uri);
 849                 fNamespaceContext.declarePrefix(prefix, uri);
 850             }
 851         } else { // Element has no namespace
 852             if (element.getLocalName() == null) {
 853 
 854                 //  Error: DOM Level 1 node!
 855                 if (fNamespaceValidation) {
 856                     String msg = DOMMessageFormatter.formatMessage(
 857                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 858                             new Object[]{element.getNodeName()});
 859                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR,
 860                     &quot;NullLocalElementName&quot;);
 861                 } else {
 862                     String msg = DOMMessageFormatter.formatMessage(
 863                             DOMMessageFormatter.DOM_DOMAIN, &quot;NullLocalElementName&quot;,
 864                             new Object[]{element.getNodeName()});
 865                     reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 866                     &quot;NullLocalElementName&quot;);
 867                 }
 868 
 869             } else { // uri=null and no colon (DOM L2 node)
 870                 uri = fNamespaceContext.getURI(XMLSymbols.EMPTY_STRING);
 871                 if (uri !=null &amp;&amp; uri.length() &gt; 0) {
 872                     // undeclare default namespace declaration (before that element
 873                     // bound to non-zero length uir), but adding xmlns=&quot;&quot; decl
 874                     addNamespaceDecl (XMLSymbols.EMPTY_STRING, XMLSymbols.EMPTY_STRING, element);
 875                     fLocalNSBinder.declarePrefix(XMLSymbols.EMPTY_STRING, null);
 876                     fNamespaceContext.declarePrefix(XMLSymbols.EMPTY_STRING, null);
 877                 }
 878             }
 879         }
 880 
 881         // -----------------------------------------
 882         // Fix up namespaces for attributes: per DOM L3
 883         // check if prefix/namespace is correct the attributes
 884         // -----------------------------------------
 885         if (attributes != null) {
 886 
 887             // clone content of the attributes
 888             attributes.cloneMap(fAttributeList);
 889             for (int i = 0; i &lt; fAttributeList.size(); i++) {
 890                 Attr attr = (Attr) fAttributeList.get(i);
 891                 fLocator.fRelatedNode = attr;
 892 
 893                 if (DEBUG) {
 894                     System.out.println(&quot;==&gt;[ns-fixup] process attribute: &quot;+attr.getNodeName());
 895                 }
 896                 // normalize attribute value
 897                 attr.normalize();
 898                 value = attr.getValue();
 899                 uri = attr.getNamespaceURI();
 900 
 901                 // make sure that value is never null.
 902                 if (value == null) {
 903                     value = XMLSymbols.EMPTY_STRING;
 904                 }
 905 
 906                 //---------------------------------------
 907                 // check if value of the attribute is namespace well-formed
 908                 //---------------------------------------
 909                 if (fDocument.errorChecking &amp;&amp; ((fConfiguration.features &amp; DOMConfigurationImpl.WELLFORMED) != 0)) {
 910                     isAttrValueWF(fErrorHandler, fError, fLocator, attributes, attr, value, fDocument.isXML11Version());
 911                     if (fDocument.isXMLVersionChanged()) {
 912                         boolean wellformed;
 913                         if (fNamespaceValidation){
 914                             wellformed = CoreDocumentImpl.isValidQName(attr.getPrefix(), attr.getLocalName(), fDocument.isXML11Version());
 915                         }
 916                         else {
 917                             wellformed = CoreDocumentImpl.isXMLName(attr.getNodeName(), fDocument.isXML11Version());
 918                         }
 919                         if (!wellformed) {
 920                             String msg = DOMMessageFormatter.formatMessage(
 921                                     DOMMessageFormatter.DOM_DOMAIN,
 922                                     &quot;wf-invalid-character-in-node-name&quot;,
 923                                     new Object[]{&quot;Attr&quot;, attr.getNodeName()});
 924                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
 925                             &quot;wf-invalid-character-in-node-name&quot;);
 926                         }
 927                     }
 928                 }
 929 
 930                 if (uri != null) {  // attribute has namespace !=null
 931                     prefix = attr.getPrefix();
 932                     prefix = (prefix == null ||
 933                               prefix.length() == 0) ? XMLSymbols.EMPTY_STRING :fSymbolTable.addSymbol(prefix);
 934                     /*String localpart =*/ fSymbolTable.addSymbol( attr.getLocalName());
 935 
 936                     // ---------------------------------------
 937                     // skip namespace declarations
 938                     // ---------------------------------------
 939                     // REVISIT: can we assume that &quot;uri&quot; is from some symbol
 940                     // table, and compare by reference? -SG
 941                     if (uri != null &amp;&amp; uri.equals(NamespaceContext.XMLNS_URI)) {
 942                         continue;
 943                     }
 944 
 945                     // ---------------------------------------
 946                     // remove default attributes
 947                     // ---------------------------------------
 948                     /*
 949                     if (removeDefault(attr, attributes)) {
 950                         continue;
 951                     }
 952                     */
 953                     // XML 1.0 Attribute value normalization
 954                     //value = normalizeAttributeValue(value, attr);
 955 
 956                     // reset id-attributes
 957                     ((AttrImpl)attr).setIdAttribute(false);
 958 
 959                     uri = fSymbolTable.addSymbol(uri);
 960 
 961                     // find if for this prefix a URI was already declared
 962                     String declaredURI =  fNamespaceContext.getURI(prefix);
 963 
 964                     if (prefix == XMLSymbols.EMPTY_STRING || declaredURI != uri) {
 965                         // attribute has no prefix (default namespace decl does not apply to attributes)
 966                         // OR
 967                         // attribute prefix is not declared
 968                         // OR
 969                         // conflict: attribute has a prefix that conficlicts with a binding
 970                         //           already active in scope
 971 
 972                         // Find if any prefix for attributes namespace URI is available
 973                         // in the scope
 974                         String declaredPrefix = fNamespaceContext.getPrefix(uri);
 975                         if (declaredPrefix !=null &amp;&amp; declaredPrefix !=XMLSymbols.EMPTY_STRING) {
 976 
 977                             // use the prefix that was found (declared previously for this URI
 978                             prefix = declaredPrefix;
 979                         } else {
 980                             if (prefix != XMLSymbols.EMPTY_STRING &amp;&amp; fLocalNSBinder.getURI(prefix) == null) {
 981                                 // the current prefix is not null and it has no in scope declaration
 982 
 983                                 // use this prefix
 984                             } else {
 985 
 986                                 // find a prefix following the pattern &quot;NS&quot; +index (starting at 1)
 987                                 // make sure this prefix is not declared in the current scope.
 988                                 int counter = 1;
 989                                 prefix = fSymbolTable.addSymbol(PREFIX +counter++);
 990                                 while (fLocalNSBinder.getURI(prefix)!=null) {
 991                                     prefix = fSymbolTable.addSymbol(PREFIX +counter++);
 992                                 }
 993 
 994                             }
 995                             // add declaration for the new prefix
 996                             addNamespaceDecl(prefix, uri, element);
 997                             value = fSymbolTable.addSymbol(value);
 998                             fLocalNSBinder.declarePrefix(prefix, value);
 999                             fNamespaceContext.declarePrefix(prefix, uri);
1000                         }
1001 
1002                         // change prefix for this attribute
1003                         attr.setPrefix(prefix);
1004                     }
1005                 } else { // attribute uri == null
1006 
1007                     // XML 1.0 Attribute value normalization
1008                     //value = normalizeAttributeValue(value, attr);
1009 
1010                     // reset id-attributes
1011                     ((AttrImpl)attr).setIdAttribute(false);
1012 
1013                     if (attr.getLocalName() == null) {
1014                         // It is an error if document has DOM L1 nodes.
1015                         if (fNamespaceValidation) {
1016                             String msg = DOMMessageFormatter.formatMessage(
1017                                 DOMMessageFormatter.DOM_DOMAIN,
1018                                 &quot;NullLocalAttrName&quot;, new Object[]{attr.getNodeName()});
1019                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_FATAL_ERROR,
1020                                 &quot;NullLocalAttrName&quot;);
1021                         } else {
1022                             String msg = DOMMessageFormatter.formatMessage(
1023                                 DOMMessageFormatter.DOM_DOMAIN,
1024                                 &quot;NullLocalAttrName&quot;, new Object[]{attr.getNodeName()});
1025                             reportDOMError(fErrorHandler, fError, fLocator, msg, DOMError.SEVERITY_ERROR,
1026                                 &quot;NullLocalAttrName&quot;);
1027                         }
1028                     } else {
1029                         // uri=null and no colon
1030                         // no fix up is needed: default namespace decl does not
1031 
1032                         // ---------------------------------------
1033                         // remove default attributes
1034                         // ---------------------------------------
1035                         // removeDefault(attr, attributes);
1036                     }
1037                 }
1038             }
1039         } // end loop for attributes
1040     }
1041 
1042     /**
1043      * Adds a namespace attribute or replaces the value of existing namespace
1044      * attribute with the given prefix and value for URI.
1045      * In case prefix is empty will add/update default namespace declaration.
1046      *
1047      * @param prefix
1048      * @param uri
1049      * @exception IOException
1050      */
1051 
1052     protected final void addNamespaceDecl(String prefix, String uri, ElementImpl element){
1053         if (DEBUG) {
1054             System.out.println(&quot;[ns-fixup] addNamespaceDecl [&quot;+prefix+&quot;]&quot;);
1055         }
1056         if (prefix == XMLSymbols.EMPTY_STRING) {
1057             if (DEBUG) {
1058                 System.out.println(&quot;=&gt;add xmlns=\&quot;&quot;+uri+&quot;\&quot; declaration&quot;);
1059             }
1060             element.setAttributeNS(NamespaceContext.XMLNS_URI, XMLSymbols.PREFIX_XMLNS, uri);
1061         } else {
1062             if (DEBUG) {
1063                 System.out.println(&quot;=&gt;add xmlns:&quot;+prefix+&quot;=\&quot;&quot;+uri+&quot;\&quot; declaration&quot;);
1064             }
1065             element.setAttributeNS(NamespaceContext.XMLNS_URI, &quot;xmlns:&quot;+prefix, uri);
1066         }
1067     }
1068 
1069 
1070     //
1071     // Methods for well-formness checking
1072     //
1073 
1074 
1075     /**
1076      * Check if CDATA section is well-formed
1077      * @param datavalue
1078      * @param isXML11Version = true if XML 1.1
1079      */
1080     public static final void isCDataWF(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1081         String datavalue, boolean isXML11Version)
1082     {
1083         if (datavalue == null || (datavalue.length() == 0) ) {
1084             return;
1085         }
1086 
1087         char [] dataarray = datavalue.toCharArray();
1088         int datalength = dataarray.length;
1089 
1090         // version of the document is XML 1.1
1091         if (isXML11Version) {
1092             // we need to check all chracters as per production rules of XML11
1093             int i = 0;
1094             while(i &lt; datalength){
1095                 char c = dataarray[i++];
1096                 if ( XML11Char.isXML11Invalid(c) ) {
1097                     // check if this is a supplemental character
1098                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1099                         char c2 = dataarray[i++];
1100                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1101                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1102                             continue;
1103                         }
1104                     }
1105                     String msg = DOMMessageFormatter.formatMessage(
1106                         DOMMessageFormatter.XML_DOMAIN,
1107                         &quot;InvalidCharInCDSect&quot;,
1108                         new Object[] { Integer.toString(c, 16)});
1109                     reportDOMError(
1110                         errorHandler,
1111                         error,
1112                         locator,
1113                         msg,
1114                         DOMError.SEVERITY_ERROR,
1115                         &quot;wf-invalid-character&quot;);
1116                 }
1117                 else if (c == &#39;]&#39;) {
1118                     int count = i;
1119                     if (count &lt; datalength &amp;&amp; dataarray[count] == &#39;]&#39;) {
1120                         while (++count &lt; datalength &amp;&amp; dataarray[count] == &#39;]&#39;) {
1121                             // do nothing
1122                         }
1123                         if (count &lt; datalength &amp;&amp; dataarray[count] == &#39;&gt;&#39;) {
1124                             // CDEndInContent
1125                             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN, &quot;CDEndInContent&quot;, null);
1126                             reportDOMError(errorHandler, error, locator,msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1127                         }
1128                     }
1129 
1130                 }
1131             }
1132         } // version of the document is XML 1.0
1133         else {
1134             // we need to check all chracters as per production rules of XML 1.0
1135             int i = 0;
1136             while (i &lt; datalength) {
1137                 char c = dataarray[i++];
1138                 if( XMLChar.isInvalid(c) ) {
1139                     // check if this is a supplemental character
1140                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1141                         char c2 = dataarray[i++];
1142                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1143                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1144                             continue;
1145                         }
1146                     }
1147                     // Note:  The key InvalidCharInCDSect from XMLMessages.properties
1148                     // is being used to obtain the message and DOM error type
1149                     // &quot;wf-invalid-character&quot; is used.  Also per DOM it is error but
1150                     // as per XML spec. it is fatal error
1151                     String msg = DOMMessageFormatter.formatMessage(
1152                         DOMMessageFormatter.XML_DOMAIN,
1153                         &quot;InvalidCharInCDSect&quot;,
1154                         new Object[]{Integer.toString(c, 16)});
1155                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1156                 }
1157                 else if (c==&#39;]&#39;) {
1158                     int count = i;
1159                     if ( count&lt; datalength &amp;&amp; dataarray[count]==&#39;]&#39; ) {
1160                         while (++count &lt; datalength &amp;&amp; dataarray[count]==&#39;]&#39; ) {
1161                             // do nothing
1162                         }
1163                         if ( count &lt; datalength &amp;&amp; dataarray[count]==&#39;&gt;&#39; ) {
1164                             String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN, &quot;CDEndInContent&quot;, null);
1165                             reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1166                         }
1167                     }
1168 
1169                 }
1170             }
1171         } // end-else fDocument.isXMLVersion()
1172 
1173     } // isCDataWF
1174 
1175     /**
1176      * NON-DOM: check for valid XML characters as per the XML version
1177      * @param datavalue
1178      * @param isXML11Version = true if XML 1.1
1179      */
1180     public static final void isXMLCharWF(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1181         String datavalue, boolean isXML11Version)
1182     {
1183         if ( datavalue == null || (datavalue.length() == 0) ) {
1184             return;
1185         }
1186 
1187         char [] dataarray = datavalue.toCharArray();
1188         int datalength = dataarray.length;
1189 
1190         // version of the document is XML 1.1
1191         if(isXML11Version){
1192             //we need to check all characters as per production rules of XML11
1193             int i = 0 ;
1194             while (i &lt; datalength) {
1195                 if(XML11Char.isXML11Invalid(dataarray[i++])){
1196                     // check if this is a supplemental character
1197                     char ch = dataarray[i-1];
1198                     if (XMLChar.isHighSurrogate(ch) &amp;&amp; i &lt; datalength) {
1199                         char ch2 = dataarray[i++];
1200                         if (XMLChar.isLowSurrogate(ch2) &amp;&amp;
1201                             XMLChar.isSupplemental(XMLChar.supplemental(ch, ch2))) {
1202                             continue;
1203                         }
1204                     }
1205                     String msg = DOMMessageFormatter.formatMessage(
1206                         DOMMessageFormatter.DOM_DOMAIN, &quot;InvalidXMLCharInDOM&quot;,
1207                         new Object[]{Integer.toString(dataarray[i-1], 16)});
1208                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR,
1209                     &quot;wf-invalid-character&quot;);
1210                 }
1211             }
1212         } // version of the document is XML 1.0
1213         else{
1214             // we need to check all characters as per production rules of XML 1.0
1215             int i = 0 ;
1216             while (i &lt; datalength) {
1217                 if( XMLChar.isInvalid(dataarray[i++]) ) {
1218                     // check if this is a supplemental character
1219                     char ch = dataarray[i-1];
1220                     if (XMLChar.isHighSurrogate(ch) &amp;&amp; i &lt; datalength) {
1221                         char ch2 = dataarray[i++];
1222                         if (XMLChar.isLowSurrogate(ch2) &amp;&amp;
1223                             XMLChar.isSupplemental(XMLChar.supplemental(ch, ch2))) {
1224                             continue;
1225                         }
1226                     }
1227                     String msg = DOMMessageFormatter.formatMessage(
1228                         DOMMessageFormatter.DOM_DOMAIN, &quot;InvalidXMLCharInDOM&quot;,
1229                         new Object[]{Integer.toString(dataarray[i-1], 16)});
1230                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR,
1231                     &quot;wf-invalid-character&quot;);
1232                 }
1233             }
1234         } // end-else fDocument.isXMLVersion()
1235 
1236     } // isXMLCharWF
1237 
1238     /**
1239      * NON-DOM: check if value of the comment is well-formed
1240      * @param datavalue
1241      * @param isXML11Version = true if XML 1.1
1242      */
1243     public static final void isCommentWF(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1244         String datavalue, boolean isXML11Version)
1245     {
1246         if ( datavalue == null || (datavalue.length() == 0) ) {
1247             return;
1248         }
1249 
1250         char [] dataarray = datavalue.toCharArray();
1251         int datalength = dataarray.length ;
1252 
1253         // version of the document is XML 1.1
1254         if (isXML11Version) {
1255             // we need to check all chracters as per production rules of XML11
1256             int i = 0 ;
1257             while (i &lt; datalength){
1258                 char c = dataarray[i++];
1259                 if ( XML11Char.isXML11Invalid(c) ) {
1260                     // check if this is a supplemental character
1261                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1262                         char c2 = dataarray[i++];
1263                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1264                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1265                             continue;
1266                         }
1267                     }
1268                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1269                         &quot;InvalidCharInComment&quot;,
1270                         new Object [] {Integer.toString(dataarray[i-1], 16)});
1271                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1272                 }
1273                 else if (c == &#39;-&#39; &amp;&amp; i &lt; datalength &amp;&amp; dataarray[i] == &#39;-&#39;) {
1274                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1275                         &quot;DashDashInComment&quot;, null);
1276                     // invalid: &#39;--&#39; in comment
1277                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1278                 }
1279             }
1280         } // version of the document is XML 1.0
1281         else {
1282             // we need to check all chracters as per production rules of XML 1.0
1283             int i = 0;
1284             while (i &lt; datalength){
1285                 char c = dataarray[i++];
1286                 if( XMLChar.isInvalid(c) ){
1287                     // check if this is a supplemental character
1288                     if (XMLChar.isHighSurrogate(c) &amp;&amp; i &lt; datalength) {
1289                         char c2 = dataarray[i++];
1290                         if (XMLChar.isLowSurrogate(c2) &amp;&amp;
1291                             XMLChar.isSupplemental(XMLChar.supplemental(c, c2))) {
1292                             continue;
1293                         }
1294                     }
1295                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1296                         &quot;InvalidCharInComment&quot;, new Object [] {Integer.toString(dataarray[i-1], 16)});
1297                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1298                 }
1299                 else if (c == &#39;-&#39; &amp;&amp; i&lt;datalength &amp;&amp; dataarray[i]==&#39;-&#39;){
1300                     String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.XML_DOMAIN,
1301                         &quot;DashDashInComment&quot;, null);
1302                     // invalid: &#39;--&#39; in comment
1303                     reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR, &quot;wf-invalid-character&quot;);
1304                 }
1305             }
1306 
1307         } // end-else fDocument.isXMLVersion()
1308 
1309     } // isCommentWF
1310 
1311     /** NON-DOM: check if attribute value is well-formed
1312      * @param attributes
1313      * @param a
1314      * @param value
1315      */
1316     public static final void isAttrValueWF(DOMErrorHandler errorHandler, DOMErrorImpl error,
1317             DOMLocatorImpl locator, NamedNodeMap attributes, Attr a, String value, boolean xml11Version) {
1318         if (a instanceof AttrImpl &amp;&amp; ((AttrImpl)a).hasStringValue()) {
1319             isXMLCharWF(errorHandler, error, locator, value, xml11Version);
1320         } else {
1321                 NodeList children = a.getChildNodes();
1322             //check each child node of the attribute&#39;s value
1323             for (int j = 0; j &lt; children.getLength(); j++) {
1324                 Node child = children.item(j);
1325                 //If the attribute&#39;s child is an entity refernce
1326                 if (child.getNodeType() == Node.ENTITY_REFERENCE_NODE) {
1327                     Document owner = a.getOwnerDocument();
1328                     Entity ent = null;
1329                     //search for the entity in the docType
1330                     //of the attribute&#39;s ownerDocument
1331                     if (owner != null) {
1332                         DocumentType docType = owner.getDoctype();
1333                         if (docType != null) {
1334                             NamedNodeMap entities = docType.getEntities();
1335                             ent = (Entity) entities.getNamedItemNS(
1336                                     &quot;*&quot;,
1337                                     child.getNodeName());
1338                         }
1339                     }
1340                     //If the entity was not found issue a fatal error
1341                     if (ent == null) {
1342                         String msg = DOMMessageFormatter.formatMessage(
1343                             DOMMessageFormatter.DOM_DOMAIN, &quot;UndeclaredEntRefInAttrValue&quot;,
1344                             new Object[]{a.getNodeName()});
1345                         reportDOMError(errorHandler, error, locator, msg, DOMError.SEVERITY_ERROR,
1346                             &quot;UndeclaredEntRefInAttrValue&quot;);
1347                     }
1348                 }
1349                 else {
1350                     // Text node
1351                     isXMLCharWF(errorHandler, error, locator, child.getNodeValue(), xml11Version);
1352                 }
1353             }
1354         }
1355     }
1356 
1357 
1358 
1359     /**
1360      * Reports a DOM error to the user handler.
1361      *
1362      * If the error is fatal, the processing will be always aborted.
1363      */
1364     public static final void reportDOMError(DOMErrorHandler errorHandler, DOMErrorImpl error, DOMLocatorImpl locator,
1365                         String message, short severity, String type ) {
1366         if( errorHandler!=null ) {
1367             error.reset();
1368             error.fMessage = message;
1369             error.fSeverity = severity;
1370             error.fLocator = locator;
1371             error.fType = type;
1372             error.fRelatedData = locator.fRelatedNode;
1373 
1374             if(!errorHandler.handleError(error))
1375                 throw new AbortException();
1376         }
1377         if( severity==DOMError.SEVERITY_FATAL_ERROR )
1378             throw new AbortException();
1379     }
1380 
1381     protected final void updateQName (Node node, QName qname){
1382 
1383         String prefix    = node.getPrefix();
1384         String namespace = node.getNamespaceURI();
1385         String localName = node.getLocalName();
1386         // REVISIT: the symbols are added too often: start/endElement
1387         //          and in the namespaceFixup. Should reduce number of calls to symbol table.
1388         qname.prefix = (prefix!=null &amp;&amp; prefix.length()!=0)?fSymbolTable.addSymbol(prefix):null;
1389         qname.localpart = (localName != null)?fSymbolTable.addSymbol(localName):null;
1390         qname.rawname = fSymbolTable.addSymbol(node.getNodeName());
1391         qname.uri =  (namespace != null)?fSymbolTable.addSymbol(namespace):null;
1392     }
1393 
1394 
1395 
1396         /* REVISIT: remove this method if DOM does not change spec.
1397          * Performs partial XML 1.0 attribute value normalization and replaces
1398      * attribute value if the value is changed after the normalization.
1399      * DOM defines that normalizeDocument acts as if the document was going
1400      * through a save and load cycle, given that serializer will not escape
1401      * any &#39;\n&#39; or &#39;\r&#39; characters on load those will be normalized.
1402      * Thus during normalize document we need to do the following:
1403      * - perform &quot;2.11 End-of-Line Handling&quot;
1404      * - replace #xD, #xA, #x9 with #x20 (white space).
1405      * Note: This alg. won&#39;t attempt to resolve entity references or character entity
1406      * references, since &#39;&amp;&#39; will be escaped during serialization and during loading
1407      * this won&#39;t be recognized as entity reference, i.e. attribute value &quot;&amp;foo;&quot; will
1408      * be serialized as &quot;&amp;amp;foo;&quot; and thus after loading will be &quot;&amp;foo;&quot; again.
1409          * @param value current attribute value
1410          * @param attr current attribute
1411          * @return String the value (could be original if normalization did not change
1412      * the string)
1413          */
1414     final String normalizeAttributeValue(String value, Attr attr) {
1415         if (!attr.getSpecified()){
1416             // specified attributes should already have a normalized form
1417             // since those were added by validator
1418             return value;
1419         }
1420         int end = value.length();
1421         // ensure capacity
1422         if (fNormalizedValue.ch.length &lt; end) {
1423             fNormalizedValue.ch = new char[end];
1424         }
1425         fNormalizedValue.length = 0;
1426         boolean normalized = false;
1427         for (int i = 0; i &lt; end; i++) {
1428             char c = value.charAt(i);
1429             if (c==0x0009 || c==0x000A) {
1430                fNormalizedValue.ch[fNormalizedValue.length++] = &#39; &#39;;
1431                normalized = true;
1432             }
1433             else if(c==0x000D){
1434                normalized = true;
1435                fNormalizedValue.ch[fNormalizedValue.length++] = &#39; &#39;;
1436                int next = i+1;
1437                if (next &lt; end &amp;&amp; value.charAt(next)==0x000A) i=next; // skip following xA
1438             }
1439             else {
1440                 fNormalizedValue.ch[fNormalizedValue.length++] = c;
1441             }
1442         }
1443         if (normalized){
1444            value = fNormalizedValue.toString();
1445            attr.setValue(value);
1446         }
1447         return value;
1448     }
1449 
1450     protected final class XMLAttributesProxy
1451     implements XMLAttributes {
1452         protected AttributeMap fAttributes;
1453         protected CoreDocumentImpl fDocument;
1454         protected ElementImpl fElement;
1455 
1456         protected Vector&lt;String&gt; fDTDTypes = new Vector&lt;&gt;(5);
1457         protected Vector&lt;Augmentations&gt; fAugmentations = new Vector&lt;&gt;(5);
1458 
1459         public void setAttributes(AttributeMap attributes, CoreDocumentImpl doc, ElementImpl elem) {
1460             fDocument = doc;
1461             fAttributes = attributes;
1462             fElement = elem;
1463             if (attributes != null) {
1464                 int length = attributes.getLength();
1465                 fDTDTypes.setSize(length);
1466                 fAugmentations.setSize(length);
1467                 // REVISIT: this implementation does not store any value in augmentations
1468                 //          and basically not keeping augs in parallel to attributes map
1469                 //          untill all attributes are added (default attributes)
1470                 for (int i = 0; i &lt; length; i++) {
1471                     fAugmentations.setElementAt(new AugmentationsImpl(), i);
1472                 }
1473             }
1474             else {
1475                 fDTDTypes.setSize(0);
1476                 fAugmentations.setSize(0);
1477             }
1478         }
1479 
1480 
1481         /**
1482          * This method adds default declarations
1483                  * @see com.sun.org.apache.xerces.internal.xni.XMLAttributes#addAttribute(QName, String, String)
1484          */
1485         public int addAttribute(QName qname, String attrType, String attrValue) {
1486             int index = fElement.getXercesAttribute(qname.uri, qname.localpart);
1487             // add defaults to the tree
1488             if (index &lt; 0) {
1489                 // the default attribute was removed by a user and needed to
1490                 // be added back
1491                 AttrImpl attr = (AttrImpl)
1492                     ((CoreDocumentImpl) fElement.getOwnerDocument()).createAttributeNS(
1493                         qname.uri,
1494                         qname.rawname,
1495                         qname.localpart);
1496                 // REVISIT: the following should also update ID table
1497                 attr.setNodeValue(attrValue);
1498                 index = fElement.setXercesAttributeNode(attr);
1499                 fDTDTypes.insertElementAt(attrType, index);
1500                 fAugmentations.insertElementAt(new AugmentationsImpl(), index);
1501                 attr.setSpecified(false);
1502             }
1503             else {
1504                 // default attribute is in the tree
1505                 // we don&#39;t need to do anything since prefix was already fixed
1506                 // at the namespace fixup time and value must be same value, otherwise
1507                 // attribute will be treated as specified and we will never reach
1508                 // this method.
1509 
1510             }
1511             return index;
1512         }
1513 
1514 
1515         public void removeAllAttributes(){
1516             // REVISIT: implement
1517         }
1518 
1519 
1520         public void removeAttributeAt(int attrIndex){
1521             // REVISIT: implement
1522         }
1523 
1524 
1525         public int getLength(){
1526             return(fAttributes != null)?fAttributes.getLength():0;
1527         }
1528 
1529 
1530         public int getIndex(String qName){
1531             // REVISIT: implement
1532             return -1;
1533         }
1534 
1535         public int getIndex(String uri, String localPart) {
1536             // REVISIT: implement
1537             return -1;
1538         }
1539 
1540         public void setName(int attrIndex, QName attrName) {
1541             // REVISIT: implement
1542         }
1543 
1544         public void getName(int attrIndex, QName attrName) {
1545             if (fAttributes != null) {
1546                 updateQName((Node)fAttributes.getItem(attrIndex), attrName);
1547             }
1548         }
1549 
1550         public String getPrefix(int index) {
1551             if (fAttributes != null) {
1552                 Node node = (Node) fAttributes.getItem(index);
1553                 String prefix = node.getPrefix();
1554                 prefix = (prefix != null &amp;&amp; prefix.length() != 0) ? fSymbolTable.addSymbol(prefix) : null;
1555                 return prefix;
1556             }
1557             return null;
1558         }
1559 
1560         public String getURI(int index) {
1561             if (fAttributes != null) {
1562                 Node node = (Node) fAttributes.getItem(index);
1563                 String namespace = node.getNamespaceURI();
1564                 namespace = (namespace != null) ? fSymbolTable.addSymbol(namespace) : null;
1565                 return namespace;
1566             }
1567             return null;
1568         }
1569 
1570 
1571         public String getLocalName(int index) {
1572             if (fAttributes != null) {
1573                 Node node = (Node) fAttributes.getItem(index);
1574                 String localName = node.getLocalName();
1575                 localName = (localName != null) ? fSymbolTable.addSymbol(localName) : null;
1576                 return localName;
1577             }
1578             return null;
1579         }
1580 
1581         public String getQName(int index) {
1582             if (fAttributes != null) {
1583                 Node node = (Node) fAttributes.getItem(index);
1584                 String rawname = fSymbolTable.addSymbol(node.getNodeName());
1585                 return rawname;
1586             }
1587             return null;
1588         }
1589 
1590          public QName getQualifiedName(int index){
1591             //return fAttributes.item(index).ge);
1592             return null;
1593         }
1594 
1595         public void setType(int attrIndex, String attrType) {
1596             fDTDTypes.setElementAt(attrType, attrIndex);
1597         }
1598 
1599         public String getType(int index) {
1600             String type = fDTDTypes.elementAt(index);
1601             return (type != null) ? getReportableType(type) : &quot;CDATA&quot;;
1602         }
1603 
1604         public String getType(String qName) {
1605             return &quot;CDATA&quot;;
1606         }
1607 
1608         public String getType(String uri, String localName) {
1609             return &quot;CDATA&quot;;
1610         }
1611 
1612         private String getReportableType(String type) {
1613             if (type.charAt(0) == &#39;(&#39;) {
1614                 return &quot;NMTOKEN&quot;;
1615             }
1616             return type;
1617         }
1618 
1619         public void setValue(int attrIndex, String attrValue) {
1620             // REVISIT: is this desired behaviour?
1621             // The values are updated in the case datatype-normalization is turned on
1622             // in this case we need to make sure that specified attributes stay specified
1623 
1624             if (fAttributes != null){
1625                 AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1626                 boolean specified = attr.getSpecified();
1627                 attr.setValue(attrValue);
1628                 attr.setSpecified(specified);
1629 
1630             }
1631         }
1632 
1633         public  void setValue(int attrIndex, String attrValue, XMLString value){
1634             setValue(attrIndex, value.toString());
1635         }
1636 
1637         public String getValue(int index){
1638             return (fAttributes !=null)?fAttributes.item(index).getNodeValue():&quot;&quot;;
1639 
1640         }
1641 
1642         public String getValue(String qName){
1643             // REVISIT: implement
1644             return null;
1645         }
1646 
1647         public String getValue(String uri, String localName){
1648             if (fAttributes != null) {
1649                 Node node =  fAttributes.getNamedItemNS(uri, localName);
1650                 return(node != null)? node.getNodeValue():null;
1651             }
1652             return null;
1653         }
1654 
1655         public void setNonNormalizedValue(int attrIndex, String attrValue){
1656             // REVISIT: implement
1657 
1658         }
1659 
1660         public String getNonNormalizedValue(int attrIndex){
1661             // REVISIT: implement
1662             return null;
1663         }
1664 
1665         public void setSpecified(int attrIndex, boolean specified){
1666             AttrImpl attr = (AttrImpl)fAttributes.getItem(attrIndex);
1667             attr.setSpecified(specified);
1668         }
1669 
1670         public boolean isSpecified(int attrIndex){
1671             return((Attr)fAttributes.getItem(attrIndex)).getSpecified();
1672         }
1673 
1674         public Augmentations getAugmentations (int attributeIndex){
1675             return fAugmentations.elementAt(attributeIndex);
1676         }
1677 
1678         public Augmentations getAugmentations (String uri, String localPart){
1679             // REVISIT: implement
1680             return null;
1681         }
1682 
1683         public Augmentations getAugmentations(String qName){
1684             // REVISIT: implement
1685             return null;
1686         }
1687 
1688         /**
1689          * Sets the augmentations of the attribute at the specified index.
1690          *
1691          * @param attrIndex The attribute index.
1692          * @param augs      The augmentations.
1693          */
1694         public void setAugmentations(int attrIndex, Augmentations augs) {
1695             fAugmentations.setElementAt(augs, attrIndex);
1696         }
1697     }
1698 
1699     //
1700     // XMLDocumentHandler methods
1701     //
1702 
1703     /**
1704      * The start of the document.
1705      *
1706      * @param locator  The document locator, or null if the document
1707      *                 location cannot be reported during the parsing
1708      *                 of this document. However, it is &lt;em&gt;strongly&lt;/em&gt;
1709      *                 recommended that a locator be supplied that can
1710      *                 at least report the system identifier of the
1711      *                 document.
1712      * @param encoding The auto-detected IANA encoding name of the entity
1713      *                 stream. This value will be null in those situations
1714      *                 where the entity encoding is not auto-detected (e.g.
1715      *                 internal entities or a document entity that is
1716      *                 parsed from a java.io.Reader).
1717      * @param namespaceContext
1718      *                 The namespace context in effect at the
1719      *                 start of this document.
1720      *                 This object represents the current context.
1721      *                 Implementors of this class are responsible
1722      *                 for copying the namespace bindings from the
1723      *                 the current context (and its parent contexts)
1724      *                 if that information is important.
1725      *
1726      * @param augs     Additional information that may include infoset augmentations
1727      * @exception XNIException
1728      *                   Thrown by handler to signal an error.
1729      */
1730     public void startDocument(XMLLocator locator, String encoding,
1731                               NamespaceContext namespaceContext,
1732                               Augmentations augs)
1733         throws XNIException{
1734     }
1735 
1736     /**
1737      * Notifies of the presence of an XMLDecl line in the document. If
1738      * present, this method will be called immediately following the
1739      * startDocument call.
1740      *
1741      * @param version    The XML version.
1742      * @param encoding   The IANA encoding name of the document, or null if
1743      *                   not specified.
1744      * @param standalone The standalone value, or null if not specified.
1745      * @param augs       Additional information that may include infoset augmentations
1746      *
1747      * @exception XNIException
1748      *                   Thrown by handler to signal an error.
1749      */
1750     public void xmlDecl(String version, String encoding, String standalone, Augmentations augs)
1751         throws XNIException{
1752     }
1753 
1754     /**
1755      * Notifies of the presence of the DOCTYPE line in the document.
1756      *
1757      * @param rootElement
1758      *                 The name of the root element.
1759      * @param publicId The public identifier if an external DTD or null
1760      *                 if the external DTD is specified using SYSTEM.
1761      * @param systemId The system identifier if an external DTD, null
1762      *                 otherwise.
1763      * @param augs     Additional information that may include infoset augmentations
1764      *
1765      * @exception XNIException
1766      *                   Thrown by handler to signal an error.
1767      */
1768     public void doctypeDecl(String rootElement, String publicId, String systemId, Augmentations augs)
1769         throws XNIException{
1770     }
1771 
1772     /**
1773      * A comment.
1774      *
1775      * @param text   The text in the comment.
1776      * @param augs   Additional information that may include infoset augmentations
1777      *
1778      * @exception XNIException
1779      *                   Thrown by application to signal an error.
1780      */
1781     public void comment(XMLString text, Augmentations augs) throws XNIException{
1782     }
1783 
1784     /**
1785      * A processing instruction. Processing instructions consist of a
1786      * target name and, optionally, text data. The data is only meaningful
1787      * to the application.
1788      * &lt;p&gt;
1789      * Typically, a processing instruction&#39;s data will contain a series
1790      * of pseudo-attributes. These pseudo-attributes follow the form of
1791      * element attributes but are &lt;strong&gt;not&lt;/strong&gt; parsed or presented
1792      * to the application as anything other than text. The application is
1793      * responsible for parsing the data.
1794      *
1795      * @param target The target.
1796      * @param data   The data or null if none specified.
1797      * @param augs   Additional information that may include infoset augmentations
1798      *
1799      * @exception XNIException
1800      *                   Thrown by handler to signal an error.
1801      */
1802     public void processingInstruction(String target, XMLString data, Augmentations augs)
1803         throws XNIException{
1804     }
1805 
1806     /**
1807      * The start of an element.
1808      *
1809      * @param element    The name of the element.
1810      * @param attributes The element attributes.
1811      * @param augs       Additional information that may include infoset augmentations
1812      *
1813      * @exception XNIException
1814      *                   Thrown by handler to signal an error.
1815      */
1816     public void startElement(QName element, XMLAttributes attributes, Augmentations augs)
1817         throws XNIException {
1818         Element currentElement = (Element) fCurrentNode;
1819         int attrCount = attributes.getLength();
1820         if (DEBUG_EVENTS) {
1821             System.out.println(&quot;==&gt;startElement: &quot; +element+
1822                     &quot; attrs.length=&quot;+attrCount);
1823         }
1824 
1825         for (int i = 0; i &lt; attrCount; i++) {
1826             attributes.getName(i, fAttrQName);
1827             Attr attr = null;
1828 
1829             attr = currentElement.getAttributeNodeNS(fAttrQName.uri, fAttrQName.localpart);
1830             if (attr == null) {
1831                 // Must be a non-namespace aware DOM Level 1 node.
1832                 attr = currentElement.getAttributeNode(fAttrQName.rawname);
1833             }
1834             AttributePSVI attrPSVI =
1835                 (AttributePSVI) attributes.getAugmentations(i).getItem(Constants.ATTRIBUTE_PSVI);
1836 
1837             if (attrPSVI != null) {
1838                 //REVISIT: instead we should be using augmentations:
1839                 // to set/retrieve Id attributes
1840                 XSTypeDefinition decl = attrPSVI.getMemberTypeDefinition();
1841                 boolean id = false;
1842                 if (decl != null) {
1843                     id = ((XSSimpleType)decl).isIDType();
1844                 }
1845                 else {
1846                     decl = attrPSVI.getTypeDefinition();
1847                     if (decl != null) {
1848                         id = ((XSSimpleType)decl).isIDType();
1849                     }
1850                 }
1851                 if (id) {
1852                     ((ElementImpl)currentElement).setIdAttributeNode(attr, true);
1853                 }
1854 
1855                 if (fPSVI) {
1856                     ((PSVIAttrNSImpl) attr).setPSVI(attrPSVI);
1857                 }
1858 
1859                 // Updating the TypeInfo for this attribute.
1860                 ((AttrImpl) attr).setType(decl);
1861 
1862                 if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {
1863                     // datatype-normalization
1864                     // NOTE: The specified value MUST be set after we set
1865                     //       the node value because that turns the &quot;specified&quot;
1866                     //       flag to &quot;true&quot; which may overwrite a &quot;false&quot;
1867                     //       value from the attribute list.
1868                     final String normalizedValue = attrPSVI.getSchemaValue().getNormalizedValue();
1869                     if (normalizedValue != null) {
1870                         boolean specified = attr.getSpecified();
1871                         attr.setValue(normalizedValue);
1872                         if (!specified) {
1873                             ((AttrImpl) attr).setSpecified(specified);
1874                         }
1875                     }
1876                 }
1877             }
1878             else { // DTD
1879                 String type = null;
1880                 boolean isDeclared = Boolean.TRUE.equals(attributes.getAugmentations(i).getItem (Constants.ATTRIBUTE_DECLARED));
1881                 // For DOM Level 3 TypeInfo, the type name must
1882                 // be null if this attribute has not been declared
1883                 // in the DTD.
1884                 if (isDeclared) {
1885                     type = attributes.getType(i);
1886                     if (&quot;ID&quot;.equals (type)) {
1887                         ((ElementImpl) currentElement).setIdAttributeNode(attr, true);
1888                     }
1889                 }
1890                 // Updating the TypeInfo for this attribute.
1891                 ((AttrImpl) attr).setType(type);
1892             }
1893         }
1894     }
1895 
1896 
1897     /**
1898      * An empty element.
1899      *
1900      * @param element    The name of the element.
1901      * @param attributes The element attributes.
1902      * @param augs       Additional information that may include infoset augmentations
1903      *
1904      * @exception XNIException
1905      *                   Thrown by handler to signal an error.
1906      */
1907         public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs)
1908                 throws XNIException {
1909         if (DEBUG_EVENTS) {
1910             System.out.println(&quot;==&gt;emptyElement: &quot; +element);
1911         }
1912 
1913                 startElement(element, attributes, augs);
1914         endElement(element, augs);
1915         }
1916 
1917     /**
1918      * This method notifies the start of a general entity.
1919      * &lt;p&gt;
1920      * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
1921      * appearing as part of attribute values.
1922      *
1923      * @param name     The name of the general entity.
1924      * @param identifier The resource identifier.
1925      * @param encoding The auto-detected IANA encoding name of the entity
1926      *                 stream. This value will be null in those situations
1927      *                 where the entity encoding is not auto-detected (e.g.
1928      *                 internal entities or a document entity that is
1929      *                 parsed from a java.io.Reader).
1930      * @param augs     Additional information that may include infoset augmentations
1931      *
1932      * @exception XNIException Thrown by handler to signal an error.
1933      */
1934     public void startGeneralEntity(String name,
1935                                    XMLResourceIdentifier identifier,
1936                                    String encoding,
1937                                    Augmentations augs) throws XNIException{
1938     }
1939 
1940     /**
1941      * Notifies of the presence of a TextDecl line in an entity. If present,
1942      * this method will be called immediately following the startEntity call.
1943      * &lt;p&gt;
1944      * &lt;strong&gt;Note:&lt;/strong&gt; This method will never be called for the
1945      * document entity; it is only called for external general entities
1946      * referenced in document content.
1947      * &lt;p&gt;
1948      * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
1949      * appearing as part of attribute values.
1950      *
1951      * @param version  The XML version, or null if not specified.
1952      * @param encoding The IANA encoding name of the entity.
1953      * @param augs     Additional information that may include infoset augmentations
1954      *
1955      * @exception XNIException
1956      *                   Thrown by handler to signal an error.
1957      */
1958     public void textDecl(String version, String encoding, Augmentations augs) throws XNIException{
1959     }
1960 
1961     /**
1962      * This method notifies the end of a general entity.
1963      * &lt;p&gt;
1964      * &lt;strong&gt;Note:&lt;/strong&gt; This method is not called for entity references
1965      * appearing as part of attribute values.
1966      *
1967      * @param name   The name of the entity.
1968      * @param augs   Additional information that may include infoset augmentations
1969      *
1970      * @exception XNIException
1971      *                   Thrown by handler to signal an error.
1972      */
1973     public void endGeneralEntity(String name, Augmentations augs) throws XNIException{
1974     }
1975 
1976     /**
1977      * Character content.
1978      *
1979      * @param text   The content.
1980      * @param augs   Additional information that may include infoset augmentations
1981      *
1982      * @exception XNIException
1983      *                   Thrown by handler to signal an error.
1984      */
1985     public void characters(XMLString text, Augmentations augs) throws XNIException{
1986     }
1987 
1988     /**
1989      * Ignorable whitespace. For this method to be called, the document
1990      * source must have some way of determining that the text containing
1991      * only whitespace characters should be considered ignorable. For
1992      * example, the validator can determine if a length of whitespace
1993      * characters in the document are ignorable based on the element
1994      * content model.
1995      *
1996      * @param text   The ignorable whitespace.
1997      * @param augs   Additional information that may include infoset augmentations
1998      *
1999      * @exception XNIException
2000      *                   Thrown by handler to signal an error.
2001      */
2002     public void ignorableWhitespace(XMLString text, Augmentations augs) throws XNIException{
2003         fAllWhitespace = true;
2004     }
2005 
2006     /**
2007      * The end of an element.
2008      *
2009      * @param element The name of the element.
2010      * @param augs    Additional information that may include infoset augmentations
2011      *
2012      * @exception XNIException
2013      *                   Thrown by handler to signal an error.
2014      */
2015     public void endElement(QName element, Augmentations augs) throws XNIException {
2016         if (DEBUG_EVENTS) {
2017             System.out.println(&quot;==&gt;endElement: &quot; + element);
2018         }
2019 
2020         if (augs != null) {
2021             ElementPSVI elementPSVI = (ElementPSVI) augs.getItem(Constants.ELEMENT_PSVI);
2022             if (elementPSVI != null) {
2023                 ElementImpl elementNode = (ElementImpl) fCurrentNode;
2024                 if (fPSVI) {
2025                     ((PSVIElementNSImpl) fCurrentNode).setPSVI(elementPSVI);
2026                 }
2027                 // Updating the TypeInfo for this element.
2028                 if (elementNode instanceof ElementNSImpl) {
2029                     XSTypeDefinition type = elementPSVI.getMemberTypeDefinition();
2030                     if (type == null) {
2031                         type = elementPSVI.getTypeDefinition();
2032                     }
2033                     ((ElementNSImpl) elementNode).setType(type);
2034                 }
2035                 // include element default content (if one is available)
2036                 String normalizedValue = elementPSVI.getSchemaValue().getNormalizedValue();
2037                 if ((fConfiguration.features &amp; DOMConfigurationImpl.DTNORMALIZATION) != 0) {
2038                     if (normalizedValue !=null)
2039                         elementNode.setTextContent(normalizedValue);
2040                 }
2041                 else {
2042                     // NOTE: this is a hack: it is possible that DOM had an empty element
2043                     // and validator sent default value using characters(), which we don&#39;t
2044                     // implement. Thus, here we attempt to add the default value.
2045                     String text = elementNode.getTextContent();
2046                     if (text.length() == 0) {
2047                         // default content could be provided
2048                         if (normalizedValue !=null)
2049                             elementNode.setTextContent(normalizedValue);
2050                     }
2051                 }
2052                 return;
2053             }
2054         }
2055         // DTD; elements have no type.
2056         if (fCurrentNode instanceof ElementNSImpl) {
2057             ((ElementNSImpl) fCurrentNode).setType(null);
2058         }
2059     }
2060 
2061 
2062     /**
2063      * The start of a CDATA section.
2064      *
2065      * @param augs   Additional information that may include infoset augmentations
2066      *
2067      * @exception XNIException
2068      *                   Thrown by handler to signal an error.
2069      */
2070     public void startCDATA(Augmentations augs) throws XNIException{
2071     }
2072 
2073     /**
2074      * The end of a CDATA section.
2075      *
2076      * @param augs   Additional information that may include infoset augmentations
2077      *
2078      * @exception XNIException
2079      *                   Thrown by handler to signal an error.
2080      */
2081     public void endCDATA(Augmentations augs) throws XNIException{
2082     }
2083 
2084     /**
2085      * The end of the document.
2086      *
2087      * @param augs   Additional information that may include infoset augmentations
2088      *
2089      * @exception XNIException
2090      *                   Thrown by handler to signal an error.
2091      */
2092     public void endDocument(Augmentations augs) throws XNIException{
2093     }
2094 
2095 
2096     /** Sets the document source. */
2097     public void setDocumentSource(XMLDocumentSource source){
2098     }
2099 
2100 
2101     /** Returns the document source. */
2102     public XMLDocumentSource getDocumentSource(){
2103         return null;
2104     }
2105 
2106 }  // DOMNormalizer class
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/xpath/internal/compiler/XPathParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xpath.internal.compiler;
  22 
  23 import javax.xml.transform.ErrorListener;
  24 import javax.xml.transform.TransformerException;
  25 
  26 import com.sun.org.apache.xalan.internal.res.XSLMessages;
  27 import com.sun.org.apache.xml.internal.utils.PrefixResolver;
  28 import com.sun.org.apache.xpath.internal.XPathProcessorException;
  29 import com.sun.org.apache.xpath.internal.objects.XNumber;
  30 import com.sun.org.apache.xpath.internal.objects.XString;
  31 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
  32 
  33 /**
  34  * Tokenizes and parses XPath expressions. This should really be named
  35  * XPathParserImpl, and may be renamed in the future.
  36  * @xsl.usage general
  37  */
  38 public class XPathParser
  39 {
  40         // %REVIEW% Is there a better way of doing this?
  41         // Upside is minimum object churn. Downside is that we don&#39;t have a useful
  42         // backtrace in the exception itself -- but we don&#39;t expect to need one.
  43         static public final String CONTINUE_AFTER_FATAL_ERROR=&quot;CONTINUE_AFTER_FATAL_ERROR&quot;;
  44 
  45   /**
  46    * The XPath to be processed.
  47    */
  48   private OpMap m_ops;
  49 
  50   /**
  51    * The next token in the pattern.
  52    */
  53   transient String m_token;
  54 
  55   /**
  56    * The first char in m_token, the theory being that this
  57    * is an optimization because we won&#39;t have to do charAt(0) as
  58    * often.
  59    */
  60   transient char m_tokenChar = 0;
  61 
  62   /**
  63    * The position in the token queue is tracked by m_queueMark.
  64    */
  65   int m_queueMark = 0;
  66 
  67   /**
  68    * Results from checking FilterExpr syntax
  69    */
  70   protected final static int FILTER_MATCH_FAILED     = 0;
  71   protected final static int FILTER_MATCH_PRIMARY    = 1;
  72   protected final static int FILTER_MATCH_PREDICATES = 2;
  73 
  74   /**
  75    * The parser constructor.
  76    */
  77   public XPathParser(ErrorListener errorListener, javax.xml.transform.SourceLocator sourceLocator)
  78   {
  79     m_errorListener = errorListener;
  80     m_sourceLocator = sourceLocator;
  81   }
  82 
  83   /**
  84    * The prefix resolver to map prefixes to namespaces in the OpMap.
  85    */
  86   PrefixResolver m_namespaceContext;
  87 
  88   /**
  89    * Given an string, init an XPath object for selections,
  90    * in order that a parse doesn&#39;t
  91    * have to be done each time the expression is evaluated.
  92    *
  93    * @param compiler The compiler object.
  94    * @param expression A string conforming to the XPath grammar.
  95    * @param namespaceContext An object that is able to resolve prefixes in
  96    * the XPath to namespaces.
  97    *
  98    * @throws javax.xml.transform.TransformerException
  99    */
 100   public void initXPath(
 101           Compiler compiler, String expression, PrefixResolver namespaceContext)
 102             throws javax.xml.transform.TransformerException
 103   {
 104 
 105     m_ops = compiler;
 106     m_namespaceContext = namespaceContext;
 107     m_functionTable = compiler.getFunctionTable();
 108 
 109     Lexer lexer = new Lexer(compiler, namespaceContext, this);
 110 
 111     lexer.tokenize(expression);
 112 
 113     m_ops.setOp(0,OpCodes.OP_XPATH);
 114     m_ops.setOp(OpMap.MAPINDEX_LENGTH,2);
 115 
 116 
 117         // Patch for Christine&#39;s gripe. She wants her errorHandler to return from
 118         // a fatal error and continue trying to parse, rather than throwing an exception.
 119         // Without the patch, that put us into an endless loop.
 120         //
 121         // %REVIEW% Is there a better way of doing this?
 122         // %REVIEW% Are there any other cases which need the safety net?
 123         //      (and if so do we care right now, or should we rewrite the XPath
 124         //      grammar engine and can fix it at that time?)
 125         try {
 126 
 127       nextToken();
 128       Expr();
 129 
 130       if (null != m_token)
 131       {
 132         String extraTokens = &quot;&quot;;
 133 
 134         while (null != m_token)
 135         {
 136           extraTokens += &quot;&#39;&quot; + m_token + &quot;&#39;&quot;;
 137 
 138           nextToken();
 139 
 140           if (null != m_token)
 141             extraTokens += &quot;, &quot;;
 142         }
 143 
 144         error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
 145               new Object[]{ extraTokens });  //&quot;Extra illegal tokens: &quot;+extraTokens);
 146       }
 147 
 148     }
 149     catch (com.sun.org.apache.xpath.internal.XPathProcessorException e)
 150     {
 151           if(CONTINUE_AFTER_FATAL_ERROR.equals(e.getMessage()))
 152           {
 153                 // What I _want_ to do is null out this XPath.
 154                 // I doubt this has the desired effect, but I&#39;m not sure what else to do.
 155                 // %REVIEW%!!!
 156                 initXPath(compiler, &quot;/..&quot;,  namespaceContext);
 157           }
 158           else
 159                 throw e;
 160     }
 161 
 162     compiler.shrink();
 163   }
 164 
 165   /**
 166    * Given an string, init an XPath object for pattern matches,
 167    * in order that a parse doesn&#39;t
 168    * have to be done each time the expression is evaluated.
 169    * @param compiler The XPath object to be initialized.
 170    * @param expression A String representing the XPath.
 171    * @param namespaceContext An object that is able to resolve prefixes in
 172    * the XPath to namespaces.
 173    *
 174    * @throws javax.xml.transform.TransformerException
 175    */
 176   public void initMatchPattern(
 177           Compiler compiler, String expression, PrefixResolver namespaceContext)
 178             throws javax.xml.transform.TransformerException
 179   {
 180 
 181     m_ops = compiler;
 182     m_namespaceContext = namespaceContext;
 183     m_functionTable = compiler.getFunctionTable();
 184 
 185     Lexer lexer = new Lexer(compiler, namespaceContext, this);
 186 
 187     lexer.tokenize(expression);
 188 
 189     m_ops.setOp(0, OpCodes.OP_MATCHPATTERN);
 190     m_ops.setOp(OpMap.MAPINDEX_LENGTH, 2);
 191 
 192     nextToken();
 193     Pattern();
 194 
 195     if (null != m_token)
 196     {
 197       String extraTokens = &quot;&quot;;
 198 
 199       while (null != m_token)
 200       {
 201         extraTokens += &quot;&#39;&quot; + m_token + &quot;&#39;&quot;;
 202 
 203         nextToken();
 204 
 205         if (null != m_token)
 206           extraTokens += &quot;, &quot;;
 207       }
 208 
 209       error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
 210             new Object[]{ extraTokens });  //&quot;Extra illegal tokens: &quot;+extraTokens);
 211     }
 212 
 213     // Terminate for safety.
 214     m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
 215     m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH)+1);
 216 
 217     m_ops.shrink();
 218   }
 219 
 220   /** The error listener where syntax errors are to be sent.
 221    */
 222   private ErrorListener m_errorListener;
 223 
 224   /** The source location of the XPath. */
 225   javax.xml.transform.SourceLocator m_sourceLocator;
 226 
 227   /** The table contains build-in functions and customized functions */
 228   private FunctionTable m_functionTable;
 229 
 230   /**
 231    * Allow an application to register an error event handler, where syntax
 232    * errors will be sent.  If the error listener is not set, syntax errors
 233    * will be sent to System.err.
 234    *
 235    * @param handler Reference to error listener where syntax errors will be
 236    *                sent.
 237    */
 238   public void setErrorHandler(ErrorListener handler)
 239   {
 240     m_errorListener = handler;
 241   }
 242 
 243   /**
 244    * Return the current error listener.
 245    *
 246    * @return The error listener, which should not normally be null, but may be.
 247    */
 248   public ErrorListener getErrorListener()
 249   {
 250     return m_errorListener;
 251   }
 252 
 253   /**
 254    * Check whether m_token matches the target string.
 255    *
 256    * @param s A string reference or null.
 257    *
 258    * @return If m_token is null, returns false (or true if s is also null), or
 259    * return true if the current token matches the string, else false.
 260    */
 261   final boolean tokenIs(String s)
 262   {
 263     return (m_token != null) ? (m_token.equals(s)) : (s == null);
 264   }
 265 
 266   /**
 267    * Check whether m_tokenChar==c.
 268    *
 269    * @param c A character to be tested.
 270    *
 271    * @return If m_token is null, returns false, or return true if c matches
 272    *         the current token.
 273    */
 274   final boolean tokenIs(char c)
 275   {
 276     return (m_token != null) ? (m_tokenChar == c) : false;
 277   }
 278 
 279   /**
 280    * Look ahead of the current token in order to
 281    * make a branching decision.
 282    *
 283    * @param c the character to be tested for.
 284    * @param n number of tokens to look ahead.  Must be
 285    * greater than 1.
 286    *
 287    * @return true if the next token matches the character argument.
 288    */
 289   final boolean lookahead(char c, int n)
 290   {
 291 
 292     int pos = (m_queueMark + n);
 293     boolean b;
 294 
 295     if ((pos &lt;= m_ops.getTokenQueueSize()) &amp;&amp; (pos &gt; 0)
 296             &amp;&amp; (m_ops.getTokenQueueSize() != 0))
 297     {
 298       String tok = ((String) m_ops.m_tokenQueue.elementAt(pos - 1));
 299 
 300       b = (tok.length() == 1) ? (tok.charAt(0) == c) : false;
 301     }
 302     else
 303     {
 304       b = false;
 305     }
 306 
 307     return b;
 308   }
 309 
 310   /**
 311    * Look behind the first character of the current token in order to
 312    * make a branching decision.
 313    *
 314    * @param c the character to compare it to.
 315    * @param n number of tokens to look behind.  Must be
 316    * greater than 1.  Note that the look behind terminates
 317    * at either the beginning of the string or on a &#39;|&#39;
 318    * character.  Because of this, this method should only
 319    * be used for pattern matching.
 320    *
 321    * @return true if the token behind the current token matches the character
 322    *         argument.
 323    */
 324   private final boolean lookbehind(char c, int n)
 325   {
 326 
 327     boolean isToken;
 328     int lookBehindPos = m_queueMark - (n + 1);
 329 
 330     if (lookBehindPos &gt;= 0)
 331     {
 332       String lookbehind = (String) m_ops.m_tokenQueue.elementAt(lookBehindPos);
 333 
 334       if (lookbehind.length() == 1)
 335       {
 336         char c0 = (lookbehind == null) ? &#39;|&#39; : lookbehind.charAt(0);
 337 
 338         isToken = (c0 == &#39;|&#39;) ? false : (c0 == c);
 339       }
 340       else
 341       {
 342         isToken = false;
 343       }
 344     }
 345     else
 346     {
 347       isToken = false;
 348     }
 349 
 350     return isToken;
 351   }
 352 
 353   /**
 354    * look behind the current token in order to
 355    * see if there is a useable token.
 356    *
 357    * @param n number of tokens to look behind.  Must be
 358    * greater than 1.  Note that the look behind terminates
 359    * at either the beginning of the string or on a &#39;|&#39;
 360    * character.  Because of this, this method should only
 361    * be used for pattern matching.
 362    *
 363    * @return true if look behind has a token, false otherwise.
 364    */
 365   private final boolean lookbehindHasToken(int n)
 366   {
 367 
 368     boolean hasToken;
 369 
 370     if ((m_queueMark - n) &gt; 0)
 371     {
 372       String lookbehind = (String) m_ops.m_tokenQueue.elementAt(m_queueMark - (n - 1));
 373       char c0 = (lookbehind == null) ? &#39;|&#39; : lookbehind.charAt(0);
 374 
 375       hasToken = (c0 == &#39;|&#39;) ? false : true;
 376     }
 377     else
 378     {
 379       hasToken = false;
 380     }
 381 
 382     return hasToken;
 383   }
 384 
 385   /**
 386    * Look ahead of the current token in order to
 387    * make a branching decision.
 388    *
 389    * @param s the string to compare it to.
 390    * @param n number of tokens to lookahead.  Must be
 391    * greater than 1.
 392    *
 393    * @return true if the token behind the current token matches the string
 394    *         argument.
 395    */
 396   private final boolean lookahead(String s, int n)
 397   {
 398 
 399     boolean isToken;
 400 
 401     if ((m_queueMark + n) &lt;= m_ops.getTokenQueueSize())
 402     {
 403       String lookahead = (String) m_ops.m_tokenQueue.elementAt(m_queueMark + (n - 1));
 404 
 405       isToken = (lookahead != null) ? lookahead.equals(s) : (s == null);
 406     }
 407     else
 408     {
 409       isToken = (null == s);
 410     }
 411 
 412     return isToken;
 413   }
 414 
 415   /**
 416    * Retrieve the next token from the command and
 417    * store it in m_token string.
 418    */
 419   private final void nextToken()
 420   {
 421 
 422     if (m_queueMark &lt; m_ops.getTokenQueueSize())
 423     {
 424       m_token = (String) m_ops.m_tokenQueue.elementAt(m_queueMark++);
 425       m_tokenChar = m_token.charAt(0);
 426     }
 427     else
 428     {
 429       m_token = null;
 430       m_tokenChar = 0;
 431     }
 432   }
 433 
 434   /**
 435    * Retrieve a token relative to the current token.
 436    *
 437    * @param i Position relative to current token.
 438    *
 439    * @return The string at the given index, or null if the index is out
 440    *         of range.
 441    */
 442   private final String getTokenRelative(int i)
 443   {
 444 
 445     String tok;
 446     int relative = m_queueMark + i;
 447 
 448     if ((relative &gt; 0) &amp;&amp; (relative &lt; m_ops.getTokenQueueSize()))
 449     {
 450       tok = (String) m_ops.m_tokenQueue.elementAt(relative);
 451     }
 452     else
 453     {
 454       tok = null;
 455     }
 456 
 457     return tok;
 458   }
 459 
 460   /**
 461    * Retrieve the previous token from the command and
 462    * store it in m_token string.
 463    */
 464   private final void prevToken()
 465   {
 466 
 467     if (m_queueMark &gt; 0)
 468     {
 469       m_queueMark--;
 470 
 471       m_token = (String) m_ops.m_tokenQueue.elementAt(m_queueMark);
 472       m_tokenChar = m_token.charAt(0);
 473     }
 474     else
 475     {
 476       m_token = null;
 477       m_tokenChar = 0;
 478     }
 479   }
 480 
 481   /**
 482    * Consume an expected token, throwing an exception if it
 483    * isn&#39;t there.
 484    *
 485    * @param expected The string to be expected.
 486    *
 487    * @throws javax.xml.transform.TransformerException
 488    */
 489   private final void consumeExpected(String expected)
 490           throws javax.xml.transform.TransformerException
 491   {
 492 
 493     if (tokenIs(expected))
 494     {
 495       nextToken();
 496     }
 497     else
 498     {
 499       error(XPATHErrorResources.ER_EXPECTED_BUT_FOUND, new Object[]{ expected,
 500                                                                      m_token });  //&quot;Expected &quot;+expected+&quot;, but found: &quot;+m_token);
 501 
 502           // Patch for Christina&#39;s gripe. She wants her errorHandler to return from
 503           // this error and continue trying to parse, rather than throwing an exception.
 504           // Without the patch, that put us into an endless loop.
 505                 throw new XPathProcessorException(CONTINUE_AFTER_FATAL_ERROR);
 506         }
 507   }
 508 
 509   /**
 510    * Consume an expected token, throwing an exception if it
 511    * isn&#39;t there.
 512    *
 513    * @param expected the character to be expected.
 514    *
 515    * @throws javax.xml.transform.TransformerException
 516    */
 517   private final void consumeExpected(char expected)
 518           throws javax.xml.transform.TransformerException
 519   {
 520 
 521     if (tokenIs(expected))
 522     {
 523       nextToken();
 524     }
 525     else
 526     {
 527       error(XPATHErrorResources.ER_EXPECTED_BUT_FOUND,
 528             new Object[]{ String.valueOf(expected),
 529                           m_token });  //&quot;Expected &quot;+expected+&quot;, but found: &quot;+m_token);
 530 
 531           // Patch for Christina&#39;s gripe. She wants her errorHandler to return from
 532           // this error and continue trying to parse, rather than throwing an exception.
 533           // Without the patch, that put us into an endless loop.
 534                 throw new XPathProcessorException(CONTINUE_AFTER_FATAL_ERROR);
 535     }
 536   }
 537 
 538   /**
 539    * Warn the user of a problem.
 540    *
 541    * @param msg An error msgkey that corresponds to one of the constants found
 542    *            in {@link com.sun.org.apache.xpath.internal.res.XPATHErrorResources}, which is
 543    *            a key for a format string.
 544    * @param args An array of arguments represented in the format string, which
 545    *             may be null.
 546    *
 547    * @throws TransformerException if the current ErrorListoner determines to
 548    *                              throw an exception.
 549    */
 550   void warn(String msg, Object[] args) throws TransformerException
 551   {
 552 
 553     String fmsg = XSLMessages.createXPATHWarning(msg, args);
 554     ErrorListener ehandler = this.getErrorListener();
 555 
 556     if (null != ehandler)
 557     {
 558       // TO DO: Need to get stylesheet Locator from here.
 559       ehandler.warning(new TransformerException(fmsg, m_sourceLocator));
 560     }
 561     else
 562     {
 563       // Should never happen.
 564       System.err.println(fmsg);
 565     }
 566   }
 567 
 568   /**
 569    * Notify the user of an assertion error, and probably throw an
 570    * exception.
 571    *
 572    * @param b  If false, a runtime exception will be thrown.
 573    * @param msg The assertion message, which should be informative.
 574    *
 575    * @throws RuntimeException if the b argument is false.
 576    */
 577   private void assertion(boolean b, String msg)
 578   {
 579 
 580     if (!b)
 581     {
 582       String fMsg = XSLMessages.createXPATHMessage(
 583         XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
 584         new Object[]{ msg });
 585 
 586       throw new RuntimeException(fMsg);
 587     }
 588   }
 589 
 590   /**
 591    * Notify the user of an error, and probably throw an
 592    * exception.
 593    *
 594    * @param msg An error msgkey that corresponds to one of the constants found
 595    *            in {@link com.sun.org.apache.xpath.internal.res.XPATHErrorResources}, which is
 596    *            a key for a format string.
 597    * @param args An array of arguments represented in the format string, which
 598    *             may be null.
 599    *
 600    * @throws TransformerException if the current ErrorListoner determines to
 601    *                              throw an exception.
 602    */
 603   void error(String msg, Object[] args) throws TransformerException
 604   {
 605 
 606     String fmsg = XSLMessages.createXPATHMessage(msg, args);
 607     ErrorListener ehandler = this.getErrorListener();
 608 
 609     TransformerException te = new TransformerException(fmsg, m_sourceLocator);
 610     if (null != ehandler)
 611     {
 612       // TO DO: Need to get stylesheet Locator from here.
 613       ehandler.fatalError(te);
 614     }
 615     else
 616     {
 617       // System.err.println(fmsg);
 618       throw te;
 619     }
 620   }
 621 
 622   /**
 623    * Dump the remaining token queue.
 624    * Thanks to Craig for this.
 625    *
 626    * @return A dump of the remaining token queue, which may be appended to
 627    *         an error message.
 628    */
 629   protected String dumpRemainingTokenQueue()
 630   {
 631 
 632     int q = m_queueMark;
 633     String returnMsg;
 634 
 635     if (q &lt; m_ops.getTokenQueueSize())
 636     {
 637       String msg = &quot;\n Remaining tokens: (&quot;;
 638 
 639       while (q &lt; m_ops.getTokenQueueSize())
 640       {
 641         String t = (String) m_ops.m_tokenQueue.elementAt(q++);
 642 
 643         msg += (&quot; &#39;&quot; + t + &quot;&#39;&quot;);
 644       }
 645 
 646       returnMsg = msg + &quot;)&quot;;
 647     }
 648     else
 649     {
 650       returnMsg = &quot;&quot;;
 651     }
 652 
 653     return returnMsg;
 654   }
 655 
 656   /**
 657    * Given a string, return the corresponding function token.
 658    *
 659    * @param key A local name of a function.
 660    *
 661    * @return   The function ID, which may correspond to one of the FUNC_XXX
 662    *    values found in {@link com.sun.org.apache.xpath.internal.compiler.FunctionTable}, but may
 663    *    be a value installed by an external module.
 664    */
 665   final int getFunctionToken(String key)
 666   {
 667 
 668     int tok;
 669     Integer id;
 670 
 671     try
 672     {
 673       // These are nodetests, xpathparser treats them as functions when parsing
 674       // a FilterExpr.
 675       id = Keywords.lookupNodeTest(key);
 676       if (null == id) id = m_functionTable.getFunctionID(key);
 677       tok = id;
 678     }
 679     catch (NullPointerException npe)
 680     {
 681       tok = -1;
 682     }
 683     catch (ClassCastException cce)
 684     {
 685       tok = -1;
 686     }
 687 
 688     return tok;
 689   }
 690 
 691   /**
 692    * Insert room for operation.  This will NOT set
 693    * the length value of the operation, but will update
 694    * the length value for the total expression.
 695    *
 696    * @param pos The position where the op is to be inserted.
 697    * @param length The length of the operation space in the op map.
 698    * @param op The op code to the inserted.
 699    */
 700   void insertOp(int pos, int length, int op)
 701   {
 702 
 703     int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 704 
 705     for (int i = totalLen - 1; i &gt;= pos; i--)
 706     {
 707       m_ops.setOp(i + length, m_ops.getOp(i));
 708     }
 709 
 710     m_ops.setOp(pos,op);
 711     m_ops.setOp(OpMap.MAPINDEX_LENGTH,totalLen + length);
 712   }
 713 
 714   /**
 715    * Insert room for operation.  This WILL set
 716    * the length value of the operation, and will update
 717    * the length value for the total expression.
 718    *
 719    * @param length The length of the operation.
 720    * @param op The op code to the inserted.
 721    */
 722   void appendOp(int length, int op)
 723   {
 724 
 725     int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 726 
 727     m_ops.setOp(totalLen, op);
 728     m_ops.setOp(totalLen + OpMap.MAPINDEX_LENGTH, length);
 729     m_ops.setOp(OpMap.MAPINDEX_LENGTH, totalLen + length);
 730   }
 731 
 732   // ============= EXPRESSIONS FUNCTIONS =================
 733 
 734   /**
 735    *
 736    *
 737    * Expr  ::=  OrExpr
 738    *
 739    *
 740    * @throws javax.xml.transform.TransformerException
 741    */
 742   protected void Expr() throws javax.xml.transform.TransformerException
 743   {
 744     OrExpr();
 745   }
 746 
 747   /**
 748    *
 749    *
 750    * OrExpr  ::=  AndExpr
 751    * | OrExpr &#39;or&#39; AndExpr
 752    *
 753    *
 754    * @throws javax.xml.transform.TransformerException
 755    */
 756   protected void OrExpr() throws javax.xml.transform.TransformerException
 757   {
 758 
 759     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 760 
 761     AndExpr();
 762 
 763     if ((null != m_token) &amp;&amp; tokenIs(&quot;or&quot;))
 764     {
 765       nextToken();
 766       insertOp(opPos, 2, OpCodes.OP_OR);
 767       OrExpr();
 768 
 769       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
 770         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
 771     }
 772   }
 773 
 774   /**
 775    *
 776    *
 777    * AndExpr  ::=  EqualityExpr
 778    * | AndExpr &#39;and&#39; EqualityExpr
 779    *
 780    *
 781    * @throws javax.xml.transform.TransformerException
 782    */
 783   protected void AndExpr() throws javax.xml.transform.TransformerException
 784   {
 785 
 786     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 787 
 788     EqualityExpr(-1);
 789 
 790     if ((null != m_token) &amp;&amp; tokenIs(&quot;and&quot;))
 791     {
 792       nextToken();
 793       insertOp(opPos, 2, OpCodes.OP_AND);
 794       AndExpr();
 795 
 796       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
 797         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
 798     }
 799   }
 800 
 801   /**
 802    *
 803    * @returns an Object which is either a String, a Number, a Boolean, or a vector
 804    * of nodes.
 805    *
 806    * EqualityExpr  ::=  RelationalExpr
 807    * | EqualityExpr &#39;=&#39; RelationalExpr
 808    *
 809    *
 810    * @param addPos Position where expression is to be added, or -1 for append.
 811    *
 812    * @return the position at the end of the equality expression.
 813    *
 814    * @throws javax.xml.transform.TransformerException
 815    */
 816   protected int EqualityExpr(int addPos) throws javax.xml.transform.TransformerException
 817   {
 818 
 819     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 820 
 821     if (-1 == addPos)
 822       addPos = opPos;
 823 
 824     RelationalExpr(-1);
 825 
 826     if (null != m_token)
 827     {
 828       if (tokenIs(&#39;!&#39;) &amp;&amp; lookahead(&#39;=&#39;, 1))
 829       {
 830         nextToken();
 831         nextToken();
 832         insertOp(addPos, 2, OpCodes.OP_NOTEQUALS);
 833 
 834         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
 835 
 836         addPos = EqualityExpr(addPos);
 837         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
 838           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
 839         addPos += 2;
 840       }
 841       else if (tokenIs(&#39;=&#39;))
 842       {
 843         nextToken();
 844         insertOp(addPos, 2, OpCodes.OP_EQUALS);
 845 
 846         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
 847 
 848         addPos = EqualityExpr(addPos);
 849         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
 850           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
 851         addPos += 2;
 852       }
 853     }
 854 
 855     return addPos;
 856   }
 857 
 858   /**
 859    * .
 860    * @returns an Object which is either a String, a Number, a Boolean, or a vector
 861    * of nodes.
 862    *
 863    * RelationalExpr  ::=  AdditiveExpr
 864    * | RelationalExpr &#39;&lt;&#39; AdditiveExpr
 865    * | RelationalExpr &#39;&gt;&#39; AdditiveExpr
 866    * | RelationalExpr &#39;&lt;=&#39; AdditiveExpr
 867    * | RelationalExpr &#39;&gt;=&#39; AdditiveExpr
 868    *
 869    *
 870    * @param addPos Position where expression is to be added, or -1 for append.
 871    *
 872    * @return the position at the end of the relational expression.
 873    *
 874    * @throws javax.xml.transform.TransformerException
 875    */
 876   protected int RelationalExpr(int addPos) throws javax.xml.transform.TransformerException
 877   {
 878 
 879     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 880 
 881     if (-1 == addPos)
 882       addPos = opPos;
 883 
 884     AdditiveExpr(-1);
 885 
 886     if (null != m_token)
 887     {
 888       if (tokenIs(&#39;&lt;&#39;))
 889       {
 890         nextToken();
 891 
 892         if (tokenIs(&#39;=&#39;))
 893         {
 894           nextToken();
 895           insertOp(addPos, 2, OpCodes.OP_LTE);
 896         }
 897         else
 898         {
 899           insertOp(addPos, 2, OpCodes.OP_LT);
 900         }
 901 
 902         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
 903 
 904         addPos = RelationalExpr(addPos);
 905         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
 906           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
 907         addPos += 2;
 908       }
 909       else if (tokenIs(&#39;&gt;&#39;))
 910       {
 911         nextToken();
 912 
 913         if (tokenIs(&#39;=&#39;))
 914         {
 915           nextToken();
 916           insertOp(addPos, 2, OpCodes.OP_GTE);
 917         }
 918         else
 919         {
 920           insertOp(addPos, 2, OpCodes.OP_GT);
 921         }
 922 
 923         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
 924 
 925         addPos = RelationalExpr(addPos);
 926         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
 927           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
 928         addPos += 2;
 929       }
 930     }
 931 
 932     return addPos;
 933   }
 934 
 935   /**
 936    * This has to handle construction of the operations so that they are evaluated
 937    * in pre-fix order.  So, for 9+7-6, instead of |+|9|-|7|6|, this needs to be
 938    * evaluated as |-|+|9|7|6|.
 939    *
 940    * AdditiveExpr  ::=  MultiplicativeExpr
 941    * | AdditiveExpr &#39;+&#39; MultiplicativeExpr
 942    * | AdditiveExpr &#39;-&#39; MultiplicativeExpr
 943    *
 944    *
 945    * @param addPos Position where expression is to be added, or -1 for append.
 946    *
 947    * @return the position at the end of the equality expression.
 948    *
 949    * @throws javax.xml.transform.TransformerException
 950    */
 951   protected int AdditiveExpr(int addPos) throws javax.xml.transform.TransformerException
 952   {
 953 
 954     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
 955 
 956     if (-1 == addPos)
 957       addPos = opPos;
 958 
 959     MultiplicativeExpr(-1);
 960 
 961     if (null != m_token)
 962     {
 963       if (tokenIs(&#39;+&#39;))
 964       {
 965         nextToken();
 966         insertOp(addPos, 2, OpCodes.OP_PLUS);
 967 
 968         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
 969 
 970         addPos = AdditiveExpr(addPos);
 971         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
 972           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
 973         addPos += 2;
 974       }
 975       else if (tokenIs(&#39;-&#39;))
 976       {
 977         nextToken();
 978         insertOp(addPos, 2, OpCodes.OP_MINUS);
 979 
 980         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
 981 
 982         addPos = AdditiveExpr(addPos);
 983         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
 984           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
 985         addPos += 2;
 986       }
 987     }
 988 
 989     return addPos;
 990   }
 991 
 992   /**
 993    * This has to handle construction of the operations so that they are evaluated
 994    * in pre-fix order.  So, for 9+7-6, instead of |+|9|-|7|6|, this needs to be
 995    * evaluated as |-|+|9|7|6|.
 996    *
 997    * MultiplicativeExpr  ::=  UnaryExpr
 998    * | MultiplicativeExpr MultiplyOperator UnaryExpr
 999    * | MultiplicativeExpr &#39;div&#39; UnaryExpr
1000    * | MultiplicativeExpr &#39;mod&#39; UnaryExpr
1001    * | MultiplicativeExpr &#39;quo&#39; UnaryExpr
1002    *
1003    * @param addPos Position where expression is to be added, or -1 for append.
1004    *
1005    * @return the position at the end of the equality expression.
1006    *
1007    * @throws javax.xml.transform.TransformerException
1008    */
1009   protected int MultiplicativeExpr(int addPos) throws javax.xml.transform.TransformerException
1010   {
1011 
1012     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1013 
1014     if (-1 == addPos)
1015       addPos = opPos;
1016 
1017     UnaryExpr();
1018 
1019     if (null != m_token)
1020     {
1021       if (tokenIs(&#39;*&#39;))
1022       {
1023         nextToken();
1024         insertOp(addPos, 2, OpCodes.OP_MULT);
1025 
1026         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
1027 
1028         addPos = MultiplicativeExpr(addPos);
1029         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
1030           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
1031         addPos += 2;
1032       }
1033       else if (tokenIs(&quot;div&quot;))
1034       {
1035         nextToken();
1036         insertOp(addPos, 2, OpCodes.OP_DIV);
1037 
1038         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
1039 
1040         addPos = MultiplicativeExpr(addPos);
1041         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
1042           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
1043         addPos += 2;
1044       }
1045       else if (tokenIs(&quot;mod&quot;))
1046       {
1047         nextToken();
1048         insertOp(addPos, 2, OpCodes.OP_MOD);
1049 
1050         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
1051 
1052         addPos = MultiplicativeExpr(addPos);
1053         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
1054           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
1055         addPos += 2;
1056       }
1057       else if (tokenIs(&quot;quo&quot;))
1058       {
1059         nextToken();
1060         insertOp(addPos, 2, OpCodes.OP_QUO);
1061 
1062         int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;
1063 
1064         addPos = MultiplicativeExpr(addPos);
1065         m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
1066           m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
1067         addPos += 2;
1068       }
1069     }
1070 
1071     return addPos;
1072   }
1073 
1074   /**
1075    *
1076    * UnaryExpr  ::=  UnionExpr
1077    * | &#39;-&#39; UnaryExpr
1078    *
1079    *
1080    * @throws javax.xml.transform.TransformerException
1081    */
1082   protected void UnaryExpr() throws javax.xml.transform.TransformerException
1083   {
1084 
1085     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1086     boolean isNeg = false;
1087 
1088     if (m_tokenChar == &#39;-&#39;)
1089     {
1090       nextToken();
1091       appendOp(2, OpCodes.OP_NEG);
1092 
1093       isNeg = true;
1094     }
1095 
1096     UnionExpr();
1097 
1098     if (isNeg)
1099       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1100         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1101   }
1102 
1103   /**
1104    *
1105    * StringExpr  ::=  Expr
1106    *
1107    *
1108    * @throws javax.xml.transform.TransformerException
1109    */
1110   protected void StringExpr() throws javax.xml.transform.TransformerException
1111   {
1112 
1113     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1114 
1115     appendOp(2, OpCodes.OP_STRING);
1116     Expr();
1117 
1118     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1119       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1120   }
1121 
1122   /**
1123    *
1124    *
1125    * StringExpr  ::=  Expr
1126    *
1127    *
1128    * @throws javax.xml.transform.TransformerException
1129    */
1130   protected void BooleanExpr() throws javax.xml.transform.TransformerException
1131   {
1132 
1133     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1134 
1135     appendOp(2, OpCodes.OP_BOOL);
1136     Expr();
1137 
1138     int opLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos;
1139 
1140     if (opLen == 2)
1141     {
1142       error(XPATHErrorResources.ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL, null);  //&quot;boolean(...) argument is no longer optional with 19990709 XPath draft.&quot;);
1143     }
1144 
1145     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH, opLen);
1146   }
1147 
1148   /**
1149    *
1150    *
1151    * NumberExpr  ::=  Expr
1152    *
1153    *
1154    * @throws javax.xml.transform.TransformerException
1155    */
1156   protected void NumberExpr() throws javax.xml.transform.TransformerException
1157   {
1158 
1159     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1160 
1161     appendOp(2, OpCodes.OP_NUMBER);
1162     Expr();
1163 
1164     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1165       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1166   }
1167 
1168   /**
1169    * The context of the right hand side expressions is the context of the
1170    * left hand side expression. The results of the right hand side expressions
1171    * are node sets. The result of the left hand side UnionExpr is the union
1172    * of the results of the right hand side expressions.
1173    *
1174    *
1175    * UnionExpr    ::=    PathExpr
1176    * | UnionExpr &#39;|&#39; PathExpr
1177    *
1178    *
1179    * @throws javax.xml.transform.TransformerException
1180    */
1181   protected void UnionExpr() throws javax.xml.transform.TransformerException
1182   {
1183 
1184     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1185     boolean continueOrLoop = true;
1186     boolean foundUnion = false;
1187 
1188     do
1189     {
1190       PathExpr();
1191 
1192       if (tokenIs(&#39;|&#39;))
1193       {
1194         if (false == foundUnion)
1195         {
1196           foundUnion = true;
1197 
1198           insertOp(opPos, 2, OpCodes.OP_UNION);
1199         }
1200 
1201         nextToken();
1202       }
1203       else
1204       {
1205         break;
1206       }
1207 
1208       // this.m_testForDocOrder = true;
1209     }
1210     while (continueOrLoop);
1211 
1212     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1213           m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1214   }
1215 
1216   /**
1217    * PathExpr  ::=  LocationPath
1218    * | FilterExpr
1219    * | FilterExpr &#39;/&#39; RelativeLocationPath
1220    * | FilterExpr &#39;//&#39; RelativeLocationPath
1221    *
1222    * @throws XSLProcessorException thrown if the active ProblemListener and XPathContext decide
1223    * the error condition is severe enough to halt processing.
1224    *
1225    * @throws javax.xml.transform.TransformerException
1226    */
1227   protected void PathExpr() throws javax.xml.transform.TransformerException
1228   {
1229 
1230     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1231 
1232     int filterExprMatch = FilterExpr();
1233 
1234     if (filterExprMatch != FILTER_MATCH_FAILED)
1235     {
1236       // If FilterExpr had Predicates, a OP_LOCATIONPATH opcode would already
1237       // have been inserted.
1238       boolean locationPathStarted = (filterExprMatch==FILTER_MATCH_PREDICATES);
1239 
1240       if (tokenIs(&#39;/&#39;))
1241       {
1242         nextToken();
1243 
1244         if (!locationPathStarted)
1245         {
1246           // int locationPathOpPos = opPos;
1247           insertOp(opPos, 2, OpCodes.OP_LOCATIONPATH);
1248 
1249           locationPathStarted = true;
1250         }
1251 
1252         if (!RelativeLocationPath())
1253         {
1254           // &quot;Relative location path expected following &#39;/&#39; or &#39;//&#39;&quot;
1255           error(XPATHErrorResources.ER_EXPECTED_REL_LOC_PATH, null);
1256         }
1257 
1258       }
1259 
1260       // Terminate for safety.
1261       if (locationPathStarted)
1262       {
1263         m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
1264         m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1265         m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1266           m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1267       }
1268     }
1269     else
1270     {
1271       LocationPath();
1272     }
1273   }
1274 
1275   /**
1276    *
1277    *
1278    * FilterExpr  ::=  PrimaryExpr
1279    * | FilterExpr Predicate
1280    *
1281    * @throws XSLProcessorException thrown if the active ProblemListener and XPathContext decide
1282    * the error condition is severe enough to halt processing.
1283    *
1284    * @return  FILTER_MATCH_PREDICATES, if this method successfully matched a
1285    *          FilterExpr with one or more Predicates;
1286    *          FILTER_MATCH_PRIMARY, if this method successfully matched a
1287    *          FilterExpr that was just a PrimaryExpr; or
1288    *          FILTER_MATCH_FAILED, if this method did not match a FilterExpr
1289    *
1290    * @throws javax.xml.transform.TransformerException
1291    */
1292   protected int FilterExpr() throws javax.xml.transform.TransformerException
1293   {
1294 
1295     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1296 
1297     int filterMatch;
1298 
1299     if (PrimaryExpr())
1300     {
1301       if (tokenIs(&#39;[&#39;))
1302       {
1303 
1304         // int locationPathOpPos = opPos;
1305         insertOp(opPos, 2, OpCodes.OP_LOCATIONPATH);
1306 
1307         while (tokenIs(&#39;[&#39;))
1308         {
1309           Predicate();
1310         }
1311 
1312         filterMatch = FILTER_MATCH_PREDICATES;
1313       }
1314       else
1315       {
1316         filterMatch = FILTER_MATCH_PRIMARY;
1317       }
1318     }
1319     else
1320     {
1321       filterMatch = FILTER_MATCH_FAILED;
1322     }
1323 
1324     return filterMatch;
1325 
1326     /*
1327      * if(tokenIs(&#39;[&#39;))
1328      * {
1329      *   Predicate();
1330      *   m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
1331      * }
1332      */
1333   }
1334 
1335   /**
1336    *
1337    * PrimaryExpr  ::=  VariableReference
1338    * | &#39;(&#39; Expr &#39;)&#39;
1339    * | Literal
1340    * | Number
1341    * | FunctionCall
1342    *
1343    * @return true if this method successfully matched a PrimaryExpr
1344    *
1345    * @throws javax.xml.transform.TransformerException
1346    *
1347    */
1348   protected boolean PrimaryExpr() throws javax.xml.transform.TransformerException
1349   {
1350 
1351     boolean matchFound;
1352     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1353 
1354     if ((m_tokenChar == &#39;\&#39;&#39;) || (m_tokenChar == &#39;&quot;&#39;))
1355     {
1356       appendOp(2, OpCodes.OP_LITERAL);
1357       Literal();
1358 
1359       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1360         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1361 
1362       matchFound = true;
1363     }
1364     else if (m_tokenChar == &#39;$&#39;)
1365     {
1366       nextToken();  // consume &#39;$&#39;
1367       appendOp(2, OpCodes.OP_VARIABLE);
1368       QName();
1369 
1370       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1371         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1372 
1373       matchFound = true;
1374     }
1375     else if (m_tokenChar == &#39;(&#39;)
1376     {
1377       nextToken();
1378       appendOp(2, OpCodes.OP_GROUP);
1379       Expr();
1380       consumeExpected(&#39;)&#39;);
1381 
1382       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1383         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1384 
1385       matchFound = true;
1386     }
1387     else if ((null != m_token) &amp;&amp; (((&#39;.&#39; == m_tokenChar) &amp;&amp; (m_token.length() &gt; 1) &amp;&amp; Character.isDigit(
1388             m_token.charAt(1))) || Character.isDigit(m_tokenChar)))
1389     {
1390       appendOp(2, OpCodes.OP_NUMBERLIT);
1391       Number();
1392 
1393       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1394         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1395 
1396       matchFound = true;
1397     }
1398     else if (lookahead(&#39;(&#39;, 1) || (lookahead(&#39;:&#39;, 1) &amp;&amp; lookahead(&#39;(&#39;, 3)))
1399     {
1400       matchFound = FunctionCall();
1401     }
1402     else
1403     {
1404       matchFound = false;
1405     }
1406 
1407     return matchFound;
1408   }
1409 
1410   /**
1411    *
1412    * Argument    ::=    Expr
1413    *
1414    *
1415    * @throws javax.xml.transform.TransformerException
1416    */
1417   protected void Argument() throws javax.xml.transform.TransformerException
1418   {
1419 
1420     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1421 
1422     appendOp(2, OpCodes.OP_ARGUMENT);
1423     Expr();
1424 
1425     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1426       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1427   }
1428 
1429   /**
1430    *
1431    * FunctionCall    ::=    FunctionName &#39;(&#39; ( Argument ( &#39;,&#39; Argument)*)? &#39;)&#39;
1432    *
1433    * @return true if, and only if, a FunctionCall was matched
1434    *
1435    * @throws javax.xml.transform.TransformerException
1436    */
1437   protected boolean FunctionCall() throws javax.xml.transform.TransformerException
1438   {
1439 
1440     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1441 
1442     if (lookahead(&#39;:&#39;, 1))
1443     {
1444       appendOp(4, OpCodes.OP_EXTFUNCTION);
1445 
1446       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1, m_queueMark - 1);
1447 
1448       nextToken();
1449       consumeExpected(&#39;:&#39;);
1450 
1451       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 2, m_queueMark - 1);
1452 
1453       nextToken();
1454     }
1455     else
1456     {
1457       int funcTok = getFunctionToken(m_token);
1458 
1459       if (-1 == funcTok)
1460       {
1461         error(XPATHErrorResources.ER_COULDNOT_FIND_FUNCTION,
1462               new Object[]{ m_token });  //&quot;Could not find function: &quot;+m_token+&quot;()&quot;);
1463       }
1464 
1465       switch (funcTok)
1466       {
1467       case OpCodes.NODETYPE_PI :
1468       case OpCodes.NODETYPE_COMMENT :
1469       case OpCodes.NODETYPE_TEXT :
1470       case OpCodes.NODETYPE_NODE :
1471         // Node type tests look like function calls, but they&#39;re not
1472         return false;
1473       default :
1474         appendOp(3, OpCodes.OP_FUNCTION);
1475 
1476         m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1, funcTok);
1477       }
1478 
1479       nextToken();
1480     }
1481 
1482     consumeExpected(&#39;(&#39;);
1483 
1484     while (!tokenIs(&#39;)&#39;) &amp;&amp; m_token != null)
1485     {
1486       if (tokenIs(&#39;,&#39;))
1487       {
1488         error(XPATHErrorResources.ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG, null);  //&quot;Found &#39;,&#39; but no preceding argument!&quot;);
1489       }
1490 
1491       Argument();
1492 
1493       if (!tokenIs(&#39;)&#39;))
1494       {
1495         consumeExpected(&#39;,&#39;);
1496 
1497         if (tokenIs(&#39;)&#39;))
1498         {
1499           error(XPATHErrorResources.ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
1500                 null);  //&quot;Found &#39;,&#39; but no following argument!&quot;);
1501         }
1502       }
1503     }
1504 
1505     consumeExpected(&#39;)&#39;);
1506 
1507     // Terminate for safety.
1508     m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
1509     m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1510     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1511       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1512 
1513     return true;
1514   }
1515 
1516   // ============= GRAMMAR FUNCTIONS =================
1517 
1518   /**
1519    *
1520    * LocationPath ::= RelativeLocationPath
1521    * | AbsoluteLocationPath
1522    *
1523    *
1524    * @throws javax.xml.transform.TransformerException
1525    */
1526   protected void LocationPath() throws javax.xml.transform.TransformerException
1527   {
1528 
1529     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1530 
1531     // int locationPathOpPos = opPos;
1532     appendOp(2, OpCodes.OP_LOCATIONPATH);
1533 
1534     boolean seenSlash = tokenIs(&#39;/&#39;);
1535 
1536     if (seenSlash)
1537     {
1538       appendOp(4, OpCodes.FROM_ROOT);
1539 
1540       // Tell how long the step is without the predicate
1541       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2, 4);
1542       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_ROOT);
1543 
1544       nextToken();
1545     } else if (m_token == null) {
1546       error(XPATHErrorResources.ER_EXPECTED_LOC_PATH_AT_END_EXPR, null);
1547     }
1548 
1549     if (m_token != null)
1550     {
1551       if (!RelativeLocationPath() &amp;&amp; !seenSlash)
1552       {
1553         // Neither a &#39;/&#39; nor a RelativeLocationPath - i.e., matched nothing
1554         // &quot;Location path expected, but found &quot;+m_token+&quot; was encountered.&quot;
1555         error(XPATHErrorResources.ER_EXPECTED_LOC_PATH,
1556               new Object [] {m_token});
1557       }
1558     }
1559 
1560     // Terminate for safety.
1561     m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
1562     m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1563     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1564       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1565   }
1566 
1567   /**
1568    *
1569    * RelativeLocationPath ::= Step
1570    * | RelativeLocationPath &#39;/&#39; Step
1571    * | AbbreviatedRelativeLocationPath
1572    *
1573    * @returns true if, and only if, a RelativeLocationPath was matched
1574    *
1575    * @throws javax.xml.transform.TransformerException
1576    */
1577   protected boolean RelativeLocationPath()
1578                throws javax.xml.transform.TransformerException
1579   {
1580     if (!Step())
1581     {
1582       return false;
1583     }
1584 
1585     while (tokenIs(&#39;/&#39;))
1586     {
1587       nextToken();
1588 
1589       if (!Step())
1590       {
1591         // RelativeLocationPath can&#39;t end with a trailing &#39;/&#39;
1592         // &quot;Location step expected following &#39;/&#39; or &#39;//&#39;&quot;
1593         error(XPATHErrorResources.ER_EXPECTED_LOC_STEP, null);
1594       }
1595     }
1596 
1597     return true;
1598   }
1599 
1600   /**
1601    *
1602    * Step    ::=    Basis Predicate
1603    * | AbbreviatedStep
1604    *
1605    * @returns false if step was empty (or only a &#39;/&#39;); true, otherwise
1606    *
1607    * @throws javax.xml.transform.TransformerException
1608    */
1609   protected boolean Step() throws javax.xml.transform.TransformerException
1610   {
1611     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1612 
1613     boolean doubleSlash = tokenIs(&#39;/&#39;);
1614 
1615     // At most a single &#39;/&#39; before each Step is consumed by caller; if the
1616     // first thing is a &#39;/&#39;, that means we had &#39;//&#39; and the Step must not
1617     // be empty.
1618     if (doubleSlash)
1619     {
1620       nextToken();
1621 
1622       appendOp(2, OpCodes.FROM_DESCENDANTS_OR_SELF);
1623 
1624       // Have to fix up for patterns such as &#39;//@foo&#39; or &#39;//attribute::foo&#39;,
1625       // which translate to &#39;descendant-or-self::node()/attribute::foo&#39;.
1626       // notice I leave the &#39;/&#39; on the queue, so the next will be processed
1627       // by a regular step pattern.
1628 
1629       // Make room for telling how long the step is without the predicate
1630       m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1631       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.NODETYPE_NODE);
1632       m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1633 
1634       // Tell how long the step is without the predicate
1635       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1,
1636           m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1637 
1638       // Tell how long the step is with the predicate
1639       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1640           m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1641 
1642       opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1643     }
1644 
1645     if (tokenIs(&quot;.&quot;))
1646     {
1647       nextToken();
1648 
1649       if (tokenIs(&#39;[&#39;))
1650       {
1651         error(XPATHErrorResources.ER_PREDICATE_ILLEGAL_SYNTAX, null);  //&quot;&#39;..[predicate]&#39; or &#39;.[predicate]&#39; is illegal syntax.  Use &#39;self::node()[predicate]&#39; instead.&quot;);
1652       }
1653 
1654       appendOp(4, OpCodes.FROM_SELF);
1655 
1656       // Tell how long the step is without the predicate
1657       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2,4);
1658       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_NODE);
1659     }
1660     else if (tokenIs(&quot;..&quot;))
1661     {
1662       nextToken();
1663       appendOp(4, OpCodes.FROM_PARENT);
1664 
1665       // Tell how long the step is without the predicate
1666       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2,4);
1667       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_NODE);
1668     }
1669 
1670     // There is probably a better way to test for this
1671     // transition... but it gets real hairy if you try
1672     // to do it in basis().
1673     else if (tokenIs(&#39;*&#39;) || tokenIs(&#39;@&#39;) || tokenIs(&#39;_&#39;)
1674              || (m_token!= null &amp;&amp; Character.isLetter(m_token.charAt(0))))
1675     {
1676       Basis();
1677 
1678       while (tokenIs(&#39;[&#39;))
1679       {
1680         Predicate();
1681       }
1682 
1683       // Tell how long the entire step is.
1684       m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1685         m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1686     }
1687     else
1688     {
1689       // No Step matched - that&#39;s an error if previous thing was a &#39;//&#39;
1690       if (doubleSlash)
1691       {
1692         // &quot;Location step expected following &#39;/&#39; or &#39;//&#39;&quot;
1693         error(XPATHErrorResources.ER_EXPECTED_LOC_STEP, null);
1694       }
1695 
1696       return false;
1697     }
1698 
1699     return true;
1700   }
1701 
1702   /**
1703    *
1704    * Basis    ::=    AxisName &#39;::&#39; NodeTest
1705    * | AbbreviatedBasis
1706    *
1707    * @throws javax.xml.transform.TransformerException
1708    */
1709   protected void Basis() throws javax.xml.transform.TransformerException
1710   {
1711 
1712     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1713     int axesType;
1714 
1715     // The next blocks guarantee that a FROM_XXX will be added.
1716     if (lookahead(&quot;::&quot;, 1))
1717     {
1718       axesType = AxisName();
1719 
1720       nextToken();
1721       nextToken();
1722     }
1723     else if (tokenIs(&#39;@&#39;))
1724     {
1725       axesType = OpCodes.FROM_ATTRIBUTES;
1726 
1727       appendOp(2, axesType);
1728       nextToken();
1729     }
1730     else
1731     {
1732       axesType = OpCodes.FROM_CHILDREN;
1733 
1734       appendOp(2, axesType);
1735     }
1736 
1737     // Make room for telling how long the step is without the predicate
1738     m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1739 
1740     NodeTest(axesType);
1741 
1742     // Tell how long the step is without the predicate
1743     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1,
1744       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1745    }
1746 
1747   /**
1748    *
1749    * Basis    ::=    AxisName &#39;::&#39; NodeTest
1750    * | AbbreviatedBasis
1751    *
1752    * @return FROM_XXX axes type, found in {@link com.sun.org.apache.xpath.internal.compiler.Keywords}.
1753    *
1754    * @throws javax.xml.transform.TransformerException
1755    */
1756   protected int AxisName() throws javax.xml.transform.TransformerException
1757   {
1758 
1759     Object val = Keywords.getAxisName(m_token);
1760 
1761     if (null == val)
1762     {
1763       error(XPATHErrorResources.ER_ILLEGAL_AXIS_NAME,
1764             new Object[]{ m_token });  //&quot;illegal axis name: &quot;+m_token);
1765     }
1766 
1767     int axesType = ((Integer) val).intValue();
1768 
1769     appendOp(2, axesType);
1770 
1771     return axesType;
1772   }
1773 
1774   /**
1775    *
1776    * NodeTest    ::=    WildcardName
1777    * | NodeType &#39;(&#39; &#39;)&#39;
1778    * | &#39;processing-instruction&#39; &#39;(&#39; Literal &#39;)&#39;
1779    *
1780    * @param axesType FROM_XXX axes type, found in {@link com.sun.org.apache.xpath.internal.compiler.Keywords}.
1781    *
1782    * @throws javax.xml.transform.TransformerException
1783    */
1784   protected void NodeTest(int axesType) throws javax.xml.transform.TransformerException
1785   {
1786 
1787     if (lookahead(&#39;(&#39;, 1))
1788     {
1789       Object nodeTestOp = Keywords.getNodeType(m_token);
1790 
1791       if (null == nodeTestOp)
1792       {
1793         error(XPATHErrorResources.ER_UNKNOWN_NODETYPE,
1794               new Object[]{ m_token });  //&quot;Unknown nodetype: &quot;+m_token);
1795       }
1796       else
1797       {
1798         nextToken();
1799 
1800         int nt = ((Integer) nodeTestOp).intValue();
1801 
1802         m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), nt);
1803         m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1804 
1805         consumeExpected(&#39;(&#39;);
1806 
1807         if (OpCodes.NODETYPE_PI == nt)
1808         {
1809           if (!tokenIs(&#39;)&#39;))
1810           {
1811             Literal();
1812           }
1813         }
1814 
1815         consumeExpected(&#39;)&#39;);
1816       }
1817     }
1818     else
1819     {
1820 
1821       // Assume name of attribute or element.
1822       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.NODENAME);
1823       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1824 
1825       if (lookahead(&#39;:&#39;, 1))
1826       {
1827         if (tokenIs(&#39;*&#39;))
1828         {
1829           m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ELEMWILDCARD);
1830         }
1831         else
1832         {
1833           m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
1834 
1835           // Minimalist check for an NCName - just check first character
1836           // to distinguish from other possible tokens
1837           if (!Character.isLetter(m_tokenChar) &amp;&amp; !tokenIs(&#39;_&#39;))
1838           {
1839             // &quot;Node test that matches either NCName:* or QName was expected.&quot;
1840             error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
1841           }
1842         }
1843 
1844         nextToken();
1845         consumeExpected(&#39;:&#39;);
1846       }
1847       else
1848       {
1849         m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.EMPTY);
1850       }
1851 
1852       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1853 
1854       if (tokenIs(&#39;*&#39;))
1855       {
1856         m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ELEMWILDCARD);
1857       }
1858       else
1859       {
1860         m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
1861 
1862         // Minimalist check for an NCName - just check first character
1863         // to distinguish from other possible tokens
1864         if (!Character.isLetter(m_tokenChar) &amp;&amp; !tokenIs(&#39;_&#39;))
1865         {
1866           // &quot;Node test that matches either NCName:* or QName was expected.&quot;
1867           error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
1868         }
1869       }
1870 
1871       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1872 
1873       nextToken();
1874     }
1875   }
1876 
1877   /**
1878    *
1879    * Predicate ::= &#39;[&#39; PredicateExpr &#39;]&#39;
1880    *
1881    *
1882    * @throws javax.xml.transform.TransformerException
1883    */
1884   protected void Predicate() throws javax.xml.transform.TransformerException
1885   {
1886 
1887     if (tokenIs(&#39;[&#39;))
1888     {
1889       nextToken();
1890       PredicateExpr();
1891       consumeExpected(&#39;]&#39;);
1892     }
1893   }
1894 
1895   /**
1896    *
1897    * PredicateExpr ::= Expr
1898    *
1899    *
1900    * @throws javax.xml.transform.TransformerException
1901    */
1902   protected void PredicateExpr() throws javax.xml.transform.TransformerException
1903   {
1904 
1905     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
1906 
1907     appendOp(2, OpCodes.OP_PREDICATE);
1908     Expr();
1909 
1910     // Terminate for safety.
1911     m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
1912     m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1913     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
1914       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
1915   }
1916 
1917   /**
1918    * QName ::=  (Prefix &#39;:&#39;)? LocalPart
1919    * Prefix ::=  NCName
1920    * LocalPart ::=  NCName
1921    *
1922    * @throws javax.xml.transform.TransformerException
1923    */
1924   protected void QName() throws javax.xml.transform.TransformerException
1925   {
1926     // Namespace
1927     if(lookahead(&#39;:&#39;, 1))
1928     {
1929       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
1930       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1931 
1932       nextToken();
1933       consumeExpected(&#39;:&#39;);
1934     }
1935     else
1936     {
1937       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.EMPTY);
1938       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1939     }
1940 
1941     // Local name
1942     m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
1943     m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1944 
1945     nextToken();
1946   }
1947 
1948   /**
1949    * NCName ::=  (Letter | &#39;_&#39;) (NCNameChar)
1950    * NCNameChar ::=  Letter | Digit | &#39;.&#39; | &#39;-&#39; | &#39;_&#39; | CombiningChar | Extender
1951    */
1952   protected void NCName()
1953   {
1954 
1955     m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
1956     m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1957 
1958     nextToken();
1959   }
1960 
1961   /**
1962    * The value of the Literal is the sequence of characters inside
1963    * the &quot; or &#39; characters&gt;.
1964    *
1965    * Literal  ::=  &#39;&quot;&#39; [^&quot;]* &#39;&quot;&#39;
1966    * | &quot;&#39;&quot; [^&#39;]* &quot;&#39;&quot;
1967    *
1968    *
1969    * @throws javax.xml.transform.TransformerException
1970    */
1971   protected void Literal() throws javax.xml.transform.TransformerException
1972   {
1973 
1974     int last = m_token.length() - 1;
1975     char c0 = m_tokenChar;
1976     char cX = m_token.charAt(last);
1977 
1978     if (((c0 == &#39;\&quot;&#39;) &amp;&amp; (cX == &#39;\&quot;&#39;)) || ((c0 == &#39;\&#39;&#39;) &amp;&amp; (cX == &#39;\&#39;&#39;)))
1979     {
1980 
1981       // Mutate the token to remove the quotes and have the XString object
1982       // already made.
1983       int tokenQueuePos = m_queueMark - 1;
1984 
1985       m_ops.m_tokenQueue.setElementAt(null,tokenQueuePos);
1986 
1987       Object obj = new XString(m_token.substring(1, last));
1988 
1989       m_ops.m_tokenQueue.setElementAt(obj,tokenQueuePos);
1990 
1991       // lit = m_token.substring(1, last);
1992       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), tokenQueuePos);
1993       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
1994 
1995       nextToken();
1996     }
1997     else
1998     {
1999       error(XPATHErrorResources.ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
2000             new Object[]{ m_token });  //&quot;Pattern literal (&quot;+m_token+&quot;) needs to be quoted!&quot;);
2001     }
2002   }
2003 
2004   /**
2005    *
2006    * Number ::= [0-9]+(&#39;.&#39;[0-9]+)? | &#39;.&#39;[0-9]+
2007    *
2008    *
2009    * @throws javax.xml.transform.TransformerException
2010    */
2011   protected void Number() throws javax.xml.transform.TransformerException
2012   {
2013 
2014     if (null != m_token)
2015     {
2016 
2017       // Mutate the token to remove the quotes and have the XNumber object
2018       // already made.
2019       double num;
2020 
2021       try
2022       {
2023         // XPath 1.0 does not support number in exp notation
2024         if ((m_token.indexOf(&#39;e&#39;) &gt; -1)||(m_token.indexOf(&#39;E&#39;) &gt; -1))
2025                 throw new NumberFormatException();
2026         num = Double.valueOf(m_token).doubleValue();
2027       }
2028       catch (NumberFormatException nfe)
2029       {
2030         num = 0.0;  // to shut up compiler.
2031 
2032         error(XPATHErrorResources.ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
2033               new Object[]{ m_token });  //m_token+&quot; could not be formatted to a number!&quot;);
2034       }
2035 
2036       m_ops.m_tokenQueue.setElementAt(new XNumber(num),m_queueMark - 1);
2037       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
2038       m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
2039 
2040       nextToken();
2041     }
2042   }
2043 
2044   // ============= PATTERN FUNCTIONS =================
2045 
2046   /**
2047    *
2048    * Pattern  ::=  LocationPathPattern
2049    * | Pattern &#39;|&#39; LocationPathPattern
2050    *
2051    *
2052    * @throws javax.xml.transform.TransformerException
2053    */
2054   protected void Pattern() throws javax.xml.transform.TransformerException
2055   {
2056 
2057     while (true)
2058     {
2059       LocationPathPattern();
2060 
2061       if (tokenIs(&#39;|&#39;))
2062       {
2063         nextToken();
2064       }
2065       else
2066       {
2067         break;
2068       }
2069     }
2070   }
2071 
2072   /**
2073    *
2074    *
2075    * LocationPathPattern  ::=  &#39;/&#39; RelativePathPattern?
2076    * | IdKeyPattern ((&#39;/&#39; | &#39;//&#39;) RelativePathPattern)?
2077    * | &#39;//&#39;? RelativePathPattern
2078    *
2079    *
2080    * @throws javax.xml.transform.TransformerException
2081    */
2082   protected void LocationPathPattern() throws javax.xml.transform.TransformerException
2083   {
2084 
2085     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
2086 
2087     final int RELATIVE_PATH_NOT_PERMITTED = 0;
2088     final int RELATIVE_PATH_PERMITTED     = 1;
2089     final int RELATIVE_PATH_REQUIRED      = 2;
2090 
2091     int relativePathStatus = RELATIVE_PATH_NOT_PERMITTED;
2092 
2093     appendOp(2, OpCodes.OP_LOCATIONPATHPATTERN);
2094 
2095     if (lookahead(&#39;(&#39;, 1)
2096             &amp;&amp; (tokenIs(Keywords.FUNC_ID_STRING)
2097                 || tokenIs(Keywords.FUNC_KEY_STRING)))
2098     {
2099       IdKeyPattern();
2100 
2101       if (tokenIs(&#39;/&#39;))
2102       {
2103         nextToken();
2104 
2105         if (tokenIs(&#39;/&#39;))
2106         {
2107           appendOp(4, OpCodes.MATCH_ANY_ANCESTOR);
2108 
2109           nextToken();
2110         }
2111         else
2112         {
2113           appendOp(4, OpCodes.MATCH_IMMEDIATE_ANCESTOR);
2114         }
2115 
2116         // Tell how long the step is without the predicate
2117         m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2, 4);
2118         m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_FUNCTEST);
2119 
2120         relativePathStatus = RELATIVE_PATH_REQUIRED;
2121       }
2122     }
2123     else if (tokenIs(&#39;/&#39;))
2124     {
2125       if (lookahead(&#39;/&#39;, 1))
2126       {
2127         appendOp(4, OpCodes.MATCH_ANY_ANCESTOR);
2128 
2129         // Added this to fix bug reported by Myriam for match=&quot;//x/a&quot;
2130         // patterns.  If you don&#39;t do this, the &#39;x&#39; step will think it&#39;s part
2131         // of a &#39;//&#39; pattern, and so will cause &#39;a&#39; to be matched when it has
2132         // any ancestor that is &#39;x&#39;.
2133         nextToken();
2134 
2135         relativePathStatus = RELATIVE_PATH_REQUIRED;
2136       }
2137       else
2138       {
2139         appendOp(4, OpCodes.FROM_ROOT);
2140 
2141         relativePathStatus = RELATIVE_PATH_PERMITTED;
2142       }
2143 
2144 
2145       // Tell how long the step is without the predicate
2146       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2, 4);
2147       m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_ROOT);
2148 
2149       nextToken();
2150     }
2151     else
2152     {
2153       relativePathStatus = RELATIVE_PATH_REQUIRED;
2154     }
2155 
2156     if (relativePathStatus != RELATIVE_PATH_NOT_PERMITTED)
2157     {
2158       if (!tokenIs(&#39;|&#39;) &amp;&amp; (null != m_token))
2159       {
2160         RelativePathPattern();
2161       }
2162       else if (relativePathStatus == RELATIVE_PATH_REQUIRED)
2163       {
2164         // &quot;A relative path pattern was expected.&quot;
2165         error(XPATHErrorResources.ER_EXPECTED_REL_PATH_PATTERN, null);
2166       }
2167     }
2168 
2169     // Terminate for safety.
2170     m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
2171     m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
2172     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
2173       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
2174   }
2175 
2176   /**
2177    *
2178    * IdKeyPattern  ::=  &#39;id&#39; &#39;(&#39; Literal &#39;)&#39;
2179    * | &#39;key&#39; &#39;(&#39; Literal &#39;,&#39; Literal &#39;)&#39;
2180    * (Also handle doc())
2181    *
2182    *
2183    * @throws javax.xml.transform.TransformerException
2184    */
2185   protected void IdKeyPattern() throws javax.xml.transform.TransformerException
2186   {
2187     FunctionCall();
2188   }
2189 
2190   /**
2191    *
2192    * RelativePathPattern  ::=  StepPattern
2193    * | RelativePathPattern &#39;/&#39; StepPattern
2194    * | RelativePathPattern &#39;//&#39; StepPattern
2195    *
2196    * @throws javax.xml.transform.TransformerException
2197    */
2198   protected void RelativePathPattern()
2199               throws javax.xml.transform.TransformerException
2200   {
2201 
2202     // Caller will have consumed any &#39;/&#39; or &#39;//&#39; preceding the
2203     // RelativePathPattern, so let StepPattern know it can&#39;t begin with a &#39;/&#39;
2204     boolean trailingSlashConsumed = StepPattern(false);
2205 
2206     while (tokenIs(&#39;/&#39;))
2207     {
2208       nextToken();
2209 
2210       // StepPattern() may consume first slash of pair in &quot;a//b&quot; while
2211       // processing StepPattern &quot;a&quot;.  On next iteration, let StepPattern know
2212       // that happened, so it doesn&#39;t match ill-formed patterns like &quot;a///b&quot;.
2213       trailingSlashConsumed = StepPattern(!trailingSlashConsumed);
2214     }
2215   }
2216 
2217   /**
2218    *
2219    * StepPattern  ::=  AbbreviatedNodeTestStep
2220    *
2221    * @param isLeadingSlashPermitted a boolean indicating whether a slash can
2222    *        appear at the start of this step
2223    *
2224    * @return boolean indicating whether a slash following the step was consumed
2225    *
2226    * @throws javax.xml.transform.TransformerException
2227    */
2228   protected boolean StepPattern(boolean isLeadingSlashPermitted)
2229             throws javax.xml.transform.TransformerException
2230   {
2231     return AbbreviatedNodeTestStep(isLeadingSlashPermitted);
2232   }
2233 
2234   /**
2235    *
2236    * AbbreviatedNodeTestStep    ::=    &#39;@&#39;? NodeTest Predicate
2237    *
2238    * @param isLeadingSlashPermitted a boolean indicating whether a slash can
2239    *        appear at the start of this step
2240    *
2241    * @return boolean indicating whether a slash following the step was consumed
2242    *
2243    * @throws javax.xml.transform.TransformerException
2244    */
2245   protected boolean AbbreviatedNodeTestStep(boolean isLeadingSlashPermitted)
2246             throws javax.xml.transform.TransformerException
2247   {
2248 
2249     int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
2250     int axesType;
2251 
2252     // The next blocks guarantee that a MATCH_XXX will be added.
2253     int matchTypePos = -1;
2254 
2255     if (tokenIs(&#39;@&#39;))
2256     {
2257       axesType = OpCodes.MATCH_ATTRIBUTE;
2258 
2259       appendOp(2, axesType);
2260       nextToken();
2261     }
2262     else if (this.lookahead(&quot;::&quot;, 1))
2263     {
2264       if (tokenIs(&quot;attribute&quot;))
2265       {
2266         axesType = OpCodes.MATCH_ATTRIBUTE;
2267 
2268         appendOp(2, axesType);
2269       }
2270       else if (tokenIs(&quot;child&quot;))
2271       {
2272         matchTypePos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
2273         axesType = OpCodes.MATCH_IMMEDIATE_ANCESTOR;
2274 
2275         appendOp(2, axesType);
2276       }
2277       else
2278       {
2279         axesType = -1;
2280 
2281         this.error(XPATHErrorResources.ER_AXES_NOT_ALLOWED,
2282                    new Object[]{ this.m_token });
2283       }
2284 
2285       nextToken();
2286       nextToken();
2287     }
2288     else if (tokenIs(&#39;/&#39;))
2289     {
2290       if (!isLeadingSlashPermitted)
2291       {
2292         // &quot;A step was expected in the pattern, but &#39;/&#39; was encountered.&quot;
2293         error(XPATHErrorResources.ER_EXPECTED_STEP_PATTERN, null);
2294       }
2295       axesType = OpCodes.MATCH_ANY_ANCESTOR;
2296 
2297       appendOp(2, axesType);
2298       nextToken();
2299     }
2300     else
2301     {
2302       matchTypePos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
2303       axesType = OpCodes.MATCH_IMMEDIATE_ANCESTOR;
2304 
2305       appendOp(2, axesType);
2306     }
2307 
2308     // Make room for telling how long the step is without the predicate
2309     m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
2310 
2311     NodeTest(axesType);
2312 
2313     // Tell how long the step is without the predicate
2314     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1,
2315       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
2316 
2317     while (tokenIs(&#39;[&#39;))
2318     {
2319       Predicate();
2320     }
2321 
2322     boolean trailingSlashConsumed;
2323 
2324     // For &quot;a//b&quot;, where &quot;a&quot; is current step, we need to mark operation of
2325     // current step as &quot;MATCH_ANY_ANCESTOR&quot;.  Then we&#39;ll consume the first
2326     // slash and subsequent step will be treated as a MATCH_IMMEDIATE_ANCESTOR
2327     // (unless it too is followed by &#39;//&#39;.)
2328     //
2329     // %REVIEW%  Following is what happens today, but I&#39;m not sure that&#39;s
2330     // %REVIEW%  correct behaviour.  Perhaps no valid case could be constructed
2331     // %REVIEW%  where it would matter?
2332     //
2333     // If current step is on the attribute axis (e.g., &quot;@x//b&quot;), we won&#39;t
2334     // change the current step, and let following step be marked as
2335     // MATCH_ANY_ANCESTOR on next call instead.
2336     if ((matchTypePos &gt; -1) &amp;&amp; tokenIs(&#39;/&#39;) &amp;&amp; lookahead(&#39;/&#39;, 1))
2337     {
2338       m_ops.setOp(matchTypePos, OpCodes.MATCH_ANY_ANCESTOR);
2339 
2340       nextToken();
2341 
2342       trailingSlashConsumed = true;
2343     }
2344     else
2345     {
2346       trailingSlashConsumed = false;
2347     }
2348 
2349     // Tell how long the entire step is.
2350     m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
2351       m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
2352 
2353     return trailingSlashConsumed;
2354   }
2355 }
    </pre>
  </body>
</html>
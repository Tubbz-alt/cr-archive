<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SubstitutionGroupHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="identity/XPathMatcher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/XMLSchemaValidator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2006, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.impl.xs;
  22 
</pre>
<hr />
<pre>
  94  * filter: receiving document events from the scanner; validating
  95  * the content and structure; augmenting the InfoSet, if applicable;
  96  * and notifying the parser of the information resulting from the
  97  * validation process.
  98  * &lt;p&gt;
  99  * This component requires the following features and properties from the
 100  * component manager that uses it:
 101  * &lt;ul&gt;
 102  *  &lt;li&gt;http://xml.org/sax/features/validation&lt;/li&gt;
 103  *  &lt;li&gt;http://apache.org/xml/properties/internal/symbol-table&lt;/li&gt;
 104  *  &lt;li&gt;http://apache.org/xml/properties/internal/error-reporter&lt;/li&gt;
 105  *  &lt;li&gt;http://apache.org/xml/properties/internal/entity-resolver&lt;/li&gt;
 106  * &lt;/ul&gt;
 107  *
 108  * @xerces.internal
 109  *
 110  * @author Sandy Gao IBM
 111  * @author Elena Litani IBM
 112  * @author Andy Clark IBM
 113  * @author Neeraj Bajaj, Sun Microsystems, inc.
<span class="line-modified"> 114  * @LastModified: Nov 2017</span>
 115  */
 116 public class XMLSchemaValidator
 117     implements XMLComponent, XMLDocumentFilter, FieldActivator, RevalidationHandler, XSElementDeclHelper {
 118 
 119     //
 120     // Constants
 121     //
 122     private static final boolean DEBUG = false;
 123 
 124     // feature identifiers
 125 
 126     /** Feature identifier: validation. */
 127     protected static final String VALIDATION =
 128         Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
 129 
 130     /** Feature identifier: validation. */
 131     protected static final String SCHEMA_VALIDATION =
 132         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE;
 133 
 134     /** Feature identifier: schema full checking*/
</pre>
<hr />
<pre>
2412                     IdentityConstraint id;
2413                     if ((id = selMatcher.getIdentityConstraint()) != null
2414                             &amp;&amp; id.getCategory() != IdentityConstraint.IC_KEYREF) {
2415                         fValueStoreCache.transplant(id, selMatcher.getInitialDepth());
2416                     }
2417                 }
2418             }
2419 
2420             // now handle keyref&#39;s/...
2421             for (int i = oldCount - 1; i &gt;= newCount; i--) {
2422                 XPathMatcher matcher = fMatcherStack.getMatcherAt(i);
2423                 if (matcher instanceof Selector.Matcher) {
2424                     Selector.Matcher selMatcher = (Selector.Matcher) matcher;
2425                     IdentityConstraint id;
2426                     if ((id = selMatcher.getIdentityConstraint()) != null
2427                             &amp;&amp; id.getCategory() == IdentityConstraint.IC_KEYREF) {
2428                         ValueStoreBase values =
2429                             fValueStoreCache.getValueStoreFor(id, selMatcher.getInitialDepth());
2430                         // nothing to do if nothing matched, or if not all
2431                         // fields are present.
<span class="line-modified">2432                         if (values != null &amp;&amp; values.fValuesCount == values.fFieldCount)</span>
2433                             values.endDocumentFragment();
2434                     }
2435                 }
2436             }
2437             fValueStoreCache.endElement();
2438         }
2439 
2440         // Check if we should modify the xsi:type ignore depth
2441         // This check is independent of whether this is the validation root,
2442         // and should be done before the element depth is decremented.
2443         if (fElementDepth &lt; fIgnoreXSITypeDepth) {
2444             fIgnoreXSITypeDepth--;
2445         }
2446 
2447         SchemaGrammar[] grammars = null;
2448         // have we reached the end tag of the validation root?
2449         if (fElementDepth == 0) {
2450             // 7 If the element information item is the validation root, it must be valid per Validation Root Valid (ID/IDREF) (3.3.4).
2451             Iterator&lt;String&gt; invIdRefs = fValidationState.checkIDRefID();
2452             fValidationState.resetIDTables();
</pre>
<hr />
<pre>
3701      *
3702      * @author Andy Clark, IBM
3703      */
3704     protected abstract class ValueStoreBase implements ValueStore {
3705 
3706         //
3707         // Data
3708         //
3709 
3710         /** Identity constraint. */
3711         protected IdentityConstraint fIdentityConstraint;
3712         protected int fFieldCount = 0;
3713         protected Field[] fFields = null;
3714         /** current data */
3715         protected Object[] fLocalValues = null;
3716         protected short[] fLocalValueTypes = null;
3717         protected ShortList[] fLocalItemValueTypes = null;
3718 
3719         /** Current data value count. */
3720         protected int fValuesCount;

3721 
3722         /** global data */
3723         public final Vector&lt;Object&gt; fValues = new Vector&lt;&gt;();
3724         public ShortVector fValueTypes = null;
3725         public Vector&lt;ShortList&gt; fItemValueTypes = null;
3726 
3727         private boolean fUseValueTypeVector = false;
3728         private int fValueTypesLength = 0;
3729         private short fValueType = 0;
3730 
3731         private boolean fUseItemValueTypeVector = false;
3732         private int fItemValueTypesLength = 0;
3733         private ShortList fItemValueType = null;
3734 
3735         /** buffer for error messages */
3736         final StringBuilder fTempBuffer = new StringBuilder();
3737 
3738         //
3739         // Constructors
3740         //
</pre>
<hr />
<pre>
3868             for (i = fFieldCount - 1; i &gt; -1; i--) {
3869                 if (fFields[i] == field) {
3870                     break;
3871                 }
3872             }
3873             // do we even know this field?
3874             if (i == -1) {
3875                 String code = &quot;UnknownField&quot;;
3876                 String eName = fIdentityConstraint.getElementName();
3877                 String cName = fIdentityConstraint.getIdentityConstraintName();
3878                 reportSchemaError(code, new Object[] { field.toString(), eName, cName });
3879                 return;
3880             }
3881             if (!mayMatch) {
3882                 String code = &quot;FieldMultipleMatch&quot;;
3883                 String cName = fIdentityConstraint.getIdentityConstraintName();
3884                 reportSchemaError(code, new Object[] { field.toString(), cName });
3885             }
3886             else {
3887                 fValuesCount++;

3888             }
3889             fLocalValues[i] = actualValue;
3890             fLocalValueTypes[i] = valueType;
3891             fLocalItemValueTypes[i] = itemValueType;
3892             if (fValuesCount == fFieldCount) {
3893                 checkDuplicateValues();
3894                 // store values
3895                 for (i = 0; i &lt; fFieldCount; i++) {
3896                     fValues.add(fLocalValues[i]);
3897                     addValueType(fLocalValueTypes[i]);
3898                     addItemValueType(fLocalItemValueTypes[i]);
3899                 }
3900             }
3901         } // addValue(String,Field)
3902 
3903         /**
3904          * Returns true if this value store contains the locally scoped value stores
3905          */
3906         public boolean contains() {
3907             // REVISIT: we can improve performance by using hash codes, instead of
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2006, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.impl.xs;
  22 
</pre>
<hr />
<pre>
  94  * filter: receiving document events from the scanner; validating
  95  * the content and structure; augmenting the InfoSet, if applicable;
  96  * and notifying the parser of the information resulting from the
  97  * validation process.
  98  * &lt;p&gt;
  99  * This component requires the following features and properties from the
 100  * component manager that uses it:
 101  * &lt;ul&gt;
 102  *  &lt;li&gt;http://xml.org/sax/features/validation&lt;/li&gt;
 103  *  &lt;li&gt;http://apache.org/xml/properties/internal/symbol-table&lt;/li&gt;
 104  *  &lt;li&gt;http://apache.org/xml/properties/internal/error-reporter&lt;/li&gt;
 105  *  &lt;li&gt;http://apache.org/xml/properties/internal/entity-resolver&lt;/li&gt;
 106  * &lt;/ul&gt;
 107  *
 108  * @xerces.internal
 109  *
 110  * @author Sandy Gao IBM
 111  * @author Elena Litani IBM
 112  * @author Andy Clark IBM
 113  * @author Neeraj Bajaj, Sun Microsystems, inc.
<span class="line-modified"> 114  * @LastModified: Apr 2019</span>
 115  */
 116 public class XMLSchemaValidator
 117     implements XMLComponent, XMLDocumentFilter, FieldActivator, RevalidationHandler, XSElementDeclHelper {
 118 
 119     //
 120     // Constants
 121     //
 122     private static final boolean DEBUG = false;
 123 
 124     // feature identifiers
 125 
 126     /** Feature identifier: validation. */
 127     protected static final String VALIDATION =
 128         Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
 129 
 130     /** Feature identifier: validation. */
 131     protected static final String SCHEMA_VALIDATION =
 132         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE;
 133 
 134     /** Feature identifier: schema full checking*/
</pre>
<hr />
<pre>
2412                     IdentityConstraint id;
2413                     if ((id = selMatcher.getIdentityConstraint()) != null
2414                             &amp;&amp; id.getCategory() != IdentityConstraint.IC_KEYREF) {
2415                         fValueStoreCache.transplant(id, selMatcher.getInitialDepth());
2416                     }
2417                 }
2418             }
2419 
2420             // now handle keyref&#39;s/...
2421             for (int i = oldCount - 1; i &gt;= newCount; i--) {
2422                 XPathMatcher matcher = fMatcherStack.getMatcherAt(i);
2423                 if (matcher instanceof Selector.Matcher) {
2424                     Selector.Matcher selMatcher = (Selector.Matcher) matcher;
2425                     IdentityConstraint id;
2426                     if ((id = selMatcher.getIdentityConstraint()) != null
2427                             &amp;&amp; id.getCategory() == IdentityConstraint.IC_KEYREF) {
2428                         ValueStoreBase values =
2429                             fValueStoreCache.getValueStoreFor(id, selMatcher.getInitialDepth());
2430                         // nothing to do if nothing matched, or if not all
2431                         // fields are present.
<span class="line-modified">2432                         if (values != null &amp;&amp; values.fHasValue)</span>
2433                             values.endDocumentFragment();
2434                     }
2435                 }
2436             }
2437             fValueStoreCache.endElement();
2438         }
2439 
2440         // Check if we should modify the xsi:type ignore depth
2441         // This check is independent of whether this is the validation root,
2442         // and should be done before the element depth is decremented.
2443         if (fElementDepth &lt; fIgnoreXSITypeDepth) {
2444             fIgnoreXSITypeDepth--;
2445         }
2446 
2447         SchemaGrammar[] grammars = null;
2448         // have we reached the end tag of the validation root?
2449         if (fElementDepth == 0) {
2450             // 7 If the element information item is the validation root, it must be valid per Validation Root Valid (ID/IDREF) (3.3.4).
2451             Iterator&lt;String&gt; invIdRefs = fValidationState.checkIDRefID();
2452             fValidationState.resetIDTables();
</pre>
<hr />
<pre>
3701      *
3702      * @author Andy Clark, IBM
3703      */
3704     protected abstract class ValueStoreBase implements ValueStore {
3705 
3706         //
3707         // Data
3708         //
3709 
3710         /** Identity constraint. */
3711         protected IdentityConstraint fIdentityConstraint;
3712         protected int fFieldCount = 0;
3713         protected Field[] fFields = null;
3714         /** current data */
3715         protected Object[] fLocalValues = null;
3716         protected short[] fLocalValueTypes = null;
3717         protected ShortList[] fLocalItemValueTypes = null;
3718 
3719         /** Current data value count. */
3720         protected int fValuesCount;
<span class="line-added">3721         protected boolean fHasValue = false;</span>
3722 
3723         /** global data */
3724         public final Vector&lt;Object&gt; fValues = new Vector&lt;&gt;();
3725         public ShortVector fValueTypes = null;
3726         public Vector&lt;ShortList&gt; fItemValueTypes = null;
3727 
3728         private boolean fUseValueTypeVector = false;
3729         private int fValueTypesLength = 0;
3730         private short fValueType = 0;
3731 
3732         private boolean fUseItemValueTypeVector = false;
3733         private int fItemValueTypesLength = 0;
3734         private ShortList fItemValueType = null;
3735 
3736         /** buffer for error messages */
3737         final StringBuilder fTempBuffer = new StringBuilder();
3738 
3739         //
3740         // Constructors
3741         //
</pre>
<hr />
<pre>
3869             for (i = fFieldCount - 1; i &gt; -1; i--) {
3870                 if (fFields[i] == field) {
3871                     break;
3872                 }
3873             }
3874             // do we even know this field?
3875             if (i == -1) {
3876                 String code = &quot;UnknownField&quot;;
3877                 String eName = fIdentityConstraint.getElementName();
3878                 String cName = fIdentityConstraint.getIdentityConstraintName();
3879                 reportSchemaError(code, new Object[] { field.toString(), eName, cName });
3880                 return;
3881             }
3882             if (!mayMatch) {
3883                 String code = &quot;FieldMultipleMatch&quot;;
3884                 String cName = fIdentityConstraint.getIdentityConstraintName();
3885                 reportSchemaError(code, new Object[] { field.toString(), cName });
3886             }
3887             else {
3888                 fValuesCount++;
<span class="line-added">3889                 fHasValue = true;</span>
3890             }
3891             fLocalValues[i] = actualValue;
3892             fLocalValueTypes[i] = valueType;
3893             fLocalItemValueTypes[i] = itemValueType;
3894             if (fValuesCount == fFieldCount) {
3895                 checkDuplicateValues();
3896                 // store values
3897                 for (i = 0; i &lt; fFieldCount; i++) {
3898                     fValues.add(fLocalValues[i]);
3899                     addValueType(fLocalValueTypes[i]);
3900                     addItemValueType(fLocalItemValueTypes[i]);
3901                 }
3902             }
3903         } // addValue(String,Field)
3904 
3905         /**
3906          * Returns true if this value store contains the locally scoped value stores
3907          */
3908         public boolean contains() {
3909             // REVISIT: we can improve performance by using hash codes, instead of
</pre>
</td>
</tr>
</table>
<center><a href="SubstitutionGroupHandler.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="identity/XPathMatcher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
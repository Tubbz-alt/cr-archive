<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/CodeExceptionGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassObserver.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompoundInstruction.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/CodeExceptionGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.classfile.CodeException;
 24 
 25 /**
<span class="line-modified"> 26  * This class represents an exception handler, i.e., specifies the region where</span>
 27  * a handler is active and an instruction where the actual handling is done.
 28  * pool as parameters. Opposed to the JVM specification the end of the handled
 29  * region is set to be inclusive, i.e. all instructions between start and end
 30  * are protected including the start and end instructions (handles) themselves.
 31  * The end of the region is automatically mapped to be exclusive when calling
 32  * getCodeException(), i.e., there is no difference semantically.
 33  *
<span class="line-modified"> 34  * @version $Id: CodeExceptionGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
<span class="line-modified"> 35  * @see MethodGen</span>
<span class="line-modified"> 36  * @see CodeException</span>
<span class="line-removed"> 37  * @see InstructionHandle</span>
 38  */
 39 public final class CodeExceptionGen implements InstructionTargeter, Cloneable {
 40 
 41     private InstructionHandle start_pc;
 42     private InstructionHandle end_pc;
 43     private InstructionHandle handler_pc;
 44     private ObjectType catch_type;
 45 

 46     /**
<span class="line-modified"> 47      * Add an exception handler, i.e., specify region where a handler is active</span>
<span class="line-modified"> 48      * and an instruction where the actual handling is done.</span>
 49      *
 50      * @param start_pc Start of handled region (inclusive)
 51      * @param end_pc End of handled region (inclusive)
 52      * @param handler_pc Where handling is done
 53      * @param catch_type which exception is handled, null for ANY
 54      */
 55     public CodeExceptionGen(final InstructionHandle start_pc, final InstructionHandle end_pc,
 56             final InstructionHandle handler_pc, final ObjectType catch_type) {
 57         setStartPC(start_pc);
 58         setEndPC(end_pc);
 59         setHandlerPC(handler_pc);
 60         this.catch_type = catch_type;
 61     }
 62 

 63     /**
 64      * Get CodeException object.&lt;BR&gt;
 65      *
<span class="line-modified"> 66      * This relies on that the instruction list has already been dumped to byte</span>
<span class="line-modified"> 67      * code or or that the `setPositions&#39; methods has been called for the</span>
<span class="line-modified"> 68      * instruction list.</span>
 69      *
 70      * @param cp constant pool
 71      */
<span class="line-modified"> 72     public CodeException getCodeException(final ConstantPoolGen cp) {</span>
 73         return new CodeException(start_pc.getPosition(), end_pc.getPosition()
 74                 + end_pc.getInstruction().getLength(), handler_pc.getPosition(),
 75                 (catch_type == null) ? 0 : cp.addClass(catch_type));
 76     }
 77 
 78 
 79     /* Set start of handler
 80      * @param start_pc Start of handled region (inclusive)
 81      */
<span class="line-modified"> 82     public void setStartPC(final InstructionHandle start_pc) { // TODO could be package-protected?</span>
 83         BranchInstruction.notifyTarget(this.start_pc, start_pc, this);
 84         this.start_pc = start_pc;
 85     }
 86 
 87 
 88     /* Set end of handler
 89      * @param end_pc End of handled region (inclusive)
 90      */
<span class="line-modified"> 91     public void setEndPC(final InstructionHandle end_pc) { // TODO could be package-protected?</span>
 92         BranchInstruction.notifyTarget(this.end_pc, end_pc, this);
 93         this.end_pc = end_pc;
 94     }
 95 
 96 
 97     /* Set handler code
 98      * @param handler_pc Start of handler
 99      */
<span class="line-modified">100     public void setHandlerPC(final InstructionHandle handler_pc) { // TODO could be package-protected?</span>
101         BranchInstruction.notifyTarget(this.handler_pc, handler_pc, this);
102         this.handler_pc = handler_pc;
103     }
104 

105     /**
106      * @param old_ih old target, either start or end
107      * @param new_ih new target
108      */
109     @Override
<span class="line-modified">110     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {</span>
111         boolean targeted = false;
112         if (start_pc == old_ih) {
113             targeted = true;
114             setStartPC(new_ih);
115         }
116         if (end_pc == old_ih) {
117             targeted = true;
118             setEndPC(new_ih);
119         }
120         if (handler_pc == old_ih) {
121             targeted = true;
122             setHandlerPC(new_ih);
123         }
124         if (!targeted) {
125             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start_pc + &quot;, &quot;
126                     + end_pc + &quot;, &quot; + handler_pc + &quot;}&quot;);
127         }
128     }
129 

130     /**
131      * @return true, if ih is target of this handler
132      */
133     @Override
<span class="line-modified">134     public boolean containsTarget(final InstructionHandle ih) {</span>
135         return (start_pc == ih) || (end_pc == ih) || (handler_pc == ih);
136     }
137 
<span class="line-modified">138     /**</span>
<span class="line-modified">139      * Sets the type of the Exception to catch. Set &#39;null&#39; for ANY.</span>
<span class="line-modified">140      */</span>
<span class="line-removed">141     public void setCatchType(final ObjectType catch_type) {</span>
142         this.catch_type = catch_type;
143     }
144 
<span class="line-modified">145     /**</span>
<span class="line-modified">146      * Gets the type of the Exception to catch, &#39;null&#39; for ANY.</span>
<span class="line-removed">147      */</span>
148     public ObjectType getCatchType() {
149         return catch_type;
150     }
151 
<span class="line-modified">152     /**</span>
<span class="line-modified">153      * @return start of handled region (inclusive)</span>
154      */
155     public InstructionHandle getStartPC() {
156         return start_pc;
157     }
158 
<span class="line-modified">159     /**</span>
<span class="line-modified">160      * @return end of handled region (inclusive)</span>
161      */
162     public InstructionHandle getEndPC() {
163         return end_pc;
164     }
165 
<span class="line-modified">166     /**</span>
<span class="line-modified">167      * @return start of handler</span>
168      */
169     public InstructionHandle getHandlerPC() {
170         return handler_pc;
171     }
172 

173     @Override
174     public String toString() {
175         return &quot;CodeExceptionGen(&quot; + start_pc + &quot;, &quot; + end_pc + &quot;, &quot; + handler_pc + &quot;)&quot;;
176     }
177 

178     @Override
179     public Object clone() {
180         try {
181             return super.clone();
182         } catch (final CloneNotSupportedException e) {
183             throw new Error(&quot;Clone Not Supported&quot;); // never happens
184         }
185     }
186 }
</pre>
</td>
<td>
<hr />
<pre>
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.classfile.CodeException;
 24 
 25 /**
<span class="line-modified"> 26  * This class represents an exception handler, i.e., specifies the  region where</span>
 27  * a handler is active and an instruction where the actual handling is done.
 28  * pool as parameters. Opposed to the JVM specification the end of the handled
 29  * region is set to be inclusive, i.e. all instructions between start and end
 30  * are protected including the start and end instructions (handles) themselves.
 31  * The end of the region is automatically mapped to be exclusive when calling
 32  * getCodeException(), i.e., there is no difference semantically.
 33  *
<span class="line-modified"> 34  * @see     MethodGen</span>
<span class="line-modified"> 35  * @see     CodeException</span>
<span class="line-modified"> 36  * @see     InstructionHandle</span>

 37  */
 38 public final class CodeExceptionGen implements InstructionTargeter, Cloneable {
 39 
 40     private InstructionHandle start_pc;
 41     private InstructionHandle end_pc;
 42     private InstructionHandle handler_pc;
 43     private ObjectType catch_type;
 44 
<span class="line-added"> 45 </span>
 46     /**
<span class="line-modified"> 47      * Add an exception handler, i.e., specify region where a handler is active and an</span>
<span class="line-modified"> 48      * instruction where the actual handling is done.</span>
 49      *
 50      * @param start_pc Start of handled region (inclusive)
 51      * @param end_pc End of handled region (inclusive)
 52      * @param handler_pc Where handling is done
 53      * @param catch_type which exception is handled, null for ANY
 54      */
 55     public CodeExceptionGen(final InstructionHandle start_pc, final InstructionHandle end_pc,
 56             final InstructionHandle handler_pc, final ObjectType catch_type) {
 57         setStartPC(start_pc);
 58         setEndPC(end_pc);
 59         setHandlerPC(handler_pc);
 60         this.catch_type = catch_type;
 61     }
 62 
<span class="line-added"> 63 </span>
 64     /**
 65      * Get CodeException object.&lt;BR&gt;
 66      *
<span class="line-modified"> 67      * This relies on that the instruction list has already been dumped</span>
<span class="line-modified"> 68      * to byte code or or that the `setPositions&#39; methods has been</span>
<span class="line-modified"> 69      * called for the instruction list.</span>
 70      *
 71      * @param cp constant pool
 72      */
<span class="line-modified"> 73     public CodeException getCodeException( final ConstantPoolGen cp ) {</span>
 74         return new CodeException(start_pc.getPosition(), end_pc.getPosition()
 75                 + end_pc.getInstruction().getLength(), handler_pc.getPosition(),
 76                 (catch_type == null) ? 0 : cp.addClass(catch_type));
 77     }
 78 
 79 
 80     /* Set start of handler
 81      * @param start_pc Start of handled region (inclusive)
 82      */
<span class="line-modified"> 83     public void setStartPC( final InstructionHandle start_pc ) { // TODO could be package-protected?</span>
 84         BranchInstruction.notifyTarget(this.start_pc, start_pc, this);
 85         this.start_pc = start_pc;
 86     }
 87 
 88 
 89     /* Set end of handler
 90      * @param end_pc End of handled region (inclusive)
 91      */
<span class="line-modified"> 92     public void setEndPC( final InstructionHandle end_pc ) { // TODO could be package-protected?</span>
 93         BranchInstruction.notifyTarget(this.end_pc, end_pc, this);
 94         this.end_pc = end_pc;
 95     }
 96 
 97 
 98     /* Set handler code
 99      * @param handler_pc Start of handler
100      */
<span class="line-modified">101     public void setHandlerPC( final InstructionHandle handler_pc ) { // TODO could be package-protected?</span>
102         BranchInstruction.notifyTarget(this.handler_pc, handler_pc, this);
103         this.handler_pc = handler_pc;
104     }
105 
<span class="line-added">106 </span>
107     /**
108      * @param old_ih old target, either start or end
109      * @param new_ih new target
110      */
111     @Override
<span class="line-modified">112     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
113         boolean targeted = false;
114         if (start_pc == old_ih) {
115             targeted = true;
116             setStartPC(new_ih);
117         }
118         if (end_pc == old_ih) {
119             targeted = true;
120             setEndPC(new_ih);
121         }
122         if (handler_pc == old_ih) {
123             targeted = true;
124             setHandlerPC(new_ih);
125         }
126         if (!targeted) {
127             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start_pc + &quot;, &quot;
128                     + end_pc + &quot;, &quot; + handler_pc + &quot;}&quot;);
129         }
130     }
131 
<span class="line-added">132 </span>
133     /**
134      * @return true, if ih is target of this handler
135      */
136     @Override
<span class="line-modified">137     public boolean containsTarget( final InstructionHandle ih ) {</span>
138         return (start_pc == ih) || (end_pc == ih) || (handler_pc == ih);
139     }
140 
<span class="line-modified">141 </span>
<span class="line-modified">142     /** Sets the type of the Exception to catch. Set &#39;null&#39; for ANY. */</span>
<span class="line-modified">143     public void setCatchType( final ObjectType catch_type ) {</span>

144         this.catch_type = catch_type;
145     }
146 
<span class="line-modified">147 </span>
<span class="line-modified">148     /** Gets the type of the Exception to catch, &#39;null&#39; for ANY. */</span>

149     public ObjectType getCatchType() {
150         return catch_type;
151     }
152 
<span class="line-modified">153 </span>
<span class="line-modified">154     /** @return start of handled region (inclusive)</span>
155      */
156     public InstructionHandle getStartPC() {
157         return start_pc;
158     }
159 
<span class="line-modified">160 </span>
<span class="line-modified">161     /** @return end of handled region (inclusive)</span>
162      */
163     public InstructionHandle getEndPC() {
164         return end_pc;
165     }
166 
<span class="line-modified">167 </span>
<span class="line-modified">168     /** @return start of handler</span>
169      */
170     public InstructionHandle getHandlerPC() {
171         return handler_pc;
172     }
173 
<span class="line-added">174 </span>
175     @Override
176     public String toString() {
177         return &quot;CodeExceptionGen(&quot; + start_pc + &quot;, &quot; + end_pc + &quot;, &quot; + handler_pc + &quot;)&quot;;
178     }
179 
<span class="line-added">180 </span>
181     @Override
182     public Object clone() {
183         try {
184             return super.clone();
185         } catch (final CloneNotSupportedException e) {
186             throw new Error(&quot;Clone Not Supported&quot;); // never happens
187         }
188     }
189 }
</pre>
</td>
</tr>
</table>
<center><a href="ClassObserver.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CompoundInstruction.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
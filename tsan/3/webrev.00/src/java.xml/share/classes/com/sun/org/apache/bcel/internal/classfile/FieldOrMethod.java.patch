diff a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/FieldOrMethod.java b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/FieldOrMethod.java
--- a/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/FieldOrMethod.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/bcel/internal/classfile/FieldOrMethod.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  */
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -27,11 +27,11 @@
 import com.sun.org.apache.bcel.internal.Const;
 
 /**
  * Abstract super class for fields and methods.
  *
- * @version $Id: FieldOrMethod.java 1750029 2016-06-23 22:14:38Z sebb $
+ * @LastModified: Jan 2020
  */
 public abstract class FieldOrMethod extends AccessFlags implements Cloneable, Node {
     private int name_index; // Points to field name in constant pool
     private int signature_index; // Points to encoded signature
     private Attribute[] attributes; // Collection of attributes
@@ -46,53 +46,55 @@
     private boolean searchedForSignatureAttribute = false;
 
     FieldOrMethod() {
     }
 
+
     /**
      * Initialize from another object. Note that both objects use the same
      * references (shallow copy). Use clone() for a physical copy.
      */
     protected FieldOrMethod(final FieldOrMethod c) {
         this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(),
                 c.getAttributes(), c.getConstantPool());
     }
 
+
     /**
      * Construct object from file stream.
      *
      * @param file Input stream
      * @throws IOException
      * @throws ClassFormatException
-     * @deprecated (6.0) Use
-     * {@link #FieldOrMethod(java.io.DataInput, ConstantPool)} instead.
+     * @deprecated (6.0) Use {@link #FieldOrMethod(java.io.DataInput, ConstantPool)} instead.
      */
     @java.lang.Deprecated
-    protected FieldOrMethod(final DataInputStream file,
-            final ConstantPool constant_pool) throws IOException,
+    protected FieldOrMethod(final DataInputStream file, final ConstantPool constant_pool)
+            throws IOException,
             ClassFormatException {
         this((DataInput) file, constant_pool);
     }
 
     /**
      * Construct object from file stream.
-     *
      * @param file Input stream
      * @throws IOException
      * @throws ClassFormatException
      */
-    protected FieldOrMethod(final DataInput file,
-            final ConstantPool constant_pool) throws IOException, ClassFormatException {
+    protected FieldOrMethod(final DataInput file, final ConstantPool constant_pool)
+            throws IOException, ClassFormatException {
         this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null,
                 constant_pool);
-        attributes_count = file.readUnsignedShort();
+        final int attributes_count = file.readUnsignedShort();
         attributes = new Attribute[attributes_count];
         for (int i = 0; i < attributes_count; i++) {
             attributes[i] = Attribute.readAttribute(file, constant_pool);
         }
+        this.attributes_count = attributes_count; // init deprecated field
     }
 
+
     /**
      * @param access_flags Access rights of method
      * @param name_index Points to field name in constant pool
      * @param signature_index Points to encoded signature
      * @param attributes Collection of attributes
@@ -105,10 +107,11 @@
         this.signature_index = signature_index;
         this.constant_pool = constant_pool;
         setAttributes(attributes);
     }
 
+
     /**
      * Dump object to file stream on binary format.
      *
      * @param file Output file stream
      * @throws IOException
@@ -116,108 +119,120 @@
     public final void dump(final DataOutputStream file) throws IOException {
         file.writeShort(super.getAccessFlags());
         file.writeShort(name_index);
         file.writeShort(signature_index);
         file.writeShort(attributes_count);
-
-        for(int i=0; i < attributes_count; i++) {
-            attributes[i].dump(file);
+        if (attributes != null) {
+            for (final Attribute attribute : attributes) {
+                attribute.dump(file);
+            }
         }
     }
 
+
     /**
      * @return Collection of object attributes.
      */
     public final Attribute[] getAttributes() {
         return attributes;
     }
 
+
     /**
      * @param attributes Collection of object attributes.
      */
-    public final void setAttributes(final Attribute[] attributes) {
+    public final void setAttributes( final Attribute[] attributes ) {
         this.attributes = attributes;
-        this.attributes_count = attributes != null ? attributes.length : 0;
+        this.attributes_count = attributes != null ? attributes.length : 0; // init deprecated field
     }
 
+
     /**
      * @return Constant pool used by this object.
      */
     public final ConstantPool getConstantPool() {
         return constant_pool;
     }
 
+
     /**
      * @param constant_pool Constant pool to be used for this object.
      */
-    public final void setConstantPool(final ConstantPool constant_pool) {
+    public final void setConstantPool( final ConstantPool constant_pool ) {
         this.constant_pool = constant_pool;
     }
 
+
     /**
      * @return Index in constant pool of object's name.
      */
     public final int getNameIndex() {
         return name_index;
     }
 
+
     /**
      * @param name_index Index in constant pool of object's name.
      */
-    public final void setNameIndex(final int name_index) {
+    public final void setNameIndex( final int name_index ) {
         this.name_index = name_index;
     }
 
+
     /**
      * @return Index in constant pool of field signature.
      */
     public final int getSignatureIndex() {
         return signature_index;
     }
 
+
     /**
      * @param signature_index Index in constant pool of field signature.
      */
-    public final void setSignatureIndex(final int signature_index) {
+    public final void setSignatureIndex( final int signature_index ) {
         this.signature_index = signature_index;
     }
 
+
     /**
      * @return Name of object, i.e., method name or field name
      */
     public final String getName() {
         ConstantUtf8 c;
         c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);
         return c.getBytes();
     }
 
+
     /**
      * @return String representation of object's type signature (java style)
      */
     public final String getSignature() {
         ConstantUtf8 c;
         c = (ConstantUtf8) constant_pool.getConstant(signature_index, Const.CONSTANT_Utf8);
         return c.getBytes();
     }
 
+
     /**
      * @return deep copy of this field
      */
-    protected FieldOrMethod copy_(final ConstantPool _constant_pool) {
+    protected FieldOrMethod copy_( final ConstantPool _constant_pool ) {
         FieldOrMethod c = null;
 
         try {
-            c = (FieldOrMethod) clone();
-        } catch (final CloneNotSupportedException e) {
+          c = (FieldOrMethod)clone();
+        } catch(final CloneNotSupportedException e) {
             // ignored, but will cause NPE ...
         }
 
-        c.constant_pool = constant_pool;
-        c.attributes = new Attribute[attributes_count];
-        c.attributes_count = attributes_count;
+        c.constant_pool    = constant_pool;
+        c.attributes       = new Attribute[attributes.length];
+        c.attributes_count = attributes_count; // init deprecated field
 
-        for (int i = 0; i < attributes_count; i++) {
+        for (int i = 0; i < attributes.length; i++) {
             c.attributes[i] = attributes[i].copy(constant_pool);
         }
 
         return c;
     }
@@ -242,15 +257,19 @@
      * searches for the attribute only when requested - only searches for it
      * once.
      *
      * @since 6.0
      */
-    public final String getGenericSignature() {
-        if (!searchedForSignatureAttribute) {
+    public final String getGenericSignature()
+    {
+        if (!searchedForSignatureAttribute)
+        {
             boolean found = false;
-            for (int i = 0; !found && i < attributes.length; i++) {
-                if (attributes[i] instanceof Signature) {
+            for (int i = 0; !found && i < attributes.length; i++)
+            {
+                if (attributes[i] instanceof Signature)
+                {
                     signatureAttributeString = ((Signature) attributes[i])
                             .getSignature();
                     found = true;
                 }
             }

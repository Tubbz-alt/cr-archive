<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstructionConst.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionHandle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import com.sun.org.apache.bcel.internal.Const;
 23 
 24 /**
<span class="line-modified"> 25  * Instances of this class may be used, e.g., to generate typed versions of</span>
<span class="line-modified"> 26  * instructions. Its main purpose is to be used as the byte code generating</span>
<span class="line-modified"> 27  * backend of a compiler. You can subclass it to add your own create methods.</span>

 28  * &lt;p&gt;
<span class="line-modified"> 29  * Note: The static createXXX methods return singleton instances from the</span>
<span class="line-modified"> 30  * {@link InstructionConst} class.</span>
 31  *
<span class="line-removed"> 32  * @version $Id: InstructionFactory.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 33  * @see Const
 34  * @see InstructionConst
<span class="line-modified"> 35  * @LastModified: Nov 2017</span>
 36  */
 37 public class InstructionFactory {
 38 
 39     // N.N. These must agree with the order of Constants.T_CHAR through T_LONG
 40     private static final String[] short_names = {
<span class="line-modified"> 41         &quot;C&quot;, &quot;F&quot;, &quot;D&quot;, &quot;B&quot;, &quot;S&quot;, &quot;I&quot;, &quot;L&quot;</span>
 42     };
 43 
 44     private ClassGen cg;
 45     private ConstantPoolGen cp;
 46 
 47     public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {
 48         this.cg = cg;
 49         this.cp = cp;
 50     }
 51 
<span class="line-modified"> 52     /**</span>
<span class="line-modified"> 53      * Initialize with ClassGen object</span>
 54      */
 55     public InstructionFactory(final ClassGen cg) {
 56         this(cg, cg.getConstantPool());
 57     }
 58 
<span class="line-modified"> 59     /**</span>
<span class="line-modified"> 60      * Initialize just with ConstantPoolGen object</span>
 61      */
 62     public InstructionFactory(final ConstantPoolGen cp) {
 63         this(null, cp);
 64     }
 65 
<span class="line-modified"> 66     /**</span>
<span class="line-modified"> 67      * Create an invoke instruction. (Except for invokedynamic.)</span>
 68      *
 69      * @param class_name name of the called class
 70      * @param name name of the called method
 71      * @param ret_type return type of method
 72      * @param arg_types argument types of method
<span class="line-modified"> 73      * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC,</span>
<span class="line-modified"> 74      * INVOKEVIRTUAL, or INVOKESPECIAL</span>
 75      * @see Const
 76      */
<span class="line-modified"> 77     public InvokeInstruction createInvoke(final String class_name, final String name, final Type ret_type,</span>
<span class="line-modified"> 78             final Type[] arg_types, final short kind) {</span>
 79         int index;
 80         int nargs = 0;
 81         final String signature = Type.getMethodSignature(ret_type, arg_types);
 82         for (final Type arg_type : arg_types) {
 83             nargs += arg_type.getSize();
 84         }
 85         if (kind == Const.INVOKEINTERFACE) {
 86             index = cp.addInterfaceMethodref(class_name, name, signature);
 87         } else {
 88             index = cp.addMethodref(class_name, name, signature);
 89         }
 90         switch (kind) {
 91             case Const.INVOKESPECIAL:
 92                 return new INVOKESPECIAL(index);
 93             case Const.INVOKEVIRTUAL:
 94                 return new INVOKEVIRTUAL(index);
 95             case Const.INVOKESTATIC:
 96                 return new INVOKESTATIC(index);
 97             case Const.INVOKEINTERFACE:
 98                 return new INVOKEINTERFACE(index, nargs + 1);
 99             case Const.INVOKEDYNAMIC:
100                 return new INVOKEDYNAMIC(index);
101             default:
102                 throw new RuntimeException(&quot;Oops: Unknown invoke kind: &quot; + kind);
103         }
104     }
105 
<span class="line-modified">106     /**</span>
<span class="line-removed">107      * Create an invokedynamic instruction.</span>
108      *
109      * @param bootstrap_index index into the bootstrap_methods array
110      * @param name name of the called method
111      * @param ret_type return type of method
112      * @param arg_types argument types of method
113      * @see Constants
114      */
<span class="line-modified">115     /*</span>
<span class="line-modified">116      * createInvokeDynamic only needed if instrumention code wants to generate</span>
<span class="line-modified">117      * a new invokedynamic instruction.  I don&#39;t think we need.  (markro)</span>
<span class="line-modified">118      *</span>
<span class="line-modified">119      public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,</span>
<span class="line-modified">120      Type[] arg_types) {</span>
<span class="line-modified">121      int index;</span>
<span class="line-modified">122      int nargs = 0;</span>
<span class="line-modified">123      String signature = Type.getMethodSignature(ret_type, arg_types);</span>
<span class="line-modified">124      for (int i = 0; i &lt; arg_types.length; i++) {</span>
<span class="line-modified">125      nargs += arg_types[i].getSize();</span>
<span class="line-modified">126      }</span>
<span class="line-modified">127      // UNDONE - needs to be added to ConstantPoolGen</span>
<span class="line-modified">128      //index = cp.addInvokeDynamic(bootstrap_index, name, signature);</span>
<span class="line-modified">129      index = 0;</span>
<span class="line-modified">130      return new INVOKEDYNAMIC(index);</span>
<span class="line-modified">131      }</span>
<span class="line-modified">132      */</span>
<span class="line-modified">133     /**</span>
<span class="line-modified">134      * Create a call to the most popular System.out.println() method.</span>
135      *
136      * @param s the string to print
137      */
<span class="line-modified">138     public InstructionList createPrintln(final String s) {</span>
139         final InstructionList il = new InstructionList();
140         final int out = cp.addFieldref(&quot;java.lang.System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
141         final int println = cp.addMethodref(&quot;java.io.PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;);
142         il.append(new GETSTATIC(out));
143         il.append(new PUSH(cp, s));
144         il.append(new INVOKEVIRTUAL(println));
145         return il;
146     }
147 
<span class="line-modified">148     /**</span>
<span class="line-modified">149      * Uses PUSH to push a constant value onto the stack.</span>
<span class="line-removed">150      *</span>
151      * @param value must be of type Number, Boolean, Character or String
152      */
<span class="line-modified">153     public Instruction createConstant(final Object value) {</span>
154         PUSH push;
155         if (value instanceof Number) {
156             push = new PUSH(cp, (Number) value);
157         } else if (value instanceof String) {
158             push = new PUSH(cp, (String) value);
159         } else if (value instanceof Boolean) {
160             push = new PUSH(cp, (Boolean) value);
161         } else if (value instanceof Character) {
162             push = new PUSH(cp, (Character) value);
163         } else {
164             throw new ClassGenException(&quot;Illegal type: &quot; + value.getClass());
165         }
166         return push.getInstruction();
167     }
168 
169     private static class MethodObject {
170 
171         final Type[] arg_types;
172         final Type result_type;
173         final String class_name;
174         final String name;
175 

176         MethodObject(final String c, final String n, final Type r, final Type[] a) {
177             class_name = c;
178             name = n;
179             result_type = r;
180             arg_types = a;
181         }
182     }
183 
<span class="line-modified">184     private InvokeInstruction createInvoke(final MethodObject m, final short kind) {</span>

185         return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);
186     }
187 
188     private static final MethodObject[] append_mos = {
<span class="line-modified">189         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">190             Type.STRING</span>
<span class="line-modified">191         }),</span>
<span class="line-modified">192         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">193             Type.OBJECT</span>
<span class="line-modified">194         }),</span>
<span class="line-modified">195         null,</span>
<span class="line-modified">196         null, // indices 2, 3</span>
<span class="line-modified">197         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">198             Type.BOOLEAN</span>
<span class="line-modified">199         }),</span>
<span class="line-modified">200         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">201             Type.CHAR</span>
<span class="line-modified">202         }),</span>
<span class="line-modified">203         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">204             Type.FLOAT</span>
<span class="line-modified">205         }),</span>
<span class="line-modified">206         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">207             Type.DOUBLE</span>
<span class="line-modified">208         }),</span>
<span class="line-modified">209         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">210             Type.INT</span>
<span class="line-modified">211         }),</span>
<span class="line-modified">212         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(byte)</span>
<span class="line-modified">213         new Type[]{</span>
<span class="line-modified">214             Type.INT</span>
<span class="line-modified">215         }),</span>
<span class="line-modified">216         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(short)</span>
<span class="line-modified">217         new Type[]{</span>
<span class="line-modified">218             Type.INT</span>
<span class="line-modified">219         }),</span>
<span class="line-modified">220         new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[]{</span>
<span class="line-modified">221             Type.LONG</span>
<span class="line-modified">222         })</span>
223     };
224 
<span class="line-modified">225     private static boolean isString(final Type type) {</span>
<span class="line-modified">226         return (type instanceof ObjectType)</span>
<span class="line-modified">227                 &amp;&amp; ((ObjectType) type).getClassName().equals(&quot;java.lang.String&quot;);</span>

228     }
229 
<span class="line-modified">230     public Instruction createAppend(final Type type) {</span>

231         final byte t = type.getType();
232         if (isString(type)) {
233             return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);
234         }
235         switch (t) {
236             case Const.T_BOOLEAN:
237             case Const.T_CHAR:
238             case Const.T_FLOAT:
239             case Const.T_DOUBLE:
240             case Const.T_BYTE:
241             case Const.T_SHORT:
242             case Const.T_INT:
243             case Const.T_LONG:
244                 return createInvoke(append_mos[t], Const.INVOKEVIRTUAL);
245             case Const.T_ARRAY:
246             case Const.T_OBJECT:
247                 return createInvoke(append_mos[1], Const.INVOKEVIRTUAL);
248             default:
249                 throw new RuntimeException(&quot;Oops: No append for this type? &quot; + type);
250         }
251     }
252 
<span class="line-modified">253     /**</span>
<span class="line-modified">254      * Create a field instruction.</span>
255      *
256      * @param class_name name of the accessed class
257      * @param name name of the referenced field
<span class="line-modified">258      * @param type type of field</span>
259      * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC
260      * @see Const
261      */
<span class="line-modified">262     public FieldInstruction createFieldAccess(final String class_name, final String name, final Type type, final short kind) {</span>

263         int index;
264         final String signature = type.getSignature();
265         index = cp.addFieldref(class_name, name, signature);
266         switch (kind) {
267             case Const.GETFIELD:
268                 return new GETFIELD(index);
269             case Const.PUTFIELD:
270                 return new PUTFIELD(index);
271             case Const.GETSTATIC:
272                 return new GETSTATIC(index);
273             case Const.PUTSTATIC:
274                 return new PUTSTATIC(index);
275             default:
276                 throw new RuntimeException(&quot;Oops: Unknown getfield kind:&quot; + kind);
277         }
278     }
279 
<span class="line-modified">280     /**</span>
<span class="line-modified">281      * Create reference to `this&#39;</span>
282      */
283     public static Instruction createThis() {
284         return new ALOAD(0);
285     }
286 
<span class="line-modified">287     /**</span>
<span class="line-modified">288      * Create typed return</span>
289      */
<span class="line-modified">290     public static ReturnInstruction createReturn(final Type type) {</span>
291         switch (type.getType()) {
292             case Const.T_ARRAY:
293             case Const.T_OBJECT:
294                 return InstructionConst.ARETURN;
295             case Const.T_INT:
296             case Const.T_SHORT:
297             case Const.T_BOOLEAN:
298             case Const.T_CHAR:
299             case Const.T_BYTE:
300                 return InstructionConst.IRETURN;
301             case Const.T_FLOAT:
302                 return InstructionConst.FRETURN;
303             case Const.T_DOUBLE:
304                 return InstructionConst.DRETURN;
305             case Const.T_LONG:
306                 return InstructionConst.LRETURN;
307             case Const.T_VOID:
308                 return InstructionConst.RETURN;
309             default:
310                 throw new RuntimeException(&quot;Invalid type: &quot; + type);
311         }
312     }
313 
<span class="line-modified">314     private static ArithmeticInstruction createBinaryIntOp(final char first, final String op) {</span>

315         switch (first) {
316             case &#39;-&#39;:
317                 return InstructionConst.ISUB;
318             case &#39;+&#39;:
319                 return InstructionConst.IADD;
320             case &#39;%&#39;:
321                 return InstructionConst.IREM;
322             case &#39;*&#39;:
323                 return InstructionConst.IMUL;
324             case &#39;/&#39;:
325                 return InstructionConst.IDIV;
326             case &#39;&amp;&#39;:
327                 return InstructionConst.IAND;
328             case &#39;|&#39;:
329                 return InstructionConst.IOR;
330             case &#39;^&#39;:
331                 return InstructionConst.IXOR;
332             case &#39;&lt;&#39;:
333                 return InstructionConst.ISHL;
334             case &#39;&gt;&#39;:
335                 return op.equals(&quot;&gt;&gt;&gt;&quot;) ? InstructionConst.IUSHR : InstructionConst.ISHR;
336             default:
337                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
338         }
339     }
340 
<span class="line-modified">341     private static ArithmeticInstruction createBinaryLongOp(final char first, final String op) {</span>

342         switch (first) {
343             case &#39;-&#39;:
344                 return InstructionConst.LSUB;
345             case &#39;+&#39;:
346                 return InstructionConst.LADD;
347             case &#39;%&#39;:
348                 return InstructionConst.LREM;
349             case &#39;*&#39;:
350                 return InstructionConst.LMUL;
351             case &#39;/&#39;:
352                 return InstructionConst.LDIV;
353             case &#39;&amp;&#39;:
354                 return InstructionConst.LAND;
355             case &#39;|&#39;:
356                 return InstructionConst.LOR;
357             case &#39;^&#39;:
358                 return InstructionConst.LXOR;
359             case &#39;&lt;&#39;:
360                 return InstructionConst.LSHL;
361             case &#39;&gt;&#39;:
362                 return op.equals(&quot;&gt;&gt;&gt;&quot;) ? InstructionConst.LUSHR : InstructionConst.LSHR;
363             default:
364                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
365         }
366     }
367 
<span class="line-modified">368     private static ArithmeticInstruction createBinaryFloatOp(final char op) {</span>

369         switch (op) {
370             case &#39;-&#39;:
371                 return InstructionConst.FSUB;
372             case &#39;+&#39;:
373                 return InstructionConst.FADD;
374             case &#39;*&#39;:
375                 return InstructionConst.FMUL;
376             case &#39;/&#39;:
377                 return InstructionConst.FDIV;
378             case &#39;%&#39;:
379                 return InstructionConst.FREM;
380             default:
381                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
382         }
383     }
384 
<span class="line-modified">385     private static ArithmeticInstruction createBinaryDoubleOp(final char op) {</span>

386         switch (op) {
387             case &#39;-&#39;:
388                 return InstructionConst.DSUB;
389             case &#39;+&#39;:
390                 return InstructionConst.DADD;
391             case &#39;*&#39;:
392                 return InstructionConst.DMUL;
393             case &#39;/&#39;:
394                 return InstructionConst.DDIV;
395             case &#39;%&#39;:
396                 return InstructionConst.DREM;
397             default:
398                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
399         }
400     }
401 

402     /**
403      * Create binary operation for simple basic types, such as int and float.
404      *
405      * @param op operation, such as &quot;+&quot;, &quot;*&quot;, &quot;&amp;lt;&amp;lt;&quot;, etc.
406      */
<span class="line-modified">407     public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {</span>
408         final char first = op.charAt(0);
409         switch (type.getType()) {
410             case Const.T_BYTE:
411             case Const.T_SHORT:
412             case Const.T_INT:
413             case Const.T_CHAR:
414                 return createBinaryIntOp(first, op);
415             case Const.T_LONG:
416                 return createBinaryLongOp(first, op);
417             case Const.T_FLOAT:
418                 return createBinaryFloatOp(first);
419             case Const.T_DOUBLE:
420                 return createBinaryDoubleOp(first);
421             default:
422                 throw new RuntimeException(&quot;Invalid type &quot; + type);
423         }
424     }
425 

426     /**
427      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
428      */
<span class="line-modified">429     public static StackInstruction createPop(final int size) {</span>
430         return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;
431     }
432 

433     /**
434      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
435      */
<span class="line-modified">436     public static StackInstruction createDup(final int size) {</span>
437         return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;
438     }
439 

440     /**
441      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
442      */
<span class="line-modified">443     public static StackInstruction createDup_2(final int size) {</span>
444         return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;
445     }
446 

447     /**
448      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
449      */
<span class="line-modified">450     public static StackInstruction createDup_1(final int size) {</span>
451         return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;
452     }
453 

454     /**
455      * @param index index of local variable
456      */
<span class="line-modified">457     public static LocalVariableInstruction createStore(final Type type, final int index) {</span>
458         switch (type.getType()) {
459             case Const.T_BOOLEAN:
460             case Const.T_CHAR:
461             case Const.T_BYTE:
462             case Const.T_SHORT:
463             case Const.T_INT:
464                 return new ISTORE(index);
465             case Const.T_FLOAT:
466                 return new FSTORE(index);
467             case Const.T_DOUBLE:
468                 return new DSTORE(index);
469             case Const.T_LONG:
470                 return new LSTORE(index);
471             case Const.T_ARRAY:
472             case Const.T_OBJECT:
473                 return new ASTORE(index);
474             default:
475                 throw new RuntimeException(&quot;Invalid type &quot; + type);
476         }
477     }
478 

479     /**
480      * @param index index of local variable
481      */
<span class="line-modified">482     public static LocalVariableInstruction createLoad(final Type type, final int index) {</span>
483         switch (type.getType()) {
484             case Const.T_BOOLEAN:
485             case Const.T_CHAR:
486             case Const.T_BYTE:
487             case Const.T_SHORT:
488             case Const.T_INT:
489                 return new ILOAD(index);
490             case Const.T_FLOAT:
491                 return new FLOAD(index);
492             case Const.T_DOUBLE:
493                 return new DLOAD(index);
494             case Const.T_LONG:
495                 return new LLOAD(index);
496             case Const.T_ARRAY:
497             case Const.T_OBJECT:
498                 return new ALOAD(index);
499             default:
500                 throw new RuntimeException(&quot;Invalid type &quot; + type);
501         }
502     }
503 

504     /**
505      * @param type type of elements of array, i.e., array.getElementType()
506      */
<span class="line-modified">507     public static ArrayInstruction createArrayLoad(final Type type) {</span>
508         switch (type.getType()) {
509             case Const.T_BOOLEAN:
510             case Const.T_BYTE:
511                 return InstructionConst.BALOAD;
512             case Const.T_CHAR:
513                 return InstructionConst.CALOAD;
514             case Const.T_SHORT:
515                 return InstructionConst.SALOAD;
516             case Const.T_INT:
517                 return InstructionConst.IALOAD;
518             case Const.T_FLOAT:
519                 return InstructionConst.FALOAD;
520             case Const.T_DOUBLE:
521                 return InstructionConst.DALOAD;
522             case Const.T_LONG:
523                 return InstructionConst.LALOAD;
524             case Const.T_ARRAY:
525             case Const.T_OBJECT:
526                 return InstructionConst.AALOAD;
527             default:
528                 throw new RuntimeException(&quot;Invalid type &quot; + type);
529         }
530     }
531 

532     /**
533      * @param type type of elements of array, i.e., array.getElementType()
534      */
<span class="line-modified">535     public static ArrayInstruction createArrayStore(final Type type) {</span>
536         switch (type.getType()) {
537             case Const.T_BOOLEAN:
538             case Const.T_BYTE:
539                 return InstructionConst.BASTORE;
540             case Const.T_CHAR:
541                 return InstructionConst.CASTORE;
542             case Const.T_SHORT:
543                 return InstructionConst.SASTORE;
544             case Const.T_INT:
545                 return InstructionConst.IASTORE;
546             case Const.T_FLOAT:
547                 return InstructionConst.FASTORE;
548             case Const.T_DOUBLE:
549                 return InstructionConst.DASTORE;
550             case Const.T_LONG:
551                 return InstructionConst.LASTORE;
552             case Const.T_ARRAY:
553             case Const.T_OBJECT:
554                 return InstructionConst.AASTORE;
555             default:
556                 throw new RuntimeException(&quot;Invalid type &quot; + type);
557         }
558     }
559 
560     /**
561      * Create conversion operation for two stack operands, this may be an I2C,
562      * instruction, e.g., if the operands are basic types and CHECKCAST if they
563      * are reference types.
564      */
<span class="line-modified">565     public Instruction createCast(final Type src_type, final Type dest_type) {</span>
566         if ((src_type instanceof BasicType) &amp;&amp; (dest_type instanceof BasicType)) {
567             final byte dest = dest_type.getType();
568             byte src = src_type.getType();
569             if (dest == Const.T_LONG
570                     &amp;&amp; (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
571                 src = Const.T_INT;
572             }
573             final String name = &quot;com.sun.org.apache.bcel.internal.generic.&quot; + short_names[src - Const.T_CHAR] + &quot;2&quot;
574                     + short_names[dest - Const.T_CHAR];
575             Instruction i = null;
576             try {
577                 i = (Instruction) java.lang.Class.forName(name).getDeclaredConstructor().newInstance();
578             } catch (final Exception e) {
579                 throw new RuntimeException(&quot;Could not find instruction: &quot; + name, e);
580             }
581             return i;
582         } else if ((src_type instanceof ReferenceType) &amp;&amp; (dest_type instanceof ReferenceType)) {
583             if (dest_type instanceof ArrayType) {
584                 return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
585             }
586             return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
587         } else {
588             throw new RuntimeException(&quot;Can not cast &quot; + src_type + &quot; to &quot; + dest_type);
589         }
590     }
591 
<span class="line-modified">592     public GETFIELD createGetField(final String class_name, final String name, final Type t) {</span>

593         return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));
594     }
595 
<span class="line-modified">596     public GETSTATIC createGetStatic(final String class_name, final String name, final Type t) {</span>

597         return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
598     }
599 
<span class="line-modified">600     public PUTFIELD createPutField(final String class_name, final String name, final Type t) {</span>

601         return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));
602     }
603 
<span class="line-modified">604     public PUTSTATIC createPutStatic(final String class_name, final String name, final Type t) {</span>

605         return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
606     }
607 
<span class="line-modified">608     public CHECKCAST createCheckCast(final ReferenceType t) {</span>

609         if (t instanceof ArrayType) {
610             return new CHECKCAST(cp.addArrayClass((ArrayType) t));
611         }
612         return new CHECKCAST(cp.addClass((ObjectType) t));
613     }
614 
<span class="line-modified">615     public INSTANCEOF createInstanceOf(final ReferenceType t) {</span>

616         if (t instanceof ArrayType) {
617             return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
618         }
619         return new INSTANCEOF(cp.addClass((ObjectType) t));
620     }
621 
<span class="line-modified">622     public NEW createNew(final ObjectType t) {</span>

623         return new NEW(cp.addClass(t));
624     }
625 
<span class="line-modified">626     public NEW createNew(final String s) {</span>

627         return createNew(ObjectType.getInstance(s));
628     }
629 
630     /**
631      * Create new array of given size and type.
632      *
633      * @return an instruction that creates the corresponding array at runtime,
634      * i.e. is an AllocationInstruction
635      */
<span class="line-modified">636     public Instruction createNewArray(final Type t, final short dim) {</span>
637         if (dim == 1) {
638             if (t instanceof ObjectType) {
639                 return new ANEWARRAY(cp.addClass((ObjectType) t));
640             } else if (t instanceof ArrayType) {
641                 return new ANEWARRAY(cp.addArrayClass((ArrayType) t));
642             } else {
643                 return new NEWARRAY(t.getType());
644             }
645         }
646         ArrayType at;
647         if (t instanceof ArrayType) {
648             at = (ArrayType) t;
649         } else {
650             at = new ArrayType(t, dim);
651         }
652         return new MULTIANEWARRAY(cp.addArrayClass(at), dim);
653     }
654 
655     /**
656      * Create &quot;null&quot; value for reference types, 0 for basic types like int
657      */
<span class="line-modified">658     public static Instruction createNull(final Type type) {</span>
659         switch (type.getType()) {
660             case Const.T_ARRAY:
661             case Const.T_OBJECT:
662                 return InstructionConst.ACONST_NULL;
663             case Const.T_INT:
664             case Const.T_SHORT:
665             case Const.T_BOOLEAN:
666             case Const.T_CHAR:
667             case Const.T_BYTE:
668                 return InstructionConst.ICONST_0;
669             case Const.T_FLOAT:
670                 return InstructionConst.FCONST_0;
671             case Const.T_DOUBLE:
672                 return InstructionConst.DCONST_0;
673             case Const.T_LONG:
674                 return InstructionConst.LCONST_0;
675             case Const.T_VOID:
676                 return InstructionConst.NOP;
677             default:
678                 throw new RuntimeException(&quot;Invalid type: &quot; + type);
679         }
680     }
681 
682     /**
683      * Create branch instruction by given opcode, except LOOKUPSWITCH and
684      * TABLESWITCH. For those you should use the SWITCH compound instruction.
685      */
<span class="line-modified">686     public static BranchInstruction createBranchInstruction(final short opcode, final InstructionHandle target) {</span>

687         switch (opcode) {
688             case Const.IFEQ:
689                 return new IFEQ(target);
690             case Const.IFNE:
691                 return new IFNE(target);
692             case Const.IFLT:
693                 return new IFLT(target);
694             case Const.IFGE:
695                 return new IFGE(target);
696             case Const.IFGT:
697                 return new IFGT(target);
698             case Const.IFLE:
699                 return new IFLE(target);
700             case Const.IF_ICMPEQ:
701                 return new IF_ICMPEQ(target);
702             case Const.IF_ICMPNE:
703                 return new IF_ICMPNE(target);
704             case Const.IF_ICMPLT:
705                 return new IF_ICMPLT(target);
706             case Const.IF_ICMPGE:
</pre>
<hr />
<pre>
713                 return new IF_ACMPEQ(target);
714             case Const.IF_ACMPNE:
715                 return new IF_ACMPNE(target);
716             case Const.GOTO:
717                 return new GOTO(target);
718             case Const.JSR:
719                 return new JSR(target);
720             case Const.IFNULL:
721                 return new IFNULL(target);
722             case Const.IFNONNULL:
723                 return new IFNONNULL(target);
724             case Const.GOTO_W:
725                 return new GOTO_W(target);
726             case Const.JSR_W:
727                 return new JSR_W(target);
728             default:
729                 throw new RuntimeException(&quot;Invalid opcode: &quot; + opcode);
730         }
731     }
732 
<span class="line-modified">733     public void setClassGen(final ClassGen c) {</span>

734         cg = c;
735     }
736 

737     public ClassGen getClassGen() {
738         return cg;
739     }
740 
<span class="line-modified">741     public void setConstantPool(final ConstantPoolGen c) {</span>

742         cp = c;
743     }
744 

745     public ConstantPoolGen getConstantPool() {
746         return cp;
747     }
748 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import com.sun.org.apache.bcel.internal.Const;
 23 
 24 /**
<span class="line-modified"> 25  * Instances of this class may be used, e.g., to generate typed</span>
<span class="line-modified"> 26  * versions of instructions. Its main purpose is to be used as the</span>
<span class="line-modified"> 27  * byte code generating backend of a compiler. You can subclass it to</span>
<span class="line-added"> 28  * add your own create methods.</span>
 29  * &lt;p&gt;
<span class="line-modified"> 30  * Note: The static createXXX methods return singleton instances</span>
<span class="line-modified"> 31  * from the {@link InstructionConst} class.</span>
 32  *

 33  * @see Const
 34  * @see InstructionConst
<span class="line-modified"> 35  * @LastModified: Jan 2020</span>
 36  */
 37 public class InstructionFactory {
 38 
 39     // N.N. These must agree with the order of Constants.T_CHAR through T_LONG
 40     private static final String[] short_names = {
<span class="line-modified"> 41             &quot;C&quot;, &quot;F&quot;, &quot;D&quot;, &quot;B&quot;, &quot;S&quot;, &quot;I&quot;, &quot;L&quot;</span>
 42     };
 43 
 44     private ClassGen cg;
 45     private ConstantPoolGen cp;
 46 
 47     public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {
 48         this.cg = cg;
 49         this.cp = cp;
 50     }
 51 
<span class="line-modified"> 52 </span>
<span class="line-modified"> 53     /** Initialize with ClassGen object</span>
 54      */
 55     public InstructionFactory(final ClassGen cg) {
 56         this(cg, cg.getConstantPool());
 57     }
 58 
<span class="line-modified"> 59 </span>
<span class="line-modified"> 60     /** Initialize just with ConstantPoolGen object</span>
 61      */
 62     public InstructionFactory(final ConstantPoolGen cp) {
 63         this(null, cp);
 64     }
 65 
<span class="line-modified"> 66 </span>
<span class="line-modified"> 67     /** Create an invoke instruction. (Except for invokedynamic.)</span>
 68      *
 69      * @param class_name name of the called class
 70      * @param name name of the called method
 71      * @param ret_type return type of method
 72      * @param arg_types argument types of method
<span class="line-modified"> 73      * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,</span>
<span class="line-modified"> 74      * or INVOKESPECIAL</span>
 75      * @see Const
 76      */
<span class="line-modified"> 77     public InvokeInstruction createInvoke( final String class_name, final String name,</span>
<span class="line-modified"> 78             final Type ret_type, final Type[] arg_types, final short kind ) {</span>
 79         int index;
 80         int nargs = 0;
 81         final String signature = Type.getMethodSignature(ret_type, arg_types);
 82         for (final Type arg_type : arg_types) {
 83             nargs += arg_type.getSize();
 84         }
 85         if (kind == Const.INVOKEINTERFACE) {
 86             index = cp.addInterfaceMethodref(class_name, name, signature);
 87         } else {
 88             index = cp.addMethodref(class_name, name, signature);
 89         }
 90         switch (kind) {
 91             case Const.INVOKESPECIAL:
 92                 return new INVOKESPECIAL(index);
 93             case Const.INVOKEVIRTUAL:
 94                 return new INVOKEVIRTUAL(index);
 95             case Const.INVOKESTATIC:
 96                 return new INVOKESTATIC(index);
 97             case Const.INVOKEINTERFACE:
 98                 return new INVOKEINTERFACE(index, nargs + 1);
 99             case Const.INVOKEDYNAMIC:
100                 return new INVOKEDYNAMIC(index);
101             default:
102                 throw new RuntimeException(&quot;Oops: Unknown invoke kind: &quot; + kind);
103         }
104     }
105 
<span class="line-modified">106     /** Create an invokedynamic instruction.</span>

107      *
108      * @param bootstrap_index index into the bootstrap_methods array
109      * @param name name of the called method
110      * @param ret_type return type of method
111      * @param arg_types argument types of method
112      * @see Constants
113      */
<span class="line-modified">114 /*</span>
<span class="line-modified">115  * createInvokeDynamic only needed if instrumention code wants to generate</span>
<span class="line-modified">116  * a new invokedynamic instruction.  I don&#39;t think we need.  (markro)</span>
<span class="line-modified">117  *</span>
<span class="line-modified">118     public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,</span>
<span class="line-modified">119             Type[] arg_types) {</span>
<span class="line-modified">120         int index;</span>
<span class="line-modified">121         int nargs = 0;</span>
<span class="line-modified">122         String signature = Type.getMethodSignature(ret_type, arg_types);</span>
<span class="line-modified">123         for (int i = 0; i &lt; arg_types.length; i++) {</span>
<span class="line-modified">124             nargs += arg_types[i].getSize();</span>
<span class="line-modified">125         }</span>
<span class="line-modified">126         // UNDONE - needs to be added to ConstantPoolGen</span>
<span class="line-modified">127         //index = cp.addInvokeDynamic(bootstrap_index, name, signature);</span>
<span class="line-modified">128         index = 0;</span>
<span class="line-modified">129         return new INVOKEDYNAMIC(index);</span>
<span class="line-modified">130     }</span>
<span class="line-modified">131  */</span>
<span class="line-modified">132 </span>
<span class="line-modified">133     /** Create a call to the most popular System.out.println() method.</span>
134      *
135      * @param s the string to print
136      */
<span class="line-modified">137     public InstructionList createPrintln( final String s ) {</span>
138         final InstructionList il = new InstructionList();
139         final int out = cp.addFieldref(&quot;java.lang.System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
140         final int println = cp.addMethodref(&quot;java.io.PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;);
141         il.append(new GETSTATIC(out));
142         il.append(new PUSH(cp, s));
143         il.append(new INVOKEVIRTUAL(println));
144         return il;
145     }
146 
<span class="line-modified">147 </span>
<span class="line-modified">148     /** Uses PUSH to push a constant value onto the stack.</span>

149      * @param value must be of type Number, Boolean, Character or String
150      */
<span class="line-modified">151     public Instruction createConstant( final Object value ) {</span>
152         PUSH push;
153         if (value instanceof Number) {
154             push = new PUSH(cp, (Number) value);
155         } else if (value instanceof String) {
156             push = new PUSH(cp, (String) value);
157         } else if (value instanceof Boolean) {
158             push = new PUSH(cp, (Boolean) value);
159         } else if (value instanceof Character) {
160             push = new PUSH(cp, (Character) value);
161         } else {
162             throw new ClassGenException(&quot;Illegal type: &quot; + value.getClass());
163         }
164         return push.getInstruction();
165     }
166 
167     private static class MethodObject {
168 
169         final Type[] arg_types;
170         final Type result_type;
171         final String class_name;
172         final String name;
173 
<span class="line-added">174 </span>
175         MethodObject(final String c, final String n, final Type r, final Type[] a) {
176             class_name = c;
177             name = n;
178             result_type = r;
179             arg_types = a;
180         }
181     }
182 
<span class="line-modified">183 </span>
<span class="line-added">184     private InvokeInstruction createInvoke( final MethodObject m, final short kind ) {</span>
185         return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);
186     }
187 
188     private static final MethodObject[] append_mos = {
<span class="line-modified">189             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">190                 Type.STRING</span>
<span class="line-modified">191             }),</span>
<span class="line-modified">192             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">193                 Type.OBJECT</span>
<span class="line-modified">194             }),</span>
<span class="line-modified">195             null,</span>
<span class="line-modified">196             null, // indices 2, 3</span>
<span class="line-modified">197             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">198                 Type.BOOLEAN</span>
<span class="line-modified">199             }),</span>
<span class="line-modified">200             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">201                 Type.CHAR</span>
<span class="line-modified">202             }),</span>
<span class="line-modified">203             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">204                 Type.FLOAT</span>
<span class="line-modified">205             }),</span>
<span class="line-modified">206             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">207                 Type.DOUBLE</span>
<span class="line-modified">208             }),</span>
<span class="line-modified">209             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">210                 Type.INT</span>
<span class="line-modified">211             }),</span>
<span class="line-modified">212             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(byte)</span>
<span class="line-modified">213                     new Type[] {</span>
<span class="line-modified">214                         Type.INT</span>
<span class="line-modified">215                     }),</span>
<span class="line-modified">216             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, // No append(short)</span>
<span class="line-modified">217                     new Type[] {</span>
<span class="line-modified">218                         Type.INT</span>
<span class="line-modified">219                     }),</span>
<span class="line-modified">220             new MethodObject(&quot;java.lang.StringBuffer&quot;, &quot;append&quot;, Type.STRINGBUFFER, new Type[] {</span>
<span class="line-modified">221                 Type.LONG</span>
<span class="line-modified">222             })</span>
223     };
224 
<span class="line-modified">225 </span>
<span class="line-modified">226     private static boolean isString( final Type type ) {</span>
<span class="line-modified">227         return (type instanceof ObjectType) &amp;&amp;</span>
<span class="line-added">228               ((ObjectType) type).getClassName().equals(&quot;java.lang.String&quot;);</span>
229     }
230 
<span class="line-modified">231 </span>
<span class="line-added">232     public Instruction createAppend( final Type type ) {</span>
233         final byte t = type.getType();
234         if (isString(type)) {
235             return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);
236         }
237         switch (t) {
238             case Const.T_BOOLEAN:
239             case Const.T_CHAR:
240             case Const.T_FLOAT:
241             case Const.T_DOUBLE:
242             case Const.T_BYTE:
243             case Const.T_SHORT:
244             case Const.T_INT:
245             case Const.T_LONG:
246                 return createInvoke(append_mos[t], Const.INVOKEVIRTUAL);
247             case Const.T_ARRAY:
248             case Const.T_OBJECT:
249                 return createInvoke(append_mos[1], Const.INVOKEVIRTUAL);
250             default:
251                 throw new RuntimeException(&quot;Oops: No append for this type? &quot; + type);
252         }
253     }
254 
<span class="line-modified">255 </span>
<span class="line-modified">256     /** Create a field instruction.</span>
257      *
258      * @param class_name name of the accessed class
259      * @param name name of the referenced field
<span class="line-modified">260      * @param type  type of field</span>
261      * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC
262      * @see Const
263      */
<span class="line-modified">264     public FieldInstruction createFieldAccess( final String class_name,</span>
<span class="line-added">265             final String name, final Type type, final short kind ) {</span>
266         int index;
267         final String signature = type.getSignature();
268         index = cp.addFieldref(class_name, name, signature);
269         switch (kind) {
270             case Const.GETFIELD:
271                 return new GETFIELD(index);
272             case Const.PUTFIELD:
273                 return new PUTFIELD(index);
274             case Const.GETSTATIC:
275                 return new GETSTATIC(index);
276             case Const.PUTSTATIC:
277                 return new PUTSTATIC(index);
278             default:
279                 throw new RuntimeException(&quot;Oops: Unknown getfield kind:&quot; + kind);
280         }
281     }
282 
<span class="line-modified">283 </span>
<span class="line-modified">284     /** Create reference to `this&#39;</span>
285      */
286     public static Instruction createThis() {
287         return new ALOAD(0);
288     }
289 
<span class="line-modified">290 </span>
<span class="line-modified">291     /** Create typed return</span>
292      */
<span class="line-modified">293     public static ReturnInstruction createReturn( final Type type ) {</span>
294         switch (type.getType()) {
295             case Const.T_ARRAY:
296             case Const.T_OBJECT:
297                 return InstructionConst.ARETURN;
298             case Const.T_INT:
299             case Const.T_SHORT:
300             case Const.T_BOOLEAN:
301             case Const.T_CHAR:
302             case Const.T_BYTE:
303                 return InstructionConst.IRETURN;
304             case Const.T_FLOAT:
305                 return InstructionConst.FRETURN;
306             case Const.T_DOUBLE:
307                 return InstructionConst.DRETURN;
308             case Const.T_LONG:
309                 return InstructionConst.LRETURN;
310             case Const.T_VOID:
311                 return InstructionConst.RETURN;
312             default:
313                 throw new RuntimeException(&quot;Invalid type: &quot; + type);
314         }
315     }
316 
<span class="line-modified">317 </span>
<span class="line-added">318     private static ArithmeticInstruction createBinaryIntOp( final char first, final String op ) {</span>
319         switch (first) {
320             case &#39;-&#39;:
321                 return InstructionConst.ISUB;
322             case &#39;+&#39;:
323                 return InstructionConst.IADD;
324             case &#39;%&#39;:
325                 return InstructionConst.IREM;
326             case &#39;*&#39;:
327                 return InstructionConst.IMUL;
328             case &#39;/&#39;:
329                 return InstructionConst.IDIV;
330             case &#39;&amp;&#39;:
331                 return InstructionConst.IAND;
332             case &#39;|&#39;:
333                 return InstructionConst.IOR;
334             case &#39;^&#39;:
335                 return InstructionConst.IXOR;
336             case &#39;&lt;&#39;:
337                 return InstructionConst.ISHL;
338             case &#39;&gt;&#39;:
339                 return op.equals(&quot;&gt;&gt;&gt;&quot;) ? InstructionConst.IUSHR : InstructionConst.ISHR;
340             default:
341                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
342         }
343     }
344 
<span class="line-modified">345 </span>
<span class="line-added">346     private static ArithmeticInstruction createBinaryLongOp( final char first, final String op ) {</span>
347         switch (first) {
348             case &#39;-&#39;:
349                 return InstructionConst.LSUB;
350             case &#39;+&#39;:
351                 return InstructionConst.LADD;
352             case &#39;%&#39;:
353                 return InstructionConst.LREM;
354             case &#39;*&#39;:
355                 return InstructionConst.LMUL;
356             case &#39;/&#39;:
357                 return InstructionConst.LDIV;
358             case &#39;&amp;&#39;:
359                 return InstructionConst.LAND;
360             case &#39;|&#39;:
361                 return InstructionConst.LOR;
362             case &#39;^&#39;:
363                 return InstructionConst.LXOR;
364             case &#39;&lt;&#39;:
365                 return InstructionConst.LSHL;
366             case &#39;&gt;&#39;:
367                 return op.equals(&quot;&gt;&gt;&gt;&quot;) ? InstructionConst.LUSHR : InstructionConst.LSHR;
368             default:
369                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
370         }
371     }
372 
<span class="line-modified">373 </span>
<span class="line-added">374     private static ArithmeticInstruction createBinaryFloatOp( final char op ) {</span>
375         switch (op) {
376             case &#39;-&#39;:
377                 return InstructionConst.FSUB;
378             case &#39;+&#39;:
379                 return InstructionConst.FADD;
380             case &#39;*&#39;:
381                 return InstructionConst.FMUL;
382             case &#39;/&#39;:
383                 return InstructionConst.FDIV;
384             case &#39;%&#39;:
385                 return InstructionConst.FREM;
386             default:
387                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
388         }
389     }
390 
<span class="line-modified">391 </span>
<span class="line-added">392     private static ArithmeticInstruction createBinaryDoubleOp( final char op ) {</span>
393         switch (op) {
394             case &#39;-&#39;:
395                 return InstructionConst.DSUB;
396             case &#39;+&#39;:
397                 return InstructionConst.DADD;
398             case &#39;*&#39;:
399                 return InstructionConst.DMUL;
400             case &#39;/&#39;:
401                 return InstructionConst.DDIV;
402             case &#39;%&#39;:
403                 return InstructionConst.DREM;
404             default:
405                 throw new RuntimeException(&quot;Invalid operand &quot; + op);
406         }
407     }
408 
<span class="line-added">409 </span>
410     /**
411      * Create binary operation for simple basic types, such as int and float.
412      *
413      * @param op operation, such as &quot;+&quot;, &quot;*&quot;, &quot;&amp;lt;&amp;lt;&quot;, etc.
414      */
<span class="line-modified">415     public static ArithmeticInstruction createBinaryOperation( final String op, final Type type ) {</span>
416         final char first = op.charAt(0);
417         switch (type.getType()) {
418             case Const.T_BYTE:
419             case Const.T_SHORT:
420             case Const.T_INT:
421             case Const.T_CHAR:
422                 return createBinaryIntOp(first, op);
423             case Const.T_LONG:
424                 return createBinaryLongOp(first, op);
425             case Const.T_FLOAT:
426                 return createBinaryFloatOp(first);
427             case Const.T_DOUBLE:
428                 return createBinaryDoubleOp(first);
429             default:
430                 throw new RuntimeException(&quot;Invalid type &quot; + type);
431         }
432     }
433 
<span class="line-added">434 </span>
435     /**
436      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
437      */
<span class="line-modified">438     public static StackInstruction createPop( final int size ) {</span>
439         return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;
440     }
441 
<span class="line-added">442 </span>
443     /**
444      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
445      */
<span class="line-modified">446     public static StackInstruction createDup( final int size ) {</span>
447         return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;
448     }
449 
<span class="line-added">450 </span>
451     /**
452      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
453      */
<span class="line-modified">454     public static StackInstruction createDup_2( final int size ) {</span>
455         return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;
456     }
457 
<span class="line-added">458 </span>
459     /**
460      * @param size size of operand, either 1 (int, e.g.) or 2 (double)
461      */
<span class="line-modified">462     public static StackInstruction createDup_1( final int size ) {</span>
463         return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;
464     }
465 
<span class="line-added">466 </span>
467     /**
468      * @param index index of local variable
469      */
<span class="line-modified">470     public static LocalVariableInstruction createStore( final Type type, final int index ) {</span>
471         switch (type.getType()) {
472             case Const.T_BOOLEAN:
473             case Const.T_CHAR:
474             case Const.T_BYTE:
475             case Const.T_SHORT:
476             case Const.T_INT:
477                 return new ISTORE(index);
478             case Const.T_FLOAT:
479                 return new FSTORE(index);
480             case Const.T_DOUBLE:
481                 return new DSTORE(index);
482             case Const.T_LONG:
483                 return new LSTORE(index);
484             case Const.T_ARRAY:
485             case Const.T_OBJECT:
486                 return new ASTORE(index);
487             default:
488                 throw new RuntimeException(&quot;Invalid type &quot; + type);
489         }
490     }
491 
<span class="line-added">492 </span>
493     /**
494      * @param index index of local variable
495      */
<span class="line-modified">496     public static LocalVariableInstruction createLoad( final Type type, final int index ) {</span>
497         switch (type.getType()) {
498             case Const.T_BOOLEAN:
499             case Const.T_CHAR:
500             case Const.T_BYTE:
501             case Const.T_SHORT:
502             case Const.T_INT:
503                 return new ILOAD(index);
504             case Const.T_FLOAT:
505                 return new FLOAD(index);
506             case Const.T_DOUBLE:
507                 return new DLOAD(index);
508             case Const.T_LONG:
509                 return new LLOAD(index);
510             case Const.T_ARRAY:
511             case Const.T_OBJECT:
512                 return new ALOAD(index);
513             default:
514                 throw new RuntimeException(&quot;Invalid type &quot; + type);
515         }
516     }
517 
<span class="line-added">518 </span>
519     /**
520      * @param type type of elements of array, i.e., array.getElementType()
521      */
<span class="line-modified">522     public static ArrayInstruction createArrayLoad( final Type type ) {</span>
523         switch (type.getType()) {
524             case Const.T_BOOLEAN:
525             case Const.T_BYTE:
526                 return InstructionConst.BALOAD;
527             case Const.T_CHAR:
528                 return InstructionConst.CALOAD;
529             case Const.T_SHORT:
530                 return InstructionConst.SALOAD;
531             case Const.T_INT:
532                 return InstructionConst.IALOAD;
533             case Const.T_FLOAT:
534                 return InstructionConst.FALOAD;
535             case Const.T_DOUBLE:
536                 return InstructionConst.DALOAD;
537             case Const.T_LONG:
538                 return InstructionConst.LALOAD;
539             case Const.T_ARRAY:
540             case Const.T_OBJECT:
541                 return InstructionConst.AALOAD;
542             default:
543                 throw new RuntimeException(&quot;Invalid type &quot; + type);
544         }
545     }
546 
<span class="line-added">547 </span>
548     /**
549      * @param type type of elements of array, i.e., array.getElementType()
550      */
<span class="line-modified">551     public static ArrayInstruction createArrayStore( final Type type ) {</span>
552         switch (type.getType()) {
553             case Const.T_BOOLEAN:
554             case Const.T_BYTE:
555                 return InstructionConst.BASTORE;
556             case Const.T_CHAR:
557                 return InstructionConst.CASTORE;
558             case Const.T_SHORT:
559                 return InstructionConst.SASTORE;
560             case Const.T_INT:
561                 return InstructionConst.IASTORE;
562             case Const.T_FLOAT:
563                 return InstructionConst.FASTORE;
564             case Const.T_DOUBLE:
565                 return InstructionConst.DASTORE;
566             case Const.T_LONG:
567                 return InstructionConst.LASTORE;
568             case Const.T_ARRAY:
569             case Const.T_OBJECT:
570                 return InstructionConst.AASTORE;
571             default:
572                 throw new RuntimeException(&quot;Invalid type &quot; + type);
573         }
574     }
575 
576     /**
577      * Create conversion operation for two stack operands, this may be an I2C,
578      * instruction, e.g., if the operands are basic types and CHECKCAST if they
579      * are reference types.
580      */
<span class="line-modified">581     public Instruction createCast( final Type src_type, final Type dest_type ) {</span>
582         if ((src_type instanceof BasicType) &amp;&amp; (dest_type instanceof BasicType)) {
583             final byte dest = dest_type.getType();
584             byte src = src_type.getType();
585             if (dest == Const.T_LONG
586                     &amp;&amp; (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {
587                 src = Const.T_INT;
588             }
589             final String name = &quot;com.sun.org.apache.bcel.internal.generic.&quot; + short_names[src - Const.T_CHAR] + &quot;2&quot;
590                     + short_names[dest - Const.T_CHAR];
591             Instruction i = null;
592             try {
593                 i = (Instruction) java.lang.Class.forName(name).getDeclaredConstructor().newInstance();
594             } catch (final Exception e) {
595                 throw new RuntimeException(&quot;Could not find instruction: &quot; + name, e);
596             }
597             return i;
598         } else if ((src_type instanceof ReferenceType) &amp;&amp; (dest_type instanceof ReferenceType)) {
599             if (dest_type instanceof ArrayType) {
600                 return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));
601             }
602             return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
603         } else {
604             throw new RuntimeException(&quot;Can not cast &quot; + src_type + &quot; to &quot; + dest_type);
605         }
606     }
607 
<span class="line-modified">608 </span>
<span class="line-added">609     public GETFIELD createGetField( final String class_name, final String name, final Type t ) {</span>
610         return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));
611     }
612 
<span class="line-modified">613 </span>
<span class="line-added">614     public GETSTATIC createGetStatic( final String class_name, final String name, final Type t ) {</span>
615         return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
616     }
617 
<span class="line-modified">618 </span>
<span class="line-added">619     public PUTFIELD createPutField( final String class_name, final String name, final Type t ) {</span>
620         return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));
621     }
622 
<span class="line-modified">623 </span>
<span class="line-added">624     public PUTSTATIC createPutStatic( final String class_name, final String name, final Type t ) {</span>
625         return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));
626     }
627 
<span class="line-modified">628 </span>
<span class="line-added">629     public CHECKCAST createCheckCast( final ReferenceType t ) {</span>
630         if (t instanceof ArrayType) {
631             return new CHECKCAST(cp.addArrayClass((ArrayType) t));
632         }
633         return new CHECKCAST(cp.addClass((ObjectType) t));
634     }
635 
<span class="line-modified">636 </span>
<span class="line-added">637     public INSTANCEOF createInstanceOf( final ReferenceType t ) {</span>
638         if (t instanceof ArrayType) {
639             return new INSTANCEOF(cp.addArrayClass((ArrayType) t));
640         }
641         return new INSTANCEOF(cp.addClass((ObjectType) t));
642     }
643 
<span class="line-modified">644 </span>
<span class="line-added">645     public NEW createNew( final ObjectType t ) {</span>
646         return new NEW(cp.addClass(t));
647     }
648 
<span class="line-modified">649 </span>
<span class="line-added">650     public NEW createNew( final String s ) {</span>
651         return createNew(ObjectType.getInstance(s));
652     }
653 
654     /**
655      * Create new array of given size and type.
656      *
657      * @return an instruction that creates the corresponding array at runtime,
658      * i.e. is an AllocationInstruction
659      */
<span class="line-modified">660     public Instruction createNewArray( final Type t, final short dim ) {</span>
661         if (dim == 1) {
662             if (t instanceof ObjectType) {
663                 return new ANEWARRAY(cp.addClass((ObjectType) t));
664             } else if (t instanceof ArrayType) {
665                 return new ANEWARRAY(cp.addArrayClass((ArrayType) t));
666             } else {
667                 return new NEWARRAY(t.getType());
668             }
669         }
670         ArrayType at;
671         if (t instanceof ArrayType) {
672             at = (ArrayType) t;
673         } else {
674             at = new ArrayType(t, dim);
675         }
676         return new MULTIANEWARRAY(cp.addArrayClass(at), dim);
677     }
678 
679     /**
680      * Create &quot;null&quot; value for reference types, 0 for basic types like int
681      */
<span class="line-modified">682     public static Instruction createNull( final Type type ) {</span>
683         switch (type.getType()) {
684             case Const.T_ARRAY:
685             case Const.T_OBJECT:
686                 return InstructionConst.ACONST_NULL;
687             case Const.T_INT:
688             case Const.T_SHORT:
689             case Const.T_BOOLEAN:
690             case Const.T_CHAR:
691             case Const.T_BYTE:
692                 return InstructionConst.ICONST_0;
693             case Const.T_FLOAT:
694                 return InstructionConst.FCONST_0;
695             case Const.T_DOUBLE:
696                 return InstructionConst.DCONST_0;
697             case Const.T_LONG:
698                 return InstructionConst.LCONST_0;
699             case Const.T_VOID:
700                 return InstructionConst.NOP;
701             default:
702                 throw new RuntimeException(&quot;Invalid type: &quot; + type);
703         }
704     }
705 
706     /**
707      * Create branch instruction by given opcode, except LOOKUPSWITCH and
708      * TABLESWITCH. For those you should use the SWITCH compound instruction.
709      */
<span class="line-modified">710     public static BranchInstruction createBranchInstruction( final short opcode,</span>
<span class="line-added">711             final InstructionHandle target ) {</span>
712         switch (opcode) {
713             case Const.IFEQ:
714                 return new IFEQ(target);
715             case Const.IFNE:
716                 return new IFNE(target);
717             case Const.IFLT:
718                 return new IFLT(target);
719             case Const.IFGE:
720                 return new IFGE(target);
721             case Const.IFGT:
722                 return new IFGT(target);
723             case Const.IFLE:
724                 return new IFLE(target);
725             case Const.IF_ICMPEQ:
726                 return new IF_ICMPEQ(target);
727             case Const.IF_ICMPNE:
728                 return new IF_ICMPNE(target);
729             case Const.IF_ICMPLT:
730                 return new IF_ICMPLT(target);
731             case Const.IF_ICMPGE:
</pre>
<hr />
<pre>
738                 return new IF_ACMPEQ(target);
739             case Const.IF_ACMPNE:
740                 return new IF_ACMPNE(target);
741             case Const.GOTO:
742                 return new GOTO(target);
743             case Const.JSR:
744                 return new JSR(target);
745             case Const.IFNULL:
746                 return new IFNULL(target);
747             case Const.IFNONNULL:
748                 return new IFNONNULL(target);
749             case Const.GOTO_W:
750                 return new GOTO_W(target);
751             case Const.JSR_W:
752                 return new JSR_W(target);
753             default:
754                 throw new RuntimeException(&quot;Invalid opcode: &quot; + opcode);
755         }
756     }
757 
<span class="line-modified">758 </span>
<span class="line-added">759     public void setClassGen( final ClassGen c ) {</span>
760         cg = c;
761     }
762 
<span class="line-added">763 </span>
764     public ClassGen getClassGen() {
765         return cg;
766     }
767 
<span class="line-modified">768 </span>
<span class="line-added">769     public void setConstantPool( final ConstantPoolGen c ) {</span>
770         cp = c;
771     }
772 
<span class="line-added">773 </span>
774     public ConstantPoolGen getConstantPool() {
775         return cp;
776     }
777 }
</pre>
</td>
</tr>
</table>
<center><a href="InstructionConst.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionHandle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
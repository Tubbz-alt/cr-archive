<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.Const;
 24 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
 25 
 26 /**
<a name="1" id="anc1"></a><span class="line-modified"> 27  * Represents a local variable within a method. It contains its</span>
<span class="line-modified"> 28  * scope, name and type. The generated LocalVariable object can be obtained</span>
<span class="line-modified"> 29  * with getLocalVariable which needs the instruction list and the constant</span>
<span class="line-modified"> 30  * pool as parameters.</span>
 31  *
<a name="2" id="anc2"></a><span class="line-modified"> 32  * @see     LocalVariable</span>
<span class="line-modified"> 33  * @see     MethodGen</span>

 34  */
 35 public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Cloneable {
 36 
 37     private int index;
 38     private String name;
 39     private Type type;
 40     private InstructionHandle start;
 41     private InstructionHandle end;
<a name="3" id="anc3"></a><span class="line-added"> 42     private int orig_index; // never changes; used to match up with LocalVariableTypeTable entries</span>
<span class="line-added"> 43     private boolean live_to_end;</span>
<span class="line-added"> 44 </span>
 45 
 46     /**
<a name="4" id="anc4"></a><span class="line-modified"> 47      * Generate a local variable that with index `index&#39;. Note that double and long</span>
<span class="line-modified"> 48      * variables need two indexs. Index indices have to be provided by the user.</span>

 49      *
 50      * @param index index of local variable
 51      * @param name its name
 52      * @param type its type
<a name="5" id="anc5"></a><span class="line-modified"> 53      * @param start from where the instruction is valid (null means from the start)</span>

 54      * @param end until where the instruction is valid (null means to the end)
 55      */
<a name="6" id="anc6"></a><span class="line-modified"> 56     public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,</span>
<span class="line-modified"> 57             final InstructionHandle end) {</span>
 58         if ((index &lt; 0) || (index &gt; Const.MAX_SHORT)) {
 59             throw new ClassGenException(&quot;Invalid index index: &quot; + index);
 60         }
 61         this.name = name;
 62         this.type = type;
 63         this.index = index;
 64         setStart(start);
 65         setEnd(end);
<a name="7" id="anc7"></a><span class="line-added"> 66         this.orig_index = index;</span>
<span class="line-added"> 67         this.live_to_end = end == null;</span>
<span class="line-added"> 68     }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     /**</span>
<span class="line-added"> 72      * Generates a local variable that with index `index&#39;. Note that double and long</span>
<span class="line-added"> 73      * variables need two indexs. Index indices have to be provided by the user.</span>
<span class="line-added"> 74      *</span>
<span class="line-added"> 75      * @param index index of local variable</span>
<span class="line-added"> 76      * @param name its name</span>
<span class="line-added"> 77      * @param type its type</span>
<span class="line-added"> 78      * @param start from where the instruction is valid (null means from the start)</span>
<span class="line-added"> 79      * @param end until where the instruction is valid (null means to the end)</span>
<span class="line-added"> 80      * @param orig_index index of local variable prior to any changes to index</span>
<span class="line-added"> 81      */</span>
<span class="line-added"> 82     public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,</span>
<span class="line-added"> 83             final InstructionHandle end, final int orig_index) {</span>
<span class="line-added"> 84         this(index, name, type, start, end);</span>
<span class="line-added"> 85         this.orig_index = orig_index;</span>
 86     }
 87 
<a name="8" id="anc8"></a><span class="line-added"> 88 </span>
 89     /**
<a name="9" id="anc9"></a><span class="line-modified"> 90      * Gets LocalVariable object.</span>
 91      *
<a name="10" id="anc10"></a><span class="line-modified"> 92      * This relies on that the instruction list has already been dumped to byte code or</span>
<span class="line-modified"> 93      * or that the `setPositions&#39; methods has been called for the instruction list.</span>

 94      *
<a name="11" id="anc11"></a><span class="line-modified"> 95      * Note that due to the conversion from byte code offset to InstructionHandle,</span>
<span class="line-modified"> 96      * it is impossible to tell the difference between a live range that ends BEFORE</span>
<span class="line-modified"> 97      * the last insturction of the method or a live range that ends AFTER the last</span>
<span class="line-modified"> 98      * instruction of the method.  Hence the live_to_end flag to differentiate</span>
<span class="line-added"> 99      * between these two cases.</span>
100      *
101      * @param cp constant pool
102      */
<a name="12" id="anc12"></a><span class="line-modified">103     public LocalVariable getLocalVariable( final ConstantPoolGen cp ) {</span>
104         int start_pc = 0;
105         int length = 0;
106         if ((start != null) &amp;&amp; (end != null)) {
107             start_pc = start.getPosition();
108             length = end.getPosition() - start_pc;
<a name="13" id="anc13"></a><span class="line-modified">109             if ((end.getNext() == null) &amp;&amp; live_to_end) {</span>
110                 length += end.getInstruction().getLength();
111             }
112         }
113         final int name_index = cp.addUtf8(name);
114         final int signature_index = cp.addUtf8(type.getSignature());
115         return new LocalVariable(start_pc, length, name_index, signature_index, index, cp
<a name="14" id="anc14"></a><span class="line-modified">116                 .getConstantPool(), orig_index);</span>
117     }
118 
<a name="15" id="anc15"></a><span class="line-modified">119 </span>
<span class="line-added">120     public void setIndex( final int index ) {</span>
121         this.index = index;
122     }
123 
<a name="16" id="anc16"></a><span class="line-added">124 </span>
125     public int getIndex() {
126         return index;
127     }
128 
<a name="17" id="anc17"></a><span class="line-added">129 </span>
<span class="line-added">130     public int getOrigIndex() {</span>
<span class="line-added">131         return orig_index;</span>
<span class="line-added">132     }</span>
<span class="line-added">133 </span>
<span class="line-added">134 </span>
<span class="line-added">135     public void setLiveToEnd( final boolean live_to_end) {</span>
<span class="line-added">136         this.live_to_end = live_to_end;</span>
<span class="line-added">137     }</span>
<span class="line-added">138 </span>
<span class="line-added">139 </span>
<span class="line-added">140     public boolean getLiveToEnd() {</span>
<span class="line-added">141         return live_to_end;</span>
<span class="line-added">142     }</span>
<span class="line-added">143 </span>
<span class="line-added">144 </span>
145     @Override
<a name="18" id="anc18"></a><span class="line-modified">146     public void setName( final String name ) {</span>
147         this.name = name;
148     }
149 
<a name="19" id="anc19"></a><span class="line-added">150 </span>
151     @Override
152     public String getName() {
153         return name;
154     }
155 
<a name="20" id="anc20"></a><span class="line-added">156 </span>
157     @Override
<a name="21" id="anc21"></a><span class="line-modified">158     public void setType( final Type type ) {</span>
159         this.type = type;
160     }
161 
<a name="22" id="anc22"></a><span class="line-added">162 </span>
163     @Override
164     public Type getType() {
165         return type;
166     }
167 
<a name="23" id="anc23"></a><span class="line-added">168 </span>
169     public InstructionHandle getStart() {
170         return start;
171     }
172 
<a name="24" id="anc24"></a><span class="line-added">173 </span>
174     public InstructionHandle getEnd() {
175         return end;
176     }
177 
<a name="25" id="anc25"></a><span class="line-modified">178 </span>
<span class="line-added">179     public void setStart( final InstructionHandle start ) { // TODO could be package-protected?</span>
180         BranchInstruction.notifyTarget(this.start, start, this);
181         this.start = start;
182     }
183 
<a name="26" id="anc26"></a><span class="line-modified">184 </span>
<span class="line-added">185     public void setEnd( final InstructionHandle end ) { // TODO could be package-protected?</span>
186         BranchInstruction.notifyTarget(this.end, end, this);
187         this.end = end;
188     }
189 
<a name="27" id="anc27"></a><span class="line-added">190 </span>
191     /**
192      * @param old_ih old target, either start or end
193      * @param new_ih new target
194      */
195     @Override
<a name="28" id="anc28"></a><span class="line-modified">196     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
197         boolean targeted = false;
198         if (start == old_ih) {
199             targeted = true;
200             setStart(new_ih);
201         }
202         if (end == old_ih) {
203             targeted = true;
204             setEnd(new_ih);
205         }
206         if (!targeted) {
207             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start + &quot;, &quot; + end
208                     + &quot;}&quot;);
209         }
210     }
211 
212     /**
213      * Clear the references from and to this variable when it&#39;s removed.
214      */
215     void dispose() {
216         setStart(null);
217         setEnd(null);
218     }
219 
220     /**
221      * @return true, if ih is target of this variable
222      */
223     @Override
<a name="29" id="anc29"></a><span class="line-modified">224     public boolean containsTarget( final InstructionHandle ih ) {</span>
225         return (start == ih) || (end == ih);
226     }
227 
<a name="30" id="anc30"></a><span class="line-added">228 </span>
229     @Override
230     public int hashCode() {
231         // If the user changes the name or type, problems with the targeter hashmap will occur.
232         // Note: index cannot be part of hash as it may be changed by the user.
233         return name.hashCode() ^ type.hashCode();
234     }
235 
<a name="31" id="anc31"></a><span class="line-added">236 </span>
237     /**
238      * We consider to local variables to be equal, if the use the same index and
239      * are valid in the same range.
240      */
241     @Override
<a name="32" id="anc32"></a><span class="line-modified">242     public boolean equals( final Object o ) {</span>
243         if (!(o instanceof LocalVariableGen)) {
244             return false;
245         }
246         final LocalVariableGen l = (LocalVariableGen) o;
247         return (l.index == index) &amp;&amp; (l.start == start) &amp;&amp; (l.end == end);
248     }
249 
<a name="33" id="anc33"></a><span class="line-added">250 </span>
251     @Override
252     public String toString() {
253         return &quot;LocalVariableGen(&quot; + name + &quot;, &quot; + type + &quot;, &quot; + start + &quot;, &quot; + end + &quot;)&quot;;
254     }
255 
<a name="34" id="anc34"></a><span class="line-added">256 </span>
257     @Override
258     public Object clone() {
259         try {
260             return super.clone();
261         } catch (final CloneNotSupportedException e) {
262             throw new Error(&quot;Clone Not Supported&quot;); // never happens
263         }
264     }
265 }
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="35" type="hidden" />
</body>
</html>
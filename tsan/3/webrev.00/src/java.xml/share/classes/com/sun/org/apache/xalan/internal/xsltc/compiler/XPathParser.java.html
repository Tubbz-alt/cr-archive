<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/XPathParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.org.apache.xalan.internal.xsltc.compiler;
  27 
  28 import com.sun.java_cup.internal.runtime.*;
  29 import com.sun.org.apache.xalan.internal.xsltc.DOM;
  30 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
  31 import com.sun.org.apache.xalan.internal.xsltc.runtime.Operators;
  32 import com.sun.org.apache.xml.internal.dtm.Axis;
  33 import com.sun.org.apache.xml.internal.dtm.DTM;
  34 import java.util.ArrayList;
  35 import java.util.List;
  36 import java.util.Stack;
  37 
  38 /**
  39  * CUP v0.11b generated parser.
  40  * This class was generated by CUP v0.11b on Nov 12, 2019.
  41  *
  42  * @LastModified: Nov 2019
  43  */
  44 public class XPathParser extends lr_parser {
  45 
  46     /**
  47      * Default constructor.
  48      */
  49     public XPathParser() {
  50         super();
  51     }
  52 
  53     /**
  54      * Constructor which sets the default scanner.
  55      */
  56     public XPathParser(Scanner s) {
  57         super(s);
  58     }
  59 
  60     /**
  61      * Production table.
  62      */
  63     protected static final short _production_table[][]
  64             = unpackFromStrings(new String[]{
  65         &quot;\000\215\000\002\002\004\000\002\003\004\000\002\003&quot;
  66         + &quot;\004\000\002\036\003\000\002\036\005\000\002\037\003&quot;
  67         + &quot;\000\002\037\004\000\002\037\003\000\002\037\005\000&quot;
  68         + &quot;\002\037\005\000\002\037\004\000\002\037\003\000\002&quot;
  69         + &quot;\035\006\000\002\035\010\000\002\040\006\000\002\041&quot;
  70         + &quot;\003\000\002\041\005\000\002\041\005\000\002\042\003&quot;
  71         + &quot;\000\002\042\004\000\002\042\003\000\002\042\004\000&quot;
  72         + &quot;\002\042\004\000\002\042\005\000\002\042\004\000\002&quot;
  73         + &quot;\042\005\000\002\043\003\000\002\043\003\000\002\043&quot;
  74         + &quot;\003\000\002\043\003\000\002\043\003\000\002\044\003&quot;
  75         + &quot;\000\002\044\003\000\002\054\003\000\002\054\004\000&quot;
  76         + &quot;\002\054\004\000\002\045\003\000\002\045\004\000\002&quot;
  77         + &quot;\007\005\000\002\004\003\000\002\012\003\000\002\012&quot;
  78         + &quot;\005\000\002\013\003\000\002\013\005\000\002\014\003&quot;
  79         + &quot;\000\002\014\005\000\002\014\005\000\002\015\003\000&quot;
  80         + &quot;\002\015\005\000\002\015\005\000\002\015\005\000\002&quot;
  81         + &quot;\015\005\000\002\016\003\000\002\016\005\000\002\016&quot;
  82         + &quot;\005\000\002\017\003\000\002\017\005\000\002\017\005&quot;
  83         + &quot;\000\002\017\005\000\002\020\003\000\002\020\004\000&quot;
  84         + &quot;\002\024\003\000\002\024\005\000\002\025\003\000\002&quot;
  85         + &quot;\025\003\000\002\025\005\000\002\025\005\000\002\006&quot;
  86         + &quot;\003\000\002\006\003\000\002\027\003\000\002\027\005&quot;
  87         + &quot;\000\002\027\003\000\002\031\003\000\002\031\004\000&quot;
  88         + &quot;\002\031\003\000\002\030\005\000\002\032\004\000\002&quot;
  89         + &quot;\011\003\000\002\011\004\000\002\011\005\000\002\011&quot;
  90         + &quot;\004\000\002\011\003\000\002\053\004\000\002\053\003&quot;
  91         + &quot;\000\002\052\003\000\002\052\003\000\002\052\003\000&quot;
  92         + &quot;\002\052\003\000\002\052\003\000\002\052\003\000\002&quot;
  93         + &quot;\052\003\000\002\052\003\000\002\052\003\000\002\052&quot;
  94         + &quot;\003\000\002\052\003\000\002\052\003\000\002\052\003&quot;
  95         + &quot;\000\002\026\003\000\002\026\003\000\002\010\003\000&quot;
  96         + &quot;\002\010\004\000\002\023\003\000\002\023\005\000\002&quot;
  97         + &quot;\023\003\000\002\023\003\000\002\023\003\000\002\023&quot;
  98         + &quot;\003\000\002\021\004\000\002\022\005\000\002\022\006&quot;
  99         + &quot;\000\002\046\003\000\002\046\005\000\002\050\003\000&quot;
 100         + &quot;\002\051\003\000\002\005\003\000\002\033\003\000\002&quot;
 101         + &quot;\033\003\000\002\033\003\000\002\033\003\000\002\033&quot;
 102         + &quot;\006\000\002\033\003\000\002\034\003\000\002\034\003&quot;
 103         + &quot;\000\002\047\003\000\002\047\003\000\002\047\003\000&quot;
 104         + &quot;\002\047\003\000\002\047\003\000\002\047\003\000\002&quot;
 105         + &quot;\047\003\000\002\047\003\000\002\047\003\000\002\047&quot;
 106         + &quot;\003\000\002\047\003\000\002\047\003\000\002\047\003&quot;
 107         + &quot;\000\002\047\003\000\002\047\003\000\002\047\003\000&quot;
 108         + &quot;\002\047\003\000\002\047\003&quot;});
 109 
 110     /**
 111      * Access to production table.
 112      */
 113     public short[][] production_table() {
 114         return _production_table;
 115     }
 116 
 117     /**
 118      * Parse-action table.
 119      */
 120     protected static final short[][] _action_table
 121             = unpackFromStrings(new String[]{
 122         &quot;\000\307\000\006\066\006\067\005\001\002\000\004\002&quot;
 123         + &quot;\311\001\002\000\110\004\061\005\111\011\071\013\103&quot;
 124         + &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot;
 125         + &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot;
 126         + &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot;
 127         + &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot;
 128         + &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot;
 129         + &quot;\070\004\013\013\027\016\020\021\023\032\031\033\040&quot;
 130         + &quot;\035\034\036\033\037\046\040\047\041\051\044\015\045&quot;
 131         + &quot;\014\046\016\047\036\050\037\051\044\052\025\053\050&quot;
 132         + &quot;\054\043\055\041\056\035\057\030\060\045\061\021\062&quot;
 133         + &quot;\012\063\042\001\002\000\006\002\ufffe\010\306\001\002&quot;
 134         + &quot;\000\004\002\000\001\002\000\014\002\uffe7\004\uffe7\006&quot;
 135         + &quot;\uffe7\010\uffe7\021\uffe7\001\002\000\054\002\uff7a\004\uff7a&quot;
 136         + &quot;\006\uff7a\007\uff7a\010\uff7a\012\uff7a\013\uff7a\014\uff7a\021&quot;
 137         + &quot;\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027\uff7a&quot;
 138         + &quot;\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a\001&quot;
 139         + &quot;\002\000\070\002\ufffc\010\ufffc\013\027\016\020\032\031&quot;
 140         + &quot;\033\040\035\034\036\113\037\141\040\047\041\051\044&quot;
 141         + &quot;\015\045\014\046\016\047\036\050\037\051\044\052\025&quot;
 142         + &quot;\053\050\054\043\055\041\056\035\057\030\060\045\061&quot;
 143         + &quot;\021\062\012\063\042\001\002\000\014\002\uffe3\004\uffe3&quot;
 144         + &quot;\006\uffe3\010\uffe3\021\uffe3\001\002\000\014\002\uffe4\004&quot;
 145         + &quot;\uffe4\006\uffe4\010\uffe4\021\uffe4\001\002\000\004\011\302&quot;
 146         + &quot;\001\002\000\012\002\ufffa\004\277\010\ufffa\021\276\001&quot;
 147         + &quot;\002\000\062\013\uffe0\032\uffe0\033\uffe0\035\uffe0\036\uffe0&quot;
 148         + &quot;\037\uffe0\040\uffe0\041\uffe0\044\uffe0\045\uffe0\046\uffe0\047&quot;
 149         + &quot;\uffe0\050\uffe0\051\uffe0\052\uffe0\053\uffe0\054\uffe0\055\uffe0&quot;
 150         + &quot;\056\uffe0\057\uffe0\060\uffe0\061\uffe0\062\uffe0\063\uffe0\001&quot;
 151         + &quot;\002\000\054\002\uff7b\004\uff7b\006\uff7b\007\uff7b\010\uff7b&quot;
 152         + &quot;\012\uff7b\013\uff7b\014\uff7b\021\uff7b\022\uff7b\023\uff7b\024&quot;
 153         + &quot;\uff7b\025\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b&quot;
 154         + &quot;\033\uff7b\042\uff7b\043\uff7b\001\002\000\062\013\027\032&quot;
 155         + &quot;\031\033\040\035\034\036\113\037\141\040\047\041\051&quot;
 156         + &quot;\044\015\045\014\046\016\047\036\050\037\051\044\052&quot;
 157         + &quot;\170\053\166\054\043\055\041\056\035\057\030\060\045&quot;
 158         + &quot;\061\021\062\012\063\042\001\002\000\064\013\027\016&quot;
 159         + &quot;\020\032\031\033\040\035\034\036\113\037\141\040\047&quot;
 160         + &quot;\041\051\044\015\045\014\046\016\047\036\050\037\051&quot;
 161         + &quot;\044\052\025\053\050\054\043\055\041\056\035\057\030&quot;
 162         + &quot;\060\045\061\021\062\012\063\042\001\002\000\012\002&quot;
 163         + &quot;\ufff2\004\266\010\ufff2\021\265\001\002\000\016\002\uff7f&quot;
 164         + &quot;\004\uff7f\006\uff7f\010\uff7f\020\264\021\uff7f\001\002\000&quot;
 165         + &quot;\006\002\ufff6\010\ufff6\001\002\000\014\002\uffe2\004\uffe2&quot;
 166         + &quot;\006\uffe2\010\uffe2\021\uffe2\001\002\000\054\002\uff7d\004&quot;
 167         + &quot;\uff7d\006\uff7d\007\uff7d\010\uff7d\012\uff7d\013\uff7d\014\uff7d&quot;
 168         + &quot;\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025\uff7d\026\uff7d\027&quot;
 169         + &quot;\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d\042\uff7d\043\uff7d&quot;
 170         + &quot;\001\002\000\056\002\uff85\004\uff85\006\uff85\007\uff85\010&quot;
 171         + &quot;\uff85\011\uff85\012\uff85\013\uff85\014\uff85\021\uff85\022\uff85&quot;
 172         + &quot;\023\uff85\024\uff85\025\uff85\026\uff85\027\uff85\030\uff85\031&quot;
 173         + &quot;\uff85\032\uff85\033\uff85\042\uff85\043\uff85\001\002\000\014&quot;
 174         + &quot;\002\uffed\004\uffed\006\055\010\uffed\021\uffed\001\002\000&quot;
 175         + &quot;\016\002\uff75\004\uff75\006\uff75\010\uff75\011\260\021\uff75&quot;
 176         + &quot;\001\002\000\056\002\uff86\004\uff86\006\uff86\007\uff86\010&quot;
 177         + &quot;\uff86\011\uff86\012\uff86\013\uff86\014\uff86\021\uff86\022\uff86&quot;
 178         + &quot;\023\uff86\024\uff86\025\uff86\026\uff86\027\uff86\030\uff86\031&quot;
 179         + &quot;\uff86\032\uff86\033\uff86\042\uff86\043\uff86\001\002\000\054&quot;
 180         + &quot;\002\uff7e\004\uff7e\006\uff7e\007\uff7e\010\uff7e\012\uff7e\013&quot;
 181         + &quot;\uff7e\014\uff7e\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e&quot;
 182         + &quot;\026\uff7e\027\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042&quot;
 183         + &quot;\uff7e\043\uff7e\001\002\000\054\002\uff77\004\uff77\006\uff77&quot;
 184         + &quot;\007\uff77\010\uff77\012\uff77\013\uff77\014\uff77\021\uff77\022&quot;
 185         + &quot;\uff77\023\uff77\024\uff77\025\uff77\026\uff77\027\uff77\030\uff77&quot;
 186         + &quot;\031\uff77\032\uff77\033\uff77\042\uff77\043\uff77\001\002\000&quot;
 187         + &quot;\054\002\uff76\004\uff76\006\uff76\007\uff76\010\uff76\012\uff76&quot;
 188         + &quot;\013\uff76\014\uff76\021\uff76\022\uff76\023\uff76\024\uff76\025&quot;
 189         + &quot;\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76&quot;
 190         + &quot;\042\uff76\043\uff76\001\002\000\056\002\uff84\004\uff84\006&quot;
 191         + &quot;\uff84\007\uff84\010\uff84\011\uff84\012\uff84\013\uff84\014\uff84&quot;
 192         + &quot;\021\uff84\022\uff84\023\uff84\024\uff84\025\uff84\026\uff84\027&quot;
 193         + &quot;\uff84\030\uff84\031\uff84\032\uff84\033\uff84\042\uff84\043\uff84&quot;
 194         + &quot;\001\002\000\054\002\uff81\004\uff81\006\uff81\007\uff81\010&quot;
 195         + &quot;\uff81\012\uff81\013\uff81\014\uff81\021\uff81\022\uff81\023\uff81&quot;
 196         + &quot;\024\uff81\025\uff81\026\uff81\027\uff81\030\uff81\031\uff81\032&quot;
 197         + &quot;\uff81\033\uff81\042\uff81\043\uff81\001\002\000\054\002\uff78&quot;
 198         + &quot;\004\uff78\006\uff78\007\uff78\010\uff78\012\uff78\013\uff78\014&quot;
 199         + &quot;\uff78\021\uff78\022\uff78\023\uff78\024\uff78\025\uff78\026\uff78&quot;
 200         + &quot;\027\uff78\030\uff78\031\uff78\032\uff78\033\uff78\042\uff78\043&quot;
 201         + &quot;\uff78\001\002\000\054\002\uff82\004\uff82\006\uff82\007\uff82&quot;
 202         + &quot;\010\uff82\012\uff82\013\uff82\014\uff82\021\uff82\022\uff82\023&quot;
 203         + &quot;\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030\uff82\031\uff82&quot;
 204         + &quot;\032\uff82\033\uff82\042\uff82\043\uff82\001\002\000\054\002&quot;
 205         + &quot;\uff79\004\uff79\006\uff79\007\uff79\010\uff79\012\uff79\013\uff79&quot;
 206         + &quot;\014\uff79\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026&quot;
 207         + &quot;\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79&quot;
 208         + &quot;\043\uff79\001\002\000\054\002\uff7c\004\uff7c\006\uff7c\007&quot;
 209         + &quot;\uff7c\010\uff7c\012\uff7c\013\uff7c\014\uff7c\021\uff7c\022\uff7c&quot;
 210         + &quot;\023\uff7c\024\uff7c\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031&quot;
 211         + &quot;\uff7c\032\uff7c\033\uff7c\042\uff7c\043\uff7c\001\002\000\016&quot;
 212         + &quot;\002\uff83\004\uff83\006\uff83\010\uff83\011\253\021\uff83\001&quot;
 213         + &quot;\002\000\014\002\uffe5\004\uffe5\006\uffe5\010\uffe5\021\uffe5&quot;
 214         + &quot;\001\002\000\016\002\uff80\004\uff80\006\uff80\010\uff80\020&quot;
 215         + &quot;\252\021\uff80\001\002\000\014\002\uffe6\004\uffe6\006\uffe6&quot;
 216         + &quot;\010\uffe6\021\uffe6\001\002\000\014\002\uffe1\004\uffe1\006&quot;
 217         + &quot;\uffe1\010\uffe1\021\uffe1\001\002\000\014\002\uffef\004\uffef&quot;
 218         + &quot;\006\055\010\uffef\021\uffef\001\002\000\054\002\uffdd\004&quot;
 219         + &quot;\uffdd\006\055\007\uffdd\010\uffdd\012\uffdd\013\uffdd\014\uffdd&quot;
 220         + &quot;\021\uffdd\022\uffdd\023\uffdd\024\uffdd\025\uffdd\026\uffdd\027&quot;
 221         + &quot;\uffdd\030\uffdd\031\uffdd\032\uffdd\033\uffdd\042\uffdd\043\uffdd&quot;
 222         + &quot;\001\002\000\110\004\061\005\111\011\071\013\103\015&quot;
 223         + &quot;\134\016\066\017\106\021\070\031\075\032\031\033\040&quot;
 224         + &quot;\034\057\035\034\036\113\037\141\040\142\041\145\044&quot;
 225         + &quot;\063\045\062\046\065\047\115\050\123\051\136\052\077&quot;
 226         + &quot;\053\143\054\131\055\125\056\116\057\104\060\140\061&quot;
 227         + &quot;\067\062\060\063\127\064\132\065\072\001\002\000\012&quot;
 228         + &quot;\002\uffee\004\uffee\010\uffee\021\uffee\001\002\000\054\002&quot;
 229         + &quot;\uff9a\004\uff9a\006\uff9a\007\uff9a\010\uff9a\012\uff9a\013\uff9a&quot;
 230         + &quot;\014\uff9a\021\uff9a\022\uff9a\023\uff9a\024\uff9a\025\uff9a\026&quot;
 231         + &quot;\uff9a\027\uff9a\030\uff9a\031\uff9a\032\uff9a\033\uff9a\042\uff9a&quot;
 232         + &quot;\043\uff9a\001\002\000\060\002\uff7a\004\uff7a\006\uff7a\007&quot;
 233         + &quot;\uff7a\010\uff7a\011\uff7a\012\uff7a\013\uff7a\014\uff7a\020\uffa5&quot;
 234         + &quot;\021\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027&quot;
 235         + &quot;\uff7a\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a&quot;
 236         + &quot;\001\002\000\126\002\uffb9\005\111\007\uffb9\010\uffb9\012&quot;
 237         + &quot;\uffb9\013\103\014\uffb9\016\066\017\106\022\uffb9\023\uffb9&quot;
 238         + &quot;\024\uffb9\025\uffb9\026\uffb9\027\uffb9\030\uffb9\031\uffb9\032&quot;
 239         + &quot;\031\033\040\035\034\036\113\037\141\040\142\041\145&quot;
 240         + &quot;\042\uffb9\043\uffb9\044\063\045\062\046\065\047\115\050&quot;
 241         + &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot;
 242         + &quot;\057\104\060\140\061\067\062\060\063\127\001\002\000&quot;
 243         + &quot;\054\002\uff89\004\uff89\006\uff89\007\uff89\010\uff89\012\uff89&quot;
 244         + &quot;\013\uff89\014\uff89\021\uff89\022\uff89\023\uff89\024\uff89\025&quot;
 245         + &quot;\uff89\026\uff89\027\uff89\030\uff89\031\uff89\032\uff89\033\uff89&quot;
 246         + &quot;\042\uff89\043\uff89\001\002\000\054\002\uff8b\004\uff8b\006&quot;
 247         + &quot;\uff8b\007\uff8b\010\uff8b\012\uff8b\013\uff8b\014\uff8b\021\uff8b&quot;
 248         + &quot;\022\uff8b\023\uff8b\024\uff8b\025\uff8b\026\uff8b\027\uff8b\030&quot;
 249         + &quot;\uff8b\031\uff8b\032\uff8b\033\uff8b\042\uff8b\043\uff8b\001\002&quot;
 250         + &quot;\000\032\002\uffd5\007\uffd5\012\uffd5\014\uffd5\022\uffd5\023&quot;
 251         + &quot;\uffd5\024\221\025\222\026\223\027\224\042\uffd5\043\uffd5&quot;
 252         + &quot;\001\002\000\004\011\245\001\002\000\062\013\uffae\032&quot;
 253         + &quot;\uffae\033\uffae\035\uffae\036\uffae\037\uffae\040\uffae\041\uffae&quot;
 254         + &quot;\044\uffae\045\uffae\046\uffae\047\uffae\050\uffae\051\uffae\052&quot;
 255         + &quot;\uffae\053\uffae\054\uffae\055\uffae\056\uffae\057\uffae\060\uffae&quot;
 256         + &quot;\061\uffae\062\uffae\063\uffae\001\002\000\060\002\uff7b\004&quot;
 257         + &quot;\uff7b\006\uff7b\007\uff7b\010\uff7b\011\uff7b\012\uff7b\013\uff7b&quot;
 258         + &quot;\014\uff7b\020\uffa6\021\uff7b\022\uff7b\023\uff7b\024\uff7b\025&quot;
 259         + &quot;\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b\033\uff7b&quot;
 260         + &quot;\042\uff7b\043\uff7b\001\002\000\070\005\111\013\103\016&quot;
 261         + &quot;\066\017\106\032\031\033\040\035\034\036\113\037\141&quot;
 262         + &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot;
 263         + &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot;
 264         + &quot;\057\104\060\140\061\067\062\060\063\127\001\002\000&quot;
 265         + &quot;\110\004\061\005\111\011\071\013\103\015\134\016\066&quot;
 266         + &quot;\017\106\021\070\031\075\032\031\033\040\034\057\035&quot;
 267         + &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot;
 268         + &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot;
 269         + &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot;
 270         + &quot;\063\127\064\132\065\072\001\002\000\054\002\uff99\004&quot;
 271         + &quot;\uff99\006\uff99\007\uff99\010\uff99\012\uff99\013\uff99\014\uff99&quot;
 272         + &quot;\021\uff99\022\uff99\023\uff99\024\uff99\025\uff99\026\uff99\027&quot;
 273         + &quot;\uff99\030\uff99\031\uff99\032\uff99\033\uff99\042\uff99\043\uff99&quot;
 274         + &quot;\001\002\000\046\002\uffb7\007\uffb7\010\uffb7\012\uffb7\013&quot;
 275         + &quot;\uffb7\014\uffb7\022\uffb7\023\uffb7\024\uffb7\025\uffb7\026\uffb7&quot;
 276         + &quot;\027\uffb7\030\uffb7\031\uffb7\032\uffb7\033\uffb7\042\uffb7\043&quot;
 277         + &quot;\uffb7\001\002\000\054\002\uff97\004\uff97\006\uff97\007\uff97&quot;
 278         + &quot;\010\uff97\012\uff97\013\uff97\014\uff97\021\uff97\022\uff97\023&quot;
 279         + &quot;\uff97\024\uff97\025\uff97\026\uff97\027\uff97\030\uff97\031\uff97&quot;
 280         + &quot;\032\uff97\033\uff97\042\uff97\043\uff97\001\002\000\110\004&quot;
 281         + &quot;\061\005\111\011\071\013\103\015\134\016\066\017\106&quot;
 282         + &quot;\021\070\031\075\032\031\033\040\034\057\035\034\036&quot;
 283         + &quot;\113\037\141\040\142\041\145\044\063\045\062\046\065&quot;
 284         + &quot;\047\115\050\123\051\136\052\077\053\143\054\131\055&quot;
 285         + &quot;\125\056\116\057\104\060\140\061\067\062\060\063\127&quot;
 286         + &quot;\064\132\065\072\001\002\000\016\002\uffd9\007\uffd9\012&quot;
 287         + &quot;\uffd9\014\uffd9\042\uffd9\043\234\001\002\000\060\002\uff7f&quot;
 288         + &quot;\004\uff7f\006\uff7f\007\uff7f\010\uff7f\011\uff7f\012\uff7f\013&quot;
 289         + &quot;\uff7f\014\uff7f\020\uffaa\021\uff7f\022\uff7f\023\uff7f\024\uff7f&quot;
 290         + &quot;\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031\uff7f\032\uff7f\033&quot;
 291         + &quot;\uff7f\042\uff7f\043\uff7f\001\002\000\062\013\103\032\031&quot;
 292         + &quot;\033\040\035\034\036\113\037\141\040\142\041\145\044&quot;
 293         + &quot;\063\045\062\046\065\047\036\050\037\051\044\052\170&quot;
 294         + &quot;\053\166\054\043\055\041\056\035\057\030\060\045\061&quot;
 295         + &quot;\021\062\012\063\042\001\002\000\004\020\236\001\002&quot;
 296         + &quot;\000\014\002\uffda\007\uffda\012\uffda\014\uffda\042\232\001&quot;
 297         + &quot;\002\000\054\002\uff88\004\uff88\006\uff88\007\uff88\010\uff88&quot;
 298         + &quot;\012\uff88\013\uff88\014\uff88\021\uff88\022\uff88\023\uff88\024&quot;
 299         + &quot;\uff88\025\uff88\026\uff88\027\uff88\030\uff88\031\uff88\032\uff88&quot;
 300         + &quot;\033\uff88\042\uff88\043\uff88\001\002\000\060\002\uff7d\004&quot;
 301         + &quot;\uff7d\006\uff7d\007\uff7d\010\uff7d\011\uff7d\012\uff7d\013\uff7d&quot;
 302         + &quot;\014\uff7d\020\uffa8\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025&quot;
 303         + &quot;\uff7d\026\uff7d\027\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d&quot;
 304         + &quot;\042\uff7d\043\uff7d\001\002\000\022\002\uffd7\007\uffd7\012&quot;
 305         + &quot;\uffd7\014\uffd7\022\216\023\217\042\uffd7\043\uffd7\001\002&quot;
 306         + &quot;\000\052\002\uff9f\004\uff9f\007\uff9f\010\uff9f\012\uff9f\013&quot;
 307         + &quot;\uff9f\014\uff9f\021\uff9f\022\uff9f\023\uff9f\024\uff9f\025\uff9f&quot;
 308         + &quot;\026\uff9f\027\uff9f\030\uff9f\031\uff9f\032\uff9f\033\uff9f\042&quot;
 309         + &quot;\uff9f\043\uff9f\001\002\000\054\002\uffb4\004\uffb4\006\055&quot;
 310         + &quot;\007\uffb4\010\uffb4\012\uffb4\013\uffb4\014\uffb4\021\uffb4\022&quot;
 311         + &quot;\uffb4\023\uffb4\024\uffb4\025\uffb4\026\uffb4\027\uffb4\030\uffb4&quot;
 312         + &quot;\031\uffb4\032\uffb4\033\uffb4\042\uffb4\043\uffb4\001\002\000&quot;
 313         + &quot;\046\002\uffbd\007\uffbd\010\uffbd\012\uffbd\013\uffbd\014\uffbd&quot;
 314         + &quot;\022\uffbd\023\uffbd\024\uffbd\025\uffbd\026\uffbd\027\uffbd\030&quot;
 315         + &quot;\uffbd\031\uffbd\032\uffbd\033\uffbd\042\uffbd\043\uffbd\001\002&quot;
 316         + &quot;\000\052\002\uffa0\004\uffa0\007\uffa0\010\uffa0\012\uffa0\013&quot;
 317         + &quot;\uffa0\014\uffa0\021\uffa0\022\uffa0\023\uffa0\024\uffa0\025\uffa0&quot;
 318         + &quot;\026\uffa0\027\uffa0\030\uffa0\031\uffa0\032\uffa0\033\uffa0\042&quot;
 319         + &quot;\uffa0\043\uffa0\001\002\000\036\002\uffd2\007\uffd2\012\uffd2&quot;
 320         + &quot;\014\uffd2\022\uffd2\023\uffd2\024\uffd2\025\uffd2\026\uffd2\027&quot;
 321         + &quot;\uffd2\030\211\031\212\042\uffd2\043\uffd2\001\002\000\056&quot;
 322         + &quot;\002\uff75\004\uff75\006\uff75\007\uff75\010\uff75\011\uff75\012&quot;
 323         + &quot;\uff75\013\uff75\014\uff75\021\uff75\022\uff75\023\uff75\024\uff75&quot;
 324         + &quot;\025\uff75\026\uff75\027\uff75\030\uff75\031\uff75\032\uff75\033&quot;
 325         + &quot;\uff75\042\uff75\043\uff75\001\002\000\044\002\uffca\007\uffca&quot;
 326         + &quot;\012\uffca\013\uffca\014\uffca\022\uffca\023\uffca\024\uffca\025&quot;
 327         + &quot;\uffca\026\uffca\027\uffca\030\uffca\031\uffca\032\uffca\033\uffca&quot;
 328         + &quot;\042\uffca\043\uffca\001\002\000\060\002\uff77\004\uff77\006&quot;
 329         + &quot;\uff77\007\uff77\010\uff77\011\uff77\012\uff77\013\uff77\014\uff77&quot;
 330         + &quot;\020\uffa2\021\uff77\022\uff77\023\uff77\024\uff77\025\uff77\026&quot;
 331         + &quot;\uff77\027\uff77\030\uff77\031\uff77\032\uff77\033\uff77\042\uff77&quot;
 332         + &quot;\043\uff77\001\002\000\060\002\uff7e\004\uff7e\006\uff7e\007&quot;
 333         + &quot;\uff7e\010\uff7e\011\uff7e\012\uff7e\013\uff7e\014\uff7e\020\uffa9&quot;
 334         + &quot;\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e\026\uff7e\027&quot;
 335         + &quot;\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042\uff7e\043\uff7e&quot;
 336         + &quot;\001\002\000\004\011\201\001\002\000\052\002\uffbc\004&quot;
 337         + &quot;\uffbc\007\uffbc\010\uffbc\012\uffbc\013\uffbc\014\uffbc\021\uffbc&quot;
 338         + &quot;\022\uffbc\023\uffbc\024\uffbc\025\uffbc\026\uffbc\027\uffbc\030&quot;
 339         + &quot;\uffbc\031\uffbc\032\uffbc\033\uffbc\042\uffbc\043\uffbc\001\002&quot;
 340         + &quot;\000\046\002\uffc2\007\uffc2\010\uffc2\012\uffc2\013\uffc2\014&quot;
 341         + &quot;\uffc2\022\uffc2\023\uffc2\024\uffc2\025\uffc2\026\uffc2\027\uffc2&quot;
 342         + &quot;\030\uffc2\031\uffc2\032\uffc2\033\uffc2\042\uffc2\043\uffc2\001&quot;
 343         + &quot;\002\000\054\002\uff9e\004\uff9e\006\055\007\uff9e\010\uff9e&quot;
 344         + &quot;\012\uff9e\013\uff9e\014\uff9e\021\uff9e\022\uff9e\023\uff9e\024&quot;
 345         + &quot;\uff9e\025\uff9e\026\uff9e\027\uff9e\030\uff9e\031\uff9e\032\uff9e&quot;
 346         + &quot;\033\uff9e\042\uff9e\043\uff9e\001\002\000\060\002\uff76\004&quot;
 347         + &quot;\uff76\006\uff76\007\uff76\010\uff76\011\uff76\012\uff76\013\uff76&quot;
 348         + &quot;\014\uff76\020\uffa1\021\uff76\022\uff76\023\uff76\024\uff76\025&quot;
 349         + &quot;\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76&quot;
 350         + &quot;\042\uff76\043\uff76\001\002\000\046\002\uffc4\007\uffc4\010&quot;
 351         + &quot;\176\012\uffc4\013\uffc4\014\uffc4\022\uffc4\023\uffc4\024\uffc4&quot;
 352         + &quot;\025\uffc4\026\uffc4\027\uffc4\030\uffc4\031\uffc4\032\uffc4\033&quot;
 353         + &quot;\uffc4\042\uffc4\043\uffc4\001\002\000\060\002\uff81\004\uff81&quot;
 354         + &quot;\006\uff81\007\uff81\010\uff81\011\uff81\012\uff81\013\uff81\014&quot;
 355         + &quot;\uff81\020\uffac\021\uff81\022\uff81\023\uff81\024\uff81\025\uff81&quot;
 356         + &quot;\026\uff81\027\uff81\030\uff81\031\uff81\032\uff81\033\uff81\042&quot;
 357         + &quot;\uff81\043\uff81\001\002\000\054\002\uff9c\004\uff9c\006\uff9c&quot;
 358         + &quot;\007\uff9c\010\uff9c\012\uff9c\013\uff9c\014\uff9c\021\uff9c\022&quot;
 359         + &quot;\uff9c\023\uff9c\024\uff9c\025\uff9c\026\uff9c\027\uff9c\030\uff9c&quot;
 360         + &quot;\031\uff9c\032\uff9c\033\uff9c\042\uff9c\043\uff9c\001\002\000&quot;
 361         + &quot;\060\002\uff78\004\uff78\006\uff78\007\uff78\010\uff78\011\uff78&quot;
 362         + &quot;\012\uff78\013\uff78\014\uff78\020\uffa3\021\uff78\022\uff78\023&quot;
 363         + &quot;\uff78\024\uff78\025\uff78\026\uff78\027\uff78\030\uff78\031\uff78&quot;
 364         + &quot;\032\uff78\033\uff78\042\uff78\043\uff78\001\002\000\052\002&quot;
 365         + &quot;\uffc1\004\173\007\uffc1\010\uffc1\012\uffc1\013\uffc1\014\uffc1&quot;
 366         + &quot;\021\172\022\uffc1\023\uffc1\024\uffc1\025\uffc1\026\uffc1\027&quot;
 367         + &quot;\uffc1\030\uffc1\031\uffc1\032\uffc1\033\uffc1\042\uffc1\043\uffc1&quot;
 368         + &quot;\001\002\000\060\002\uff82\004\uff82\006\uff82\007\uff82\010&quot;
 369         + &quot;\uff82\011\uff82\012\uff82\013\uff82\014\uff82\020\uffad\021\uff82&quot;
 370         + &quot;\022\uff82\023\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030&quot;
 371         + &quot;\uff82\031\uff82\032\uff82\033\uff82\042\uff82\043\uff82\001\002&quot;
 372         + &quot;\000\054\002\uff98\004\uff98\006\uff98\007\uff98\010\uff98\012&quot;
 373         + &quot;\uff98\013\uff98\014\uff98\021\uff98\022\uff98\023\uff98\024\uff98&quot;
 374         + &quot;\025\uff98\026\uff98\027\uff98\030\uff98\031\uff98\032\uff98\033&quot;
 375         + &quot;\uff98\042\uff98\043\uff98\001\002\000\004\007\171\001\002&quot;
 376         + &quot;\000\046\032\031\033\040\035\034\036\113\037\141\047&quot;
 377         + &quot;\036\050\037\051\044\052\170\053\166\054\043\055\041&quot;
 378         + &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot;
 379         + &quot;\002\000\052\002\uffba\004\uffba\007\uffba\010\uffba\012\uffba&quot;
 380         + &quot;\013\uffba\014\uffba\021\uffba\022\uffba\023\uffba\024\uffba\025&quot;
 381         + &quot;\uffba\026\uffba\027\uffba\030\uffba\031\uffba\032\uffba\033\uffba&quot;
 382         + &quot;\042\uffba\043\uffba\001\002\000\060\002\uff79\004\uff79\006&quot;
 383         + &quot;\uff79\007\uff79\010\uff79\011\uff79\012\uff79\013\uff79\014\uff79&quot;
 384         + &quot;\020\uffa4\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026&quot;
 385         + &quot;\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79&quot;
 386         + &quot;\043\uff79\001\002\000\052\002\uffb0\004\uffb0\007\uffb0\010&quot;
 387         + &quot;\uffb0\012\uffb0\013\uffb0\014\uffb0\021\uffb0\022\uffb0\023\uffb0&quot;
 388         + &quot;\024\uffb0\025\uffb0\026\uffb0\027\uffb0\030\uffb0\031\uffb0\032&quot;
 389         + &quot;\uffb0\033\uffb0\042\uffb0\043\uffb0\001\002\000\060\002\uff7c&quot;
 390         + &quot;\004\uff7c\006\uff7c\007\uff7c\010\uff7c\011\uff7c\012\uff7c\013&quot;
 391         + &quot;\uff7c\014\uff7c\020\uffa7\021\uff7c\022\uff7c\023\uff7c\024\uff7c&quot;
 392         + &quot;\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031\uff7c\032\uff7c\033&quot;
 393         + &quot;\uff7c\042\uff7c\043\uff7c\001\002\000\056\002\uff83\004\uff83&quot;
 394         + &quot;\006\uff83\007\uff83\010\uff83\011\uff83\012\uff83\013\uff83\014&quot;
 395         + &quot;\uff83\021\uff83\022\uff83\023\uff83\024\uff83\025\uff83\026\uff83&quot;
 396         + &quot;\027\uff83\030\uff83\031\uff83\032\uff83\033\uff83\042\uff83\043&quot;
 397         + &quot;\uff83\001\002\000\054\002\uff8c\004\uff8c\006\uff8c\007\uff8c&quot;
 398         + &quot;\010\uff8c\012\uff8c\013\uff8c\014\uff8c\021\uff8c\022\uff8c\023&quot;
 399         + &quot;\uff8c\024\uff8c\025\uff8c\026\uff8c\027\uff8c\030\uff8c\031\uff8c&quot;
 400         + &quot;\032\uff8c\033\uff8c\042\uff8c\043\uff8c\001\002\000\060\002&quot;
 401         + &quot;\uff80\004\uff80\006\uff80\007\uff80\010\uff80\011\uff80\012\uff80&quot;
 402         + &quot;\013\uff80\014\uff80\020\uffab\021\uff80\022\uff80\023\uff80\024&quot;
 403         + &quot;\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80\032\uff80&quot;
 404         + &quot;\033\uff80\042\uff80\043\uff80\001\002\000\044\002\uffc6\007&quot;
 405         + &quot;\uffc6\012\uffc6\013\uffc6\014\uffc6\022\uffc6\023\uffc6\024\uffc6&quot;
 406         + &quot;\025\uffc6\026\uffc6\027\uffc6\030\uffc6\031\uffc6\032\uffc6\033&quot;
 407         + &quot;\uffc6\042\uffc6\043\uffc6\001\002\000\054\002\uff8d\004\uff8d&quot;
 408         + &quot;\006\uff8d\007\uff8d\010\uff8d\012\uff8d\013\uff8d\014\uff8d\021&quot;
 409         + &quot;\uff8d\022\uff8d\023\uff8d\024\uff8d\025\uff8d\026\uff8d\027\uff8d&quot;
 410         + &quot;\030\uff8d\031\uff8d\032\uff8d\033\uff8d\042\uff8d\043\uff8d\001&quot;
 411         + &quot;\002\000\044\002\uffcd\007\uffcd\012\uffcd\013\160\014\uffcd&quot;
 412         + &quot;\022\uffcd\023\uffcd\024\uffcd\025\uffcd\026\uffcd\027\uffcd\030&quot;
 413         + &quot;\uffcd\031\uffcd\032\161\033\157\042\uffcd\043\uffcd\001\002&quot;
 414         + &quot;\000\052\002\uffbe\004\153\007\uffbe\010\uffbe\012\uffbe\013&quot;
 415         + &quot;\uffbe\014\uffbe\021\152\022\uffbe\023\uffbe\024\uffbe\025\uffbe&quot;
 416         + &quot;\026\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\042&quot;
 417         + &quot;\uffbe\043\uffbe\001\002\000\054\002\uff8e\004\uff8e\006\uff8e&quot;
 418         + &quot;\007\uff8e\010\uff8e\012\uff8e\013\uff8e\014\uff8e\021\uff8e\022&quot;
 419         + &quot;\uff8e\023\uff8e\024\uff8e\025\uff8e\026\uff8e\027\uff8e\030\uff8e&quot;
 420         + &quot;\031\uff8e\032\uff8e\033\uff8e\042\uff8e\043\uff8e\001\002\000&quot;
 421         + &quot;\056\002\uff87\004\uff87\006\uff87\007\uff87\010\uff87\011\uff91&quot;
 422         + &quot;\012\uff87\013\uff87\014\uff87\021\uff87\022\uff87\023\uff87\024&quot;
 423         + &quot;\uff87\025\uff87\026\uff87\027\uff87\030\uff87\031\uff87\032\uff87&quot;
 424         + &quot;\033\uff87\042\uff87\043\uff87\001\002\000\070\005\111\013&quot;
 425         + &quot;\103\016\066\017\106\032\031\033\040\035\034\036\113&quot;
 426         + &quot;\037\141\040\142\041\145\044\063\045\062\046\065\047&quot;
 427         + &quot;\115\050\123\051\136\052\077\053\143\054\131\055\125&quot;
 428         + &quot;\056\116\057\104\060\140\061\067\062\060\063\127\001&quot;
 429         + &quot;\002\000\070\005\111\013\103\016\066\017\106\032\031&quot;
 430         + &quot;\033\040\035\034\036\113\037\141\040\142\041\145\044&quot;
 431         + &quot;\063\045\062\046\065\047\115\050\123\051\136\052\077&quot;
 432         + &quot;\053\143\054\131\055\125\056\116\057\104\060\140\061&quot;
 433         + &quot;\067\062\060\063\127\001\002\000\054\002\uff87\004\uff87&quot;
 434         + &quot;\006\uff87\007\uff87\010\uff87\012\uff87\013\uff87\014\uff87\021&quot;
 435         + &quot;\uff87\022\uff87\023\uff87\024\uff87\025\uff87\026\uff87\027\uff87&quot;
 436         + &quot;\030\uff87\031\uff87\032\uff87\033\uff87\042\uff87\043\uff87\001&quot;
 437         + &quot;\002\000\052\002\uffbb\004\uffbb\007\uffbb\010\uffbb\012\uffbb&quot;
 438         + &quot;\013\uffbb\014\uffbb\021\uffbb\022\uffbb\023\uffbb\024\uffbb\025&quot;
 439         + &quot;\uffbb\026\uffbb\027\uffbb\030\uffbb\031\uffbb\032\uffbb\033\uffbb&quot;
 440         + &quot;\042\uffbb\043\uffbb\001\002\000\052\002\uffb6\004\uffb6\007&quot;
 441         + &quot;\uffb6\010\uffb6\012\uffb6\013\uffb6\014\uffb6\021\uffb6\022\uffb6&quot;
 442         + &quot;\023\uffb6\024\uffb6\025\uffb6\026\uffb6\027\uffb6\030\uffb6\031&quot;
 443         + &quot;\uffb6\032\uffb6\033\uffb6\042\uffb6\043\uffb6\001\002\000\110&quot;
 444         + &quot;\004\061\005\111\011\071\013\103\015\134\016\066\017&quot;
 445         + &quot;\106\021\070\031\075\032\031\033\040\034\057\035\034&quot;
 446         + &quot;\036\113\037\141\040\142\041\145\044\063\045\062\046&quot;
 447         + &quot;\065\047\115\050\123\051\136\052\077\053\143\054\131&quot;
 448         + &quot;\055\125\056\116\057\104\060\140\061\067\062\060\063&quot;
 449         + &quot;\127\064\132\065\072\001\002\000\110\004\061\005\111&quot;
 450         + &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot;
 451         + &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot;
 452         + &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot;
 453         + &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot;
 454         + &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot;
 455         + &quot;\072\001\002\000\110\004\061\005\111\011\071\013\103&quot;
 456         + &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot;
 457         + &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot;
 458         + &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot;
 459         + &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot;
 460         + &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot;
 461         + &quot;\044\002\uffc8\007\uffc8\012\uffc8\013\uffc8\014\uffc8\022\uffc8&quot;
 462         + &quot;\023\uffc8\024\uffc8\025\uffc8\026\uffc8\027\uffc8\030\uffc8\031&quot;
 463         + &quot;\uffc8\032\uffc8\033\uffc8\042\uffc8\043\uffc8\001\002\000\044&quot;
 464         + &quot;\002\uffc9\007\uffc9\012\uffc9\013\uffc9\014\uffc9\022\uffc9\023&quot;
 465         + &quot;\uffc9\024\uffc9\025\uffc9\026\uffc9\027\uffc9\030\uffc9\031\uffc9&quot;
 466         + &quot;\032\uffc9\033\uffc9\042\uffc9\043\uffc9\001\002\000\044\002&quot;
 467         + &quot;\uffc7\007\uffc7\012\uffc7\013\uffc7\014\uffc7\022\uffc7\023\uffc7&quot;
 468         + &quot;\024\uffc7\025\uffc7\026\uffc7\027\uffc7\030\uffc7\031\uffc7\032&quot;
 469         + &quot;\uffc7\033\uffc7\042\uffc7\043\uffc7\001\002\000\054\002\uff90&quot;
 470         + &quot;\004\uff90\006\uff90\007\uff90\010\uff90\012\uff90\013\uff90\014&quot;
 471         + &quot;\uff90\021\uff90\022\uff90\023\uff90\024\uff90\025\uff90\026\uff90&quot;
 472         + &quot;\027\uff90\030\uff90\031\uff90\032\uff90\033\uff90\042\uff90\043&quot;
 473         + &quot;\uff90\001\002\000\054\002\uff80\004\uff80\006\uff80\007\uff80&quot;
 474         + &quot;\010\uff80\012\uff80\013\uff80\014\uff80\021\uff80\022\uff80\023&quot;
 475         + &quot;\uff80\024\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80&quot;
 476         + &quot;\032\uff80\033\uff80\042\uff80\043\uff80\001\002\000\054\002&quot;
 477         + &quot;\uff96\004\uff96\006\uff96\007\uff96\010\uff96\012\uff96\013\uff96&quot;
 478         + &quot;\014\uff96\021\uff96\022\uff96\023\uff96\024\uff96\025\uff96\026&quot;
 479         + &quot;\uff96\027\uff96\030\uff96\031\uff96\032\uff96\033\uff96\042\uff96&quot;
 480         + &quot;\043\uff96\001\002\000\054\002\uff7f\004\uff7f\006\uff7f\007&quot;
 481         + &quot;\uff7f\010\uff7f\012\uff7f\013\uff7f\014\uff7f\021\uff7f\022\uff7f&quot;
 482         + &quot;\023\uff7f\024\uff7f\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031&quot;
 483         + &quot;\uff7f\032\uff7f\033\uff7f\042\uff7f\043\uff7f\001\002\000\054&quot;
 484         + &quot;\002\uffdb\004\uffdb\006\uffdb\007\uffdb\010\uffdb\012\uffdb\013&quot;
 485         + &quot;\uffdb\014\uffdb\021\uffdb\022\uffdb\023\uffdb\024\uffdb\025\uffdb&quot;
 486         + &quot;\026\uffdb\027\uffdb\030\uffdb\031\uffdb\032\uffdb\033\uffdb\042&quot;
 487         + &quot;\uffdb\043\uffdb\001\002\000\070\005\111\013\103\016\066&quot;
 488         + &quot;\017\106\032\031\033\040\035\034\036\113\037\141\040&quot;
 489         + &quot;\142\041\145\044\063\045\062\046\065\047\115\050\123&quot;
 490         + &quot;\051\136\052\077\053\143\054\131\055\125\056\116\057&quot;
 491         + &quot;\104\060\140\061\067\062\060\063\127\001\002\000\070&quot;
 492         + &quot;\005\111\013\103\016\066\017\106\032\031\033\040\035&quot;
 493         + &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot;
 494         + &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot;
 495         + &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot;
 496         + &quot;\063\127\001\002\000\052\002\uffc0\004\153\007\uffc0\010&quot;
 497         + &quot;\uffc0\012\uffc0\013\uffc0\014\uffc0\021\152\022\uffc0\023\uffc0&quot;
 498         + &quot;\024\uffc0\025\uffc0\026\uffc0\027\uffc0\030\uffc0\031\uffc0\032&quot;
 499         + &quot;\uffc0\033\uffc0\042\uffc0\043\uffc0\001\002\000\052\002\uffbf&quot;
 500         + &quot;\004\153\007\uffbf\010\uffbf\012\uffbf\013\uffbf\014\uffbf\021&quot;
 501         + &quot;\152\022\uffbf\023\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf&quot;
 502         + &quot;\030\uffbf\031\uffbf\032\uffbf\033\uffbf\042\uffbf\043\uffbf\001&quot;
 503         + &quot;\002\000\106\004\061\005\111\011\071\013\103\015\134&quot;
 504         + &quot;\016\066\017\106\021\070\032\031\033\040\034\057\035&quot;
 505         + &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot;
 506         + &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot;
 507         + &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot;
 508         + &quot;\063\127\064\132\065\072\001\002\000\044\002\uffc3\007&quot;
 509         + &quot;\uffc3\012\uffc3\013\uffc3\014\uffc3\022\uffc3\023\uffc3\024\uffc3&quot;
 510         + &quot;\025\uffc3\026\uffc3\027\uffc3\030\uffc3\031\uffc3\032\uffc3\033&quot;
 511         + &quot;\uffc3\042\uffc3\043\uffc3\001\002\000\052\002\uff9d\004\uff9d&quot;
 512         + &quot;\007\uff9d\010\uff9d\012\uff9d\013\uff9d\014\uff9d\021\uff9d\022&quot;
 513         + &quot;\uff9d\023\uff9d\024\uff9d\025\uff9d\026\uff9d\027\uff9d\030\uff9d&quot;
 514         + &quot;\031\uff9d\032\uff9d\033\uff9d\042\uff9d\043\uff9d\001\002\000&quot;
 515         + &quot;\112\004\061\005\111\011\071\012\202\013\103\015\134&quot;
 516         + &quot;\016\066\017\106\021\070\031\075\032\031\033\040\034&quot;
 517         + &quot;\057\035\034\036\113\037\141\040\142\041\145\044\063&quot;
 518         + &quot;\045\062\046\065\047\115\050\123\051\136\052\077\053&quot;
 519         + &quot;\143\054\131\055\125\056\116\057\104\060\140\061\067&quot;
 520         + &quot;\062\060\063\127\064\132\065\072\001\002\000\054\002&quot;
 521         + &quot;\uff95\004\uff95\006\uff95\007\uff95\010\uff95\012\uff95\013\uff95&quot;
 522         + &quot;\014\uff95\021\uff95\022\uff95\023\uff95\024\uff95\025\uff95\026&quot;
 523         + &quot;\uff95\027\uff95\030\uff95\031\uff95\032\uff95\033\uff95\042\uff95&quot;
 524         + &quot;\043\uff95\001\002\000\006\012\uff93\014\207\001\002\000&quot;
 525         + &quot;\006\012\uff8f\014\uff8f\001\002\000\004\012\206\001\002&quot;
 526         + &quot;\000\054\002\uff94\004\uff94\006\uff94\007\uff94\010\uff94\012&quot;
 527         + &quot;\uff94\013\uff94\014\uff94\021\uff94\022\uff94\023\uff94\024\uff94&quot;
 528         + &quot;\025\uff94\026\uff94\027\uff94\030\uff94\031\uff94\032\uff94\033&quot;
 529         + &quot;\uff94\042\uff94\043\uff94\001\002\000\110\004\061\005\111&quot;
 530         + &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot;
 531         + &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot;
 532         + &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot;
 533         + &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot;
 534         + &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot;
 535         + &quot;\072\001\002\000\004\012\uff92\001\002\000\110\004\061&quot;
 536         + &quot;\005\111\011\071\013\103\015\134\016\066\017\106\021&quot;
 537         + &quot;\070\031\075\032\031\033\040\034\057\035\034\036\113&quot;
 538         + &quot;\037\141\040\142\041\145\044\063\045\062\046\065\047&quot;
 539         + &quot;\115\050\123\051\136\052\077\053\143\054\131\055\125&quot;
 540         + &quot;\056\116\057\104\060\140\061\067\062\060\063\127\064&quot;
 541         + &quot;\132\065\072\001\002\000\110\004\061\005\111\011\071&quot;
 542         + &quot;\013\103\015\134\016\066\017\106\021\070\031\075\032&quot;
 543         + &quot;\031\033\040\034\057\035\034\036\113\037\141\040\142&quot;
 544         + &quot;\041\145\044\063\045\062\046\065\047\115\050\123\051&quot;
 545         + &quot;\136\052\077\053\143\054\131\055\125\056\116\057\104&quot;
 546         + &quot;\060\140\061\067\062\060\063\127\064\132\065\072\001&quot;
 547         + &quot;\002\000\044\002\uffcb\007\uffcb\012\uffcb\013\160\014\uffcb&quot;
 548         + &quot;\022\uffcb\023\uffcb\024\uffcb\025\uffcb\026\uffcb\027\uffcb\030&quot;
 549         + &quot;\uffcb\031\uffcb\032\161\033\157\042\uffcb\043\uffcb\001\002&quot;
 550         + &quot;\000\044\002\uffcc\007\uffcc\012\uffcc\013\160\014\uffcc\022&quot;
 551         + &quot;\uffcc\023\uffcc\024\uffcc\025\uffcc\026\uffcc\027\uffcc\030\uffcc&quot;
 552         + &quot;\031\uffcc\032\161\033\157\042\uffcc\043\uffcc\001\002\000&quot;
 553         + &quot;\052\002\uffb3\004\uffb3\007\uffb3\010\uffb3\012\uffb3\013\uffb3&quot;
 554         + &quot;\014\uffb3\021\uffb3\022\uffb3\023\uffb3\024\uffb3\025\uffb3\026&quot;
 555         + &quot;\uffb3\027\uffb3\030\uffb3\031\uffb3\032\uffb3\033\uffb3\042\uffb3&quot;
 556         + &quot;\043\uffb3\001\002\000\110\004\061\005\111\011\071\013&quot;
 557         + &quot;\103\015\134\016\066\017\106\021\070\031\075\032\031&quot;
 558         + &quot;\033\040\034\057\035\034\036\113\037\141\040\142\041&quot;
 559         + &quot;\145\044\063\045\062\046\065\047\115\050\123\051\136&quot;
 560         + &quot;\052\077\053\143\054\131\055\125\056\116\057\104\060&quot;
 561         + &quot;\140\061\067\062\060\063\127\064\132\065\072\001\002&quot;
 562         + &quot;\000\110\004\061\005\111\011\071\013\103\015\134\016&quot;
 563         + &quot;\066\017\106\021\070\031\075\032\031\033\040\034\057&quot;
 564         + &quot;\035\034\036\113\037\141\040\142\041\145\044\063\045&quot;
 565         + &quot;\062\046\065\047\115\050\123\051\136\052\077\053\143&quot;
 566         + &quot;\054\131\055\125\056\116\057\104\060\140\061\067\062&quot;
 567         + &quot;\060\063\127\064\132\065\072\001\002\000\032\002\uffd3&quot;
 568         + &quot;\007\uffd3\012\uffd3\014\uffd3\022\uffd3\023\uffd3\024\221\025&quot;
 569         + &quot;\222\026\223\027\224\042\uffd3\043\uffd3\001\002\000\110&quot;
 570         + &quot;\004\061\005\111\011\071\013\103\015\134\016\066\017&quot;
 571         + &quot;\106\021\070\031\075\032\031\033\040\034\057\035\034&quot;
 572         + &quot;\036\113\037\141\040\142\041\145\044\063\045\062\046&quot;
 573         + &quot;\065\047\115\050\123\051\136\052\077\053\143\054\131&quot;
 574         + &quot;\055\125\056\116\057\104\060\140\061\067\062\060\063&quot;
 575         + &quot;\127\064\132\065\072\001\002\000\110\004\061\005\111&quot;
 576         + &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot;
 577         + &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot;
 578         + &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot;
 579         + &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot;
 580         + &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot;
 581         + &quot;\072\001\002\000\110\004\061\005\111\011\071\013\103&quot;
 582         + &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot;
 583         + &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot;
 584         + &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot;
 585         + &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot;
 586         + &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot;
 587         + &quot;\110\004\061\005\111\011\071\013\103\015\134\016\066&quot;
 588         + &quot;\017\106\021\070\031\075\032\031\033\040\034\057\035&quot;
 589         + &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot;
 590         + &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot;
 591         + &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot;
 592         + &quot;\063\127\064\132\065\072\001\002\000\036\002\uffce\007&quot;
 593         + &quot;\uffce\012\uffce\014\uffce\022\uffce\023\uffce\024\uffce\025\uffce&quot;
 594         + &quot;\026\uffce\027\uffce\030\211\031\212\042\uffce\043\uffce\001&quot;
 595         + &quot;\002\000\036\002\uffcf\007\uffcf\012\uffcf\014\uffcf\022\uffcf&quot;
 596         + &quot;\023\uffcf\024\uffcf\025\uffcf\026\uffcf\027\uffcf\030\211\031&quot;
 597         + &quot;\212\042\uffcf\043\uffcf\001\002\000\036\002\uffd0\007\uffd0&quot;
 598         + &quot;\012\uffd0\014\uffd0\022\uffd0\023\uffd0\024\uffd0\025\uffd0\026&quot;
 599         + &quot;\uffd0\027\uffd0\030\211\031\212\042\uffd0\043\uffd0\001\002&quot;
 600         + &quot;\000\036\002\uffd1\007\uffd1\012\uffd1\014\uffd1\022\uffd1\023&quot;
 601         + &quot;\uffd1\024\uffd1\025\uffd1\026\uffd1\027\uffd1\030\211\031\212&quot;
 602         + &quot;\042\uffd1\043\uffd1\001\002\000\032\002\uffd4\007\uffd4\012&quot;
 603         + &quot;\uffd4\014\uffd4\022\uffd4\023\uffd4\024\221\025\222\026\223&quot;
 604         + &quot;\027\224\042\uffd4\043\uffd4\001\002\000\110\004\061\005&quot;
 605         + &quot;\111\011\071\013\103\015\134\016\066\017\106\021\070&quot;
 606         + &quot;\031\075\032\031\033\040\034\057\035\034\036\113\037&quot;
 607         + &quot;\141\040\142\041\145\044\063\045\062\046\065\047\115&quot;
 608         + &quot;\050\123\051\136\052\077\053\143\054\131\055\125\056&quot;
 609         + &quot;\116\057\104\060\140\061\067\062\060\063\127\064\132&quot;
 610         + &quot;\065\072\001\002\000\016\002\uffd8\007\uffd8\012\uffd8\014&quot;
 611         + &quot;\uffd8\042\uffd8\043\234\001\002\000\110\004\061\005\111&quot;
 612         + &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot;
 613         + &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot;
 614         + &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot;
 615         + &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot;
 616         + &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot;
 617         + &quot;\072\001\002\000\022\002\uffd6\007\uffd6\012\uffd6\014\uffd6&quot;
 618         + &quot;\022\216\023\217\042\uffd6\043\uffd6\001\002\000\062\013&quot;
 619         + &quot;\uffaf\032\uffaf\033\uffaf\035\uffaf\036\uffaf\037\uffaf\040\uffaf&quot;
 620         + &quot;\041\uffaf\044\uffaf\045\uffaf\046\uffaf\047\uffaf\050\uffaf\051&quot;
 621         + &quot;\uffaf\052\uffaf\053\uffaf\054\uffaf\055\uffaf\056\uffaf\057\uffaf&quot;
 622         + &quot;\060\uffaf\061\uffaf\062\uffaf\063\uffaf\001\002\000\054\002&quot;
 623         + &quot;\uffb1\004\uffb1\006\055\007\uffb1\010\uffb1\012\uffb1\013\uffb1&quot;
 624         + &quot;\014\uffb1\021\uffb1\022\uffb1\023\uffb1\024\uffb1\025\uffb1\026&quot;
 625         + &quot;\uffb1\027\uffb1\030\uffb1\031\uffb1\032\uffb1\033\uffb1\042\uffb1&quot;
 626         + &quot;\043\uffb1\001\002\000\052\002\uffb2\004\uffb2\007\uffb2\010&quot;
 627         + &quot;\uffb2\012\uffb2\013\uffb2\014\uffb2\021\uffb2\022\uffb2\023\uffb2&quot;
 628         + &quot;\024\uffb2\025\uffb2\026\uffb2\027\uffb2\030\uffb2\031\uffb2\032&quot;
 629         + &quot;\uffb2\033\uffb2\042\uffb2\043\uffb2\001\002\000\044\002\uffc5&quot;
 630         + &quot;\007\uffc5\012\uffc5\013\uffc5\014\uffc5\022\uffc5\023\uffc5\024&quot;
 631         + &quot;\uffc5\025\uffc5\026\uffc5\027\uffc5\030\uffc5\031\uffc5\032\uffc5&quot;
 632         + &quot;\033\uffc5\042\uffc5\043\uffc5\001\002\000\004\012\243\001&quot;
 633         + &quot;\002\000\054\002\uff9b\004\uff9b\006\uff9b\007\uff9b\010\uff9b&quot;
 634         + &quot;\012\uff9b\013\uff9b\014\uff9b\021\uff9b\022\uff9b\023\uff9b\024&quot;
 635         + &quot;\uff9b\025\uff9b\026\uff9b\027\uff9b\030\uff9b\031\uff9b\032\uff9b&quot;
 636         + &quot;\033\uff9b\042\uff9b\043\uff9b\001\002\000\052\002\uffb5\004&quot;
 637         + &quot;\153\007\uffb5\010\uffb5\012\uffb5\013\uffb5\014\uffb5\021\152&quot;
 638         + &quot;\022\uffb5\023\uffb5\024\uffb5\025\uffb5\026\uffb5\027\uffb5\030&quot;
 639         + &quot;\uffb5\031\uffb5\032\uffb5\033\uffb5\042\uffb5\043\uffb5\001\002&quot;
 640         + &quot;\000\004\034\246\001\002\000\004\012\247\001\002\000&quot;
 641         + &quot;\054\002\uff8a\004\uff8a\006\uff8a\007\uff8a\010\uff8a\012\uff8a&quot;
 642         + &quot;\013\uff8a\014\uff8a\021\uff8a\022\uff8a\023\uff8a\024\uff8a\025&quot;
 643         + &quot;\uff8a\026\uff8a\027\uff8a\030\uff8a\031\uff8a\032\uff8a\033\uff8a&quot;
 644         + &quot;\042\uff8a\043\uff8a\001\002\000\052\002\uffb8\004\153\007&quot;
 645         + &quot;\uffb8\010\uffb8\012\uffb8\013\uffb8\014\uffb8\021\152\022\uffb8&quot;
 646         + &quot;\023\uffb8\024\uffb8\025\uffb8\026\uffb8\027\uffb8\030\uffb8\031&quot;
 647         + &quot;\uffb8\032\uffb8\033\uffb8\042\uffb8\043\uffb8\001\002\000\052&quot;
 648         + &quot;\002\uffdc\004\uffdc\007\uffdc\010\uffdc\012\uffdc\013\uffdc\014&quot;
 649         + &quot;\uffdc\021\uffdc\022\uffdc\023\uffdc\024\uffdc\025\uffdc\026\uffdc&quot;
 650         + &quot;\027\uffdc\030\uffdc\031\uffdc\032\uffdc\033\uffdc\042\uffdc\043&quot;
 651         + &quot;\uffdc\001\002\000\062\013\uffde\032\uffde\033\uffde\035\uffde&quot;
 652         + &quot;\036\uffde\037\uffde\040\uffde\041\uffde\044\uffde\045\uffde\046&quot;
 653         + &quot;\uffde\047\uffde\050\uffde\051\uffde\052\uffde\053\uffde\054\uffde&quot;
 654         + &quot;\055\uffde\056\uffde\057\uffde\060\uffde\061\uffde\062\uffde\063&quot;
 655         + &quot;\uffde\001\002\000\004\034\254\001\002\000\004\014\255&quot;
 656         + &quot;\001\002\000\004\034\256\001\002\000\004\012\257\001&quot;
 657         + &quot;\002\000\012\002\ufff4\004\ufff4\010\ufff4\021\ufff4\001\002&quot;
 658         + &quot;\000\004\034\261\001\002\000\004\012\262\001\002\000&quot;
 659         + &quot;\012\002\ufff5\004\ufff5\010\ufff5\021\ufff5\001\002\000\012&quot;
 660         + &quot;\002\uffec\004\uffec\010\uffec\021\uffec\001\002\000\062\013&quot;
 661         + &quot;\uffdf\032\uffdf\033\uffdf\035\uffdf\036\uffdf\037\uffdf\040\uffdf&quot;
 662         + &quot;\041\uffdf\044\uffdf\045\uffdf\046\uffdf\047\uffdf\050\uffdf\051&quot;
 663         + &quot;\uffdf\052\uffdf\053\uffdf\054\uffdf\055\uffdf\056\uffdf\057\uffdf&quot;
 664         + &quot;\060\uffdf\061\uffdf\062\uffdf\063\uffdf\001\002\000\064\013&quot;
 665         + &quot;\027\016\020\032\031\033\040\035\034\036\113\037\141&quot;
 666         + &quot;\040\047\041\051\044\015\045\014\046\016\047\036\050&quot;
 667         + &quot;\037\051\044\052\025\053\050\054\043\055\041\056\035&quot;
 668         + &quot;\057\030\060\045\061\021\062\012\063\042\001\002\000&quot;
 669         + &quot;\064\013\027\016\020\032\031\033\040\035\034\036\113&quot;
 670         + &quot;\037\141\040\047\041\051\044\015\045\014\046\016\047&quot;
 671         + &quot;\036\050\037\051\044\052\025\053\050\054\043\055\041&quot;
 672         + &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot;
 673         + &quot;\002\000\006\002\ufff1\010\ufff1\001\002\000\006\002\ufff0&quot;
 674         + &quot;\010\ufff0\001\002\000\006\002\ufff7\010\ufff7\001\002\000&quot;
 675         + &quot;\014\002\uffe9\004\uffe9\006\055\010\uffe9\021\uffe9\001\002&quot;
 676         + &quot;\000\014\002\uffeb\004\uffeb\006\055\010\uffeb\021\uffeb\001&quot;
 677         + &quot;\002\000\012\002\uffea\004\uffea\010\uffea\021\uffea\001\002&quot;
 678         + &quot;\000\012\002\uffe8\004\uffe8\010\uffe8\021\uffe8\001\002\000&quot;
 679         + &quot;\064\013\027\016\020\032\031\033\040\035\034\036\113&quot;
 680         + &quot;\037\141\040\047\041\051\044\015\045\014\046\016\047&quot;
 681         + &quot;\036\050\037\051\044\052\025\053\050\054\043\055\041&quot;
 682         + &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot;
 683         + &quot;\002\000\064\013\027\016\020\032\031\033\040\035\034&quot;
 684         + &quot;\036\113\037\141\040\047\041\051\044\015\045\014\046&quot;
 685         + &quot;\016\047\036\050\037\051\044\052\025\053\050\054\043&quot;
 686         + &quot;\055\041\056\035\057\030\060\045\061\021\062\012\063&quot;
 687         + &quot;\042\001\002\000\006\002\ufff9\010\ufff9\001\002\000\006&quot;
 688         + &quot;\002\ufff8\010\ufff8\001\002\000\004\034\303\001\002\000&quot;
 689         + &quot;\004\012\304\001\002\000\014\002\ufff3\004\ufff3\006\ufff3&quot;
 690         + &quot;\010\ufff3\021\ufff3\001\002\000\006\002\ufffb\010\ufffb\001&quot;
 691         + &quot;\002\000\070\004\013\013\027\016\020\021\023\032\031&quot;
 692         + &quot;\033\040\035\034\036\033\037\046\040\047\041\051\044&quot;
 693         + &quot;\015\045\014\046\016\047\036\050\037\051\044\052\025&quot;
 694         + &quot;\053\050\054\043\055\041\056\035\057\030\060\045\061&quot;
 695         + &quot;\021\062\012\063\042\001\002\000\004\002\ufffd\001\002&quot;
 696         + &quot;\000\004\002\uffff\001\002\000\004\002\001\001\002&quot;});
 697 
 698     /**
 699      * Access to parse-action table.
 700      */
 701     public short[][] action_table() {
 702         return _action_table;
 703     }
 704 
 705     /**
 706      * &lt;code&gt;reduce_goto&lt;/code&gt; table.
 707      */
 708     protected static final short[][] _reduce_table
 709             = unpackFromStrings(new String[]{
 710         &quot;\000\307\000\004\003\003\001\001\000\002\001\001\000&quot;
 711         + &quot;\070\004\307\006\120\010\127\011\117\012\101\013\075&quot;
 712         + &quot;\014\104\015\063\016\111\017\145\020\113\021\125\022&quot;
 713         + &quot;\073\023\121\024\143\025\123\026\136\027\146\030\134&quot;
 714         + &quot;\031\107\032\072\033\106\034\147\047\150\050\116\052&quot;
 715         + &quot;\100\053\077\001\001\000\026\035\016\036\007\037\006&quot;
 716         + &quot;\040\031\041\025\042\023\043\052\044\010\047\051\054&quot;
 717         + &quot;\021\001\001\000\002\001\001\000\002\001\001\000\002&quot;
 718         + &quot;\001\001\000\002\001\001\000\020\040\031\041\304\042&quot;
 719         + &quot;\023\043\052\044\010\047\051\054\021\001\001\000\002&quot;
 720         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 721         + &quot;\001\000\002\001\001\000\002\001\001\000\012\040\271&quot;
 722         + &quot;\043\272\044\010\047\051\001\001\000\020\040\031\041&quot;
 723         + &quot;\270\042\023\043\052\044\010\047\051\054\021\001\001&quot;
 724         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 725         + &quot;\002\001\001\000\002\001\001\000\002\001\001\000\006&quot;
 726         + &quot;\007\053\045\262\001\001\000\002\001\001\000\002\001&quot;
 727         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 728         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 729         + &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot;
 730         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 731         + &quot;\001\000\002\001\001\000\006\007\053\045\055\001\001&quot;
 732         + &quot;\000\006\007\053\045\250\001\001\000\070\004\132\006&quot;
 733         + &quot;\120\010\127\011\117\012\101\013\075\014\104\015\063&quot;
 734         + &quot;\016\111\017\145\020\113\021\125\022\073\023\121\024&quot;
 735         + &quot;\143\025\123\026\136\027\146\030\134\031\107\032\072&quot;
 736         + &quot;\033\106\034\147\047\150\050\116\052\100\053\077\001&quot;
 737         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 738         + &quot;\000\024\011\117\026\136\027\247\030\134\033\106\034&quot;
 739         + &quot;\147\047\153\052\100\053\077\001\001\000\002\001\001&quot;
 740         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 741         + &quot;\002\001\001\000\002\001\001\000\024\011\117\026\136&quot;
 742         + &quot;\027\243\030\134\033\106\034\147\047\153\052\100\053&quot;
 743         + &quot;\077\001\001\000\070\004\241\006\120\010\127\011\117&quot;
 744         + &quot;\012\101\013\075\014\104\015\063\016\111\017\145\020&quot;
 745         + &quot;\113\021\125\022\073\023\121\024\143\025\123\026\136&quot;
 746         + &quot;\027\146\030\134\031\107\032\072\033\106\034\147\047&quot;
 747         + &quot;\150\050\116\052\100\053\077\001\001\000\002\001\001&quot;
 748         + &quot;\000\002\001\001\000\002\001\001\000\052\006\120\010&quot;
 749         + &quot;\127\011\117\020\240\021\125\022\073\023\121\024\143&quot;
 750         + &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot;
 751         + &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot;
 752         + &quot;\000\002\001\001\000\002\001\001\000\010\033\236\034&quot;
 753         + &quot;\147\047\153\001\001\000\002\001\001\000\002\001\001&quot;
 754         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 755         + &quot;\002\001\001\000\006\007\053\045\214\001\001\000\002&quot;
 756         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 757         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 758         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 759         + &quot;\006\007\053\045\177\001\001\000\002\001\001\000\002&quot;
 760         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 761         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 762         + &quot;\000\002\001\001\000\006\047\164\051\166\001\001\000&quot;
 763         + &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot;
 764         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 765         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 766         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 767         + &quot;\020\011\155\026\136\033\106\034\147\047\153\052\100&quot;
 768         + &quot;\053\077\001\001\000\020\011\154\026\136\033\106\034&quot;
 769         + &quot;\147\047\153\052\100\053\077\001\001\000\002\001\001&quot;
 770         + &quot;\000\002\001\001\000\002\001\001\000\052\006\120\010&quot;
 771         + &quot;\127\011\117\020\163\021\125\022\073\023\121\024\143&quot;
 772         + &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot;
 773         + &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot;
 774         + &quot;\000\052\006\120\010\127\011\117\020\162\021\125\022&quot;
 775         + &quot;\073\023\121\024\143\025\123\026\136\027\146\030\134&quot;
 776         + &quot;\031\107\032\072\033\106\034\147\047\150\050\116\052&quot;
 777         + &quot;\100\053\077\001\001\000\052\006\120\010\127\011\117&quot;
 778         + &quot;\020\161\021\125\022\073\023\121\024\143\025\123\026&quot;
 779         + &quot;\136\027\146\030\134\031\107\032\072\033\106\034\147&quot;
 780         + &quot;\047\150\050\116\052\100\053\077\001\001\000\002\001&quot;
 781         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 782         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 783         + &quot;\002\001\001\000\024\011\117\026\136\027\174\030\134&quot;
 784         + &quot;\033\106\034\147\047\153\052\100\053\077\001\001\000&quot;
 785         + &quot;\024\011\117\026\136\027\173\030\134\033\106\034\147&quot;
 786         + &quot;\047\153\052\100\053\077\001\001\000\002\001\001\000&quot;
 787         + &quot;\002\001\001\000\050\006\120\010\127\011\117\021\125&quot;
 788         + &quot;\022\073\023\121\024\176\025\123\026\136\027\146\030&quot;
 789         + &quot;\134\031\107\032\072\033\106\034\147\047\150\050\116&quot;
 790         + &quot;\052\100\053\077\001\001\000\002\001\001\000\002\001&quot;
 791         + &quot;\001\000\074\004\203\005\202\006\120\010\127\011\117&quot;
 792         + &quot;\012\101\013\075\014\104\015\063\016\111\017\145\020&quot;
 793         + &quot;\113\021\125\022\073\023\121\024\143\025\123\026\136&quot;
 794         + &quot;\027\146\030\134\031\107\032\072\033\106\034\147\046&quot;
 795         + &quot;\204\047\150\050\116\052\100\053\077\001\001\000\002&quot;
 796         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 797         + &quot;\001\000\002\001\001\000\074\004\203\005\202\006\120&quot;
 798         + &quot;\010\127\011\117\012\101\013\075\014\104\015\063\016&quot;
 799         + &quot;\111\017\145\020\113\021\125\022\073\023\121\024\143&quot;
 800         + &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot;
 801         + &quot;\106\034\147\046\207\047\150\050\116\052\100\053\077&quot;
 802         + &quot;\001\001\000\002\001\001\000\054\006\120\010\127\011&quot;
 803         + &quot;\117\017\213\020\113\021\125\022\073\023\121\024\143&quot;
 804         + &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot;
 805         + &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot;
 806         + &quot;\000\054\006\120\010\127\011\117\017\212\020\113\021&quot;
 807         + &quot;\125\022\073\023\121\024\143\025\123\026\136\027\146&quot;
 808         + &quot;\030\134\031\107\032\072\033\106\034\147\047\150\050&quot;
 809         + &quot;\116\052\100\053\077\001\001\000\002\001\001\000\002&quot;
 810         + &quot;\001\001\000\002\001\001\000\060\006\120\010\127\011&quot;
 811         + &quot;\117\015\230\016\111\017\145\020\113\021\125\022\073&quot;
 812         + &quot;\023\121\024\143\025\123\026\136\027\146\030\134\031&quot;
 813         + &quot;\107\032\072\033\106\034\147\047\150\050\116\052\100&quot;
 814         + &quot;\053\077\001\001\000\060\006\120\010\127\011\117\015&quot;
 815         + &quot;\217\016\111\017\145\020\113\021\125\022\073\023\121&quot;
 816         + &quot;\024\143\025\123\026\136\027\146\030\134\031\107\032&quot;
 817         + &quot;\072\033\106\034\147\047\150\050\116\052\100\053\077&quot;
 818         + &quot;\001\001\000\002\001\001\000\056\006\120\010\127\011&quot;
 819         + &quot;\117\016\227\017\145\020\113\021\125\022\073\023\121&quot;
 820         + &quot;\024\143\025\123\026\136\027\146\030\134\031\107\032&quot;
 821         + &quot;\072\033\106\034\147\047\150\050\116\052\100\053\077&quot;
 822         + &quot;\001\001\000\056\006\120\010\127\011\117\016\226\017&quot;
 823         + &quot;\145\020\113\021\125\022\073\023\121\024\143\025\123&quot;
 824         + &quot;\026\136\027\146\030\134\031\107\032\072\033\106\034&quot;
 825         + &quot;\147\047\150\050\116\052\100\053\077\001\001\000\056&quot;
 826         + &quot;\006\120\010\127\011\117\016\225\017\145\020\113\021&quot;
 827         + &quot;\125\022\073\023\121\024\143\025\123\026\136\027\146&quot;
 828         + &quot;\030\134\031\107\032\072\033\106\034\147\047\150\050&quot;
 829         + &quot;\116\052\100\053\077\001\001\000\056\006\120\010\127&quot;
 830         + &quot;\011\117\016\224\017\145\020\113\021\125\022\073\023&quot;
 831         + &quot;\121\024\143\025\123\026\136\027\146\030\134\031\107&quot;
 832         + &quot;\032\072\033\106\034\147\047\150\050\116\052\100\053&quot;
 833         + &quot;\077\001\001\000\002\001\001\000\002\001\001\000\002&quot;
 834         + &quot;\001\001\000\002\001\001\000\002\001\001\000\064\006&quot;
 835         + &quot;\120\010\127\011\117\013\232\014\104\015\063\016\111&quot;
 836         + &quot;\017\145\020\113\021\125\022\073\023\121\024\143\025&quot;
 837         + &quot;\123\026\136\027\146\030\134\031\107\032\072\033\106&quot;
 838         + &quot;\034\147\047\150\050\116\052\100\053\077\001\001\000&quot;
 839         + &quot;\002\001\001\000\062\006\120\010\127\011\117\014\234&quot;
 840         + &quot;\015\063\016\111\017\145\020\113\021\125\022\073\023&quot;
 841         + &quot;\121\024\143\025\123\026\136\027\146\030\134\031\107&quot;
 842         + &quot;\032\072\033\106\034\147\047\150\050\116\052\100\053&quot;
 843         + &quot;\077\001\001\000\002\001\001\000\002\001\001\000\006&quot;
 844         + &quot;\007\053\045\237\001\001\000\002\001\001\000\002\001&quot;
 845         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 846         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 847         + &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot;
 848         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 849         + &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot;
 850         + &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot;
 851         + &quot;\020\040\031\041\267\042\023\043\052\044\010\047\051&quot;
 852         + &quot;\054\021\001\001\000\020\040\031\041\266\042\023\043&quot;
 853         + &quot;\052\044\010\047\051\054\021\001\001\000\002\001\001&quot;
 854         + &quot;\000\002\001\001\000\002\001\001\000\006\007\053\045&quot;
 855         + &quot;\274\001\001\000\006\007\053\045\273\001\001\000\002&quot;
 856         + &quot;\001\001\000\002\001\001\000\020\040\031\041\300\042&quot;
 857         + &quot;\023\043\052\044\010\047\051\054\021\001\001\000\020&quot;
 858         + &quot;\040\031\041\277\042\023\043\052\044\010\047\051\054&quot;
 859         + &quot;\021\001\001\000\002\001\001\000\002\001\001\000\002&quot;
 860         + &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot;
 861         + &quot;\001\000\026\035\016\036\306\037\006\040\031\041\025&quot;
 862         + &quot;\042\023\043\052\044\010\047\051\054\021\001\001\000&quot;
 863         + &quot;\002\001\001\000\002\001\001\000\002\001\001&quot;});
 864 
 865     /**
 866      * Access to &lt;code&gt;reduce_goto&lt;/code&gt; table.
 867      */
 868     public short[][] reduce_table() {
 869         return _reduce_table;
 870     }
 871 
 872     /**
 873      * Instance of action encapsulation class.
 874      */
 875     protected parser_actions action_obj;
 876 
 877     /**
 878      * Action encapsulation object initializer.
 879      */
 880     protected void init_actions() {
 881         action_obj = new parser_actions(this);
 882     }
 883 
 884     /**
 885      * Invoke a user supplied parse action.
 886      */
 887     public Symbol do_action(
 888             int act_num,
 889             lr_parser parser,
 890             Stack&lt;Symbol&gt; stack,
 891             int top)
 892             throws java.lang.Exception {
 893         /* call code in generated class */
 894         return action_obj.parser_do_action(act_num, parser, stack, top);
 895     }
 896 
 897     /**
 898      * Indicates start state.
 899      */
 900     public int start_state() {
 901         return 0;
 902     }
 903 
 904     /**
 905      * Indicates start production.
 906      */
 907     public int start_production() {
 908         return 0;
 909     }
 910 
 911     /**
 912      * &lt;code&gt;EOF&lt;/code&gt; Symbol index.
 913      */
 914     public int EOF_sym() {
 915         return 0;
 916     }
 917 
 918     /**
 919      * &lt;code&gt;error&lt;/code&gt; Symbol index.
 920      */
 921     public int error_sym() {
 922         return 1;
 923     }
 924 
 925     /**
 926      * Used by function calls with no args.
 927      */
 928     static public final List&lt;Expression&gt; EmptyArgs = new ArrayList&lt;&gt;(0);
 929 
 930     /**
 931      * Reference to non-existing variable.
 932      */
 933     static public final VariableRef DummyVarRef = null;
 934 
 935     /**
 936      * Reference to the Parser class.
 937      */
 938     private Parser _parser;
 939     private XSLTC _xsltc;
 940 
 941     /**
 942      * String representation of the expression being parsed.
 943      */
 944     private String _expression;
 945 
 946     /**
 947      * Line number where this expression/pattern was declared.
 948      */
 949     private int _lineNumber = 0;
 950 
 951     /**
 952      * Reference to the symbol table.
 953      */
 954     public SymbolTable _symbolTable;
 955 
 956     public XPathParser(Parser parser) {
 957         _parser = parser;
 958         _xsltc = parser.getXSLTC();
 959         _symbolTable = parser.getSymbolTable();
 960     }
 961 
 962     public int getLineNumber() {
 963         return _lineNumber;
 964     }
 965 
 966     public QName getQNameIgnoreDefaultNs(String name) {
 967         return _parser.getQNameIgnoreDefaultNs(name);
 968     }
 969 
 970     public QName getQName(String namespace, String prefix, String localname) {
 971         return _parser.getQName(namespace, prefix, localname);
 972     }
 973 
 974     public void setMultiDocument(boolean flag) {
 975         _xsltc.setMultiDocument(flag);
 976     }
 977 
 978     public void setCallsNodeset(boolean flag) {
 979         _xsltc.setCallsNodeset(flag);
 980     }
 981 
 982     public void setHasIdCall(boolean flag) {
 983         _xsltc.setHasIdCall(flag);
 984     }
 985 
 986     /**
 987      * This method is similar to findNodeType(int, Object) except that it
 988      * creates a StepPattern instead of just returning a node type. It also
 989      * differs in the way it handles &quot;{uri}:*&quot; and &quot;{uri}:@*&quot;. The last two
 990      * patterns are expanded as &quot;*[namespace-uri() = &#39;uri&#39;]&quot; and
 991      * &quot;@*[namespace-uri() = &#39;uri&#39;]&quot;, respectively. This expansion considerably
 992      * simplifies the grouping of patterns in the Mode class. For this expansion
 993      * to be correct, the priority of the pattern/template must be set to -0.25
 994      * (when no other predicates are present).
 995      */
 996     public StepPattern createStepPattern(int axis, Object test, List&lt;Predicate&gt; predicates) {
 997         int nodeType;
 998 
 999         if (test == null) {  // &quot;*&quot;
1000             nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
1001                     : (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;
1002 
1003             return new StepPattern(axis, nodeType, predicates);
1004         } else if (test instanceof Integer) {
1005             nodeType = ((Integer) test);
1006 
1007             return new StepPattern(axis, nodeType, predicates);
1008         } else {
1009             QName name = (QName) test;
1010             boolean setPriority = false;
1011 
1012             if (axis == Axis.NAMESPACE) {
1013                 nodeType = (name.toString().equals(&quot;*&quot;)) ? -1
1014                         : _xsltc.registerNamespacePrefix(name);;
1015             } else {
1016                 final String uri = name.getNamespace();
1017                 final String local = name.getLocalPart();
1018                 final QName namespace_uri
1019                         = _parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;);
1020 
1021                 // Expand {uri}:* to *[namespace-uri() = &#39;uri&#39;] - same for @*
1022                 if (uri != null &amp;&amp; (local.equals(&quot;*&quot;) || local.equals(&quot;@*&quot;))) {
1023                     if (predicates == null) {
1024                         predicates = new ArrayList&lt;&gt;(2);
1025                     }
1026 
1027                     // Priority is set by hand if no other predicates exist
1028                     setPriority = (predicates.size() == 0);
1029 
1030                     predicates.add(
1031                             new Predicate(
1032                                     new EqualityExpr(Operators.EQ,
1033                                             new NamespaceUriCall(namespace_uri),
1034                                             new LiteralExpr(uri))));
1035                 }
1036 
1037                 if (local.equals(&quot;*&quot;)) {
1038                     nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
1039                             : NodeTest.ELEMENT;
1040                 } else if (local.equals(&quot;@*&quot;)) {
1041                     nodeType = NodeTest.ATTRIBUTE;
1042                 } else {
1043                     nodeType = (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
1044                             : _xsltc.registerElement(name);
1045                 }
1046             }
1047 
1048             final StepPattern result = new StepPattern(axis, nodeType, predicates);
1049 
1050             // Set priority for case prefix:* and prefix:@* (no predicates)
1051             if (setPriority) {
1052                 result.setPriority(-0.25);
1053             }
1054 
1055             return result;
1056         }
1057     }
1058 
1059     public int findNodeType(int axis, Object test) {
1060         if (test == null) {  // *
1061             return (axis == Axis.ATTRIBUTE)
1062                     ? NodeTest.ATTRIBUTE
1063                     : (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;
1064         } else if (test instanceof Integer) {
1065             return ((Integer) test);
1066         } else {
1067             QName name = (QName) test;
1068 
1069             if (axis == Axis.NAMESPACE) {
1070                 return (name.toString().equals(&quot;*&quot;)) ? -1
1071                         : _xsltc.registerNamespacePrefix(name);
1072             }
1073 
1074             if (name.getNamespace() == null) {
1075                 final String local = name.getLocalPart();
1076 
1077                 if (local.equals(&quot;*&quot;)) {
1078                     return (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
1079                             : NodeTest.ELEMENT;
1080                 } else if (local.equals(&quot;@*&quot;)) {
1081                     return NodeTest.ATTRIBUTE;
1082                 }
1083             }
1084 
1085             return (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
1086                     : _xsltc.registerElement(name);
1087         }
1088     }
1089 
1090     /**
1091      * Parse the expression passed to the current scanner. If this expression
1092      * contains references to local variables and it will be compiled in an
1093      * external module (not in the main class) request the current template to
1094      * create a new variable stack frame.
1095      *
1096      * @param expression the expression to be parsed
1097      * @param lineNumber Line where the current expression is defined.
1098      *
1099      */
1100     public Symbol parse(String expression, int lineNumber) throws Exception {
1101         try {
1102             _expression = expression;
1103             _lineNumber = lineNumber;
1104             return super.parse();
1105         } catch (IllegalCharException e) {
1106             ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_CHAR_ERR,
1107                     lineNumber, e.getMessage());
1108             _parser.reportError(Constants.FATAL, err);
1109         }
1110         return null;
1111     }
1112 
1113     /**
1114      * Lookup a variable or parameter in the symbol table given its name.
1115      *
1116      * @param name Name of the symbol being looked up.
1117      */
1118     final SyntaxTreeNode lookupName(QName name) {
1119         // Is it a local var or param ?
1120         final SyntaxTreeNode result = _parser.lookupVariable(name);
1121         if (result != null) {
1122             return (result);
1123         } else {
1124             return (_symbolTable.lookupName(name));
1125         }
1126     }
1127 
1128     public final void addError(ErrorMsg error) {
1129         _parser.reportError(Constants.ERROR, error);
1130     }
1131 
1132     public void report_error(String message, Object info) {
1133         final ErrorMsg err = new ErrorMsg(ErrorMsg.SYNTAX_ERR, _lineNumber,
1134                 _expression);
1135         _parser.reportError(Constants.FATAL, err);
1136     }
1137 
1138     public void report_fatal_error(String message, Object info) {
1139         // empty
1140     }
1141 
1142     public RelativeLocationPath insertStep(Step step, RelativeLocationPath rlp) {
1143         if (rlp instanceof Step) {
1144             return new ParentLocationPath(step, (Step) rlp);
1145         } else if (rlp instanceof ParentLocationPath) {
1146             final ParentLocationPath plp = (ParentLocationPath) rlp;
1147             final RelativeLocationPath newrlp = insertStep(step, plp.getPath());
1148             return new ParentLocationPath(newrlp, plp.getStep());
1149         } else {
1150             addError(new ErrorMsg(ErrorMsg.INTERNAL_ERR, &quot;XPathParser.insertStep&quot;));
1151             return rlp;
1152         }
1153     }
1154 
1155     /**
1156      * Returns true if the axis applies to elements only. The axes child,
1157      * attribute, namespace, descendant result in non-empty nodesets only if the
1158      * context node is of type element.
1159      */
1160     public boolean isElementAxis(int axis) {
1161         return (axis == Axis.CHILD || axis == Axis.ATTRIBUTE
1162                 || axis == Axis.NAMESPACE || axis == Axis.DESCENDANT);
1163     }
1164 
1165 }
1166 
1167 /**
1168  * Cup generated class to encapsulate user supplied action code.
1169  */
1170 class parser_actions {
1171 
1172     private final XPathParser parser;
1173 
1174     /**
1175      * Constructor
1176      */
1177     parser_actions(XPathParser parser) {
1178         this.parser = parser;
1179     }
1180 
1181     /**
1182      * Method with the actual generated action code.
1183      */
1184     public final Symbol parser_do_action(
1185             int parser_act_num,
1186             lr_parser parser_parser,
1187             Stack&lt;Symbol&gt; parser_stack,
1188             int parser_top)
1189             throws java.lang.Exception {
1190         /* Symbol object for return from actions */
1191         Symbol parser_result;
1192 
1193         /* select the action based on the action number */
1194         switch (parser_act_num) {
1195             /*. . . . . . . . . . . . . . . . . . . .*/
1196             case 0: // $START ::= TopLevel EOF
1197             {
1198                 SyntaxTreeNode start_val = (SyntaxTreeNode) (parser_stack.get(parser_top - 1)).value;
1199                 parser_result = new Symbol(0, (parser_stack.get(parser_top - 1)).left,
1200                         (parser_stack.get(parser_top - 0)).right, start_val);
1201             }
1202             /* ACCEPT */
1203             parser_parser.done_parsing();
1204             return parser_result;
1205 
1206             /*. . . . . . . . . . . . . . . . . . . .*/
1207             case 1: // TopLevel ::= PATTERN Pattern
1208             {
1209                 Pattern pattern = (Pattern) (parser_stack.get(parser_top - 0)).value;
1210                 parser_result = new Symbol(1, (parser_stack.get(parser_top - 1)).left,
1211                         (parser_stack.get(parser_top - 0)).right, pattern);
1212             }
1213             return parser_result;
1214 
1215             /*. . . . . . . . . . . . . . . . . . . .*/
1216             case 2: // TopLevel ::= EXPRESSION Expr
1217             {
1218                 Expression expr = (Expression) (parser_stack.get(parser_top - 0)).value;
1219                 parser_result = new Symbol(1, (parser_stack.get(parser_top - 1)).left,
1220                         (parser_stack.get(parser_top - 0)).right, expr);
1221             }
1222             return parser_result;
1223 
1224             /*. . . . . . . . . . . . . . . . . . . .*/
1225             case 3: // Pattern ::= LocationPathPattern
1226             {
1227                 Pattern lpp = (Pattern) (parser_stack.get(parser_top - 0)).value;
1228                 parser_result = new Symbol(28, (parser_stack.get(parser_top - 0)).left,
1229                         (parser_stack.get(parser_top - 0)).right, lpp);
1230             }
1231             return parser_result;
1232 
1233             /*. . . . . . . . . . . . . . . . . . . .*/
1234             case 4: // Pattern ::= LocationPathPattern VBAR Pattern
1235             {
1236                 Pattern lpp = (Pattern) (parser_stack.get(parser_top - 2)).value;
1237                 Pattern p = (Pattern) (parser_stack.get(parser_top - 0)).value;
1238                 Pattern result = new AlternativePattern(lpp, p);
1239                 parser_result = new Symbol(28, (parser_stack.get(parser_top - 2)).left,
1240                         (parser_stack.get(parser_top - 0)).right, result);
1241             }
1242             return parser_result;
1243 
1244             /*. . . . . . . . . . . . . . . . . . . .*/
1245             case 5: // LocationPathPattern ::= SLASH
1246             {
1247                 Pattern result = new AbsolutePathPattern(null);
1248                 parser_result = new Symbol(29, (parser_stack.get(parser_top - 0)).left,
1249                         (parser_stack.get(parser_top - 0)).right, result);
1250             }
1251             return parser_result;
1252 
1253             /*. . . . . . . . . . . . . . . . . . . .*/
1254             case 6: // LocationPathPattern ::= SLASH RelativePathPattern
1255             {
1256                 RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
1257                 Pattern result = new AbsolutePathPattern(rpp);
1258                 parser_result = new Symbol(29, (parser_stack.get(parser_top - 1)).left,
1259                         (parser_stack.get(parser_top - 0)).right, result);
1260             }
1261             return parser_result;
1262 
1263             /*. . . . . . . . . . . . . . . . . . . .*/
1264             case 7: // LocationPathPattern ::= IdKeyPattern
1265             {
1266                 IdKeyPattern ikp = (IdKeyPattern) (parser_stack.get(parser_top - 0)).value;
1267                 parser_result = new Symbol(29, (parser_stack.get(parser_top - 0)).left,
1268                         (parser_stack.get(parser_top - 0)).right, ikp);
1269             }
1270             return parser_result;
1271 
1272             /*. . . . . . . . . . . . . . . . . . . .*/
1273             case 8: // LocationPathPattern ::= IdKeyPattern SLASH RelativePathPattern
1274             {
1275                 IdKeyPattern ikp = (IdKeyPattern) (parser_stack.get(parser_top - 2)).value;
1276                 RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
1277                 Pattern result = new ParentPattern(ikp, rpp);
1278                 parser_result = new Symbol(29, (parser_stack.get(parser_top - 2)).left,
1279                         (parser_stack.get(parser_top - 0)).right, result);
1280             }
1281             return parser_result;
1282 
1283             /*. . . . . . . . . . . . . . . . . . . .*/
1284             case 9: // LocationPathPattern ::= IdKeyPattern DSLASH RelativePathPattern
1285             {
1286                 IdKeyPattern ikp = (IdKeyPattern) (parser_stack.get(parser_top - 2)).value;
1287                 RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
1288                 Pattern result = new AncestorPattern(ikp, rpp);
1289                 parser_result = new Symbol(29, (parser_stack.get(parser_top - 2)).left,
1290                         (parser_stack.get(parser_top - 0)).right, result);
1291             }
1292             return parser_result;
1293 
1294             /*. . . . . . . . . . . . . . . . . . . .*/
1295             case 10: // LocationPathPattern ::= DSLASH RelativePathPattern
1296             {
1297                 RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
1298                 Pattern result = new AncestorPattern(rpp);
1299                 parser_result = new Symbol(29, (parser_stack.get(parser_top - 1)).left,
1300                         (parser_stack.get(parser_top - 0)).right, result);
1301             }
1302             return parser_result;
1303 
1304             /*. . . . . . . . . . . . . . . . . . . .*/
1305             case 11: // LocationPathPattern ::= RelativePathPattern
1306             {
1307                 RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
1308                 parser_result = new Symbol(29, (parser_stack.get(parser_top - 0)).left,
1309                         (parser_stack.get(parser_top - 0)).right, rpp);
1310             }
1311             return parser_result;
1312 
1313             /*. . . . . . . . . . . . . . . . . . . .*/
1314             case 12: // IdKeyPattern ::= ID LPAREN Literal RPAREN
1315             {
1316                 String l = (String) (parser_stack.get(parser_top - 1)).value;
1317                 IdKeyPattern result = new IdPattern(l);
1318                 parser.setHasIdCall(true);
1319                 parser_result = new Symbol(27, (parser_stack.get(parser_top - 3)).left,
1320                         (parser_stack.get(parser_top - 0)).right, result);
1321             }
1322             return parser_result;
1323 
1324             /*. . . . . . . . . . . . . . . . . . . .*/
1325             case 13: // IdKeyPattern ::= KEY LPAREN Literal COMMA Literal RPAREN
1326             {
1327                 String l1 = (String) (parser_stack.get(parser_top - 3)).value;
1328                 String l2 = (String) (parser_stack.get(parser_top - 1)).value;
1329                 IdKeyPattern result = new KeyPattern(l1, l2);
1330                 parser_result = new Symbol(27, (parser_stack.get(parser_top - 5)).left,
1331                         (parser_stack.get(parser_top - 0)).right, result);
1332             }
1333             return parser_result;
1334 
1335             /*. . . . . . . . . . . . . . . . . . . .*/
1336             case 14: // ProcessingInstructionPattern ::= PIPARAM LPAREN Literal RPAREN
1337             {
1338                 String l = (String) (parser_stack.get(parser_top - 1)).value;
1339                 StepPattern result = new ProcessingInstructionPattern(l);
1340                 parser_result = new Symbol(30, (parser_stack.get(parser_top - 3)).left,
1341                         (parser_stack.get(parser_top - 0)).right, result);
1342             }
1343             return parser_result;
1344 
1345             /*. . . . . . . . . . . . . . . . . . . .*/
1346             case 15: // RelativePathPattern ::= StepPattern
1347             {
1348                 StepPattern sp = (StepPattern) (parser_stack.get(parser_top - 0)).value;
1349                 parser_result = new Symbol(31, (parser_stack.get(parser_top - 0)).left,
1350                         (parser_stack.get(parser_top - 0)).right, sp);
1351             }
1352             return parser_result;
1353 
1354             /*. . . . . . . . . . . . . . . . . . . .*/
1355             case 16: // RelativePathPattern ::= StepPattern SLASH RelativePathPattern
1356             {
1357                 StepPattern sp = (StepPattern) (parser_stack.get(parser_top - 2)).value;
1358                 RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
1359                 RelativePathPattern result = new ParentPattern(sp, rpp);
1360                 parser_result = new Symbol(31, (parser_stack.get(parser_top - 2)).left,
1361                         (parser_stack.get(parser_top - 0)).right, result);
1362             }
1363             return parser_result;
1364 
1365             /*. . . . . . . . . . . . . . . . . . . .*/
1366             case 17: // RelativePathPattern ::= StepPattern DSLASH RelativePathPattern
1367             {
1368                 StepPattern sp = (StepPattern) (parser_stack.get(parser_top - 2)).value;
1369                 RelativePathPattern rpp = (RelativePathPattern) (parser_stack.get(parser_top - 0)).value;
1370                 RelativePathPattern result = new AncestorPattern(sp, rpp);
1371                 parser_result = new Symbol(31, (parser_stack.get(parser_top - 2)).left,
1372                         (parser_stack.get(parser_top - 0)).right, result);
1373             }
1374             return parser_result;
1375 
1376             /*. . . . . . . . . . . . . . . . . . . .*/
1377             case 18: // StepPattern ::= NodeTestPattern
1378             {
1379                 Object nt = parser_stack.get(parser_top - 0).value;
1380                 StepPattern result = parser.createStepPattern(Axis.CHILD, nt, null);
1381                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 0)).left,
1382                         (parser_stack.get(parser_top - 0)).right, result);
1383             }
1384             return parser_result;
1385 
1386             /*. . . . . . . . . . . . . . . . . . . .*/
1387             case 19: // StepPattern ::= NodeTestPattern Predicates
1388             {
1389                 Object nt = parser_stack.get(parser_top - 1).value;
1390                 @SuppressWarnings(&quot;unchecked&quot;)
1391                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;) (parser_stack.get(parser_top - 0)).value;
1392                 StepPattern result = parser.createStepPattern(Axis.CHILD, nt, pp);
1393                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
1394                         (parser_stack.get(parser_top - 0)).right, result);
1395             }
1396             return parser_result;
1397 
1398             /*. . . . . . . . . . . . . . . . . . . .*/
1399             case 20: // StepPattern ::= ProcessingInstructionPattern
1400             {
1401                 StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 0)).value;
1402                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 0)).left,
1403                         (parser_stack.get(parser_top - 0)).right, pip);
1404             }
1405             return parser_result;
1406 
1407             /*. . . . . . . . . . . . . . . . . . . .*/
1408             case 21: // StepPattern ::= ProcessingInstructionPattern Predicates
1409             {
1410                 StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 1)).value;
1411                 @SuppressWarnings(&quot;unchecked&quot;)
1412                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;) (parser_stack.get(parser_top - 0)).value;
1413                 StepPattern result = (ProcessingInstructionPattern) pip.setPredicates(pp);
1414                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
1415                         (parser_stack.get(parser_top - 0)).right, result);
1416             }
1417             return parser_result;
1418 
1419             /*. . . . . . . . . . . . . . . . . . . .*/
1420             case 22: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern
1421             {
1422                 Integer axis = (Integer) (parser_stack.get(parser_top - 1)).value;
1423                 Object nt = parser_stack.get(parser_top - 0).value;
1424                 StepPattern result = parser.createStepPattern(axis, nt, null);
1425                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
1426                         (parser_stack.get(parser_top - 0)).right, result);
1427             }
1428             return parser_result;
1429 
1430             /*. . . . . . . . . . . . . . . . . . . .*/
1431             case 23: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern Predicates
1432             {
1433                 Integer axis = (Integer) (parser_stack.get(parser_top - 2)).value;
1434                 Object nt = parser_stack.get(parser_top - 1).value;
1435                 @SuppressWarnings(&quot;unchecked&quot;)
1436                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;) (parser_stack.get(parser_top - 0)).value;
1437                 StepPattern result = parser.createStepPattern(axis, nt, pp);
1438                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 2)).left,
1439                         (parser_stack.get(parser_top - 0)).right, result);
1440             }
1441             return parser_result;
1442 
1443             /*. . . . . . . . . . . . . . . . . . . .*/
1444             case 24: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern
1445             {
1446                 StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 0)).value;
1447                 StepPattern result = pip;    // TODO: report error if axis is attribute
1448                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 1)).left,
1449                         (parser_stack.get(parser_top - 0)).right, result);
1450             }
1451             return parser_result;
1452 
1453             /*. . . . . . . . . . . . . . . . . . . .*/
1454             case 25: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern Predicates
1455             {
1456                 StepPattern pip = (StepPattern) (parser_stack.get(parser_top - 1)).value;
1457                 @SuppressWarnings(&quot;unchecked&quot;)
1458                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;) (parser_stack.get(parser_top - 0)).value;
1459                 // TODO: report error if axis is attribute
1460                 StepPattern result = (ProcessingInstructionPattern) pip.setPredicates(pp);
1461                 parser_result = new Symbol(32, (parser_stack.get(parser_top - 2)).left,
1462                         (parser_stack.get(parser_top - 0)).right, result);
1463             }
1464             return parser_result;
1465 
1466             /*. . . . . . . . . . . . . . . . . . . .*/
1467             case 26: // NodeTestPattern ::= NameTestPattern
1468             {
1469                 Object nt = parser_stack.get(parser_top - 0).value;
1470                 parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
1471                         (parser_stack.get(parser_top - 0)).right, nt);
1472             }
1473             return parser_result;
1474 
1475             /*. . . . . . . . . . . . . . . . . . . .*/
1476             case 27: // NodeTestPattern ::= NODE
1477             {
1478                 Object result = NodeTest.ANODE;
1479                 parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
1480                         (parser_stack.get(parser_top - 0)).right, result);
1481             }
1482             return parser_result;
1483 
1484             /*. . . . . . . . . . . . . . . . . . . .*/
1485             case 28: // NodeTestPattern ::= TEXT
1486             {
1487                 Object result = NodeTest.TEXT;
1488                 parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
1489                         (parser_stack.get(parser_top - 0)).right, result);
1490             }
1491             return parser_result;
1492 
1493             /*. . . . . . . . . . . . . . . . . . . .*/
1494             case 29: // NodeTestPattern ::= COMMENT
1495             {
1496                 Object result = NodeTest.COMMENT;
1497                 parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
1498                         (parser_stack.get(parser_top - 0)).right, result);
1499             }
1500             return parser_result;
1501 
1502             /*. . . . . . . . . . . . . . . . . . . .*/
1503             case 30: // NodeTestPattern ::= PI
1504             {
1505                 Object result = NodeTest.PI;
1506                 parser_result = new Symbol(33, (parser_stack.get(parser_top - 0)).left,
1507                         (parser_stack.get(parser_top - 0)).right, result);
1508             }
1509             return parser_result;
1510 
1511             /*. . . . . . . . . . . . . . . . . . . .*/
1512             case 31: // NameTestPattern ::= STAR
1513             {
1514                 Object result = null;
1515                 parser_result = new Symbol(34, (parser_stack.get(parser_top - 0)).left,
1516                         (parser_stack.get(parser_top - 0)).right, result);
1517             }
1518             return parser_result;
1519 
1520             /*. . . . . . . . . . . . . . . . . . . .*/
1521             case 32: // NameTestPattern ::= QName
1522             {
1523                 QName qn = (QName) (parser_stack.get(parser_top - 0)).value;
1524                 parser_result = new Symbol(34, (parser_stack.get(parser_top - 0)).left,
1525                         (parser_stack.get(parser_top - 0)).right, qn);
1526             }
1527             return parser_result;
1528 
1529             /*. . . . . . . . . . . . . . . . . . . .*/
1530             case 33: // ChildOrAttributeAxisSpecifier ::= ATSIGN
1531             {
1532                 Integer result = Axis.ATTRIBUTE;
1533                 parser_result = new Symbol(42, (parser_stack.get(parser_top - 0)).left,
1534                         (parser_stack.get(parser_top - 0)).right, result);
1535             }
1536             return parser_result;
1537 
1538             /*. . . . . . . . . . . . . . . . . . . .*/
1539             case 34: // ChildOrAttributeAxisSpecifier ::= CHILD DCOLON
1540             {
1541                 Integer result = Axis.CHILD;
1542                 parser_result = new Symbol(42, (parser_stack.get(parser_top - 1)).left,
1543                         (parser_stack.get(parser_top - 0)).right, result);
1544             }
1545             return parser_result;
1546 
1547             /*. . . . . . . . . . . . . . . . . . . .*/
1548             case 35: // ChildOrAttributeAxisSpecifier ::= ATTRIBUTE DCOLON
1549             {
1550                 Integer result = Axis.ATTRIBUTE;
1551                 parser_result = new Symbol(42, (parser_stack.get(parser_top - 1)).left,
1552                         (parser_stack.get(parser_top - 0)).right, result);
1553             }
1554             return parser_result;
1555 
1556             /*. . . . . . . . . . . . . . . . . . . .*/
1557             case 36: // Predicates ::= Predicate
1558             {
1559                 Expression p = (Expression) (parser_stack.get(parser_top - 0)).value;
1560                 List&lt;Expression&gt; temp = new ArrayList&lt;&gt;();
1561                 temp.add(p);
1562                 parser_result = new Symbol(35, (parser_stack.get(parser_top - 0)).left,
1563                         (parser_stack.get(parser_top - 0)).right, temp);
1564             }
1565             return parser_result;
1566 
1567             /*. . . . . . . . . . . . . . . . . . . .*/
1568             case 37: // Predicates ::= Predicate Predicates
1569             {
1570                 Expression p = (Expression) (parser_stack.get(parser_top - 1)).value;
1571                 @SuppressWarnings(&quot;unchecked&quot;)
1572                 List&lt;Expression&gt; pp = (ArrayList&lt;Expression&gt;) (parser_stack.get(parser_top - 0)).value;
1573                 pp.add(0, p);
1574                 parser_result = new Symbol(35, (parser_stack.get(parser_top - 1)).left,
1575                         (parser_stack.get(parser_top - 0)).right, pp);
1576             }
1577             return parser_result;
1578 
1579             /*. . . . . . . . . . . . . . . . . . . .*/
1580             case 38: // Predicate ::= LBRACK Expr RBRACK
1581             {
1582                 Expression e = (Expression) (parser_stack.get(parser_top - 1)).value;
1583                 Expression result = new Predicate(e);
1584                 parser_result = new Symbol(5, (parser_stack.get(parser_top - 2)).left,
1585                         (parser_stack.get(parser_top - 0)).right, result);
1586             }
1587             return parser_result;
1588 
1589             /*. . . . . . . . . . . . . . . . . . . .*/
1590             case 39: // Expr ::= OrExpr
1591             {
1592                 Expression ex = (Expression) (parser_stack.get(parser_top - 0)).value;
1593                 parser_result = new Symbol(2, (parser_stack.get(parser_top - 0)).left,
1594                         (parser_stack.get(parser_top - 0)).right, ex);
1595             }
1596             return parser_result;
1597 
1598             /*. . . . . . . . . . . . . . . . . . . .*/
1599             case 40: // OrExpr ::= AndExpr
1600             {
1601                 Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
1602                 parser_result = new Symbol(8, (parser_stack.get(parser_top - 0)).left,
1603                         (parser_stack.get(parser_top - 0)).right, ae);
1604             }
1605             return parser_result;
1606 
1607             /*. . . . . . . . . . . . . . . . . . . .*/
1608             case 41: // OrExpr ::= OrExpr OR AndExpr
1609             {
1610                 Expression oe = (Expression) (parser_stack.get(parser_top - 2)).value;
1611                 Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
1612                 Expression result = new LogicalExpr(LogicalExpr.OR, oe, ae);
1613                 parser_result = new Symbol(8, (parser_stack.get(parser_top - 2)).left,
1614                         (parser_stack.get(parser_top - 0)).right, result);
1615             }
1616             return parser_result;
1617 
1618             /*. . . . . . . . . . . . . . . . . . . .*/
1619             case 42: // AndExpr ::= EqualityExpr
1620             {
1621                 Expression e = (Expression) (parser_stack.get(parser_top - 0)).value;
1622                 parser_result = new Symbol(9, (parser_stack.get(parser_top - 0)).left,
1623                         (parser_stack.get(parser_top - 0)).right, e);
1624             }
1625             return parser_result;
1626 
1627             /*. . . . . . . . . . . . . . . . . . . .*/
1628             case 43: // AndExpr ::= AndExpr AND EqualityExpr
1629             {
1630                 Expression ae = (Expression) (parser_stack.get(parser_top - 2)).value;
1631                 Expression ee = (Expression) (parser_stack.get(parser_top - 0)).value;
1632                 Expression result = new LogicalExpr(LogicalExpr.AND, ae, ee);
1633                 parser_result = new Symbol(9, (parser_stack.get(parser_top - 2)).left,
1634                         (parser_stack.get(parser_top - 0)).right, result);
1635             }
1636             return parser_result;
1637 
1638             /*. . . . . . . . . . . . . . . . . . . .*/
1639             case 44: // EqualityExpr ::= RelationalExpr
1640             {
1641                 Expression re = (Expression) (parser_stack.get(parser_top - 0)).value;
1642                 parser_result = new Symbol(10, (parser_stack.get(parser_top - 0)).left,
1643                         (parser_stack.get(parser_top - 0)).right, re);
1644             }
1645             return parser_result;
1646 
1647             /*. . . . . . . . . . . . . . . . . . . .*/
1648             case 45: // EqualityExpr ::= EqualityExpr EQ RelationalExpr
1649             {
1650                 Expression ee = (Expression) (parser_stack.get(parser_top - 2)).value;
1651                 Expression re = (Expression) (parser_stack.get(parser_top - 0)).value;
1652                 Expression result = new EqualityExpr(Operators.EQ, ee, re);
1653                 parser_result = new Symbol(10, (parser_stack.get(parser_top - 2)).left,
1654                         (parser_stack.get(parser_top - 0)).right, result);
1655             }
1656             return parser_result;
1657 
1658             /*. . . . . . . . . . . . . . . . . . . .*/
1659             case 46: // EqualityExpr ::= EqualityExpr NE RelationalExpr
1660             {
1661                 Expression ee = (Expression) (parser_stack.get(parser_top - 2)).value;
1662                 Expression re = (Expression) (parser_stack.get(parser_top - 0)).value;
1663                 Expression result = new EqualityExpr(Operators.NE, ee, re);
1664                 parser_result = new Symbol(10, (parser_stack.get(parser_top - 2)).left,
1665                         (parser_stack.get(parser_top - 0)).right, result);
1666             }
1667             return parser_result;
1668 
1669             /*. . . . . . . . . . . . . . . . . . . .*/
1670             case 47: // RelationalExpr ::= AdditiveExpr
1671             {
1672                 Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
1673                 parser_result = new Symbol(11, (parser_stack.get(parser_top - 0)).left,
1674                         (parser_stack.get(parser_top - 0)).right, ae);
1675             }
1676             return parser_result;
1677 
1678             /*. . . . . . . . . . . . . . . . . . . .*/
1679             case 48: // RelationalExpr ::= RelationalExpr LT AdditiveExpr
1680             {
1681                 Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
1682                 Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
1683                 Expression result = new RelationalExpr(Operators.LT, re, ae);
1684                 parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
1685                         (parser_stack.get(parser_top - 0)).right, result);
1686             }
1687             return parser_result;
1688 
1689             /*. . . . . . . . . . . . . . . . . . . .*/
1690             case 49: // RelationalExpr ::= RelationalExpr GT AdditiveExpr
1691             {
1692                 Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
1693                 Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
1694                 Expression result = new RelationalExpr(Operators.GT, re, ae);
1695                 parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
1696                         (parser_stack.get(parser_top - 0)).right, result);
1697             }
1698             return parser_result;
1699 
1700             /*. . . . . . . . . . . . . . . . . . . .*/
1701             case 50: // RelationalExpr ::= RelationalExpr LE AdditiveExpr
1702             {
1703                 Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
1704                 Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
1705                 Expression result = new RelationalExpr(Operators.LE, re, ae);
1706                 parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
1707                         (parser_stack.get(parser_top - 0)).right, result);
1708             }
1709             return parser_result;
1710 
1711             /*. . . . . . . . . . . . . . . . . . . .*/
1712             case 51: // RelationalExpr ::= RelationalExpr GE AdditiveExpr
1713             {
1714                 Expression re = (Expression) (parser_stack.get(parser_top - 2)).value;
1715                 Expression ae = (Expression) (parser_stack.get(parser_top - 0)).value;
1716                 Expression result = new RelationalExpr(Operators.GE, re, ae);
1717                 parser_result = new Symbol(11, (parser_stack.get(parser_top - 2)).left,
1718                         (parser_stack.get(parser_top - 0)).right, result);
1719             }
1720             return parser_result;
1721 
1722             /*. . . . . . . . . . . . . . . . . . . .*/
1723             case 52: // AdditiveExpr ::= MultiplicativeExpr
1724             {
1725                 Expression me = (Expression) (parser_stack.get(parser_top - 0)).value;
1726                 parser_result = new Symbol(12, (parser_stack.get(parser_top - 0)).left,
1727                         (parser_stack.get(parser_top - 0)).right, me);
1728             }
1729             return parser_result;
1730 
1731             /*. . . . . . . . . . . . . . . . . . . .*/
1732             case 53: // AdditiveExpr ::= AdditiveExpr PLUS MultiplicativeExpr
1733             {
1734                 Expression ae = (Expression) (parser_stack.get(parser_top - 2)).value;
1735                 Expression me = (Expression) (parser_stack.get(parser_top - 0)).value;
1736                 Expression result = new BinOpExpr(BinOpExpr.PLUS, ae, me);
1737                 parser_result = new Symbol(12, (parser_stack.get(parser_top - 2)).left,
1738                         (parser_stack.get(parser_top - 0)).right, result);
1739             }
1740             return parser_result;
1741 
1742             /*. . . . . . . . . . . . . . . . . . . .*/
1743             case 54: // AdditiveExpr ::= AdditiveExpr MINUS MultiplicativeExpr
1744             {
1745                 Expression ae = (Expression) (parser_stack.get(parser_top - 2)).value;
1746                 Expression me = (Expression) (parser_stack.get(parser_top - 0)).value;
1747                 Expression result = new BinOpExpr(BinOpExpr.MINUS, ae, me);
1748                 parser_result = new Symbol(12, (parser_stack.get(parser_top - 2)).left,
1749                         (parser_stack.get(parser_top - 0)).right, result);
1750             }
1751             return parser_result;
1752 
1753             /*. . . . . . . . . . . . . . . . . . . .*/
1754             case 55: // MultiplicativeExpr ::= UnaryExpr
1755             {
1756                 Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
1757                 parser_result = new Symbol(13, (parser_stack.get(parser_top - 0)).left,
1758                         (parser_stack.get(parser_top - 0)).right, ue);
1759             }
1760             return parser_result;
1761 
1762             /*. . . . . . . . . . . . . . . . . . . .*/
1763             case 56: // MultiplicativeExpr ::= MultiplicativeExpr STAR UnaryExpr
1764             {
1765                 Expression me = (Expression) (parser_stack.get(parser_top - 2)).value;
1766                 Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
1767                 Expression result = new BinOpExpr(BinOpExpr.TIMES, me, ue);
1768                 parser_result = new Symbol(13, (parser_stack.get(parser_top - 2)).left,
1769                         (parser_stack.get(parser_top - 0)).right, result);
1770             }
1771             return parser_result;
1772 
1773             /*. . . . . . . . . . . . . . . . . . . .*/
1774             case 57: // MultiplicativeExpr ::= MultiplicativeExpr DIV UnaryExpr
1775             {
1776                 Expression me = (Expression) (parser_stack.get(parser_top - 2)).value;
1777                 Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
1778                 Expression result = new BinOpExpr(BinOpExpr.DIV, me, ue);
1779                 parser_result = new Symbol(13, (parser_stack.get(parser_top - 2)).left,
1780                         (parser_stack.get(parser_top - 0)).right, result);
1781             }
1782             return parser_result;
1783 
1784             /*. . . . . . . . . . . . . . . . . . . .*/
1785             case 58: // MultiplicativeExpr ::= MultiplicativeExpr MOD UnaryExpr
1786             {
1787                 Expression me = (Expression) (parser_stack.get(parser_top - 2)).value;
1788                 Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
1789                 Expression result = new BinOpExpr(BinOpExpr.MOD, me, ue);
1790                 parser_result = new Symbol(13, (parser_stack.get(parser_top - 2)).left,
1791                         (parser_stack.get(parser_top - 0)).right, result);
1792             }
1793             return parser_result;
1794 
1795             /*. . . . . . . . . . . . . . . . . . . .*/
1796             case 59: // UnaryExpr ::= UnionExpr
1797             {
1798                 Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
1799                 parser_result = new Symbol(14, (parser_stack.get(parser_top - 0)).left,
1800                         (parser_stack.get(parser_top - 0)).right, ue);
1801             }
1802             return parser_result;
1803 
1804             /*. . . . . . . . . . . . . . . . . . . .*/
1805             case 60: // UnaryExpr ::= MINUS UnaryExpr
1806             {
1807                 Expression ue = (Expression) (parser_stack.get(parser_top - 0)).value;
1808                 Expression result = new UnaryOpExpr(ue);
1809                 parser_result = new Symbol(14, (parser_stack.get(parser_top - 1)).left,
1810                         (parser_stack.get(parser_top - 0)).right, result);
1811             }
1812             return parser_result;
1813 
1814             /*. . . . . . . . . . . . . . . . . . . .*/
1815             case 61: // UnionExpr ::= PathExpr
1816             {
1817                 Expression pe = (Expression) (parser_stack.get(parser_top - 0)).value;
1818                 parser_result = new Symbol(18, (parser_stack.get(parser_top - 0)).left,
1819                         (parser_stack.get(parser_top - 0)).right, pe);
1820             }
1821             return parser_result;
1822 
1823             /*. . . . . . . . . . . . . . . . . . . .*/
1824             case 62: // UnionExpr ::= PathExpr VBAR UnionExpr
1825             {
1826                 Expression pe = (Expression) (parser_stack.get(parser_top - 2)).value;
1827                 Expression rest = (Expression) (parser_stack.get(parser_top - 0)).value;
1828                 Expression result = new UnionPathExpr(pe, rest);
1829                 parser_result = new Symbol(18, (parser_stack.get(parser_top - 2)).left,
1830                         (parser_stack.get(parser_top - 0)).right, result);
1831             }
1832             return parser_result;
1833 
1834             /*. . . . . . . . . . . . . . . . . . . .*/
1835             case 63: // PathExpr ::= LocationPath
1836             {
1837                 Expression lp = (Expression) (parser_stack.get(parser_top - 0)).value;
1838                 parser_result = new Symbol(19, (parser_stack.get(parser_top - 0)).left,
1839                         (parser_stack.get(parser_top - 0)).right, lp);
1840             }
1841             return parser_result;
1842 
1843             /*. . . . . . . . . . . . . . . . . . . .*/
1844             case 64: // PathExpr ::= FilterExpr
1845             {
1846                 Expression fexp = (Expression) (parser_stack.get(parser_top - 0)).value;
1847                 parser_result = new Symbol(19, (parser_stack.get(parser_top - 0)).left,
1848                         (parser_stack.get(parser_top - 0)).right, fexp);
1849             }
1850             return parser_result;
1851 
1852             /*. . . . . . . . . . . . . . . . . . . .*/
1853             case 65: // PathExpr ::= FilterExpr SLASH RelativeLocationPath
1854             {
1855                 Expression fexp = (Expression) (parser_stack.get(parser_top - 2)).value;
1856                 Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
1857                 Expression result = new FilterParentPath(fexp, rlp);
1858                 parser_result = new Symbol(19, (parser_stack.get(parser_top - 2)).left,
1859                         (parser_stack.get(parser_top - 0)).right, result);
1860             }
1861             return parser_result;
1862 
1863             /*. . . . . . . . . . . . . . . . . . . .*/
1864             case 66: // PathExpr ::= FilterExpr DSLASH RelativeLocationPath
1865             {
1866                 Expression fexp = (Expression) (parser_stack.get(parser_top - 2)).value;
1867                 Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
1868                 //
1869                 // Expand &#39;//&#39; into &#39;/descendant-or-self::node()/&#39; or
1870                 // into /descendant-or-self::*/
1871                 //
1872                 int nodeType = DOM.NO_TYPE;
1873                 if (rlp instanceof Step
1874                         &amp;&amp; parser.isElementAxis(((Step) rlp).getAxis())) {
1875                     nodeType = DTM.ELEMENT_NODE;
1876                 }
1877                 final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
1878                 FilterParentPath fpp = new FilterParentPath(fexp, step);
1879                 fpp = new FilterParentPath(fpp, rlp);
1880                 if (fexp instanceof KeyCall == false) {
1881                     fpp.setDescendantAxis();
1882                 }
1883                 parser_result = new Symbol(19, (parser_stack.get(parser_top - 2)).left,
1884                         (parser_stack.get(parser_top - 0)).right, fpp);
1885             }
1886             return parser_result;
1887 
1888             /*. . . . . . . . . . . . . . . . . . . .*/
1889             case 67: // LocationPath ::= RelativeLocationPath
1890             {
1891                 Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
1892                 parser_result = new Symbol(4, (parser_stack.get(parser_top - 0)).left,
1893                         (parser_stack.get(parser_top - 0)).right, rlp);
1894             }
1895             return parser_result;
1896 
1897             /*. . . . . . . . . . . . . . . . . . . .*/
1898             case 68: // LocationPath ::= AbsoluteLocationPath
1899             {
1900                 Expression alp = (Expression) (parser_stack.get(parser_top - 0)).value;
1901                 parser_result = new Symbol(4, (parser_stack.get(parser_top - 0)).left,
1902                         (parser_stack.get(parser_top - 0)).right, alp);
1903             }
1904             return parser_result;
1905 
1906             /*. . . . . . . . . . . . . . . . . . . .*/
1907             case 69: // RelativeLocationPath ::= Step
1908             {
1909                 Expression step = (Expression) (parser_stack.get(parser_top - 0)).value;
1910                 parser_result = new Symbol(21, (parser_stack.get(parser_top - 0)).left,
1911                         (parser_stack.get(parser_top - 0)).right, step);
1912             }
1913             return parser_result;
1914 
1915             /*. . . . . . . . . . . . . . . . . . . .*/
1916             case 70: // RelativeLocationPath ::= RelativeLocationPath SLASH Step
1917             {
1918                 Expression result = null;
1919                 Expression rlp = (Expression) (parser_stack.get(parser_top - 2)).value;
1920                 Expression step = (Expression) (parser_stack.get(parser_top - 0)).value;
1921                 if (rlp instanceof Step &amp;&amp; ((Step) rlp).isAbbreviatedDot()) {
1922                     result = step;       // Remove &#39;./&#39; from the middle
1923                 } else if (((Step) step).isAbbreviatedDot()) {
1924                     result = rlp;        // Remove &#39;/.&#39; from the end
1925                 } else {
1926                     result
1927                             = new ParentLocationPath((RelativeLocationPath) rlp, step);
1928                 }
1929                 parser_result = new Symbol(21, (parser_stack.get(parser_top - 2)).left,
1930                         (parser_stack.get(parser_top - 0)).right, result);
1931             }
1932             return parser_result;
1933 
1934             /*. . . . . . . . . . . . . . . . . . . .*/
1935             case 71: // RelativeLocationPath ::= AbbreviatedRelativeLocationPath
1936             {
1937                 Expression arlp = (Expression) (parser_stack.get(parser_top - 0)).value;
1938                 parser_result = new Symbol(21, (parser_stack.get(parser_top - 0)).left,
1939                         (parser_stack.get(parser_top - 0)).right, arlp);
1940             }
1941             return parser_result;
1942 
1943             /*. . . . . . . . . . . . . . . . . . . .*/
1944             case 72: // AbsoluteLocationPath ::= SLASH
1945             {
1946                 Expression result = new AbsoluteLocationPath();
1947                 parser_result = new Symbol(23, (parser_stack.get(parser_top - 0)).left,
1948                         (parser_stack.get(parser_top - 0)).right, result);
1949             }
1950             return parser_result;
1951 
1952             /*. . . . . . . . . . . . . . . . . . . .*/
1953             case 73: // AbsoluteLocationPath ::= SLASH RelativeLocationPath
1954             {
1955                 Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
1956                 Expression result = new AbsoluteLocationPath(rlp);
1957                 parser_result = new Symbol(23, (parser_stack.get(parser_top - 1)).left,
1958                         (parser_stack.get(parser_top - 0)).right, result);
1959             }
1960             return parser_result;
1961 
1962             /*. . . . . . . . . . . . . . . . . . . .*/
1963             case 74: // AbsoluteLocationPath ::= AbbreviatedAbsoluteLocationPath
1964             {
1965                 Expression aalp = (Expression) (parser_stack.get(parser_top - 0)).value;
1966                 parser_result = new Symbol(23, (parser_stack.get(parser_top - 0)).left,
1967                         (parser_stack.get(parser_top - 0)).right, aalp);
1968             }
1969             return parser_result;
1970 
1971             /*. . . . . . . . . . . . . . . . . . . .*/
1972             case 75: // AbbreviatedRelativeLocationPath ::= RelativeLocationPath DSLASH Step
1973             {
1974                 Expression result = null;
1975                 Expression rlp = (Expression) (parser_stack.get(parser_top - 2)).value;
1976                 Expression step = (Expression) (parser_stack.get(parser_top - 0)).value;
1977                 final Step right = (Step) step;
1978                 final int axis = right.getAxis();
1979                 final int type = right.getNodeType();
1980                 final List&lt;Predicate&gt; predicates = right.getPredicates();
1981                 if ((axis == Axis.CHILD) &amp;&amp; (type != NodeTest.ATTRIBUTE)) {
1982                     // Compress &#39;.//child:E&#39; into &#39;descendant::E&#39; - if possible
1983                     if (predicates == null) {
1984                         right.setAxis(Axis.DESCENDANT);
1985                         if (rlp instanceof Step &amp;&amp; ((Step) rlp).isAbbreviatedDot()) {
1986                             result = right;
1987                         } else {
1988                             // Expand &#39;rlp//child::E&#39; into &#39;rlp/descendant::E&#39;
1989                             RelativeLocationPath left = (RelativeLocationPath) rlp;
1990                             result = new ParentLocationPath(left, right);
1991                         }
1992                     } else // Expand &#39;.//step&#39; -&gt; &#39;descendant-or-self::*/step&#39;
1993                     if (rlp instanceof Step &amp;&amp; ((Step) rlp).isAbbreviatedDot()) {
1994                         Step left = new Step(Axis.DESCENDANTORSELF,
1995                                 DTM.ELEMENT_NODE, null);
1996                         result = new ParentLocationPath(left, right);
1997                     } else {
1998                         // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::*/step&#39;
1999                         RelativeLocationPath left = (RelativeLocationPath) rlp;
2000                         Step mid = new Step(Axis.DESCENDANTORSELF,
2001                                 DTM.ELEMENT_NODE, null);
2002                         ParentLocationPath ppl = new ParentLocationPath(mid, right);
2003                         result = new ParentLocationPath(left, ppl);
2004                     }
2005                 } else if ((axis == Axis.ATTRIBUTE) || (type == NodeTest.ATTRIBUTE)) {
2006                     // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::*/step&#39;
2007                     RelativeLocationPath left = (RelativeLocationPath) rlp;
2008                     Step middle = new Step(Axis.DESCENDANTORSELF,
2009                             DTM.ELEMENT_NODE, null);
2010                     ParentLocationPath ppl = new ParentLocationPath(middle, right);
2011                     result = new ParentLocationPath(left, ppl);
2012                 } else {
2013                     // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::node()/step&#39;
2014                     RelativeLocationPath left = (RelativeLocationPath) rlp;
2015                     Step middle = new Step(Axis.DESCENDANTORSELF,
2016                             DOM.NO_TYPE, null);
2017                     ParentLocationPath ppl = new ParentLocationPath(middle, right);
2018                     result = new ParentLocationPath(left, ppl);
2019                 }
2020                 parser_result = new Symbol(22, (parser_stack.get(parser_top - 2)).left,
2021                         (parser_stack.get(parser_top - 0)).right, result);
2022             }
2023             return parser_result;
2024 
2025             /*. . . . . . . . . . . . . . . . . . . .*/
2026             case 76: // AbbreviatedAbsoluteLocationPath ::= DSLASH RelativeLocationPath
2027             {
2028                 Expression rlp = (Expression) (parser_stack.get(parser_top - 0)).value;
2029                 //
2030                 // Expand &#39;//&#39; into &#39;/descendant-or-self::node()/&#39; or
2031                 // into /descendant-or-self::*/
2032                 //
2033                 int nodeType = DOM.NO_TYPE;
2034                 if (rlp instanceof Step
2035                         &amp;&amp; parser.isElementAxis(((Step) rlp).getAxis())) {
2036                     nodeType = DTM.ELEMENT_NODE;
2037                 }
2038                 final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
2039                 Expression result = new AbsoluteLocationPath(parser.insertStep(step,
2040                         (RelativeLocationPath) rlp));
2041                 parser_result = new Symbol(24, (parser_stack.get(parser_top - 1)).left,
2042                         (parser_stack.get(parser_top - 0)).right, result);
2043             }
2044             return parser_result;
2045 
2046             /*. . . . . . . . . . . . . . . . . . . .*/
2047             case 77: // Step ::= NodeTest
2048             {
2049                 Expression result = null;
2050                 Object ntest = parser_stack.get(parser_top - 0).value;
2051                 if (ntest instanceof Step) {
2052                     result = (Step) ntest;
2053                 } else {
2054                     result = new Step(Axis.CHILD,
2055                             parser.findNodeType(Axis.CHILD, ntest),
2056                             null);
2057                 }
2058                 parser_result = new Symbol(7, (parser_stack.get(parser_top - 0)).left,
2059                         (parser_stack.get(parser_top - 0)).right, result);
2060             }
2061             return parser_result;
2062 
2063             /*. . . . . . . . . . . . . . . . . . . .*/
2064             case 78: // Step ::= NodeTest Predicates
2065             {
2066                 Expression result = null;
2067                 Object ntest = parser_stack.get(parser_top - 1).value;
2068                 @SuppressWarnings(&quot;unchecked&quot;)
2069                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;) (parser_stack.get(parser_top - 0)).value;
2070                 if (ntest instanceof Step) {
2071                     Step step = (Step) ntest;
2072                     step.addPredicates(pp);
2073                     result = (Step) ntest;
2074                 } else {
2075                     result = new Step(Axis.CHILD,
2076                             parser.findNodeType(Axis.CHILD, ntest), pp);
2077                 }
2078                 parser_result = new Symbol(7, (parser_stack.get(parser_top - 1)).left,
2079                         (parser_stack.get(parser_top - 0)).right, result);
2080             }
2081             return parser_result;
2082 
2083             /*. . . . . . . . . . . . . . . . . . . .*/
2084             case 79: // Step ::= AxisSpecifier NodeTest Predicates
2085             {
2086                 Integer axis = (Integer) (parser_stack.get(parser_top - 2)).value;
2087                 Object ntest = parser_stack.get(parser_top - 1).value;
2088                 @SuppressWarnings(&quot;unchecked&quot;)
2089                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;) (parser_stack.get(parser_top - 0)).value;
2090                 Expression result = new Step(axis, parser.findNodeType(axis, ntest), pp);
2091                 parser_result = new Symbol(7, (parser_stack.get(parser_top - 2)).left,
2092                         (parser_stack.get(parser_top - 0)).right, result);
2093             }
2094             return parser_result;
2095 
2096             /*. . . . . . . . . . . . . . . . . . . .*/
2097             case 80: // Step ::= AxisSpecifier NodeTest
2098             {
2099                 Integer axis = (Integer) (parser_stack.get(parser_top - 1)).value;
2100                 Object ntest = parser_stack.get(parser_top - 0).value;
2101                 Expression result = new Step(axis, parser.findNodeType(axis, ntest), null);
2102                 parser_result = new Symbol(7, (parser_stack.get(parser_top - 1)).left,
2103                         (parser_stack.get(parser_top - 0)).right, result);
2104             }
2105             return parser_result;
2106 
2107             /*. . . . . . . . . . . . . . . . . . . .*/
2108             case 81: // Step ::= AbbreviatedStep
2109             {
2110                 Expression abbrev = (Expression) (parser_stack.get(parser_top - 0)).value;
2111                 parser_result = new Symbol(7, (parser_stack.get(parser_top - 0)).left,
2112                         (parser_stack.get(parser_top - 0)).right, abbrev);
2113             }
2114             return parser_result;
2115 
2116             /*. . . . . . . . . . . . . . . . . . . .*/
2117             case 82: // AxisSpecifier ::= AxisName DCOLON
2118             {
2119                 Integer an = (Integer) (parser_stack.get(parser_top - 1)).value;
2120                 parser_result = new Symbol(41, (parser_stack.get(parser_top - 1)).left,
2121                         (parser_stack.get(parser_top - 0)).right, an);
2122             }
2123             return parser_result;
2124 
2125             /*. . . . . . . . . . . . . . . . . . . .*/
2126             case 83: // AxisSpecifier ::= ATSIGN
2127             {
2128                 Integer result = Axis.ATTRIBUTE;
2129                 parser_result = new Symbol(41, (parser_stack.get(parser_top - 0)).left,
2130                         (parser_stack.get(parser_top - 0)).right, result);
2131             }
2132             return parser_result;
2133 
2134             /*. . . . . . . . . . . . . . . . . . . .*/
2135             case 84: // AxisName ::= ANCESTOR
2136             {
2137                 Integer result = Axis.ANCESTOR;
2138                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2139                         (parser_stack.get(parser_top - 0)).right, result);
2140             }
2141             return parser_result;
2142 
2143             /*. . . . . . . . . . . . . . . . . . . .*/
2144             case 85: // AxisName ::= ANCESTORORSELF
2145             {
2146                 Integer result = Axis.ANCESTORORSELF;
2147                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2148                         (parser_stack.get(parser_top - 0)).right, result);
2149             }
2150             return parser_result;
2151 
2152             /*. . . . . . . . . . . . . . . . . . . .*/
2153             case 86: // AxisName ::= ATTRIBUTE
2154             {
2155                 Integer result = Axis.ATTRIBUTE;
2156                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2157                         (parser_stack.get(parser_top - 0)).right, result);
2158             }
2159             return parser_result;
2160 
2161             /*. . . . . . . . . . . . . . . . . . . .*/
2162             case 87: // AxisName ::= CHILD
2163             {
2164                 Integer result = Axis.CHILD;
2165                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2166                         (parser_stack.get(parser_top - 0)).right, result);
2167             }
2168             return parser_result;
2169 
2170             /*. . . . . . . . . . . . . . . . . . . .*/
2171             case 88: // AxisName ::= DESCENDANT
2172             {
2173                 Integer result = Axis.DESCENDANT;
2174                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2175                         (parser_stack.get(parser_top - 0)).right, result);
2176             }
2177             return parser_result;
2178 
2179             /*. . . . . . . . . . . . . . . . . . . .*/
2180             case 89: // AxisName ::= DESCENDANTORSELF
2181             {
2182                 Integer result = Axis.DESCENDANTORSELF;
2183                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2184                         (parser_stack.get(parser_top - 0)).right, result);
2185             }
2186             return parser_result;
2187 
2188             /*. . . . . . . . . . . . . . . . . . . .*/
2189             case 90: // AxisName ::= FOLLOWING
2190             {
2191                 Integer result = Axis.FOLLOWING;
2192                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2193                         (parser_stack.get(parser_top - 0)).right, result);
2194             }
2195             return parser_result;
2196 
2197             /*. . . . . . . . . . . . . . . . . . . .*/
2198             case 91: // AxisName ::= FOLLOWINGSIBLING
2199             {
2200                 Integer result = Axis.FOLLOWINGSIBLING;
2201                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2202                         (parser_stack.get(parser_top - 0)).right, result);
2203             }
2204             return parser_result;
2205 
2206             /*. . . . . . . . . . . . . . . . . . . .*/
2207             case 92: // AxisName ::= NAMESPACE
2208             {
2209                 Integer result = Axis.NAMESPACE;
2210                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2211                         (parser_stack.get(parser_top - 0)).right, result);
2212             }
2213             return parser_result;
2214 
2215             /*. . . . . . . . . . . . . . . . . . . .*/
2216             case 93: // AxisName ::= PARENT
2217             {
2218                 Integer result = Axis.PARENT;
2219                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2220                         (parser_stack.get(parser_top - 0)).right, result);
2221             }
2222             return parser_result;
2223 
2224             /*. . . . . . . . . . . . . . . . . . . .*/
2225             case 94: // AxisName ::= PRECEDING
2226             {
2227                 Integer result = Axis.PRECEDING;
2228                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2229                         (parser_stack.get(parser_top - 0)).right, result);
2230             }
2231             return parser_result;
2232 
2233             /*. . . . . . . . . . . . . . . . . . . .*/
2234             case 95: // AxisName ::= PRECEDINGSIBLING
2235             {
2236                 Integer result = Axis.PRECEDINGSIBLING;
2237                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2238                         (parser_stack.get(parser_top - 0)).right, result);
2239             }
2240             return parser_result;
2241 
2242             /*. . . . . . . . . . . . . . . . . . . .*/
2243             case 96: // AxisName ::= SELF
2244             {
2245                 Integer result = Axis.SELF;
2246                 parser_result = new Symbol(40, (parser_stack.get(parser_top - 0)).left,
2247                         (parser_stack.get(parser_top - 0)).right, result);
2248             }
2249             return parser_result;
2250 
2251             /*. . . . . . . . . . . . . . . . . . . .*/
2252             case 97: // AbbreviatedStep ::= DOT
2253             {
2254                 Expression result = new Step(Axis.SELF, NodeTest.ANODE, null);
2255                 parser_result = new Symbol(20, (parser_stack.get(parser_top - 0)).left,
2256                         (parser_stack.get(parser_top - 0)).right, result);
2257             }
2258             return parser_result;
2259 
2260             /*. . . . . . . . . . . . . . . . . . . .*/
2261             case 98: // AbbreviatedStep ::= DDOT
2262             {
2263                 Expression result = new Step(Axis.PARENT, NodeTest.ANODE, null);
2264                 parser_result = new Symbol(20, (parser_stack.get(parser_top - 0)).left,
2265                         (parser_stack.get(parser_top - 0)).right, result);
2266             }
2267             return parser_result;
2268 
2269             /*. . . . . . . . . . . . . . . . . . . .*/
2270             case 99: // FilterExpr ::= PrimaryExpr
2271             {
2272                 Expression primary = (Expression) (parser_stack.get(parser_top - 0)).value;
2273                 parser_result = new Symbol(6, (parser_stack.get(parser_top - 0)).left,
2274                         (parser_stack.get(parser_top - 0)).right, primary);
2275             }
2276             return parser_result;
2277 
2278             /*. . . . . . . . . . . . . . . . . . . .*/
2279             case 100: // FilterExpr ::= PrimaryExpr Predicates
2280             {
2281                 Expression primary = (Expression) (parser_stack.get(parser_top - 1)).value;
2282                 @SuppressWarnings(&quot;unchecked&quot;)
2283                 List&lt;Expression&gt; pp = (ArrayList&lt;Expression&gt;) (parser_stack.get(parser_top - 0)).value;
2284                 Expression result = new FilterExpr(primary, pp);
2285                 parser_result = new Symbol(6, (parser_stack.get(parser_top - 1)).left,
2286                         (parser_stack.get(parser_top - 0)).right, result);
2287             }
2288             return parser_result;
2289 
2290             /*. . . . . . . . . . . . . . . . . . . .*/
2291             case 101: // PrimaryExpr ::= VariableReference
2292             {
2293                 Expression vr = (Expression) (parser_stack.get(parser_top - 0)).value;
2294                 parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
2295                         (parser_stack.get(parser_top - 0)).right, vr);
2296             }
2297             return parser_result;
2298 
2299             /*. . . . . . . . . . . . . . . . . . . .*/
2300             case 102: // PrimaryExpr ::= LPAREN Expr RPAREN
2301             {
2302                 Expression ex = (Expression) (parser_stack.get(parser_top - 1)).value;
2303                 parser_result = new Symbol(17, (parser_stack.get(parser_top - 2)).left,
2304                         (parser_stack.get(parser_top - 0)).right, ex);
2305             }
2306             return parser_result;
2307 
2308             /*. . . . . . . . . . . . . . . . . . . .*/
2309             case 103: // PrimaryExpr ::= Literal
2310             {
2311                 String string = (String) (parser_stack.get(parser_top - 0)).value;
2312                 /*
2313         * If the string appears to have the syntax of a QName, store
2314         * namespace info in the literal expression. This is used for
2315         * element-available and function-available functions, among
2316         * others. Also, the default namespace must be ignored.
2317                  */
2318                 String namespace = null;
2319                 final int index = string.lastIndexOf(&#39;:&#39;);
2320                 if (index &gt; 0) {
2321                     final String prefix = string.substring(0, index);
2322                     namespace = parser._symbolTable.lookupNamespace(prefix);
2323                 }
2324                 Expression result = (namespace == null) ? new LiteralExpr(string)
2325                         : new LiteralExpr(string, namespace);
2326                 parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
2327                         (parser_stack.get(parser_top - 0)).right, result);
2328             }
2329             return parser_result;
2330 
2331             /*. . . . . . . . . . . . . . . . . . . .*/
2332             case 104: // PrimaryExpr ::= INT
2333             {
2334                 Expression result = null;
2335                 Long num = (Long) (parser_stack.get(parser_top - 0)).value;
2336                 if (num &lt; Integer.MIN_VALUE || num &gt; Integer.MAX_VALUE) {
2337                     result = new RealExpr(num);
2338                 } else if (num.doubleValue() == -0) {
2339                     result = new RealExpr(num.doubleValue());
2340                 } else if (num.intValue() == 0) {
2341                     result = new IntExpr(num.intValue());
2342                 } else if (num.doubleValue() == 0.0) {
2343                     result = new RealExpr(num.doubleValue());
2344                 } else {
2345                     result = new IntExpr(num.intValue());
2346                 }
2347                 parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
2348                         (parser_stack.get(parser_top - 0)).right, result);
2349             }
2350             return parser_result;
2351 
2352             /*. . . . . . . . . . . . . . . . . . . .*/
2353             case 105: // PrimaryExpr ::= REAL
2354             {
2355                 Double num = (Double) (parser_stack.get(parser_top - 0)).value;
2356                 Expression result = new RealExpr(num);
2357                 parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
2358                         (parser_stack.get(parser_top - 0)).right, result);
2359             }
2360             return parser_result;
2361 
2362             /*. . . . . . . . . . . . . . . . . . . .*/
2363             case 106: // PrimaryExpr ::= FunctionCall
2364             {
2365                 Expression fc = (Expression) (parser_stack.get(parser_top - 0)).value;
2366                 parser_result = new Symbol(17, (parser_stack.get(parser_top - 0)).left,
2367                         (parser_stack.get(parser_top - 0)).right, fc);
2368             }
2369             return parser_result;
2370 
2371             /*. . . . . . . . . . . . . . . . . . . .*/
2372             case 107: // VariableReference ::= DOLLAR VariableName
2373             {
2374                 Expression result = null;
2375                 QName varName = (QName) (parser_stack.get(parser_top - 0)).value;
2376                 // An empty qname prefix for a variable or parameter reference
2377                 // should map to the null namespace and not the default URI.
2378                 SyntaxTreeNode node = parser.lookupName(varName);
2379                 if (node != null) {
2380                     if (node instanceof Variable) {
2381                         result = new VariableRef((Variable) node);
2382                     } else if (node instanceof Param) {
2383                         result = new ParameterRef((Param) node);
2384                     } else {
2385                         result = new UnresolvedRef(varName);
2386                     }
2387                 }
2388                 if (node == null) {
2389                     result = new UnresolvedRef(varName);
2390                 }
2391                 parser_result = new Symbol(15, (parser_stack.get(parser_top - 1)).left,
2392                         (parser_stack.get(parser_top - 0)).right, result);
2393             }
2394             return parser_result;
2395 
2396             /*. . . . . . . . . . . . . . . . . . . .*/
2397             case 108: // FunctionCall ::= FunctionName LPAREN RPAREN
2398             {
2399                 Expression result = null;
2400                 QName fname = (QName) (parser_stack.get(parser_top - 2)).value;
2401                 if (fname == parser.getQNameIgnoreDefaultNs(&quot;current&quot;)) {
2402                     result = new CurrentCall(fname);
2403                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;number&quot;)) {
2404                     result = new NumberCall(fname, XPathParser.EmptyArgs);
2405                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string&quot;)) {
2406                     result = new StringCall(fname, XPathParser.EmptyArgs);
2407                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;concat&quot;)) {
2408                     result = new ConcatCall(fname, XPathParser.EmptyArgs);
2409                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;true&quot;)) {
2410                     result = new BooleanExpr(true);
2411                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;false&quot;)) {
2412                     result = new BooleanExpr(false);
2413                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;name&quot;)) {
2414                     result = new NameCall(fname);
2415                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;generate-id&quot;)) {
2416                     result = new GenerateIdCall(fname, XPathParser.EmptyArgs);
2417                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string-length&quot;)) {
2418                     result = new StringLengthCall(fname, XPathParser.EmptyArgs);
2419                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;position&quot;)) {
2420                     result = new PositionCall(fname);
2421                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;last&quot;)) {
2422                     result = new LastCall(fname);
2423                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;local-name&quot;)) {
2424                     result = new LocalNameCall(fname);
2425                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;)) {
2426                     result = new NamespaceUriCall(fname);
2427                 } else {
2428                     result = new FunctionCall(fname, XPathParser.EmptyArgs);
2429                 }
2430                 parser_result = new Symbol(16, (parser_stack.get(parser_top - 2)).left,
2431                         (parser_stack.get(parser_top - 0)).right, result);
2432             }
2433             return parser_result;
2434 
2435             /*. . . . . . . . . . . . . . . . . . . .*/
2436             case 109: // FunctionCall ::= FunctionName LPAREN NonemptyArgumentList RPAREN
2437             {
2438                 Expression result = null;
2439                 QName fname = (QName) (parser_stack.get(parser_top - 3)).value;
2440                 @SuppressWarnings(&quot;unchecked&quot;)
2441                 List&lt;Expression&gt; argl = (ArrayList&lt;Expression&gt;) (parser_stack.get(parser_top - 1)).value;
2442                 if (fname == parser.getQNameIgnoreDefaultNs(&quot;concat&quot;)) {
2443                     result = new ConcatCall(fname, argl);
2444                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;number&quot;)) {
2445                     result = new NumberCall(fname, argl);
2446                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;document&quot;)) {
2447                     parser.setMultiDocument(true);
2448                     result = new DocumentCall(fname, argl);
2449                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string&quot;)) {
2450                     result = new StringCall(fname, argl);
2451                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;boolean&quot;)) {
2452                     result = new BooleanCall(fname, argl);
2453                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;name&quot;)) {
2454                     result = new NameCall(fname, argl);
2455                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;generate-id&quot;)) {
2456                     result = new GenerateIdCall(fname, argl);
2457                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;not&quot;)) {
2458                     result = new NotCall(fname, argl);
2459                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;format-number&quot;)) {
2460                     result = new FormatNumberCall(fname, argl);
2461                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;unparsed-entity-uri&quot;)) {
2462                     result = new UnparsedEntityUriCall(fname, argl);
2463                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;key&quot;)) {
2464                     result = new KeyCall(fname, argl);
2465                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;id&quot;)) {
2466                     result = new KeyCall(fname, argl);
2467                     parser.setHasIdCall(true);
2468                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;ceiling&quot;)) {
2469                     result = new CeilingCall(fname, argl);
2470                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;round&quot;)) {
2471                     result = new RoundCall(fname, argl);
2472                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;floor&quot;)) {
2473                     result = new FloorCall(fname, argl);
2474                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;contains&quot;)) {
2475                     result = new ContainsCall(fname, argl);
2476                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string-length&quot;)) {
2477                     result = new StringLengthCall(fname, argl);
2478                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;starts-with&quot;)) {
2479                     result = new StartsWithCall(fname, argl);
2480                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;function-available&quot;)) {
2481                     result = new FunctionAvailableCall(fname, argl);
2482                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;element-available&quot;)) {
2483                     result = new ElementAvailableCall(fname, argl);
2484                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;local-name&quot;)) {
2485                     result = new LocalNameCall(fname, argl);
2486                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;lang&quot;)) {
2487                     result = new LangCall(fname, argl);
2488                 } else if (fname == parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;)) {
2489                     result = new NamespaceUriCall(fname, argl);
2490                 } else if (fname == parser.getQName(Constants.TRANSLET_URI, &quot;xsltc&quot;, &quot;cast&quot;)) {
2491                     result = new CastCall(fname, argl);
2492                 } // Special case for extension function nodeset()
2493                 else if (fname.getLocalPart().equals(&quot;nodeset&quot;) || fname.getLocalPart().equals(&quot;node-set&quot;)) {
2494                     parser.setCallsNodeset(true);  // implies MultiDOM
2495                     result = new FunctionCall(fname, argl);
2496                 } else {
2497                     result = new FunctionCall(fname, argl);
2498                 }
2499                 parser_result = new Symbol(16, (parser_stack.get(parser_top - 3)).left,
2500                         (parser_stack.get(parser_top - 0)).right, result);
2501             }
2502             return parser_result;
2503 
2504             /*. . . . . . . . . . . . . . . . . . . .*/
2505             case 110: // NonemptyArgumentList ::= Argument
2506             {
2507                 Expression arg = (Expression) (parser_stack.get(parser_top - 0)).value;
2508                 List&lt;Expression&gt; temp = new ArrayList&lt;&gt;();
2509                 temp.add(arg);
2510                 parser_result = new Symbol(36, (parser_stack.get(parser_top - 0)).left,
2511                         (parser_stack.get(parser_top - 0)).right, temp);
2512             }
2513             return parser_result;
2514 
2515             /*. . . . . . . . . . . . . . . . . . . .*/
2516             case 111: // NonemptyArgumentList ::= Argument COMMA NonemptyArgumentList
2517             {
2518                 Expression arg = (Expression) (parser_stack.get(parser_top - 2)).value;
2519                 @SuppressWarnings(&quot;unchecked&quot;)
2520                 List&lt;Expression&gt; argl = (ArrayList&lt;Expression&gt;) (parser_stack.get(parser_top - 0)).value;
2521                 argl.add(0, arg);
2522                 parser_result = new Symbol(36, (parser_stack.get(parser_top - 2)).left,
2523                         (parser_stack.get(parser_top - 0)).right, argl);
2524             }
2525             return parser_result;
2526 
2527             /*. . . . . . . . . . . . . . . . . . . .*/
2528             case 112: // FunctionName ::= QName
2529             {
2530                 QName fname = (QName) (parser_stack.get(parser_top - 0)).value;
2531                 parser_result = new Symbol(38, (parser_stack.get(parser_top - 0)).left,
2532                         (parser_stack.get(parser_top - 0)).right, fname);
2533             }
2534             return parser_result;
2535 
2536             /*. . . . . . . . . . . . . . . . . . . .*/
2537             case 113: // VariableName ::= QName
2538             {
2539                 QName vname = (QName) (parser_stack.get(parser_top - 0)).value;
2540                 parser_result = new Symbol(39, (parser_stack.get(parser_top - 0)).left,
2541                         (parser_stack.get(parser_top - 0)).right, vname);
2542             }
2543             return parser_result;
2544 
2545             /*. . . . . . . . . . . . . . . . . . . .*/
2546             case 114: // Argument ::= Expr
2547             {
2548                 Expression ex = (Expression) (parser_stack.get(parser_top - 0)).value;
2549                 parser_result = new Symbol(3, (parser_stack.get(parser_top - 0)).left,
2550                         (parser_stack.get(parser_top - 0)).right, ex);
2551             }
2552             return parser_result;
2553 
2554             /*. . . . . . . . . . . . . . . . . . . .*/
2555             case 115: // NodeTest ::= NameTest
2556             {
2557                 Object nt = parser_stack.get(parser_top - 0).value;
2558                 parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
2559                         (parser_stack.get(parser_top - 0)).right, nt);
2560             }
2561             return parser_result;
2562 
2563             /*. . . . . . . . . . . . . . . . . . . .*/
2564             case 116: // NodeTest ::= NODE
2565             {
2566                 Object result = NodeTest.ANODE;
2567                 parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
2568                         (parser_stack.get(parser_top - 0)).right, result);
2569             }
2570             return parser_result;
2571 
2572             /*. . . . . . . . . . . . . . . . . . . .*/
2573             case 117: // NodeTest ::= TEXT
2574             {
2575                 Object result = NodeTest.TEXT;
2576                 parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
2577                         (parser_stack.get(parser_top - 0)).right, result);
2578             }
2579             return parser_result;
2580 
2581             /*. . . . . . . . . . . . . . . . . . . .*/
2582             case 118: // NodeTest ::= COMMENT
2583             {
2584                 Object result = NodeTest.COMMENT;
2585                 parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
2586                         (parser_stack.get(parser_top - 0)).right, result);
2587             }
2588             return parser_result;
2589 
2590             /*. . . . . . . . . . . . . . . . . . . .*/
2591             case 119: // NodeTest ::= PIPARAM LPAREN Literal RPAREN
2592             {
2593                 String l = (String) (parser_stack.get(parser_top - 1)).value;
2594                 QName name = parser.getQNameIgnoreDefaultNs(&quot;name&quot;);
2595                 Expression exp = new EqualityExpr(Operators.EQ,
2596                         new NameCall(name),
2597                         new LiteralExpr(l));
2598                 List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();
2599                 predicates.add(new Predicate(exp));
2600                 Object result = new Step(Axis.CHILD, NodeTest.PI, predicates);
2601                 parser_result = new Symbol(25, (parser_stack.get(parser_top - 3)).left,
2602                         (parser_stack.get(parser_top - 0)).right, result);
2603             }
2604             return parser_result;
2605 
2606             /*. . . . . . . . . . . . . . . . . . . .*/
2607             case 120: // NodeTest ::= PI
2608             {
2609                 Object result = NodeTest.PI;
2610                 parser_result = new Symbol(25, (parser_stack.get(parser_top - 0)).left,
2611                         (parser_stack.get(parser_top - 0)).right, result);
2612             }
2613             return parser_result;
2614 
2615             /*. . . . . . . . . . . . . . . . . . . .*/
2616             case 121: // NameTest ::= STAR
2617             {
2618                 Object result = null;
2619                 parser_result = new Symbol(26, (parser_stack.get(parser_top - 0)).left,
2620                         (parser_stack.get(parser_top - 0)).right, result);
2621             }
2622             return parser_result;
2623 
2624             /*. . . . . . . . . . . . . . . . . . . .*/
2625             case 122: // NameTest ::= QName
2626             {
2627                 QName qn = (QName) (parser_stack.get(parser_top - 0)).value;
2628                 parser_result = new Symbol(26, (parser_stack.get(parser_top - 0)).left,
2629                         (parser_stack.get(parser_top - 0)).right, qn);
2630             }
2631             return parser_result;
2632 
2633             /*. . . . . . . . . . . . . . . . . . . .*/
2634             case 123: // QName ::= QNAME
2635             {
2636                 String qname = (String) (parser_stack.get(parser_top - 0)).value;
2637                 QName result = parser.getQNameIgnoreDefaultNs(qname);
2638                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2639                         (parser_stack.get(parser_top - 0)).right, result);
2640             }
2641             return parser_result;
2642 
2643             /*. . . . . . . . . . . . . . . . . . . .*/
2644             case 124: // QName ::= DIV
2645             {
2646                 QName result = parser.getQNameIgnoreDefaultNs(&quot;div&quot;);
2647                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2648                         (parser_stack.get(parser_top - 0)).right, result);
2649             }
2650             return parser_result;
2651 
2652             /*. . . . . . . . . . . . . . . . . . . .*/
2653             case 125: // QName ::= MOD
2654             {
2655                 QName result = parser.getQNameIgnoreDefaultNs(&quot;mod&quot;);
2656                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2657                         (parser_stack.get(parser_top - 0)).right, result);
2658             }
2659             return parser_result;
2660 
2661             /*. . . . . . . . . . . . . . . . . . . .*/
2662             case 126: // QName ::= KEY
2663             {
2664                 QName result = parser.getQNameIgnoreDefaultNs(&quot;key&quot;);
2665                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2666                         (parser_stack.get(parser_top - 0)).right, result);
2667             }
2668             return parser_result;
2669 
2670             /*. . . . . . . . . . . . . . . . . . . .*/
2671             case 127: // QName ::= ANCESTOR
2672             {
2673                 QName result = parser.getQNameIgnoreDefaultNs(&quot;child&quot;);
2674                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2675                         (parser_stack.get(parser_top - 0)).right, result);
2676             }
2677             return parser_result;
2678 
2679             /*. . . . . . . . . . . . . . . . . . . .*/
2680             case 128: // QName ::= ANCESTORORSELF
2681             {
2682                 QName result = parser.getQNameIgnoreDefaultNs(&quot;ancestor-or-self&quot;);
2683                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2684                         (parser_stack.get(parser_top - 0)).right, result);
2685             }
2686             return parser_result;
2687 
2688             /*. . . . . . . . . . . . . . . . . . . .*/
2689             case 129: // QName ::= ATTRIBUTE
2690             {
2691                 QName result = parser.getQNameIgnoreDefaultNs(&quot;attribute&quot;);
2692                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2693                         (parser_stack.get(parser_top - 0)).right, result);
2694             }
2695             return parser_result;
2696 
2697             /*. . . . . . . . . . . . . . . . . . . .*/
2698             case 130: // QName ::= CHILD
2699             {
2700                 QName result = parser.getQNameIgnoreDefaultNs(&quot;child&quot;);
2701                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2702                         (parser_stack.get(parser_top - 0)).right, result);
2703             }
2704             return parser_result;
2705 
2706             /*. . . . . . . . . . . . . . . . . . . .*/
2707             case 131: // QName ::= DESCENDANT
2708             {
2709                 QName result = parser.getQNameIgnoreDefaultNs(&quot;decendant&quot;);
2710                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2711                         (parser_stack.get(parser_top - 0)).right, result);
2712             }
2713             return parser_result;
2714 
2715             /*. . . . . . . . . . . . . . . . . . . .*/
2716             case 132: // QName ::= DESCENDANTORSELF
2717             {
2718                 QName result = parser.getQNameIgnoreDefaultNs(&quot;decendant-or-self&quot;);
2719                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2720                         (parser_stack.get(parser_top - 0)).right, result);
2721             }
2722             return parser_result;
2723 
2724             /*. . . . . . . . . . . . . . . . . . . .*/
2725             case 133: // QName ::= FOLLOWING
2726             {
2727                 QName result = parser.getQNameIgnoreDefaultNs(&quot;following&quot;);
2728                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2729                         (parser_stack.get(parser_top - 0)).right, result);
2730             }
2731             return parser_result;
2732 
2733             /*. . . . . . . . . . . . . . . . . . . .*/
2734             case 134: // QName ::= FOLLOWINGSIBLING
2735             {
2736                 QName result = parser.getQNameIgnoreDefaultNs(&quot;following-sibling&quot;);
2737                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2738                         (parser_stack.get(parser_top - 0)).right, result);
2739             }
2740             return parser_result;
2741 
2742             /*. . . . . . . . . . . . . . . . . . . .*/
2743             case 135: // QName ::= NAMESPACE
2744             {
2745                 QName result = parser.getQNameIgnoreDefaultNs(&quot;namespace&quot;);
2746                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2747                         (parser_stack.get(parser_top - 0)).right, result);
2748             }
2749             return parser_result;
2750 
2751             /*. . . . . . . . . . . . . . . . . . . .*/
2752             case 136: // QName ::= PARENT
2753             {
2754                 QName result = parser.getQNameIgnoreDefaultNs(&quot;parent&quot;);
2755                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2756                         (parser_stack.get(parser_top - 0)).right, result);
2757             }
2758             return parser_result;
2759 
2760             /*. . . . . . . . . . . . . . . . . . . .*/
2761             case 137: // QName ::= PRECEDING
2762             {
2763                 QName result = parser.getQNameIgnoreDefaultNs(&quot;preceding&quot;);
2764                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2765                         (parser_stack.get(parser_top - 0)).right, result);
2766             }
2767             return parser_result;
2768 
2769             /*. . . . . . . . . . . . . . . . . . . .*/
2770             case 138: // QName ::= PRECEDINGSIBLING
2771             {
2772                 QName result = parser.getQNameIgnoreDefaultNs(&quot;preceding-sibling&quot;);
2773                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2774                         (parser_stack.get(parser_top - 0)).right, result);
2775             }
2776             return parser_result;
2777 
2778             /*. . . . . . . . . . . . . . . . . . . .*/
2779             case 139: // QName ::= SELF
2780             {
2781                 QName result = parser.getQNameIgnoreDefaultNs(&quot;self&quot;);
2782                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2783                         (parser_stack.get(parser_top - 0)).right, result);
2784             }
2785             return parser_result;
2786 
2787             /*. . . . . . . . . . . . . . . . . . . .*/
2788             case 140: // QName ::= ID
2789             {
2790                 QName result = parser.getQNameIgnoreDefaultNs(&quot;id&quot;);
2791                 parser_result = new Symbol(37, (parser_stack.get(parser_top - 0)).left,
2792                         (parser_stack.get(parser_top - 0)).right, result);
2793             }
2794             return parser_result;
2795 
2796             /* . . . . . .*/
2797             default:
2798                 throw new Exception(
2799                         &quot;Invalid action number found in internal parse table&quot;);
2800 
2801         }
2802     }
2803 }
    </pre>
  </body>
</html>
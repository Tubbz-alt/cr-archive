diff a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/NodeImpl.java b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/NodeImpl.java
--- a/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/NodeImpl.java
+++ b/src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/NodeImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  */
  /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -25,10 +25,11 @@
 import java.io.Serializable;
 import java.util.Map;
 import org.w3c.dom.DOMException;
 import org.w3c.dom.Document;
 import org.w3c.dom.DocumentType;
+import org.w3c.dom.Element;
 import org.w3c.dom.NamedNodeMap;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.w3c.dom.UserDataHandler;
 import org.w3c.dom.events.Event;
@@ -76,10 +77,11 @@
  * @xerces.internal
  *
  * @author Arnaud  Le Hors, IBM
  * @author Joe Kesselman, IBM
  * @since  PR-DOM-Level-1-19980818.
+ * @LastModified: Apr 2019
  */
 public abstract class NodeImpl
     implements Node, NodeList, EventTarget, Cloneable, Serializable{
 
     //
@@ -120,19 +122,10 @@
      * The two nodes are disconnected, they do not have any common ancestor.
      * This is the case of two nodes that are not in the same document.
      */
     public static final short TREE_POSITION_DISCONNECTED = 0x00;
 
-
-    // DocumentPosition
-    public static final short DOCUMENT_POSITION_DISCONNECTED = 0x01;
-    public static final short DOCUMENT_POSITION_PRECEDING = 0x02;
-    public static final short DOCUMENT_POSITION_FOLLOWING = 0x04;
-    public static final short DOCUMENT_POSITION_CONTAINS = 0x08;
-    public static final short DOCUMENT_POSITION_IS_CONTAINED = 0x10;
-    public static final short DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;
-
     /** Serialization version. */
     static final long serialVersionUID = -6316591992167219696L;
 
     // public
 
@@ -322,11 +315,11 @@
 
     /**
      * NON-DOM
      * set the ownerDocument of this node
      */
-    void setOwnerDocument(CoreDocumentImpl doc) {
+    protected void setOwnerDocument(CoreDocumentImpl doc) {
         if (needsSyncData()) {
             synchronizeData();
         }
         // if we have an owner we rely on it to have it right
         // otherwise ownerNode is our ownerDocument
@@ -557,11 +550,11 @@
      * <P>
      * By default we do not have any children, ParentNode overrides this.
      * @see ParentNode
      *
      * @return org.w3c.dom.Node
-     * @param Index int
+     * @param index int
      */
     public Node item(int index) {
         return null;
     }
 
@@ -974,13 +967,11 @@
         // If the nodes are the same, no flags should be set
         if (this==other)
           return 0;
 
         // check if other is from a different implementation
-        try {
-            NodeImpl node = (NodeImpl) other;
-        } catch (ClassCastException e) {
+        if (other != null && !(other instanceof NodeImpl)) {
             // other comes from a different implementation
             String msg = DOMMessageFormatter.formatMessage(
                DOMMessageFormatter.DOM_DOMAIN, "NOT_SUPPORTED_ERR", null);
             throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
         }
@@ -1039,11 +1030,11 @@
 
         for (node=other; node!=null; node=node.getParentNode()) {
             otherDepth +=1;
             if (node == this)
               // The other node is a descendent of the reference node.
-              return (DOCUMENT_POSITION_IS_CONTAINED |
+              return (DOCUMENT_POSITION_CONTAINED_BY |
                       DOCUMENT_POSITION_FOLLOWING);
             otherAncestor = node;
         }
 
 
@@ -1129,19 +1120,19 @@
         }
         switch (otherAncestorType) {
           case Node.NOTATION_NODE:
           case Node.ENTITY_NODE: {
           DocumentType container = thisOwnerDoc.getDoctype();
-            if (container == this) return (DOCUMENT_POSITION_IS_CONTAINED |
+            if (container == this) return (DOCUMENT_POSITION_CONTAINED_BY |
                                           DOCUMENT_POSITION_FOLLOWING);
             otherNode = otherAncestor = thisOwnerDoc;
             break;
           }
           case Node.DOCUMENT_TYPE_NODE: {
             if (thisNode == otherOwnerDoc)
               return (DOCUMENT_POSITION_FOLLOWING |
-                      DOCUMENT_POSITION_IS_CONTAINED);
+                      DOCUMENT_POSITION_CONTAINED_BY);
             else if (otherOwnerDoc!=null && thisOwnerDoc==otherOwnerDoc)
               return (DOCUMENT_POSITION_PRECEDING);
             break;
           }
           case Node.ATTRIBUTE_NODE: {
@@ -1151,11 +1142,11 @@
                 otherDepth +=1;
                 if (node == thisNode)
                   // The other node is a descendent of the reference
                   // node's element
                   return DOCUMENT_POSITION_FOLLOWING |
-                         DOCUMENT_POSITION_IS_CONTAINED;
+                         DOCUMENT_POSITION_CONTAINED_BY;
                 otherAncestor = node;
             }
 
           }
         }
@@ -1300,12 +1291,12 @@
      */
     public String getTextContent() throws DOMException {
         return getNodeValue();  // overriden in some subclasses
     }
 
-    // internal method taking a StringBuffer in parameter
-    void getTextContent(StringBuffer buf) throws DOMException {
+    // internal method taking a StringBuilder in parameter
+    void getTextContent(StringBuilder buf) throws DOMException {
         String content = getNodeValue();
         if (content != null) {
             buf.append(content);
         }
     }
@@ -1423,11 +1414,15 @@
                 return ancestor.isDefaultNamespace(namespaceURI);
             }
             return false;
         }
         case Node.DOCUMENT_NODE:{
-                return((NodeImpl)((Document)this).getDocumentElement()).isDefaultNamespace(namespaceURI);
+                Element docElement = ((Document)this).getDocumentElement();
+                if (docElement != null) {
+                    return docElement.isDefaultNamespace(namespaceURI);
+                }
+                return false;
             }
 
         case Node.ENTITY_NODE :
         case Node.NOTATION_NODE:
         case Node.DOCUMENT_FRAGMENT_NODE:
@@ -1473,16 +1468,19 @@
 
         short type = this.getNodeType();
 
         switch (type) {
         case Node.ELEMENT_NODE: {
-
-                String namespace = this.getNamespaceURI(); // to flip out children
+                this.getNamespaceURI(); // to flip out children
                 return lookupNamespacePrefix(namespaceURI, (ElementImpl)this);
             }
         case Node.DOCUMENT_NODE:{
-                return((NodeImpl)((Document)this).getDocumentElement()).lookupPrefix(namespaceURI);
+                Element docElement = ((Document)this).getDocumentElement();
+                if (docElement != null) {
+                    return docElement.lookupPrefix(namespaceURI);
+                }
+                return null;
             }
 
         case Node.ENTITY_NODE :
         case Node.NOTATION_NODE:
         case Node.DOCUMENT_FRAGMENT_NODE:
@@ -1509,12 +1507,12 @@
     /**
      * DOM Level 3 - Experimental:
      * Look up the namespace URI associated to the given prefix, starting from this node.
      * Use lookupNamespaceURI(null) to lookup the default namespace
      *
-     * @param namespaceURI
-     * @return th URI for the namespace
+     * @param specifiedPrefix
+     * @return the URI for the namespace
      * @since DOM Level 3
      */
     public String lookupNamespaceURI(String specifiedPrefix) {
         short type = this.getNodeType();
         switch (type) {
@@ -1535,24 +1533,24 @@
                 if (this.hasAttributes()) {
                     NamedNodeMap map = this.getAttributes();
                     int length = map.getLength();
                     for (int i=0;i<length;i++) {
                         Node attr = map.item(i);
-                        String attrPrefix = attr.getPrefix();
-                        String value = attr.getNodeValue();
                         namespace = attr.getNamespaceURI();
                         if (namespace !=null && namespace.equals("http://www.w3.org/2000/xmlns/")) {
+                            String attrPrefix = attr.getPrefix();
+                            String value = attr.getNodeValue();
                             // at this point we are dealing with DOM Level 2 nodes only
                             if (specifiedPrefix == null &&
                                 attr.getNodeName().equals("xmlns")) {
                                 // default namespace
-                                return value;
+                                return value.length() > 0 ? value : null;
                             } else if (attrPrefix !=null &&
                                        attrPrefix.equals("xmlns") &&
                                        attr.getLocalName().equals(specifiedPrefix)) {
                                 // non default namespace
-                                return value;
+                                return value.length() > 0 ? value : null;
                             }
                         }
                     }
                 }
                 NodeImpl ancestor = (NodeImpl)getElementAncestor(this);
@@ -1563,11 +1561,15 @@
                 return null;
 
 
             }
         case Node.DOCUMENT_NODE : {
-                return((NodeImpl)((Document)this).getDocumentElement()).lookupNamespaceURI(specifiedPrefix);
+                Element docElement = ((Document)this).getDocumentElement();
+                if (docElement != null) {
+                    return docElement.lookupNamespaceURI(specifiedPrefix);
+                }
+                return null;
             }
         case Node.ENTITY_NODE :
         case Node.NOTATION_NODE:
         case Node.DOCUMENT_FRAGMENT_NODE:
         case Node.DOCUMENT_TYPE_NODE:
@@ -1589,19 +1591,18 @@
             }
 
         }
     }
 
-
-    Node getElementAncestor (Node currentNode){
+    Node getElementAncestor(Node currentNode) {
         Node parent = currentNode.getParentNode();
-        if (parent != null) {
+        while (parent != null) {
             short type = parent.getNodeType();
             if (type == Node.ELEMENT_NODE) {
                 return parent;
             }
-            return getElementAncestor(parent);
+            parent = parent.getParentNode();
         }
         return null;
     }
 
     String lookupNamespacePrefix(String namespaceURI, ElementImpl el){
@@ -1622,14 +1623,14 @@
         if (this.hasAttributes()) {
             NamedNodeMap map = this.getAttributes();
             int length = map.getLength();
             for (int i=0;i<length;i++) {
                 Node attr = map.item(i);
-                String attrPrefix = attr.getPrefix();
-                String value = attr.getNodeValue();
                 namespace = attr.getNamespaceURI();
                 if (namespace !=null && namespace.equals("http://www.w3.org/2000/xmlns/")) {
+                    String attrPrefix = attr.getPrefix();
+                    String value = attr.getNodeValue();
                     // DOM Level 2 nodes
                     if (((attr.getNodeName().equals("xmlns")) ||
                          (attrPrefix !=null && attrPrefix.equals("xmlns")) &&
                          value.equals(namespaceURI))) {
 
@@ -1685,13 +1686,10 @@
      * attribute for <code>Attr</code> nodes, the
      * <code>isWhitespaceInElementContent</code> attribute for
      * <code>Text</code> nodes, as well as any user data or event listeners
      * registered on the nodes.
      * @param arg The node to compare equality with.
-     * @param deep If <code>true</code>, recursively compare the subtrees; if
-     *   <code>false</code>, compare only the nodes themselves (and its
-     *   attributes, if it is an <code>Element</code>).
      * @return If the nodes, and possibly subtrees are equal,
      *   <code>true</code> otherwise <code>false</code>.
      * @since DOM Level 3
      */
     public boolean isEqualNode(Node arg) {

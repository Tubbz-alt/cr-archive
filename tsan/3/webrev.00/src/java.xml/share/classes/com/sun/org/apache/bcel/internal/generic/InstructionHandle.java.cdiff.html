<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionHandle.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstructionFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionList.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/InstructionHandle.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,20 ***</span>
  /**
   * Instances of this class give users a handle to the instructions contained in
   * an InstructionList. Instruction objects may be used more than once within a
   * list, this is useful because it saves memory and may be much faster.
   *
<span class="line-modified">!  * Within an InstructionList an InstructionHandle object is wrapped around all</span>
<span class="line-modified">!  * instructions, i.e., it implements a cell in a doubly-linked list. From the</span>
<span class="line-modified">!  * outside only the next and the previous instruction (handle) are accessible.</span>
<span class="line-modified">!  * One can traverse the list via an Enumeration returned by</span>
   * InstructionList.elements().
   *
<span class="line-removed">-  * @version $Id: InstructionHandle.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   * @see Instruction
   * @see BranchHandle
   * @see InstructionList
   */
  public class InstructionHandle {
  
      private InstructionHandle next;
      private InstructionHandle prev;
<span class="line-new-header">--- 30,21 ---</span>
  /**
   * Instances of this class give users a handle to the instructions contained in
   * an InstructionList. Instruction objects may be used more than once within a
   * list, this is useful because it saves memory and may be much faster.
   *
<span class="line-modified">!  * Within an InstructionList an InstructionHandle object is wrapped</span>
<span class="line-modified">!  * around all instructions, i.e., it implements a cell in a</span>
<span class="line-modified">!  * doubly-linked list. From the outside only the next and the</span>
<span class="line-modified">!  * previous instruction (handle) are accessible. One</span>
<span class="line-added">+  * can traverse the list via an Enumeration returned by</span>
   * InstructionList.elements().
   *
   * @see Instruction
   * @see BranchHandle
   * @see InstructionList
<span class="line-added">+  * @LastModified: Jan 2020</span>
   */
  public class InstructionHandle {
  
      private InstructionHandle next;
      private InstructionHandle prev;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 52,27 ***</span>
      private int i_position = -1; // byte code offset of instruction
  
      private Set&lt;InstructionTargeter&gt; targeters;
      private Map&lt;Object, Object&gt; attributes;
  
      public final InstructionHandle getNext() {
          return next;
      }
  
      public final InstructionHandle getPrev() {
          return prev;
      }
  
      public final Instruction getInstruction() {
          return instruction;
      }
  
      /**
<span class="line-modified">!      * Replace current instruction contained in this handle. Old instruction is</span>
<span class="line-modified">!      * disposed using Instruction.dispose().</span>
       */
<span class="line-modified">!     public void setInstruction(final Instruction i) { // Overridden in BranchHandle TODO could be package-protected?</span>
          if (i == null) {
              throw new ClassGenException(&quot;Assigning null to handle&quot;);
          }
          if ((this.getClass() != BranchHandle.class) &amp;&amp; (i instanceof BranchInstruction)) {
              throw new ClassGenException(&quot;Assigning branch instruction &quot; + i + &quot; to plain handle&quot;);
<span class="line-new-header">--- 53,41 ---</span>
      private int i_position = -1; // byte code offset of instruction
  
      private Set&lt;InstructionTargeter&gt; targeters;
      private Map&lt;Object, Object&gt; attributes;
  
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Does nothing.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @deprecated Does nothing as of 6.3.1.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     protected void addHandle() {</span>
<span class="line-added">+         // noop</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public final InstructionHandle getNext() {
          return next;
      }
  
<span class="line-added">+ </span>
      public final InstructionHandle getPrev() {
          return prev;
      }
  
<span class="line-added">+ </span>
      public final Instruction getInstruction() {
          return instruction;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Replace current instruction contained in this handle.</span>
<span class="line-modified">!      * Old instruction is disposed using Instruction.dispose().</span>
       */
<span class="line-modified">!     public void setInstruction( final Instruction i ) { // Overridden in BranchHandle TODO could be package-protected?</span>
          if (i == null) {
              throw new ClassGenException(&quot;Assigning null to handle&quot;);
          }
          if ((this.getClass() != BranchHandle.class) &amp;&amp; (i instanceof BranchInstruction)) {
              throw new ClassGenException(&quot;Assigning branch instruction &quot; + i + &quot; to plain handle&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,139 ***</span>
              instruction.dispose();
          }
          instruction = i;
      }
  
      /**
<span class="line-modified">!      * Temporarily swap the current instruction, without disturbing anything.</span>
<span class="line-modified">!      * Meant to be used by a debugger, implementing breakpoints. Current</span>
<span class="line-modified">!      * instruction is returned.</span>
       * &lt;p&gt;
       * Warning: if this is used on a BranchHandle then some methods such as
<span class="line-modified">!      * getPosition() will still refer to the original cached instruction,</span>
<span class="line-modified">!      * whereas other BH methods may affect the cache and the replacement</span>
<span class="line-removed">-      * instruction.</span>
       */
      // See BCEL-273
      // TODO remove this method in any redesign of BCEL
<span class="line-modified">!     public Instruction swapInstruction(final Instruction i) {</span>
          final Instruction oldInstruction = instruction;
          instruction = i;
          return oldInstruction;
      }
  
  
<span class="line-modified">!     /*private*/</span>
<span class="line-removed">-     protected InstructionHandle(final Instruction i) {</span>
          setInstruction(i);
      }
  
<span class="line-modified">!     private static InstructionHandle ih_list = null; // List of reusable handles</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Factory method.</span>
       */
<span class="line-modified">!     static InstructionHandle getInstructionHandle(final Instruction i) {</span>
<span class="line-modified">!         if (ih_list == null) {</span>
<span class="line-removed">-             return new InstructionHandle(i);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         final InstructionHandle ih = ih_list;</span>
<span class="line-removed">-         ih_list = ih.next;</span>
<span class="line-removed">-         ih.setInstruction(i);</span>
<span class="line-removed">-         return ih;</span>
      }
  
      /**
<span class="line-modified">!      * Called by InstructionList.setPositions when setting the position for</span>
<span class="line-modified">!      * every instruction. In the presence of variable length instructions</span>
<span class="line-modified">!      * `setPositions()&#39; performs multiple passes over the instruction list to</span>
<span class="line-modified">!      * calculate the correct (byte) positions and offsets by calling this</span>
<span class="line-removed">-      * function.</span>
       *
<span class="line-modified">!      * @param offset additional offset caused by preceding (variable length)</span>
<span class="line-modified">!      * instructions</span>
<span class="line-modified">!      * @param max_offset the maximum offset that may be caused by these</span>
<span class="line-removed">-      * instructions</span>
<span class="line-removed">-      * @return additional offset caused by possible change of this instruction&#39;s</span>
<span class="line-removed">-      * length</span>
       */
<span class="line-modified">!     protected int updatePosition(final int offset, final int max_offset) {</span>
          i_position += offset;
          return 0;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return the position, i.e., the byte code offset of the contained</span>
<span class="line-modified">!      * instruction. This is accurate only after InstructionList.setPositions()</span>
<span class="line-modified">!      * has been called.</span>
       */
      public int getPosition() {
          return i_position;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Set the position, i.e., the byte code offset of the contained</span>
       * instruction.
       */
<span class="line-modified">!     void setPosition(final int pos) {</span>
          i_position = pos;
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Overridden in BranchHandle</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     protected void addHandle() {</span>
<span class="line-removed">-         next = ih_list;</span>
<span class="line-removed">-         ih_list = this;</span>
<span class="line-removed">-     }</span>
  
      /**
<span class="line-modified">!      * Delete contents, i.e., remove user access and make handle reusable.</span>
       */
      void dispose() {
          next = prev = null;
          instruction.dispose();
          instruction = null;
          i_position = -1;
          attributes = null;
          removeAllTargeters();
<span class="line-removed">-         addHandle();</span>
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Remove all targeters, if any.</span>
       */
      public void removeAllTargeters() {
          if (targeters != null) {
              targeters.clear();
          }
      }
  
      /**
       * Denote this handle isn&#39;t referenced anymore by t.
       */
<span class="line-modified">!     public void removeTargeter(final InstructionTargeter t) {</span>
          if (targeters != null) {
              targeters.remove(t);
          }
      }
  
      /**
       * Denote this handle is being referenced by t.
       */
<span class="line-modified">!     public void addTargeter(final InstructionTargeter t) {</span>
          if (targeters == null) {
              targeters = new HashSet&lt;&gt;();
          }
          //if(!targeters.contains(t))
          targeters.add(t);
      }
  
      public boolean hasTargeters() {
          return (targeters != null) &amp;&amp; (targeters.size() &gt; 0);
      }
  
      /**
       * @return null, if there are no targeters
       */
      public InstructionTargeter[] getTargeters() {
          if (!hasTargeters()) {
<span class="line-new-header">--- 96,122 ---</span>
              instruction.dispose();
          }
          instruction = i;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Temporarily swap the current instruction, without disturbing</span>
<span class="line-modified">!      * anything. Meant to be used by a debugger, implementing</span>
<span class="line-modified">!      * breakpoints. Current instruction is returned.</span>
       * &lt;p&gt;
       * Warning: if this is used on a BranchHandle then some methods such as
<span class="line-modified">!      * getPosition() will still refer to the original cached instruction, whereas</span>
<span class="line-modified">!      * other BH methods may affect the cache and the replacement instruction.</span>
       */
      // See BCEL-273
      // TODO remove this method in any redesign of BCEL
<span class="line-modified">!     public Instruction swapInstruction( final Instruction i ) {</span>
          final Instruction oldInstruction = instruction;
          instruction = i;
          return oldInstruction;
      }
  
  
<span class="line-modified">!     /*private*/protected InstructionHandle(final Instruction i) {</span>
          setInstruction(i);
      }
  
<span class="line-modified">!     /** Factory method.</span>
       */
<span class="line-modified">!     static InstructionHandle getInstructionHandle( final Instruction i ) {</span>
<span class="line-modified">!         return new InstructionHandle(i);</span>
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified">!      * instruction. In the presence of variable length instructions `setPositions()&#39;</span>
<span class="line-modified">!      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified">!      * correct (byte) positions and offsets by calling this function.</span>
       *
<span class="line-modified">!      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified">!      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified">!      * @return additional offset caused by possible change of this instruction&#39;s length</span>
       */
<span class="line-modified">!     protected int updatePosition( final int offset, final int max_offset ) {</span>
          i_position += offset;
          return 0;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return the position, i.e., the byte code offset of the contained</span>
<span class="line-modified">!      * instruction. This is accurate only after</span>
<span class="line-modified">!      * InstructionList.setPositions() has been called.</span>
       */
      public int getPosition() {
          return i_position;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Set the position, i.e., the byte code offset of the contained</span>
       * instruction.
       */
<span class="line-modified">!     void setPosition( final int pos ) {</span>
          i_position = pos;
      }
  
  
      /**
<span class="line-modified">!      * Delete contents, i.e., remove user access.</span>
       */
      void dispose() {
          next = prev = null;
          instruction.dispose();
          instruction = null;
          i_position = -1;
          attributes = null;
          removeAllTargeters();
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Remove all targeters, if any.</span>
       */
      public void removeAllTargeters() {
          if (targeters != null) {
              targeters.clear();
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Denote this handle isn&#39;t referenced anymore by t.
       */
<span class="line-modified">!     public void removeTargeter( final InstructionTargeter t ) {</span>
          if (targeters != null) {
              targeters.remove(t);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Denote this handle is being referenced by t.
       */
<span class="line-modified">!     public void addTargeter( final InstructionTargeter t ) {</span>
          if (targeters == null) {
              targeters = new HashSet&lt;&gt;();
          }
          //if(!targeters.contains(t))
          targeters.add(t);
      }
  
<span class="line-added">+ </span>
      public boolean hasTargeters() {
          return (targeters != null) &amp;&amp; (targeters.size() &gt; 0);
      }
  
<span class="line-added">+ </span>
      /**
       * @return null, if there are no targeters
       */
      public InstructionTargeter[] getTargeters() {
          if (!hasTargeters()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,89 ***</span>
          final InstructionTargeter[] t = new InstructionTargeter[targeters.size()];
          targeters.toArray(t);
          return t;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return a (verbose) string representation of the contained instruction.</span>
       */
<span class="line-modified">!     public String toString(final boolean verbose) {</span>
          return Utility.format(i_position, 4, false, &#39; &#39;) + &quot;: &quot; + instruction.toString(verbose);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return a string representation of the contained instruction.</span>
       */
      @Override
      public String toString() {
          return toString(true);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add an attribute to an instruction handle.</span>
       *
       * @param key the key object to store/retrieve the attribute
       * @param attr the attribute to associate with this handle
       */
<span class="line-modified">!     public void addAttribute(final Object key, final Object attr) {</span>
          if (attributes == null) {
              attributes = new HashMap&lt;&gt;(3);
          }
          attributes.put(key, attr);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Delete an attribute of an instruction handle.</span>
       *
       * @param key the key object to retrieve the attribute
       */
<span class="line-modified">!     public void removeAttribute(final Object key) {</span>
          if (attributes != null) {
              attributes.remove(key);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Get attribute of an instruction handle.</span>
       *
       * @param key the key object to store/retrieve the attribute
       */
<span class="line-modified">!     public Object getAttribute(final Object key) {</span>
          if (attributes != null) {
              return attributes.get(key);
          }
          return null;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return all attributes associated with this handle</span>
       */
      public Collection&lt;Object&gt; getAttributes() {
          if (attributes == null) {
              attributes = new HashMap&lt;&gt;(3);
          }
          return attributes.values();
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Convenience method, simply calls accept() on the contained instruction.</span>
       *
       * @param v Visitor object
       */
<span class="line-modified">!     public void accept(final Visitor v) {</span>
          instruction.accept(v);
      }
  
      /**
       * @param next the next to set
       * @ since 6.0
       */
      final InstructionHandle setNext(final InstructionHandle next) {
          this.next = next;
          return next;
      }
  
      /**
       * @param prev the prev to set
       * @ since 6.0
       */
      final InstructionHandle setPrev(final InstructionHandle prev) {
<span class="line-new-header">--- 220,91 ---</span>
          final InstructionTargeter[] t = new InstructionTargeter[targeters.size()];
          targeters.toArray(t);
          return t;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return a (verbose) string representation of the contained instruction.</span>
       */
<span class="line-modified">!     public String toString( final boolean verbose ) {</span>
          return Utility.format(i_position, 4, false, &#39; &#39;) + &quot;: &quot; + instruction.toString(verbose);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return a string representation of the contained instruction.</span>
       */
      @Override
      public String toString() {
          return toString(true);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Add an attribute to an instruction handle.</span>
       *
       * @param key the key object to store/retrieve the attribute
       * @param attr the attribute to associate with this handle
       */
<span class="line-modified">!     public void addAttribute( final Object key, final Object attr ) {</span>
          if (attributes == null) {
              attributes = new HashMap&lt;&gt;(3);
          }
          attributes.put(key, attr);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Delete an attribute of an instruction handle.</span>
       *
       * @param key the key object to retrieve the attribute
       */
<span class="line-modified">!     public void removeAttribute( final Object key ) {</span>
          if (attributes != null) {
              attributes.remove(key);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Get attribute of an instruction handle.</span>
       *
       * @param key the key object to store/retrieve the attribute
       */
<span class="line-modified">!     public Object getAttribute( final Object key ) {</span>
          if (attributes != null) {
              return attributes.get(key);
          }
          return null;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return all attributes associated with this handle</span>
       */
      public Collection&lt;Object&gt; getAttributes() {
          if (attributes == null) {
              attributes = new HashMap&lt;&gt;(3);
          }
          return attributes.values();
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Convenience method, simply calls accept() on the contained instruction.</span>
       *
       * @param v Visitor object
       */
<span class="line-modified">!     public void accept( final Visitor v ) {</span>
          instruction.accept(v);
      }
  
<span class="line-added">+ </span>
      /**
       * @param next the next to set
       * @ since 6.0
       */
      final InstructionHandle setNext(final InstructionHandle next) {
          this.next = next;
          return next;
      }
  
<span class="line-added">+ </span>
      /**
       * @param prev the prev to set
       * @ since 6.0
       */
      final InstructionHandle setPrev(final InstructionHandle prev) {
</pre>
<center><a href="InstructionFactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionList.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/LocalVariableGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import com.sun.org.apache.bcel.internal.Const;
 24 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
 25 
 26 /**
 27  * This class represents a local variable within a method. It contains its
 28  * scope, name and type. The generated LocalVariable object can be obtained with
 29  * getLocalVariable which needs the instruction list and the constant pool as
 30  * parameters.
 31  *
 32  * @version $Id: LocalVariableGen.java 1749603 2016-06-21 20:50:19Z ggregory $
 33  * @see LocalVariable
 34  * @see MethodGen
 35  */
 36 public class LocalVariableGen implements InstructionTargeter, NamedAndTyped, Cloneable {
 37 
 38     private int index;
 39     private String name;
 40     private Type type;
 41     private InstructionHandle start;
 42     private InstructionHandle end;
 43 
 44     /**
 45      * Generate a local variable that with index `index&#39;. Note that double and
 46      * long variables need two indexs. Index indices have to be provided by the
 47      * user.
 48      *
 49      * @param index index of local variable
 50      * @param name its name
 51      * @param type its type
 52      * @param start from where the instruction is valid (null means from the
 53      * start)
 54      * @param end until where the instruction is valid (null means to the end)
 55      */
 56     public LocalVariableGen(final int index, final String name, final Type type,
 57             final InstructionHandle start, final InstructionHandle end) {
 58         if ((index &lt; 0) || (index &gt; Const.MAX_SHORT)) {
 59             throw new ClassGenException(&quot;Invalid index index: &quot; + index);
 60         }
 61         this.name = name;
 62         this.type = type;
 63         this.index = index;
 64         setStart(start);
 65         setEnd(end);
 66     }
 67 
 68     /**
 69      * Get LocalVariable object.
 70      *
 71      * This relies on that the instruction list has already been dumped to byte
 72      * code or or that the `setPositions&#39; methods has been called for the
 73      * instruction list.
 74      *
 75      * Note that for local variables whose scope end at the last instruction of
 76      * the method&#39;s code, the JVM specification is ambiguous: both a
 77      * start_pc+length ending at the last instruction and start_pc+length ending
 78      * at first index beyond the end of the code are valid.
 79      *
 80      * @param cp constant pool
 81      */
 82     public LocalVariable getLocalVariable(final ConstantPoolGen cp) {
 83         int start_pc = 0;
 84         int length = 0;
 85         if ((start != null) &amp;&amp; (end != null)) {
 86             start_pc = start.getPosition();
 87             length = end.getPosition() - start_pc;
 88             if (end.getNext() == null) {
 89                 length += end.getInstruction().getLength();
 90             }
 91         }
 92         final int name_index = cp.addUtf8(name);
 93         final int signature_index = cp.addUtf8(type.getSignature());
 94         return new LocalVariable(start_pc, length, name_index, signature_index, index, cp
 95                 .getConstantPool());
 96     }
 97 
 98     public void setIndex(final int index) {
 99         this.index = index;
100     }
101 
102     public int getIndex() {
103         return index;
104     }
105 
106     @Override
107     public void setName(final String name) {
108         this.name = name;
109     }
110 
111     @Override
112     public String getName() {
113         return name;
114     }
115 
116     @Override
117     public void setType(final Type type) {
118         this.type = type;
119     }
120 
121     @Override
122     public Type getType() {
123         return type;
124     }
125 
126     public InstructionHandle getStart() {
127         return start;
128     }
129 
130     public InstructionHandle getEnd() {
131         return end;
132     }
133 
134     public void setStart(final InstructionHandle start) { // TODO could be package-protected?
135         BranchInstruction.notifyTarget(this.start, start, this);
136         this.start = start;
137     }
138 
139     public void setEnd(final InstructionHandle end) { // TODO could be package-protected?
140         BranchInstruction.notifyTarget(this.end, end, this);
141         this.end = end;
142     }
143 
144     /**
145      * @param old_ih old target, either start or end
146      * @param new_ih new target
147      */
148     @Override
149     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {
150         boolean targeted = false;
151         if (start == old_ih) {
152             targeted = true;
153             setStart(new_ih);
154         }
155         if (end == old_ih) {
156             targeted = true;
157             setEnd(new_ih);
158         }
159         if (!targeted) {
160             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but {&quot; + start + &quot;, &quot; + end
161                     + &quot;}&quot;);
162         }
163     }
164 
165     /**
166      * Clear the references from and to this variable when it&#39;s removed.
167      */
168     void dispose() {
169         setStart(null);
170         setEnd(null);
171     }
172 
173     /**
174      * @return true, if ih is target of this variable
175      */
176     @Override
177     public boolean containsTarget(final InstructionHandle ih) {
178         return (start == ih) || (end == ih);
179     }
180 
181     @Override
182     public int hashCode() {
183         // If the user changes the name or type, problems with the targeter hashmap will occur.
184         // Note: index cannot be part of hash as it may be changed by the user.
185         return name.hashCode() ^ type.hashCode();
186     }
187 
188     /**
189      * We consider to local variables to be equal, if the use the same index and
190      * are valid in the same range.
191      */
192     @Override
193     public boolean equals(final Object o) {
194         if (!(o instanceof LocalVariableGen)) {
195             return false;
196         }
197         final LocalVariableGen l = (LocalVariableGen) o;
198         return (l.index == index) &amp;&amp; (l.start == start) &amp;&amp; (l.end == end);
199     }
200 
201     @Override
202     public String toString() {
203         return &quot;LocalVariableGen(&quot; + name + &quot;, &quot; + type + &quot;, &quot; + start + &quot;, &quot; + end + &quot;)&quot;;
204     }
205 
206     @Override
207     public Object clone() {
208         try {
209             return super.clone();
210         } catch (final CloneNotSupportedException e) {
211             throw new Error(&quot;Clone Not Supported&quot;); // never happens
212         }
213     }
214 }
    </pre>
  </body>
</html>
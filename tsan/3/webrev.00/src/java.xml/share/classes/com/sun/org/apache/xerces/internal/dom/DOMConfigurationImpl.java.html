<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/xerces/internal/dom/DOMConfigurationImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.dom;
  22 
  23 import com.sun.org.apache.xerces.internal.impl.Constants;
  24 import com.sun.org.apache.xerces.internal.impl.XMLEntityManager;
  25 import com.sun.org.apache.xerces.internal.impl.XMLErrorReporter;
  26 import com.sun.org.apache.xerces.internal.impl.dv.DTDDVFactory;
  27 import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
  28 import com.sun.org.apache.xerces.internal.impl.validation.ValidationManager;
  29 import com.sun.org.apache.xerces.internal.util.DOMEntityResolverWrapper;
  30 import com.sun.org.apache.xerces.internal.util.DOMErrorHandlerWrapper;
  31 import com.sun.org.apache.xerces.internal.util.MessageFormatter;
  32 import com.sun.org.apache.xerces.internal.util.ParserConfigurationSettings;
  33 import com.sun.org.apache.xerces.internal.util.PropertyState;
  34 import com.sun.org.apache.xerces.internal.util.SymbolTable;
  35 import com.sun.org.apache.xerces.internal.utils.XMLSecurityManager;
  36 import com.sun.org.apache.xerces.internal.utils.XMLSecurityPropertyManager;
  37 import com.sun.org.apache.xerces.internal.xni.XMLDTDContentModelHandler;
  38 import com.sun.org.apache.xerces.internal.xni.XMLDTDHandler;
  39 import com.sun.org.apache.xerces.internal.xni.XMLDocumentHandler;
  40 import com.sun.org.apache.xerces.internal.xni.XNIException;
  41 import com.sun.org.apache.xerces.internal.xni.grammars.XMLGrammarPool;
  42 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponent;
  43 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponentManager;
  44 import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
  45 import com.sun.org.apache.xerces.internal.xni.parser.XMLEntityResolver;
  46 import com.sun.org.apache.xerces.internal.xni.parser.XMLErrorHandler;
  47 import com.sun.org.apache.xerces.internal.xni.parser.XMLInputSource;
  48 import com.sun.org.apache.xerces.internal.xni.parser.XMLParserConfiguration;
  49 import java.io.IOException;
  50 import java.util.ArrayList;
  51 import java.util.HashMap;
  52 import java.util.List;
  53 import java.util.Locale;
  54 import java.util.StringTokenizer;
  55 import javax.xml.XMLConstants;
  56 import javax.xml.catalog.CatalogFeatures;
  57 import jdk.xml.internal.JdkXmlUtils;
  58 import org.w3c.dom.DOMConfiguration;
  59 import org.w3c.dom.DOMErrorHandler;
  60 import org.w3c.dom.DOMException;
  61 import org.w3c.dom.DOMStringList;
  62 import org.w3c.dom.ls.LSResourceResolver;
  63 
  64 
  65 
  66 /**
  67  * Xerces implementation of DOMConfiguration that maintains a table of recognized parameters.
  68  *
  69  * @xerces.internal
  70  *
  71  * @author Elena Litani, IBM
  72  * @author Neeraj Bajaj, Sun Microsystems.
  73  * @LastModified: Apr 2019
  74  */
  75 public class DOMConfigurationImpl extends ParserConfigurationSettings
  76     implements XMLParserConfiguration, DOMConfiguration {
  77 
  78     //
  79     // Constants
  80     //
  81 
  82     protected static final String XML11_DATATYPE_VALIDATOR_FACTORY =
  83         &quot;com.sun.org.apache.xerces.internal.impl.dv.dtd.XML11DTDDVFactoryImpl&quot;;
  84 
  85     // feature identifiers
  86 
  87     /** Feature identifier: validation. */
  88     protected static final String XERCES_VALIDATION =
  89         Constants.SAX_FEATURE_PREFIX + Constants.VALIDATION_FEATURE;
  90 
  91     /** Feature identifier: namespaces. */
  92     protected static final String XERCES_NAMESPACES =
  93         Constants.SAX_FEATURE_PREFIX + Constants.NAMESPACES_FEATURE;
  94 
  95     protected static final String SCHEMA =
  96         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_VALIDATION_FEATURE;
  97 
  98     protected static final String SCHEMA_FULL_CHECKING =
  99         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_FULL_CHECKING;
 100 
 101     protected static final String DYNAMIC_VALIDATION =
 102         Constants.XERCES_FEATURE_PREFIX + Constants.DYNAMIC_VALIDATION_FEATURE;
 103 
 104     protected static final String NORMALIZE_DATA =
 105         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_NORMALIZED_VALUE;
 106 
 107     /** Feature identifier: send element default value via characters() */
 108     protected static final String SCHEMA_ELEMENT_DEFAULT =
 109         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_ELEMENT_DEFAULT;
 110 
 111     /** sending psvi in the pipeline */
 112     protected static final String SEND_PSVI =
 113         Constants.XERCES_FEATURE_PREFIX + Constants.SCHEMA_AUGMENT_PSVI;
 114 
 115     /** Feature: generate synthetic annotations */
 116     protected static final String GENERATE_SYNTHETIC_ANNOTATIONS =
 117         Constants.XERCES_FEATURE_PREFIX + Constants.GENERATE_SYNTHETIC_ANNOTATIONS_FEATURE;
 118 
 119     /** Feature identifier: validate annotations */
 120     protected static final String VALIDATE_ANNOTATIONS =
 121         Constants.XERCES_FEATURE_PREFIX + Constants.VALIDATE_ANNOTATIONS_FEATURE;
 122 
 123     /** Feature identifier: honour all schemaLocations */
 124     protected static final String HONOUR_ALL_SCHEMALOCATIONS =
 125         Constants.XERCES_FEATURE_PREFIX + Constants.HONOUR_ALL_SCHEMALOCATIONS_FEATURE;
 126 
 127     /** Feature identifier: use grammar pool only */
 128     protected static final String USE_GRAMMAR_POOL_ONLY =
 129         Constants.XERCES_FEATURE_PREFIX + Constants.USE_GRAMMAR_POOL_ONLY_FEATURE;
 130 
 131     /** Feature identifier: load external DTD. */
 132     protected static final String DISALLOW_DOCTYPE_DECL_FEATURE =
 133         Constants.XERCES_FEATURE_PREFIX + Constants.DISALLOW_DOCTYPE_DECL_FEATURE;
 134 
 135     /** Feature identifier: balance syntax trees. */
 136     protected static final String BALANCE_SYNTAX_TREES =
 137         Constants.XERCES_FEATURE_PREFIX + Constants.BALANCE_SYNTAX_TREES;
 138 
 139     /** Feature identifier: warn on duplicate attribute definition. */
 140     protected static final String WARN_ON_DUPLICATE_ATTDEF =
 141         Constants.XERCES_FEATURE_PREFIX + Constants.WARN_ON_DUPLICATE_ATTDEF_FEATURE;
 142 
 143     /** Feature identifier: namespace growth */
 144     protected static final String NAMESPACE_GROWTH =
 145         Constants.XERCES_FEATURE_PREFIX + Constants.NAMESPACE_GROWTH_FEATURE;
 146 
 147     protected static final String TOLERATE_DUPLICATES =
 148         Constants.XERCES_FEATURE_PREFIX + Constants.TOLERATE_DUPLICATES_FEATURE;
 149 
 150     // property identifiers
 151 
 152     /** Property identifier: entity manager. */
 153     protected static final String ENTITY_MANAGER =
 154         Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_MANAGER_PROPERTY;
 155 
 156     /** Property identifier: error reporter. */
 157     protected static final String ERROR_REPORTER =
 158         Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_REPORTER_PROPERTY;
 159 
 160     /** Property identifier: xml string. */
 161     protected static final String XML_STRING =
 162         Constants.SAX_PROPERTY_PREFIX + Constants.XML_STRING_PROPERTY;
 163 
 164     /** Property identifier: symbol table. */
 165     protected static final String SYMBOL_TABLE =
 166         Constants.XERCES_PROPERTY_PREFIX + Constants.SYMBOL_TABLE_PROPERTY;
 167 
 168     /** Property id: Grammar pool. */
 169     protected static final String GRAMMAR_POOL =
 170         Constants.XERCES_PROPERTY_PREFIX + Constants.XMLGRAMMAR_POOL_PROPERTY;
 171 
 172     /** Property identifier: error handler. */
 173     protected static final String ERROR_HANDLER =
 174         Constants.XERCES_PROPERTY_PREFIX + Constants.ERROR_HANDLER_PROPERTY;
 175 
 176     /** Property identifier: entity resolver. */
 177     protected static final String ENTITY_RESOLVER =
 178         Constants.XERCES_PROPERTY_PREFIX + Constants.ENTITY_RESOLVER_PROPERTY;
 179 
 180     /** Property identifier: JAXP schema language / DOM schema-type. */
 181     protected static final String JAXP_SCHEMA_LANGUAGE =
 182         Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE;
 183 
 184     /** Property identifier: JAXP schema source/ DOM schema-location. */
 185     protected static final String JAXP_SCHEMA_SOURCE =
 186         Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE;
 187 
 188     /** Property identifier: DTD validator. */
 189     protected final static String DTD_VALIDATOR_PROPERTY =
 190         Constants.XERCES_PROPERTY_PREFIX + Constants.DTD_VALIDATOR_PROPERTY;
 191 
 192     /** Property identifier: datatype validator factory. */
 193     protected static final String DTD_VALIDATOR_FACTORY_PROPERTY =
 194         Constants.XERCES_PROPERTY_PREFIX + Constants.DATATYPE_VALIDATOR_FACTORY_PROPERTY;
 195 
 196     protected static final String VALIDATION_MANAGER =
 197         Constants.XERCES_PROPERTY_PREFIX + Constants.VALIDATION_MANAGER_PROPERTY;
 198 
 199     /** Property identifier: schema location. */
 200     protected static final String SCHEMA_LOCATION =
 201         Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_LOCATION;
 202 
 203     /** Property identifier: no namespace schema location. */
 204     protected static final String SCHEMA_NONS_LOCATION =
 205         Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_NONS_LOCATION;
 206 
 207     /** Property identifier: Schema DV Factory */
 208     protected static final String SCHEMA_DV_FACTORY =
 209         Constants.XERCES_PROPERTY_PREFIX + Constants.SCHEMA_DV_FACTORY_PROPERTY;
 210 
 211     /** Property identifier: Security manager. */
 212     private static final String SECURITY_MANAGER = Constants.SECURITY_MANAGER;
 213 
 214     /** Property identifier: Security property manager. */
 215     private static final String XML_SECURITY_PROPERTY_MANAGER =
 216             Constants.XML_SECURITY_PROPERTY_MANAGER;
 217 
 218     //
 219     // Data
 220     //
 221     XMLDocumentHandler fDocumentHandler;
 222 
 223     /** Normalization features*/
 224     protected short features = 0;
 225 
 226     protected final static short NAMESPACES          = 0x1&lt;&lt;0;
 227     protected final static short DTNORMALIZATION     = 0x1&lt;&lt;1;
 228     protected final static short ENTITIES            = 0x1&lt;&lt;2;
 229     protected final static short CDATA               = 0x1&lt;&lt;3;
 230     protected final static short SPLITCDATA          = 0x1&lt;&lt;4;
 231     protected final static short COMMENTS            = 0x1&lt;&lt;5;
 232     protected final static short VALIDATE            = 0x1&lt;&lt;6;
 233     protected final static short PSVI                = 0x1&lt;&lt;7;
 234     protected final static short WELLFORMED          = 0x1&lt;&lt;8;
 235     protected final static short NSDECL              = 0x1&lt;&lt;9;
 236 
 237     protected final static short INFOSET_TRUE_PARAMS = NAMESPACES | COMMENTS | WELLFORMED | NSDECL;
 238     protected final static short INFOSET_FALSE_PARAMS = ENTITIES | DTNORMALIZATION | CDATA;
 239     protected final static short INFOSET_MASK = INFOSET_TRUE_PARAMS | INFOSET_FALSE_PARAMS;
 240 
 241     // components
 242 
 243     /** Symbol table. */
 244     protected SymbolTable fSymbolTable;
 245 
 246     /** Components. */
 247     protected List&lt;XMLComponent&gt; fComponents;
 248 
 249     protected ValidationManager fValidationManager;
 250 
 251     /** Locale. */
 252     protected Locale fLocale;
 253 
 254     /** Error reporter */
 255     protected XMLErrorReporter fErrorReporter;
 256 
 257     protected final DOMErrorHandlerWrapper fErrorHandlerWrapper =
 258                 new DOMErrorHandlerWrapper();
 259 
 260     /** Current Datatype validator factory. */
 261     protected DTDDVFactory fCurrentDVFactory;
 262 
 263     /** The XML 1.0 Datatype validator factory. */
 264     protected DTDDVFactory fDatatypeValidatorFactory;
 265 
 266     /** The XML 1.1 Datatype validator factory. **/
 267     protected DTDDVFactory fXML11DatatypeFactory;
 268 
 269     // private data
 270 
 271     private String fSchemaLocation = null;
 272     private DOMStringList fRecognizedParameters;
 273 
 274 
 275     //
 276     // Constructors
 277     //
 278 
 279     /** Default Constructor. */
 280     protected DOMConfigurationImpl() {
 281         this(null, null);
 282     } // &lt;init&gt;()
 283 
 284     /**
 285      * Constructs a parser configuration using the specified symbol table.
 286      *
 287      * @param symbolTable The symbol table to use.
 288      */
 289     protected DOMConfigurationImpl(SymbolTable symbolTable) {
 290         this(symbolTable, null);
 291     } // &lt;init&gt;(SymbolTable)
 292 
 293     /**
 294      * Constructs a parser configuration using the specified symbol table
 295      * and parent settings.
 296      *
 297      * @param symbolTable    The symbol table to use.
 298      * @param parentSettings The parent settings.
 299      */
 300     protected DOMConfigurationImpl(SymbolTable symbolTable,
 301                                     XMLComponentManager parentSettings) {
 302         super(parentSettings);
 303 
 304 
 305         // create table for features and properties
 306         fFeatures = new HashMap&lt;&gt;();
 307         fProperties = new HashMap&lt;&gt;();
 308 
 309         // add default recognized features
 310         final String[] recognizedFeatures = {
 311             XERCES_VALIDATION,
 312             XERCES_NAMESPACES,
 313             SCHEMA,
 314             SCHEMA_FULL_CHECKING,
 315             DYNAMIC_VALIDATION,
 316             NORMALIZE_DATA,
 317             SCHEMA_ELEMENT_DEFAULT,
 318             SEND_PSVI,
 319             GENERATE_SYNTHETIC_ANNOTATIONS,
 320             VALIDATE_ANNOTATIONS,
 321             HONOUR_ALL_SCHEMALOCATIONS,
 322             USE_GRAMMAR_POOL_ONLY,
 323             DISALLOW_DOCTYPE_DECL_FEATURE,
 324             BALANCE_SYNTAX_TREES,
 325             WARN_ON_DUPLICATE_ATTDEF,
 326             PARSER_SETTINGS,
 327             NAMESPACE_GROWTH,
 328             TOLERATE_DUPLICATES,
 329             XMLConstants.USE_CATALOG,
 330             JdkXmlUtils.OVERRIDE_PARSER
 331         };
 332         addRecognizedFeatures(recognizedFeatures);
 333 
 334         // set state for default features
 335         setFeature(XERCES_VALIDATION, false);
 336         setFeature(SCHEMA, false);
 337         setFeature(SCHEMA_FULL_CHECKING, false);
 338         setFeature(DYNAMIC_VALIDATION, false);
 339         setFeature(NORMALIZE_DATA, false);
 340         setFeature(SCHEMA_ELEMENT_DEFAULT, false);
 341         setFeature(XERCES_NAMESPACES, true);
 342         setFeature(SEND_PSVI, true);
 343         setFeature(GENERATE_SYNTHETIC_ANNOTATIONS, false);
 344         setFeature(VALIDATE_ANNOTATIONS, false);
 345         setFeature(HONOUR_ALL_SCHEMALOCATIONS, false);
 346         setFeature(USE_GRAMMAR_POOL_ONLY, false);
 347         setFeature(DISALLOW_DOCTYPE_DECL_FEATURE, false);
 348         setFeature(BALANCE_SYNTAX_TREES, false);
 349         setFeature(WARN_ON_DUPLICATE_ATTDEF, false);
 350         setFeature(PARSER_SETTINGS, true);
 351         setFeature(NAMESPACE_GROWTH, false);
 352         setFeature(TOLERATE_DUPLICATES, false);
 353         setFeature(XMLConstants.USE_CATALOG, JdkXmlUtils.USE_CATALOG_DEFAULT);
 354         setFeature(JdkXmlUtils.OVERRIDE_PARSER, JdkXmlUtils.OVERRIDE_PARSER_DEFAULT);
 355 
 356         // add default recognized properties
 357         final String[] recognizedProperties = {
 358             XML_STRING,
 359             SYMBOL_TABLE,
 360             ERROR_HANDLER,
 361             ENTITY_RESOLVER,
 362             ERROR_REPORTER,
 363             ENTITY_MANAGER,
 364             VALIDATION_MANAGER,
 365             GRAMMAR_POOL,
 366             JAXP_SCHEMA_SOURCE,
 367             JAXP_SCHEMA_LANGUAGE,
 368             SCHEMA_LOCATION,
 369             SCHEMA_NONS_LOCATION,
 370             DTD_VALIDATOR_PROPERTY,
 371             DTD_VALIDATOR_FACTORY_PROPERTY,
 372             SCHEMA_DV_FACTORY,
 373             SECURITY_MANAGER,
 374             XML_SECURITY_PROPERTY_MANAGER,
 375             JdkXmlUtils.CATALOG_DEFER,
 376             JdkXmlUtils.CATALOG_FILES,
 377             JdkXmlUtils.CATALOG_PREFER,
 378             JdkXmlUtils.CATALOG_RESOLVE,
 379             JdkXmlUtils.CDATA_CHUNK_SIZE
 380         };
 381         addRecognizedProperties(recognizedProperties);
 382 
 383         // set default values for normalization features
 384         features |= NAMESPACES;
 385         features |= ENTITIES;
 386         features |= COMMENTS;
 387         features |= CDATA;
 388         features |= SPLITCDATA;
 389         features |= WELLFORMED;
 390         features |= NSDECL;
 391 
 392         if (symbolTable == null) {
 393             symbolTable = new SymbolTable();
 394         }
 395         fSymbolTable = symbolTable;
 396 
 397         fComponents = new ArrayList&lt;&gt;();
 398 
 399         setProperty(SYMBOL_TABLE, fSymbolTable);
 400         fErrorReporter = new XMLErrorReporter();
 401         setProperty(ERROR_REPORTER, fErrorReporter);
 402         addComponent(fErrorReporter);
 403 
 404         fDatatypeValidatorFactory = DTDDVFactory.getInstance();
 405         fXML11DatatypeFactory = DTDDVFactory.getInstance(XML11_DATATYPE_VALIDATOR_FACTORY);
 406         fCurrentDVFactory = fDatatypeValidatorFactory;
 407         setProperty(DTD_VALIDATOR_FACTORY_PROPERTY, fCurrentDVFactory);
 408 
 409         XMLEntityManager manager =  new XMLEntityManager();
 410         setProperty(ENTITY_MANAGER, manager);
 411         addComponent(manager);
 412 
 413         fValidationManager = createValidationManager();
 414         setProperty(VALIDATION_MANAGER, fValidationManager);
 415 
 416         setProperty(SECURITY_MANAGER, new XMLSecurityManager(true));
 417 
 418         setProperty(Constants.XML_SECURITY_PROPERTY_MANAGER,
 419                 new XMLSecurityPropertyManager());
 420 
 421         // add message formatters
 422         if (fErrorReporter.getMessageFormatter(XMLMessageFormatter.XML_DOMAIN) == null) {
 423             XMLMessageFormatter xmft = new XMLMessageFormatter();
 424             fErrorReporter.putMessageFormatter(XMLMessageFormatter.XML_DOMAIN, xmft);
 425             fErrorReporter.putMessageFormatter(XMLMessageFormatter.XMLNS_DOMAIN, xmft);
 426         }
 427 
 428         // REVISIT: try to include XML Schema formatter.
 429         //          This is a hack to allow DTD configuration to be build.
 430         //
 431         if (fErrorReporter.getMessageFormatter(&quot;http://www.w3.org/TR/xml-schema-1&quot;) == null) {
 432             MessageFormatter xmft = null;
 433             try {
 434                xmft = new com.sun.org.apache.xerces.internal.impl.xs.XSMessageFormatter();
 435             } catch (Exception exception){
 436             }
 437 
 438              if (xmft !=  null) {
 439                  fErrorReporter.putMessageFormatter(&quot;http://www.w3.org/TR/xml-schema-1&quot;, xmft);
 440              }
 441         }
 442 
 443 
 444         // set locale
 445         try {
 446             setLocale(Locale.getDefault());
 447         }
 448         catch (XNIException e) {
 449             // do nothing
 450             // REVISIT: What is the right thing to do? -Ac
 451         }
 452 
 453         // Initialize Catalog features
 454         for( CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {
 455             setProperty(f.getPropertyName(), null);
 456         }
 457 
 458         setProperty(JdkXmlUtils.CDATA_CHUNK_SIZE, JdkXmlUtils.CDATA_CHUNK_SIZE_DEFAULT);
 459     } // &lt;init&gt;(SymbolTable)
 460 
 461 
 462     //
 463     // XMLParserConfiguration methods
 464     //
 465 
 466     /**
 467      * Parse an XML document.
 468      * &lt;p&gt;
 469      * The parser can use this method to instruct this configuration
 470      * to begin parsing an XML document from any valid input source
 471      * (a character stream, a byte stream, or a URI).
 472      * &lt;p&gt;
 473      * Parsers may not invoke this method while a parse is in progress.
 474      * Once a parse is complete, the parser may then parse another XML
 475      * document.
 476      * &lt;p&gt;
 477      * This method is synchronous: it will not return until parsing
 478      * has ended.  If a client application wants to terminate
 479      * parsing early, it should throw an exception.
 480      *
 481      * @param inputSource The input source for the top-level of the
 482      *                    XML document.
 483      *
 484      * @exception XNIException Any XNI exception, possibly wrapping
 485      *                         another exception.
 486      * @exception IOException  An IO exception from the parser, possibly
 487      *                         from a byte stream or character stream
 488      *                         supplied by the parser.
 489      */
 490     public void parse(XMLInputSource inputSource)
 491         throws XNIException, IOException{
 492         // no-op
 493     }
 494 
 495     /**
 496      * Sets the document handler on the last component in the pipeline
 497      * to receive information about the document.
 498      *
 499      * @param documentHandler   The document handler.
 500      */
 501     public void setDocumentHandler(XMLDocumentHandler documentHandler) {
 502         fDocumentHandler = documentHandler;
 503     } // setDocumentHandler(XMLDocumentHandler)
 504 
 505     /** Returns the registered document handler. */
 506     public XMLDocumentHandler getDocumentHandler() {
 507         return fDocumentHandler;
 508     } // getDocumentHandler():XMLDocumentHandler
 509 
 510     /**
 511      * Sets the DTD handler.
 512      *
 513      * @param dtdHandler The DTD handler.
 514      */
 515     public void setDTDHandler(XMLDTDHandler dtdHandler) {
 516         //no-op
 517     } // setDTDHandler(XMLDTDHandler)
 518 
 519     /** Returns the registered DTD handler. */
 520     public XMLDTDHandler getDTDHandler() {
 521         return null;
 522     } // getDTDHandler():XMLDTDHandler
 523 
 524     /**
 525      * Sets the DTD content model handler.
 526      *
 527      * @param handler The DTD content model handler.
 528      */
 529     public void setDTDContentModelHandler(XMLDTDContentModelHandler handler) {
 530         //no-op
 531 
 532     } // setDTDContentModelHandler(XMLDTDContentModelHandler)
 533 
 534     /** Returns the registered DTD content model handler. */
 535     public XMLDTDContentModelHandler getDTDContentModelHandler() {
 536         return null;
 537     } // getDTDContentModelHandler():XMLDTDContentModelHandler
 538 
 539     /**
 540      * Sets the resolver used to resolve external entities. The EntityResolver
 541      * interface supports resolution of public and system identifiers.
 542      *
 543      * @param resolver The new entity resolver. Passing a null value will
 544      *                 uninstall the currently installed resolver.
 545      */
 546     public void setEntityResolver(XMLEntityResolver resolver) {
 547         fProperties.put(ENTITY_RESOLVER, resolver);
 548     } // setEntityResolver(XMLEntityResolver)
 549 
 550     /**
 551      * Return the current entity resolver.
 552      *
 553      * @return The current entity resolver, or null if none
 554      *         has been registered.
 555      * @see #setEntityResolver
 556      */
 557     public XMLEntityResolver getEntityResolver() {
 558         return (XMLEntityResolver)fProperties.get(ENTITY_RESOLVER);
 559     } // getEntityResolver():XMLEntityResolver
 560 
 561     /**
 562      * Allow an application to register an error event handler.
 563      *
 564      * &lt;p&gt;If the application does not register an error handler, all
 565      * error events reported by the SAX parser will be silently
 566      * ignored; however, normal processing may not continue.  It is
 567      * highly recommended that all SAX applications implement an
 568      * error handler to avoid unexpected bugs.&lt;/p&gt;
 569      *
 570      * &lt;p&gt;Applications may register a new or different handler in the
 571      * middle of a parse, and the SAX parser must begin using the new
 572      * handler immediately.&lt;/p&gt;
 573      *
 574      * @param errorHandler The error handler.
 575      * @exception java.lang.NullPointerException If the handler
 576      *            argument is null.
 577      * @see #getErrorHandler
 578      */
 579     public void setErrorHandler(XMLErrorHandler errorHandler) {
 580         if (errorHandler != null) {
 581             fProperties.put(ERROR_HANDLER, errorHandler);
 582         }
 583     } // setErrorHandler(XMLErrorHandler)
 584 
 585     /**
 586      * Return the current error handler.
 587      *
 588      * @return The current error handler, or null if none
 589      *         has been registered.
 590      * @see #setErrorHandler
 591      */
 592     public XMLErrorHandler getErrorHandler() {
 593         return (XMLErrorHandler)fProperties.get(ERROR_HANDLER);
 594     } // getErrorHandler():XMLErrorHandler
 595 
 596     /**
 597      * Returns the state of a feature.
 598      *
 599      * @param featureId The feature identifier.
 600      * @return true if the feature is supported
 601      *
 602      * @throws XMLConfigurationException Thrown for configuration error.
 603      *                                   In general, components should
 604      *                                   only throw this exception if
 605      *                                   it is &lt;strong&gt;really&lt;/strong&gt;
 606      *                                   a critical error.
 607      */
 608     public boolean getFeature(String featureId)
 609         throws XMLConfigurationException {
 610         if (featureId.equals(PARSER_SETTINGS)) {
 611             return true;
 612         }
 613         return super.getFeature(featureId);
 614     }
 615 
 616     /**
 617      * Set the state of a feature.
 618      *
 619      * Set the state of any feature in a SAX2 parser.  The parser
 620      * might not recognize the feature, and if it does recognize
 621      * it, it might not be able to fulfill the request.
 622      *
 623      * @param featureId The unique identifier (URI) of the feature.
 624      * @param state The requested state of the feature (true or false).
 625      *
 626      * @exception com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException If the
 627      *            requested feature is not known.
 628      */
 629     public void setFeature(String featureId, boolean state)
 630         throws XMLConfigurationException {
 631 
 632         // save state if noone &quot;objects&quot;
 633         super.setFeature(featureId, state);
 634 
 635     } // setFeature(String,boolean)
 636 
 637     /**
 638      * setProperty
 639      *
 640      * @param propertyId
 641      * @param value
 642      */
 643     public void setProperty(String propertyId, Object value)
 644         throws XMLConfigurationException {
 645 
 646         // store value if noone &quot;objects&quot;
 647         super.setProperty(propertyId, value);
 648 
 649     } // setProperty(String,Object)
 650 
 651     /**
 652      * Set the locale to use for messages.
 653      *
 654      * @param locale The locale object to use for localization of messages.
 655      *
 656      * @exception XNIException Thrown if the parser does not support the
 657      *                         specified locale.
 658      */
 659     public void setLocale(Locale locale) throws XNIException {
 660         fLocale = locale;
 661         fErrorReporter.setLocale(locale);
 662 
 663     } // setLocale(Locale)
 664 
 665     /** Returns the locale. */
 666     public Locale getLocale() {
 667         return fLocale;
 668     } // getLocale():Locale
 669 
 670     /**
 671      * DOM Level 3 WD - Experimental.
 672      * setParameter
 673      */
 674     public void setParameter(String name, Object value) throws DOMException {
 675         boolean found = true;
 676 
 677         // REVISIT: Recognizes DOM L3 default features only.
 678         //          Does not yet recognize Xerces features.
 679         if(value instanceof Boolean){
 680             boolean state = ((Boolean)value).booleanValue();
 681 
 682             if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)) {
 683                 features = (short) (state ? features | COMMENTS : features &amp; ~COMMENTS);
 684             }
 685             else if (name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)) {
 686                 setFeature(NORMALIZE_DATA, state);
 687                 features =
 688                     (short) (state ? features | DTNORMALIZATION : features &amp; ~DTNORMALIZATION);
 689                 if (state) {
 690                     features = (short) (features | VALIDATE);
 691                 }
 692             }
 693             else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES)) {
 694                 features = (short) (state ? features | NAMESPACES : features &amp; ~NAMESPACES);
 695             }
 696             else if (name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)) {
 697                 features = (short) (state ? features | CDATA : features &amp; ~CDATA);
 698             }
 699             else if (name.equalsIgnoreCase(Constants.DOM_ENTITIES)) {
 700                 features = (short) (state ? features | ENTITIES : features &amp; ~ENTITIES);
 701             }
 702             else if (name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)) {
 703                 features = (short) (state ? features | SPLITCDATA : features &amp; ~SPLITCDATA);
 704             }
 705             else if (name.equalsIgnoreCase(Constants.DOM_VALIDATE)) {
 706                 features = (short) (state ? features | VALIDATE : features &amp; ~VALIDATE);
 707             }
 708             else if (name.equalsIgnoreCase(Constants.DOM_WELLFORMED)) {
 709                 features = (short) (state ? features | WELLFORMED : features &amp; ~WELLFORMED );
 710             }
 711             else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)) {
 712                 features = (short) (state ? features | NSDECL : features &amp; ~NSDECL);
 713             }
 714             else if (name.equalsIgnoreCase(Constants.DOM_INFOSET)) {
 715                 // Setting to false has no effect.
 716                 if (state) {
 717                     features = (short) (features | INFOSET_TRUE_PARAMS);
 718                     features = (short) (features &amp; ~INFOSET_FALSE_PARAMS);
 719                     setFeature(NORMALIZE_DATA, false);
 720                 }
 721             }
 722             else if (name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)
 723                     || name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM)
 724                     || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA)
 725                     || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION)
 726                     ) {
 727                 if (state) { // true is not supported
 728                     throw newFeatureNotSupportedError(name);
 729                 }
 730             }
 731                         else if ( name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE)) {
 732                 if (!state) { // false is not supported
 733                     throw newFeatureNotSupportedError(name);
 734                 }
 735             }
 736             else if (name.equalsIgnoreCase(SEND_PSVI) ){
 737                 // REVISIT: turning augmentation of PSVI is not support,
 738                 // because in this case we won&#39;t be able to retrieve element
 739                 // default value.
 740                 if (!state) { // false is not supported
 741                     throw newFeatureNotSupportedError(name);
 742                 }
 743             }
 744             else if (name.equalsIgnoreCase(Constants.DOM_PSVI)){
 745                   features = (short) (state ? features | PSVI : features &amp; ~PSVI);
 746             }
 747             else {
 748                 found = false;
 749                 /*
 750                 String msg =
 751                     DOMMessageFormatter.formatMessage(
 752                         DOMMessageFormatter.DOM_DOMAIN,
 753                         &quot;FEATURE_NOT_FOUND&quot;,
 754                         new Object[] { name });
 755                 throw new DOMException(DOMException.NOT_FOUND_ERR, msg);
 756                 */
 757             }
 758 
 759         }
 760 
 761         if (!found || !(value instanceof Boolean))  { // set properties
 762                 found = true;
 763 
 764             if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
 765                 if (value instanceof DOMErrorHandler || value == null) {
 766                     fErrorHandlerWrapper.setErrorHandler((DOMErrorHandler)value);
 767                     setErrorHandler(fErrorHandlerWrapper);
 768                 }
 769                 else {
 770                     throw newTypeMismatchError(name);
 771                 }
 772             }
 773             else if (name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER)) {
 774                 if (value instanceof LSResourceResolver || value == null) {
 775                     try {
 776                         setEntityResolver(new DOMEntityResolverWrapper((LSResourceResolver) value));
 777                     }
 778                     catch (XMLConfigurationException e) {}
 779                 }
 780                 else {
 781                     throw newTypeMismatchError(name);
 782                 }
 783             }
 784             else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION)) {
 785                 if (value instanceof String || value == null) {
 786                     try {
 787                         if (value == null) {
 788                             fSchemaLocation = null;
 789                             setProperty (
 790                                 Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE,
 791                                 null);
 792                         }
 793                         else {
 794                             fSchemaLocation = (String) value;
 795                             // map DOM schema-location to JAXP schemaSource property
 796                             // tokenize location string
 797                             StringTokenizer t = new StringTokenizer(fSchemaLocation, &quot; \n\t\r&quot;);
 798                             if (t.hasMoreTokens()) {
 799                                 List&lt;String&gt; locations = new ArrayList&lt;&gt;();
 800                                 locations.add(t.nextToken());
 801                                 while (t.hasMoreTokens()) {
 802                                     locations.add (t.nextToken());
 803                                 }
 804                                 setProperty (
 805                                     Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE,
 806                                     locations.toArray(new String[locations.size()]));
 807                             }
 808                             else {
 809                                 setProperty (
 810                                     Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_SOURCE,
 811                                     new String [] {(String) value});
 812                             }
 813                         }
 814                     }
 815                     catch (XMLConfigurationException e) {}
 816                 }
 817                 else {
 818                     throw newTypeMismatchError(name);
 819                 }
 820             }
 821             else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE)) {
 822                 if (value instanceof String || value == null) {
 823                     try {
 824                         if (value == null) {
 825                             setProperty(
 826                                 Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE,
 827                                 null);
 828                         }
 829                         else if (value.equals(Constants.NS_XMLSCHEMA)) {
 830                             // REVISIT: when add support to DTD validation
 831                             setProperty(
 832                                 Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE,
 833                                 Constants.NS_XMLSCHEMA);
 834                         }
 835                         else if (value.equals(Constants.NS_DTD)) {
 836                             // Added support for revalidation against DTDs
 837                                 setProperty(Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE,
 838                                                 Constants.NS_DTD);
 839                         }
 840                     }
 841                     catch (XMLConfigurationException e) {}
 842                 }
 843                 else {
 844                     throw newTypeMismatchError(name);
 845                 }
 846             }
 847             else if (name.equalsIgnoreCase(ENTITY_RESOLVER)) {
 848                 if (value instanceof XMLEntityResolver || value == null) {
 849                     try {
 850                         setEntityResolver((XMLEntityResolver) value);
 851                     }
 852                     catch (XMLConfigurationException e) {}
 853                 }
 854                 else {
 855                     throw newTypeMismatchError(name);
 856                 }
 857             }
 858             else if (name.equalsIgnoreCase(SYMBOL_TABLE)) {
 859                 // Xerces Symbol Table
 860                 if (value instanceof SymbolTable){
 861                     setProperty(SYMBOL_TABLE, value);
 862                 }
 863                 else {
 864                     throw newTypeMismatchError(name);
 865                 }
 866             }
 867             else if (name.equalsIgnoreCase (GRAMMAR_POOL)) {
 868                 if (value instanceof XMLGrammarPool || value == null) {
 869                     setProperty(GRAMMAR_POOL, value);
 870                 }
 871                 else {
 872                     throw newTypeMismatchError(name);
 873                 }
 874             }
 875                 else {
 876                 // REVISIT: check if this is a boolean parameter -- type mismatch should be thrown.
 877                 //parameter is not recognized
 878                 throw newFeatureNotFoundError(name);
 879             }
 880         }
 881     }
 882 
 883 
 884     /**
 885      * DOM Level 3 WD - Experimental.
 886      * getParameter
 887      */
 888         public Object getParameter(String name) throws DOMException {
 889 
 890                 // REVISIT: Recognizes DOM L3 default features only.
 891                 //          Does not yet recognize Xerces features.
 892 
 893                 if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)) {
 894                         return ((features &amp; COMMENTS) != 0) ? Boolean.TRUE : Boolean.FALSE;
 895                 }
 896                 else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACES)) {
 897                         return (features &amp; NAMESPACES) != 0 ? Boolean.TRUE : Boolean.FALSE;
 898                 }
 899                 else if (name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)) {
 900                         // REVISIT: datatype-normalization only takes effect if validation is on
 901                         return (features &amp; DTNORMALIZATION) != 0 ? Boolean.TRUE : Boolean.FALSE;
 902                 }
 903                 else if (name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)) {
 904                         return (features &amp; CDATA) != 0 ? Boolean.TRUE : Boolean.FALSE;
 905                 }
 906                 else if (name.equalsIgnoreCase(Constants.DOM_ENTITIES)) {
 907                         return (features &amp; ENTITIES) != 0 ? Boolean.TRUE : Boolean.FALSE;
 908                 }
 909                 else if (name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)) {
 910                         return (features &amp; SPLITCDATA) != 0 ? Boolean.TRUE : Boolean.FALSE;
 911                 }
 912                 else if (name.equalsIgnoreCase(Constants.DOM_VALIDATE)) {
 913                         return (features &amp; VALIDATE) != 0 ? Boolean.TRUE : Boolean.FALSE;
 914                 }
 915                 else if (name.equalsIgnoreCase(Constants.DOM_WELLFORMED)) {
 916                         return (features &amp; WELLFORMED) != 0 ? Boolean.TRUE : Boolean.FALSE;
 917                 }
 918                 else if (name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)) {
 919                     return (features &amp; NSDECL) != 0 ? Boolean.TRUE : Boolean.FALSE;
 920                 }
 921                 else if (name.equalsIgnoreCase(Constants.DOM_INFOSET)) {
 922                         return (features &amp; INFOSET_MASK) == INFOSET_TRUE_PARAMS ? Boolean.TRUE : Boolean.FALSE;
 923                 }
 924                 else if (name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)
 925                                 || name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM)
 926                                 || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA)
 927                                 || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION)
 928                 ) {
 929                         return Boolean.FALSE;
 930                 }
 931         else if (name.equalsIgnoreCase(SEND_PSVI)) {
 932             return Boolean.TRUE;
 933         }
 934         else if (name.equalsIgnoreCase(Constants.DOM_PSVI)) {
 935             return (features &amp; PSVI) != 0 ? Boolean.TRUE : Boolean.FALSE;
 936         }
 937         else if (name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE)) {
 938                         return Boolean.TRUE;
 939                 }
 940                 else if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
 941             return fErrorHandlerWrapper.getErrorHandler();
 942                 }
 943                 else if (name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER)) {
 944                         XMLEntityResolver entityResolver = getEntityResolver();
 945                         if (entityResolver != null &amp;&amp; entityResolver instanceof DOMEntityResolverWrapper) {
 946                                 return ((DOMEntityResolverWrapper) entityResolver).getEntityResolver();
 947                         }
 948                         return null;
 949                 }
 950                 else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE)) {
 951                         return getProperty(Constants.JAXP_PROPERTY_PREFIX + Constants.SCHEMA_LANGUAGE);
 952                 }
 953                 else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION)) {
 954             return fSchemaLocation;
 955                 }
 956         else if (name.equalsIgnoreCase(ENTITY_RESOLVER)) {
 957             return getEntityResolver();
 958         }
 959         else if (name.equalsIgnoreCase(SYMBOL_TABLE)) {
 960             return getProperty(SYMBOL_TABLE);
 961         }
 962         else if (name.equalsIgnoreCase(GRAMMAR_POOL)) {
 963             return getProperty(GRAMMAR_POOL);
 964         }
 965         else if (name.equalsIgnoreCase(SECURITY_MANAGER)) {
 966             return getProperty(SECURITY_MANAGER);
 967         }
 968                 else {
 969                     throw newFeatureNotFoundError(name);
 970                 }
 971         }
 972 
 973     /**
 974      * DOM Level 3 WD - Experimental.
 975      * Check if setting a parameter to a specific value is supported.
 976      *
 977      * @param name The name of the parameter to check.
 978      *
 979      * @param value An object. if null, the returned value is true.
 980      *
 981      * @return true if the parameter could be successfully set to the
 982      * specified value, or false if the parameter is not recognized or
 983      * the requested value is not supported. This does not change the
 984      * current value of the parameter itself.
 985      */
 986         public boolean canSetParameter(String name, Object value) {
 987 
 988         if (value == null){
 989             //if null, the returned value is true.
 990             //REVISIT: I dont like this --- even for unrecognized parameter it would
 991             //return &#39;true&#39;. I think it should return false in that case.
 992             // Application will be surprised to find that setParameter throws not
 993             //recognized exception when canSetParameter returns &#39;true&#39; Then what is the use
 994             //of having canSetParameter ??? - nb.
 995             return true ;
 996         }
 997         if( value instanceof Boolean ){
 998             //features whose parameter value can be set either &#39;true&#39; or &#39;false&#39;
 999             // or they accept any boolean value -- so we just need to check that
1000             // its a boolean value..
1001             if (name.equalsIgnoreCase(Constants.DOM_COMMENTS)
1002                 || name.equalsIgnoreCase(Constants.DOM_DATATYPE_NORMALIZATION)
1003                 || name.equalsIgnoreCase(Constants.DOM_CDATA_SECTIONS)
1004                 || name.equalsIgnoreCase(Constants.DOM_ENTITIES)
1005                 || name.equalsIgnoreCase(Constants.DOM_SPLIT_CDATA)
1006                 || name.equalsIgnoreCase(Constants.DOM_NAMESPACES)
1007                 || name.equalsIgnoreCase(Constants.DOM_VALIDATE)
1008                 || name.equalsIgnoreCase(Constants.DOM_WELLFORMED)
1009                 || name.equalsIgnoreCase(Constants.DOM_INFOSET)
1010                 || name.equalsIgnoreCase(Constants.DOM_NAMESPACE_DECLARATIONS)
1011                 ) {
1012                 return true;
1013             }//features whose parameter value can not be set to &#39;true&#39;
1014             else if (
1015                 name.equalsIgnoreCase(Constants.DOM_NORMALIZE_CHARACTERS)
1016                     || name.equalsIgnoreCase(Constants.DOM_CANONICAL_FORM)
1017                     || name.equalsIgnoreCase(Constants.DOM_VALIDATE_IF_SCHEMA)
1018                     || name.equalsIgnoreCase(Constants.DOM_CHECK_CHAR_NORMALIZATION)
1019                     ) {
1020                     return (value.equals(Boolean.TRUE)) ? false : true;
1021             }//features whose parameter value can not be set to &#39;false&#39;
1022             else if( name.equalsIgnoreCase(Constants.DOM_ELEMENT_CONTENT_WHITESPACE)
1023                     || name.equalsIgnoreCase(SEND_PSVI)
1024                     ) {
1025                     return (value.equals(Boolean.TRUE)) ? true : false;
1026             }// if name is not among the above listed above -- its not recognized. return false
1027             else {
1028                 return false ;
1029             }
1030         }
1031                 else if (name.equalsIgnoreCase(Constants.DOM_ERROR_HANDLER)) {
1032             return (value instanceof DOMErrorHandler) ? true : false ;
1033         }
1034         else if (name.equalsIgnoreCase(Constants.DOM_RESOURCE_RESOLVER)) {
1035             return (value instanceof LSResourceResolver) ? true : false ;
1036         }
1037         else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_LOCATION)) {
1038             return (value instanceof String) ? true : false ;
1039         }
1040         else if (name.equalsIgnoreCase(Constants.DOM_SCHEMA_TYPE)) {
1041             // REVISIT: should null value be supported?
1042             // as of now we are only supporting W3C XML Schema and DTD.
1043             return ((value instanceof String) &amp;&amp;
1044                     (value.equals(Constants.NS_XMLSCHEMA) || value.equals(Constants.NS_DTD))) ? true : false;
1045         }
1046         else if (name.equalsIgnoreCase(ENTITY_RESOLVER)) {
1047             return (value instanceof XMLEntityResolver) ? true : false;
1048         }
1049         else if (name.equalsIgnoreCase(SYMBOL_TABLE)) {
1050             // Xerces Symbol Table
1051             return (value instanceof SymbolTable) ? true : false;
1052         }
1053         else if (name.equalsIgnoreCase (GRAMMAR_POOL)) {
1054             return (value instanceof XMLGrammarPool) ? true : false;
1055         }
1056         else {
1057             //false if the parameter is not recognized or the requested value is not supported.
1058             return false ;
1059         }
1060 
1061         } //canSetParameter
1062 
1063     /**
1064      *  DOM Level 3 CR - Experimental.
1065      *
1066      *  The list of the parameters supported by this
1067      * &lt;code&gt;DOMConfiguration&lt;/code&gt; object and for which at least one value
1068      * can be set by the application. Note that this list can also contain
1069      * parameter names defined outside this specification.
1070      */
1071         public DOMStringList getParameterNames() {
1072             if (fRecognizedParameters == null){
1073             List&lt;String&gt; parameters = new ArrayList&lt;&gt;();
1074 
1075                 //Add DOM recognized parameters
1076                 //REVISIT: Would have been nice to have a list of
1077                 //recognized paramters.
1078                 parameters.add(Constants.DOM_COMMENTS);
1079                 parameters.add(Constants.DOM_DATATYPE_NORMALIZATION);
1080                 parameters.add(Constants.DOM_CDATA_SECTIONS);
1081                 parameters.add(Constants.DOM_ENTITIES);
1082                 parameters.add(Constants.DOM_SPLIT_CDATA);
1083                 parameters.add(Constants.DOM_NAMESPACES);
1084                 parameters.add(Constants.DOM_VALIDATE);
1085 
1086                 parameters.add(Constants.DOM_INFOSET);
1087                 parameters.add(Constants.DOM_NORMALIZE_CHARACTERS);
1088                 parameters.add(Constants.DOM_CANONICAL_FORM);
1089                 parameters.add(Constants.DOM_VALIDATE_IF_SCHEMA);
1090                 parameters.add(Constants.DOM_CHECK_CHAR_NORMALIZATION);
1091                 parameters.add(Constants.DOM_WELLFORMED);
1092 
1093                 parameters.add(Constants.DOM_NAMESPACE_DECLARATIONS);
1094                 parameters.add(Constants.DOM_ELEMENT_CONTENT_WHITESPACE);
1095 
1096                 parameters.add(Constants.DOM_ERROR_HANDLER);
1097                 parameters.add(Constants.DOM_SCHEMA_TYPE);
1098                 parameters.add(Constants.DOM_SCHEMA_LOCATION);
1099                 parameters.add(Constants.DOM_RESOURCE_RESOLVER);
1100 
1101                 //Add recognized xerces features and properties
1102                 parameters.add(ENTITY_RESOLVER);
1103                 parameters.add(GRAMMAR_POOL);
1104                 parameters.add(SECURITY_MANAGER);
1105                 parameters.add(SYMBOL_TABLE);
1106                 parameters.add(SEND_PSVI);
1107 
1108                 fRecognizedParameters = new DOMStringListImpl(parameters);
1109 
1110             }
1111 
1112             return fRecognizedParameters;
1113         }//getParameterNames
1114 
1115     //
1116     // Protected methods
1117     //
1118 
1119     /**
1120      * reset all components before parsing
1121      */
1122     protected void reset() throws XNIException {
1123 
1124         if (fValidationManager != null)
1125             fValidationManager.reset();
1126 
1127         int count = fComponents.size();
1128         for (int i = 0; i &lt; count; i++) {
1129             XMLComponent c = fComponents.get(i);
1130             c.reset(this);
1131         }
1132 
1133     } // reset()
1134 
1135     /**
1136      * Check a property. If the property is known and supported, this method
1137      * simply returns. Otherwise, the appropriate exception is thrown.
1138      *
1139      * @param propertyId The unique identifier (URI) of the property
1140      *                   being set.
1141      * @exception com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException If the
1142      *            requested feature is not known or supported.
1143      */
1144     @Override
1145     protected PropertyState checkProperty(String propertyId)
1146         throws XMLConfigurationException {
1147 
1148         // special cases
1149         if (propertyId.startsWith(Constants.SAX_PROPERTY_PREFIX)) {
1150             final int suffixLength = propertyId.length() - Constants.SAX_PROPERTY_PREFIX.length();
1151 
1152             //
1153             // http://xml.org/sax/properties/xml-string
1154             // Value type: String
1155             // Access: read-only
1156             //   Get the literal string of characters associated with the
1157             //   current event.  If the parser recognises and supports this
1158             //   property but is not currently parsing text, it should return
1159             //   null (this is a good way to check for availability before the
1160             //   parse begins).
1161             //
1162             if (suffixLength == Constants.XML_STRING_PROPERTY.length() &amp;&amp;
1163                 propertyId.endsWith(Constants.XML_STRING_PROPERTY)) {
1164                 // REVISIT - we should probably ask xml-dev for a precise
1165                 // definition of what this is actually supposed to return, and
1166                 // in exactly which circumstances.
1167                 return PropertyState.NOT_SUPPORTED;
1168             }
1169         }
1170 
1171         // check property
1172         return super.checkProperty(propertyId);
1173 
1174     } // checkProperty(String)
1175 
1176 
1177     protected void addComponent(XMLComponent component) {
1178 
1179         // don&#39;t add a component more than once
1180         if (fComponents.contains(component)) {
1181             return;
1182         }
1183         fComponents.add(component);
1184 
1185         // register component&#39;s recognized features
1186         String[] recognizedFeatures = component.getRecognizedFeatures();
1187         addRecognizedFeatures(recognizedFeatures);
1188 
1189         // register component&#39;s recognized properties
1190         String[] recognizedProperties = component.getRecognizedProperties();
1191         addRecognizedProperties(recognizedProperties);
1192 
1193     } // addComponent(XMLComponent)
1194 
1195     protected ValidationManager createValidationManager(){
1196         return new ValidationManager();
1197     }
1198 
1199     protected final void setDTDValidatorFactory(String version) {
1200         if (&quot;1.1&quot;.equals(version)) {
1201             if (fCurrentDVFactory != fXML11DatatypeFactory) {
1202                 fCurrentDVFactory = fXML11DatatypeFactory;
1203                 setProperty(DTD_VALIDATOR_FACTORY_PROPERTY, fCurrentDVFactory);
1204             }
1205         }
1206         else if (fCurrentDVFactory != fDatatypeValidatorFactory) {
1207             fCurrentDVFactory = fDatatypeValidatorFactory;
1208             setProperty(DTD_VALIDATOR_FACTORY_PROPERTY, fCurrentDVFactory);
1209         }
1210     }
1211 
1212     private static DOMException newFeatureNotSupportedError(String name) {
1213         String msg =
1214             DOMMessageFormatter.formatMessage(
1215                 DOMMessageFormatter.DOM_DOMAIN,
1216                 &quot;FEATURE_NOT_SUPPORTED&quot;,
1217                 new Object[] { name });
1218         return new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);
1219     }
1220 
1221     private static DOMException newFeatureNotFoundError(String name) {
1222         String msg =
1223             DOMMessageFormatter.formatMessage(
1224                 DOMMessageFormatter.DOM_DOMAIN,
1225                 &quot;FEATURE_NOT_FOUND&quot;,
1226                 new Object[] { name });
1227         return new DOMException(DOMException.NOT_FOUND_ERR, msg);
1228     }
1229 
1230     private static DOMException newTypeMismatchError(String name) {
1231         String msg =
1232             DOMMessageFormatter.formatMessage(
1233                 DOMMessageFormatter.DOM_DOMAIN,
1234                 &quot;TYPE_MISMATCH_ERR&quot;,
1235                 new Object[] { name });
1236         return new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);
1237     }
1238 
1239 } // class DOMConfigurationImpl
    </pre>
  </body>
</html>
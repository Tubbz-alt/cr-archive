<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ClassGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CPInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ClassGenException.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ClassGen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
<span class="line-modified">!  * reserved comment block</span>
<span class="line-removed">-  * DO NOT REMOVE OR ALTER!</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 20,10 ***</span>
<span class="line-new-header">--- 19,11 ---</span>
   */
  package com.sun.org.apache.bcel.internal.generic;
  
  import java.util.ArrayList;
  import java.util.List;
<span class="line-added">+ import java.util.Objects;</span>
  
  import com.sun.org.apache.bcel.internal.Const;
  import com.sun.org.apache.bcel.internal.classfile.AccessFlags;
  import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
  import com.sun.org.apache.bcel.internal.classfile.Annotations;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,11 ***</span>
  /**
   * Template class for building up a java class. May be initialized with an
   * existing java class (file).
   *
   * @see JavaClass
<span class="line-modified">!  * @version $Id: ClassGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
   */
  public class ClassGen extends AccessFlags implements Cloneable {
  
      /* Corresponds to the fields found in a JavaClass object.
       */
<span class="line-new-header">--- 40,11 ---</span>
  /**
   * Template class for building up a java class. May be initialized with an
   * existing java class (file).
   *
   * @see JavaClass
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public class ClassGen extends AccessFlags implements Cloneable {
  
      /* Corresponds to the fields found in a JavaClass object.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,25 ***</span>
      private final List&lt;AnnotationEntryGen&gt; annotation_vec = new ArrayList&lt;&gt;();
  
      private static BCELComparator _cmp = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals(final Object o1, final Object o2) {</span>
              final ClassGen THIS = (ClassGen) o1;
              final ClassGen THAT = (ClassGen) o2;
<span class="line-modified">!             return THIS.getClassName().equals(THAT.getClassName());</span>
          }
  
          @Override
<span class="line-modified">!         public int hashCode(final Object o) {</span>
              final ClassGen THIS = (ClassGen) o;
              return THIS.getClassName().hashCode();
          }
      };
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Convenience constructor to set up some important values initially.</span>
       *
       * @param class_name fully qualified class name
       * @param super_class_name fully qualified superclass name
       * @param file_name source file name
       * @param access_flags access qualifiers
<span class="line-new-header">--- 64,26 ---</span>
      private final List&lt;AnnotationEntryGen&gt; annotation_vec = new ArrayList&lt;&gt;();
  
      private static BCELComparator _cmp = new BCELComparator() {
  
          @Override
<span class="line-modified">!         public boolean equals( final Object o1, final Object o2 ) {</span>
              final ClassGen THIS = (ClassGen) o1;
              final ClassGen THAT = (ClassGen) o2;
<span class="line-modified">!             return Objects.equals(THIS.getClassName(), THAT.getClassName());</span>
          }
  
<span class="line-added">+ </span>
          @Override
<span class="line-modified">!         public int hashCode( final Object o ) {</span>
              final ClassGen THIS = (ClassGen) o;
              return THIS.getClassName().hashCode();
          }
      };
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Convenience constructor to set up some important values initially.</span>
       *
       * @param class_name fully qualified class name
       * @param super_class_name fully qualified superclass name
       * @param file_name source file name
       * @param access_flags access qualifiers
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,12 ***</span>
                  addInterface(interface1);
              }
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Convenience constructor to set up some important values initially.</span>
       *
       * @param class_name fully qualified class name
       * @param super_class_name fully qualified superclass name
       * @param file_name source file name
       * @param access_flags access qualifiers
<span class="line-new-header">--- 109,12 ---</span>
                  addInterface(interface1);
              }
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Convenience constructor to set up some important values initially.</span>
       *
       * @param class_name fully qualified class name
       * @param super_class_name fully qualified superclass name
       * @param file_name source file name
       * @param access_flags access qualifiers
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,13 ***</span>
              final String[] interfaces) {
          this(class_name, super_class_name, file_name, access_flags, interfaces,
                  new ConstantPoolGen());
      }
  
      /**
       * Initialize with existing class.
<span class="line-removed">-      *</span>
       * @param clazz JavaClass object (e.g. read from file)
       */
      public ClassGen(final JavaClass clazz) {
          super(clazz.getAccessFlags());
          class_name_index = clazz.getClassNameIndex();
<span class="line-new-header">--- 124,13 ---</span>
              final String[] interfaces) {
          this(class_name, super_class_name, file_name, access_flags, interfaces,
                  new ConstantPoolGen());
      }
  
<span class="line-added">+ </span>
      /**
       * Initialize with existing class.
       * @param clazz JavaClass object (e.g. read from file)
       */
      public ClassGen(final JavaClass clazz) {
          super(clazz.getAccessFlags());
          class_name_index = clazz.getClassNameIndex();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,206 ***</span>
      }
  
      /**
       * Look for attributes representing annotations and unpack them.
       */
<span class="line-modified">!     private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {</span>
          final List&lt;AnnotationEntryGen&gt; annotationGenObjs = new ArrayList&lt;&gt;();
          for (final Attribute attr : attrs) {
<span class="line-modified">!             if (attr instanceof RuntimeVisibleAnnotations) {</span>
                  final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;
                  final AnnotationEntry[] annos = rva.getAnnotationEntries();
                  for (final AnnotationEntry a : annos) {
                      annotationGenObjs.add(new AnnotationEntryGen(a,
                              getConstantPool(), false));
                  }
<span class="line-removed">-             } else if (attr instanceof RuntimeInvisibleAnnotations) {</span>
<span class="line-removed">-                 final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;</span>
<span class="line-removed">-                 final AnnotationEntry[] annos = ria.getAnnotationEntries();</span>
<span class="line-removed">-                 for (final AnnotationEntry a : annos) {</span>
<span class="line-removed">-                     annotationGenObjs.add(new AnnotationEntryGen(a,</span>
<span class="line-removed">-                             getConstantPool(), false));</span>
<span class="line-removed">-                 }</span>
              }
          }
          return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);
      }
  
      /**
       * @return the (finally) built up Java class object.
       */
      public JavaClass getJavaClass() {
          final int[] interfaces = getInterfaces();
          final Field[] fields = getFields();
          final Method[] methods = getMethods();
<span class="line-modified">!         Attribute[] attributes;</span>
          if (annotation_vec.isEmpty()) {
              attributes = getAttributes();
          } else {
              // TODO: Sometime later, trash any attributes called &#39;RuntimeVisibleAnnotations&#39; or &#39;RuntimeInvisibleAnnotations&#39;
<span class="line-modified">!             final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());</span>
<span class="line-modified">!             attributes = new Attribute[attribute_vec.size() + annAttributes.length];</span>
              attribute_vec.toArray(attributes);
<span class="line-modified">!             System.arraycopy(annAttributes, 0, attributes, attribute_vec.size(), annAttributes.length);</span>
          }
          // Must be last since the above calls may still add something to it
          final ConstantPool _cp = this.cp.getFinalConstantPool();
          return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
                  super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);
      }
  
      /**
       * Add an interface to this class, i.e., this class has to implement it.
<span class="line-removed">-      *</span>
       * @param name interface to implement (fully qualified class name)
       */
<span class="line-modified">!     public final void addInterface(final String name) {</span>
          interface_vec.add(name);
      }
  
      /**
       * Remove an interface from this class.
<span class="line-removed">-      *</span>
       * @param name interface to remove (fully qualified name)
       */
<span class="line-modified">!     public void removeInterface(final String name) {</span>
          interface_vec.remove(name);
      }
  
      /**
       * @return major version number of class file
       */
      public int getMajor() {
          return major;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Set major version number of class file, default value is 45 (JDK 1.1)</span>
<span class="line-removed">-      *</span>
       * @param major major version number
       */
<span class="line-modified">!     public void setMajor(final int major) { // TODO could be package-protected - only called by test code</span>
          this.major = major;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Set minor version number of class file, default value is 3 (JDK 1.1)</span>
<span class="line-removed">-      *</span>
       * @param minor minor version number
       */
<span class="line-modified">!     public void setMinor(final int minor) {  // TODO could be package-protected - only called by test code</span>
          this.minor = minor;
      }
  
      /**
       * @return minor version number of class file
       */
      public int getMinor() {
          return minor;
      }
  
      /**
       * Add an attribute to this class.
<span class="line-removed">-      *</span>
       * @param a attribute to add
       */
<span class="line-modified">!     public final void addAttribute(final Attribute a) {</span>
          attribute_vec.add(a);
      }
  
<span class="line-modified">!     public final void addAnnotationEntry(final AnnotationEntryGen a) {</span>
          annotation_vec.add(a);
      }
  
      /**
       * Add a method to this class.
<span class="line-removed">-      *</span>
       * @param m method to add
       */
<span class="line-modified">!     public final void addMethod(final Method m) {</span>
          method_vec.add(m);
      }
  
      /**
       * Convenience method.
       *
<span class="line-modified">!      * Add an empty constructor to this class that does nothing but calling</span>
<span class="line-removed">-      * super().</span>
<span class="line-removed">-      *</span>
       * @param access_flags rights for constructor
       */
<span class="line-modified">!     public void addEmptyConstructor(final int access_flags) {</span>
          final InstructionList il = new InstructionList();
          il.append(InstructionConst.THIS); // Push `this&#39;
          il.append(new INVOKESPECIAL(cp.addMethodref(super_class_name, &quot;&lt;init&gt;&quot;, &quot;()V&quot;)));
          il.append(InstructionConst.RETURN);
          final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, &quot;&lt;init&gt;&quot;,
                  class_name, il, cp);
          mg.setMaxStack(1);
          addMethod(mg.getMethod());
      }
  
      /**
       * Add a field to this class.
<span class="line-removed">-      *</span>
       * @param f field to add
       */
<span class="line-modified">!     public final void addField(final Field f) {</span>
          field_vec.add(f);
      }
  
<span class="line-modified">!     public boolean containsField(final Field f) {</span>
          return field_vec.contains(f);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return field object with given name, or null</span>
       */
<span class="line-modified">!     public Field containsField(final String name) {</span>
          for (final Field f : field_vec) {
              if (f.getName().equals(name)) {
                  return f;
              }
          }
          return null;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return method object with given name and signature, or null</span>
       */
<span class="line-modified">!     public Method containsMethod(final String name, final String signature) {</span>
          for (final Method m : method_vec) {
              if (m.getName().equals(name) &amp;&amp; m.getSignature().equals(signature)) {
                  return m;
              }
          }
          return null;
      }
  
      /**
       * Remove an attribute from this class.
<span class="line-removed">-      *</span>
       * @param a attribute to remove
       */
<span class="line-modified">!     public void removeAttribute(final Attribute a) {</span>
          attribute_vec.remove(a);
      }
  
      /**
       * Remove a method from this class.
<span class="line-removed">-      *</span>
       * @param m method to remove
       */
<span class="line-modified">!     public void removeMethod(final Method m) {</span>
          method_vec.remove(m);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Replace given method with new one. If the old one does not exist add the</span>
<span class="line-modified">!      * new_ method to the class anyway.</span>
       */
<span class="line-modified">!     public void replaceMethod(final Method old, final Method new_) {</span>
          if (new_ == null) {
              throw new ClassGenException(&quot;Replacement method must not be null&quot;);
          }
          final int i = method_vec.indexOf(old);
          if (i &lt; 0) {
<span class="line-new-header">--- 167,211 ---</span>
      }
  
      /**
       * Look for attributes representing annotations and unpack them.
       */
<span class="line-modified">!     private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs)</span>
<span class="line-added">+     {</span>
          final List&lt;AnnotationEntryGen&gt; annotationGenObjs = new ArrayList&lt;&gt;();
          for (final Attribute attr : attrs) {
<span class="line-modified">!             if (attr instanceof RuntimeVisibleAnnotations)</span>
<span class="line-added">+             {</span>
                  final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;
                  final AnnotationEntry[] annos = rva.getAnnotationEntries();
                  for (final AnnotationEntry a : annos) {
                      annotationGenObjs.add(new AnnotationEntryGen(a,
                              getConstantPool(), false));
                  }
              }
<span class="line-added">+             else</span>
<span class="line-added">+                 if (attr instanceof RuntimeInvisibleAnnotations)</span>
<span class="line-added">+                 {</span>
<span class="line-added">+                     final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;</span>
<span class="line-added">+                     final AnnotationEntry[] annos = ria.getAnnotationEntries();</span>
<span class="line-added">+                     for (final AnnotationEntry a : annos) {</span>
<span class="line-added">+                         annotationGenObjs.add(new AnnotationEntryGen(a,</span>
<span class="line-added">+                                 getConstantPool(), false));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
          }
          return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);
      }
  
<span class="line-added">+ </span>
      /**
       * @return the (finally) built up Java class object.
       */
      public JavaClass getJavaClass() {
          final int[] interfaces = getInterfaces();
          final Field[] fields = getFields();
          final Method[] methods = getMethods();
<span class="line-modified">!         Attribute[] attributes = null;</span>
          if (annotation_vec.isEmpty()) {
              attributes = getAttributes();
          } else {
              // TODO: Sometime later, trash any attributes called &#39;RuntimeVisibleAnnotations&#39; or &#39;RuntimeInvisibleAnnotations&#39;
<span class="line-modified">!             final Attribute[] annAttributes  = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());</span>
<span class="line-modified">!             attributes = new Attribute[attribute_vec.size()+annAttributes.length];</span>
              attribute_vec.toArray(attributes);
<span class="line-modified">!             System.arraycopy(annAttributes,0,attributes,attribute_vec.size(),annAttributes.length);</span>
          }
          // Must be last since the above calls may still add something to it
          final ConstantPool _cp = this.cp.getFinalConstantPool();
          return new JavaClass(class_name_index, superclass_name_index, file_name, major, minor,
                  super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);
      }
  
<span class="line-added">+ </span>
      /**
       * Add an interface to this class, i.e., this class has to implement it.
       * @param name interface to implement (fully qualified class name)
       */
<span class="line-modified">!     public void addInterface( final String name ) {</span>
          interface_vec.add(name);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove an interface from this class.
       * @param name interface to remove (fully qualified name)
       */
<span class="line-modified">!     public void removeInterface( final String name ) {</span>
          interface_vec.remove(name);
      }
  
<span class="line-added">+ </span>
      /**
       * @return major version number of class file
       */
      public int getMajor() {
          return major;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Set major version number of class file, default value is 45 (JDK 1.1)</span>
       * @param major major version number
       */
<span class="line-modified">!     public void setMajor( final int major ) { // TODO could be package-protected - only called by test code</span>
          this.major = major;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Set minor version number of class file, default value is 3 (JDK 1.1)</span>
       * @param minor minor version number
       */
<span class="line-modified">!     public void setMinor( final int minor ) {  // TODO could be package-protected - only called by test code</span>
          this.minor = minor;
      }
  
      /**
       * @return minor version number of class file
       */
      public int getMinor() {
          return minor;
      }
  
<span class="line-added">+ </span>
      /**
       * Add an attribute to this class.
       * @param a attribute to add
       */
<span class="line-modified">!     public void addAttribute( final Attribute a ) {</span>
          attribute_vec.add(a);
      }
  
<span class="line-modified">!     public void addAnnotationEntry(final AnnotationEntryGen a) {</span>
          annotation_vec.add(a);
      }
  
<span class="line-added">+ </span>
      /**
       * Add a method to this class.
       * @param m method to add
       */
<span class="line-modified">!     public void addMethod( final Method m ) {</span>
          method_vec.add(m);
      }
  
<span class="line-added">+ </span>
      /**
       * Convenience method.
       *
<span class="line-modified">!      * Add an empty constructor to this class that does nothing but calling super().</span>
       * @param access_flags rights for constructor
       */
<span class="line-modified">!     public void addEmptyConstructor( final int access_flags ) {</span>
          final InstructionList il = new InstructionList();
          il.append(InstructionConst.THIS); // Push `this&#39;
          il.append(new INVOKESPECIAL(cp.addMethodref(super_class_name, &quot;&lt;init&gt;&quot;, &quot;()V&quot;)));
          il.append(InstructionConst.RETURN);
          final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, &quot;&lt;init&gt;&quot;,
                  class_name, il, cp);
          mg.setMaxStack(1);
          addMethod(mg.getMethod());
      }
  
<span class="line-added">+ </span>
      /**
       * Add a field to this class.
       * @param f field to add
       */
<span class="line-modified">!     public void addField( final Field f ) {</span>
          field_vec.add(f);
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public boolean containsField( final Field f ) {</span>
          return field_vec.contains(f);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return field object with given name, or null</span>
       */
<span class="line-modified">!     public Field containsField( final String name ) {</span>
          for (final Field f : field_vec) {
              if (f.getName().equals(name)) {
                  return f;
              }
          }
          return null;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return method object with given name and signature, or null</span>
       */
<span class="line-modified">!     public Method containsMethod( final String name, final String signature ) {</span>
          for (final Method m : method_vec) {
              if (m.getName().equals(name) &amp;&amp; m.getSignature().equals(signature)) {
                  return m;
              }
          }
          return null;
      }
  
<span class="line-added">+ </span>
      /**
       * Remove an attribute from this class.
       * @param a attribute to remove
       */
<span class="line-modified">!     public void removeAttribute( final Attribute a ) {</span>
          attribute_vec.remove(a);
      }
  
<span class="line-added">+ </span>
      /**
       * Remove a method from this class.
       * @param m method to remove
       */
<span class="line-modified">!     public void removeMethod( final Method m ) {</span>
          method_vec.remove(m);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Replace given method with new one. If the old one does not exist</span>
<span class="line-modified">!      * add the new_ method to the class anyway.</span>
       */
<span class="line-modified">!     public void replaceMethod( final Method old, final Method new_ ) {</span>
          if (new_ == null) {
              throw new ClassGenException(&quot;Replacement method must not be null&quot;);
          }
          final int i = method_vec.indexOf(old);
          if (i &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,15 ***</span>
          } else {
              method_vec.set(i, new_);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Replace given field with new one. If the old one does not exist add the</span>
<span class="line-modified">!      * new_ field to the class anyway.</span>
       */
<span class="line-modified">!     public void replaceField(final Field old, final Field new_) {</span>
          if (new_ == null) {
              throw new ClassGenException(&quot;Replacement method must not be null&quot;);
          }
          final int i = field_vec.indexOf(old);
          if (i &lt; 0) {
<span class="line-new-header">--- 379,15 ---</span>
          } else {
              method_vec.set(i, new_);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Replace given field with new one. If the old one does not exist</span>
<span class="line-modified">!      * add the new_ field to the class anyway.</span>
       */
<span class="line-modified">!     public void replaceField( final Field old, final Field new_ ) {</span>
          if (new_ == null) {
              throw new ClassGenException(&quot;Replacement method must not be null&quot;);
          }
          final int i = field_vec.indexOf(old);
          if (i &lt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,188 ***</span>
          } else {
              field_vec.set(i, new_);
          }
      }
  
      /**
       * Remove a field to this class.
<span class="line-removed">-      *</span>
       * @param f field to remove
       */
<span class="line-modified">!     public void removeField(final Field f) {</span>
          field_vec.remove(f);
      }
  
      public String getClassName() {
          return class_name;
      }
  
      public String getSuperclassName() {
          return super_class_name;
      }
  
      public String getFileName() {
          return file_name;
      }
  
<span class="line-modified">!     public void setClassName(final String name) {</span>
          class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
          class_name_index = cp.addClass(name);
      }
  
<span class="line-modified">!     public void setSuperclassName(final String name) {</span>
          super_class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
          superclass_name_index = cp.addClass(name);
      }
  
      public Method[] getMethods() {
          return method_vec.toArray(new Method[method_vec.size()]);
      }
  
<span class="line-modified">!     public void setMethods(final Method[] methods) {</span>
          method_vec.clear();
          for (final Method method : methods) {
              addMethod(method);
          }
      }
  
<span class="line-modified">!     public void setMethodAt(final Method method, final int pos) {</span>
          method_vec.set(pos, method);
      }
  
<span class="line-modified">!     public Method getMethodAt(final int pos) {</span>
          return method_vec.get(pos);
      }
  
      public String[] getInterfaceNames() {
          final int size = interface_vec.size();
          final String[] interfaces = new String[size];
          interface_vec.toArray(interfaces);
          return interfaces;
      }
  
      public int[] getInterfaces() {
          final int size = interface_vec.size();
          final int[] interfaces = new int[size];
          for (int i = 0; i &lt; size; i++) {
              interfaces[i] = cp.addClass(interface_vec.get(i));
          }
          return interfaces;
      }
  
      public Field[] getFields() {
          return field_vec.toArray(new Field[field_vec.size()]);
      }
  
      public Attribute[] getAttributes() {
          return attribute_vec.toArray(new Attribute[attribute_vec.size()]);
      }
  
      //  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?
      public AnnotationEntryGen[] getAnnotationEntries() {
          return annotation_vec.toArray(new AnnotationEntryGen[annotation_vec.size()]);
      }
  
      public ConstantPoolGen getConstantPool() {
          return cp;
      }
  
<span class="line-modified">!     public void setConstantPool(final ConstantPoolGen constant_pool) {</span>
          cp = constant_pool;
      }
  
<span class="line-modified">!     public void setClassNameIndex(final int class_name_index) {</span>
          this.class_name_index = class_name_index;
          class_name = cp.getConstantPool().getConstantString(class_name_index,
                  Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
      }
  
<span class="line-modified">!     public void setSuperclassNameIndex(final int superclass_name_index) {</span>
          this.superclass_name_index = superclass_name_index;
          super_class_name = cp.getConstantPool().getConstantString(superclass_name_index,
                  Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
      }
  
      public int getSuperclassNameIndex() {
          return superclass_name_index;
      }
  
      public int getClassNameIndex() {
          return class_name_index;
      }
  
      private List&lt;ClassObserver&gt; observers;
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Add observer for this object.</span>
       */
<span class="line-modified">!     public void addObserver(final ClassObserver o) {</span>
          if (observers == null) {
              observers = new ArrayList&lt;&gt;();
          }
          observers.add(o);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Remove observer for this object.</span>
       */
<span class="line-modified">!     public void removeObserver(final ClassObserver o) {</span>
          if (observers != null) {
              observers.remove(o);
          }
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Call notify() method on all observers. This method is not called</span>
<span class="line-modified">!      * automatically whenever the state has changed, but has to be called by the</span>
<span class="line-modified">!      * user after he has finished editing the object.</span>
       */
      public void update() {
          if (observers != null) {
              for (final ClassObserver observer : observers) {
                  observer.notify(this);
              }
          }
      }
  
      @Override
      public Object clone() {
          try {
              return super.clone();
          } catch (final CloneNotSupportedException e) {
              throw new Error(&quot;Clone Not Supported&quot;); // never happens
          }
      }
  
      /**
       * @return Comparison strategy object
       */
      public static BCELComparator getComparator() {
          return _cmp;
      }
  
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator(final BCELComparator comparator) {</span>
          _cmp = comparator;
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default two</span>
<span class="line-modified">!      * ClassGen objects are said to be equal when their class names are equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals(final Object obj) {</span>
          return _cmp.equals(this, obj);
      }
  
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy. By default</span>
<span class="line-modified">!      * return the hashcode of the class name.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
<span class="line-new-header">--- 395,213 ---</span>
          } else {
              field_vec.set(i, new_);
          }
      }
  
<span class="line-added">+ </span>
      /**
       * Remove a field to this class.
       * @param f field to remove
       */
<span class="line-modified">!     public void removeField( final Field f ) {</span>
          field_vec.remove(f);
      }
  
<span class="line-added">+ </span>
      public String getClassName() {
          return class_name;
      }
  
<span class="line-added">+ </span>
      public String getSuperclassName() {
          return super_class_name;
      }
  
<span class="line-added">+ </span>
      public String getFileName() {
          return file_name;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setClassName( final String name ) {</span>
          class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
          class_name_index = cp.addClass(name);
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setSuperclassName( final String name ) {</span>
          super_class_name = name.replace(&#39;/&#39;, &#39;.&#39;);
          superclass_name_index = cp.addClass(name);
      }
  
<span class="line-added">+ </span>
      public Method[] getMethods() {
          return method_vec.toArray(new Method[method_vec.size()]);
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setMethods( final Method[] methods ) {</span>
          method_vec.clear();
          for (final Method method : methods) {
              addMethod(method);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setMethodAt( final Method method, final int pos ) {</span>
          method_vec.set(pos, method);
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public Method getMethodAt( final int pos ) {</span>
          return method_vec.get(pos);
      }
  
<span class="line-added">+ </span>
      public String[] getInterfaceNames() {
          final int size = interface_vec.size();
          final String[] interfaces = new String[size];
          interface_vec.toArray(interfaces);
          return interfaces;
      }
  
<span class="line-added">+ </span>
      public int[] getInterfaces() {
          final int size = interface_vec.size();
          final int[] interfaces = new int[size];
          for (int i = 0; i &lt; size; i++) {
              interfaces[i] = cp.addClass(interface_vec.get(i));
          }
          return interfaces;
      }
  
<span class="line-added">+ </span>
      public Field[] getFields() {
          return field_vec.toArray(new Field[field_vec.size()]);
      }
  
<span class="line-added">+ </span>
      public Attribute[] getAttributes() {
          return attribute_vec.toArray(new Attribute[attribute_vec.size()]);
      }
  
      //  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?
      public AnnotationEntryGen[] getAnnotationEntries() {
          return annotation_vec.toArray(new AnnotationEntryGen[annotation_vec.size()]);
      }
  
<span class="line-added">+ </span>
      public ConstantPoolGen getConstantPool() {
          return cp;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setConstantPool( final ConstantPoolGen constant_pool ) {</span>
          cp = constant_pool;
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setClassNameIndex( final int class_name_index ) {</span>
          this.class_name_index = class_name_index;
          class_name = cp.getConstantPool().getConstantString(class_name_index,
                  Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
      }
  
<span class="line-modified">! </span>
<span class="line-added">+     public void setSuperclassNameIndex( final int superclass_name_index ) {</span>
          this.superclass_name_index = superclass_name_index;
          super_class_name = cp.getConstantPool().getConstantString(superclass_name_index,
                  Const.CONSTANT_Class).replace(&#39;/&#39;, &#39;.&#39;);
      }
  
<span class="line-added">+ </span>
      public int getSuperclassNameIndex() {
          return superclass_name_index;
      }
  
<span class="line-added">+ </span>
      public int getClassNameIndex() {
          return class_name_index;
      }
  
      private List&lt;ClassObserver&gt; observers;
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Add observer for this object.</span>
       */
<span class="line-modified">!     public void addObserver( final ClassObserver o ) {</span>
          if (observers == null) {
              observers = new ArrayList&lt;&gt;();
          }
          observers.add(o);
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Remove observer for this object.</span>
       */
<span class="line-modified">!     public void removeObserver( final ClassObserver o ) {</span>
          if (observers != null) {
              observers.remove(o);
          }
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Call notify() method on all observers. This method is not called</span>
<span class="line-modified">!      * automatically whenever the state has changed, but has to be</span>
<span class="line-modified">!      * called by the user after he has finished editing the object.</span>
       */
      public void update() {
          if (observers != null) {
              for (final ClassObserver observer : observers) {
                  observer.notify(this);
              }
          }
      }
  
<span class="line-added">+ </span>
      @Override
      public Object clone() {
          try {
              return super.clone();
          } catch (final CloneNotSupportedException e) {
              throw new Error(&quot;Clone Not Supported&quot;); // never happens
          }
      }
  
<span class="line-added">+ </span>
      /**
       * @return Comparison strategy object
       */
      public static BCELComparator getComparator() {
          return _cmp;
      }
  
<span class="line-added">+ </span>
      /**
       * @param comparator Comparison strategy object
       */
<span class="line-modified">!     public static void setComparator( final BCELComparator comparator ) {</span>
          _cmp = comparator;
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default two ClassGen objects are said to be equal when</span>
<span class="line-added">+      * their class names are equal.</span>
       *
       * @see java.lang.Object#equals(java.lang.Object)
       */
      @Override
<span class="line-modified">!     public boolean equals( final Object obj ) {</span>
          return _cmp.equals(this, obj);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Return value as defined by given BCELComparator strategy.</span>
<span class="line-modified">!      * By default return the hashcode of the class name.</span>
       *
       * @see java.lang.Object#hashCode()
       */
      @Override
      public int hashCode() {
</pre>
<center><a href="CPInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="ClassGenException.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
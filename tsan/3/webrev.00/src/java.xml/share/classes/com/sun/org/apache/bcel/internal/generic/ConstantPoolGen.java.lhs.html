<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/ConstantPoolGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.util.HashMap;
 23 import java.util.Map;
 24 
 25 import com.sun.org.apache.bcel.internal.Const;
 26 import com.sun.org.apache.bcel.internal.classfile.Constant;
 27 import com.sun.org.apache.bcel.internal.classfile.ConstantCP;
 28 import com.sun.org.apache.bcel.internal.classfile.ConstantClass;
 29 import com.sun.org.apache.bcel.internal.classfile.ConstantDouble;
 30 import com.sun.org.apache.bcel.internal.classfile.ConstantFieldref;
 31 import com.sun.org.apache.bcel.internal.classfile.ConstantFloat;
 32 import com.sun.org.apache.bcel.internal.classfile.ConstantInteger;
 33 import com.sun.org.apache.bcel.internal.classfile.ConstantInterfaceMethodref;
 34 import com.sun.org.apache.bcel.internal.classfile.ConstantInvokeDynamic;
 35 import com.sun.org.apache.bcel.internal.classfile.ConstantLong;
 36 import com.sun.org.apache.bcel.internal.classfile.ConstantMethodref;
 37 import com.sun.org.apache.bcel.internal.classfile.ConstantNameAndType;
 38 import com.sun.org.apache.bcel.internal.classfile.ConstantPool;
 39 import com.sun.org.apache.bcel.internal.classfile.ConstantString;
 40 import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;
 41 
 42 /**
<a name="2" id="anc2"></a><span class="line-modified"> 43  * This class is used to build up a constant pool. The user adds constants via</span>
<span class="line-modified"> 44  * `addXXX&#39; methods, `addString&#39;, `addClass&#39;, etc.. These methods return an</span>
<span class="line-modified"> 45  * index into the constant pool. Finally, `getFinalConstantPool()&#39; returns the</span>
<span class="line-modified"> 46  * constant pool built up. Intermediate versions of the constant pool can be</span>

 47  * obtained with `getConstantPool()&#39;. A constant pool has capacity for
<a name="3" id="anc3"></a><span class="line-modified"> 48  * Constants.MAX_SHORT entries. Note that the first (0) is used by the JVM and</span>
<span class="line-modified"> 49  * that Double and Long constants need two slots.</span>
 50  *
<a name="4" id="anc4"></a><span class="line-removed"> 51  * @version $Id: ConstantPoolGen.java 1749603 2016-06-21 20:50:19Z ggregory $</span>
 52  * @see Constant
<a name="5" id="anc5"></a>
 53  */
 54 public class ConstantPoolGen {
 55 
 56     private static final int DEFAULT_BUFFER_SIZE = 256;
 57     private int size;
 58     private Constant[] constants;
 59     private int index = 1; // First entry (0) used by JVM
 60 
 61     private static final String METHODREF_DELIM = &quot;:&quot;;
 62     private static final String IMETHODREF_DELIM = &quot;#&quot;;
 63     private static final String FIELDREF_DELIM = &quot;&amp;&quot;;
 64     private static final String NAT_DELIM = &quot;%&quot;; // Name and Type
 65 
 66     private static class Index {
 67 
 68         final int index;
 69 
<a name="6" id="anc6"></a>
 70         Index(final int i) {
 71             index = i;
 72         }
 73     }
 74 
<a name="7" id="anc7"></a>
 75     /**
 76      * Initialize with given array of constants.
 77      *
 78      * @param cs array of given constants, new ones will be appended
 79      */
 80     public ConstantPoolGen(final Constant[] cs) {
 81         final StringBuilder sb = new StringBuilder(DEFAULT_BUFFER_SIZE);
 82 
 83         size = Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64);
 84         constants = new Constant[size];
 85 
 86         System.arraycopy(cs, 0, constants, 0, cs.length);
 87         if (cs.length &gt; 0) {
 88             index = cs.length;
 89         }
 90 
<a name="8" id="anc8"></a>
 91         for (int i = 1; i &lt; index; i++) {
 92             final Constant c = constants[i];
 93             if (c instanceof ConstantString) {
 94                 final ConstantString s = (ConstantString) c;
 95                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
 96                 final String key = u8.getBytes();
 97                 if (!string_table.containsKey(key)) {
 98                     string_table.put(key, new Index(i));
 99                 }
100             } else if (c instanceof ConstantClass) {
101                 final ConstantClass s = (ConstantClass) c;
102                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
103                 final String key = u8.getBytes();
104                 if (!class_table.containsKey(key)) {
105                     class_table.put(key, new Index(i));
106                 }
107             } else if (c instanceof ConstantNameAndType) {
108                 final ConstantNameAndType n = (ConstantNameAndType) c;
109                 final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
110                 final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
111 
112                 sb.append(u8.getBytes());
113                 sb.append(NAT_DELIM);
114                 sb.append(u8_2.getBytes());
115                 final String key = sb.toString();
116                 sb.delete(0, sb.length());
117 
118                 if (!n_a_t_table.containsKey(key)) {
119                     n_a_t_table.put(key, new Index(i));
120                 }
121             } else if (c instanceof ConstantUtf8) {
122                 final ConstantUtf8 u = (ConstantUtf8) c;
123                 final String key = u.getBytes();
124                 if (!utf8_table.containsKey(key)) {
125                     utf8_table.put(key, new Index(i));
126                 }
127             } else if (c instanceof ConstantCP) {
128                 final ConstantCP m = (ConstantCP) c;
129                 String class_name;
130                 ConstantUtf8 u8;
131 
132                 if (c instanceof ConstantInvokeDynamic) {
133                     class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());
134                     // since name can&#39;t begin with digit, can  use
135                     // METHODREF_DELIM with out fear of duplicates.
136                 } else {
<a name="9" id="anc9"></a><span class="line-modified">137                     final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];</span>
138                     u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
139                     class_name = u8.getBytes().replace(&#39;/&#39;, &#39;.&#39;);
140                 }
141 
142                 final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
143                 u8 = (ConstantUtf8) constants[n.getNameIndex()];
144                 final String method_name = u8.getBytes();
145                 u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
146                 final String signature = u8.getBytes();
147 
148                 String delim = METHODREF_DELIM;
149                 if (c instanceof ConstantInterfaceMethodref) {
150                     delim = IMETHODREF_DELIM;
151                 } else if (c instanceof ConstantFieldref) {
152                     delim = FIELDREF_DELIM;
153                 }
154 
155                 sb.append(class_name);
156                 sb.append(delim);
157                 sb.append(method_name);
158                 sb.append(delim);
159                 sb.append(signature);
160                 final String key = sb.toString();
161                 sb.delete(0, sb.length());
162 
163                 if (!cp_table.containsKey(key)) {
164                     cp_table.put(key, new Index(i));
165                 }
166             } else if (c == null) { // entries may be null
167                 // nothing to do
168             } else if (c instanceof ConstantInteger) {
169                 // nothing to do
170             } else if (c instanceof ConstantLong) {
171                 // nothing to do
172             } else if (c instanceof ConstantFloat) {
173                 // nothing to do
174             } else if (c instanceof ConstantDouble) {
175                 // nothing to do
176             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {
177                 // TODO should this be handled somehow?
178             } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {
179                 // TODO should this be handled somehow?
<a name="10" id="anc10"></a>



180             } else {
181                 assert false : &quot;Unexpected constant type: &quot; + c.getClass().getName();
182             }
183         }
184     }
185 
<a name="11" id="anc11"></a>
186     /**
187      * Initialize with given constant pool.
188      */
189     public ConstantPoolGen(final ConstantPool cp) {
190         this(cp.getConstantPool());
191     }
192 
<a name="12" id="anc12"></a>
193     /**
194      * Create empty constant pool.
195      */
196     public ConstantPoolGen() {
197         size = DEFAULT_BUFFER_SIZE;
198         constants = new Constant[size];
199     }
200 
<a name="13" id="anc13"></a><span class="line-modified">201     /**</span>
<span class="line-modified">202      * Resize internal array of constants.</span>
203      */
204     protected void adjustSize() {
205         if (index + 3 &gt;= size) {
206             final Constant[] cs = constants;
207             size *= 2;
208             constants = new Constant[size];
209             System.arraycopy(cs, 0, constants, 0, index);
210         }
211     }
212 
213     private final Map&lt;String, Index&gt; string_table = new HashMap&lt;&gt;();
214 
<a name="14" id="anc14"></a>
215     /**
216      * Look for ConstantString in ConstantPool containing String `str&#39;.
217      *
218      * @param str String to search for
219      * @return index on success, -1 otherwise
220      */
<a name="15" id="anc15"></a><span class="line-modified">221     public int lookupString(final String str) {</span>
222         final Index index = string_table.get(str);
223         return (index != null) ? index.index : -1;
224     }
225 
<a name="16" id="anc16"></a>
226     /**
<a name="17" id="anc17"></a><span class="line-modified">227      * Add a new String constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">228      * there.</span>
229      *
230      * @param str String to add
231      * @return index of entry
232      */
<a name="18" id="anc18"></a><span class="line-modified">233     public int addString(final String str) {</span>
234         int ret;
235         if ((ret = lookupString(str)) != -1) {
236             return ret; // Already in CP
237         }
238         final int utf8 = addUtf8(str);
239         adjustSize();
240         final ConstantString s = new ConstantString(utf8);
241         ret = index;
242         constants[index++] = s;
243         if (!string_table.containsKey(str)) {
244             string_table.put(str, new Index(ret));
245         }
246         return ret;
247     }
248 
249     private final Map&lt;String, Index&gt; class_table = new HashMap&lt;&gt;();
250 
<a name="19" id="anc19"></a>
251     /**
252      * Look for ConstantClass in ConstantPool named `str&#39;.
253      *
254      * @param str String to search for
255      * @return index on success, -1 otherwise
256      */
<a name="20" id="anc20"></a><span class="line-modified">257     public int lookupClass(final String str) {</span>
258         final Index index = class_table.get(str.replace(&#39;.&#39;, &#39;/&#39;));
259         return (index != null) ? index.index : -1;
260     }
261 
<a name="21" id="anc21"></a><span class="line-modified">262     private int addClass_(final String clazz) {</span>

263         int ret;
264         if ((ret = lookupClass(clazz)) != -1) {
265             return ret; // Already in CP
266         }
267         adjustSize();
268         final ConstantClass c = new ConstantClass(addUtf8(clazz));
269         ret = index;
270         constants[index++] = c;
271         if (!class_table.containsKey(clazz)) {
272             class_table.put(clazz, new Index(ret));
273         }
274         return ret;
275     }
276 
<a name="22" id="anc22"></a>
277     /**
<a name="23" id="anc23"></a><span class="line-modified">278      * Add a new Class reference to the ConstantPool, if it is not already in</span>
<span class="line-removed">279      * there.</span>
280      *
281      * @param str Class to add
282      * @return index of entry
283      */
<a name="24" id="anc24"></a><span class="line-modified">284     public int addClass(final String str) {</span>
285         return addClass_(str.replace(&#39;.&#39;, &#39;/&#39;));
286     }
287 
<a name="25" id="anc25"></a>
288     /**
289      * Add a new Class reference to the ConstantPool for a given type.
290      *
291      * @param type Class to add
292      * @return index of entry
293      */
<a name="26" id="anc26"></a><span class="line-modified">294     public int addClass(final ObjectType type) {</span>
295         return addClass(type.getClassName());
296     }
297 
<a name="27" id="anc27"></a>
298     /**
<a name="28" id="anc28"></a><span class="line-modified">299      * Add a reference to an array class (e.g. String[][]) as needed by</span>
<span class="line-modified">300      * MULTIANEWARRAY instruction, e.g. to the ConstantPool.</span>
301      *
302      * @param type type of array class
303      * @return index of entry
304      */
<a name="29" id="anc29"></a><span class="line-modified">305     public int addArrayClass(final ArrayType type) {</span>
306         return addClass_(type.getSignature());
307     }
308 
<a name="30" id="anc30"></a>
309     /**
310      * Look for ConstantInteger in ConstantPool.
311      *
312      * @param n integer number to look for
313      * @return index on success, -1 otherwise
314      */
<a name="31" id="anc31"></a><span class="line-modified">315     public int lookupInteger(final int n) {</span>
316         for (int i = 1; i &lt; index; i++) {
317             if (constants[i] instanceof ConstantInteger) {
318                 final ConstantInteger c = (ConstantInteger) constants[i];
319                 if (c.getBytes() == n) {
320                     return i;
321                 }
322             }
323         }
324         return -1;
325     }
326 
<a name="32" id="anc32"></a>
327     /**
<a name="33" id="anc33"></a><span class="line-modified">328      * Add a new Integer constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">329      * there.</span>
330      *
331      * @param n integer number to add
332      * @return index of entry
333      */
<a name="34" id="anc34"></a><span class="line-modified">334     public int addInteger(final int n) {</span>
335         int ret;
336         if ((ret = lookupInteger(n)) != -1) {
337             return ret; // Already in CP
338         }
339         adjustSize();
340         ret = index;
341         constants[index++] = new ConstantInteger(n);
342         return ret;
343     }
344 
<a name="35" id="anc35"></a>
345     /**
346      * Look for ConstantFloat in ConstantPool.
347      *
348      * @param n Float number to look for
349      * @return index on success, -1 otherwise
350      */
<a name="36" id="anc36"></a><span class="line-modified">351     public int lookupFloat(final float n) {</span>
352         final int bits = Float.floatToIntBits(n);
353         for (int i = 1; i &lt; index; i++) {
354             if (constants[i] instanceof ConstantFloat) {
355                 final ConstantFloat c = (ConstantFloat) constants[i];
356                 if (Float.floatToIntBits(c.getBytes()) == bits) {
357                     return i;
358                 }
359             }
360         }
361         return -1;
362     }
363 
<a name="37" id="anc37"></a>
364     /**
<a name="38" id="anc38"></a><span class="line-modified">365      * Add a new Float constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">366      * there.</span>
367      *
368      * @param n Float number to add
369      * @return index of entry
370      */
<a name="39" id="anc39"></a><span class="line-modified">371     public int addFloat(final float n) {</span>
372         int ret;
373         if ((ret = lookupFloat(n)) != -1) {
374             return ret; // Already in CP
375         }
376         adjustSize();
377         ret = index;
378         constants[index++] = new ConstantFloat(n);
379         return ret;
380     }
381 
382     private final Map&lt;String, Index&gt; utf8_table = new HashMap&lt;&gt;();
383 
<a name="40" id="anc40"></a>
384     /**
385      * Look for ConstantUtf8 in ConstantPool.
386      *
387      * @param n Utf8 string to look for
388      * @return index on success, -1 otherwise
389      */
<a name="41" id="anc41"></a><span class="line-modified">390     public int lookupUtf8(final String n) {</span>
391         final Index index = utf8_table.get(n);
392         return (index != null) ? index.index : -1;
393     }
394 
<a name="42" id="anc42"></a>
395     /**
<a name="43" id="anc43"></a><span class="line-modified">396      * Add a new Utf8 constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">397      * there.</span>
398      *
399      * @param n Utf8 string to add
400      * @return index of entry
401      */
<a name="44" id="anc44"></a><span class="line-modified">402     public int addUtf8(final String n) {</span>
403         int ret;
404         if ((ret = lookupUtf8(n)) != -1) {
405             return ret; // Already in CP
406         }
407         adjustSize();
408         ret = index;
409         constants[index++] = new ConstantUtf8(n);
410         if (!utf8_table.containsKey(n)) {
411             utf8_table.put(n, new Index(ret));
412         }
413         return ret;
414     }
415 
<a name="45" id="anc45"></a>
416     /**
417      * Look for ConstantLong in ConstantPool.
418      *
419      * @param n Long number to look for
420      * @return index on success, -1 otherwise
421      */
<a name="46" id="anc46"></a><span class="line-modified">422     public int lookupLong(final long n) {</span>
423         for (int i = 1; i &lt; index; i++) {
424             if (constants[i] instanceof ConstantLong) {
425                 final ConstantLong c = (ConstantLong) constants[i];
426                 if (c.getBytes() == n) {
427                     return i;
428                 }
429             }
430         }
431         return -1;
432     }
433 
<a name="47" id="anc47"></a>
434     /**
<a name="48" id="anc48"></a><span class="line-modified">435      * Add a new long constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">436      * there.</span>
437      *
438      * @param n Long number to add
439      * @return index of entry
440      */
<a name="49" id="anc49"></a><span class="line-modified">441     public int addLong(final long n) {</span>
442         int ret;
443         if ((ret = lookupLong(n)) != -1) {
444             return ret; // Already in CP
445         }
446         adjustSize();
447         ret = index;
448         constants[index] = new ConstantLong(n);
449         index += 2; // Wastes one entry according to spec
450         return ret;
451     }
452 
<a name="50" id="anc50"></a>
453     /**
454      * Look for ConstantDouble in ConstantPool.
455      *
456      * @param n Double number to look for
457      * @return index on success, -1 otherwise
458      */
<a name="51" id="anc51"></a><span class="line-modified">459     public int lookupDouble(final double n) {</span>
460         final long bits = Double.doubleToLongBits(n);
461         for (int i = 1; i &lt; index; i++) {
462             if (constants[i] instanceof ConstantDouble) {
463                 final ConstantDouble c = (ConstantDouble) constants[i];
464                 if (Double.doubleToLongBits(c.getBytes()) == bits) {
465                     return i;
466                 }
467             }
468         }
469         return -1;
470     }
471 
<a name="52" id="anc52"></a>
472     /**
<a name="53" id="anc53"></a><span class="line-modified">473      * Add a new double constant to the ConstantPool, if it is not already in</span>
<span class="line-removed">474      * there.</span>
475      *
476      * @param n Double number to add
477      * @return index of entry
478      */
<a name="54" id="anc54"></a><span class="line-modified">479     public int addDouble(final double n) {</span>
480         int ret;
481         if ((ret = lookupDouble(n)) != -1) {
482             return ret; // Already in CP
483         }
484         adjustSize();
485         ret = index;
486         constants[index] = new ConstantDouble(n);
487         index += 2; // Wastes one entry according to spec
488         return ret;
489     }
490 
491     private final Map&lt;String, Index&gt; n_a_t_table = new HashMap&lt;&gt;();
492 
<a name="55" id="anc55"></a>
493     /**
494      * Look for ConstantNameAndType in ConstantPool.
495      *
496      * @param name of variable/method
497      * @param signature of variable/method
498      * @return index on success, -1 otherwise
499      */
<a name="56" id="anc56"></a><span class="line-modified">500     public int lookupNameAndType(final String name, final String signature) {</span>
501         final Index _index = n_a_t_table.get(name + NAT_DELIM + signature);
502         return (_index != null) ? _index.index : -1;
503     }
504 
<a name="57" id="anc57"></a>
505     /**
506      * Add a new NameAndType constant to the ConstantPool if it is not already
507      * in there.
508      *
509      * @param name Name string to add
510      * @param signature signature string to add
511      * @return index of entry
512      */
<a name="58" id="anc58"></a><span class="line-modified">513     public int addNameAndType(final String name, final String signature) {</span>
514         int ret;
515         int name_index;
516         int signature_index;
517         if ((ret = lookupNameAndType(name, signature)) != -1) {
518             return ret; // Already in CP
519         }
520         adjustSize();
521         name_index = addUtf8(name);
522         signature_index = addUtf8(signature);
523         ret = index;
524         constants[index++] = new ConstantNameAndType(name_index, signature_index);
525         final String key = name + NAT_DELIM + signature;
526         if (!n_a_t_table.containsKey(key)) {
527             n_a_t_table.put(key, new Index(ret));
528         }
529         return ret;
530     }
531 
532     private final Map&lt;String, Index&gt; cp_table = new HashMap&lt;&gt;();
533 
<a name="59" id="anc59"></a>
534     /**
535      * Look for ConstantMethodref in ConstantPool.
536      *
537      * @param class_name Where to find method
538      * @param method_name Guess what
539      * @param signature return and argument types
540      * @return index on success, -1 otherwise
541      */
<a name="60" id="anc60"></a><span class="line-modified">542     public int lookupMethodref(final String class_name, final String method_name, final String signature) {</span>
543         final Index index = cp_table.get(class_name + METHODREF_DELIM + method_name
544                 + METHODREF_DELIM + signature);
545         return (index != null) ? index.index : -1;
546     }
547 
<a name="61" id="anc61"></a><span class="line-modified">548     public int lookupMethodref(final MethodGen method) {</span>

549         return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());
550     }
551 
<a name="62" id="anc62"></a>
552     /**
<a name="63" id="anc63"></a><span class="line-modified">553      * Add a new Methodref constant to the ConstantPool, if it is not already in</span>
<span class="line-modified">554      * there.</span>
555      *
556      * @param class_name class name string to add
557      * @param method_name method name string to add
558      * @param signature method signature string to add
559      * @return index of entry
560      */
<a name="64" id="anc64"></a><span class="line-modified">561     public int addMethodref(final String class_name, final String method_name, final String signature) {</span>
562         int ret;
563         int class_index;
564         int name_and_type_index;
565         if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {
566             return ret; // Already in CP
567         }
568         adjustSize();
569         name_and_type_index = addNameAndType(method_name, signature);
570         class_index = addClass(class_name);
571         ret = index;
572         constants[index++] = new ConstantMethodref(class_index, name_and_type_index);
573         final String key = class_name + METHODREF_DELIM + method_name + METHODREF_DELIM + signature;
574         if (!cp_table.containsKey(key)) {
575             cp_table.put(key, new Index(ret));
576         }
577         return ret;
578     }
579 
<a name="65" id="anc65"></a><span class="line-modified">580     public int addMethodref(final MethodGen method) {</span>

581         return addMethodref(method.getClassName(), method.getName(), method.getSignature());
582     }
583 
<a name="66" id="anc66"></a>
584     /**
585      * Look for ConstantInterfaceMethodref in ConstantPool.
586      *
587      * @param class_name Where to find method
588      * @param method_name Guess what
589      * @param signature return and argument types
590      * @return index on success, -1 otherwise
591      */
<a name="67" id="anc67"></a><span class="line-modified">592     public int lookupInterfaceMethodref(final String class_name, final String method_name, final String signature) {</span>
593         final Index index = cp_table.get(class_name + IMETHODREF_DELIM + method_name
594                 + IMETHODREF_DELIM + signature);
595         return (index != null) ? index.index : -1;
596     }
597 
<a name="68" id="anc68"></a><span class="line-modified">598     public int lookupInterfaceMethodref(final MethodGen method) {</span>

599         return lookupInterfaceMethodref(method.getClassName(), method.getName(), method
600                 .getSignature());
601     }
602 
<a name="69" id="anc69"></a>
603     /**
<a name="70" id="anc70"></a><span class="line-modified">604      * Add a new InterfaceMethodref constant to the ConstantPool, if it is not</span>
<span class="line-modified">605      * already in there.</span>
606      *
607      * @param class_name class name string to add
608      * @param method_name method name string to add
609      * @param signature signature string to add
610      * @return index of entry
611      */
<a name="71" id="anc71"></a><span class="line-modified">612     public int addInterfaceMethodref(final String class_name, final String method_name, final String signature) {</span>
613         int ret;
614         int class_index;
615         int name_and_type_index;
616         if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {
617             return ret; // Already in CP
618         }
619         adjustSize();
620         class_index = addClass(class_name);
621         name_and_type_index = addNameAndType(method_name, signature);
622         ret = index;
623         constants[index++] = new ConstantInterfaceMethodref(class_index, name_and_type_index);
624         final String key = class_name + IMETHODREF_DELIM + method_name + IMETHODREF_DELIM + signature;
625         if (!cp_table.containsKey(key)) {
626             cp_table.put(key, new Index(ret));
627         }
628         return ret;
629     }
630 
<a name="72" id="anc72"></a><span class="line-modified">631     public int addInterfaceMethodref(final MethodGen method) {</span>

632         return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());
633     }
634 
<a name="73" id="anc73"></a>
635     /**
636      * Look for ConstantFieldref in ConstantPool.
637      *
638      * @param class_name Where to find method
639      * @param field_name Guess what
640      * @param signature return and argument types
641      * @return index on success, -1 otherwise
642      */
<a name="74" id="anc74"></a><span class="line-modified">643     public int lookupFieldref(final String class_name, final String field_name, final String signature) {</span>
644         final Index index = cp_table.get(class_name + FIELDREF_DELIM + field_name
645                 + FIELDREF_DELIM + signature);
646         return (index != null) ? index.index : -1;
647     }
648 
<a name="75" id="anc75"></a>
649     /**
<a name="76" id="anc76"></a><span class="line-modified">650      * Add a new Fieldref constant to the ConstantPool, if it is not already in</span>
<span class="line-modified">651      * there.</span>
652      *
653      * @param class_name class name string to add
654      * @param field_name field name string to add
655      * @param signature signature string to add
656      * @return index of entry
657      */
<a name="77" id="anc77"></a><span class="line-modified">658     public int addFieldref(final String class_name, final String field_name, final String signature) {</span>
659         int ret;
660         int class_index;
661         int name_and_type_index;
662         if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {
663             return ret; // Already in CP
664         }
665         adjustSize();
666         class_index = addClass(class_name);
667         name_and_type_index = addNameAndType(field_name, signature);
668         ret = index;
669         constants[index++] = new ConstantFieldref(class_index, name_and_type_index);
670         final String key = class_name + FIELDREF_DELIM + field_name + FIELDREF_DELIM + signature;
671         if (!cp_table.containsKey(key)) {
672             cp_table.put(key, new Index(ret));
673         }
674         return ret;
675     }
676 
<a name="78" id="anc78"></a>
677     /**
678      * @param i index in constant pool
679      * @return constant pool entry at index i
680      */
<a name="79" id="anc79"></a><span class="line-modified">681     public Constant getConstant(final int i) {</span>
682         return constants[i];
683     }
684 
<a name="80" id="anc80"></a>
685     /**
686      * Use with care!
687      *
688      * @param i index in constant pool
689      * @param c new constant pool entry at index i
690      */
<a name="81" id="anc81"></a><span class="line-modified">691     public void setConstant(final int i, final Constant c) {</span>
692         constants[i] = c;
693     }
694 
<a name="82" id="anc82"></a>
695     /**
696      * @return intermediate constant pool
697      */
698     public ConstantPool getConstantPool() {
699         return new ConstantPool(constants);
700     }
701 
<a name="83" id="anc83"></a>
702     /**
703      * @return current size of constant pool
704      */
705     public int getSize() {
706         return index;
707     }
708 
<a name="84" id="anc84"></a>
709     /**
710      * @return constant pool with proper length
711      */
712     public ConstantPool getFinalConstantPool() {
713         final Constant[] cs = new Constant[index];
714         System.arraycopy(constants, 0, cs, 0, index);
715         return new ConstantPool(cs);
716     }
717 
<a name="85" id="anc85"></a>
718     /**
719      * @return String representation.
720      */
721     @Override
722     public String toString() {
723         final StringBuilder buf = new StringBuilder();
724         for (int i = 1; i &lt; index; i++) {
725             buf.append(i).append(&quot;)&quot;).append(constants[i]).append(&quot;\n&quot;);
726         }
727         return buf.toString();
728     }
729 
<a name="86" id="anc86"></a><span class="line-modified">730     /**</span>
<span class="line-modified">731      * Import constant from another ConstantPool and return new index.</span>
732      */
<a name="87" id="anc87"></a><span class="line-modified">733     public int addConstant(final Constant c, final ConstantPoolGen cp) {</span>
734         final Constant[] constants = cp.getConstantPool().getConstantPool();
735         switch (c.getTag()) {
736             case Const.CONSTANT_String: {
737                 final ConstantString s = (ConstantString) c;
738                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];
739                 return addString(u8.getBytes());
740             }
741             case Const.CONSTANT_Class: {
742                 final ConstantClass s = (ConstantClass) c;
743                 final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];
744                 return addClass(u8.getBytes());
745             }
746             case Const.CONSTANT_NameAndType: {
747                 final ConstantNameAndType n = (ConstantNameAndType) c;
748                 final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];
749                 final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];
750                 return addNameAndType(u8.getBytes(), u8_2.getBytes());
751             }
752             case Const.CONSTANT_Utf8:
753                 return addUtf8(((ConstantUtf8) c).getBytes());
754             case Const.CONSTANT_Double:
755                 return addDouble(((ConstantDouble) c).getBytes());
756             case Const.CONSTANT_Float:
757                 return addFloat(((ConstantFloat) c).getBytes());
758             case Const.CONSTANT_Long:
759                 return addLong(((ConstantLong) c).getBytes());
760             case Const.CONSTANT_Integer:
761                 return addInteger(((ConstantInteger) c).getBytes());
762             case Const.CONSTANT_InterfaceMethodref:
763             case Const.CONSTANT_Methodref:
764             case Const.CONSTANT_Fieldref: {
765                 final ConstantCP m = (ConstantCP) c;
766                 final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];
767                 final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];
768                 ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];
769                 final String class_name = u8.getBytes().replace(&#39;/&#39;, &#39;.&#39;);
770                 u8 = (ConstantUtf8) constants[n.getNameIndex()];
771                 final String name = u8.getBytes();
772                 u8 = (ConstantUtf8) constants[n.getSignatureIndex()];
773                 final String signature = u8.getBytes();
774                 switch (c.getTag()) {
775                     case Const.CONSTANT_InterfaceMethodref:
776                         return addInterfaceMethodref(class_name, name, signature);
777                     case Const.CONSTANT_Methodref:
778                         return addMethodref(class_name, name, signature);
779                     case Const.CONSTANT_Fieldref:
780                         return addFieldref(class_name, name, signature);
781                     default: // Never reached
782                         throw new RuntimeException(&quot;Unknown constant type &quot; + c);
783                 }
784             }
785             default: // Never reached
786                 throw new RuntimeException(&quot;Unknown constant type &quot; + c);
787         }
788     }
789 }
<a name="88" id="anc88"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="88" type="hidden" />
</body>
</html>
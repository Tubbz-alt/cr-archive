<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/xalan/internal/xsltc/compiler/XPathParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.org.apache.xalan.internal.xsltc.compiler;
  27 
  28 import com.sun.java_cup.internal.runtime.*;
  29 import com.sun.org.apache.xalan.internal.xsltc.DOM;
  30 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
  31 import com.sun.org.apache.xalan.internal.xsltc.runtime.Operators;
  32 import com.sun.org.apache.xml.internal.dtm.Axis;
  33 import com.sun.org.apache.xml.internal.dtm.DTM;
  34 import java.util.ArrayList;
  35 import java.util.List;
  36 import java.util.Stack;
  37 
  38 /**
  39  * CUP v0.10j generated parser.
  40  * This class was generated by CUP v0.10j on Thu Oct 06 10:09:26 PDT 2005.
  41  */
  42 public class XPathParser extends lr_parser {
  43 
  44   /** Default constructor. */
  45   public XPathParser() {super();}
  46 
  47   /** Constructor which sets the default scanner. */
  48   public XPathParser(Scanner s) {super(s);}
  49 
  50   /** Production table. */
  51   protected static final short _production_table[][] =
  52     unpackFromStrings(new String[] {
  53     &quot;\000\215\000\002\002\004\000\002\003\004\000\002\003&quot; +
  54     &quot;\004\000\002\036\003\000\002\036\005\000\002\037\003&quot; +
  55     &quot;\000\002\037\004\000\002\037\003\000\002\037\005\000&quot; +
  56     &quot;\002\037\005\000\002\037\004\000\002\037\003\000\002&quot; +
  57     &quot;\035\006\000\002\035\010\000\002\040\006\000\002\041&quot; +
  58     &quot;\003\000\002\041\005\000\002\041\005\000\002\042\003&quot; +
  59     &quot;\000\002\042\004\000\002\042\003\000\002\042\004\000&quot; +
  60     &quot;\002\042\004\000\002\042\005\000\002\042\004\000\002&quot; +
  61     &quot;\042\005\000\002\043\003\000\002\043\003\000\002\043&quot; +
  62     &quot;\003\000\002\043\003\000\002\043\003\000\002\044\003&quot; +
  63     &quot;\000\002\044\003\000\002\054\003\000\002\054\004\000&quot; +
  64     &quot;\002\054\004\000\002\045\003\000\002\045\004\000\002&quot; +
  65     &quot;\007\005\000\002\004\003\000\002\012\003\000\002\012&quot; +
  66     &quot;\005\000\002\013\003\000\002\013\005\000\002\014\003&quot; +
  67     &quot;\000\002\014\005\000\002\014\005\000\002\015\003\000&quot; +
  68     &quot;\002\015\005\000\002\015\005\000\002\015\005\000\002&quot; +
  69     &quot;\015\005\000\002\016\003\000\002\016\005\000\002\016&quot; +
  70     &quot;\005\000\002\017\003\000\002\017\005\000\002\017\005&quot; +
  71     &quot;\000\002\017\005\000\002\020\003\000\002\020\004\000&quot; +
  72     &quot;\002\024\003\000\002\024\005\000\002\025\003\000\002&quot; +
  73     &quot;\025\003\000\002\025\005\000\002\025\005\000\002\006&quot; +
  74     &quot;\003\000\002\006\003\000\002\027\003\000\002\027\005&quot; +
  75     &quot;\000\002\027\003\000\002\031\003\000\002\031\004\000&quot; +
  76     &quot;\002\031\003\000\002\030\005\000\002\032\004\000\002&quot; +
  77     &quot;\011\003\000\002\011\004\000\002\011\005\000\002\011&quot; +
  78     &quot;\004\000\002\011\003\000\002\053\004\000\002\053\003&quot; +
  79     &quot;\000\002\052\003\000\002\052\003\000\002\052\003\000&quot; +
  80     &quot;\002\052\003\000\002\052\003\000\002\052\003\000\002&quot; +
  81     &quot;\052\003\000\002\052\003\000\002\052\003\000\002\052&quot; +
  82     &quot;\003\000\002\052\003\000\002\052\003\000\002\052\003&quot; +
  83     &quot;\000\002\026\003\000\002\026\003\000\002\010\003\000&quot; +
  84     &quot;\002\010\004\000\002\023\003\000\002\023\005\000\002&quot; +
  85     &quot;\023\003\000\002\023\003\000\002\023\003\000\002\023&quot; +
  86     &quot;\003\000\002\021\004\000\002\022\005\000\002\022\006&quot; +
  87     &quot;\000\002\046\003\000\002\046\005\000\002\050\003\000&quot; +
  88     &quot;\002\051\003\000\002\005\003\000\002\033\003\000\002&quot; +
  89     &quot;\033\003\000\002\033\003\000\002\033\003\000\002\033&quot; +
  90     &quot;\006\000\002\033\003\000\002\034\003\000\002\034\003&quot; +
  91     &quot;\000\002\047\003\000\002\047\003\000\002\047\003\000&quot; +
  92     &quot;\002\047\003\000\002\047\003\000\002\047\003\000\002&quot; +
  93     &quot;\047\003\000\002\047\003\000\002\047\003\000\002\047&quot; +
  94     &quot;\003\000\002\047\003\000\002\047\003\000\002\047\003&quot; +
  95     &quot;\000\002\047\003\000\002\047\003\000\002\047\003\000&quot; +
  96     &quot;\002\047\003\000\002\047\003&quot; });
  97 
  98   /** Access to production table. */
  99   public short[][] production_table() {return _production_table;}
 100 
 101   /** Parse-action table. */
 102   protected static final short[][] _action_table =
 103     unpackFromStrings(new String[] {
 104     &quot;\000\307\000\006\066\006\067\005\001\002\000\004\002&quot; +
 105     &quot;\311\001\002\000\110\004\061\005\111\011\071\013\103&quot; +
 106     &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot; +
 107     &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot; +
 108     &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot; +
 109     &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot; +
 110     &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot; +
 111     &quot;\070\004\013\013\027\016\020\021\023\032\031\033\040&quot; +
 112     &quot;\035\034\036\033\037\046\040\047\041\051\044\015\045&quot; +
 113     &quot;\014\046\016\047\036\050\037\051\044\052\025\053\050&quot; +
 114     &quot;\054\043\055\041\056\035\057\030\060\045\061\021\062&quot; +
 115     &quot;\012\063\042\001\002\000\006\002\ufffe\010\306\001\002&quot; +
 116     &quot;\000\004\002\000\001\002\000\014\002\uffe7\004\uffe7\006&quot; +
 117     &quot;\uffe7\010\uffe7\021\uffe7\001\002\000\054\002\uff7a\004\uff7a&quot; +
 118     &quot;\006\uff7a\007\uff7a\010\uff7a\012\uff7a\013\uff7a\014\uff7a\021&quot; +
 119     &quot;\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027\uff7a&quot; +
 120     &quot;\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a\001&quot; +
 121     &quot;\002\000\070\002\ufffc\010\ufffc\013\027\016\020\032\031&quot; +
 122     &quot;\033\040\035\034\036\113\037\141\040\047\041\051\044&quot; +
 123     &quot;\015\045\014\046\016\047\036\050\037\051\044\052\025&quot; +
 124     &quot;\053\050\054\043\055\041\056\035\057\030\060\045\061&quot; +
 125     &quot;\021\062\012\063\042\001\002\000\014\002\uffe3\004\uffe3&quot; +
 126     &quot;\006\uffe3\010\uffe3\021\uffe3\001\002\000\014\002\uffe4\004&quot; +
 127     &quot;\uffe4\006\uffe4\010\uffe4\021\uffe4\001\002\000\004\011\302&quot; +
 128     &quot;\001\002\000\012\002\ufffa\004\277\010\ufffa\021\276\001&quot; +
 129     &quot;\002\000\062\013\uffe0\032\uffe0\033\uffe0\035\uffe0\036\uffe0&quot; +
 130     &quot;\037\uffe0\040\uffe0\041\uffe0\044\uffe0\045\uffe0\046\uffe0\047&quot; +
 131     &quot;\uffe0\050\uffe0\051\uffe0\052\uffe0\053\uffe0\054\uffe0\055\uffe0&quot; +
 132     &quot;\056\uffe0\057\uffe0\060\uffe0\061\uffe0\062\uffe0\063\uffe0\001&quot; +
 133     &quot;\002\000\054\002\uff7b\004\uff7b\006\uff7b\007\uff7b\010\uff7b&quot; +
 134     &quot;\012\uff7b\013\uff7b\014\uff7b\021\uff7b\022\uff7b\023\uff7b\024&quot; +
 135     &quot;\uff7b\025\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b&quot; +
 136     &quot;\033\uff7b\042\uff7b\043\uff7b\001\002\000\062\013\027\032&quot; +
 137     &quot;\031\033\040\035\034\036\113\037\141\040\047\041\051&quot; +
 138     &quot;\044\015\045\014\046\016\047\036\050\037\051\044\052&quot; +
 139     &quot;\170\053\166\054\043\055\041\056\035\057\030\060\045&quot; +
 140     &quot;\061\021\062\012\063\042\001\002\000\064\013\027\016&quot; +
 141     &quot;\020\032\031\033\040\035\034\036\113\037\141\040\047&quot; +
 142     &quot;\041\051\044\015\045\014\046\016\047\036\050\037\051&quot; +
 143     &quot;\044\052\025\053\050\054\043\055\041\056\035\057\030&quot; +
 144     &quot;\060\045\061\021\062\012\063\042\001\002\000\012\002&quot; +
 145     &quot;\ufff2\004\266\010\ufff2\021\265\001\002\000\016\002\uff7f&quot; +
 146     &quot;\004\uff7f\006\uff7f\010\uff7f\020\264\021\uff7f\001\002\000&quot; +
 147     &quot;\006\002\ufff6\010\ufff6\001\002\000\014\002\uffe2\004\uffe2&quot; +
 148     &quot;\006\uffe2\010\uffe2\021\uffe2\001\002\000\054\002\uff7d\004&quot; +
 149     &quot;\uff7d\006\uff7d\007\uff7d\010\uff7d\012\uff7d\013\uff7d\014\uff7d&quot; +
 150     &quot;\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025\uff7d\026\uff7d\027&quot; +
 151     &quot;\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d\042\uff7d\043\uff7d&quot; +
 152     &quot;\001\002\000\056\002\uff85\004\uff85\006\uff85\007\uff85\010&quot; +
 153     &quot;\uff85\011\uff85\012\uff85\013\uff85\014\uff85\021\uff85\022\uff85&quot; +
 154     &quot;\023\uff85\024\uff85\025\uff85\026\uff85\027\uff85\030\uff85\031&quot; +
 155     &quot;\uff85\032\uff85\033\uff85\042\uff85\043\uff85\001\002\000\014&quot; +
 156     &quot;\002\uffed\004\uffed\006\055\010\uffed\021\uffed\001\002\000&quot; +
 157     &quot;\016\002\uff75\004\uff75\006\uff75\010\uff75\011\260\021\uff75&quot; +
 158     &quot;\001\002\000\056\002\uff86\004\uff86\006\uff86\007\uff86\010&quot; +
 159     &quot;\uff86\011\uff86\012\uff86\013\uff86\014\uff86\021\uff86\022\uff86&quot; +
 160     &quot;\023\uff86\024\uff86\025\uff86\026\uff86\027\uff86\030\uff86\031&quot; +
 161     &quot;\uff86\032\uff86\033\uff86\042\uff86\043\uff86\001\002\000\054&quot; +
 162     &quot;\002\uff7e\004\uff7e\006\uff7e\007\uff7e\010\uff7e\012\uff7e\013&quot; +
 163     &quot;\uff7e\014\uff7e\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e&quot; +
 164     &quot;\026\uff7e\027\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042&quot; +
 165     &quot;\uff7e\043\uff7e\001\002\000\054\002\uff77\004\uff77\006\uff77&quot; +
 166     &quot;\007\uff77\010\uff77\012\uff77\013\uff77\014\uff77\021\uff77\022&quot; +
 167     &quot;\uff77\023\uff77\024\uff77\025\uff77\026\uff77\027\uff77\030\uff77&quot; +
 168     &quot;\031\uff77\032\uff77\033\uff77\042\uff77\043\uff77\001\002\000&quot; +
 169     &quot;\054\002\uff76\004\uff76\006\uff76\007\uff76\010\uff76\012\uff76&quot; +
 170     &quot;\013\uff76\014\uff76\021\uff76\022\uff76\023\uff76\024\uff76\025&quot; +
 171     &quot;\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76&quot; +
 172     &quot;\042\uff76\043\uff76\001\002\000\056\002\uff84\004\uff84\006&quot; +
 173     &quot;\uff84\007\uff84\010\uff84\011\uff84\012\uff84\013\uff84\014\uff84&quot; +
 174     &quot;\021\uff84\022\uff84\023\uff84\024\uff84\025\uff84\026\uff84\027&quot; +
 175     &quot;\uff84\030\uff84\031\uff84\032\uff84\033\uff84\042\uff84\043\uff84&quot; +
 176     &quot;\001\002\000\054\002\uff81\004\uff81\006\uff81\007\uff81\010&quot; +
 177     &quot;\uff81\012\uff81\013\uff81\014\uff81\021\uff81\022\uff81\023\uff81&quot; +
 178     &quot;\024\uff81\025\uff81\026\uff81\027\uff81\030\uff81\031\uff81\032&quot; +
 179     &quot;\uff81\033\uff81\042\uff81\043\uff81\001\002\000\054\002\uff78&quot; +
 180     &quot;\004\uff78\006\uff78\007\uff78\010\uff78\012\uff78\013\uff78\014&quot; +
 181     &quot;\uff78\021\uff78\022\uff78\023\uff78\024\uff78\025\uff78\026\uff78&quot; +
 182     &quot;\027\uff78\030\uff78\031\uff78\032\uff78\033\uff78\042\uff78\043&quot; +
 183     &quot;\uff78\001\002\000\054\002\uff82\004\uff82\006\uff82\007\uff82&quot; +
 184     &quot;\010\uff82\012\uff82\013\uff82\014\uff82\021\uff82\022\uff82\023&quot; +
 185     &quot;\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030\uff82\031\uff82&quot; +
 186     &quot;\032\uff82\033\uff82\042\uff82\043\uff82\001\002\000\054\002&quot; +
 187     &quot;\uff79\004\uff79\006\uff79\007\uff79\010\uff79\012\uff79\013\uff79&quot; +
 188     &quot;\014\uff79\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026&quot; +
 189     &quot;\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79&quot; +
 190     &quot;\043\uff79\001\002\000\054\002\uff7c\004\uff7c\006\uff7c\007&quot; +
 191     &quot;\uff7c\010\uff7c\012\uff7c\013\uff7c\014\uff7c\021\uff7c\022\uff7c&quot; +
 192     &quot;\023\uff7c\024\uff7c\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031&quot; +
 193     &quot;\uff7c\032\uff7c\033\uff7c\042\uff7c\043\uff7c\001\002\000\016&quot; +
 194     &quot;\002\uff83\004\uff83\006\uff83\010\uff83\011\253\021\uff83\001&quot; +
 195     &quot;\002\000\014\002\uffe5\004\uffe5\006\uffe5\010\uffe5\021\uffe5&quot; +
 196     &quot;\001\002\000\016\002\uff80\004\uff80\006\uff80\010\uff80\020&quot; +
 197     &quot;\252\021\uff80\001\002\000\014\002\uffe6\004\uffe6\006\uffe6&quot; +
 198     &quot;\010\uffe6\021\uffe6\001\002\000\014\002\uffe1\004\uffe1\006&quot; +
 199     &quot;\uffe1\010\uffe1\021\uffe1\001\002\000\014\002\uffef\004\uffef&quot; +
 200     &quot;\006\055\010\uffef\021\uffef\001\002\000\054\002\uffdd\004&quot; +
 201     &quot;\uffdd\006\055\007\uffdd\010\uffdd\012\uffdd\013\uffdd\014\uffdd&quot; +
 202     &quot;\021\uffdd\022\uffdd\023\uffdd\024\uffdd\025\uffdd\026\uffdd\027&quot; +
 203     &quot;\uffdd\030\uffdd\031\uffdd\032\uffdd\033\uffdd\042\uffdd\043\uffdd&quot; +
 204     &quot;\001\002\000\110\004\061\005\111\011\071\013\103\015&quot; +
 205     &quot;\134\016\066\017\106\021\070\031\075\032\031\033\040&quot; +
 206     &quot;\034\057\035\034\036\113\037\141\040\142\041\145\044&quot; +
 207     &quot;\063\045\062\046\065\047\115\050\123\051\136\052\077&quot; +
 208     &quot;\053\143\054\131\055\125\056\116\057\104\060\140\061&quot; +
 209     &quot;\067\062\060\063\127\064\132\065\072\001\002\000\012&quot; +
 210     &quot;\002\uffee\004\uffee\010\uffee\021\uffee\001\002\000\054\002&quot; +
 211     &quot;\uff9a\004\uff9a\006\uff9a\007\uff9a\010\uff9a\012\uff9a\013\uff9a&quot; +
 212     &quot;\014\uff9a\021\uff9a\022\uff9a\023\uff9a\024\uff9a\025\uff9a\026&quot; +
 213     &quot;\uff9a\027\uff9a\030\uff9a\031\uff9a\032\uff9a\033\uff9a\042\uff9a&quot; +
 214     &quot;\043\uff9a\001\002\000\060\002\uff7a\004\uff7a\006\uff7a\007&quot; +
 215     &quot;\uff7a\010\uff7a\011\uff7a\012\uff7a\013\uff7a\014\uff7a\020\uffa5&quot; +
 216     &quot;\021\uff7a\022\uff7a\023\uff7a\024\uff7a\025\uff7a\026\uff7a\027&quot; +
 217     &quot;\uff7a\030\uff7a\031\uff7a\032\uff7a\033\uff7a\042\uff7a\043\uff7a&quot; +
 218     &quot;\001\002\000\126\002\uffb9\005\111\007\uffb9\010\uffb9\012&quot; +
 219     &quot;\uffb9\013\103\014\uffb9\016\066\017\106\022\uffb9\023\uffb9&quot; +
 220     &quot;\024\uffb9\025\uffb9\026\uffb9\027\uffb9\030\uffb9\031\uffb9\032&quot; +
 221     &quot;\031\033\040\035\034\036\113\037\141\040\142\041\145&quot; +
 222     &quot;\042\uffb9\043\uffb9\044\063\045\062\046\065\047\115\050&quot; +
 223     &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
 224     &quot;\057\104\060\140\061\067\062\060\063\127\001\002\000&quot; +
 225     &quot;\054\002\uff89\004\uff89\006\uff89\007\uff89\010\uff89\012\uff89&quot; +
 226     &quot;\013\uff89\014\uff89\021\uff89\022\uff89\023\uff89\024\uff89\025&quot; +
 227     &quot;\uff89\026\uff89\027\uff89\030\uff89\031\uff89\032\uff89\033\uff89&quot; +
 228     &quot;\042\uff89\043\uff89\001\002\000\054\002\uff8b\004\uff8b\006&quot; +
 229     &quot;\uff8b\007\uff8b\010\uff8b\012\uff8b\013\uff8b\014\uff8b\021\uff8b&quot; +
 230     &quot;\022\uff8b\023\uff8b\024\uff8b\025\uff8b\026\uff8b\027\uff8b\030&quot; +
 231     &quot;\uff8b\031\uff8b\032\uff8b\033\uff8b\042\uff8b\043\uff8b\001\002&quot; +
 232     &quot;\000\032\002\uffd5\007\uffd5\012\uffd5\014\uffd5\022\uffd5\023&quot; +
 233     &quot;\uffd5\024\221\025\222\026\223\027\224\042\uffd5\043\uffd5&quot; +
 234     &quot;\001\002\000\004\011\245\001\002\000\062\013\uffae\032&quot; +
 235     &quot;\uffae\033\uffae\035\uffae\036\uffae\037\uffae\040\uffae\041\uffae&quot; +
 236     &quot;\044\uffae\045\uffae\046\uffae\047\uffae\050\uffae\051\uffae\052&quot; +
 237     &quot;\uffae\053\uffae\054\uffae\055\uffae\056\uffae\057\uffae\060\uffae&quot; +
 238     &quot;\061\uffae\062\uffae\063\uffae\001\002\000\060\002\uff7b\004&quot; +
 239     &quot;\uff7b\006\uff7b\007\uff7b\010\uff7b\011\uff7b\012\uff7b\013\uff7b&quot; +
 240     &quot;\014\uff7b\020\uffa6\021\uff7b\022\uff7b\023\uff7b\024\uff7b\025&quot; +
 241     &quot;\uff7b\026\uff7b\027\uff7b\030\uff7b\031\uff7b\032\uff7b\033\uff7b&quot; +
 242     &quot;\042\uff7b\043\uff7b\001\002\000\070\005\111\013\103\016&quot; +
 243     &quot;\066\017\106\032\031\033\040\035\034\036\113\037\141&quot; +
 244     &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
 245     &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
 246     &quot;\057\104\060\140\061\067\062\060\063\127\001\002\000&quot; +
 247     &quot;\110\004\061\005\111\011\071\013\103\015\134\016\066&quot; +
 248     &quot;\017\106\021\070\031\075\032\031\033\040\034\057\035&quot; +
 249     &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
 250     &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
 251     &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
 252     &quot;\063\127\064\132\065\072\001\002\000\054\002\uff99\004&quot; +
 253     &quot;\uff99\006\uff99\007\uff99\010\uff99\012\uff99\013\uff99\014\uff99&quot; +
 254     &quot;\021\uff99\022\uff99\023\uff99\024\uff99\025\uff99\026\uff99\027&quot; +
 255     &quot;\uff99\030\uff99\031\uff99\032\uff99\033\uff99\042\uff99\043\uff99&quot; +
 256     &quot;\001\002\000\046\002\uffb7\007\uffb7\010\uffb7\012\uffb7\013&quot; +
 257     &quot;\uffb7\014\uffb7\022\uffb7\023\uffb7\024\uffb7\025\uffb7\026\uffb7&quot; +
 258     &quot;\027\uffb7\030\uffb7\031\uffb7\032\uffb7\033\uffb7\042\uffb7\043&quot; +
 259     &quot;\uffb7\001\002\000\054\002\uff97\004\uff97\006\uff97\007\uff97&quot; +
 260     &quot;\010\uff97\012\uff97\013\uff97\014\uff97\021\uff97\022\uff97\023&quot; +
 261     &quot;\uff97\024\uff97\025\uff97\026\uff97\027\uff97\030\uff97\031\uff97&quot; +
 262     &quot;\032\uff97\033\uff97\042\uff97\043\uff97\001\002\000\110\004&quot; +
 263     &quot;\061\005\111\011\071\013\103\015\134\016\066\017\106&quot; +
 264     &quot;\021\070\031\075\032\031\033\040\034\057\035\034\036&quot; +
 265     &quot;\113\037\141\040\142\041\145\044\063\045\062\046\065&quot; +
 266     &quot;\047\115\050\123\051\136\052\077\053\143\054\131\055&quot; +
 267     &quot;\125\056\116\057\104\060\140\061\067\062\060\063\127&quot; +
 268     &quot;\064\132\065\072\001\002\000\016\002\uffd9\007\uffd9\012&quot; +
 269     &quot;\uffd9\014\uffd9\042\uffd9\043\234\001\002\000\060\002\uff7f&quot; +
 270     &quot;\004\uff7f\006\uff7f\007\uff7f\010\uff7f\011\uff7f\012\uff7f\013&quot; +
 271     &quot;\uff7f\014\uff7f\020\uffaa\021\uff7f\022\uff7f\023\uff7f\024\uff7f&quot; +
 272     &quot;\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031\uff7f\032\uff7f\033&quot; +
 273     &quot;\uff7f\042\uff7f\043\uff7f\001\002\000\062\013\103\032\031&quot; +
 274     &quot;\033\040\035\034\036\113\037\141\040\142\041\145\044&quot; +
 275     &quot;\063\045\062\046\065\047\036\050\037\051\044\052\170&quot; +
 276     &quot;\053\166\054\043\055\041\056\035\057\030\060\045\061&quot; +
 277     &quot;\021\062\012\063\042\001\002\000\004\020\236\001\002&quot; +
 278     &quot;\000\014\002\uffda\007\uffda\012\uffda\014\uffda\042\232\001&quot; +
 279     &quot;\002\000\054\002\uff88\004\uff88\006\uff88\007\uff88\010\uff88&quot; +
 280     &quot;\012\uff88\013\uff88\014\uff88\021\uff88\022\uff88\023\uff88\024&quot; +
 281     &quot;\uff88\025\uff88\026\uff88\027\uff88\030\uff88\031\uff88\032\uff88&quot; +
 282     &quot;\033\uff88\042\uff88\043\uff88\001\002\000\060\002\uff7d\004&quot; +
 283     &quot;\uff7d\006\uff7d\007\uff7d\010\uff7d\011\uff7d\012\uff7d\013\uff7d&quot; +
 284     &quot;\014\uff7d\020\uffa8\021\uff7d\022\uff7d\023\uff7d\024\uff7d\025&quot; +
 285     &quot;\uff7d\026\uff7d\027\uff7d\030\uff7d\031\uff7d\032\uff7d\033\uff7d&quot; +
 286     &quot;\042\uff7d\043\uff7d\001\002\000\022\002\uffd7\007\uffd7\012&quot; +
 287     &quot;\uffd7\014\uffd7\022\216\023\217\042\uffd7\043\uffd7\001\002&quot; +
 288     &quot;\000\052\002\uff9f\004\uff9f\007\uff9f\010\uff9f\012\uff9f\013&quot; +
 289     &quot;\uff9f\014\uff9f\021\uff9f\022\uff9f\023\uff9f\024\uff9f\025\uff9f&quot; +
 290     &quot;\026\uff9f\027\uff9f\030\uff9f\031\uff9f\032\uff9f\033\uff9f\042&quot; +
 291     &quot;\uff9f\043\uff9f\001\002\000\054\002\uffb4\004\uffb4\006\055&quot; +
 292     &quot;\007\uffb4\010\uffb4\012\uffb4\013\uffb4\014\uffb4\021\uffb4\022&quot; +
 293     &quot;\uffb4\023\uffb4\024\uffb4\025\uffb4\026\uffb4\027\uffb4\030\uffb4&quot; +
 294     &quot;\031\uffb4\032\uffb4\033\uffb4\042\uffb4\043\uffb4\001\002\000&quot; +
 295     &quot;\046\002\uffbd\007\uffbd\010\uffbd\012\uffbd\013\uffbd\014\uffbd&quot; +
 296     &quot;\022\uffbd\023\uffbd\024\uffbd\025\uffbd\026\uffbd\027\uffbd\030&quot; +
 297     &quot;\uffbd\031\uffbd\032\uffbd\033\uffbd\042\uffbd\043\uffbd\001\002&quot; +
 298     &quot;\000\052\002\uffa0\004\uffa0\007\uffa0\010\uffa0\012\uffa0\013&quot; +
 299     &quot;\uffa0\014\uffa0\021\uffa0\022\uffa0\023\uffa0\024\uffa0\025\uffa0&quot; +
 300     &quot;\026\uffa0\027\uffa0\030\uffa0\031\uffa0\032\uffa0\033\uffa0\042&quot; +
 301     &quot;\uffa0\043\uffa0\001\002\000\036\002\uffd2\007\uffd2\012\uffd2&quot; +
 302     &quot;\014\uffd2\022\uffd2\023\uffd2\024\uffd2\025\uffd2\026\uffd2\027&quot; +
 303     &quot;\uffd2\030\211\031\212\042\uffd2\043\uffd2\001\002\000\056&quot; +
 304     &quot;\002\uff75\004\uff75\006\uff75\007\uff75\010\uff75\011\uff75\012&quot; +
 305     &quot;\uff75\013\uff75\014\uff75\021\uff75\022\uff75\023\uff75\024\uff75&quot; +
 306     &quot;\025\uff75\026\uff75\027\uff75\030\uff75\031\uff75\032\uff75\033&quot; +
 307     &quot;\uff75\042\uff75\043\uff75\001\002\000\044\002\uffca\007\uffca&quot; +
 308     &quot;\012\uffca\013\uffca\014\uffca\022\uffca\023\uffca\024\uffca\025&quot; +
 309     &quot;\uffca\026\uffca\027\uffca\030\uffca\031\uffca\032\uffca\033\uffca&quot; +
 310     &quot;\042\uffca\043\uffca\001\002\000\060\002\uff77\004\uff77\006&quot; +
 311     &quot;\uff77\007\uff77\010\uff77\011\uff77\012\uff77\013\uff77\014\uff77&quot; +
 312     &quot;\020\uffa2\021\uff77\022\uff77\023\uff77\024\uff77\025\uff77\026&quot; +
 313     &quot;\uff77\027\uff77\030\uff77\031\uff77\032\uff77\033\uff77\042\uff77&quot; +
 314     &quot;\043\uff77\001\002\000\060\002\uff7e\004\uff7e\006\uff7e\007&quot; +
 315     &quot;\uff7e\010\uff7e\011\uff7e\012\uff7e\013\uff7e\014\uff7e\020\uffa9&quot; +
 316     &quot;\021\uff7e\022\uff7e\023\uff7e\024\uff7e\025\uff7e\026\uff7e\027&quot; +
 317     &quot;\uff7e\030\uff7e\031\uff7e\032\uff7e\033\uff7e\042\uff7e\043\uff7e&quot; +
 318     &quot;\001\002\000\004\011\201\001\002\000\052\002\uffbc\004&quot; +
 319     &quot;\uffbc\007\uffbc\010\uffbc\012\uffbc\013\uffbc\014\uffbc\021\uffbc&quot; +
 320     &quot;\022\uffbc\023\uffbc\024\uffbc\025\uffbc\026\uffbc\027\uffbc\030&quot; +
 321     &quot;\uffbc\031\uffbc\032\uffbc\033\uffbc\042\uffbc\043\uffbc\001\002&quot; +
 322     &quot;\000\046\002\uffc2\007\uffc2\010\uffc2\012\uffc2\013\uffc2\014&quot; +
 323     &quot;\uffc2\022\uffc2\023\uffc2\024\uffc2\025\uffc2\026\uffc2\027\uffc2&quot; +
 324     &quot;\030\uffc2\031\uffc2\032\uffc2\033\uffc2\042\uffc2\043\uffc2\001&quot; +
 325     &quot;\002\000\054\002\uff9e\004\uff9e\006\055\007\uff9e\010\uff9e&quot; +
 326     &quot;\012\uff9e\013\uff9e\014\uff9e\021\uff9e\022\uff9e\023\uff9e\024&quot; +
 327     &quot;\uff9e\025\uff9e\026\uff9e\027\uff9e\030\uff9e\031\uff9e\032\uff9e&quot; +
 328     &quot;\033\uff9e\042\uff9e\043\uff9e\001\002\000\060\002\uff76\004&quot; +
 329     &quot;\uff76\006\uff76\007\uff76\010\uff76\011\uff76\012\uff76\013\uff76&quot; +
 330     &quot;\014\uff76\020\uffa1\021\uff76\022\uff76\023\uff76\024\uff76\025&quot; +
 331     &quot;\uff76\026\uff76\027\uff76\030\uff76\031\uff76\032\uff76\033\uff76&quot; +
 332     &quot;\042\uff76\043\uff76\001\002\000\046\002\uffc4\007\uffc4\010&quot; +
 333     &quot;\176\012\uffc4\013\uffc4\014\uffc4\022\uffc4\023\uffc4\024\uffc4&quot; +
 334     &quot;\025\uffc4\026\uffc4\027\uffc4\030\uffc4\031\uffc4\032\uffc4\033&quot; +
 335     &quot;\uffc4\042\uffc4\043\uffc4\001\002\000\060\002\uff81\004\uff81&quot; +
 336     &quot;\006\uff81\007\uff81\010\uff81\011\uff81\012\uff81\013\uff81\014&quot; +
 337     &quot;\uff81\020\uffac\021\uff81\022\uff81\023\uff81\024\uff81\025\uff81&quot; +
 338     &quot;\026\uff81\027\uff81\030\uff81\031\uff81\032\uff81\033\uff81\042&quot; +
 339     &quot;\uff81\043\uff81\001\002\000\054\002\uff9c\004\uff9c\006\uff9c&quot; +
 340     &quot;\007\uff9c\010\uff9c\012\uff9c\013\uff9c\014\uff9c\021\uff9c\022&quot; +
 341     &quot;\uff9c\023\uff9c\024\uff9c\025\uff9c\026\uff9c\027\uff9c\030\uff9c&quot; +
 342     &quot;\031\uff9c\032\uff9c\033\uff9c\042\uff9c\043\uff9c\001\002\000&quot; +
 343     &quot;\060\002\uff78\004\uff78\006\uff78\007\uff78\010\uff78\011\uff78&quot; +
 344     &quot;\012\uff78\013\uff78\014\uff78\020\uffa3\021\uff78\022\uff78\023&quot; +
 345     &quot;\uff78\024\uff78\025\uff78\026\uff78\027\uff78\030\uff78\031\uff78&quot; +
 346     &quot;\032\uff78\033\uff78\042\uff78\043\uff78\001\002\000\052\002&quot; +
 347     &quot;\uffc1\004\173\007\uffc1\010\uffc1\012\uffc1\013\uffc1\014\uffc1&quot; +
 348     &quot;\021\172\022\uffc1\023\uffc1\024\uffc1\025\uffc1\026\uffc1\027&quot; +
 349     &quot;\uffc1\030\uffc1\031\uffc1\032\uffc1\033\uffc1\042\uffc1\043\uffc1&quot; +
 350     &quot;\001\002\000\060\002\uff82\004\uff82\006\uff82\007\uff82\010&quot; +
 351     &quot;\uff82\011\uff82\012\uff82\013\uff82\014\uff82\020\uffad\021\uff82&quot; +
 352     &quot;\022\uff82\023\uff82\024\uff82\025\uff82\026\uff82\027\uff82\030&quot; +
 353     &quot;\uff82\031\uff82\032\uff82\033\uff82\042\uff82\043\uff82\001\002&quot; +
 354     &quot;\000\054\002\uff98\004\uff98\006\uff98\007\uff98\010\uff98\012&quot; +
 355     &quot;\uff98\013\uff98\014\uff98\021\uff98\022\uff98\023\uff98\024\uff98&quot; +
 356     &quot;\025\uff98\026\uff98\027\uff98\030\uff98\031\uff98\032\uff98\033&quot; +
 357     &quot;\uff98\042\uff98\043\uff98\001\002\000\004\007\171\001\002&quot; +
 358     &quot;\000\046\032\031\033\040\035\034\036\113\037\141\047&quot; +
 359     &quot;\036\050\037\051\044\052\170\053\166\054\043\055\041&quot; +
 360     &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot; +
 361     &quot;\002\000\052\002\uffba\004\uffba\007\uffba\010\uffba\012\uffba&quot; +
 362     &quot;\013\uffba\014\uffba\021\uffba\022\uffba\023\uffba\024\uffba\025&quot; +
 363     &quot;\uffba\026\uffba\027\uffba\030\uffba\031\uffba\032\uffba\033\uffba&quot; +
 364     &quot;\042\uffba\043\uffba\001\002\000\060\002\uff79\004\uff79\006&quot; +
 365     &quot;\uff79\007\uff79\010\uff79\011\uff79\012\uff79\013\uff79\014\uff79&quot; +
 366     &quot;\020\uffa4\021\uff79\022\uff79\023\uff79\024\uff79\025\uff79\026&quot; +
 367     &quot;\uff79\027\uff79\030\uff79\031\uff79\032\uff79\033\uff79\042\uff79&quot; +
 368     &quot;\043\uff79\001\002\000\052\002\uffb0\004\uffb0\007\uffb0\010&quot; +
 369     &quot;\uffb0\012\uffb0\013\uffb0\014\uffb0\021\uffb0\022\uffb0\023\uffb0&quot; +
 370     &quot;\024\uffb0\025\uffb0\026\uffb0\027\uffb0\030\uffb0\031\uffb0\032&quot; +
 371     &quot;\uffb0\033\uffb0\042\uffb0\043\uffb0\001\002\000\060\002\uff7c&quot; +
 372     &quot;\004\uff7c\006\uff7c\007\uff7c\010\uff7c\011\uff7c\012\uff7c\013&quot; +
 373     &quot;\uff7c\014\uff7c\020\uffa7\021\uff7c\022\uff7c\023\uff7c\024\uff7c&quot; +
 374     &quot;\025\uff7c\026\uff7c\027\uff7c\030\uff7c\031\uff7c\032\uff7c\033&quot; +
 375     &quot;\uff7c\042\uff7c\043\uff7c\001\002\000\056\002\uff83\004\uff83&quot; +
 376     &quot;\006\uff83\007\uff83\010\uff83\011\uff83\012\uff83\013\uff83\014&quot; +
 377     &quot;\uff83\021\uff83\022\uff83\023\uff83\024\uff83\025\uff83\026\uff83&quot; +
 378     &quot;\027\uff83\030\uff83\031\uff83\032\uff83\033\uff83\042\uff83\043&quot; +
 379     &quot;\uff83\001\002\000\054\002\uff8c\004\uff8c\006\uff8c\007\uff8c&quot; +
 380     &quot;\010\uff8c\012\uff8c\013\uff8c\014\uff8c\021\uff8c\022\uff8c\023&quot; +
 381     &quot;\uff8c\024\uff8c\025\uff8c\026\uff8c\027\uff8c\030\uff8c\031\uff8c&quot; +
 382     &quot;\032\uff8c\033\uff8c\042\uff8c\043\uff8c\001\002\000\060\002&quot; +
 383     &quot;\uff80\004\uff80\006\uff80\007\uff80\010\uff80\011\uff80\012\uff80&quot; +
 384     &quot;\013\uff80\014\uff80\020\uffab\021\uff80\022\uff80\023\uff80\024&quot; +
 385     &quot;\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80\032\uff80&quot; +
 386     &quot;\033\uff80\042\uff80\043\uff80\001\002\000\044\002\uffc6\007&quot; +
 387     &quot;\uffc6\012\uffc6\013\uffc6\014\uffc6\022\uffc6\023\uffc6\024\uffc6&quot; +
 388     &quot;\025\uffc6\026\uffc6\027\uffc6\030\uffc6\031\uffc6\032\uffc6\033&quot; +
 389     &quot;\uffc6\042\uffc6\043\uffc6\001\002\000\054\002\uff8d\004\uff8d&quot; +
 390     &quot;\006\uff8d\007\uff8d\010\uff8d\012\uff8d\013\uff8d\014\uff8d\021&quot; +
 391     &quot;\uff8d\022\uff8d\023\uff8d\024\uff8d\025\uff8d\026\uff8d\027\uff8d&quot; +
 392     &quot;\030\uff8d\031\uff8d\032\uff8d\033\uff8d\042\uff8d\043\uff8d\001&quot; +
 393     &quot;\002\000\044\002\uffcd\007\uffcd\012\uffcd\013\160\014\uffcd&quot; +
 394     &quot;\022\uffcd\023\uffcd\024\uffcd\025\uffcd\026\uffcd\027\uffcd\030&quot; +
 395     &quot;\uffcd\031\uffcd\032\161\033\157\042\uffcd\043\uffcd\001\002&quot; +
 396     &quot;\000\052\002\uffbe\004\153\007\uffbe\010\uffbe\012\uffbe\013&quot; +
 397     &quot;\uffbe\014\uffbe\021\152\022\uffbe\023\uffbe\024\uffbe\025\uffbe&quot; +
 398     &quot;\026\uffbe\027\uffbe\030\uffbe\031\uffbe\032\uffbe\033\uffbe\042&quot; +
 399     &quot;\uffbe\043\uffbe\001\002\000\054\002\uff8e\004\uff8e\006\uff8e&quot; +
 400     &quot;\007\uff8e\010\uff8e\012\uff8e\013\uff8e\014\uff8e\021\uff8e\022&quot; +
 401     &quot;\uff8e\023\uff8e\024\uff8e\025\uff8e\026\uff8e\027\uff8e\030\uff8e&quot; +
 402     &quot;\031\uff8e\032\uff8e\033\uff8e\042\uff8e\043\uff8e\001\002\000&quot; +
 403     &quot;\056\002\uff87\004\uff87\006\uff87\007\uff87\010\uff87\011\uff91&quot; +
 404     &quot;\012\uff87\013\uff87\014\uff87\021\uff87\022\uff87\023\uff87\024&quot; +
 405     &quot;\uff87\025\uff87\026\uff87\027\uff87\030\uff87\031\uff87\032\uff87&quot; +
 406     &quot;\033\uff87\042\uff87\043\uff87\001\002\000\070\005\111\013&quot; +
 407     &quot;\103\016\066\017\106\032\031\033\040\035\034\036\113&quot; +
 408     &quot;\037\141\040\142\041\145\044\063\045\062\046\065\047&quot; +
 409     &quot;\115\050\123\051\136\052\077\053\143\054\131\055\125&quot; +
 410     &quot;\056\116\057\104\060\140\061\067\062\060\063\127\001&quot; +
 411     &quot;\002\000\070\005\111\013\103\016\066\017\106\032\031&quot; +
 412     &quot;\033\040\035\034\036\113\037\141\040\142\041\145\044&quot; +
 413     &quot;\063\045\062\046\065\047\115\050\123\051\136\052\077&quot; +
 414     &quot;\053\143\054\131\055\125\056\116\057\104\060\140\061&quot; +
 415     &quot;\067\062\060\063\127\001\002\000\054\002\uff87\004\uff87&quot; +
 416     &quot;\006\uff87\007\uff87\010\uff87\012\uff87\013\uff87\014\uff87\021&quot; +
 417     &quot;\uff87\022\uff87\023\uff87\024\uff87\025\uff87\026\uff87\027\uff87&quot; +
 418     &quot;\030\uff87\031\uff87\032\uff87\033\uff87\042\uff87\043\uff87\001&quot; +
 419     &quot;\002\000\052\002\uffbb\004\uffbb\007\uffbb\010\uffbb\012\uffbb&quot; +
 420     &quot;\013\uffbb\014\uffbb\021\uffbb\022\uffbb\023\uffbb\024\uffbb\025&quot; +
 421     &quot;\uffbb\026\uffbb\027\uffbb\030\uffbb\031\uffbb\032\uffbb\033\uffbb&quot; +
 422     &quot;\042\uffbb\043\uffbb\001\002\000\052\002\uffb6\004\uffb6\007&quot; +
 423     &quot;\uffb6\010\uffb6\012\uffb6\013\uffb6\014\uffb6\021\uffb6\022\uffb6&quot; +
 424     &quot;\023\uffb6\024\uffb6\025\uffb6\026\uffb6\027\uffb6\030\uffb6\031&quot; +
 425     &quot;\uffb6\032\uffb6\033\uffb6\042\uffb6\043\uffb6\001\002\000\110&quot; +
 426     &quot;\004\061\005\111\011\071\013\103\015\134\016\066\017&quot; +
 427     &quot;\106\021\070\031\075\032\031\033\040\034\057\035\034&quot; +
 428     &quot;\036\113\037\141\040\142\041\145\044\063\045\062\046&quot; +
 429     &quot;\065\047\115\050\123\051\136\052\077\053\143\054\131&quot; +
 430     &quot;\055\125\056\116\057\104\060\140\061\067\062\060\063&quot; +
 431     &quot;\127\064\132\065\072\001\002\000\110\004\061\005\111&quot; +
 432     &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
 433     &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
 434     &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
 435     &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
 436     &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
 437     &quot;\072\001\002\000\110\004\061\005\111\011\071\013\103&quot; +
 438     &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot; +
 439     &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot; +
 440     &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot; +
 441     &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot; +
 442     &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot; +
 443     &quot;\044\002\uffc8\007\uffc8\012\uffc8\013\uffc8\014\uffc8\022\uffc8&quot; +
 444     &quot;\023\uffc8\024\uffc8\025\uffc8\026\uffc8\027\uffc8\030\uffc8\031&quot; +
 445     &quot;\uffc8\032\uffc8\033\uffc8\042\uffc8\043\uffc8\001\002\000\044&quot; +
 446     &quot;\002\uffc9\007\uffc9\012\uffc9\013\uffc9\014\uffc9\022\uffc9\023&quot; +
 447     &quot;\uffc9\024\uffc9\025\uffc9\026\uffc9\027\uffc9\030\uffc9\031\uffc9&quot; +
 448     &quot;\032\uffc9\033\uffc9\042\uffc9\043\uffc9\001\002\000\044\002&quot; +
 449     &quot;\uffc7\007\uffc7\012\uffc7\013\uffc7\014\uffc7\022\uffc7\023\uffc7&quot; +
 450     &quot;\024\uffc7\025\uffc7\026\uffc7\027\uffc7\030\uffc7\031\uffc7\032&quot; +
 451     &quot;\uffc7\033\uffc7\042\uffc7\043\uffc7\001\002\000\054\002\uff90&quot; +
 452     &quot;\004\uff90\006\uff90\007\uff90\010\uff90\012\uff90\013\uff90\014&quot; +
 453     &quot;\uff90\021\uff90\022\uff90\023\uff90\024\uff90\025\uff90\026\uff90&quot; +
 454     &quot;\027\uff90\030\uff90\031\uff90\032\uff90\033\uff90\042\uff90\043&quot; +
 455     &quot;\uff90\001\002\000\054\002\uff80\004\uff80\006\uff80\007\uff80&quot; +
 456     &quot;\010\uff80\012\uff80\013\uff80\014\uff80\021\uff80\022\uff80\023&quot; +
 457     &quot;\uff80\024\uff80\025\uff80\026\uff80\027\uff80\030\uff80\031\uff80&quot; +
 458     &quot;\032\uff80\033\uff80\042\uff80\043\uff80\001\002\000\054\002&quot; +
 459     &quot;\uff96\004\uff96\006\uff96\007\uff96\010\uff96\012\uff96\013\uff96&quot; +
 460     &quot;\014\uff96\021\uff96\022\uff96\023\uff96\024\uff96\025\uff96\026&quot; +
 461     &quot;\uff96\027\uff96\030\uff96\031\uff96\032\uff96\033\uff96\042\uff96&quot; +
 462     &quot;\043\uff96\001\002\000\054\002\uff7f\004\uff7f\006\uff7f\007&quot; +
 463     &quot;\uff7f\010\uff7f\012\uff7f\013\uff7f\014\uff7f\021\uff7f\022\uff7f&quot; +
 464     &quot;\023\uff7f\024\uff7f\025\uff7f\026\uff7f\027\uff7f\030\uff7f\031&quot; +
 465     &quot;\uff7f\032\uff7f\033\uff7f\042\uff7f\043\uff7f\001\002\000\054&quot; +
 466     &quot;\002\uffdb\004\uffdb\006\uffdb\007\uffdb\010\uffdb\012\uffdb\013&quot; +
 467     &quot;\uffdb\014\uffdb\021\uffdb\022\uffdb\023\uffdb\024\uffdb\025\uffdb&quot; +
 468     &quot;\026\uffdb\027\uffdb\030\uffdb\031\uffdb\032\uffdb\033\uffdb\042&quot; +
 469     &quot;\uffdb\043\uffdb\001\002\000\070\005\111\013\103\016\066&quot; +
 470     &quot;\017\106\032\031\033\040\035\034\036\113\037\141\040&quot; +
 471     &quot;\142\041\145\044\063\045\062\046\065\047\115\050\123&quot; +
 472     &quot;\051\136\052\077\053\143\054\131\055\125\056\116\057&quot; +
 473     &quot;\104\060\140\061\067\062\060\063\127\001\002\000\070&quot; +
 474     &quot;\005\111\013\103\016\066\017\106\032\031\033\040\035&quot; +
 475     &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
 476     &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
 477     &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
 478     &quot;\063\127\001\002\000\052\002\uffc0\004\153\007\uffc0\010&quot; +
 479     &quot;\uffc0\012\uffc0\013\uffc0\014\uffc0\021\152\022\uffc0\023\uffc0&quot; +
 480     &quot;\024\uffc0\025\uffc0\026\uffc0\027\uffc0\030\uffc0\031\uffc0\032&quot; +
 481     &quot;\uffc0\033\uffc0\042\uffc0\043\uffc0\001\002\000\052\002\uffbf&quot; +
 482     &quot;\004\153\007\uffbf\010\uffbf\012\uffbf\013\uffbf\014\uffbf\021&quot; +
 483     &quot;\152\022\uffbf\023\uffbf\024\uffbf\025\uffbf\026\uffbf\027\uffbf&quot; +
 484     &quot;\030\uffbf\031\uffbf\032\uffbf\033\uffbf\042\uffbf\043\uffbf\001&quot; +
 485     &quot;\002\000\106\004\061\005\111\011\071\013\103\015\134&quot; +
 486     &quot;\016\066\017\106\021\070\032\031\033\040\034\057\035&quot; +
 487     &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
 488     &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
 489     &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
 490     &quot;\063\127\064\132\065\072\001\002\000\044\002\uffc3\007&quot; +
 491     &quot;\uffc3\012\uffc3\013\uffc3\014\uffc3\022\uffc3\023\uffc3\024\uffc3&quot; +
 492     &quot;\025\uffc3\026\uffc3\027\uffc3\030\uffc3\031\uffc3\032\uffc3\033&quot; +
 493     &quot;\uffc3\042\uffc3\043\uffc3\001\002\000\052\002\uff9d\004\uff9d&quot; +
 494     &quot;\007\uff9d\010\uff9d\012\uff9d\013\uff9d\014\uff9d\021\uff9d\022&quot; +
 495     &quot;\uff9d\023\uff9d\024\uff9d\025\uff9d\026\uff9d\027\uff9d\030\uff9d&quot; +
 496     &quot;\031\uff9d\032\uff9d\033\uff9d\042\uff9d\043\uff9d\001\002\000&quot; +
 497     &quot;\112\004\061\005\111\011\071\012\202\013\103\015\134&quot; +
 498     &quot;\016\066\017\106\021\070\031\075\032\031\033\040\034&quot; +
 499     &quot;\057\035\034\036\113\037\141\040\142\041\145\044\063&quot; +
 500     &quot;\045\062\046\065\047\115\050\123\051\136\052\077\053&quot; +
 501     &quot;\143\054\131\055\125\056\116\057\104\060\140\061\067&quot; +
 502     &quot;\062\060\063\127\064\132\065\072\001\002\000\054\002&quot; +
 503     &quot;\uff95\004\uff95\006\uff95\007\uff95\010\uff95\012\uff95\013\uff95&quot; +
 504     &quot;\014\uff95\021\uff95\022\uff95\023\uff95\024\uff95\025\uff95\026&quot; +
 505     &quot;\uff95\027\uff95\030\uff95\031\uff95\032\uff95\033\uff95\042\uff95&quot; +
 506     &quot;\043\uff95\001\002\000\006\012\uff93\014\207\001\002\000&quot; +
 507     &quot;\006\012\uff8f\014\uff8f\001\002\000\004\012\206\001\002&quot; +
 508     &quot;\000\054\002\uff94\004\uff94\006\uff94\007\uff94\010\uff94\012&quot; +
 509     &quot;\uff94\013\uff94\014\uff94\021\uff94\022\uff94\023\uff94\024\uff94&quot; +
 510     &quot;\025\uff94\026\uff94\027\uff94\030\uff94\031\uff94\032\uff94\033&quot; +
 511     &quot;\uff94\042\uff94\043\uff94\001\002\000\110\004\061\005\111&quot; +
 512     &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
 513     &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
 514     &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
 515     &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
 516     &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
 517     &quot;\072\001\002\000\004\012\uff92\001\002\000\110\004\061&quot; +
 518     &quot;\005\111\011\071\013\103\015\134\016\066\017\106\021&quot; +
 519     &quot;\070\031\075\032\031\033\040\034\057\035\034\036\113&quot; +
 520     &quot;\037\141\040\142\041\145\044\063\045\062\046\065\047&quot; +
 521     &quot;\115\050\123\051\136\052\077\053\143\054\131\055\125&quot; +
 522     &quot;\056\116\057\104\060\140\061\067\062\060\063\127\064&quot; +
 523     &quot;\132\065\072\001\002\000\110\004\061\005\111\011\071&quot; +
 524     &quot;\013\103\015\134\016\066\017\106\021\070\031\075\032&quot; +
 525     &quot;\031\033\040\034\057\035\034\036\113\037\141\040\142&quot; +
 526     &quot;\041\145\044\063\045\062\046\065\047\115\050\123\051&quot; +
 527     &quot;\136\052\077\053\143\054\131\055\125\056\116\057\104&quot; +
 528     &quot;\060\140\061\067\062\060\063\127\064\132\065\072\001&quot; +
 529     &quot;\002\000\044\002\uffcb\007\uffcb\012\uffcb\013\160\014\uffcb&quot; +
 530     &quot;\022\uffcb\023\uffcb\024\uffcb\025\uffcb\026\uffcb\027\uffcb\030&quot; +
 531     &quot;\uffcb\031\uffcb\032\161\033\157\042\uffcb\043\uffcb\001\002&quot; +
 532     &quot;\000\044\002\uffcc\007\uffcc\012\uffcc\013\160\014\uffcc\022&quot; +
 533     &quot;\uffcc\023\uffcc\024\uffcc\025\uffcc\026\uffcc\027\uffcc\030\uffcc&quot; +
 534     &quot;\031\uffcc\032\161\033\157\042\uffcc\043\uffcc\001\002\000&quot; +
 535     &quot;\052\002\uffb3\004\uffb3\007\uffb3\010\uffb3\012\uffb3\013\uffb3&quot; +
 536     &quot;\014\uffb3\021\uffb3\022\uffb3\023\uffb3\024\uffb3\025\uffb3\026&quot; +
 537     &quot;\uffb3\027\uffb3\030\uffb3\031\uffb3\032\uffb3\033\uffb3\042\uffb3&quot; +
 538     &quot;\043\uffb3\001\002\000\110\004\061\005\111\011\071\013&quot; +
 539     &quot;\103\015\134\016\066\017\106\021\070\031\075\032\031&quot; +
 540     &quot;\033\040\034\057\035\034\036\113\037\141\040\142\041&quot; +
 541     &quot;\145\044\063\045\062\046\065\047\115\050\123\051\136&quot; +
 542     &quot;\052\077\053\143\054\131\055\125\056\116\057\104\060&quot; +
 543     &quot;\140\061\067\062\060\063\127\064\132\065\072\001\002&quot; +
 544     &quot;\000\110\004\061\005\111\011\071\013\103\015\134\016&quot; +
 545     &quot;\066\017\106\021\070\031\075\032\031\033\040\034\057&quot; +
 546     &quot;\035\034\036\113\037\141\040\142\041\145\044\063\045&quot; +
 547     &quot;\062\046\065\047\115\050\123\051\136\052\077\053\143&quot; +
 548     &quot;\054\131\055\125\056\116\057\104\060\140\061\067\062&quot; +
 549     &quot;\060\063\127\064\132\065\072\001\002\000\032\002\uffd3&quot; +
 550     &quot;\007\uffd3\012\uffd3\014\uffd3\022\uffd3\023\uffd3\024\221\025&quot; +
 551     &quot;\222\026\223\027\224\042\uffd3\043\uffd3\001\002\000\110&quot; +
 552     &quot;\004\061\005\111\011\071\013\103\015\134\016\066\017&quot; +
 553     &quot;\106\021\070\031\075\032\031\033\040\034\057\035\034&quot; +
 554     &quot;\036\113\037\141\040\142\041\145\044\063\045\062\046&quot; +
 555     &quot;\065\047\115\050\123\051\136\052\077\053\143\054\131&quot; +
 556     &quot;\055\125\056\116\057\104\060\140\061\067\062\060\063&quot; +
 557     &quot;\127\064\132\065\072\001\002\000\110\004\061\005\111&quot; +
 558     &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
 559     &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
 560     &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
 561     &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
 562     &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
 563     &quot;\072\001\002\000\110\004\061\005\111\011\071\013\103&quot; +
 564     &quot;\015\134\016\066\017\106\021\070\031\075\032\031\033&quot; +
 565     &quot;\040\034\057\035\034\036\113\037\141\040\142\041\145&quot; +
 566     &quot;\044\063\045\062\046\065\047\115\050\123\051\136\052&quot; +
 567     &quot;\077\053\143\054\131\055\125\056\116\057\104\060\140&quot; +
 568     &quot;\061\067\062\060\063\127\064\132\065\072\001\002\000&quot; +
 569     &quot;\110\004\061\005\111\011\071\013\103\015\134\016\066&quot; +
 570     &quot;\017\106\021\070\031\075\032\031\033\040\034\057\035&quot; +
 571     &quot;\034\036\113\037\141\040\142\041\145\044\063\045\062&quot; +
 572     &quot;\046\065\047\115\050\123\051\136\052\077\053\143\054&quot; +
 573     &quot;\131\055\125\056\116\057\104\060\140\061\067\062\060&quot; +
 574     &quot;\063\127\064\132\065\072\001\002\000\036\002\uffce\007&quot; +
 575     &quot;\uffce\012\uffce\014\uffce\022\uffce\023\uffce\024\uffce\025\uffce&quot; +
 576     &quot;\026\uffce\027\uffce\030\211\031\212\042\uffce\043\uffce\001&quot; +
 577     &quot;\002\000\036\002\uffcf\007\uffcf\012\uffcf\014\uffcf\022\uffcf&quot; +
 578     &quot;\023\uffcf\024\uffcf\025\uffcf\026\uffcf\027\uffcf\030\211\031&quot; +
 579     &quot;\212\042\uffcf\043\uffcf\001\002\000\036\002\uffd0\007\uffd0&quot; +
 580     &quot;\012\uffd0\014\uffd0\022\uffd0\023\uffd0\024\uffd0\025\uffd0\026&quot; +
 581     &quot;\uffd0\027\uffd0\030\211\031\212\042\uffd0\043\uffd0\001\002&quot; +
 582     &quot;\000\036\002\uffd1\007\uffd1\012\uffd1\014\uffd1\022\uffd1\023&quot; +
 583     &quot;\uffd1\024\uffd1\025\uffd1\026\uffd1\027\uffd1\030\211\031\212&quot; +
 584     &quot;\042\uffd1\043\uffd1\001\002\000\032\002\uffd4\007\uffd4\012&quot; +
 585     &quot;\uffd4\014\uffd4\022\uffd4\023\uffd4\024\221\025\222\026\223&quot; +
 586     &quot;\027\224\042\uffd4\043\uffd4\001\002\000\110\004\061\005&quot; +
 587     &quot;\111\011\071\013\103\015\134\016\066\017\106\021\070&quot; +
 588     &quot;\031\075\032\031\033\040\034\057\035\034\036\113\037&quot; +
 589     &quot;\141\040\142\041\145\044\063\045\062\046\065\047\115&quot; +
 590     &quot;\050\123\051\136\052\077\053\143\054\131\055\125\056&quot; +
 591     &quot;\116\057\104\060\140\061\067\062\060\063\127\064\132&quot; +
 592     &quot;\065\072\001\002\000\016\002\uffd8\007\uffd8\012\uffd8\014&quot; +
 593     &quot;\uffd8\042\uffd8\043\234\001\002\000\110\004\061\005\111&quot; +
 594     &quot;\011\071\013\103\015\134\016\066\017\106\021\070\031&quot; +
 595     &quot;\075\032\031\033\040\034\057\035\034\036\113\037\141&quot; +
 596     &quot;\040\142\041\145\044\063\045\062\046\065\047\115\050&quot; +
 597     &quot;\123\051\136\052\077\053\143\054\131\055\125\056\116&quot; +
 598     &quot;\057\104\060\140\061\067\062\060\063\127\064\132\065&quot; +
 599     &quot;\072\001\002\000\022\002\uffd6\007\uffd6\012\uffd6\014\uffd6&quot; +
 600     &quot;\022\216\023\217\042\uffd6\043\uffd6\001\002\000\062\013&quot; +
 601     &quot;\uffaf\032\uffaf\033\uffaf\035\uffaf\036\uffaf\037\uffaf\040\uffaf&quot; +
 602     &quot;\041\uffaf\044\uffaf\045\uffaf\046\uffaf\047\uffaf\050\uffaf\051&quot; +
 603     &quot;\uffaf\052\uffaf\053\uffaf\054\uffaf\055\uffaf\056\uffaf\057\uffaf&quot; +
 604     &quot;\060\uffaf\061\uffaf\062\uffaf\063\uffaf\001\002\000\054\002&quot; +
 605     &quot;\uffb1\004\uffb1\006\055\007\uffb1\010\uffb1\012\uffb1\013\uffb1&quot; +
 606     &quot;\014\uffb1\021\uffb1\022\uffb1\023\uffb1\024\uffb1\025\uffb1\026&quot; +
 607     &quot;\uffb1\027\uffb1\030\uffb1\031\uffb1\032\uffb1\033\uffb1\042\uffb1&quot; +
 608     &quot;\043\uffb1\001\002\000\052\002\uffb2\004\uffb2\007\uffb2\010&quot; +
 609     &quot;\uffb2\012\uffb2\013\uffb2\014\uffb2\021\uffb2\022\uffb2\023\uffb2&quot; +
 610     &quot;\024\uffb2\025\uffb2\026\uffb2\027\uffb2\030\uffb2\031\uffb2\032&quot; +
 611     &quot;\uffb2\033\uffb2\042\uffb2\043\uffb2\001\002\000\044\002\uffc5&quot; +
 612     &quot;\007\uffc5\012\uffc5\013\uffc5\014\uffc5\022\uffc5\023\uffc5\024&quot; +
 613     &quot;\uffc5\025\uffc5\026\uffc5\027\uffc5\030\uffc5\031\uffc5\032\uffc5&quot; +
 614     &quot;\033\uffc5\042\uffc5\043\uffc5\001\002\000\004\012\243\001&quot; +
 615     &quot;\002\000\054\002\uff9b\004\uff9b\006\uff9b\007\uff9b\010\uff9b&quot; +
 616     &quot;\012\uff9b\013\uff9b\014\uff9b\021\uff9b\022\uff9b\023\uff9b\024&quot; +
 617     &quot;\uff9b\025\uff9b\026\uff9b\027\uff9b\030\uff9b\031\uff9b\032\uff9b&quot; +
 618     &quot;\033\uff9b\042\uff9b\043\uff9b\001\002\000\052\002\uffb5\004&quot; +
 619     &quot;\153\007\uffb5\010\uffb5\012\uffb5\013\uffb5\014\uffb5\021\152&quot; +
 620     &quot;\022\uffb5\023\uffb5\024\uffb5\025\uffb5\026\uffb5\027\uffb5\030&quot; +
 621     &quot;\uffb5\031\uffb5\032\uffb5\033\uffb5\042\uffb5\043\uffb5\001\002&quot; +
 622     &quot;\000\004\034\246\001\002\000\004\012\247\001\002\000&quot; +
 623     &quot;\054\002\uff8a\004\uff8a\006\uff8a\007\uff8a\010\uff8a\012\uff8a&quot; +
 624     &quot;\013\uff8a\014\uff8a\021\uff8a\022\uff8a\023\uff8a\024\uff8a\025&quot; +
 625     &quot;\uff8a\026\uff8a\027\uff8a\030\uff8a\031\uff8a\032\uff8a\033\uff8a&quot; +
 626     &quot;\042\uff8a\043\uff8a\001\002\000\052\002\uffb8\004\153\007&quot; +
 627     &quot;\uffb8\010\uffb8\012\uffb8\013\uffb8\014\uffb8\021\152\022\uffb8&quot; +
 628     &quot;\023\uffb8\024\uffb8\025\uffb8\026\uffb8\027\uffb8\030\uffb8\031&quot; +
 629     &quot;\uffb8\032\uffb8\033\uffb8\042\uffb8\043\uffb8\001\002\000\052&quot; +
 630     &quot;\002\uffdc\004\uffdc\007\uffdc\010\uffdc\012\uffdc\013\uffdc\014&quot; +
 631     &quot;\uffdc\021\uffdc\022\uffdc\023\uffdc\024\uffdc\025\uffdc\026\uffdc&quot; +
 632     &quot;\027\uffdc\030\uffdc\031\uffdc\032\uffdc\033\uffdc\042\uffdc\043&quot; +
 633     &quot;\uffdc\001\002\000\062\013\uffde\032\uffde\033\uffde\035\uffde&quot; +
 634     &quot;\036\uffde\037\uffde\040\uffde\041\uffde\044\uffde\045\uffde\046&quot; +
 635     &quot;\uffde\047\uffde\050\uffde\051\uffde\052\uffde\053\uffde\054\uffde&quot; +
 636     &quot;\055\uffde\056\uffde\057\uffde\060\uffde\061\uffde\062\uffde\063&quot; +
 637     &quot;\uffde\001\002\000\004\034\254\001\002\000\004\014\255&quot; +
 638     &quot;\001\002\000\004\034\256\001\002\000\004\012\257\001&quot; +
 639     &quot;\002\000\012\002\ufff4\004\ufff4\010\ufff4\021\ufff4\001\002&quot; +
 640     &quot;\000\004\034\261\001\002\000\004\012\262\001\002\000&quot; +
 641     &quot;\012\002\ufff5\004\ufff5\010\ufff5\021\ufff5\001\002\000\012&quot; +
 642     &quot;\002\uffec\004\uffec\010\uffec\021\uffec\001\002\000\062\013&quot; +
 643     &quot;\uffdf\032\uffdf\033\uffdf\035\uffdf\036\uffdf\037\uffdf\040\uffdf&quot; +
 644     &quot;\041\uffdf\044\uffdf\045\uffdf\046\uffdf\047\uffdf\050\uffdf\051&quot; +
 645     &quot;\uffdf\052\uffdf\053\uffdf\054\uffdf\055\uffdf\056\uffdf\057\uffdf&quot; +
 646     &quot;\060\uffdf\061\uffdf\062\uffdf\063\uffdf\001\002\000\064\013&quot; +
 647     &quot;\027\016\020\032\031\033\040\035\034\036\113\037\141&quot; +
 648     &quot;\040\047\041\051\044\015\045\014\046\016\047\036\050&quot; +
 649     &quot;\037\051\044\052\025\053\050\054\043\055\041\056\035&quot; +
 650     &quot;\057\030\060\045\061\021\062\012\063\042\001\002\000&quot; +
 651     &quot;\064\013\027\016\020\032\031\033\040\035\034\036\113&quot; +
 652     &quot;\037\141\040\047\041\051\044\015\045\014\046\016\047&quot; +
 653     &quot;\036\050\037\051\044\052\025\053\050\054\043\055\041&quot; +
 654     &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot; +
 655     &quot;\002\000\006\002\ufff1\010\ufff1\001\002\000\006\002\ufff0&quot; +
 656     &quot;\010\ufff0\001\002\000\006\002\ufff7\010\ufff7\001\002\000&quot; +
 657     &quot;\014\002\uffe9\004\uffe9\006\055\010\uffe9\021\uffe9\001\002&quot; +
 658     &quot;\000\014\002\uffeb\004\uffeb\006\055\010\uffeb\021\uffeb\001&quot; +
 659     &quot;\002\000\012\002\uffea\004\uffea\010\uffea\021\uffea\001\002&quot; +
 660     &quot;\000\012\002\uffe8\004\uffe8\010\uffe8\021\uffe8\001\002\000&quot; +
 661     &quot;\064\013\027\016\020\032\031\033\040\035\034\036\113&quot; +
 662     &quot;\037\141\040\047\041\051\044\015\045\014\046\016\047&quot; +
 663     &quot;\036\050\037\051\044\052\025\053\050\054\043\055\041&quot; +
 664     &quot;\056\035\057\030\060\045\061\021\062\012\063\042\001&quot; +
 665     &quot;\002\000\064\013\027\016\020\032\031\033\040\035\034&quot; +
 666     &quot;\036\113\037\141\040\047\041\051\044\015\045\014\046&quot; +
 667     &quot;\016\047\036\050\037\051\044\052\025\053\050\054\043&quot; +
 668     &quot;\055\041\056\035\057\030\060\045\061\021\062\012\063&quot; +
 669     &quot;\042\001\002\000\006\002\ufff9\010\ufff9\001\002\000\006&quot; +
 670     &quot;\002\ufff8\010\ufff8\001\002\000\004\034\303\001\002\000&quot; +
 671     &quot;\004\012\304\001\002\000\014\002\ufff3\004\ufff3\006\ufff3&quot; +
 672     &quot;\010\ufff3\021\ufff3\001\002\000\006\002\ufffb\010\ufffb\001&quot; +
 673     &quot;\002\000\070\004\013\013\027\016\020\021\023\032\031&quot; +
 674     &quot;\033\040\035\034\036\033\037\046\040\047\041\051\044&quot; +
 675     &quot;\015\045\014\046\016\047\036\050\037\051\044\052\025&quot; +
 676     &quot;\053\050\054\043\055\041\056\035\057\030\060\045\061&quot; +
 677     &quot;\021\062\012\063\042\001\002\000\004\002\ufffd\001\002&quot; +
 678     &quot;\000\004\002\uffff\001\002\000\004\002\001\001\002&quot; });
 679 
 680   /** Access to parse-action table. */
 681   public short[][] action_table() {return _action_table;}
 682 
 683   /** &lt;code&gt;reduce_goto&lt;/code&gt; table. */
 684   protected static final short[][] _reduce_table =
 685     unpackFromStrings(new String[] {
 686     &quot;\000\307\000\004\003\003\001\001\000\002\001\001\000&quot; +
 687     &quot;\070\004\307\006\120\010\127\011\117\012\101\013\075&quot; +
 688     &quot;\014\104\015\063\016\111\017\145\020\113\021\125\022&quot; +
 689     &quot;\073\023\121\024\143\025\123\026\136\027\146\030\134&quot; +
 690     &quot;\031\107\032\072\033\106\034\147\047\150\050\116\052&quot; +
 691     &quot;\100\053\077\001\001\000\026\035\016\036\007\037\006&quot; +
 692     &quot;\040\031\041\025\042\023\043\052\044\010\047\051\054&quot; +
 693     &quot;\021\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
 694     &quot;\001\001\000\002\001\001\000\020\040\031\041\304\042&quot; +
 695     &quot;\023\043\052\044\010\047\051\054\021\001\001\000\002&quot; +
 696     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 697     &quot;\001\000\002\001\001\000\002\001\001\000\012\040\271&quot; +
 698     &quot;\043\272\044\010\047\051\001\001\000\020\040\031\041&quot; +
 699     &quot;\270\042\023\043\052\044\010\047\051\054\021\001\001&quot; +
 700     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 701     &quot;\002\001\001\000\002\001\001\000\002\001\001\000\006&quot; +
 702     &quot;\007\053\045\262\001\001\000\002\001\001\000\002\001&quot; +
 703     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 704     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 705     &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
 706     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 707     &quot;\001\000\002\001\001\000\006\007\053\045\055\001\001&quot; +
 708     &quot;\000\006\007\053\045\250\001\001\000\070\004\132\006&quot; +
 709     &quot;\120\010\127\011\117\012\101\013\075\014\104\015\063&quot; +
 710     &quot;\016\111\017\145\020\113\021\125\022\073\023\121\024&quot; +
 711     &quot;\143\025\123\026\136\027\146\030\134\031\107\032\072&quot; +
 712     &quot;\033\106\034\147\047\150\050\116\052\100\053\077\001&quot; +
 713     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 714     &quot;\000\024\011\117\026\136\027\247\030\134\033\106\034&quot; +
 715     &quot;\147\047\153\052\100\053\077\001\001\000\002\001\001&quot; +
 716     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 717     &quot;\002\001\001\000\002\001\001\000\024\011\117\026\136&quot; +
 718     &quot;\027\243\030\134\033\106\034\147\047\153\052\100\053&quot; +
 719     &quot;\077\001\001\000\070\004\241\006\120\010\127\011\117&quot; +
 720     &quot;\012\101\013\075\014\104\015\063\016\111\017\145\020&quot; +
 721     &quot;\113\021\125\022\073\023\121\024\143\025\123\026\136&quot; +
 722     &quot;\027\146\030\134\031\107\032\072\033\106\034\147\047&quot; +
 723     &quot;\150\050\116\052\100\053\077\001\001\000\002\001\001&quot; +
 724     &quot;\000\002\001\001\000\002\001\001\000\052\006\120\010&quot; +
 725     &quot;\127\011\117\020\240\021\125\022\073\023\121\024\143&quot; +
 726     &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
 727     &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot; +
 728     &quot;\000\002\001\001\000\002\001\001\000\010\033\236\034&quot; +
 729     &quot;\147\047\153\001\001\000\002\001\001\000\002\001\001&quot; +
 730     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 731     &quot;\002\001\001\000\006\007\053\045\214\001\001\000\002&quot; +
 732     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 733     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 734     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 735     &quot;\006\007\053\045\177\001\001\000\002\001\001\000\002&quot; +
 736     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 737     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 738     &quot;\000\002\001\001\000\006\047\164\051\166\001\001\000&quot; +
 739     &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
 740     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 741     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 742     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 743     &quot;\020\011\155\026\136\033\106\034\147\047\153\052\100&quot; +
 744     &quot;\053\077\001\001\000\020\011\154\026\136\033\106\034&quot; +
 745     &quot;\147\047\153\052\100\053\077\001\001\000\002\001\001&quot; +
 746     &quot;\000\002\001\001\000\002\001\001\000\052\006\120\010&quot; +
 747     &quot;\127\011\117\020\163\021\125\022\073\023\121\024\143&quot; +
 748     &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
 749     &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot; +
 750     &quot;\000\052\006\120\010\127\011\117\020\162\021\125\022&quot; +
 751     &quot;\073\023\121\024\143\025\123\026\136\027\146\030\134&quot; +
 752     &quot;\031\107\032\072\033\106\034\147\047\150\050\116\052&quot; +
 753     &quot;\100\053\077\001\001\000\052\006\120\010\127\011\117&quot; +
 754     &quot;\020\161\021\125\022\073\023\121\024\143\025\123\026&quot; +
 755     &quot;\136\027\146\030\134\031\107\032\072\033\106\034\147&quot; +
 756     &quot;\047\150\050\116\052\100\053\077\001\001\000\002\001&quot; +
 757     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 758     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 759     &quot;\002\001\001\000\024\011\117\026\136\027\174\030\134&quot; +
 760     &quot;\033\106\034\147\047\153\052\100\053\077\001\001\000&quot; +
 761     &quot;\024\011\117\026\136\027\173\030\134\033\106\034\147&quot; +
 762     &quot;\047\153\052\100\053\077\001\001\000\002\001\001\000&quot; +
 763     &quot;\002\001\001\000\050\006\120\010\127\011\117\021\125&quot; +
 764     &quot;\022\073\023\121\024\176\025\123\026\136\027\146\030&quot; +
 765     &quot;\134\031\107\032\072\033\106\034\147\047\150\050\116&quot; +
 766     &quot;\052\100\053\077\001\001\000\002\001\001\000\002\001&quot; +
 767     &quot;\001\000\074\004\203\005\202\006\120\010\127\011\117&quot; +
 768     &quot;\012\101\013\075\014\104\015\063\016\111\017\145\020&quot; +
 769     &quot;\113\021\125\022\073\023\121\024\143\025\123\026\136&quot; +
 770     &quot;\027\146\030\134\031\107\032\072\033\106\034\147\046&quot; +
 771     &quot;\204\047\150\050\116\052\100\053\077\001\001\000\002&quot; +
 772     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 773     &quot;\001\000\002\001\001\000\074\004\203\005\202\006\120&quot; +
 774     &quot;\010\127\011\117\012\101\013\075\014\104\015\063\016&quot; +
 775     &quot;\111\017\145\020\113\021\125\022\073\023\121\024\143&quot; +
 776     &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
 777     &quot;\106\034\147\046\207\047\150\050\116\052\100\053\077&quot; +
 778     &quot;\001\001\000\002\001\001\000\054\006\120\010\127\011&quot; +
 779     &quot;\117\017\213\020\113\021\125\022\073\023\121\024\143&quot; +
 780     &quot;\025\123\026\136\027\146\030\134\031\107\032\072\033&quot; +
 781     &quot;\106\034\147\047\150\050\116\052\100\053\077\001\001&quot; +
 782     &quot;\000\054\006\120\010\127\011\117\017\212\020\113\021&quot; +
 783     &quot;\125\022\073\023\121\024\143\025\123\026\136\027\146&quot; +
 784     &quot;\030\134\031\107\032\072\033\106\034\147\047\150\050&quot; +
 785     &quot;\116\052\100\053\077\001\001\000\002\001\001\000\002&quot; +
 786     &quot;\001\001\000\002\001\001\000\060\006\120\010\127\011&quot; +
 787     &quot;\117\015\230\016\111\017\145\020\113\021\125\022\073&quot; +
 788     &quot;\023\121\024\143\025\123\026\136\027\146\030\134\031&quot; +
 789     &quot;\107\032\072\033\106\034\147\047\150\050\116\052\100&quot; +
 790     &quot;\053\077\001\001\000\060\006\120\010\127\011\117\015&quot; +
 791     &quot;\217\016\111\017\145\020\113\021\125\022\073\023\121&quot; +
 792     &quot;\024\143\025\123\026\136\027\146\030\134\031\107\032&quot; +
 793     &quot;\072\033\106\034\147\047\150\050\116\052\100\053\077&quot; +
 794     &quot;\001\001\000\002\001\001\000\056\006\120\010\127\011&quot; +
 795     &quot;\117\016\227\017\145\020\113\021\125\022\073\023\121&quot; +
 796     &quot;\024\143\025\123\026\136\027\146\030\134\031\107\032&quot; +
 797     &quot;\072\033\106\034\147\047\150\050\116\052\100\053\077&quot; +
 798     &quot;\001\001\000\056\006\120\010\127\011\117\016\226\017&quot; +
 799     &quot;\145\020\113\021\125\022\073\023\121\024\143\025\123&quot; +
 800     &quot;\026\136\027\146\030\134\031\107\032\072\033\106\034&quot; +
 801     &quot;\147\047\150\050\116\052\100\053\077\001\001\000\056&quot; +
 802     &quot;\006\120\010\127\011\117\016\225\017\145\020\113\021&quot; +
 803     &quot;\125\022\073\023\121\024\143\025\123\026\136\027\146&quot; +
 804     &quot;\030\134\031\107\032\072\033\106\034\147\047\150\050&quot; +
 805     &quot;\116\052\100\053\077\001\001\000\056\006\120\010\127&quot; +
 806     &quot;\011\117\016\224\017\145\020\113\021\125\022\073\023&quot; +
 807     &quot;\121\024\143\025\123\026\136\027\146\030\134\031\107&quot; +
 808     &quot;\032\072\033\106\034\147\047\150\050\116\052\100\053&quot; +
 809     &quot;\077\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
 810     &quot;\001\001\000\002\001\001\000\002\001\001\000\064\006&quot; +
 811     &quot;\120\010\127\011\117\013\232\014\104\015\063\016\111&quot; +
 812     &quot;\017\145\020\113\021\125\022\073\023\121\024\143\025&quot; +
 813     &quot;\123\026\136\027\146\030\134\031\107\032\072\033\106&quot; +
 814     &quot;\034\147\047\150\050\116\052\100\053\077\001\001\000&quot; +
 815     &quot;\002\001\001\000\062\006\120\010\127\011\117\014\234&quot; +
 816     &quot;\015\063\016\111\017\145\020\113\021\125\022\073\023&quot; +
 817     &quot;\121\024\143\025\123\026\136\027\146\030\134\031\107&quot; +
 818     &quot;\032\072\033\106\034\147\047\150\050\116\052\100\053&quot; +
 819     &quot;\077\001\001\000\002\001\001\000\002\001\001\000\006&quot; +
 820     &quot;\007\053\045\237\001\001\000\002\001\001\000\002\001&quot; +
 821     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 822     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 823     &quot;\002\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
 824     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 825     &quot;\001\000\002\001\001\000\002\001\001\000\002\001\001&quot; +
 826     &quot;\000\002\001\001\000\002\001\001\000\002\001\001\000&quot; +
 827     &quot;\020\040\031\041\267\042\023\043\052\044\010\047\051&quot; +
 828     &quot;\054\021\001\001\000\020\040\031\041\266\042\023\043&quot; +
 829     &quot;\052\044\010\047\051\054\021\001\001\000\002\001\001&quot; +
 830     &quot;\000\002\001\001\000\002\001\001\000\006\007\053\045&quot; +
 831     &quot;\274\001\001\000\006\007\053\045\273\001\001\000\002&quot; +
 832     &quot;\001\001\000\002\001\001\000\020\040\031\041\300\042&quot; +
 833     &quot;\023\043\052\044\010\047\051\054\021\001\001\000\020&quot; +
 834     &quot;\040\031\041\277\042\023\043\052\044\010\047\051\054&quot; +
 835     &quot;\021\001\001\000\002\001\001\000\002\001\001\000\002&quot; +
 836     &quot;\001\001\000\002\001\001\000\002\001\001\000\002\001&quot; +
 837     &quot;\001\000\026\035\016\036\306\037\006\040\031\041\025&quot; +
 838     &quot;\042\023\043\052\044\010\047\051\054\021\001\001\000&quot; +
 839     &quot;\002\001\001\000\002\001\001\000\002\001\001&quot; });
 840 
 841   /** Access to &lt;code&gt;reduce_goto&lt;/code&gt; table. */
 842   public short[][] reduce_table() {return _reduce_table;}
 843 
 844   /** Instance of action encapsulation class. */
 845   protected parser_actions action_obj;
 846 
 847   /** Action encapsulation object initializer. */
 848   protected void init_actions()
 849     {
 850       action_obj = new parser_actions(this);
 851     }
 852 
 853   /** Invoke a user supplied parse action. */
 854   public Symbol do_action(
 855     int                        act_num,
 856     lr_parser parser,
 857     Stack&lt;Symbol&gt;            stack,
 858     int                        top)
 859     throws java.lang.Exception
 860   {
 861     /* call code in generated class */
 862     return action_obj.parser_do_action(act_num, parser, stack, top);
 863   }
 864 
 865   /** Indicates start state. */
 866   public int start_state() {return 0;}
 867   /** Indicates start production. */
 868   public int start_production() {return 0;}
 869 
 870   /** &lt;code&gt;EOF&lt;/code&gt; Symbol index. */
 871   public int EOF_sym() {return 0;}
 872 
 873   /** &lt;code&gt;error&lt;/code&gt; Symbol index. */
 874   public int error_sym() {return 1;}
 875 
 876 
 877 
 878     /**
 879      * Used by function calls with no args.
 880      */
 881     static public final List&lt;Expression&gt; EmptyArgs = new ArrayList&lt;&gt;(0);
 882 
 883     /**
 884      * Reference to non-existing variable.
 885      */
 886     static public final VariableRef DummyVarRef = null;
 887 
 888     /**
 889      * Reference to the Parser class.
 890      */
 891     private Parser _parser;
 892     private XSLTC  _xsltc;
 893 
 894     /**
 895      * String representation of the expression being parsed.
 896      */
 897     private String _expression;
 898 
 899     /**
 900      * Line number where this expression/pattern was declared.
 901      */
 902     private int _lineNumber = 0;
 903 
 904     /**
 905      * Reference to the symbol table.
 906      */
 907     public SymbolTable _symbolTable;
 908 
 909     public XPathParser(Parser parser) {
 910         _parser = parser;
 911         _xsltc = parser.getXSLTC();
 912         _symbolTable = parser.getSymbolTable();
 913     }
 914 
 915     public int getLineNumber() {
 916         return _lineNumber;
 917     }
 918 
 919     public QName getQNameIgnoreDefaultNs(String name) {
 920           return _parser.getQNameIgnoreDefaultNs(name);
 921     }
 922 
 923     public QName getQName(String namespace, String prefix, String localname) {
 924         return _parser.getQName(namespace, prefix, localname);
 925     }
 926 
 927     public void setMultiDocument(boolean flag) {
 928           _xsltc.setMultiDocument(flag);
 929     }
 930 
 931     public void setCallsNodeset(boolean flag) {
 932           _xsltc.setCallsNodeset(flag);
 933     }
 934 
 935     public void setHasIdCall(boolean flag) {
 936           _xsltc.setHasIdCall(flag);
 937     }
 938 
 939 
 940     /**
 941      * This method is similar to findNodeType(int, Object) except that it
 942      * creates a StepPattern instead of just returning a node type. It also
 943      * differs in the way it handles &quot;{uri}:*&quot; and &quot;{uri}:@*&quot;. The last two
 944      * patterns are expanded as &quot;*[namespace-uri() = &#39;uri&#39;]&quot; and
 945      * &quot;@*[namespace-uri() = &#39;uri&#39;]&quot;, respectively. This expansion considerably
 946      * simplifies the grouping of patterns in the Mode class. For this
 947      * expansion to be correct, the priority of the pattern/template must be
 948      * set to -0.25 (when no other predicates are present).
 949      */
 950     public StepPattern createStepPattern(int axis, Object test, List&lt;Predicate&gt; predicates) {
 951         int nodeType;
 952 
 953         if (test == null) {  // &quot;*&quot;
 954             nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE :
 955                 (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;
 956 
 957             return new StepPattern(axis, nodeType, predicates);
 958         }
 959         else if (test instanceof Integer) {
 960             nodeType = ((Integer) test).intValue();
 961 
 962             return new StepPattern(axis, nodeType, predicates);
 963         }
 964         else {
 965             QName name = (QName)test;
 966             boolean setPriority = false;
 967 
 968             if (axis == Axis.NAMESPACE) {
 969                 nodeType = (name.toString().equals(&quot;*&quot;)) ? -1
 970                                 : _xsltc.registerNamespacePrefix(name);;
 971             }
 972             else {
 973                 final String uri = name.getNamespace();
 974                 final String local = name.getLocalPart();
 975                 final QName namespace_uri =
 976                     _parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;);
 977 
 978                 // Expand {uri}:* to *[namespace-uri() = &#39;uri&#39;] - same for @*
 979                 if (uri != null &amp;&amp; (local.equals(&quot;*&quot;) || local.equals(&quot;@*&quot;))) {
 980                     if (predicates == null) {
 981                         predicates = new ArrayList&lt;&gt;(2);
 982                     }
 983 
 984                     // Priority is set by hand if no other predicates exist
 985                     setPriority = (predicates.size() == 0);
 986 
 987                     predicates.add(
 988                         new Predicate(
 989                             new EqualityExpr(Operators.EQ,
 990                                 new NamespaceUriCall(namespace_uri),
 991                                 new LiteralExpr(uri))));
 992                 }
 993 
 994                 if (local.equals(&quot;*&quot;)) {
 995                     nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
 996                         : NodeTest.ELEMENT;
 997                 }
 998                 else if (local.equals(&quot;@*&quot;)) {
 999                     nodeType = NodeTest.ATTRIBUTE;
1000                 }
1001                 else {
1002                     nodeType = (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
1003                         : _xsltc.registerElement(name);
1004                 }
1005             }
1006 
1007             final StepPattern result = new StepPattern(axis, nodeType, predicates);
1008 
1009             // Set priority for case prefix:* and prefix:@* (no predicates)
1010             if (setPriority) {
1011                 result.setPriority(-0.25);
1012             }
1013 
1014             return result;
1015         }
1016     }
1017 
1018     public int findNodeType(int axis, Object test) {
1019         if (test == null) {  // *
1020             return (axis == Axis.ATTRIBUTE) ?
1021                 NodeTest.ATTRIBUTE :
1022                 (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;
1023         }
1024         else if (test instanceof Integer) {
1025             return ((Integer)test).intValue();
1026         }
1027         else {
1028             QName name = (QName)test;
1029 
1030             if (axis == Axis.NAMESPACE) {
1031                 return (name.toString().equals(&quot;*&quot;)) ? -1
1032                     : _xsltc.registerNamespacePrefix(name);
1033             }
1034 
1035             if (name.getNamespace() == null) {
1036                 final String local = name.getLocalPart();
1037 
1038                 if (local.equals(&quot;*&quot;)) {
1039                     return (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE
1040                         : NodeTest.ELEMENT;
1041                 }
1042                 else if (local.equals(&quot;@*&quot;)) {
1043                     return NodeTest.ATTRIBUTE;
1044                 }
1045             }
1046 
1047             return (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name)
1048                 : _xsltc.registerElement(name);
1049         }
1050     }
1051 
1052     /**
1053      * Parse the expression passed to the current scanner. If this
1054      * expression contains references to local variables and it will be
1055      * compiled in an external module (not in the main class) request
1056      * the current template to create a new variable stack frame.
1057      *
1058      * @param lineNumber Line where the current expression is defined.
1059      * @param external   Set to &lt;tt&gt;true&lt;/tt&gt; if this expression is
1060      *                   compiled in a separate module.
1061      *
1062      */
1063     public Symbol parse(String expression, int lineNumber) throws Exception {
1064         try {
1065             _expression = expression;
1066             _lineNumber = lineNumber;
1067             return super.parse();
1068         }
1069         catch (IllegalCharException e) {
1070             ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_CHAR_ERR,
1071                                         lineNumber, e.getMessage());
1072             _parser.reportError(Constants.FATAL, err);
1073         }
1074         return null;
1075     }
1076 
1077     /**
1078      * Lookup a variable or parameter in the symbol table given its name.
1079      *
1080      * @param name Name of the symbol being looked up.
1081      */
1082     final SyntaxTreeNode lookupName(QName name) {
1083         // Is it a local var or param ?
1084         final SyntaxTreeNode result = _parser.lookupVariable(name);
1085         if (result != null)
1086             return(result);
1087         else
1088             return(_symbolTable.lookupName(name));
1089     }
1090 
1091     public final void addError(ErrorMsg error) {
1092         _parser.reportError(Constants.ERROR, error);
1093     }
1094 
1095     public void report_error(String message, Object info) {
1096         final ErrorMsg err = new ErrorMsg(ErrorMsg.SYNTAX_ERR, _lineNumber,
1097             _expression);
1098         _parser.reportError(Constants.FATAL, err);
1099     }
1100 
1101     public void report_fatal_error(String message, Object info) {
1102         // empty
1103     }
1104 
1105     public RelativeLocationPath insertStep(Step step, RelativeLocationPath rlp) {
1106         if (rlp instanceof Step) {
1107             return new ParentLocationPath(step, (Step) rlp);
1108         }
1109         else if (rlp instanceof ParentLocationPath) {
1110             final ParentLocationPath plp = (ParentLocationPath) rlp;
1111             final RelativeLocationPath newrlp = insertStep(step, plp.getPath());
1112             return new ParentLocationPath(newrlp, plp.getStep());
1113         }
1114         else {
1115             addError(new ErrorMsg(ErrorMsg.INTERNAL_ERR, &quot;XPathParser.insertStep&quot;));
1116             return rlp;
1117         }
1118     }
1119 
1120     /**
1121      * Returns true if the axis applies to elements only. The axes
1122      * child, attribute, namespace, descendant result in non-empty
1123      * nodesets only if the context node is of type element.
1124      */
1125     public boolean isElementAxis(int axis) {
1126         return (axis == Axis.CHILD || axis == Axis.ATTRIBUTE ||
1127                 axis == Axis.NAMESPACE || axis == Axis.DESCENDANT);
1128     }
1129 
1130 }
1131 
1132 /** Cup generated class to encapsulate user supplied action code.*/
1133 class parser_actions {
1134   private final XPathParser parser;
1135 
1136   /** Constructor */
1137   parser_actions(XPathParser parser) {
1138     this.parser = parser;
1139   }
1140 
1141   /** Method with the actual generated action code. */
1142   public final Symbol parser_do_action(
1143     int                        parser_act_num,
1144     lr_parser parser_parser,
1145     Stack&lt;Symbol&gt;            parser_stack,
1146     int                        parser_top)
1147     throws java.lang.Exception
1148     {
1149       /* Symbol object for return from actions */
1150       Symbol parser_result;
1151 
1152       /* select the action based on the action number */
1153       switch (parser_act_num)
1154         {
1155           /*. . . . . . . . . . . . . . . . . . . .*/
1156           case 140: // QName ::= ID
1157             {
1158               QName RESULT = null;
1159                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;id&quot;);
1160               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1161             }
1162           return parser_result;
1163 
1164           /*. . . . . . . . . . . . . . . . . . . .*/
1165           case 139: // QName ::= SELF
1166             {
1167               QName RESULT = null;
1168                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;self&quot;);
1169               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1170             }
1171           return parser_result;
1172 
1173           /*. . . . . . . . . . . . . . . . . . . .*/
1174           case 138: // QName ::= PRECEDINGSIBLING
1175             {
1176               QName RESULT = null;
1177                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;preceding-sibling&quot;);
1178               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1179             }
1180           return parser_result;
1181 
1182           /*. . . . . . . . . . . . . . . . . . . .*/
1183           case 137: // QName ::= PRECEDING
1184             {
1185               QName RESULT = null;
1186                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;preceding&quot;);
1187               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1188             }
1189           return parser_result;
1190 
1191           /*. . . . . . . . . . . . . . . . . . . .*/
1192           case 136: // QName ::= PARENT
1193             {
1194               QName RESULT = null;
1195                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;parent&quot;);
1196               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1197             }
1198           return parser_result;
1199 
1200           /*. . . . . . . . . . . . . . . . . . . .*/
1201           case 135: // QName ::= NAMESPACE
1202             {
1203               QName RESULT = null;
1204                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;namespace&quot;);
1205               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1206             }
1207           return parser_result;
1208 
1209           /*. . . . . . . . . . . . . . . . . . . .*/
1210           case 134: // QName ::= FOLLOWINGSIBLING
1211             {
1212               QName RESULT = null;
1213                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;following-sibling&quot;);
1214               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1215             }
1216           return parser_result;
1217 
1218           /*. . . . . . . . . . . . . . . . . . . .*/
1219           case 133: // QName ::= FOLLOWING
1220             {
1221               QName RESULT = null;
1222                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;following&quot;);
1223               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1224             }
1225           return parser_result;
1226 
1227           /*. . . . . . . . . . . . . . . . . . . .*/
1228           case 132: // QName ::= DESCENDANTORSELF
1229             {
1230               QName RESULT = null;
1231                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;decendant-or-self&quot;);
1232               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1233             }
1234           return parser_result;
1235 
1236           /*. . . . . . . . . . . . . . . . . . . .*/
1237           case 131: // QName ::= DESCENDANT
1238             {
1239               QName RESULT = null;
1240                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;decendant&quot;);
1241               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1242             }
1243           return parser_result;
1244 
1245           /*. . . . . . . . . . . . . . . . . . . .*/
1246           case 130: // QName ::= CHILD
1247             {
1248               QName RESULT = null;
1249                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;child&quot;);
1250               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1251             }
1252           return parser_result;
1253 
1254           /*. . . . . . . . . . . . . . . . . . . .*/
1255           case 129: // QName ::= ATTRIBUTE
1256             {
1257               QName RESULT = null;
1258                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;attribute&quot;);
1259               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1260             }
1261           return parser_result;
1262 
1263           /*. . . . . . . . . . . . . . . . . . . .*/
1264           case 128: // QName ::= ANCESTORORSELF
1265             {
1266               QName RESULT = null;
1267                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;ancestor-or-self&quot;);
1268               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1269             }
1270           return parser_result;
1271 
1272           /*. . . . . . . . . . . . . . . . . . . .*/
1273           case 127: // QName ::= ANCESTOR
1274             {
1275               QName RESULT = null;
1276                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;child&quot;);
1277               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1278             }
1279           return parser_result;
1280 
1281           /*. . . . . . . . . . . . . . . . . . . .*/
1282           case 126: // QName ::= KEY
1283             {
1284               QName RESULT = null;
1285                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;key&quot;);
1286               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1287             }
1288           return parser_result;
1289 
1290           /*. . . . . . . . . . . . . . . . . . . .*/
1291           case 125: // QName ::= MOD
1292             {
1293               QName RESULT = null;
1294                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;mod&quot;);
1295               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1296             }
1297           return parser_result;
1298 
1299           /*. . . . . . . . . . . . . . . . . . . .*/
1300           case 124: // QName ::= DIV
1301             {
1302               QName RESULT = null;
1303                  RESULT = parser.getQNameIgnoreDefaultNs(&quot;div&quot;);
1304               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1305             }
1306           return parser_result;
1307 
1308           /*. . . . . . . . . . . . . . . . . . . .*/
1309           case 123: // QName ::= QNAME
1310             {
1311               QName RESULT = null;
1312                 int qnameleft = (parser_stack.get(parser_top-0)).left;
1313                 int qnameright = (parser_stack.get(parser_top-0)).right;
1314                 String qname = (String)(parser_stack.get(parser_top-0)).value;
1315                  RESULT = parser.getQNameIgnoreDefaultNs(qname);
1316               parser_result = new Symbol(37/*QName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1317             }
1318           return parser_result;
1319 
1320           /*. . . . . . . . . . . . . . . . . . . .*/
1321           case 122: // NameTest ::= QName
1322             {
1323               Object RESULT = null;
1324                 int qnleft = (parser_stack.get(parser_top-0)).left;
1325                 int qnright = (parser_stack.get(parser_top-0)).right;
1326                 QName qn = (QName)(parser_stack.get(parser_top-0)).value;
1327                  RESULT = qn;
1328               parser_result = new Symbol(26/*NameTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1329             }
1330           return parser_result;
1331 
1332           /*. . . . . . . . . . . . . . . . . . . .*/
1333           case 121: // NameTest ::= STAR
1334             {
1335               Object RESULT = null;
1336                  RESULT = null;
1337               parser_result = new Symbol(26/*NameTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1338             }
1339           return parser_result;
1340 
1341           /*. . . . . . . . . . . . . . . . . . . .*/
1342           case 120: // NodeTest ::= PI
1343             {
1344               Object RESULT = null;
1345                  RESULT = Integer.valueOf(NodeTest.PI);
1346               parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1347             }
1348           return parser_result;
1349 
1350           /*. . . . . . . . . . . . . . . . . . . .*/
1351           case 119: // NodeTest ::= PIPARAM LPAREN Literal RPAREN
1352             {
1353               Object RESULT = null;
1354                 int lleft = (parser_stack.get(parser_top-1)).left;
1355                 int lright = (parser_stack.get(parser_top-1)).right;
1356                 String l = (String)(parser_stack.get(parser_top-1)).value;
1357 
1358            QName name = parser.getQNameIgnoreDefaultNs(&quot;name&quot;);
1359            Expression exp = new EqualityExpr(Operators.EQ,
1360                                              new NameCall(name),
1361                                              new LiteralExpr(l));
1362            List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();
1363            predicates.add(new Predicate(exp));
1364            RESULT = new Step(Axis.CHILD, NodeTest.PI, predicates);
1365 
1366               parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1367             }
1368           return parser_result;
1369 
1370           /*. . . . . . . . . . . . . . . . . . . .*/
1371           case 118: // NodeTest ::= COMMENT
1372             {
1373               Object RESULT = null;
1374                  RESULT = Integer.valueOf(NodeTest.COMMENT);
1375               parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1376             }
1377           return parser_result;
1378 
1379           /*. . . . . . . . . . . . . . . . . . . .*/
1380           case 117: // NodeTest ::= TEXT
1381             {
1382               Object RESULT = null;
1383                  RESULT = Integer.valueOf(NodeTest.TEXT);
1384               parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1385             }
1386           return parser_result;
1387 
1388           /*. . . . . . . . . . . . . . . . . . . .*/
1389           case 116: // NodeTest ::= NODE
1390             {
1391               Object RESULT = null;
1392                  RESULT = Integer.valueOf(NodeTest.ANODE);
1393               parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1394             }
1395           return parser_result;
1396 
1397           /*. . . . . . . . . . . . . . . . . . . .*/
1398           case 115: // NodeTest ::= NameTest
1399             {
1400               Object RESULT = null;
1401                 int ntleft = (parser_stack.get(parser_top-0)).left;
1402                 int ntright = (parser_stack.get(parser_top-0)).right;
1403                 Object nt = parser_stack.get(parser_top-0).value;
1404                  RESULT = nt;
1405               parser_result = new Symbol(25/*NodeTest*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1406             }
1407           return parser_result;
1408 
1409           /*. . . . . . . . . . . . . . . . . . . .*/
1410           case 114: // Argument ::= Expr
1411             {
1412               Expression RESULT = null;
1413                 int exleft = (parser_stack.get(parser_top-0)).left;
1414                 int exright = (parser_stack.get(parser_top-0)).right;
1415                 Expression ex = (Expression)(parser_stack.get(parser_top-0)).value;
1416                  RESULT = ex;
1417               parser_result = new Symbol(3/*Argument*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1418             }
1419           return parser_result;
1420 
1421           /*. . . . . . . . . . . . . . . . . . . .*/
1422           case 113: // VariableName ::= QName
1423             {
1424               QName RESULT = null;
1425                 int vnameleft = (parser_stack.get(parser_top-0)).left;
1426                 int vnameright = (parser_stack.get(parser_top-0)).right;
1427                 QName vname = (QName)(parser_stack.get(parser_top-0)).value;
1428 
1429             RESULT = vname;
1430 
1431               parser_result = new Symbol(39/*VariableName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1432             }
1433           return parser_result;
1434 
1435           /*. . . . . . . . . . . . . . . . . . . .*/
1436           case 112: // FunctionName ::= QName
1437             {
1438               QName RESULT = null;
1439                 int fnameleft = (parser_stack.get(parser_top-0)).left;
1440                 int fnameright = (parser_stack.get(parser_top-0)).right;
1441                 QName fname = (QName)(parser_stack.get(parser_top-0)).value;
1442 
1443             RESULT = fname;
1444 
1445               parser_result = new Symbol(38/*FunctionName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1446             }
1447           return parser_result;
1448 
1449           /*. . . . . . . . . . . . . . . . . . . .*/
1450           case 111: // NonemptyArgumentList ::= Argument COMMA NonemptyArgumentList
1451             {
1452                 List&lt;Expression&gt; RESULT = null;
1453                 int argleft = (parser_stack.get(parser_top-2)).left;
1454                 int argright = (parser_stack.get(parser_top-2)).right;
1455                 Expression arg = (Expression)(parser_stack.get(parser_top-2)).value;
1456                 int arglleft = (parser_stack.get(parser_top-0)).left;
1457                 int arglright = (parser_stack.get(parser_top-0)).right;
1458                 @SuppressWarnings(&quot;unchecked&quot;)
1459                 List&lt;Expression&gt; argl = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-0)).value;
1460                 argl.add(0, arg);
1461                 RESULT = argl;
1462               parser_result = new Symbol(36/*NonemptyArgumentList*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1463             }
1464           return parser_result;
1465 
1466           /*. . . . . . . . . . . . . . . . . . . .*/
1467           case 110: // NonemptyArgumentList ::= Argument
1468             {
1469               List&lt;Expression&gt; RESULT = null;
1470                 int argleft = (parser_stack.get(parser_top-0)).left;
1471                 int argright = (parser_stack.get(parser_top-0)).right;
1472                 Expression arg = (Expression)(parser_stack.get(parser_top-0)).value;
1473 
1474             List&lt;Expression&gt; temp = new ArrayList&lt;&gt;();
1475             temp.add(arg);
1476             RESULT = temp;
1477 
1478               parser_result = new Symbol(36/*NonemptyArgumentList*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1479             }
1480           return parser_result;
1481 
1482           /*. . . . . . . . . . . . . . . . . . . .*/
1483           case 109: // FunctionCall ::= FunctionName LPAREN NonemptyArgumentList RPAREN
1484             {
1485                 Expression RESULT = null;
1486                 int fnameleft = (parser_stack.get(parser_top-3)).left;
1487                 int fnameright = (parser_stack.get(parser_top-3)).right;
1488                 QName fname = (QName)(parser_stack.get(parser_top-3)).value;
1489                 int arglleft = (parser_stack.get(parser_top-1)).left;
1490                 int arglright = (parser_stack.get(parser_top-1)).right;
1491                 @SuppressWarnings(&quot;unchecked&quot;)
1492                 List&lt;Expression&gt; argl = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-1)).value;
1493 
1494           if (fname == parser.getQNameIgnoreDefaultNs(&quot;concat&quot;)) {
1495             RESULT = new ConcatCall(fname, argl);
1496           }
1497           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;number&quot;)) {
1498             RESULT = new NumberCall(fname, argl);
1499           }
1500           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;document&quot;)) {
1501             parser.setMultiDocument(true);
1502             RESULT = new DocumentCall(fname, argl);
1503           }
1504           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string&quot;)) {
1505             RESULT = new StringCall(fname, argl);
1506           }
1507           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;boolean&quot;)) {
1508             RESULT = new BooleanCall(fname, argl);
1509           }
1510           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;name&quot;)) {
1511             RESULT = new NameCall(fname, argl);
1512           }
1513           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;generate-id&quot;)) {
1514             RESULT = new GenerateIdCall(fname, argl);
1515           }
1516           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;not&quot;)) {
1517             RESULT = new NotCall(fname, argl);
1518           }
1519           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;format-number&quot;)) {
1520             RESULT = new FormatNumberCall(fname, argl);
1521           }
1522           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;unparsed-entity-uri&quot;)) {
1523             RESULT = new UnparsedEntityUriCall(fname, argl);
1524           }
1525           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;key&quot;)) {
1526             RESULT = new KeyCall(fname, argl);
1527           }
1528           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;id&quot;)) {
1529             RESULT = new KeyCall(fname, argl);
1530             parser.setHasIdCall(true);
1531           }
1532           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;ceiling&quot;)) {
1533             RESULT = new CeilingCall(fname, argl);
1534           }
1535           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;round&quot;)) {
1536             RESULT = new RoundCall(fname, argl);
1537           }
1538           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;floor&quot;)) {
1539             RESULT = new FloorCall(fname, argl);
1540           }
1541           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;contains&quot;)) {
1542             RESULT = new ContainsCall(fname, argl);
1543           }
1544           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string-length&quot;)) {
1545             RESULT = new StringLengthCall(fname, argl);
1546           }
1547           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;starts-with&quot;)) {
1548             RESULT = new StartsWithCall(fname, argl);
1549           }
1550           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;function-available&quot;)) {
1551             RESULT = new FunctionAvailableCall(fname, argl);
1552           }
1553           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;element-available&quot;)) {
1554             RESULT = new ElementAvailableCall(fname, argl);
1555           }
1556           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;local-name&quot;)) {
1557             RESULT = new LocalNameCall(fname, argl);
1558           }
1559           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;lang&quot;)) {
1560             RESULT = new LangCall(fname, argl);
1561           }
1562           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;)) {
1563             RESULT = new NamespaceUriCall(fname, argl);
1564           }
1565           else if (fname == parser.getQName(Constants.TRANSLET_URI, &quot;xsltc&quot;, &quot;cast&quot;)) {
1566             RESULT = new CastCall(fname, argl);
1567           }
1568           // Special case for extension function nodeset()
1569           else if (fname.getLocalPart().equals(&quot;nodeset&quot;) || fname.getLocalPart().equals(&quot;node-set&quot;)) {
1570             parser.setCallsNodeset(true);  // implies MultiDOM
1571             RESULT = new FunctionCall(fname, argl);
1572           }
1573           else {
1574             RESULT = new FunctionCall(fname, argl);
1575           }
1576 
1577               parser_result = new Symbol(16/*FunctionCall*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1578             }
1579           return parser_result;
1580 
1581           /*. . . . . . . . . . . . . . . . . . . .*/
1582           case 108: // FunctionCall ::= FunctionName LPAREN RPAREN
1583             {
1584               Expression RESULT = null;
1585                 int fnameleft = (parser_stack.get(parser_top-2)).left;
1586                 int fnameright = (parser_stack.get(parser_top-2)).right;
1587                 QName fname = (QName)(parser_stack.get(parser_top-2)).value;
1588 
1589 
1590           if (fname == parser.getQNameIgnoreDefaultNs(&quot;current&quot;)) {
1591             RESULT = new CurrentCall(fname);
1592           }
1593           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;number&quot;)) {
1594             RESULT = new NumberCall(fname, XPathParser.EmptyArgs);
1595           }
1596           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string&quot;)) {
1597             RESULT = new StringCall(fname, XPathParser.EmptyArgs);
1598           }
1599           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;concat&quot;)) {
1600             RESULT = new ConcatCall(fname, XPathParser.EmptyArgs);
1601           }
1602           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;true&quot;)) {
1603             RESULT = new BooleanExpr(true);
1604           }
1605           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;false&quot;)) {
1606             RESULT = new BooleanExpr(false);
1607           }
1608           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;name&quot;)) {
1609             RESULT = new NameCall(fname);
1610           }
1611           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;generate-id&quot;)) {
1612             RESULT = new GenerateIdCall(fname, XPathParser.EmptyArgs);
1613           }
1614           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;string-length&quot;)) {
1615             RESULT = new StringLengthCall(fname, XPathParser.EmptyArgs);
1616           }
1617           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;position&quot;)) {
1618             RESULT = new PositionCall(fname);
1619           }
1620           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;last&quot;)) {
1621             RESULT = new LastCall(fname);
1622           }
1623           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;local-name&quot;)) {
1624             RESULT = new LocalNameCall(fname);
1625           }
1626           else if (fname == parser.getQNameIgnoreDefaultNs(&quot;namespace-uri&quot;)) {
1627             RESULT = new NamespaceUriCall(fname);
1628           }
1629           else {
1630             RESULT = new FunctionCall(fname, XPathParser.EmptyArgs);
1631           }
1632 
1633               parser_result = new Symbol(16/*FunctionCall*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1634             }
1635           return parser_result;
1636 
1637           /*. . . . . . . . . . . . . . . . . . . .*/
1638           case 107: // VariableReference ::= DOLLAR VariableName
1639             {
1640               Expression RESULT = null;
1641                 int varNameleft = (parser_stack.get(parser_top-0)).left;
1642                 int varNameright = (parser_stack.get(parser_top-0)).right;
1643                 QName varName = (QName)(parser_stack.get(parser_top-0)).value;
1644 
1645             // An empty qname prefix for a variable or parameter reference
1646             // should map to the null namespace and not the default URI.
1647             SyntaxTreeNode node = parser.lookupName(varName);
1648 
1649             if (node != null) {
1650                 if (node instanceof Variable) {
1651                     RESULT = new VariableRef((Variable)node);
1652                 }
1653                 else if (node instanceof Param) {
1654                     RESULT = new ParameterRef((Param)node);
1655                 }
1656                 else {
1657                     RESULT = new UnresolvedRef(varName);
1658                 }
1659             }
1660 
1661             if (node == null) {
1662                 RESULT = new UnresolvedRef(varName);
1663             }
1664 
1665               parser_result = new Symbol(15/*VariableReference*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1666             }
1667           return parser_result;
1668 
1669           /*. . . . . . . . . . . . . . . . . . . .*/
1670           case 106: // PrimaryExpr ::= FunctionCall
1671             {
1672               Expression RESULT = null;
1673                 int fcleft = (parser_stack.get(parser_top-0)).left;
1674                 int fcright = (parser_stack.get(parser_top-0)).right;
1675                 Expression fc = (Expression)(parser_stack.get(parser_top-0)).value;
1676                  RESULT = fc;
1677               parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1678             }
1679           return parser_result;
1680 
1681           /*. . . . . . . . . . . . . . . . . . . .*/
1682           case 105: // PrimaryExpr ::= REAL
1683             {
1684               Expression RESULT = null;
1685                 int numleft = (parser_stack.get(parser_top-0)).left;
1686                 int numright = (parser_stack.get(parser_top-0)).right;
1687                 Double num = (Double)(parser_stack.get(parser_top-0)).value;
1688                  RESULT = new RealExpr(num.doubleValue());
1689               parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1690             }
1691           return parser_result;
1692 
1693           /*. . . . . . . . . . . . . . . . . . . .*/
1694           case 104: // PrimaryExpr ::= INT
1695             {
1696               Expression RESULT = null;
1697                 int numleft = (parser_stack.get(parser_top-0)).left;
1698                 int numright = (parser_stack.get(parser_top-0)).right;
1699                 Long num = (Long)(parser_stack.get(parser_top-0)).value;
1700 
1701            long value = num.longValue();
1702            if (value &lt; Integer.MIN_VALUE || value &gt; Integer.MAX_VALUE) {
1703                 RESULT = new RealExpr(value);
1704            }
1705            else {
1706                if (num.doubleValue() == -0)
1707                    RESULT = new RealExpr(num.doubleValue());
1708                else if (num.intValue() == 0)
1709                    RESULT = new IntExpr(num.intValue());
1710                else if (num.doubleValue() == 0.0)
1711                    RESULT = new RealExpr(num.doubleValue());
1712                else
1713                    RESULT = new IntExpr(num.intValue());
1714            }
1715 
1716               parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1717             }
1718           return parser_result;
1719 
1720           /*. . . . . . . . . . . . . . . . . . . .*/
1721           case 103: // PrimaryExpr ::= Literal
1722             {
1723               Expression RESULT = null;
1724                 int stringleft = (parser_stack.get(parser_top-0)).left;
1725                 int stringright = (parser_stack.get(parser_top-0)).right;
1726                 String string = (String)(parser_stack.get(parser_top-0)).value;
1727 
1728         /*
1729         * If the string appears to have the syntax of a QName, store
1730         * namespace info in the literal expression. This is used for
1731         * element-available and function-available functions, among
1732         * others. Also, the default namespace must be ignored.
1733         */
1734         String namespace = null;
1735         final int index = string.lastIndexOf(&#39;:&#39;);
1736 
1737         if (index &gt; 0) {
1738             final String prefix = string.substring(0, index);
1739             namespace = parser._symbolTable.lookupNamespace(prefix);
1740         }
1741         RESULT = (namespace == null) ? new LiteralExpr(string)
1742                      : new LiteralExpr(string, namespace);
1743 
1744               parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1745             }
1746           return parser_result;
1747 
1748           /*. . . . . . . . . . . . . . . . . . . .*/
1749           case 102: // PrimaryExpr ::= LPAREN Expr RPAREN
1750             {
1751               Expression RESULT = null;
1752                 int exleft = (parser_stack.get(parser_top-1)).left;
1753                 int exright = (parser_stack.get(parser_top-1)).right;
1754                 Expression ex = (Expression)(parser_stack.get(parser_top-1)).value;
1755                  RESULT = ex;
1756               parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1757             }
1758           return parser_result;
1759 
1760           /*. . . . . . . . . . . . . . . . . . . .*/
1761           case 101: // PrimaryExpr ::= VariableReference
1762             {
1763               Expression RESULT = null;
1764                 int vrleft = (parser_stack.get(parser_top-0)).left;
1765                 int vrright = (parser_stack.get(parser_top-0)).right;
1766                 Expression vr = (Expression)(parser_stack.get(parser_top-0)).value;
1767                  RESULT = vr;
1768               parser_result = new Symbol(17/*PrimaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1769             }
1770           return parser_result;
1771 
1772           /*. . . . . . . . . . . . . . . . . . . .*/
1773           case 100: // FilterExpr ::= PrimaryExpr Predicates
1774             {
1775               Expression RESULT = null;
1776                 int primaryleft = (parser_stack.get(parser_top-1)).left;
1777                 int primaryright = (parser_stack.get(parser_top-1)).right;
1778                 Expression primary = (Expression)(parser_stack.get(parser_top-1)).value;
1779                 int ppleft = (parser_stack.get(parser_top-0)).left;
1780                 int ppright = (parser_stack.get(parser_top-0)).right;
1781                 @SuppressWarnings(&quot;unchecked&quot;)
1782                 List&lt;Expression&gt; pp = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-0)).value;
1783                  RESULT = new FilterExpr(primary, pp);
1784               parser_result = new Symbol(6/*FilterExpr*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1785             }
1786           return parser_result;
1787 
1788           /*. . . . . . . . . . . . . . . . . . . .*/
1789           case 99: // FilterExpr ::= PrimaryExpr
1790             {
1791               Expression RESULT = null;
1792                 int primaryleft = (parser_stack.get(parser_top-0)).left;
1793                 int primaryright = (parser_stack.get(parser_top-0)).right;
1794                 Expression primary = (Expression)(parser_stack.get(parser_top-0)).value;
1795                  RESULT = primary;
1796               parser_result = new Symbol(6/*FilterExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1797             }
1798           return parser_result;
1799 
1800           /*. . . . . . . . . . . . . . . . . . . .*/
1801           case 98: // AbbreviatedStep ::= DDOT
1802             {
1803               Expression RESULT = null;
1804                  RESULT = new Step(Axis.PARENT, NodeTest.ANODE, null);
1805               parser_result = new Symbol(20/*AbbreviatedStep*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1806             }
1807           return parser_result;
1808 
1809           /*. . . . . . . . . . . . . . . . . . . .*/
1810           case 97: // AbbreviatedStep ::= DOT
1811             {
1812               Expression RESULT = null;
1813                  RESULT = new Step(Axis.SELF, NodeTest.ANODE, null);
1814               parser_result = new Symbol(20/*AbbreviatedStep*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1815             }
1816           return parser_result;
1817 
1818           /*. . . . . . . . . . . . . . . . . . . .*/
1819           case 96: // AxisName ::= SELF
1820             {
1821               Integer RESULT = null;
1822                  RESULT = Integer.valueOf(Axis.SELF);
1823               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1824             }
1825           return parser_result;
1826 
1827           /*. . . . . . . . . . . . . . . . . . . .*/
1828           case 95: // AxisName ::= PRECEDINGSIBLING
1829             {
1830               Integer RESULT = null;
1831                  RESULT = Integer.valueOf(Axis.PRECEDINGSIBLING);
1832               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1833             }
1834           return parser_result;
1835 
1836           /*. . . . . . . . . . . . . . . . . . . .*/
1837           case 94: // AxisName ::= PRECEDING
1838             {
1839               Integer RESULT = null;
1840                  RESULT = Integer.valueOf(Axis.PRECEDING);
1841               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1842             }
1843           return parser_result;
1844 
1845           /*. . . . . . . . . . . . . . . . . . . .*/
1846           case 93: // AxisName ::= PARENT
1847             {
1848               Integer RESULT = null;
1849                  RESULT = Integer.valueOf(Axis.PARENT);
1850               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1851             }
1852           return parser_result;
1853 
1854           /*. . . . . . . . . . . . . . . . . . . .*/
1855           case 92: // AxisName ::= NAMESPACE
1856             {
1857               Integer RESULT = null;
1858                  RESULT = Integer.valueOf(Axis.NAMESPACE);
1859               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1860             }
1861           return parser_result;
1862 
1863           /*. . . . . . . . . . . . . . . . . . . .*/
1864           case 91: // AxisName ::= FOLLOWINGSIBLING
1865             {
1866               Integer RESULT = null;
1867                  RESULT = Integer.valueOf(Axis.FOLLOWINGSIBLING);
1868               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1869             }
1870           return parser_result;
1871 
1872           /*. . . . . . . . . . . . . . . . . . . .*/
1873           case 90: // AxisName ::= FOLLOWING
1874             {
1875               Integer RESULT = null;
1876                  RESULT = Integer.valueOf(Axis.FOLLOWING);
1877               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1878             }
1879           return parser_result;
1880 
1881           /*. . . . . . . . . . . . . . . . . . . .*/
1882           case 89: // AxisName ::= DESCENDANTORSELF
1883             {
1884               Integer RESULT = null;
1885                  RESULT = Integer.valueOf(Axis.DESCENDANTORSELF);
1886               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1887             }
1888           return parser_result;
1889 
1890           /*. . . . . . . . . . . . . . . . . . . .*/
1891           case 88: // AxisName ::= DESCENDANT
1892             {
1893               Integer RESULT = null;
1894                  RESULT = Integer.valueOf(Axis.DESCENDANT);
1895               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1896             }
1897           return parser_result;
1898 
1899           /*. . . . . . . . . . . . . . . . . . . .*/
1900           case 87: // AxisName ::= CHILD
1901             {
1902               Integer RESULT = null;
1903                  RESULT = Integer.valueOf(Axis.CHILD);
1904               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1905             }
1906           return parser_result;
1907 
1908           /*. . . . . . . . . . . . . . . . . . . .*/
1909           case 86: // AxisName ::= ATTRIBUTE
1910             {
1911               Integer RESULT = null;
1912                  RESULT = Integer.valueOf(Axis.ATTRIBUTE);
1913               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1914             }
1915           return parser_result;
1916 
1917           /*. . . . . . . . . . . . . . . . . . . .*/
1918           case 85: // AxisName ::= ANCESTORORSELF
1919             {
1920               Integer RESULT = null;
1921                  RESULT = Integer.valueOf(Axis.ANCESTORORSELF);
1922               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1923             }
1924           return parser_result;
1925 
1926           /*. . . . . . . . . . . . . . . . . . . .*/
1927           case 84: // AxisName ::= ANCESTOR
1928             {
1929               Integer RESULT = null;
1930                  RESULT = Integer.valueOf(Axis.ANCESTOR);
1931               parser_result = new Symbol(40/*AxisName*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1932             }
1933           return parser_result;
1934 
1935           /*. . . . . . . . . . . . . . . . . . . .*/
1936           case 83: // AxisSpecifier ::= ATSIGN
1937             {
1938               Integer RESULT = null;
1939                  RESULT = Integer.valueOf(Axis.ATTRIBUTE);
1940               parser_result = new Symbol(41/*AxisSpecifier*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1941             }
1942           return parser_result;
1943 
1944           /*. . . . . . . . . . . . . . . . . . . .*/
1945           case 82: // AxisSpecifier ::= AxisName DCOLON
1946             {
1947               Integer RESULT = null;
1948                 int anleft = (parser_stack.get(parser_top-1)).left;
1949                 int anright = (parser_stack.get(parser_top-1)).right;
1950                 Integer an = (Integer)(parser_stack.get(parser_top-1)).value;
1951                  RESULT = an;
1952               parser_result = new Symbol(41/*AxisSpecifier*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1953             }
1954           return parser_result;
1955 
1956           /*. . . . . . . . . . . . . . . . . . . .*/
1957           case 81: // Step ::= AbbreviatedStep
1958             {
1959               Expression RESULT = null;
1960                 int abbrevleft = (parser_stack.get(parser_top-0)).left;
1961                 int abbrevright = (parser_stack.get(parser_top-0)).right;
1962                 Expression abbrev = (Expression)(parser_stack.get(parser_top-0)).value;
1963                  RESULT = abbrev;
1964               parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1965             }
1966           return parser_result;
1967 
1968           /*. . . . . . . . . . . . . . . . . . . .*/
1969           case 80: // Step ::= AxisSpecifier NodeTest
1970             {
1971               Expression RESULT = null;
1972                 int axisleft = (parser_stack.get(parser_top-1)).left;
1973                 int axisright = (parser_stack.get(parser_top-1)).right;
1974                 Integer axis = (Integer)(parser_stack.get(parser_top-1)).value;
1975                 int ntestleft = (parser_stack.get(parser_top-0)).left;
1976                 int ntestright = (parser_stack.get(parser_top-0)).right;
1977                 Object ntest = parser_stack.get(parser_top-0).value;
1978                  RESULT = new Step(axis.intValue(),
1979                              parser.findNodeType(axis.intValue(), ntest),
1980                              null);
1981 
1982               parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
1983             }
1984           return parser_result;
1985 
1986           /*. . . . . . . . . . . . . . . . . . . .*/
1987           case 79: // Step ::= AxisSpecifier NodeTest Predicates
1988             {
1989               Expression RESULT = null;
1990                 int axisleft = (parser_stack.get(parser_top-2)).left;
1991                 int axisright = (parser_stack.get(parser_top-2)).right;
1992                 Integer axis = (Integer)(parser_stack.get(parser_top-2)).value;
1993                 int ntestleft = (parser_stack.get(parser_top-1)).left;
1994                 int ntestright = (parser_stack.get(parser_top-1)).right;
1995                 Object ntest = parser_stack.get(parser_top-1).value;
1996                 int ppleft = (parser_stack.get(parser_top-0)).left;
1997                 int ppright = (parser_stack.get(parser_top-0)).right;
1998                 @SuppressWarnings(&quot;unchecked&quot;)
1999                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
2000                  RESULT = new Step(axis.intValue(),
2001                              parser.findNodeType(axis.intValue(), ntest),
2002                              pp);
2003 
2004               parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2005             }
2006           return parser_result;
2007 
2008           /*. . . . . . . . . . . . . . . . . . . .*/
2009           case 78: // Step ::= NodeTest Predicates
2010             {
2011               Expression RESULT = null;
2012                 int ntestleft = (parser_stack.get(parser_top-1)).left;
2013                 int ntestright = (parser_stack.get(parser_top-1)).right;
2014                 Object ntest = parser_stack.get(parser_top-1).value;
2015                 int ppleft = (parser_stack.get(parser_top-0)).left;
2016                 int ppright = (parser_stack.get(parser_top-0)).right;
2017                 @SuppressWarnings(&quot;unchecked&quot;)
2018                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
2019 
2020             if (ntest instanceof Step) {
2021                 Step step = (Step)ntest;
2022                 step.addPredicates(pp);
2023                 RESULT = (Step)ntest;
2024             }
2025             else {
2026                 RESULT = new Step(Axis.CHILD,
2027                              parser.findNodeType(Axis.CHILD, ntest), pp);
2028             }
2029 
2030               parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2031             }
2032           return parser_result;
2033 
2034           /*. . . . . . . . . . . . . . . . . . . .*/
2035           case 77: // Step ::= NodeTest
2036             {
2037               Expression RESULT = null;
2038                 int ntestleft = (parser_stack.get(parser_top-0)).left;
2039                 int ntestright = (parser_stack.get(parser_top-0)).right;
2040                 Object ntest = parser_stack.get(parser_top-0).value;
2041 
2042             if (ntest instanceof Step) {
2043                 RESULT = (Step)ntest;
2044             }
2045             else {
2046                 RESULT = new Step(Axis.CHILD,
2047                              parser.findNodeType(Axis.CHILD, ntest),
2048                              null);
2049             }
2050 
2051               parser_result = new Symbol(7/*Step*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2052             }
2053           return parser_result;
2054 
2055           /*. . . . . . . . . . . . . . . . . . . .*/
2056           case 76: // AbbreviatedAbsoluteLocationPath ::= DSLASH RelativeLocationPath
2057             {
2058               Expression RESULT = null;
2059                 int rlpleft = (parser_stack.get(parser_top-0)).left;
2060                 int rlpright = (parser_stack.get(parser_top-0)).right;
2061                 Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
2062 
2063            //
2064            // Expand &#39;//&#39; into &#39;/descendant-or-self::node()/&#39; or
2065            // into /descendant-or-self::*/
2066            //
2067            int nodeType = DOM.NO_TYPE;
2068            if (rlp instanceof Step &amp;&amp;
2069                parser.isElementAxis(((Step) rlp).getAxis()))
2070            {
2071                nodeType = DTM.ELEMENT_NODE;
2072            }
2073            final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
2074            RESULT = new AbsoluteLocationPath(parser.insertStep(step,
2075                                 (RelativeLocationPath) rlp));
2076 
2077               parser_result = new Symbol(24/*AbbreviatedAbsoluteLocationPath*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2078             }
2079           return parser_result;
2080 
2081           /*. . . . . . . . . . . . . . . . . . . .*/
2082           case 75: // AbbreviatedRelativeLocationPath ::= RelativeLocationPath DSLASH Step
2083             {
2084               Expression RESULT = null;
2085                 int rlpleft = (parser_stack.get(parser_top-2)).left;
2086                 int rlpright = (parser_stack.get(parser_top-2)).right;
2087                 Expression rlp = (Expression)(parser_stack.get(parser_top-2)).value;
2088                 int stepleft = (parser_stack.get(parser_top-0)).left;
2089                 int stepright = (parser_stack.get(parser_top-0)).right;
2090                 Expression step = (Expression)(parser_stack.get(parser_top-0)).value;
2091 
2092            final Step right  = (Step)step;
2093            final int  axis   = right.getAxis();
2094            final int  type   = right.getNodeType();
2095            final List&lt;Predicate&gt; predicates = right.getPredicates();
2096 
2097            if ((axis == Axis.CHILD) &amp;&amp; (type != NodeTest.ATTRIBUTE)) {
2098                // Compress &#39;.//child:E&#39; into &#39;descendant::E&#39; - if possible
2099                if (predicates == null) {
2100                    right.setAxis(Axis.DESCENDANT);
2101                    if (rlp instanceof Step &amp;&amp; ((Step)rlp).isAbbreviatedDot()) {
2102                        RESULT = right;
2103                    }
2104                    else {
2105                        // Expand &#39;rlp//child::E&#39; into &#39;rlp/descendant::E&#39;
2106                        RelativeLocationPath left = (RelativeLocationPath)rlp;
2107                        RESULT = new ParentLocationPath(left, right);
2108                    }
2109                }
2110                else {
2111                    // Expand &#39;.//step&#39; -&gt; &#39;descendant-or-self::*/step&#39;
2112                    if (rlp instanceof Step &amp;&amp; ((Step)rlp).isAbbreviatedDot()) {
2113                        Step left = new Step(Axis.DESCENDANTORSELF,
2114                             DTM.ELEMENT_NODE, null);
2115                        RESULT = new ParentLocationPath(left, right);
2116                    }
2117                    else {
2118                        // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::*/step&#39;
2119                        RelativeLocationPath left = (RelativeLocationPath)rlp;
2120                        Step mid = new Step(Axis.DESCENDANTORSELF,
2121                             DTM.ELEMENT_NODE, null);
2122                        ParentLocationPath ppl = new ParentLocationPath(mid, right);
2123                        RESULT = new ParentLocationPath(left, ppl);
2124                    }
2125                }
2126            }
2127            else if ((axis == Axis.ATTRIBUTE) || (type == NodeTest.ATTRIBUTE)) {
2128                // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::*/step&#39;
2129                RelativeLocationPath left = (RelativeLocationPath)rlp;
2130                Step middle = new Step(Axis.DESCENDANTORSELF,
2131                     DTM.ELEMENT_NODE, null);
2132                ParentLocationPath ppl = new ParentLocationPath(middle, right);
2133                RESULT = new ParentLocationPath(left, ppl);
2134            }
2135            else {
2136                // Expand &#39;rlp//step&#39; -&gt; &#39;rlp/descendant-or-self::node()/step&#39;
2137                RelativeLocationPath left = (RelativeLocationPath)rlp;
2138                Step middle = new Step(Axis.DESCENDANTORSELF,
2139                     DOM.NO_TYPE, null);
2140                ParentLocationPath ppl = new ParentLocationPath(middle, right);
2141                RESULT = new ParentLocationPath(left, ppl);
2142            }
2143 
2144               parser_result = new Symbol(22/*AbbreviatedRelativeLocationPath*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2145             }
2146           return parser_result;
2147 
2148           /*. . . . . . . . . . . . . . . . . . . .*/
2149           case 74: // AbsoluteLocationPath ::= AbbreviatedAbsoluteLocationPath
2150             {
2151               Expression RESULT = null;
2152                 int aalpleft = (parser_stack.get(parser_top-0)).left;
2153                 int aalpright = (parser_stack.get(parser_top-0)).right;
2154                 Expression aalp = (Expression)(parser_stack.get(parser_top-0)).value;
2155                  RESULT = aalp;
2156               parser_result = new Symbol(23/*AbsoluteLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2157             }
2158           return parser_result;
2159 
2160           /*. . . . . . . . . . . . . . . . . . . .*/
2161           case 73: // AbsoluteLocationPath ::= SLASH RelativeLocationPath
2162             {
2163               Expression RESULT = null;
2164                 int rlpleft = (parser_stack.get(parser_top-0)).left;
2165                 int rlpright = (parser_stack.get(parser_top-0)).right;
2166                 Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
2167                  RESULT = new AbsoluteLocationPath(rlp);
2168               parser_result = new Symbol(23/*AbsoluteLocationPath*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2169             }
2170           return parser_result;
2171 
2172           /*. . . . . . . . . . . . . . . . . . . .*/
2173           case 72: // AbsoluteLocationPath ::= SLASH
2174             {
2175               Expression RESULT = null;
2176                  RESULT = new AbsoluteLocationPath();
2177               parser_result = new Symbol(23/*AbsoluteLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2178             }
2179           return parser_result;
2180 
2181           /*. . . . . . . . . . . . . . . . . . . .*/
2182           case 71: // RelativeLocationPath ::= AbbreviatedRelativeLocationPath
2183             {
2184               Expression RESULT = null;
2185                 int arlpleft = (parser_stack.get(parser_top-0)).left;
2186                 int arlpright = (parser_stack.get(parser_top-0)).right;
2187                 Expression arlp = (Expression)(parser_stack.get(parser_top-0)).value;
2188                  RESULT = arlp;
2189               parser_result = new Symbol(21/*RelativeLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2190             }
2191           return parser_result;
2192 
2193           /*. . . . . . . . . . . . . . . . . . . .*/
2194           case 70: // RelativeLocationPath ::= RelativeLocationPath SLASH Step
2195             {
2196               Expression RESULT = null;
2197                 int rlpleft = (parser_stack.get(parser_top-2)).left;
2198                 int rlpright = (parser_stack.get(parser_top-2)).right;
2199                 Expression rlp = (Expression)(parser_stack.get(parser_top-2)).value;
2200                 int stepleft = (parser_stack.get(parser_top-0)).left;
2201                 int stepright = (parser_stack.get(parser_top-0)).right;
2202                 Expression step = (Expression)(parser_stack.get(parser_top-0)).value;
2203 
2204         if (rlp instanceof Step &amp;&amp; ((Step) rlp).isAbbreviatedDot()) {
2205               RESULT = step;       // Remove &#39;./&#39; from the middle
2206         }
2207         else if (((Step) step).isAbbreviatedDot()) {
2208               RESULT = rlp;        // Remove &#39;/.&#39; from the end
2209         }
2210         else {
2211              RESULT =
2212                 new ParentLocationPath((RelativeLocationPath) rlp, step);
2213            }
2214 
2215               parser_result = new Symbol(21/*RelativeLocationPath*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2216             }
2217           return parser_result;
2218 
2219           /*. . . . . . . . . . . . . . . . . . . .*/
2220           case 69: // RelativeLocationPath ::= Step
2221             {
2222               Expression RESULT = null;
2223                 int stepleft = (parser_stack.get(parser_top-0)).left;
2224                 int stepright = (parser_stack.get(parser_top-0)).right;
2225                 Expression step = (Expression)(parser_stack.get(parser_top-0)).value;
2226                  RESULT = step;
2227               parser_result = new Symbol(21/*RelativeLocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2228             }
2229           return parser_result;
2230 
2231           /*. . . . . . . . . . . . . . . . . . . .*/
2232           case 68: // LocationPath ::= AbsoluteLocationPath
2233             {
2234               Expression RESULT = null;
2235                 int alpleft = (parser_stack.get(parser_top-0)).left;
2236                 int alpright = (parser_stack.get(parser_top-0)).right;
2237                 Expression alp = (Expression)(parser_stack.get(parser_top-0)).value;
2238                  RESULT = alp;
2239               parser_result = new Symbol(4/*LocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2240             }
2241           return parser_result;
2242 
2243           /*. . . . . . . . . . . . . . . . . . . .*/
2244           case 67: // LocationPath ::= RelativeLocationPath
2245             {
2246               Expression RESULT = null;
2247                 int rlpleft = (parser_stack.get(parser_top-0)).left;
2248                 int rlpright = (parser_stack.get(parser_top-0)).right;
2249                 Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
2250                  RESULT = rlp;
2251               parser_result = new Symbol(4/*LocationPath*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2252             }
2253           return parser_result;
2254 
2255           /*. . . . . . . . . . . . . . . . . . . .*/
2256           case 66: // PathExpr ::= FilterExpr DSLASH RelativeLocationPath
2257             {
2258               Expression RESULT = null;
2259                 int fexpleft = (parser_stack.get(parser_top-2)).left;
2260                 int fexpright = (parser_stack.get(parser_top-2)).right;
2261                 Expression fexp = (Expression)(parser_stack.get(parser_top-2)).value;
2262                 int rlpleft = (parser_stack.get(parser_top-0)).left;
2263                 int rlpright = (parser_stack.get(parser_top-0)).right;
2264                 Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
2265 
2266            //
2267            // Expand &#39;//&#39; into &#39;/descendant-or-self::node()/&#39; or
2268            // into /descendant-or-self::*/
2269            //
2270            int nodeType = DOM.NO_TYPE;
2271            if (rlp instanceof Step &amp;&amp;
2272                parser.isElementAxis(((Step) rlp).getAxis()))
2273            {
2274                nodeType = DTM.ELEMENT_NODE;
2275            }
2276            final Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
2277            FilterParentPath fpp = new FilterParentPath(fexp, step);
2278            fpp = new FilterParentPath(fpp, rlp);
2279            if (fexp instanceof KeyCall == false) {
2280                fpp.setDescendantAxis();
2281            }
2282            RESULT = fpp;
2283 
2284               parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2285             }
2286           return parser_result;
2287 
2288           /*. . . . . . . . . . . . . . . . . . . .*/
2289           case 65: // PathExpr ::= FilterExpr SLASH RelativeLocationPath
2290             {
2291               Expression RESULT = null;
2292                 int fexpleft = (parser_stack.get(parser_top-2)).left;
2293                 int fexpright = (parser_stack.get(parser_top-2)).right;
2294                 Expression fexp = (Expression)(parser_stack.get(parser_top-2)).value;
2295                 int rlpleft = (parser_stack.get(parser_top-0)).left;
2296                 int rlpright = (parser_stack.get(parser_top-0)).right;
2297                 Expression rlp = (Expression)(parser_stack.get(parser_top-0)).value;
2298                  RESULT = new FilterParentPath(fexp, rlp);
2299               parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2300             }
2301           return parser_result;
2302 
2303           /*. . . . . . . . . . . . . . . . . . . .*/
2304           case 64: // PathExpr ::= FilterExpr
2305             {
2306               Expression RESULT = null;
2307                 int fexpleft = (parser_stack.get(parser_top-0)).left;
2308                 int fexpright = (parser_stack.get(parser_top-0)).right;
2309                 Expression fexp = (Expression)(parser_stack.get(parser_top-0)).value;
2310                  RESULT = fexp;
2311               parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2312             }
2313           return parser_result;
2314 
2315           /*. . . . . . . . . . . . . . . . . . . .*/
2316           case 63: // PathExpr ::= LocationPath
2317             {
2318               Expression RESULT = null;
2319                 int lpleft = (parser_stack.get(parser_top-0)).left;
2320                 int lpright = (parser_stack.get(parser_top-0)).right;
2321                 Expression lp = (Expression)(parser_stack.get(parser_top-0)).value;
2322                  RESULT = lp;
2323               parser_result = new Symbol(19/*PathExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2324             }
2325           return parser_result;
2326 
2327           /*. . . . . . . . . . . . . . . . . . . .*/
2328           case 62: // UnionExpr ::= PathExpr VBAR UnionExpr
2329             {
2330               Expression RESULT = null;
2331                 int peleft = (parser_stack.get(parser_top-2)).left;
2332                 int peright = (parser_stack.get(parser_top-2)).right;
2333                 Expression pe = (Expression)(parser_stack.get(parser_top-2)).value;
2334                 int restleft = (parser_stack.get(parser_top-0)).left;
2335                 int restright = (parser_stack.get(parser_top-0)).right;
2336                 Expression rest = (Expression)(parser_stack.get(parser_top-0)).value;
2337                  RESULT = new UnionPathExpr(pe, rest);
2338               parser_result = new Symbol(18/*UnionExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2339             }
2340           return parser_result;
2341 
2342           /*. . . . . . . . . . . . . . . . . . . .*/
2343           case 61: // UnionExpr ::= PathExpr
2344             {
2345               Expression RESULT = null;
2346                 int peleft = (parser_stack.get(parser_top-0)).left;
2347                 int peright = (parser_stack.get(parser_top-0)).right;
2348                 Expression pe = (Expression)(parser_stack.get(parser_top-0)).value;
2349                  RESULT = pe;
2350               parser_result = new Symbol(18/*UnionExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2351             }
2352           return parser_result;
2353 
2354           /*. . . . . . . . . . . . . . . . . . . .*/
2355           case 60: // UnaryExpr ::= MINUS UnaryExpr
2356             {
2357               Expression RESULT = null;
2358                 int ueleft = (parser_stack.get(parser_top-0)).left;
2359                 int ueright = (parser_stack.get(parser_top-0)).right;
2360                 Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
2361                  RESULT = new UnaryOpExpr(ue);
2362               parser_result = new Symbol(14/*UnaryExpr*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2363             }
2364           return parser_result;
2365 
2366           /*. . . . . . . . . . . . . . . . . . . .*/
2367           case 59: // UnaryExpr ::= UnionExpr
2368             {
2369               Expression RESULT = null;
2370                 int ueleft = (parser_stack.get(parser_top-0)).left;
2371                 int ueright = (parser_stack.get(parser_top-0)).right;
2372                 Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
2373                  RESULT = ue;
2374               parser_result = new Symbol(14/*UnaryExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2375             }
2376           return parser_result;
2377 
2378           /*. . . . . . . . . . . . . . . . . . . .*/
2379           case 58: // MultiplicativeExpr ::= MultiplicativeExpr MOD UnaryExpr
2380             {
2381               Expression RESULT = null;
2382                 int meleft = (parser_stack.get(parser_top-2)).left;
2383                 int meright = (parser_stack.get(parser_top-2)).right;
2384                 Expression me = (Expression)(parser_stack.get(parser_top-2)).value;
2385                 int ueleft = (parser_stack.get(parser_top-0)).left;
2386                 int ueright = (parser_stack.get(parser_top-0)).right;
2387                 Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
2388                  RESULT = new BinOpExpr(BinOpExpr.MOD, me, ue);
2389               parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2390             }
2391           return parser_result;
2392 
2393           /*. . . . . . . . . . . . . . . . . . . .*/
2394           case 57: // MultiplicativeExpr ::= MultiplicativeExpr DIV UnaryExpr
2395             {
2396               Expression RESULT = null;
2397                 int meleft = (parser_stack.get(parser_top-2)).left;
2398                 int meright = (parser_stack.get(parser_top-2)).right;
2399                 Expression me = (Expression)(parser_stack.get(parser_top-2)).value;
2400                 int ueleft = (parser_stack.get(parser_top-0)).left;
2401                 int ueright = (parser_stack.get(parser_top-0)).right;
2402                 Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
2403                  RESULT = new BinOpExpr(BinOpExpr.DIV, me, ue);
2404               parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2405             }
2406           return parser_result;
2407 
2408           /*. . . . . . . . . . . . . . . . . . . .*/
2409           case 56: // MultiplicativeExpr ::= MultiplicativeExpr STAR UnaryExpr
2410             {
2411               Expression RESULT = null;
2412                 int meleft = (parser_stack.get(parser_top-2)).left;
2413                 int meright = (parser_stack.get(parser_top-2)).right;
2414                 Expression me = (Expression)(parser_stack.get(parser_top-2)).value;
2415                 int ueleft = (parser_stack.get(parser_top-0)).left;
2416                 int ueright = (parser_stack.get(parser_top-0)).right;
2417                 Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
2418                  RESULT = new BinOpExpr(BinOpExpr.TIMES, me, ue);
2419               parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2420             }
2421           return parser_result;
2422 
2423           /*. . . . . . . . . . . . . . . . . . . .*/
2424           case 55: // MultiplicativeExpr ::= UnaryExpr
2425             {
2426               Expression RESULT = null;
2427                 int ueleft = (parser_stack.get(parser_top-0)).left;
2428                 int ueright = (parser_stack.get(parser_top-0)).right;
2429                 Expression ue = (Expression)(parser_stack.get(parser_top-0)).value;
2430                  RESULT = ue;
2431               parser_result = new Symbol(13/*MultiplicativeExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2432             }
2433           return parser_result;
2434 
2435           /*. . . . . . . . . . . . . . . . . . . .*/
2436           case 54: // AdditiveExpr ::= AdditiveExpr MINUS MultiplicativeExpr
2437             {
2438               Expression RESULT = null;
2439                 int aeleft = (parser_stack.get(parser_top-2)).left;
2440                 int aeright = (parser_stack.get(parser_top-2)).right;
2441                 Expression ae = (Expression)(parser_stack.get(parser_top-2)).value;
2442                 int meleft = (parser_stack.get(parser_top-0)).left;
2443                 int meright = (parser_stack.get(parser_top-0)).right;
2444                 Expression me = (Expression)(parser_stack.get(parser_top-0)).value;
2445                  RESULT = new BinOpExpr(BinOpExpr.MINUS, ae, me);
2446               parser_result = new Symbol(12/*AdditiveExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2447             }
2448           return parser_result;
2449 
2450           /*. . . . . . . . . . . . . . . . . . . .*/
2451           case 53: // AdditiveExpr ::= AdditiveExpr PLUS MultiplicativeExpr
2452             {
2453               Expression RESULT = null;
2454                 int aeleft = (parser_stack.get(parser_top-2)).left;
2455                 int aeright = (parser_stack.get(parser_top-2)).right;
2456                 Expression ae = (Expression)(parser_stack.get(parser_top-2)).value;
2457                 int meleft = (parser_stack.get(parser_top-0)).left;
2458                 int meright = (parser_stack.get(parser_top-0)).right;
2459                 Expression me = (Expression)(parser_stack.get(parser_top-0)).value;
2460                  RESULT = new BinOpExpr(BinOpExpr.PLUS, ae, me);
2461               parser_result = new Symbol(12/*AdditiveExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2462             }
2463           return parser_result;
2464 
2465           /*. . . . . . . . . . . . . . . . . . . .*/
2466           case 52: // AdditiveExpr ::= MultiplicativeExpr
2467             {
2468               Expression RESULT = null;
2469                 int meleft = (parser_stack.get(parser_top-0)).left;
2470                 int meright = (parser_stack.get(parser_top-0)).right;
2471                 Expression me = (Expression)(parser_stack.get(parser_top-0)).value;
2472                  RESULT = me;
2473               parser_result = new Symbol(12/*AdditiveExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2474             }
2475           return parser_result;
2476 
2477           /*. . . . . . . . . . . . . . . . . . . .*/
2478           case 51: // RelationalExpr ::= RelationalExpr GE AdditiveExpr
2479             {
2480               Expression RESULT = null;
2481                 int releft = (parser_stack.get(parser_top-2)).left;
2482                 int reright = (parser_stack.get(parser_top-2)).right;
2483                 Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
2484                 int aeleft = (parser_stack.get(parser_top-0)).left;
2485                 int aeright = (parser_stack.get(parser_top-0)).right;
2486                 Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
2487                  RESULT = new RelationalExpr(Operators.GE, re, ae);
2488               parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2489             }
2490           return parser_result;
2491 
2492           /*. . . . . . . . . . . . . . . . . . . .*/
2493           case 50: // RelationalExpr ::= RelationalExpr LE AdditiveExpr
2494             {
2495               Expression RESULT = null;
2496                 int releft = (parser_stack.get(parser_top-2)).left;
2497                 int reright = (parser_stack.get(parser_top-2)).right;
2498                 Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
2499                 int aeleft = (parser_stack.get(parser_top-0)).left;
2500                 int aeright = (parser_stack.get(parser_top-0)).right;
2501                 Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
2502                  RESULT = new RelationalExpr(Operators.LE, re, ae);
2503               parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2504             }
2505           return parser_result;
2506 
2507           /*. . . . . . . . . . . . . . . . . . . .*/
2508           case 49: // RelationalExpr ::= RelationalExpr GT AdditiveExpr
2509             {
2510               Expression RESULT = null;
2511                 int releft = (parser_stack.get(parser_top-2)).left;
2512                 int reright = (parser_stack.get(parser_top-2)).right;
2513                 Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
2514                 int aeleft = (parser_stack.get(parser_top-0)).left;
2515                 int aeright = (parser_stack.get(parser_top-0)).right;
2516                 Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
2517                  RESULT = new RelationalExpr(Operators.GT, re, ae);
2518               parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2519             }
2520           return parser_result;
2521 
2522           /*. . . . . . . . . . . . . . . . . . . .*/
2523           case 48: // RelationalExpr ::= RelationalExpr LT AdditiveExpr
2524             {
2525               Expression RESULT = null;
2526                 int releft = (parser_stack.get(parser_top-2)).left;
2527                 int reright = (parser_stack.get(parser_top-2)).right;
2528                 Expression re = (Expression)(parser_stack.get(parser_top-2)).value;
2529                 int aeleft = (parser_stack.get(parser_top-0)).left;
2530                 int aeright = (parser_stack.get(parser_top-0)).right;
2531                 Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
2532                  RESULT = new RelationalExpr(Operators.LT, re, ae);
2533               parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2534             }
2535           return parser_result;
2536 
2537           /*. . . . . . . . . . . . . . . . . . . .*/
2538           case 47: // RelationalExpr ::= AdditiveExpr
2539             {
2540               Expression RESULT = null;
2541                 int aeleft = (parser_stack.get(parser_top-0)).left;
2542                 int aeright = (parser_stack.get(parser_top-0)).right;
2543                 Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
2544                  RESULT = ae;
2545               parser_result = new Symbol(11/*RelationalExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2546             }
2547           return parser_result;
2548 
2549           /*. . . . . . . . . . . . . . . . . . . .*/
2550           case 46: // EqualityExpr ::= EqualityExpr NE RelationalExpr
2551             {
2552               Expression RESULT = null;
2553                 int eeleft = (parser_stack.get(parser_top-2)).left;
2554                 int eeright = (parser_stack.get(parser_top-2)).right;
2555                 Expression ee = (Expression)(parser_stack.get(parser_top-2)).value;
2556                 int releft = (parser_stack.get(parser_top-0)).left;
2557                 int reright = (parser_stack.get(parser_top-0)).right;
2558                 Expression re = (Expression)(parser_stack.get(parser_top-0)).value;
2559                  RESULT = new EqualityExpr(Operators.NE, ee, re);
2560               parser_result = new Symbol(10/*EqualityExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2561             }
2562           return parser_result;
2563 
2564           /*. . . . . . . . . . . . . . . . . . . .*/
2565           case 45: // EqualityExpr ::= EqualityExpr EQ RelationalExpr
2566             {
2567               Expression RESULT = null;
2568                 int eeleft = (parser_stack.get(parser_top-2)).left;
2569                 int eeright = (parser_stack.get(parser_top-2)).right;
2570                 Expression ee = (Expression)(parser_stack.get(parser_top-2)).value;
2571                 int releft = (parser_stack.get(parser_top-0)).left;
2572                 int reright = (parser_stack.get(parser_top-0)).right;
2573                 Expression re = (Expression)(parser_stack.get(parser_top-0)).value;
2574                  RESULT = new EqualityExpr(Operators.EQ, ee, re);
2575               parser_result = new Symbol(10/*EqualityExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2576             }
2577           return parser_result;
2578 
2579           /*. . . . . . . . . . . . . . . . . . . .*/
2580           case 44: // EqualityExpr ::= RelationalExpr
2581             {
2582               Expression RESULT = null;
2583                 int releft = (parser_stack.get(parser_top-0)).left;
2584                 int reright = (parser_stack.get(parser_top-0)).right;
2585                 Expression re = (Expression)(parser_stack.get(parser_top-0)).value;
2586                  RESULT = re;
2587               parser_result = new Symbol(10/*EqualityExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2588             }
2589           return parser_result;
2590 
2591           /*. . . . . . . . . . . . . . . . . . . .*/
2592           case 43: // AndExpr ::= AndExpr AND EqualityExpr
2593             {
2594               Expression RESULT = null;
2595                 int aeleft = (parser_stack.get(parser_top-2)).left;
2596                 int aeright = (parser_stack.get(parser_top-2)).right;
2597                 Expression ae = (Expression)(parser_stack.get(parser_top-2)).value;
2598                 int eeleft = (parser_stack.get(parser_top-0)).left;
2599                 int eeright = (parser_stack.get(parser_top-0)).right;
2600                 Expression ee = (Expression)(parser_stack.get(parser_top-0)).value;
2601                  RESULT = new LogicalExpr(LogicalExpr.AND, ae, ee);
2602               parser_result = new Symbol(9/*AndExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2603             }
2604           return parser_result;
2605 
2606           /*. . . . . . . . . . . . . . . . . . . .*/
2607           case 42: // AndExpr ::= EqualityExpr
2608             {
2609               Expression RESULT = null;
2610                 int eleft = (parser_stack.get(parser_top-0)).left;
2611                 int eright = (parser_stack.get(parser_top-0)).right;
2612                 Expression e = (Expression)(parser_stack.get(parser_top-0)).value;
2613                  RESULT = e;
2614               parser_result = new Symbol(9/*AndExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2615             }
2616           return parser_result;
2617 
2618           /*. . . . . . . . . . . . . . . . . . . .*/
2619           case 41: // OrExpr ::= OrExpr OR AndExpr
2620             {
2621               Expression RESULT = null;
2622                 int oeleft = (parser_stack.get(parser_top-2)).left;
2623                 int oeright = (parser_stack.get(parser_top-2)).right;
2624                 Expression oe = (Expression)(parser_stack.get(parser_top-2)).value;
2625                 int aeleft = (parser_stack.get(parser_top-0)).left;
2626                 int aeright = (parser_stack.get(parser_top-0)).right;
2627                 Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
2628                  RESULT = new LogicalExpr(LogicalExpr.OR, oe, ae);
2629               parser_result = new Symbol(8/*OrExpr*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2630             }
2631           return parser_result;
2632 
2633           /*. . . . . . . . . . . . . . . . . . . .*/
2634           case 40: // OrExpr ::= AndExpr
2635             {
2636               Expression RESULT = null;
2637                 int aeleft = (parser_stack.get(parser_top-0)).left;
2638                 int aeright = (parser_stack.get(parser_top-0)).right;
2639                 Expression ae = (Expression)(parser_stack.get(parser_top-0)).value;
2640                  RESULT = ae;
2641               parser_result = new Symbol(8/*OrExpr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2642             }
2643           return parser_result;
2644 
2645           /*. . . . . . . . . . . . . . . . . . . .*/
2646           case 39: // Expr ::= OrExpr
2647             {
2648               Expression RESULT = null;
2649                 int exleft = (parser_stack.get(parser_top-0)).left;
2650                 int exright = (parser_stack.get(parser_top-0)).right;
2651                 Expression ex = (Expression)(parser_stack.get(parser_top-0)).value;
2652                  RESULT = ex;
2653               parser_result = new Symbol(2/*Expr*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2654             }
2655           return parser_result;
2656 
2657           /*. . . . . . . . . . . . . . . . . . . .*/
2658           case 38: // Predicate ::= LBRACK Expr RBRACK
2659             {
2660               Expression RESULT = null;
2661                 int eleft = (parser_stack.get(parser_top-1)).left;
2662                 int eright = (parser_stack.get(parser_top-1)).right;
2663                 Expression e = (Expression)(parser_stack.get(parser_top-1)).value;
2664 
2665                 RESULT = new Predicate(e);
2666 
2667               parser_result = new Symbol(5/*Predicate*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2668             }
2669           return parser_result;
2670 
2671           /*. . . . . . . . . . . . . . . . . . . .*/
2672           case 37: // Predicates ::= Predicate Predicates
2673             {
2674                 List&lt;Expression&gt; RESULT = null;
2675                 int pleft = (parser_stack.get(parser_top-1)).left;
2676                 int pright = (parser_stack.get(parser_top-1)).right;
2677                 Expression p = (Expression)(parser_stack.get(parser_top-1)).value;
2678                 int ppleft = (parser_stack.get(parser_top-0)).left;
2679                 int ppright = (parser_stack.get(parser_top-0)).right;
2680                 @SuppressWarnings(&quot;unchecked&quot;)
2681                 List&lt;Expression&gt; pp = (ArrayList&lt;Expression&gt;)(parser_stack.get(parser_top-0)).value;
2682                 pp.add(0, p); RESULT = pp;
2683               parser_result = new Symbol(35/*Predicates*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2684             }
2685           return parser_result;
2686 
2687           /*. . . . . . . . . . . . . . . . . . . .*/
2688           case 36: // Predicates ::= Predicate
2689             {
2690                 List&lt;Expression&gt; RESULT = null;
2691                 int pleft = (parser_stack.get(parser_top-0)).left;
2692                 int pright = (parser_stack.get(parser_top-0)).right;
2693                 Expression p = (Expression)(parser_stack.get(parser_top-0)).value;
2694 
2695                 List&lt;Expression&gt; temp = new ArrayList&lt;&gt;();
2696                 temp.add(p);
2697                 RESULT = temp;
2698 
2699               parser_result = new Symbol(35/*Predicates*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2700             }
2701           return parser_result;
2702 
2703           /*. . . . . . . . . . . . . . . . . . . .*/
2704           case 35: // ChildOrAttributeAxisSpecifier ::= ATTRIBUTE DCOLON
2705             {
2706               Integer RESULT = null;
2707                  RESULT = Integer.valueOf(Axis.ATTRIBUTE);
2708               parser_result = new Symbol(42/*ChildOrAttributeAxisSpecifier*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2709             }
2710           return parser_result;
2711 
2712           /*. . . . . . . . . . . . . . . . . . . .*/
2713           case 34: // ChildOrAttributeAxisSpecifier ::= CHILD DCOLON
2714             {
2715               Integer RESULT = null;
2716                  RESULT = Integer.valueOf(Axis.CHILD);
2717               parser_result = new Symbol(42/*ChildOrAttributeAxisSpecifier*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2718             }
2719           return parser_result;
2720 
2721           /*. . . . . . . . . . . . . . . . . . . .*/
2722           case 33: // ChildOrAttributeAxisSpecifier ::= ATSIGN
2723             {
2724               Integer RESULT = null;
2725                  RESULT = Integer.valueOf(Axis.ATTRIBUTE);
2726               parser_result = new Symbol(42/*ChildOrAttributeAxisSpecifier*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2727             }
2728           return parser_result;
2729 
2730           /*. . . . . . . . . . . . . . . . . . . .*/
2731           case 32: // NameTestPattern ::= QName
2732             {
2733               Object RESULT = null;
2734                 int qnleft = (parser_stack.get(parser_top-0)).left;
2735                 int qnright = (parser_stack.get(parser_top-0)).right;
2736                 QName qn = (QName)(parser_stack.get(parser_top-0)).value;
2737                  RESULT = qn;
2738               parser_result = new Symbol(34/*NameTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2739             }
2740           return parser_result;
2741 
2742           /*. . . . . . . . . . . . . . . . . . . .*/
2743           case 31: // NameTestPattern ::= STAR
2744             {
2745               Object RESULT = null;
2746                  RESULT = null;
2747               parser_result = new Symbol(34/*NameTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2748             }
2749           return parser_result;
2750 
2751           /*. . . . . . . . . . . . . . . . . . . .*/
2752           case 30: // NodeTestPattern ::= PI
2753             {
2754               Object RESULT = null;
2755                  RESULT = Integer.valueOf(NodeTest.PI);
2756               parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2757             }
2758           return parser_result;
2759 
2760           /*. . . . . . . . . . . . . . . . . . . .*/
2761           case 29: // NodeTestPattern ::= COMMENT
2762             {
2763               Object RESULT = null;
2764                  RESULT = Integer.valueOf(NodeTest.COMMENT);
2765               parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2766             }
2767           return parser_result;
2768 
2769           /*. . . . . . . . . . . . . . . . . . . .*/
2770           case 28: // NodeTestPattern ::= TEXT
2771             {
2772               Object RESULT = null;
2773                  RESULT = Integer.valueOf(NodeTest.TEXT);
2774               parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2775             }
2776           return parser_result;
2777 
2778           /*. . . . . . . . . . . . . . . . . . . .*/
2779           case 27: // NodeTestPattern ::= NODE
2780             {
2781               Object RESULT = null;
2782                  RESULT = Integer.valueOf(NodeTest.ANODE);
2783               parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2784             }
2785           return parser_result;
2786 
2787           /*. . . . . . . . . . . . . . . . . . . .*/
2788           case 26: // NodeTestPattern ::= NameTestPattern
2789             {
2790               Object RESULT = null;
2791                 int ntleft = (parser_stack.get(parser_top-0)).left;
2792                 int ntright = (parser_stack.get(parser_top-0)).right;
2793                 Object nt = parser_stack.get(parser_top-0).value;
2794                  RESULT = nt;
2795               parser_result = new Symbol(33/*NodeTestPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2796             }
2797           return parser_result;
2798 
2799           /*. . . . . . . . . . . . . . . . . . . .*/
2800           case 25: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern Predicates
2801             {
2802               StepPattern RESULT = null;
2803                 int axisleft = (parser_stack.get(parser_top-2)).left;
2804                 int axisright = (parser_stack.get(parser_top-2)).right;
2805                 Integer axis = (Integer)(parser_stack.get(parser_top-2)).value;
2806                 int pipleft = (parser_stack.get(parser_top-1)).left;
2807                 int pipright = (parser_stack.get(parser_top-1)).right;
2808                 StepPattern pip = (StepPattern)(parser_stack.get(parser_top-1)).value;
2809                 int ppleft = (parser_stack.get(parser_top-0)).left;
2810                 int ppright = (parser_stack.get(parser_top-0)).right;
2811                 @SuppressWarnings(&quot;unchecked&quot;)
2812                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
2813 
2814                // TODO: report error if axis is attribute
2815                RESULT = (ProcessingInstructionPattern)pip.setPredicates(pp);
2816 
2817               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2818             }
2819           return parser_result;
2820 
2821           /*. . . . . . . . . . . . . . . . . . . .*/
2822           case 24: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern
2823             {
2824               StepPattern RESULT = null;
2825                 int axisleft = (parser_stack.get(parser_top-1)).left;
2826                 int axisright = (parser_stack.get(parser_top-1)).right;
2827                 Integer axis = (Integer)(parser_stack.get(parser_top-1)).value;
2828                 int pipleft = (parser_stack.get(parser_top-0)).left;
2829                 int pipright = (parser_stack.get(parser_top-0)).right;
2830                 StepPattern pip = (StepPattern)(parser_stack.get(parser_top-0)).value;
2831 
2832                RESULT = pip;    // TODO: report error if axis is attribute
2833 
2834               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2835             }
2836           return parser_result;
2837 
2838           /*. . . . . . . . . . . . . . . . . . . .*/
2839           case 23: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern Predicates
2840             {
2841               StepPattern RESULT = null;
2842                 int axisleft = (parser_stack.get(parser_top-2)).left;
2843                 int axisright = (parser_stack.get(parser_top-2)).right;
2844                 Integer axis = (Integer)(parser_stack.get(parser_top-2)).value;
2845                 int ntleft = (parser_stack.get(parser_top-1)).left;
2846                 int ntright = (parser_stack.get(parser_top-1)).right;
2847                 Object nt = parser_stack.get(parser_top-1).value;
2848                 int ppleft = (parser_stack.get(parser_top-0)).left;
2849                 int ppright = (parser_stack.get(parser_top-0)).right;
2850                 @SuppressWarnings(&quot;unchecked&quot;)
2851                List&lt;Predicate&gt;pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
2852 
2853                RESULT = parser.createStepPattern(axis.intValue(), nt, pp);
2854 
2855               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2856             }
2857           return parser_result;
2858 
2859           /*. . . . . . . . . . . . . . . . . . . .*/
2860           case 22: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern
2861             {
2862               StepPattern RESULT = null;
2863                 int axisleft = (parser_stack.get(parser_top-1)).left;
2864                 int axisright = (parser_stack.get(parser_top-1)).right;
2865                 Integer axis = (Integer)(parser_stack.get(parser_top-1)).value;
2866                 int ntleft = (parser_stack.get(parser_top-0)).left;
2867                 int ntright = (parser_stack.get(parser_top-0)).right;
2868                 Object nt = parser_stack.get(parser_top-0).value;
2869 
2870                RESULT = parser.createStepPattern(axis.intValue(), nt, null);
2871 
2872               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2873             }
2874           return parser_result;
2875 
2876           /*. . . . . . . . . . . . . . . . . . . .*/
2877           case 21: // StepPattern ::= ProcessingInstructionPattern Predicates
2878             {
2879               StepPattern RESULT = null;
2880                 int pipleft = (parser_stack.get(parser_top-1)).left;
2881                 int pipright = (parser_stack.get(parser_top-1)).right;
2882                 StepPattern pip = (StepPattern)(parser_stack.get(parser_top-1)).value;
2883                 int ppleft = (parser_stack.get(parser_top-0)).left;
2884                 int ppright = (parser_stack.get(parser_top-0)).right;
2885                 @SuppressWarnings(&quot;unchecked&quot;)
2886                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
2887                  RESULT = (ProcessingInstructionPattern)pip.setPredicates(pp);
2888               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2889             }
2890           return parser_result;
2891 
2892           /*. . . . . . . . . . . . . . . . . . . .*/
2893           case 20: // StepPattern ::= ProcessingInstructionPattern
2894             {
2895               StepPattern RESULT = null;
2896                 int pipleft = (parser_stack.get(parser_top-0)).left;
2897                 int pipright = (parser_stack.get(parser_top-0)).right;
2898                 StepPattern pip = (StepPattern)(parser_stack.get(parser_top-0)).value;
2899                  RESULT = pip;
2900               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2901             }
2902           return parser_result;
2903 
2904           /*. . . . . . . . . . . . . . . . . . . .*/
2905           case 19: // StepPattern ::= NodeTestPattern Predicates
2906             {
2907               StepPattern RESULT = null;
2908                 int ntleft = (parser_stack.get(parser_top-1)).left;
2909                 int ntright = (parser_stack.get(parser_top-1)).right;
2910                 Object nt = parser_stack.get(parser_top-1).value;
2911                 int ppleft = (parser_stack.get(parser_top-0)).left;
2912                 int ppright = (parser_stack.get(parser_top-0)).right;
2913                 @SuppressWarnings(&quot;unchecked&quot;)
2914                 List&lt;Predicate&gt; pp = (ArrayList&lt;Predicate&gt;)(parser_stack.get(parser_top-0)).value;
2915 
2916                 RESULT = parser.createStepPattern(Axis.CHILD, nt, pp);
2917 
2918               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2919             }
2920           return parser_result;
2921 
2922           /*. . . . . . . . . . . . . . . . . . . .*/
2923           case 18: // StepPattern ::= NodeTestPattern
2924             {
2925               StepPattern RESULT = null;
2926                 int ntleft = (parser_stack.get(parser_top-0)).left;
2927                 int ntright = (parser_stack.get(parser_top-0)).right;
2928                 Object nt = parser_stack.get(parser_top-0).value;
2929 
2930                 RESULT = parser.createStepPattern(Axis.CHILD, nt, null);
2931 
2932               parser_result = new Symbol(32/*StepPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2933             }
2934           return parser_result;
2935 
2936           /*. . . . . . . . . . . . . . . . . . . .*/
2937           case 17: // RelativePathPattern ::= StepPattern DSLASH RelativePathPattern
2938             {
2939               RelativePathPattern RESULT = null;
2940                 int spleft = (parser_stack.get(parser_top-2)).left;
2941                 int spright = (parser_stack.get(parser_top-2)).right;
2942                 StepPattern sp = (StepPattern)(parser_stack.get(parser_top-2)).value;
2943                 int rppleft = (parser_stack.get(parser_top-0)).left;
2944                 int rppright = (parser_stack.get(parser_top-0)).right;
2945                 RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
2946                  RESULT = new AncestorPattern(sp, rpp);
2947               parser_result = new Symbol(31/*RelativePathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2948             }
2949           return parser_result;
2950 
2951           /*. . . . . . . . . . . . . . . . . . . .*/
2952           case 16: // RelativePathPattern ::= StepPattern SLASH RelativePathPattern
2953             {
2954               RelativePathPattern RESULT = null;
2955                 int spleft = (parser_stack.get(parser_top-2)).left;
2956                 int spright = (parser_stack.get(parser_top-2)).right;
2957                 StepPattern sp = (StepPattern)(parser_stack.get(parser_top-2)).value;
2958                 int rppleft = (parser_stack.get(parser_top-0)).left;
2959                 int rppright = (parser_stack.get(parser_top-0)).right;
2960                 RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
2961                  RESULT = new ParentPattern(sp, rpp);
2962               parser_result = new Symbol(31/*RelativePathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2963             }
2964           return parser_result;
2965 
2966           /*. . . . . . . . . . . . . . . . . . . .*/
2967           case 15: // RelativePathPattern ::= StepPattern
2968             {
2969               RelativePathPattern RESULT = null;
2970                 int spleft = (parser_stack.get(parser_top-0)).left;
2971                 int spright = (parser_stack.get(parser_top-0)).right;
2972                 StepPattern sp = (StepPattern)(parser_stack.get(parser_top-0)).value;
2973                  RESULT = sp;
2974               parser_result = new Symbol(31/*RelativePathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2975             }
2976           return parser_result;
2977 
2978           /*. . . . . . . . . . . . . . . . . . . .*/
2979           case 14: // ProcessingInstructionPattern ::= PIPARAM LPAREN Literal RPAREN
2980             {
2981               StepPattern RESULT = null;
2982                 int lleft = (parser_stack.get(parser_top-1)).left;
2983                 int lright = (parser_stack.get(parser_top-1)).right;
2984                 String l = (String)(parser_stack.get(parser_top-1)).value;
2985                  RESULT = new ProcessingInstructionPattern(l);
2986               parser_result = new Symbol(30/*ProcessingInstructionPattern*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
2987             }
2988           return parser_result;
2989 
2990           /*. . . . . . . . . . . . . . . . . . . .*/
2991           case 13: // IdKeyPattern ::= KEY LPAREN Literal COMMA Literal RPAREN
2992             {
2993               IdKeyPattern RESULT = null;
2994                 int l1left = (parser_stack.get(parser_top-3)).left;
2995                 int l1right = (parser_stack.get(parser_top-3)).right;
2996                 String l1 = (String)(parser_stack.get(parser_top-3)).value;
2997                 int l2left = (parser_stack.get(parser_top-1)).left;
2998                 int l2right = (parser_stack.get(parser_top-1)).right;
2999                 String l2 = (String)(parser_stack.get(parser_top-1)).value;
3000                  RESULT = new KeyPattern(l1, l2);
3001               parser_result = new Symbol(27/*IdKeyPattern*/, (parser_stack.get(parser_top-5)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3002             }
3003           return parser_result;
3004 
3005           /*. . . . . . . . . . . . . . . . . . . .*/
3006           case 12: // IdKeyPattern ::= ID LPAREN Literal RPAREN
3007             {
3008               IdKeyPattern RESULT = null;
3009                 int lleft = (parser_stack.get(parser_top-1)).left;
3010                 int lright = (parser_stack.get(parser_top-1)).right;
3011                 String l = (String)(parser_stack.get(parser_top-1)).value;
3012                  RESULT = new IdPattern(l);
3013                parser.setHasIdCall(true);
3014 
3015               parser_result = new Symbol(27/*IdKeyPattern*/, (parser_stack.get(parser_top-3)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3016             }
3017           return parser_result;
3018 
3019           /*. . . . . . . . . . . . . . . . . . . .*/
3020           case 11: // LocationPathPattern ::= RelativePathPattern
3021             {
3022               Pattern RESULT = null;
3023                 int rppleft = (parser_stack.get(parser_top-0)).left;
3024                 int rppright = (parser_stack.get(parser_top-0)).right;
3025                 RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
3026                  RESULT = rpp;
3027               parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3028             }
3029           return parser_result;
3030 
3031           /*. . . . . . . . . . . . . . . . . . . .*/
3032           case 10: // LocationPathPattern ::= DSLASH RelativePathPattern
3033             {
3034               Pattern RESULT = null;
3035                 int rppleft = (parser_stack.get(parser_top-0)).left;
3036                 int rppright = (parser_stack.get(parser_top-0)).right;
3037                 RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
3038                  RESULT = new AncestorPattern(rpp);
3039               parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3040             }
3041           return parser_result;
3042 
3043           /*. . . . . . . . . . . . . . . . . . . .*/
3044           case 9: // LocationPathPattern ::= IdKeyPattern DSLASH RelativePathPattern
3045             {
3046               Pattern RESULT = null;
3047                 int ikpleft = (parser_stack.get(parser_top-2)).left;
3048                 int ikpright = (parser_stack.get(parser_top-2)).right;
3049                 IdKeyPattern ikp = (IdKeyPattern)(parser_stack.get(parser_top-2)).value;
3050                 int rppleft = (parser_stack.get(parser_top-0)).left;
3051                 int rppright = (parser_stack.get(parser_top-0)).right;
3052                 RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
3053                  RESULT = new AncestorPattern(ikp, rpp);
3054               parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3055             }
3056           return parser_result;
3057 
3058           /*. . . . . . . . . . . . . . . . . . . .*/
3059           case 8: // LocationPathPattern ::= IdKeyPattern SLASH RelativePathPattern
3060             {
3061               Pattern RESULT = null;
3062                 int ikpleft = (parser_stack.get(parser_top-2)).left;
3063                 int ikpright = (parser_stack.get(parser_top-2)).right;
3064                 IdKeyPattern ikp = (IdKeyPattern)(parser_stack.get(parser_top-2)).value;
3065                 int rppleft = (parser_stack.get(parser_top-0)).left;
3066                 int rppright = (parser_stack.get(parser_top-0)).right;
3067                 RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
3068                  RESULT = new ParentPattern(ikp, rpp);
3069               parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3070             }
3071           return parser_result;
3072 
3073           /*. . . . . . . . . . . . . . . . . . . .*/
3074           case 7: // LocationPathPattern ::= IdKeyPattern
3075             {
3076               Pattern RESULT = null;
3077                 int ikpleft = (parser_stack.get(parser_top-0)).left;
3078                 int ikpright = (parser_stack.get(parser_top-0)).right;
3079                 IdKeyPattern ikp = (IdKeyPattern)(parser_stack.get(parser_top-0)).value;
3080                  RESULT = ikp;
3081               parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3082             }
3083           return parser_result;
3084 
3085           /*. . . . . . . . . . . . . . . . . . . .*/
3086           case 6: // LocationPathPattern ::= SLASH RelativePathPattern
3087             {
3088               Pattern RESULT = null;
3089                 int rppleft = (parser_stack.get(parser_top-0)).left;
3090                 int rppright = (parser_stack.get(parser_top-0)).right;
3091                 RelativePathPattern rpp = (RelativePathPattern)(parser_stack.get(parser_top-0)).value;
3092                  RESULT = new AbsolutePathPattern(rpp);
3093               parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3094             }
3095           return parser_result;
3096 
3097           /*. . . . . . . . . . . . . . . . . . . .*/
3098           case 5: // LocationPathPattern ::= SLASH
3099             {
3100               Pattern RESULT = null;
3101                  RESULT = new AbsolutePathPattern(null);
3102               parser_result = new Symbol(29/*LocationPathPattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3103             }
3104           return parser_result;
3105 
3106           /*. . . . . . . . . . . . . . . . . . . .*/
3107           case 4: // Pattern ::= LocationPathPattern VBAR Pattern
3108             {
3109               Pattern RESULT = null;
3110                 int lppleft = (parser_stack.get(parser_top-2)).left;
3111                 int lppright = (parser_stack.get(parser_top-2)).right;
3112                 Pattern lpp = (Pattern)(parser_stack.get(parser_top-2)).value;
3113                 int pleft = (parser_stack.get(parser_top-0)).left;
3114                 int pright = (parser_stack.get(parser_top-0)).right;
3115                 Pattern p = (Pattern)(parser_stack.get(parser_top-0)).value;
3116                  RESULT = new AlternativePattern(lpp, p);
3117               parser_result = new Symbol(28/*Pattern*/, (parser_stack.get(parser_top-2)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3118             }
3119           return parser_result;
3120 
3121           /*. . . . . . . . . . . . . . . . . . . .*/
3122           case 3: // Pattern ::= LocationPathPattern
3123             {
3124               Pattern RESULT = null;
3125                 int lppleft = (parser_stack.get(parser_top-0)).left;
3126                 int lppright = (parser_stack.get(parser_top-0)).right;
3127                 Pattern lpp = (Pattern)(parser_stack.get(parser_top-0)).value;
3128                  RESULT = lpp;
3129               parser_result = new Symbol(28/*Pattern*/, (parser_stack.get(parser_top-0)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3130             }
3131           return parser_result;
3132 
3133           /*. . . . . . . . . . . . . . . . . . . .*/
3134           case 2: // TopLevel ::= EXPRESSION Expr
3135             {
3136               SyntaxTreeNode RESULT = null;
3137                 int exprleft = (parser_stack.get(parser_top-0)).left;
3138                 int exprright = (parser_stack.get(parser_top-0)).right;
3139                 Expression expr = (Expression)(parser_stack.get(parser_top-0)).value;
3140                  RESULT = expr;
3141               parser_result = new Symbol(1/*TopLevel*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3142             }
3143           return parser_result;
3144 
3145           /*. . . . . . . . . . . . . . . . . . . .*/
3146           case 1: // TopLevel ::= PATTERN Pattern
3147             {
3148               SyntaxTreeNode RESULT = null;
3149                 int patternleft = (parser_stack.get(parser_top-0)).left;
3150                 int patternright = (parser_stack.get(parser_top-0)).right;
3151                 Pattern pattern = (Pattern)(parser_stack.get(parser_top-0)).value;
3152                  RESULT = pattern;
3153               parser_result = new Symbol(1/*TopLevel*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3154             }
3155           return parser_result;
3156 
3157           /*. . . . . . . . . . . . . . . . . . . .*/
3158           case 0: // $START ::= TopLevel EOF
3159             {
3160               Object RESULT = null;
3161                 int start_valleft = (parser_stack.get(parser_top-1)).left;
3162                 int start_valright = (parser_stack.get(parser_top-1)).right;
3163                 SyntaxTreeNode start_val = (SyntaxTreeNode)(parser_stack.get(parser_top-1)).value;
3164                 RESULT = start_val;
3165               parser_result = new Symbol(0/*$START*/, (parser_stack.get(parser_top-1)).left, (parser_stack.get(parser_top-0)).right, RESULT);
3166             }
3167           /* ACCEPT */
3168           parser_parser.done_parsing();
3169           return parser_result;
3170 
3171           /* . . . . . .*/
3172           default:
3173             throw new Exception(
3174                &quot;Invalid action number found in internal parse table&quot;);
3175 
3176         }
3177     }
3178 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/BranchInstruction.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 package com.sun.org.apache.bcel.internal.generic;
 22 
 23 import java.io.DataOutputStream;
 24 import java.io.IOException;
 25 
 26 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 27 
 28 /**
 29  * Abstract super class for branching instructions like GOTO, IFEQ, etc.. Branch
 30  * instructions may have a variable length, namely GOTO, JSR, LOOKUPSWITCH and
 31  * TABLESWITCH.
 32  *
 33  * @see InstructionList
 34  * @version $Id: BranchInstruction.java 1749603 2016-06-21 20:50:19Z ggregory $
 35  */
 36 public abstract class BranchInstruction extends Instruction implements InstructionTargeter {
 37 
 38     private int index; // Branch target relative to this instruction
 39     private InstructionHandle target; // Target object in instruction list
 40     private int position; // Byte code offset
 41 
 42     /**
 43      * Empty constructor needed for the Class.newInstance() statement in
 44      * Instruction.readInstruction(). Not to be used otherwise.
 45      */
 46     BranchInstruction() {
 47     }
 48 
 49     /**
 50      * Common super constructor
 51      *
 52      * @param opcode Instruction opcode
 53      * @param target instruction to branch to
 54      */
 55     protected BranchInstruction(final short opcode, final InstructionHandle target) {
 56         super(opcode, (short) 3);
 57         setTarget(target);
 58     }
 59 
 60     /**
 61      * Dump instruction as byte code to stream out.
 62      *
 63      * @param out Output stream
 64      */
 65     @Override
 66     public void dump(final DataOutputStream out) throws IOException {
 67         out.writeByte(super.getOpcode());
 68         index = getTargetOffset();
 69         if (!isValidShort(index)) {
 70             throw new ClassGenException(&quot;Branch target offset too large for short: &quot; + index);
 71         }
 72         out.writeShort(index); // May be negative, i.e., point backwards
 73     }
 74 
 75     /**
 76      * @param _target branch target
 77      * @return the offset to `target&#39; relative to this instruction
 78      */
 79     protected int getTargetOffset(final InstructionHandle _target) {
 80         if (_target == null) {
 81             throw new ClassGenException(&quot;Target of &quot; + super.toString(true)
 82                     + &quot; is invalid null handle&quot;);
 83         }
 84         final int t = _target.getPosition();
 85         if (t &lt; 0) {
 86             throw new ClassGenException(&quot;Invalid branch target position offset for &quot;
 87                     + super.toString(true) + &quot;:&quot; + t + &quot;:&quot; + _target);
 88         }
 89         return t - position;
 90     }
 91 
 92     /**
 93      * @return the offset to this instruction&#39;s target
 94      */
 95     protected int getTargetOffset() {
 96         return getTargetOffset(target);
 97     }
 98 
 99     /**
100      * Called by InstructionList.setPositions when setting the position for
101      * every instruction. In the presence of variable length instructions
102      * `setPositions&#39; performs multiple passes over the instruction list to
103      * calculate the correct (byte) positions and offsets by calling this
104      * function.
105      *
106      * @param offset additional offset caused by preceding (variable length)
107      * instructions
108      * @param max_offset the maximum offset that may be caused by these
109      * instructions
110      * @return additional offset caused by possible change of this instruction&#39;s
111      * length
112      */
113     protected int updatePosition(final int offset, final int max_offset) {
114         position += offset;
115         return 0;
116     }
117 
118     /**
119      * Long output format:
120      *
121      * &amp;lt;position in byte code&amp;gt; &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode
122      * number&amp;gt;&quot;]&quot; &quot;(&quot;&amp;lt;length of instruction&amp;gt;&quot;)&quot; &quot;&amp;lt;&quot;&amp;lt;target
123      * instruction&amp;gt;&quot;&amp;gt;&quot; &quot;@&quot;&amp;lt;branch target offset&amp;gt;
124      *
125      * @param verbose long/short format switch
126      * @return mnemonic for instruction
127      */
128     @Override
129     public String toString(final boolean verbose) {
130         final String s = super.toString(verbose);
131         String t = &quot;null&quot;;
132         if (verbose) {
133             if (target != null) {
134                 if (target.getInstruction() == this) {
135                     t = &quot;&lt;points to itself&gt;&quot;;
136                 } else if (target.getInstruction() == null) {
137                     t = &quot;&lt;null instruction!!!?&gt;&quot;;
138                 } else {
139                     // I&#39;m more interested in the address of the target then
140                     // the instruction located there.
141                     //t = target.getInstruction().toString(false); // Avoid circles
142                     t = &quot;&quot; + target.getPosition();
143                 }
144             }
145         } else {
146             if (target != null) {
147                 index = target.getPosition();
148                 // index = getTargetOffset();  crashes if positions haven&#39;t been set
149                 // t = &quot;&quot; + (index + position);
150                 t = &quot;&quot; + index;
151             }
152         }
153         return s + &quot; -&gt; &quot; + t;
154     }
155 
156     /**
157      * Read needed data (e.g. index) from file. Conversion to a
158      * InstructionHandle is done in InstructionList(byte[]).
159      *
160      * @param bytes input stream
161      * @param wide wide prefix?
162      * @see InstructionList
163      */
164     @Override
165     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {
166         super.setLength(3);
167         index = bytes.readShort();
168     }
169 
170     /**
171      * @return target offset in byte code
172      */
173     public final int getIndex() {
174         return index;
175     }
176 
177     /**
178      * @return target of branch instruction
179      */
180     public InstructionHandle getTarget() {
181         return target;
182     }
183 
184     /**
185      * Set branch target
186      *
187      * @param target branch target
188      */
189     public void setTarget(final InstructionHandle target) {
190         notifyTarget(this.target, target, this);
191         this.target = target;
192     }
193 
194     /**
195      * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen,
196      * LineNumberGen
197      */
198     static void notifyTarget(final InstructionHandle old_ih, final InstructionHandle new_ih,
199             final InstructionTargeter t) {
200         if (old_ih != null) {
201             old_ih.removeTargeter(t);
202         }
203         if (new_ih != null) {
204             new_ih.addTargeter(t);
205         }
206     }
207 
208     /**
209      * @param old_ih old target
210      * @param new_ih new target
211      */
212     @Override
213     public void updateTarget(final InstructionHandle old_ih, final InstructionHandle new_ih) {
214         if (target == old_ih) {
215             setTarget(new_ih);
216         } else {
217             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but &quot; + target);
218         }
219     }
220 
221     /**
222      * @return true, if ih is target of this instruction
223      */
224     @Override
225     public boolean containsTarget(final InstructionHandle ih) {
226         return target == ih;
227     }
228 
229     /**
230      * Inform target that it&#39;s not targeted anymore.
231      */
232     @Override
233     void dispose() {
234         setTarget(null);
235         index = -1;
236         position = -1;
237     }
238 
239     /**
240      * @return the position
241      * @since 6.0
242      */
243     protected int getPosition() {
244         return position;
245     }
246 
247     /**
248      * @param position the position to set
249      * @since 6.0
250      */
251     protected void setPosition(final int position) {
252         this.position = position;
253     }
254 
255     /**
256      * @param index the index to set
257      * @since 6.0
258      */
259     protected void setIndex(final int index) {
260         this.index = index;
261     }
262 
263 }
    </pre>
  </body>
</html>
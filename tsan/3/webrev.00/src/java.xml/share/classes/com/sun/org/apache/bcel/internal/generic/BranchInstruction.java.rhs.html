<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/BranchInstruction.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>

  3  */
  4 /*
  5  * Licensed to the Apache Software Foundation (ASF) under one or more
  6  * contributor license agreements.  See the NOTICE file distributed with
  7  * this work for additional information regarding copyright ownership.
  8  * The ASF licenses this file to You under the Apache License, Version 2.0
  9  * (the &quot;License&quot;); you may not use this file except in compliance with
 10  * the License.  You may obtain a copy of the License at
 11  *
 12  *      http://www.apache.org/licenses/LICENSE-2.0
 13  *
 14  * Unless required by applicable law or agreed to in writing, software
 15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 17  * See the License for the specific language governing permissions and
 18  * limitations under the License.
 19  */
 20 package com.sun.org.apache.bcel.internal.generic;
 21 
 22 import java.io.DataOutputStream;
 23 import java.io.IOException;
 24 
 25 import com.sun.org.apache.bcel.internal.util.ByteSequence;
 26 
 27 /**
<a name="2" id="anc2"></a><span class="line-modified"> 28  * Abstract super class for branching instructions like GOTO, IFEQ, etc..</span>
<span class="line-modified"> 29  * Branch instructions may have a variable length, namely GOTO, JSR,</span>
<span class="line-modified"> 30  * LOOKUPSWITCH and TABLESWITCH.</span>
 31  *
 32  * @see InstructionList
<a name="3" id="anc3"></a><span class="line-modified"> 33  * @LastModified: Jan 2020</span>
 34  */
 35 public abstract class BranchInstruction extends Instruction implements InstructionTargeter {
 36 
 37     private int index; // Branch target relative to this instruction
 38     private InstructionHandle target; // Target object in instruction list
 39     private int position; // Byte code offset
 40 
 41     /**
 42      * Empty constructor needed for the Class.newInstance() statement in
 43      * Instruction.readInstruction(). Not to be used otherwise.
 44      */
 45     BranchInstruction() {
 46     }
 47 
<a name="4" id="anc4"></a><span class="line-modified"> 48 </span>
<span class="line-modified"> 49     /** Common super constructor</span>

 50      * @param opcode Instruction opcode
 51      * @param target instruction to branch to
 52      */
 53     protected BranchInstruction(final short opcode, final InstructionHandle target) {
 54         super(opcode, (short) 3);
 55         setTarget(target);
 56     }
 57 
<a name="5" id="anc5"></a><span class="line-added"> 58 </span>
 59     /**
 60      * Dump instruction as byte code to stream out.
<a name="6" id="anc6"></a>
 61      * @param out Output stream
 62      */
 63     @Override
<a name="7" id="anc7"></a><span class="line-modified"> 64     public void dump( final DataOutputStream out ) throws IOException {</span>
 65         out.writeByte(super.getOpcode());
 66         index = getTargetOffset();
 67         if (!isValidShort(index)) {
 68             throw new ClassGenException(&quot;Branch target offset too large for short: &quot; + index);
 69         }
 70         out.writeShort(index); // May be negative, i.e., point backwards
 71     }
 72 
<a name="8" id="anc8"></a><span class="line-added"> 73 </span>
 74     /**
 75      * @param _target branch target
<a name="9" id="anc9"></a><span class="line-modified"> 76      * @return the offset to  `target&#39; relative to this instruction</span>
 77      */
<a name="10" id="anc10"></a><span class="line-modified"> 78     protected int getTargetOffset( final InstructionHandle _target ) {</span>
 79         if (_target == null) {
 80             throw new ClassGenException(&quot;Target of &quot; + super.toString(true)
 81                     + &quot; is invalid null handle&quot;);
 82         }
 83         final int t = _target.getPosition();
 84         if (t &lt; 0) {
 85             throw new ClassGenException(&quot;Invalid branch target position offset for &quot;
 86                     + super.toString(true) + &quot;:&quot; + t + &quot;:&quot; + _target);
 87         }
 88         return t - position;
 89     }
 90 
<a name="11" id="anc11"></a><span class="line-added"> 91 </span>
 92     /**
 93      * @return the offset to this instruction&#39;s target
 94      */
 95     protected int getTargetOffset() {
 96         return getTargetOffset(target);
 97     }
 98 
<a name="12" id="anc12"></a><span class="line-added"> 99 </span>
100     /**
<a name="13" id="anc13"></a><span class="line-modified">101      * Called by InstructionList.setPositions when setting the position for every</span>
<span class="line-modified">102      * instruction. In the presence of variable length instructions `setPositions&#39;</span>
<span class="line-modified">103      * performs multiple passes over the instruction list to calculate the</span>
<span class="line-modified">104      * correct (byte) positions and offsets by calling this function.</span>

105      *
<a name="14" id="anc14"></a><span class="line-modified">106      * @param offset additional offset caused by preceding (variable length) instructions</span>
<span class="line-modified">107      * @param max_offset the maximum offset that may be caused by these instructions</span>
<span class="line-modified">108      * @return additional offset caused by possible change of this instruction&#39;s length</span>



109      */
<a name="15" id="anc15"></a><span class="line-modified">110     protected int updatePosition( final int offset, final int max_offset ) {</span>
111         position += offset;
112         return 0;
113     }
114 
<a name="16" id="anc16"></a><span class="line-added">115 </span>
116     /**
117      * Long output format:
118      *
<a name="17" id="anc17"></a><span class="line-modified">119      * &amp;lt;position in byte code&amp;gt;</span>
<span class="line-modified">120      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot;</span>
<span class="line-modified">121      * &quot;(&quot;&amp;lt;length of instruction&amp;gt;&quot;)&quot;</span>
<span class="line-added">122      * &quot;&amp;lt;&quot;&amp;lt;target instruction&amp;gt;&quot;&amp;gt;&quot; &quot;@&quot;&amp;lt;branch target offset&amp;gt;</span>
123      *
124      * @param verbose long/short format switch
125      * @return mnemonic for instruction
126      */
127     @Override
<a name="18" id="anc18"></a><span class="line-modified">128     public String toString( final boolean verbose ) {</span>
129         final String s = super.toString(verbose);
130         String t = &quot;null&quot;;
131         if (verbose) {
132             if (target != null) {
133                 if (target.getInstruction() == this) {
134                     t = &quot;&lt;points to itself&gt;&quot;;
135                 } else if (target.getInstruction() == null) {
136                     t = &quot;&lt;null instruction!!!?&gt;&quot;;
137                 } else {
138                     // I&#39;m more interested in the address of the target then
139                     // the instruction located there.
140                     //t = target.getInstruction().toString(false); // Avoid circles
141                     t = &quot;&quot; + target.getPosition();
142                 }
143             }
144         } else {
145             if (target != null) {
146                 index = target.getPosition();
147                 // index = getTargetOffset();  crashes if positions haven&#39;t been set
148                 // t = &quot;&quot; + (index + position);
149                 t = &quot;&quot; + index;
150             }
151         }
152         return s + &quot; -&gt; &quot; + t;
153     }
154 
<a name="19" id="anc19"></a><span class="line-added">155 </span>
156     /**
<a name="20" id="anc20"></a><span class="line-modified">157      * Read needed data (e.g. index) from file. Conversion to a InstructionHandle</span>
<span class="line-modified">158      * is done in InstructionList(byte[]).</span>
159      *
160      * @param bytes input stream
161      * @param wide wide prefix?
162      * @see InstructionList
163      */
164     @Override
<a name="21" id="anc21"></a><span class="line-modified">165     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
166         super.setLength(3);
167         index = bytes.readShort();
168     }
169 
<a name="22" id="anc22"></a><span class="line-added">170 </span>
171     /**
172      * @return target offset in byte code
173      */
174     public final int getIndex() {
175         return index;
176     }
177 
<a name="23" id="anc23"></a><span class="line-added">178 </span>
179     /**
180      * @return target of branch instruction
181      */
182     public InstructionHandle getTarget() {
183         return target;
184     }
185 
<a name="24" id="anc24"></a><span class="line-added">186 </span>
187     /**
188      * Set branch target
<a name="25" id="anc25"></a>
189      * @param target branch target
190      */
<a name="26" id="anc26"></a><span class="line-modified">191     public void setTarget( final InstructionHandle target ) {</span>
192         notifyTarget(this.target, target, this);
193         this.target = target;
194     }
195 
<a name="27" id="anc27"></a><span class="line-added">196 </span>
197     /**
<a name="28" id="anc28"></a><span class="line-modified">198      * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen</span>

199      */
<a name="29" id="anc29"></a><span class="line-modified">200     static void notifyTarget( final InstructionHandle old_ih, final InstructionHandle new_ih,</span>
<span class="line-modified">201             final InstructionTargeter t ) {</span>
202         if (old_ih != null) {
203             old_ih.removeTargeter(t);
204         }
205         if (new_ih != null) {
206             new_ih.addTargeter(t);
207         }
208     }
209 
<a name="30" id="anc30"></a><span class="line-added">210 </span>
211     /**
212      * @param old_ih old target
213      * @param new_ih new target
214      */
215     @Override
<a name="31" id="anc31"></a><span class="line-modified">216     public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {</span>
217         if (target == old_ih) {
218             setTarget(new_ih);
219         } else {
220             throw new ClassGenException(&quot;Not targeting &quot; + old_ih + &quot;, but &quot; + target);
221         }
222     }
223 
<a name="32" id="anc32"></a><span class="line-added">224 </span>
225     /**
226      * @return true, if ih is target of this instruction
227      */
228     @Override
<a name="33" id="anc33"></a><span class="line-modified">229     public boolean containsTarget( final InstructionHandle ih ) {</span>
230         return target == ih;
231     }
232 
<a name="34" id="anc34"></a><span class="line-added">233 </span>
234     /**
235      * Inform target that it&#39;s not targeted anymore.
236      */
237     @Override
238     void dispose() {
239         setTarget(null);
240         index = -1;
241         position = -1;
242     }
243 
<a name="35" id="anc35"></a><span class="line-added">244 </span>
245     /**
246      * @return the position
247      * @since 6.0
248      */
249     protected int getPosition() {
250         return position;
251     }
252 
<a name="36" id="anc36"></a><span class="line-added">253 </span>
254     /**
255      * @param position the position to set
256      * @since 6.0
257      */
258     protected void setPosition(final int position) {
259         this.position = position;
260     }
261 
<a name="37" id="anc37"></a><span class="line-added">262 </span>
263     /**
264      * @param index the index to set
265      * @since 6.0
266      */
267     protected void setIndex(final int index) {
268         this.index = index;
269     }
270 
271 }
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../XMLSchemaValidator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../traversers/XSDAbstractTraverser.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/identity/XPathMatcher.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
   * XPath matcher.
   *
   * @xerces.internal
   *
   * @author Andy Clark, IBM
<span class="line-added">+  * @LastModified: July 2019</span>
   *
   */
  public class XPathMatcher {
  
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,29 ***</span>
      //
      // Data
      //
  
      /** XPath location path. */
<span class="line-modified">!     private XPath.LocationPath[] fLocationPaths;</span>
  
      /** True if XPath has been matched. */
<span class="line-modified">!     private int[] fMatched;</span>
  
      /** The matching string. */
      protected Object fMatchedString;
  
      /** Integer stack of step indexes. */
<span class="line-modified">!     private IntStack[] fStepIndexes;</span>
  
      /** Current step. */
<span class="line-modified">!     private int[] fCurrentStep;</span>
  
      /**
       * No match depth. The value of this field will be zero while
       * matching is successful for the given xpath expression.
       */
<span class="line-modified">!     private int [] fNoMatchDepth;</span>
  
      final QName fQName = new QName();
  
  
      //
<span class="line-new-header">--- 87,29 ---</span>
      //
      // Data
      //
  
      /** XPath location path. */
<span class="line-modified">!     private final XPath.LocationPath[] fLocationPaths;</span>
  
      /** True if XPath has been matched. */
<span class="line-modified">!     private final int[] fMatched;</span>
  
      /** The matching string. */
      protected Object fMatchedString;
  
      /** Integer stack of step indexes. */
<span class="line-modified">!     private final IntStack[] fStepIndexes;</span>
  
      /** Current step. */
<span class="line-modified">!     private final int[] fCurrentStep;</span>
  
      /**
       * No match depth. The value of this field will be zero while
       * matching is successful for the given xpath expression.
       */
<span class="line-modified">!     private final int [] fNoMatchDepth;</span>
  
      final QName fQName = new QName();
  
  
      //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,19 ***</span>
       * @param element    The name of the element.
       * @param attributes The element attributes.
       *
       * @throws SAXException Thrown by handler to signal an error.
       */
<span class="line-modified">!     public void startElement(QName element, XMLAttributes attributes){</span>
          if (DEBUG_METHODS2) {
              System.out.println(toString()+&quot;#startElement(&quot;+
                                 &quot;element={&quot;+element+&quot;},&quot;+
                                 &quot;attributes=...&quot;+attributes+
                                 &quot;)&quot;);
          }
  
<span class="line-modified">!         for(int i = 0; i &lt; fLocationPaths.length; i++) {</span>
              // push context
              int startStep = fCurrentStep[i];
              fStepIndexes[i].push(startStep);
  
              // try next xpath, if not matching
<span class="line-new-header">--- 206,19 ---</span>
       * @param element    The name of the element.
       * @param attributes The element attributes.
       *
       * @throws SAXException Thrown by handler to signal an error.
       */
<span class="line-modified">!     public void startElement(QName element, XMLAttributes attributes) {</span>
          if (DEBUG_METHODS2) {
              System.out.println(toString()+&quot;#startElement(&quot;+
                                 &quot;element={&quot;+element+&quot;},&quot;+
                                 &quot;attributes=...&quot;+attributes+
                                 &quot;)&quot;);
          }
  
<span class="line-modified">!         for (int i = 0; i &lt; fLocationPaths.length; i++) {</span>
              // push context
              int startStep = fCurrentStep[i];
              fStepIndexes[i].push(startStep);
  
              // try next xpath, if not matching
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,33 ***</span>
                  XPath.Step step = steps[fCurrentStep[i]];
                  XPath.NodeTest nodeTest = step.nodeTest;
                  if (DEBUG_MATCH) {
                      System.out.println(toString()+&quot; [CHILD] before&quot;);
                  }
<span class="line-modified">!                 if (nodeTest.type == XPath.NodeTest.QNAME) {</span>
<span class="line-modified">!                     if (!nodeTest.name.equals(element)) {</span>
<span class="line-modified">!                         if(fCurrentStep[i] &gt; descendantStep) {</span>
<span class="line-removed">-                             fCurrentStep[i] = descendantStep;</span>
<span class="line-removed">-                             continue;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         fNoMatchDepth[i]++;</span>
<span class="line-removed">-                         if (DEBUG_MATCH) {</span>
<span class="line-removed">-                             System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);</span>
<span class="line-removed">-                         }</span>
                          continue;
                      }
                  }
                  fCurrentStep[i]++;
                  if (DEBUG_MATCH) {
                      System.out.println(toString()+&quot; [CHILD] after MATCHED!&quot;);
                  }
              }
              if (fCurrentStep[i] == steps.length) {
<span class="line-modified">!                 if(sawDescendant) {</span>
                      fCurrentStep[i] = descendantStep;
                      fMatched[i] = MATCHED_DESCENDANT;
<span class="line-modified">!                 } else {</span>
                      fMatched[i] = MATCHED;
                  }
                  continue;
              }
  
<span class="line-new-header">--- 283,32 ---</span>
                  XPath.Step step = steps[fCurrentStep[i]];
                  XPath.NodeTest nodeTest = step.nodeTest;
                  if (DEBUG_MATCH) {
                      System.out.println(toString()+&quot; [CHILD] before&quot;);
                  }
<span class="line-modified">!                 if (!matches(nodeTest, element)) {</span>
<span class="line-modified">!                     if (fCurrentStep[i] &gt; descendantStep) {</span>
<span class="line-modified">!                         fCurrentStep[i] = descendantStep;</span>
                          continue;
                      }
<span class="line-added">+                     fNoMatchDepth[i]++;</span>
<span class="line-added">+                     if (DEBUG_MATCH) {</span>
<span class="line-added">+                         System.out.println(toString()+&quot; [CHILD] after NO MATCH&quot;);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     continue;</span>
                  }
                  fCurrentStep[i]++;
                  if (DEBUG_MATCH) {
                      System.out.println(toString()+&quot; [CHILD] after MATCHED!&quot;);
                  }
              }
              if (fCurrentStep[i] == steps.length) {
<span class="line-modified">!                 if (sawDescendant) {</span>
                      fCurrentStep[i] = descendantStep;
                      fMatched[i] = MATCHED_DESCENDANT;
<span class="line-modified">!                 }</span>
<span class="line-added">+                 else {</span>
                      fMatched[i] = MATCHED;
                  }
                  continue;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,12 ***</span>
                  if (attrCount &gt; 0) {
                      XPath.NodeTest nodeTest = steps[fCurrentStep[i]].nodeTest;
  
                      for (int aIndex = 0; aIndex &lt; attrCount; aIndex++) {
                          attributes.getName(aIndex, fQName);
<span class="line-modified">!                         if (nodeTest.type != XPath.NodeTest.QNAME ||</span>
<span class="line-removed">-                             nodeTest.name.equals(fQName)) {</span>
                              fCurrentStep[i]++;
                              if (fCurrentStep[i] == steps.length) {
                                  fMatched[i] = MATCHED_ATTRIBUTE;
                                  int j=0;
                                  for(; j&lt;i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);
<span class="line-new-header">--- 322,11 ---</span>
                  if (attrCount &gt; 0) {
                      XPath.NodeTest nodeTest = steps[fCurrentStep[i]].nodeTest;
  
                      for (int aIndex = 0; aIndex &lt; attrCount; aIndex++) {
                          attributes.getName(aIndex, fQName);
<span class="line-modified">!                         if (matches(nodeTest, fQName)) {</span>
                              fCurrentStep[i]++;
                              if (fCurrentStep[i] == steps.length) {
                                  fMatched[i] = MATCHED_ATTRIBUTE;
                                  int j=0;
                                  for(; j&lt;i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 382,25 ***</span>
          if (DEBUG_METHODS2) {
              System.out.println(toString()+&quot;#endElement(&quot;+
                                 &quot;element={&quot;+element+&quot;},&quot;+
                                 &quot;)&quot;);
          }
<span class="line-modified">!         for(int i = 0; i&lt;fLocationPaths.length; i++) {</span>
              // go back a step
              fCurrentStep[i] = fStepIndexes[i].pop();
  
              // don&#39;t do anything, if not matching
              if (fNoMatchDepth[i] &gt; 0) {
                  fNoMatchDepth[i]--;
              }
  
              // signal match, if appropriate
              else {
<span class="line-modified">!                 int j=0;</span>
<span class="line-modified">!                 for(; j&lt;i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);</span>
<span class="line-modified">!                 if ((j&lt;i) || (fMatched[j] == 0) ||</span>
<span class="line-modified">!                         ((fMatched[j] &amp; MATCHED_ATTRIBUTE) == MATCHED_ATTRIBUTE)) {</span>
                      continue;
                  }
                  // only certain kinds of matchers actually
                  // match element content.  This permits
                  // them a way to override this to do nothing
<span class="line-new-header">--- 381,28 ---</span>
          if (DEBUG_METHODS2) {
              System.out.println(toString()+&quot;#endElement(&quot;+
                                 &quot;element={&quot;+element+&quot;},&quot;+
                                 &quot;)&quot;);
          }
<span class="line-modified">!         for (int i = 0; i &lt; fLocationPaths.length; i++) {</span>
              // go back a step
              fCurrentStep[i] = fStepIndexes[i].pop();
  
              // don&#39;t do anything, if not matching
              if (fNoMatchDepth[i] &gt; 0) {
                  fNoMatchDepth[i]--;
              }
  
              // signal match, if appropriate
              else {
<span class="line-modified">!                 int j = 0;</span>
<span class="line-modified">!                 for(; j &lt; i &amp;&amp; ((fMatched[j] &amp; MATCHED) != MATCHED); j++);</span>
<span class="line-modified">!                 if ((j &lt; i) || (fMatched[j] == 0)) {</span>
<span class="line-modified">!                     continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if ((fMatched[j] &amp; MATCHED_ATTRIBUTE) == MATCHED_ATTRIBUTE) {</span>
<span class="line-added">+                     fMatched[i] = 0;</span>
                      continue;
                  }
                  // only certain kinds of matchers actually
                  // match element content.  This permits
                  // them a way to override this to do nothing
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,10 ***</span>
<span class="line-new-header">--- 476,22 ---</span>
              }
          }
          return str.toString();
      } // normalize(String):String
  
<span class="line-added">+     /** Returns true if the given QName matches the node test. **/</span>
<span class="line-added">+     private static boolean matches(XPath.NodeTest nodeTest, QName value) {</span>
<span class="line-added">+         if (nodeTest.type == XPath.NodeTest.QNAME) {</span>
<span class="line-added">+             return nodeTest.name.equals(value);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (nodeTest.type == XPath.NodeTest.NAMESPACE) {</span>
<span class="line-added">+             return nodeTest.name.uri == value.uri;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // XPath.NodeTest.WILDCARD</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     } // matches(XPath.NodeTest,QName):boolean</span>
<span class="line-added">+ </span>
      //
      // MAIN
      //
  
      // NOTE: The main of this class is here for debugging purposes.
</pre>
<center><a href="../XMLSchemaValidator.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="../traversers/XSDAbstractTraverser.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
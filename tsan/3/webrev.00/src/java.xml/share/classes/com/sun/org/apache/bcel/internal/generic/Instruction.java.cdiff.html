<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Instruction.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IndexedInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionComparator.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/Instruction.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   */
  /*
   * Licensed to the Apache Software Foundation (ASF) under one or more
   * contributor license agreements.  See the NOTICE file distributed with
   * this work for additional information regarding copyright ownership.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,82 ***</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Abstract super class for all Java byte codes.
   *
<span class="line-modified">!  * @version $Id: Instruction.java 1750029 2016-06-23 22:14:38Z sebb $</span>
   */
  public abstract class Instruction implements Cloneable {
  
      private short length = 1; // Length of instruction in bytes
      private short opcode = -1; // Opcode number
  
      private static InstructionComparator cmp = InstructionComparator.DEFAULT;
  
      /**
<span class="line-modified">!      * Empty constructor needed for the Class.newInstance() statement in</span>
<span class="line-modified">!      * Instruction.readInstruction(). Not to be used otherwise.</span>
       */
      Instruction() {
      }
  
      public Instruction(final short opcode, final short length) {
          this.length = length;
          this.opcode = opcode;
      }
  
      /**
       * Dump instruction as byte code to stream out.
<span class="line-removed">-      *</span>
       * @param out Output stream
       */
<span class="line-modified">!     public void dump(final DataOutputStream out) throws IOException {</span>
          out.writeByte(opcode); // Common for all instructions
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * @return name of instruction, i.e., opcode name</span>
       */
      public String getName() {
          return Const.getOpcodeName(opcode);
      }
  
      /**
       * Long output format:
       *
<span class="line-modified">!      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot; &quot;(&quot;&amp;lt;length of</span>
<span class="line-modified">!      * instruction&amp;gt;&quot;)&quot;</span>
       *
       * @param verbose long/short format switch
       * @return mnemonic for instruction
       */
<span class="line-modified">!     public String toString(final boolean verbose) {</span>
          if (verbose) {
              return getName() + &quot;[&quot; + opcode + &quot;](&quot; + length + &quot;)&quot;;
          }
          return getName();
      }
  
      /**
       * @return mnemonic for instruction in verbose format
       */
      @Override
      public String toString() {
          return toString(true);
      }
  
      /**
       * @return mnemonic for instruction with sumbolic references resolved
       */
<span class="line-modified">!     public String toString(final ConstantPool cp) {</span>
          return toString(false);
      }
  
      /**
<span class="line-modified">!      * Use with caution, since `BranchInstruction&#39;s have a `target&#39; reference</span>
<span class="line-modified">!      * which is not copied correctly (only basic types are). This also applies</span>
<span class="line-modified">!      * for `Select&#39; instructions with their multiple branch targets.</span>
       *
       * @see BranchInstruction
       * @return (shallow) copy of an instruction
       */
      public Instruction copy() {
<span class="line-new-header">--- 27,88 ---</span>
  import com.sun.org.apache.bcel.internal.util.ByteSequence;
  
  /**
   * Abstract super class for all Java byte codes.
   *
<span class="line-modified">!  * @LastModified: Jan 2020</span>
   */
  public abstract class Instruction implements Cloneable {
  
      private short length = 1; // Length of instruction in bytes
      private short opcode = -1; // Opcode number
  
      private static InstructionComparator cmp = InstructionComparator.DEFAULT;
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Empty constructor needed for Instruction.readInstruction.</span>
<span class="line-modified">!      * Not to be used otherwise.</span>
       */
      Instruction() {
      }
  
<span class="line-added">+ </span>
      public Instruction(final short opcode, final short length) {
          this.length = length;
          this.opcode = opcode;
      }
  
<span class="line-added">+ </span>
      /**
       * Dump instruction as byte code to stream out.
       * @param out Output stream
       */
<span class="line-modified">!     public void dump( final DataOutputStream out ) throws IOException {</span>
          out.writeByte(opcode); // Common for all instructions
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** @return name of instruction, i.e., opcode name</span>
       */
      public String getName() {
          return Const.getOpcodeName(opcode);
      }
  
<span class="line-added">+ </span>
      /**
       * Long output format:
       *
<span class="line-modified">!      * &amp;lt;name of opcode&amp;gt; &quot;[&quot;&amp;lt;opcode number&amp;gt;&quot;]&quot;</span>
<span class="line-modified">!      * &quot;(&quot;&amp;lt;length of instruction&amp;gt;&quot;)&quot;</span>
       *
       * @param verbose long/short format switch
       * @return mnemonic for instruction
       */
<span class="line-modified">!     public String toString( final boolean verbose ) {</span>
          if (verbose) {
              return getName() + &quot;[&quot; + opcode + &quot;](&quot; + length + &quot;)&quot;;
          }
          return getName();
      }
  
<span class="line-added">+ </span>
      /**
       * @return mnemonic for instruction in verbose format
       */
      @Override
      public String toString() {
          return toString(true);
      }
  
<span class="line-added">+ </span>
      /**
       * @return mnemonic for instruction with sumbolic references resolved
       */
<span class="line-modified">!     public String toString( final ConstantPool cp ) {</span>
          return toString(false);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Use with caution, since `BranchInstruction&#39;s have a `target&#39; reference which</span>
<span class="line-modified">!      * is not copied correctly (only basic types are). This also applies for</span>
<span class="line-modified">!      * `Select&#39; instructions with their multiple branch targets.</span>
       *
       * @see BranchInstruction
       * @return (shallow) copy of an instruction
       */
      public Instruction copy() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,34 ***</span>
              }
          }
          return i;
      }
  
      /**
       * Read needed data (e.g. index) from file.
       *
       * @param bytes byte sequence to read from
       * @param wide &quot;wide&quot; instruction flag
<span class="line-modified">!      * @throws IOException may be thrown if the implementation needs to read</span>
<span class="line-removed">-      * data from the file</span>
       */
<span class="line-modified">!     protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {</span>
      }
  
      /**
       * Read an instruction from (byte code) input stream and return the
       * appropiate object.
       * &lt;p&gt;
       * If the Instruction is defined in {@link InstructionConst}, then the
       * singleton instance is returned.
<span class="line-removed">-      *</span>
       * @param bytes input stream bytes
       * @return instruction object being read
       * @see InstructionConst#getInstruction(int)
       */
      // @since 6.0 no longer final
<span class="line-modified">!     public static Instruction readInstruction(final ByteSequence bytes) throws IOException {</span>
          boolean wide = false;
          short opcode = (short) bytes.readUnsignedByte();
          Instruction obj = null;
          if (opcode == Const.WIDE) { // Read next opcode after wide byte
              wide = true;
<span class="line-new-header">--- 124,34 ---</span>
              }
          }
          return i;
      }
  
<span class="line-added">+ </span>
      /**
       * Read needed data (e.g. index) from file.
       *
       * @param bytes byte sequence to read from
       * @param wide &quot;wide&quot; instruction flag
<span class="line-modified">!      * @throws IOException may be thrown if the implementation needs to read data from the file</span>
       */
<span class="line-modified">!     protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {</span>
      }
  
<span class="line-added">+ </span>
      /**
       * Read an instruction from (byte code) input stream and return the
       * appropiate object.
       * &lt;p&gt;
       * If the Instruction is defined in {@link InstructionConst}, then the
       * singleton instance is returned.
       * @param bytes input stream bytes
       * @return instruction object being read
       * @see InstructionConst#getInstruction(int)
       */
      // @since 6.0 no longer final
<span class="line-modified">!     public static Instruction readInstruction( final ByteSequence bytes ) throws IOException {</span>
          boolean wide = false;
          short opcode = (short) bytes.readUnsignedByte();
          Instruction obj = null;
          if (opcode == Const.WIDE) { // Read next opcode after wide byte
              wide = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,136 ***</span>
          obj.initFromFile(bytes, wide); // Do further initializations, if any
          return obj;
      }
  
      /**
<span class="line-modified">!      * This method also gives right results for instructions whose effect on the</span>
<span class="line-modified">!      * stack depends on the constant pool entry they reference.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return Number of words consumed from stack by this instruction, or</span>
<span class="line-modified">!      * Constants.UNPREDICTABLE, if this can not be computed statically</span>
       */
<span class="line-modified">!     public int consumeStack(final ConstantPoolGen cpg) {</span>
          return Const.getConsumeStack(opcode);
      }
  
      /**
<span class="line-modified">!      * This method also gives right results for instructions whose effect on the</span>
<span class="line-modified">!      * stack depends on the constant pool entry they reference.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return Number of words produced onto stack by this instruction, or</span>
<span class="line-modified">!      * Constants.UNPREDICTABLE, if this can not be computed statically</span>
       */
<span class="line-modified">!     public int produceStack(final ConstantPoolGen cpg) {</span>
          return Const.getProduceStack(opcode);
      }
  
      /**
       * @return this instructions opcode
       */
      public short getOpcode() {
          return opcode;
      }
  
      /**
       * @return length (in bytes) of instruction
       */
      public int getLength() {
          return length;
      }
  
      /**
       * Needed in readInstruction and subclasses in this package
       */
<span class="line-modified">!     final void setOpcode(final short opcode) {</span>
          this.opcode = opcode;
      }
  
      /**
       * Needed in readInstruction and subclasses in this package
<span class="line-removed">-      *</span>
       * @since 6.0
       */
<span class="line-modified">!     final void setLength(final int length) {</span>
          this.length = (short) length; // TODO check range?
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Some instructions may be reused, so don&#39;t do anything by default.</span>
       */
      void dispose() {
      }
  
      /**
<span class="line-modified">!      * Call corresponding visitor method(s). The order is: Call visitor methods</span>
<span class="line-modified">!      * of implemented interfaces first, then call methods according to the class</span>
<span class="line-modified">!      * hierarchy in descending order, i.e., the most specific visitXXX() call</span>
<span class="line-modified">!      * comes last.</span>
       *
       * @param v Visitor object
       */
<span class="line-modified">!     public abstract void accept(Visitor v);</span>
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Get Comparator object used in the equals() method to determine equality</span>
<span class="line-modified">!      * of instructions.</span>
       *
       * @return currently used comparator for equals()
<span class="line-modified">!      * @deprecated (6.0) use the built in comparator, or wrap this class in</span>
<span class="line-removed">-      * another object that implements these methods</span>
       */
      @Deprecated
      public static InstructionComparator getComparator() {
          return cmp;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Set comparator to be used for equals().</span>
<span class="line-modified">!      *</span>
<span class="line-removed">-      * @deprecated (6.0) use the built in comparator, or wrap this class in</span>
<span class="line-removed">-      * another object that implements these methods</span>
       */
      @Deprecated
<span class="line-modified">!     public static void setComparator(final InstructionComparator c) {</span>
          cmp = c;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-modified">!      * Check for equality, delegated to comparator</span>
<span class="line-removed">-      *</span>
       * @return true if that is an Instruction and has the same opcode
       */
      @Override
<span class="line-modified">!     public boolean equals(final Object that) {</span>
          return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * calculate the hashCode of this object</span>
<span class="line-removed">-      *</span>
       * @return the hashCode
       * @since 6.0
       */
      @Override
      public int hashCode() {
          return opcode;
      }
  
      /**
       * Check if the value can fit in a byte (signed)
<span class="line-removed">-      *</span>
       * @param value the value to check
       * @return true if the value is in range
       * @since 6.0
       */
      public static boolean isValidByte(final int value) {
          return value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE;
      }
  
      /**
       * Check if the value can fit in a short (signed)
<span class="line-removed">-      *</span>
       * @param value the value to check
       * @return true if the value is in range
       * @since 6.0
       */
      public static boolean isValidShort(final int value) {
<span class="line-new-header">--- 467,133 ---</span>
          obj.initFromFile(bytes, wide); // Do further initializations, if any
          return obj;
      }
  
      /**
<span class="line-modified">!      * This method also gives right results for instructions whose</span>
<span class="line-modified">!      * effect on the stack depends on the constant pool entry they</span>
<span class="line-modified">!      * reference.</span>
<span class="line-modified">!      *  @return Number of words consumed from stack by this instruction,</span>
<span class="line-modified">!      * or Constants.UNPREDICTABLE, if this can not be computed statically</span>
       */
<span class="line-modified">!     public int consumeStack( final ConstantPoolGen cpg ) {</span>
          return Const.getConsumeStack(opcode);
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * This method also gives right results for instructions whose</span>
<span class="line-modified">!      * effect on the stack depends on the constant pool entry they</span>
<span class="line-modified">!      * reference.</span>
<span class="line-modified">!      * @return Number of words produced onto stack by this instruction,</span>
<span class="line-modified">!      * or Constants.UNPREDICTABLE, if this can not be computed statically</span>
       */
<span class="line-modified">!     public int produceStack( final ConstantPoolGen cpg ) {</span>
          return Const.getProduceStack(opcode);
      }
  
<span class="line-added">+ </span>
      /**
       * @return this instructions opcode
       */
      public short getOpcode() {
          return opcode;
      }
  
<span class="line-added">+ </span>
      /**
       * @return length (in bytes) of instruction
       */
      public int getLength() {
          return length;
      }
  
<span class="line-added">+ </span>
      /**
       * Needed in readInstruction and subclasses in this package
       */
<span class="line-modified">!     final void setOpcode( final short opcode ) {</span>
          this.opcode = opcode;
      }
  
<span class="line-added">+ </span>
      /**
       * Needed in readInstruction and subclasses in this package
       * @since 6.0
       */
<span class="line-modified">!     final void setLength( final int length ) {</span>
          this.length = (short) length; // TODO check range?
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Some instructions may be reused, so don&#39;t do anything by default.</span>
       */
      void dispose() {
      }
  
<span class="line-added">+ </span>
      /**
<span class="line-modified">!      * Call corresponding visitor method(s). The order is:</span>
<span class="line-modified">!      * Call visitor methods of implemented interfaces first, then</span>
<span class="line-modified">!      * call methods according to the class hierarchy in descending order,</span>
<span class="line-modified">!      * i.e., the most specific visitXXX() call comes last.</span>
       *
       * @param v Visitor object
       */
<span class="line-modified">!     public abstract void accept( Visitor v );</span>
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Get Comparator object used in the equals() method to determine</span>
<span class="line-modified">!      * equality of instructions.</span>
       *
       * @return currently used comparator for equals()
<span class="line-modified">!      * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods</span>
       */
      @Deprecated
      public static InstructionComparator getComparator() {
          return cmp;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Set comparator to be used for equals().</span>
<span class="line-modified">!       * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods</span>
       */
      @Deprecated
<span class="line-modified">!     public static void setComparator( final InstructionComparator c ) {</span>
          cmp = c;
      }
  
<span class="line-modified">! </span>
<span class="line-modified">!     /** Check for equality, delegated to comparator</span>
       * @return true if that is an Instruction and has the same opcode
       */
      @Override
<span class="line-modified">!     public boolean equals( final Object that ) {</span>
          return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;
      }
  
<span class="line-modified">!     /** calculate the hashCode of this object</span>
       * @return the hashCode
       * @since 6.0
       */
      @Override
      public int hashCode() {
          return opcode;
      }
  
      /**
       * Check if the value can fit in a byte (signed)
       * @param value the value to check
       * @return true if the value is in range
       * @since 6.0
       */
      public static boolean isValidByte(final int value) {
          return value &gt;= Byte.MIN_VALUE &amp;&amp; value &lt;= Byte.MAX_VALUE;
      }
  
      /**
       * Check if the value can fit in a short (signed)
       * @param value the value to check
       * @return true if the value is in range
       * @since 6.0
       */
      public static boolean isValidShort(final int value) {
</pre>
<center><a href="IndexedInstruction.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InstructionComparator.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
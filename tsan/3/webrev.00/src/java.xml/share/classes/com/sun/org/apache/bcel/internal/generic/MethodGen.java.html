<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/MethodGen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 package com.sun.org.apache.bcel.internal.generic;
  21 
  22 import com.sun.org.apache.bcel.internal.Const;
  23 import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;
  24 import com.sun.org.apache.bcel.internal.classfile.Annotations;
  25 import com.sun.org.apache.bcel.internal.classfile.Attribute;
  26 import com.sun.org.apache.bcel.internal.classfile.Code;
  27 import com.sun.org.apache.bcel.internal.classfile.CodeException;
  28 import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;
  29 import com.sun.org.apache.bcel.internal.classfile.LineNumber;
  30 import com.sun.org.apache.bcel.internal.classfile.LineNumberTable;
  31 import com.sun.org.apache.bcel.internal.classfile.LocalVariable;
  32 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTable;
  33 import com.sun.org.apache.bcel.internal.classfile.LocalVariableTypeTable;
  34 import com.sun.org.apache.bcel.internal.classfile.Method;
  35 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotationEntry;
  36 import com.sun.org.apache.bcel.internal.classfile.ParameterAnnotations;
  37 import com.sun.org.apache.bcel.internal.classfile.RuntimeVisibleParameterAnnotations;
  38 import com.sun.org.apache.bcel.internal.classfile.Utility;
  39 import com.sun.org.apache.bcel.internal.util.BCELComparator;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.HashMap;
  43 import java.util.List;
  44 import java.util.Map;
  45 import java.util.Objects;
  46 import java.util.Stack;
  47 
  48 /**
  49  * Template class for building up a method. This is done by defining exception
  50  * handlers, adding thrown exceptions, local variables and attributes, whereas
  51  * the `LocalVariableTable&#39; and `LineNumberTable&#39; attributes will be set
  52  * automatically for the code. Use stripAttributes() if you don&#39;t like this.
  53  *
  54  * While generating code it may be necessary to insert NOP operations. You can
  55  * use the `removeNOPs&#39; method to get rid off them.
  56  * The resulting method object can be obtained via the `getMethod()&#39; method.
  57  *
  58  * @see     InstructionList
  59  * @see     Method
  60  * @LastModified: Jan 2020
  61  */
  62 public class MethodGen extends FieldGenOrMethodGen {
  63 
  64     private String class_name;
  65     private Type[] arg_types;
  66     private String[] arg_names;
  67     private int max_locals;
  68     private int max_stack;
  69     private InstructionList il;
  70     private boolean strip_attributes;
  71     private LocalVariableTypeTable local_variable_type_table = null;
  72     private final List&lt;LocalVariableGen&gt; variable_vec = new ArrayList&lt;&gt;();
  73     private final List&lt;LineNumberGen&gt; line_number_vec = new ArrayList&lt;&gt;();
  74     private final List&lt;CodeExceptionGen&gt; exception_vec = new ArrayList&lt;&gt;();
  75     private final List&lt;String&gt; throws_vec = new ArrayList&lt;&gt;();
  76     private final List&lt;Attribute&gt; code_attrs_vec = new ArrayList&lt;&gt;();
  77 
  78     private List&lt;AnnotationEntryGen&gt;[] param_annotations; // Array of lists containing AnnotationGen objects
  79     private boolean hasParameterAnnotations = false;
  80     private boolean haveUnpackedParameterAnnotations = false;
  81 
  82     private static BCELComparator bcelComparator = new BCELComparator() {
  83 
  84         @Override
  85         public boolean equals( final Object o1, final Object o2 ) {
  86             final MethodGen THIS = (MethodGen) o1;
  87             final MethodGen THAT = (MethodGen) o2;
  88             return Objects.equals(THIS.getName(), THAT.getName())
  89                     &amp;&amp; Objects.equals(THIS.getSignature(), THAT.getSignature());
  90         }
  91 
  92 
  93         @Override
  94         public int hashCode( final Object o ) {
  95             final MethodGen THIS = (MethodGen) o;
  96             return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();
  97         }
  98     };
  99 
 100 
 101     /**
 102      * Declare method. If the method is non-static the constructor
 103      * automatically declares a local variable `$this&#39; in slot 0. The
 104      * actual code is contained in the `il&#39; parameter, which may further
 105      * manipulated by the user. But he must take care not to remove any
 106      * instruction (handles) that are still referenced from this object.
 107      *
 108      * For example one may not add a local variable and later remove the
 109      * instructions it refers to without causing havoc. It is safe
 110      * however if you remove that local variable, too.
 111      *
 112      * @param access_flags access qualifiers
 113      * @param return_type  method type
 114      * @param arg_types argument types
 115      * @param arg_names argument names (if this is null, default names will be provided
 116      * for them)
 117      * @param method_name name of method
 118      * @param class_name class name containing this method (may be null, if you don&#39;t care)
 119      * @param il instruction list associated with this method, may be null only for
 120      * abstract or native methods
 121      * @param cp constant pool
 122      */
 123     public MethodGen(final int access_flags, final Type return_type, final Type[] arg_types, String[] arg_names,
 124             final String method_name, final String class_name, final InstructionList il, final ConstantPoolGen cp) {
 125         super(access_flags);
 126         setType(return_type);
 127         setArgumentTypes(arg_types);
 128         setArgumentNames(arg_names);
 129         setName(method_name);
 130         setClassName(class_name);
 131         setInstructionList(il);
 132         setConstantPool(cp);
 133         final boolean abstract_ = isAbstract() || isNative();
 134         InstructionHandle start = null;
 135         final InstructionHandle end = null;
 136         if (!abstract_) {
 137             start = il.getStart();
 138             // end == null =&gt; live to end of method
 139             /* Add local variables, namely the implicit `this&#39; and the arguments
 140              */
 141             if (!isStatic() &amp;&amp; (class_name != null)) { // Instance method -&gt; `this&#39; is local var 0
 142                 addLocalVariable(&quot;this&quot;,  ObjectType.getInstance(class_name), start, end);
 143             }
 144         }
 145         if (arg_types != null) {
 146             final int size = arg_types.length;
 147             for (final Type arg_type : arg_types) {
 148                 if (Type.VOID == arg_type) {
 149                     throw new ClassGenException(&quot;&#39;void&#39; is an illegal argument type for a method&quot;);
 150                 }
 151             }
 152             if (arg_names != null) { // Names for variables provided?
 153                 if (size != arg_names.length) {
 154                     throw new ClassGenException(&quot;Mismatch in argument array lengths: &quot; + size
 155                             + &quot; vs. &quot; + arg_names.length);
 156                 }
 157             } else { // Give them dummy names
 158                 arg_names = new String[size];
 159                 for (int i = 0; i &lt; size; i++) {
 160                     arg_names[i] = &quot;arg&quot; + i;
 161                 }
 162                 setArgumentNames(arg_names);
 163             }
 164             if (!abstract_) {
 165                 for (int i = 0; i &lt; size; i++) {
 166                     addLocalVariable(arg_names[i], arg_types[i], start, end);
 167                 }
 168             }
 169         }
 170     }
 171 
 172 
 173     /**
 174      * Instantiate from existing method.
 175      *
 176      * @param m method
 177      * @param class_name class name containing this method
 178      * @param cp constant pool
 179      */
 180     public MethodGen(final Method m, final String class_name, final ConstantPoolGen cp) {
 181         this(m.getAccessFlags(), Type.getReturnType(m.getSignature()), Type.getArgumentTypes(m
 182                 .getSignature()), null /* may be overridden anyway */
 183         , m.getName(), class_name,
 184                 ((m.getAccessFlags() &amp; (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)
 185                         ? new InstructionList(m.getCode().getCode())
 186                         : null, cp);
 187         final Attribute[] attributes = m.getAttributes();
 188         for (final Attribute attribute : attributes) {
 189             Attribute a = attribute;
 190             if (a instanceof Code) {
 191                 final Code c = (Code) a;
 192                 setMaxStack(c.getMaxStack());
 193                 setMaxLocals(c.getMaxLocals());
 194                 final CodeException[] ces = c.getExceptionTable();
 195                 if (ces != null) {
 196                     for (final CodeException ce : ces) {
 197                         final int type = ce.getCatchType();
 198                         ObjectType c_type = null;
 199                         if (type &gt; 0) {
 200                             final String cen = m.getConstantPool().getConstantString(type,
 201                                     Const.CONSTANT_Class);
 202                             c_type =  ObjectType.getInstance(cen);
 203                         }
 204                         final int end_pc = ce.getEndPC();
 205                         final int length = m.getCode().getCode().length;
 206                         InstructionHandle end;
 207                         if (length == end_pc) { // May happen, because end_pc is exclusive
 208                             end = il.getEnd();
 209                         } else {
 210                             end = il.findHandle(end_pc);
 211                             end = end.getPrev(); // Make it inclusive
 212                         }
 213                         addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce
 214                                 .getHandlerPC()), c_type);
 215                     }
 216                 }
 217                 final Attribute[] c_attributes = c.getAttributes();
 218                 for (final Attribute c_attribute : c_attributes) {
 219                     a = c_attribute;
 220                     if (a instanceof LineNumberTable) {
 221                         final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();
 222                         for (final LineNumber l : ln) {
 223                             final InstructionHandle ih = il.findHandle(l.getStartPC());
 224                             if (ih != null) {
 225                                 addLineNumber(ih, l.getLineNumber());
 226                             }
 227                         }
 228                     } else if (a instanceof LocalVariableTable) {
 229                         updateLocalVariableTable((LocalVariableTable) a);
 230                     } else if (a instanceof LocalVariableTypeTable) {
 231                         this.local_variable_type_table = (LocalVariableTypeTable) a.copy(cp.getConstantPool());
 232                     } else {
 233                         addCodeAttribute(a);
 234                     }
 235                 }
 236             } else if (a instanceof ExceptionTable) {
 237                 final String[] names = ((ExceptionTable) a).getExceptionNames();
 238                 for (final String name2 : names) {
 239                     addException(name2);
 240                 }
 241             } else if (a instanceof Annotations) {
 242                 final Annotations runtimeAnnotations = (Annotations) a;
 243                 final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();
 244                 for (final AnnotationEntry element : aes) {
 245                     addAnnotationEntry(new AnnotationEntryGen(element, cp, false));
 246                 }
 247             } else {
 248                 addAttribute(a);
 249             }
 250         }
 251     }
 252 
 253     /**
 254      * Adds a local variable to this method.
 255      *
 256      * @param name variable name
 257      * @param type variable type
 258      * @param slot the index of the local variable, if type is long or double, the next available
 259      * index is slot+2
 260      * @param start from where the variable is valid
 261      * @param end until where the variable is valid
 262      * @param orig_index the index of the local variable prior to any modifications
 263      * @return new local variable object
 264      * @see LocalVariable
 265      */
 266     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,
 267             final InstructionHandle start, final InstructionHandle end, final int orig_index ) {
 268         final byte t = type.getType();
 269         if (t != Const.T_ADDRESS) {
 270             final int add = type.getSize();
 271             if (slot + add &gt; max_locals) {
 272                 max_locals = slot + add;
 273             }
 274             final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);
 275             int i;
 276             if ((i = variable_vec.indexOf(l)) &gt;= 0) {
 277                 variable_vec.set(i, l);
 278             } else {
 279                 variable_vec.add(l);
 280             }
 281             return l;
 282         }
 283         throw new IllegalArgumentException(&quot;Can not use &quot; + type
 284                 + &quot; as type for local variable&quot;);
 285     }
 286 
 287 
 288     /**
 289      * Adds a local variable to this method.
 290      *
 291      * @param name variable name
 292      * @param type variable type
 293      * @param slot the index of the local variable, if type is long or double, the next available
 294      * index is slot+2
 295      * @param start from where the variable is valid
 296      * @param end until where the variable is valid
 297      * @return new local variable object
 298      * @see LocalVariable
 299      */
 300     public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,
 301             final InstructionHandle start, final InstructionHandle end ) {
 302         return addLocalVariable(name, type, slot, start, end, slot);
 303     }
 304 
 305     /**
 306      * Adds a local variable to this method and assigns an index automatically.
 307      *
 308      * @param name variable name
 309      * @param type variable type
 310      * @param start from where the variable is valid, if this is null,
 311      * it is valid from the start
 312      * @param end until where the variable is valid, if this is null,
 313      * it is valid to the end
 314      * @return new local variable object
 315      * @see LocalVariable
 316      */
 317     public LocalVariableGen addLocalVariable( final String name, final Type type, final InstructionHandle start,
 318             final InstructionHandle end ) {
 319         return addLocalVariable(name, type, max_locals, start, end);
 320     }
 321 
 322 
 323     /**
 324      * Remove a local variable, its slot will not be reused, if you do not use
 325      * addLocalVariable with an explicit index argument.
 326      */
 327     public void removeLocalVariable(final LocalVariableGen l) {
 328         variable_vec.remove(l);
 329     }
 330 
 331 
 332     /**
 333      * Remove all local variables.
 334      */
 335     public void removeLocalVariables() {
 336         variable_vec.clear();
 337     }
 338 
 339 
 340     /*
 341      * If the range of the variable has not been set yet, it will be set to be valid from
 342      * the start to the end of the instruction list.
 343      *
 344      * @return array of declared local variables sorted by index
 345      */
 346     public LocalVariableGen[] getLocalVariables() {
 347         final int size = variable_vec.size();
 348         final LocalVariableGen[] lg = new LocalVariableGen[size];
 349         variable_vec.toArray(lg);
 350         for (int i = 0; i &lt; size; i++) {
 351             if ((lg[i].getStart() == null) &amp;&amp; (il != null)) {
 352                 lg[i].setStart(il.getStart());
 353             }
 354             if ((lg[i].getEnd() == null) &amp;&amp; (il != null)) {
 355                 lg[i].setEnd(il.getEnd());
 356             }
 357         }
 358         if (size &gt; 1) {
 359             Arrays.sort(lg, (o1, o2) -&gt; o1.getIndex() - o2.getIndex());
 360         }
 361         return lg;
 362     }
 363 
 364 
 365     /**
 366      * @return `LocalVariableTable&#39; attribute of all the local variables of this method.
 367      */
 368     public LocalVariableTable getLocalVariableTable( final ConstantPoolGen cp ) {
 369         final LocalVariableGen[] lg = getLocalVariables();
 370         final int size = lg.length;
 371         final LocalVariable[] lv = new LocalVariable[size];
 372         for (int i = 0; i &lt; size; i++) {
 373             lv[i] = lg[i].getLocalVariable(cp);
 374         }
 375         return new LocalVariableTable(cp.addUtf8(&quot;LocalVariableTable&quot;), 2 + lv.length * 10, lv, cp
 376                 .getConstantPool());
 377     }
 378 
 379     /**
 380      * @return `LocalVariableTypeTable&#39; attribute of this method.
 381      */
 382     public LocalVariableTypeTable getLocalVariableTypeTable() {
 383         return local_variable_type_table;
 384     }
 385 
 386     /**
 387      * Give an instruction a line number corresponding to the source code line.
 388      *
 389      * @param ih instruction to tag
 390      * @return new line number object
 391      * @see LineNumber
 392      */
 393     public LineNumberGen addLineNumber( final InstructionHandle ih, final int src_line ) {
 394         final LineNumberGen l = new LineNumberGen(ih, src_line);
 395         line_number_vec.add(l);
 396         return l;
 397     }
 398 
 399 
 400     /**
 401      * Remove a line number.
 402      */
 403     public void removeLineNumber( final LineNumberGen l ) {
 404         line_number_vec.remove(l);
 405     }
 406 
 407 
 408     /**
 409      * Remove all line numbers.
 410      */
 411     public void removeLineNumbers() {
 412         line_number_vec.clear();
 413     }
 414 
 415 
 416     /*
 417      * @return array of line numbers
 418      */
 419     public LineNumberGen[] getLineNumbers() {
 420         final LineNumberGen[] lg = new LineNumberGen[line_number_vec.size()];
 421         line_number_vec.toArray(lg);
 422         return lg;
 423     }
 424 
 425 
 426     /**
 427      * @return `LineNumberTable&#39; attribute of all the local variables of this method.
 428      */
 429     public LineNumberTable getLineNumberTable( final ConstantPoolGen cp ) {
 430         final int size = line_number_vec.size();
 431         final LineNumber[] ln = new LineNumber[size];
 432         for (int i = 0; i &lt; size; i++) {
 433             ln[i] = line_number_vec.get(i).getLineNumber();
 434         }
 435         return new LineNumberTable(cp.addUtf8(&quot;LineNumberTable&quot;), 2 + ln.length * 4, ln, cp
 436                 .getConstantPool());
 437     }
 438 
 439 
 440     /**
 441      * Add an exception handler, i.e., specify region where a handler is active and an
 442      * instruction where the actual handling is done.
 443      *
 444      * @param start_pc Start of region (inclusive)
 445      * @param end_pc End of region (inclusive)
 446      * @param handler_pc Where handling is done
 447      * @param catch_type class type of handled exception or null if any
 448      * exception is handled
 449      * @return new exception handler object
 450      */
 451     public CodeExceptionGen addExceptionHandler( final InstructionHandle start_pc,
 452             final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type ) {
 453         if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {
 454             throw new ClassGenException(&quot;Exception handler target is null instruction&quot;);
 455         }
 456         final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);
 457         exception_vec.add(c);
 458         return c;
 459     }
 460 
 461 
 462     /**
 463      * Remove an exception handler.
 464      */
 465     public void removeExceptionHandler( final CodeExceptionGen c ) {
 466         exception_vec.remove(c);
 467     }
 468 
 469 
 470     /**
 471      * Remove all line numbers.
 472      */
 473     public void removeExceptionHandlers() {
 474         exception_vec.clear();
 475     }
 476 
 477 
 478     /*
 479      * @return array of declared exception handlers
 480      */
 481     public CodeExceptionGen[] getExceptionHandlers() {
 482         final CodeExceptionGen[] cg = new CodeExceptionGen[exception_vec.size()];
 483         exception_vec.toArray(cg);
 484         return cg;
 485     }
 486 
 487 
 488     /**
 489      * @return code exceptions for `Code&#39; attribute
 490      */
 491     private CodeException[] getCodeExceptions() {
 492         final int size = exception_vec.size();
 493         final CodeException[] c_exc = new CodeException[size];
 494         for (int i = 0; i &lt; size; i++) {
 495             final CodeExceptionGen c =  exception_vec.get(i);
 496             c_exc[i] = c.getCodeException(super.getConstantPool());
 497         }
 498         return c_exc;
 499     }
 500 
 501 
 502     /**
 503      * Add an exception possibly thrown by this method.
 504      *
 505      * @param class_name (fully qualified) name of exception
 506      */
 507     public void addException( final String class_name ) {
 508         throws_vec.add(class_name);
 509     }
 510 
 511 
 512     /**
 513      * Remove an exception.
 514      */
 515     public void removeException( final String c ) {
 516         throws_vec.remove(c);
 517     }
 518 
 519 
 520     /**
 521      * Remove all exceptions.
 522      */
 523     public void removeExceptions() {
 524         throws_vec.clear();
 525     }
 526 
 527 
 528     /*
 529      * @return array of thrown exceptions
 530      */
 531     public String[] getExceptions() {
 532         final String[] e = new String[throws_vec.size()];
 533         throws_vec.toArray(e);
 534         return e;
 535     }
 536 
 537 
 538     /**
 539      * @return `Exceptions&#39; attribute of all the exceptions thrown by this method.
 540      */
 541     private ExceptionTable getExceptionTable( final ConstantPoolGen cp ) {
 542         final int size = throws_vec.size();
 543         final int[] ex = new int[size];
 544         for (int i = 0; i &lt; size; i++) {
 545             ex[i] = cp.addClass(throws_vec.get(i));
 546         }
 547         return new ExceptionTable(cp.addUtf8(&quot;Exceptions&quot;), 2 + 2 * size, ex, cp.getConstantPool());
 548     }
 549 
 550 
 551     /**
 552      * Add an attribute to the code. Currently, the JVM knows about the
 553      * LineNumberTable, LocalVariableTable and StackMap attributes,
 554      * where the former two will be generated automatically and the
 555      * latter is used for the MIDP only. Other attributes will be
 556      * ignored by the JVM but do no harm.
 557      *
 558      * @param a attribute to be added
 559      */
 560     public void addCodeAttribute( final Attribute a ) {
 561         code_attrs_vec.add(a);
 562     }
 563 
 564 
 565     /**
 566      * Remove the LocalVariableTypeTable
 567      */
 568     public void removeLocalVariableTypeTable( ) {
 569         local_variable_type_table = null;
 570     }
 571 
 572     /**
 573      * Remove a code attribute.
 574      */
 575     public void removeCodeAttribute( final Attribute a ) {
 576         code_attrs_vec.remove(a);
 577     }
 578 
 579 
 580     /**
 581      * Remove all code attributes.
 582      */
 583     public void removeCodeAttributes() {
 584         local_variable_type_table = null;
 585         code_attrs_vec.clear();
 586     }
 587 
 588 
 589     /**
 590      * @return all attributes of this method.
 591      */
 592     public Attribute[] getCodeAttributes() {
 593         final Attribute[] attributes = new Attribute[code_attrs_vec.size()];
 594         code_attrs_vec.toArray(attributes);
 595         return attributes;
 596     }
 597 
 598     /**
 599      * @since 6.0
 600      */
 601     public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {
 602           final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());
 603         for (final Attribute attr : attrs) {
 604             addAttribute(attr);
 605         }
 606       }
 607 
 608     /**
 609      * @since 6.0
 610      */
 611       public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {
 612           if (!hasParameterAnnotations) {
 613               return;
 614           }
 615           final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp,param_annotations);
 616           if (attrs != null) {
 617               for (final Attribute attr : attrs) {
 618                   addAttribute(attr);
 619               }
 620           }
 621       }
 622 
 623 
 624     /**
 625      * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,
 626      * before calling this method (the same applies for max locals).
 627      *
 628      * @return method object
 629      */
 630     public Method getMethod() {
 631         final String signature = getSignature();
 632         final ConstantPoolGen _cp = super.getConstantPool();
 633         final int name_index = _cp.addUtf8(super.getName());
 634         final int signature_index = _cp.addUtf8(signature);
 635         /* Also updates positions of instructions, i.e., their indices
 636          */
 637         byte[] byte_code = null;
 638         if (il != null) {
 639             byte_code = il.getByteCode();
 640         }
 641         LineNumberTable lnt = null;
 642         LocalVariableTable lvt = null;
 643         /* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)
 644          */
 645         if ((variable_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
 646             updateLocalVariableTable(getLocalVariableTable(_cp));
 647             addCodeAttribute(lvt = getLocalVariableTable(_cp));
 648         }
 649         if (local_variable_type_table != null) {
 650             // LocalVariable length in LocalVariableTypeTable is not updated automatically. It&#39;s a difference with LocalVariableTable.
 651             if (lvt != null) {
 652                 adjustLocalVariableTypeTable(lvt);
 653             }
 654             addCodeAttribute(local_variable_type_table);
 655         }
 656         if ((line_number_vec.size() &gt; 0) &amp;&amp; !strip_attributes) {
 657             addCodeAttribute(lnt = getLineNumberTable(_cp));
 658         }
 659         final Attribute[] code_attrs = getCodeAttributes();
 660         /* Each attribute causes 6 additional header bytes
 661          */
 662         int attrs_len = 0;
 663         for (final Attribute code_attr : code_attrs) {
 664             attrs_len += code_attr.getLength() + 6;
 665         }
 666         final CodeException[] c_exc = getCodeExceptions();
 667         final int exc_len = c_exc.length * 8; // Every entry takes 8 bytes
 668         Code code = null;
 669         if ((il != null) &amp;&amp; !isAbstract() &amp;&amp; !isNative()) {
 670             // Remove any stale code attribute
 671             final Attribute[] attributes = getAttributes();
 672             for (final Attribute a : attributes) {
 673                 if (a instanceof Code) {
 674                     removeAttribute(a);
 675                 }
 676             }
 677             code = new Code(_cp.addUtf8(&quot;Code&quot;), 8 + byte_code.length + // prologue byte code
 678                     2 + exc_len + // exceptions
 679                     2 + attrs_len, // attributes
 680                     max_stack, max_locals, byte_code, c_exc, code_attrs, _cp.getConstantPool());
 681             addAttribute(code);
 682         }
 683         addAnnotationsAsAttribute(_cp);
 684         addParameterAnnotationsAsAttribute(_cp);
 685         ExceptionTable et = null;
 686         if (throws_vec.size() &gt; 0) {
 687             addAttribute(et = getExceptionTable(_cp));
 688             // Add `Exceptions&#39; if there are &quot;throws&quot; clauses
 689         }
 690         final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp
 691                 .getConstantPool());
 692         // Undo effects of adding attributes
 693         if (lvt != null) {
 694             removeCodeAttribute(lvt);
 695         }
 696         if (local_variable_type_table != null) {
 697             removeCodeAttribute(local_variable_type_table);
 698         }
 699         if (lnt != null) {
 700             removeCodeAttribute(lnt);
 701         }
 702         if (code != null) {
 703             removeAttribute(code);
 704         }
 705         if (et != null) {
 706             removeAttribute(et);
 707         }
 708         return m;
 709     }
 710 
 711     private void updateLocalVariableTable(final LocalVariableTable a) {
 712         final LocalVariable[] lv = a.getLocalVariableTable();
 713         removeLocalVariables();
 714         for (final LocalVariable l : lv) {
 715             InstructionHandle start = il.findHandle(l.getStartPC());
 716             final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());
 717             // Repair malformed handles
 718             if (null == start) {
 719                 start = il.getStart();
 720             }
 721             // end == null =&gt; live to end of method
 722             // Since we are recreating the LocalVaraible, we must
 723             // propagate the orig_index to new copy.
 724             addLocalVariable(l.getName(), Type.getType(l.getSignature()), l
 725                     .getIndex(), start, end, l.getOrigIndex());
 726         }
 727     }
 728 
 729     private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {
 730         final LocalVariable[] lv = lvt.getLocalVariableTable();
 731         final LocalVariable[] lvg = local_variable_type_table.getLocalVariableTypeTable();
 732 
 733         for (final LocalVariable element : lvg) {
 734             for (final LocalVariable l : lv) {
 735                 if (element.getName().equals(l.getName()) &amp;&amp; element.getIndex() == l.getOrigIndex()) {
 736                     element.setLength(l.getLength());
 737                     element.setStartPC(l.getStartPC());
 738                     element.setIndex(l.getIndex());
 739                     break;
 740                 }
 741             }
 742         }
 743     }
 744 
 745 
 746     /**
 747      * Remove all NOPs from the instruction list (if possible) and update every
 748      * object referring to them, i.e., branch instructions, local variables and
 749      * exception handlers.
 750      */
 751     public void removeNOPs() {
 752         if (il != null) {
 753             InstructionHandle next;
 754             /* Check branch instructions.
 755              */
 756             for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {
 757                 next = ih.getNext();
 758                 if ((next != null) &amp;&amp; (ih.getInstruction() instanceof NOP)) {
 759                     try {
 760                         il.delete(ih);
 761                     } catch (final TargetLostException e) {
 762                         for (final InstructionHandle target : e.getTargets()) {
 763                             for (final InstructionTargeter targeter : target.getTargeters()) {
 764                                 targeter.updateTarget(target, next);
 765                             }
 766                         }
 767                     }
 768                 }
 769             }
 770         }
 771     }
 772 
 773 
 774     /**
 775      * Set maximum number of local variables.
 776      */
 777     public void setMaxLocals( final int m ) {
 778         max_locals = m;
 779     }
 780 
 781 
 782     public int getMaxLocals() {
 783         return max_locals;
 784     }
 785 
 786 
 787     /**
 788      * Set maximum stack size for this method.
 789      */
 790     public void setMaxStack( final int m ) { // TODO could be package-protected?
 791         max_stack = m;
 792     }
 793 
 794 
 795     public int getMaxStack() {
 796         return max_stack;
 797     }
 798 
 799 
 800     /** @return class that contains this method
 801      */
 802     public String getClassName() {
 803         return class_name;
 804     }
 805 
 806 
 807     public void setClassName( final String class_name ) { // TODO could be package-protected?
 808         this.class_name = class_name;
 809     }
 810 
 811 
 812     public void setReturnType( final Type return_type ) {
 813         setType(return_type);
 814     }
 815 
 816 
 817     public Type getReturnType() {
 818         return getType();
 819     }
 820 
 821 
 822     public void setArgumentTypes( final Type[] arg_types ) {
 823         this.arg_types = arg_types;
 824     }
 825 
 826 
 827     public Type[] getArgumentTypes() {
 828         return arg_types.clone();
 829     }
 830 
 831 
 832     public void setArgumentType( final int i, final Type type ) {
 833         arg_types[i] = type;
 834     }
 835 
 836 
 837     public Type getArgumentType( final int i ) {
 838         return arg_types[i];
 839     }
 840 
 841 
 842     public void setArgumentNames( final String[] arg_names ) {
 843         this.arg_names = arg_names;
 844     }
 845 
 846 
 847     public String[] getArgumentNames() {
 848         return arg_names.clone();
 849     }
 850 
 851 
 852     public void setArgumentName( final int i, final String name ) {
 853         arg_names[i] = name;
 854     }
 855 
 856 
 857     public String getArgumentName( final int i ) {
 858         return arg_names[i];
 859     }
 860 
 861 
 862     public InstructionList getInstructionList() {
 863         return il;
 864     }
 865 
 866 
 867     public void setInstructionList( final InstructionList il ) { // TODO could be package-protected?
 868         this.il = il;
 869     }
 870 
 871 
 872     @Override
 873     public String getSignature() {
 874         return Type.getMethodSignature(super.getType(), arg_types);
 875     }
 876 
 877 
 878     /**
 879      * Computes max. stack size by performing control flow analysis.
 880      */
 881     public void setMaxStack() { // TODO could be package-protected? (some tests would need repackaging)
 882         if (il != null) {
 883             max_stack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());
 884         } else {
 885             max_stack = 0;
 886         }
 887     }
 888 
 889 
 890     /**
 891      * Compute maximum number of local variables.
 892      */
 893     public void setMaxLocals() { // TODO could be package-protected? (some tests would need repackaging)
 894         if (il != null) {
 895             int max = isStatic() ? 0 : 1;
 896             if (arg_types != null) {
 897                 for (final Type arg_type : arg_types) {
 898                     max += arg_type.getSize();
 899                 }
 900             }
 901             for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
 902                 final Instruction ins = ih.getInstruction();
 903                 if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)
 904                         || (ins instanceof IINC)) {
 905                     final int index = ((IndexedInstruction) ins).getIndex()
 906                             + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();
 907                     if (index &gt; max) {
 908                         max = index;
 909                     }
 910                 }
 911             }
 912             max_locals = max;
 913         } else {
 914             max_locals = 0;
 915         }
 916     }
 917 
 918 
 919     /** Do not/Do produce attributes code attributesLineNumberTable and
 920      * LocalVariableTable, like javac -O
 921      */
 922     public void stripAttributes( final boolean flag ) {
 923         strip_attributes = flag;
 924     }
 925 
 926     static final class BranchTarget {
 927 
 928         final InstructionHandle target;
 929         final int stackDepth;
 930 
 931 
 932         BranchTarget(final InstructionHandle target, final int stackDepth) {
 933             this.target = target;
 934             this.stackDepth = stackDepth;
 935         }
 936     }
 937 
 938     static final class BranchStack {
 939 
 940         private final Stack&lt;BranchTarget&gt; branchTargets = new Stack&lt;&gt;();
 941         private final Map&lt;InstructionHandle, BranchTarget&gt; visitedTargets = new HashMap&lt;&gt;();
 942 
 943 
 944         public void push( final InstructionHandle target, final int stackDepth ) {
 945             if (visited(target)) {
 946                 return;
 947             }
 948             branchTargets.push(visit(target, stackDepth));
 949         }
 950 
 951 
 952         public BranchTarget pop() {
 953             if (!branchTargets.empty()) {
 954                 final BranchTarget bt = branchTargets.pop();
 955                 return bt;
 956             }
 957             return null;
 958         }
 959 
 960 
 961         private BranchTarget visit( final InstructionHandle target, final int stackDepth ) {
 962             final BranchTarget bt = new BranchTarget(target, stackDepth);
 963             visitedTargets.put(target, bt);
 964             return bt;
 965         }
 966 
 967 
 968         private boolean visited( final InstructionHandle target ) {
 969             return visitedTargets.get(target) != null;
 970         }
 971     }
 972 
 973 
 974     /**
 975      * Computes stack usage of an instruction list by performing control flow analysis.
 976      *
 977      * @return maximum stack depth used by method
 978      */
 979     public static int getMaxStack( final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et ) {
 980         final BranchStack branchTargets = new BranchStack();
 981         /* Initially, populate the branch stack with the exception
 982          * handlers, because these aren&#39;t (necessarily) branched to
 983          * explicitly. in each case, the stack will have depth 1,
 984          * containing the exception object.
 985          */
 986         for (final CodeExceptionGen element : et) {
 987             final InstructionHandle handler_pc = element.getHandlerPC();
 988             if (handler_pc != null) {
 989                 branchTargets.push(handler_pc, 1);
 990             }
 991         }
 992         int stackDepth = 0;
 993         int maxStackDepth = 0;
 994         InstructionHandle ih = il.getStart();
 995         while (ih != null) {
 996             final Instruction instruction = ih.getInstruction();
 997             final short opcode = instruction.getOpcode();
 998             final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);
 999             stackDepth += delta;
1000             if (stackDepth &gt; maxStackDepth) {
1001                 maxStackDepth = stackDepth;
1002             }
1003             // choose the next instruction based on whether current is a branch.
1004             if (instruction instanceof BranchInstruction) {
1005                 final BranchInstruction branch = (BranchInstruction) instruction;
1006                 if (instruction instanceof Select) {
1007                     // explore all of the select&#39;s targets. the default target is handled below.
1008                     final Select select = (Select) branch;
1009                     final InstructionHandle[] targets = select.getTargets();
1010                     for (final InstructionHandle target : targets) {
1011                         branchTargets.push(target, stackDepth);
1012                     }
1013                     // nothing to fall through to.
1014                     ih = null;
1015                 } else if (!(branch instanceof IfInstruction)) {
1016                     // if an instruction that comes back to following PC,
1017                     // push next instruction, with stack depth reduced by 1.
1018                     if (opcode == Const.JSR || opcode == Const.JSR_W) {
1019                         branchTargets.push(ih.getNext(), stackDepth - 1);
1020                     }
1021                     ih = null;
1022                 }
1023                 // for all branches, the target of the branch is pushed on the branch stack.
1024                 // conditional branches have a fall through case, selects don&#39;t, and
1025                 // jsr/jsr_w return to the next instruction.
1026                 branchTargets.push(branch.getTarget(), stackDepth);
1027             } else {
1028                 // check for instructions that terminate the method.
1029                 if (opcode == Const.ATHROW || opcode == Const.RET
1030                         || (opcode &gt;= Const.IRETURN &amp;&amp; opcode &lt;= Const.RETURN)) {
1031                     ih = null;
1032                 }
1033             }
1034             // normal case, go to the next instruction.
1035             if (ih != null) {
1036                 ih = ih.getNext();
1037             }
1038             // if we have no more instructions, see if there are any deferred branches to explore.
1039             if (ih == null) {
1040                 final BranchTarget bt = branchTargets.pop();
1041                 if (bt != null) {
1042                     ih = bt.target;
1043                     stackDepth = bt.stackDepth;
1044                 }
1045             }
1046         }
1047         return maxStackDepth;
1048     }
1049 
1050     private List&lt;MethodObserver&gt; observers;
1051 
1052 
1053     /** Add observer for this object.
1054      */
1055     public void addObserver( final MethodObserver o ) {
1056         if (observers == null) {
1057             observers = new ArrayList&lt;&gt;();
1058         }
1059         observers.add(o);
1060     }
1061 
1062 
1063     /** Remove observer for this object.
1064      */
1065     public void removeObserver( final MethodObserver o ) {
1066         if (observers != null) {
1067             observers.remove(o);
1068         }
1069     }
1070 
1071 
1072     /** Call notify() method on all observers. This method is not called
1073      * automatically whenever the state has changed, but has to be
1074      * called by the user after he has finished editing the object.
1075      */
1076     public void update() {
1077         if (observers != null) {
1078             for (final MethodObserver observer : observers) {
1079                 observer.notify(this);
1080             }
1081         }
1082     }
1083 
1084 
1085     /**
1086      * Return string representation close to declaration format,
1087      * `public static void main(String[]) throws IOException&#39;, e.g.
1088      *
1089      * @return String representation of the method.
1090      */
1091     @Override
1092     public final String toString() {
1093         final String access = Utility.accessToString(super.getAccessFlags());
1094         String signature = Type.getMethodSignature(super.getType(), arg_types);
1095         signature = Utility.methodSignatureToString(signature, super.getName(), access, true,
1096                 getLocalVariableTable(super.getConstantPool()));
1097         final StringBuilder buf = new StringBuilder(signature);
1098         for (final Attribute a : getAttributes()) {
1099             if (!((a instanceof Code) || (a instanceof ExceptionTable))) {
1100                 buf.append(&quot; [&quot;).append(a).append(&quot;]&quot;);
1101             }
1102         }
1103 
1104         if (throws_vec.size() &gt; 0) {
1105             for (final String throwsDescriptor : throws_vec) {
1106                 buf.append(&quot;\n\t\tthrows &quot;).append(throwsDescriptor);
1107             }
1108         }
1109         return buf.toString();
1110     }
1111 
1112 
1113     /** @return deep copy of this method
1114      */
1115     public MethodGen copy( final String class_name, final ConstantPoolGen cp ) {
1116         final Method m = ((MethodGen) clone()).getMethod();
1117         final MethodGen mg = new MethodGen(m, class_name, super.getConstantPool());
1118         if (super.getConstantPool() != cp) {
1119             mg.setConstantPool(cp);
1120             mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);
1121         }
1122         return mg;
1123     }
1124 
1125     //J5TODO: Should param_annotations be an array of arrays? Rather than an array of lists, this
1126     // is more likely to suggest to the caller it is readonly (which a List does not).
1127     /**
1128      * Return a list of AnnotationGen objects representing parameter annotations
1129      * @since 6.0
1130      */
1131     public List&lt;AnnotationEntryGen&gt; getAnnotationsOnParameter(final int i) {
1132         ensureExistingParameterAnnotationsUnpacked();
1133         if (!hasParameterAnnotations || i &gt; arg_types.length) {
1134             return null;
1135         }
1136         return param_annotations[i];
1137     }
1138 
1139     /**
1140      * Goes through the attributes on the method and identifies any that are
1141      * RuntimeParameterAnnotations, extracting their contents and storing them
1142      * as parameter annotations. There are two kinds of parameter annotation -
1143      * visible and invisible. Once they have been unpacked, these attributes are
1144      * deleted. (The annotations will be rebuilt as attributes when someone
1145      * builds a Method object out of this MethodGen object).
1146      */
1147     private void ensureExistingParameterAnnotationsUnpacked()
1148     {
1149         if (haveUnpackedParameterAnnotations) {
1150             return;
1151         }
1152         // Find attributes that contain parameter annotation data
1153         final Attribute[] attrs = getAttributes();
1154         ParameterAnnotations paramAnnVisAttr = null;
1155         ParameterAnnotations paramAnnInvisAttr = null;
1156         for (final Attribute attribute : attrs) {
1157             if (attribute instanceof ParameterAnnotations)
1158             {
1159                 // Initialize param_annotations
1160                 if (!hasParameterAnnotations)
1161                 {
1162                     @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1163                     final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1164                     param_annotations = parmList;
1165                     for (int j = 0; j &lt; arg_types.length; j++) {
1166                         param_annotations[j] = new ArrayList&lt;&gt;();
1167                     }
1168                 }
1169                 hasParameterAnnotations = true;
1170                 final ParameterAnnotations rpa = (ParameterAnnotations) attribute;
1171                 if (rpa instanceof RuntimeVisibleParameterAnnotations) {
1172                     paramAnnVisAttr = rpa;
1173                 } else {
1174                     paramAnnInvisAttr = rpa;
1175                 }
1176                 final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();
1177                 for (int j = 0; j &lt; parameterAnnotationEntries.length; j++)
1178                 {
1179                     // This returns Annotation[] ...
1180                     final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];
1181                     // ... which needs transforming into an AnnotationGen[] ...
1182                     final List&lt;AnnotationEntryGen&gt; mutable = makeMutableVersion(immutableArray.getAnnotationEntries());
1183                     // ... then add these to any we already know about
1184                     param_annotations[j].addAll(mutable);
1185                 }
1186             }
1187         }
1188         if (paramAnnVisAttr != null) {
1189             removeAttribute(paramAnnVisAttr);
1190         }
1191         if (paramAnnInvisAttr != null) {
1192             removeAttribute(paramAnnInvisAttr);
1193         }
1194         haveUnpackedParameterAnnotations = true;
1195     }
1196 
1197     private List&lt;AnnotationEntryGen&gt; makeMutableVersion(final AnnotationEntry[] mutableArray)
1198     {
1199         final List&lt;AnnotationEntryGen&gt; result = new ArrayList&lt;&gt;();
1200         for (final AnnotationEntry element : mutableArray) {
1201             result.add(new AnnotationEntryGen(element, getConstantPool(),
1202                     false));
1203         }
1204         return result;
1205     }
1206 
1207     public void addParameterAnnotation(final int parameterIndex,
1208             final AnnotationEntryGen annotation)
1209     {
1210         ensureExistingParameterAnnotationsUnpacked();
1211         if (!hasParameterAnnotations)
1212         {
1213             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
1214             final List&lt;AnnotationEntryGen&gt;[] parmList = new List[arg_types.length];
1215             param_annotations = parmList;
1216             hasParameterAnnotations = true;
1217         }
1218         final List&lt;AnnotationEntryGen&gt; existingAnnotations = param_annotations[parameterIndex];
1219         if (existingAnnotations != null)
1220         {
1221             existingAnnotations.add(annotation);
1222         }
1223         else
1224         {
1225             final List&lt;AnnotationEntryGen&gt; l = new ArrayList&lt;&gt;();
1226             l.add(annotation);
1227             param_annotations[parameterIndex] = l;
1228         }
1229     }
1230 
1231     /**
1232      * @return Comparison strategy object
1233      */
1234     public static BCELComparator getComparator() {
1235         return bcelComparator;
1236     }
1237 
1238 
1239     /**
1240      * @param comparator Comparison strategy object
1241      */
1242     public static void setComparator( final BCELComparator comparator ) {
1243         bcelComparator = comparator;
1244     }
1245 
1246 
1247     /**
1248      * Return value as defined by given BCELComparator strategy.
1249      * By default two MethodGen objects are said to be equal when
1250      * their names and signatures are equal.
1251      *
1252      * @see java.lang.Object#equals(java.lang.Object)
1253      */
1254     @Override
1255     public boolean equals( final Object obj ) {
1256         return bcelComparator.equals(this, obj);
1257     }
1258 
1259 
1260     /**
1261      * Return value as defined by given BCELComparator strategy.
1262      * By default return the hashcode of the method&#39;s name XOR signature.
1263      *
1264      * @see java.lang.Object#hashCode()
1265      */
1266     @Override
1267     public int hashCode() {
1268         return bcelComparator.hashCode(this);
1269     }
1270 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/com/sun/org/apache/bcel/internal/generic/SWITCH.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * reserved comment block
  3  * DO NOT REMOVE OR ALTER!
  4  */
  5 /*
  6  * Licensed to the Apache Software Foundation (ASF) under one or more
  7  * contributor license agreements.  See the NOTICE file distributed with
  8  * this work for additional information regarding copyright ownership.
  9  * The ASF licenses this file to You under the Apache License, Version 2.0
 10  * (the &quot;License&quot;); you may not use this file except in compliance with
 11  * the License.  You may obtain a copy of the License at
 12  *
 13  *      http://www.apache.org/licenses/LICENSE-2.0
 14  *
 15  * Unless required by applicable law or agreed to in writing, software
 16  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 17  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 18  * See the License for the specific language governing permissions and
 19  * limitations under the License.
 20  */
 21 
 22 package com.sun.org.apache.bcel.internal.generic;
 23 
 24 /**
 25  * SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or
 26  * TABLESWITCH instruction, depending on whether the match values (int[]) can be
 27  * sorted with no gaps between the numbers.
 28  *
<a name="1" id="anc1"></a>
 29  */
 30 public final class SWITCH implements CompoundInstruction {
 31 
 32     private int[] match;
 33     private InstructionHandle[] targets;
 34     private Select instruction;
 35     private int match_length;
 36 
 37 
 38     /**
 39      * Template for switch() constructs. If the match array can be
 40      * sorted in ascending order with gaps no larger than max_gap
 41      * between the numbers, a TABLESWITCH instruction is generated, and
 42      * a LOOKUPSWITCH otherwise. The former may be more efficient, but
 43      * needs more space.
 44      *
 45      * Note, that the key array always will be sorted, though we leave
 46      * the original arrays unaltered.
 47      *
 48      * @param match array of match values (case 2: ... case 7: ..., etc.)
 49      * @param targets the instructions to be branched to for each case
 50      * @param target the default target
 51      * @param max_gap maximum gap that may between case branches
 52      */
 53     public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int max_gap) {
 54         this.match = match.clone();
 55         this.targets = targets.clone();
 56         if ((match_length = match.length) &lt; 2) {
 57             instruction = new TABLESWITCH(match, targets, target);
 58         } else {
 59             sort(0, match_length - 1);
 60             if (matchIsOrdered(max_gap)) {
 61                 fillup(max_gap, target);
 62                 instruction = new TABLESWITCH(this.match, this.targets, target);
 63             } else {
 64                 instruction = new LOOKUPSWITCH(this.match, this.targets, target);
 65             }
 66         }
 67     }
 68 
 69 
 70     public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {
 71         this(match, targets, target, 1);
 72     }
 73 
 74 
 75     private void fillup( final int max_gap, final InstructionHandle target ) {
 76         final int max_size = match_length + match_length * max_gap;
 77         final int[] m_vec = new int[max_size];
 78         final InstructionHandle[] t_vec = new InstructionHandle[max_size];
 79         int count = 1;
 80         m_vec[0] = match[0];
 81         t_vec[0] = targets[0];
 82         for (int i = 1; i &lt; match_length; i++) {
 83             final int prev = match[i - 1];
 84             final int gap = match[i] - prev;
 85             for (int j = 1; j &lt; gap; j++) {
 86                 m_vec[count] = prev + j;
 87                 t_vec[count] = target;
 88                 count++;
 89             }
 90             m_vec[count] = match[i];
 91             t_vec[count] = targets[i];
 92             count++;
 93         }
 94         match = new int[count];
 95         targets = new InstructionHandle[count];
 96         System.arraycopy(m_vec, 0, match, 0, count);
 97         System.arraycopy(t_vec, 0, targets, 0, count);
 98     }
 99 
100 
101     /**
102      * Sort match and targets array with QuickSort.
103      */
104     private void sort( final int l, final int r ) {
105         int i = l;
106         int j = r;
107         int h;
<a name="2" id="anc2"></a><span class="line-modified">108         final int m = match[(l + r) &gt;&gt;&gt; 1];</span>
109         InstructionHandle h2;
110         do {
111             while (match[i] &lt; m) {
112                 i++;
113             }
114             while (m &lt; match[j]) {
115                 j--;
116             }
117             if (i &lt;= j) {
118                 h = match[i];
119                 match[i] = match[j];
120                 match[j] = h; // Swap elements
121                 h2 = targets[i];
122                 targets[i] = targets[j];
123                 targets[j] = h2; // Swap instructions, too
124                 i++;
125                 j--;
126             }
127         } while (i &lt;= j);
128         if (l &lt; j) {
129             sort(l, j);
130         }
131         if (i &lt; r) {
132             sort(i, r);
133         }
134     }
135 
136 
137     /**
138      * @return match is sorted in ascending order with no gap bigger than max_gap?
139      */
140     private boolean matchIsOrdered( final int max_gap ) {
141         for (int i = 1; i &lt; match_length; i++) {
142             if (match[i] - match[i - 1] &gt; max_gap) {
143                 return false;
144             }
145         }
146         return true;
147     }
148 
149 
150     @Override
<a name="3" id="anc3"></a><span class="line-modified">151     public InstructionList getInstructionList() {</span>
152         return new InstructionList(instruction);
153     }
154 
155 
<a name="4" id="anc4"></a><span class="line-modified">156     public Instruction getInstruction() {</span>
157         return instruction;
158     }
159 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDComplexTypeTraverser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XSDAbstractTraverser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="XSDHandler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.xml/share/classes/com/sun/org/apache/xerces/internal/impl/xs/traversers/XSDComplexTypeTraverser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.impl.xs.traversers;
  22 
</pre>
<hr />
<pre>
  45 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
  46 import org.w3c.dom.Element;
  47 
  48 /**
  49  * A complex type definition schema component traverser.
  50  *
  51  * &lt;complexType
  52  *   abstract = boolean : false
  53  *   block = (#all | List of (extension | restriction))
  54  *   final = (#all | List of (extension | restriction))
  55  *   id = ID
  56  *   mixed = boolean : false
  57  *   name = NCName
  58  *   {any attributes with non-schema namespace . . .}&gt;
  59  *   Content: (annotation?, (simpleContent | complexContent |
  60  *            ((group | all | choice | sequence)?,
  61  *            ((attribute | attributeGroup)*, anyAttribute?))))
  62  * &lt;/complexType&gt;
  63  *
  64  * @xerces.internal
<span class="line-modified">  65  *</span>
  66  */
  67 
  68 class  XSDComplexTypeTraverser extends XSDAbstractParticleTraverser {
  69 
  70     // size of stack to hold globals:
  71     private final static int GLOBAL_NUM = 11;
  72 
  73     private static XSParticleDecl fErrorContent = null;
  74     private static XSWildcardDecl fErrorWildcard = null;
  75     private static XSParticleDecl getErrorContent() {
  76         if (fErrorContent == null) {
  77             XSParticleDecl particle = new XSParticleDecl();
  78             particle.fType = XSParticleDecl.PARTICLE_WILDCARD;
  79             particle.fValue = getErrorWildcard();
  80             particle.fMinOccurs = 0;
  81             particle.fMaxOccurs = SchemaSymbols.OCCURRENCE_UNBOUNDED;
  82             XSModelGroupImpl group = new XSModelGroupImpl();
  83             group.fCompositor = XSModelGroupImpl.MODELGROUP_SEQUENCE;
  84             group.fParticleCount = 1;
  85             group.fParticles = new XSParticleDecl[1];
</pre>
<hr />
<pre>
 557             }
 558 
 559             // this only happens when restricting a mixed/emptiable CT
 560             // but there is no &lt;simpleType&gt;, which is required
 561             if (baseValidator == null) {
 562                 fAttrChecker.returnAttrArray(simpleContentAttrValues, schemaDoc);
 563                 fAttrChecker.returnAttrArray(derivationTypeAttrValues, schemaDoc);
 564                 throw new ComplexTypeRecoverableError(&quot;src-ct.2.2&quot;,
 565                         new Object[]{fName}, simpleContent);
 566             }
 567 
 568             // -----------------------------------------------------------------------
 569             // Traverse any facets
 570             // -----------------------------------------------------------------------
 571             Element attrNode = null;
 572             XSFacets facetData = null;
 573             short presentFacets = 0 ;
 574             short fixedFacets = 0 ;
 575 
 576             if (simpleContent!=null) {
<span class="line-modified"> 577                 FacetInfo fi = traverseFacets(simpleContent, baseValidator, schemaDoc);</span>
 578                 attrNode = fi.nodeAfterFacets;
 579                 facetData = fi.facetdata;
 580                 presentFacets = fi.fPresentFacets;
 581                 fixedFacets = fi.fFixedFacets;
 582             }
 583 
 584             String name = genAnonTypeName(simpleContentElement);
 585             fXSSimpleType = fSchemaHandler.fDVFactory.createTypeRestriction(name,schemaDoc.fTargetNamespace,(short)0,baseValidator,null);
 586             try{
 587                 fValidationState.setNamespaceSupport(schemaDoc.fNamespaceSupport);
 588                 fXSSimpleType.applyFacets(facetData, presentFacets, fixedFacets, fValidationState);
 589             }catch(InvalidDatatypeFacetException ex){
 590                 reportSchemaError(ex.getKey(), ex.getArgs(), simpleContent);
 591                 // Recreate the type, ignoring the facets
 592                 fXSSimpleType = fSchemaHandler.fDVFactory.createTypeRestriction(name,schemaDoc.fTargetNamespace,(short)0,baseValidator,null);
 593             }
 594             if (fXSSimpleType instanceof XSSimpleTypeDecl) {
 595                 ((XSSimpleTypeDecl)fXSSimpleType).setAnonymous(true);
 596             }
 597 
</pre>
<hr />
<pre>
1176 
1177 
1178     private void handleComplexTypeError(String messageId,Object[] args,
1179             Element e) {
1180 
1181         if (messageId!=null) {
1182             reportSchemaError(messageId, args, e);
1183         }
1184 
1185         //
1186         //  Mock up the typeInfo structure so that there won&#39;t be problems during
1187         //  validation
1188         //
1189         fBaseType = SchemaGrammar.fAnyType;
1190         fContentType = XSComplexTypeDecl.CONTENTTYPE_MIXED;
1191         fXSSimpleType = null;
1192         fParticle = getErrorContent();
1193         // REVISIT: do we need to remove all attribute uses already added into
1194         // the attribute group? maybe it&#39;s ok to leave them there. -SG
1195         fAttrGrp.fAttributeWC = getErrorWildcard();
<span class="line-removed">1196 </span>
<span class="line-removed">1197         return;</span>
<span class="line-removed">1198 </span>
1199     }
1200 
1201     private void contentBackup() {
1202         if(fGlobalStore == null) {
1203             fGlobalStore = new Object [GLOBAL_NUM];
1204             fGlobalStorePos = 0;
1205         }
1206         if(fGlobalStorePos == fGlobalStore.length) {
1207             Object [] newArray = new Object[fGlobalStorePos+GLOBAL_NUM];
1208             System.arraycopy(fGlobalStore, 0, newArray, 0, fGlobalStorePos);
1209             fGlobalStore = newArray;
1210         }
1211         fGlobalStore[fGlobalStorePos++] = fComplexTypeDecl;
1212         fGlobalStore[fGlobalStorePos++] = fIsAbstract?Boolean.TRUE:Boolean.FALSE;
1213         fGlobalStore[fGlobalStorePos++] = fName ;
1214         fGlobalStore[fGlobalStorePos++] = fTargetNamespace;
1215         // let&#39;s save ourselves a couple of objects...
1216         fGlobalStore[fGlobalStorePos++] = (fDerivedBy &lt;&lt; 16) + fFinal;
1217         fGlobalStore[fGlobalStorePos++] = (fBlock &lt;&lt; 16) + fContentType;
1218         fGlobalStore[fGlobalStorePos++] = fBaseType;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  */
   4 /*
   5  * Licensed to the Apache Software Foundation (ASF) under one or more
   6  * contributor license agreements.  See the NOTICE file distributed with
   7  * this work for additional information regarding copyright ownership.
   8  * The ASF licenses this file to You under the Apache License, Version 2.0
   9  * (the &quot;License&quot;); you may not use this file except in compliance with
  10  * the License.  You may obtain a copy of the License at
  11  *
  12  *      http://www.apache.org/licenses/LICENSE-2.0
  13  *
  14  * Unless required by applicable law or agreed to in writing, software
  15  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  16  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  17  * See the License for the specific language governing permissions and
  18  * limitations under the License.
  19  */
  20 
  21 package com.sun.org.apache.xerces.internal.impl.xs.traversers;
  22 
</pre>
<hr />
<pre>
  45 import com.sun.org.apache.xerces.internal.xs.XSTypeDefinition;
  46 import org.w3c.dom.Element;
  47 
  48 /**
  49  * A complex type definition schema component traverser.
  50  *
  51  * &lt;complexType
  52  *   abstract = boolean : false
  53  *   block = (#all | List of (extension | restriction))
  54  *   final = (#all | List of (extension | restriction))
  55  *   id = ID
  56  *   mixed = boolean : false
  57  *   name = NCName
  58  *   {any attributes with non-schema namespace . . .}&gt;
  59  *   Content: (annotation?, (simpleContent | complexContent |
  60  *            ((group | all | choice | sequence)?,
  61  *            ((attribute | attributeGroup)*, anyAttribute?))))
  62  * &lt;/complexType&gt;
  63  *
  64  * @xerces.internal
<span class="line-modified">  65  * @LastModified: Apr 2019</span>
  66  */
  67 
  68 class  XSDComplexTypeTraverser extends XSDAbstractParticleTraverser {
  69 
  70     // size of stack to hold globals:
  71     private final static int GLOBAL_NUM = 11;
  72 
  73     private static XSParticleDecl fErrorContent = null;
  74     private static XSWildcardDecl fErrorWildcard = null;
  75     private static XSParticleDecl getErrorContent() {
  76         if (fErrorContent == null) {
  77             XSParticleDecl particle = new XSParticleDecl();
  78             particle.fType = XSParticleDecl.PARTICLE_WILDCARD;
  79             particle.fValue = getErrorWildcard();
  80             particle.fMinOccurs = 0;
  81             particle.fMaxOccurs = SchemaSymbols.OCCURRENCE_UNBOUNDED;
  82             XSModelGroupImpl group = new XSModelGroupImpl();
  83             group.fCompositor = XSModelGroupImpl.MODELGROUP_SEQUENCE;
  84             group.fParticleCount = 1;
  85             group.fParticles = new XSParticleDecl[1];
</pre>
<hr />
<pre>
 557             }
 558 
 559             // this only happens when restricting a mixed/emptiable CT
 560             // but there is no &lt;simpleType&gt;, which is required
 561             if (baseValidator == null) {
 562                 fAttrChecker.returnAttrArray(simpleContentAttrValues, schemaDoc);
 563                 fAttrChecker.returnAttrArray(derivationTypeAttrValues, schemaDoc);
 564                 throw new ComplexTypeRecoverableError(&quot;src-ct.2.2&quot;,
 565                         new Object[]{fName}, simpleContent);
 566             }
 567 
 568             // -----------------------------------------------------------------------
 569             // Traverse any facets
 570             // -----------------------------------------------------------------------
 571             Element attrNode = null;
 572             XSFacets facetData = null;
 573             short presentFacets = 0 ;
 574             short fixedFacets = 0 ;
 575 
 576             if (simpleContent!=null) {
<span class="line-modified"> 577                 FacetInfo fi = traverseFacets(simpleContent, fComplexTypeDecl, baseValidator, schemaDoc);</span>
 578                 attrNode = fi.nodeAfterFacets;
 579                 facetData = fi.facetdata;
 580                 presentFacets = fi.fPresentFacets;
 581                 fixedFacets = fi.fFixedFacets;
 582             }
 583 
 584             String name = genAnonTypeName(simpleContentElement);
 585             fXSSimpleType = fSchemaHandler.fDVFactory.createTypeRestriction(name,schemaDoc.fTargetNamespace,(short)0,baseValidator,null);
 586             try{
 587                 fValidationState.setNamespaceSupport(schemaDoc.fNamespaceSupport);
 588                 fXSSimpleType.applyFacets(facetData, presentFacets, fixedFacets, fValidationState);
 589             }catch(InvalidDatatypeFacetException ex){
 590                 reportSchemaError(ex.getKey(), ex.getArgs(), simpleContent);
 591                 // Recreate the type, ignoring the facets
 592                 fXSSimpleType = fSchemaHandler.fDVFactory.createTypeRestriction(name,schemaDoc.fTargetNamespace,(short)0,baseValidator,null);
 593             }
 594             if (fXSSimpleType instanceof XSSimpleTypeDecl) {
 595                 ((XSSimpleTypeDecl)fXSSimpleType).setAnonymous(true);
 596             }
 597 
</pre>
<hr />
<pre>
1176 
1177 
1178     private void handleComplexTypeError(String messageId,Object[] args,
1179             Element e) {
1180 
1181         if (messageId!=null) {
1182             reportSchemaError(messageId, args, e);
1183         }
1184 
1185         //
1186         //  Mock up the typeInfo structure so that there won&#39;t be problems during
1187         //  validation
1188         //
1189         fBaseType = SchemaGrammar.fAnyType;
1190         fContentType = XSComplexTypeDecl.CONTENTTYPE_MIXED;
1191         fXSSimpleType = null;
1192         fParticle = getErrorContent();
1193         // REVISIT: do we need to remove all attribute uses already added into
1194         // the attribute group? maybe it&#39;s ok to leave them there. -SG
1195         fAttrGrp.fAttributeWC = getErrorWildcard();



1196     }
1197 
1198     private void contentBackup() {
1199         if(fGlobalStore == null) {
1200             fGlobalStore = new Object [GLOBAL_NUM];
1201             fGlobalStorePos = 0;
1202         }
1203         if(fGlobalStorePos == fGlobalStore.length) {
1204             Object [] newArray = new Object[fGlobalStorePos+GLOBAL_NUM];
1205             System.arraycopy(fGlobalStore, 0, newArray, 0, fGlobalStorePos);
1206             fGlobalStore = newArray;
1207         }
1208         fGlobalStore[fGlobalStorePos++] = fComplexTypeDecl;
1209         fGlobalStore[fGlobalStorePos++] = fIsAbstract?Boolean.TRUE:Boolean.FALSE;
1210         fGlobalStore[fGlobalStorePos++] = fName ;
1211         fGlobalStore[fGlobalStorePos++] = fTargetNamespace;
1212         // let&#39;s save ourselves a couple of objects...
1213         fGlobalStore[fGlobalStorePos++] = (fDerivedBy &lt;&lt; 16) + fFinal;
1214         fGlobalStore[fGlobalStorePos++] = (fBlock &lt;&lt; 16) + fContentType;
1215         fGlobalStore[fGlobalStorePos++] = fBaseType;
</pre>
</td>
</tr>
</table>
<center><a href="XSDAbstractTraverser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../../index.html" target="_top">index</a> <a href="XSDHandler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
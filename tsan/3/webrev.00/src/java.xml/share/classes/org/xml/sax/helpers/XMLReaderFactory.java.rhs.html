<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/org/xml/sax/helpers/XMLReaderFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
<a name="2" id="anc2"></a>






 26 package org.xml.sax.helpers;
 27 
 28 import java.io.BufferedReader;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.InputStreamReader;
 32 import java.security.AccessController;
 33 import java.security.PrivilegedAction;
 34 import java.util.Iterator;
 35 import java.util.Objects;
 36 import java.util.ServiceConfigurationError;
 37 import java.util.ServiceLoader;
 38 import jdk.xml.internal.SecuritySupport;
 39 import org.xml.sax.SAXException;
 40 import org.xml.sax.XMLReader;
 41 
 42 
 43 /**
 44  * Factory for creating an XML reader.
 45  *
<a name="3" id="anc3"></a>






 46  * &lt;p&gt;This class contains static methods for creating an XML reader
 47  * from an explicit class name, or based on runtime defaults:
 48  *
 49  * &lt;pre&gt;
 50  * try {
 51  *   XMLReader myReader = XMLReaderFactory.createXMLReader();
 52  * } catch (SAXException e) {
 53  *   System.err.println(e.getMessage());
 54  * }
 55  * &lt;/pre&gt;
 56  *
 57  * &lt;p&gt;&lt;strong&gt;Note to Distributions bundled with parsers:&lt;/strong&gt;
 58  * You should modify the implementation of the no-arguments
 59  * &lt;em&gt;createXMLReader&lt;/em&gt; to handle cases where the external
 60  * configuration mechanisms aren&#39;t set up.  That method should do its
 61  * best to return a parser when one is in the class path, even when
 62  * nothing bound its class name to {@code org.xml.sax.driver} so
 63  * those configuration mechanisms would see it.
 64  *
 65  * @since 1.4, SAX 2.0
 66  * @author David Megginson, David Brownell
 67  * @version 2.0.1 (sax2r2)
 68  *
 69  * @deprecated It is recommended to use {@link javax.xml.parsers.SAXParserFactory}
 70  * instead.
 71  */
 72 @Deprecated(since=&quot;9&quot;)
 73 final public class XMLReaderFactory
 74 {
 75     /**
 76      * Private constructor.
 77      *
 78      * &lt;p&gt;This constructor prevents the class from being instantiated.
 79      */
 80     private XMLReaderFactory ()
 81     {
 82     }
 83 
 84     private static final String property = &quot;org.xml.sax.driver&quot;;
 85 
 86     /**
 87      * Obtains a new instance of a {@link org.xml.sax.XMLReader}.
 88      * This method uses the following ordered lookup procedure to find and load
 89      * the {@link org.xml.sax.XMLReader} implementation class:
 90      * &lt;ol&gt;
 91      * &lt;li&gt;If the system property {@code org.xml.sax.driver}
 92      * has a value, that is used as an XMLReader class name. &lt;/li&gt;
 93      * &lt;li&gt;
 94      * Use the service-provider loading facility, defined by the
 95      * {@link java.util.ServiceLoader} class, to attempt to locate and load an
 96      * implementation of the service {@link org.xml.sax.XMLReader} by using the
 97      * {@linkplain java.lang.Thread#getContextClassLoader() current thread&#39;s context class loader}.
 98      * If the context class loader is null, the
 99      * {@linkplain ClassLoader#getSystemClassLoader() system class loader} will
100      * be used.
101      * &lt;/li&gt;
102      * &lt;li&gt;
103      * Deprecated. Look for a class name in the {@code META-INF/services/org.xml.sax.driver}
104      * file in a jar file available to the runtime.&lt;/li&gt;
105      * &lt;li&gt;
106      * &lt;p&gt;
107      * Otherwise, the system-default implementation is returned.
108      * &lt;/li&gt;
109      * &lt;/ol&gt;
110      *
111      * @apiNote
112      * The process that looks for a class name in the
113      * {@code META-INF/services/org.xml.sax.driver} file in a jar file does not
114      * conform to the specification of the service-provider loading facility
115      * as defined in {@link java.util.ServiceLoader} and therefore does not
116      * support modularization. It is deprecated as of Java SE 9 and subject to
117      * removal in a future release.
118      *
119      * @return a new XMLReader.
120      * @exception org.xml.sax.SAXException If no default XMLReader class
121      *            can be identified and instantiated.
122      * @see #createXMLReader(java.lang.String)
123      */
124     public static XMLReader createXMLReader ()
125         throws SAXException
126     {
127         String          className = null;
128         ClassLoader     cl = SecuritySupport.getClassLoader();
129 
130         // 1. try the JVM-instance-wide system property
131         try {
132             className = SecuritySupport.getSystemProperty(property);
133         }
134         catch (RuntimeException e) { /* continue searching */ }
135 
136         // 2. try the ServiceLoader
137         if (className == null) {
138             final XMLReader provider = findServiceProvider(XMLReader.class, cl);
139             if (provider != null) {
140                 return provider;
141             }
142         }
143 
144         // 3. try META-INF/services/org.xml.sax.driver. This old process allows
145         // legacy providers to be found
146         if (className == null) {
147             className = jarLookup(cl);
148         }
149 
150         // 4. Distro-specific fallback
151         if (className == null) {
152             return new com.sun.org.apache.xerces.internal.parsers.SAXParser();
153         }
154 
155         return loadClass (cl, className);
156     }
157 
158 
159     /**
160      * Attempt to create an XML reader from a class name.
161      *
162      * &lt;p&gt;Given a class name, this method attempts to load
163      * and instantiate the class as an XML reader.
164      *
165      * &lt;p&gt;Note that this method will not be usable in environments where
166      * the caller (perhaps an applet) is not permitted to load classes
167      * dynamically.
168      *
169      * @return A new XML reader.
170      * @exception org.xml.sax.SAXException If the class cannot be
171      *            loaded, instantiated, and cast to XMLReader.
172      * @see #createXMLReader()
173      */
174     public static XMLReader createXMLReader (String className)
175         throws SAXException
176     {
177         return loadClass (SecuritySupport.getClassLoader(), className);
178     }
179 
180     private static XMLReader loadClass (ClassLoader loader, String className)
181     throws SAXException
182     {
183         try {
184             return NewInstance.newInstance (XMLReader.class, loader, className);
185         } catch (ClassNotFoundException e1) {
186             throw new SAXException(&quot;SAX2 driver class &quot; + className +
187                                    &quot; not found&quot;, e1);
188         } catch (IllegalAccessException e2) {
189             throw new SAXException(&quot;SAX2 driver class &quot; + className +
190                                    &quot; found but cannot be loaded&quot;, e2);
191         } catch (InstantiationException e3) {
192             throw new SAXException(&quot;SAX2 driver class &quot; + className +
193            &quot; loaded but cannot be instantiated (no empty public constructor?)&quot;,
194                                    e3);
195         } catch (ClassCastException e4) {
196             throw new SAXException(&quot;SAX2 driver class &quot; + className +
197                                    &quot; does not implement XMLReader&quot;, e4);
198         }
199     }
200 
201     /**
202      * Locates a provider by directly reading the jar service file.
203      * @param loader the ClassLoader to be used to read the service file
204      * @return the name of the provider, or null if nothing is found
205      */
206     private static String jarLookup(final ClassLoader loader) {
207         final ClassLoader cl = Objects.requireNonNull(loader);
208         String clsFromJar = null;
209         String service = &quot;META-INF/services/&quot; + property;
210         InputStream in;
211         BufferedReader      reader;
212 
213         try {
214             in = SecuritySupport.getResourceAsStream(cl, service);
215 
216             // If no provider found then try the current ClassLoader
217             if (in == null) {
218                 in = SecuritySupport.getResourceAsStream(null, service);
219             }
220 
221             if (in != null) {
222                 reader = new BufferedReader (new InputStreamReader (in, &quot;UTF8&quot;));
223                 clsFromJar = reader.readLine ();
224                 in.close ();
225             }
226         } catch (IOException e) {
227         }
228         return clsFromJar;
229     }
230 
231     /*
232      * Try to find provider using the ServiceLoader API
233      *
234      * @param type Base class / Service interface of the factory to find.
235      *
236      * @return instance of provider class if found or null
237      */
238     private static &lt;T&gt; T findServiceProvider(final Class&lt;T&gt; type, final ClassLoader loader)
239             throws SAXException {
240         ClassLoader cl = Objects.requireNonNull(loader);
241         try {
242             return AccessController.doPrivileged((PrivilegedAction&lt;T&gt;) () -&gt; {
243                 final ServiceLoader&lt;T&gt; serviceLoader;
244                 serviceLoader = ServiceLoader.load(type, cl);
245                 final Iterator&lt;T&gt; iterator = serviceLoader.iterator();
246                 if (iterator.hasNext()) {
247                     return iterator.next();
248                 } else {
249                     return null;
250                 }
251             });
252         } catch(ServiceConfigurationError e) {
253             final RuntimeException x = new RuntimeException(
254                     &quot;Provider for &quot; + type + &quot; cannot be created&quot;, e);
255             throw new SAXException(&quot;Provider for &quot; + type + &quot; cannot be created&quot;, x);
256 
257           }
258       }
259 
260 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
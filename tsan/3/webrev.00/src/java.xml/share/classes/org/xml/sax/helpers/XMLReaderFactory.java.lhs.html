<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.xml/share/classes/org/xml/sax/helpers/XMLReaderFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
<a name="2" id="anc2"></a><span class="line-removed"> 26 // XMLReaderFactory.java - factory for creating a new reader.</span>
<span class="line-removed"> 27 // http://www.saxproject.org</span>
<span class="line-removed"> 28 // Written by David Megginson</span>
<span class="line-removed"> 29 // and by David Brownell</span>
<span class="line-removed"> 30 // NO WARRANTY!  This class is in the Public Domain.</span>
<span class="line-removed"> 31 // $Id: XMLReaderFactory.java,v 1.2.2.1 2005/07/31 22:48:08 jeffsuttor Exp $</span>
<span class="line-removed"> 32 </span>
 33 package org.xml.sax.helpers;
 34 
 35 import java.io.BufferedReader;
 36 import java.io.IOException;
 37 import java.io.InputStream;
 38 import java.io.InputStreamReader;
 39 import java.security.AccessController;
 40 import java.security.PrivilegedAction;
 41 import java.util.Iterator;
 42 import java.util.Objects;
 43 import java.util.ServiceConfigurationError;
 44 import java.util.ServiceLoader;
 45 import jdk.xml.internal.SecuritySupport;
 46 import org.xml.sax.SAXException;
 47 import org.xml.sax.XMLReader;
 48 
 49 
 50 /**
 51  * Factory for creating an XML reader.
 52  *
<a name="3" id="anc3"></a><span class="line-removed"> 53  * &lt;blockquote&gt;</span>
<span class="line-removed"> 54  * &lt;em&gt;This module, both source code and documentation, is in the</span>
<span class="line-removed"> 55  * Public Domain, and comes with &lt;strong&gt;NO WARRANTY&lt;/strong&gt;.&lt;/em&gt;</span>
<span class="line-removed"> 56  * See &lt;a href=&#39;http://www.saxproject.org&#39;&gt;http://www.saxproject.org&lt;/a&gt;</span>
<span class="line-removed"> 57  * for further information.</span>
<span class="line-removed"> 58  * &lt;/blockquote&gt;</span>
<span class="line-removed"> 59  *</span>
 60  * &lt;p&gt;This class contains static methods for creating an XML reader
 61  * from an explicit class name, or based on runtime defaults:
 62  *
 63  * &lt;pre&gt;
 64  * try {
 65  *   XMLReader myReader = XMLReaderFactory.createXMLReader();
 66  * } catch (SAXException e) {
 67  *   System.err.println(e.getMessage());
 68  * }
 69  * &lt;/pre&gt;
 70  *
 71  * &lt;p&gt;&lt;strong&gt;Note to Distributions bundled with parsers:&lt;/strong&gt;
 72  * You should modify the implementation of the no-arguments
 73  * &lt;em&gt;createXMLReader&lt;/em&gt; to handle cases where the external
 74  * configuration mechanisms aren&#39;t set up.  That method should do its
 75  * best to return a parser when one is in the class path, even when
 76  * nothing bound its class name to {@code org.xml.sax.driver} so
 77  * those configuration mechanisms would see it.
 78  *
 79  * @since 1.4, SAX 2.0
 80  * @author David Megginson, David Brownell
 81  * @version 2.0.1 (sax2r2)
 82  *
 83  * @deprecated It is recommended to use {@link javax.xml.parsers.SAXParserFactory}
 84  * instead.
 85  */
 86 @Deprecated(since=&quot;9&quot;)
 87 final public class XMLReaderFactory
 88 {
 89     /**
 90      * Private constructor.
 91      *
 92      * &lt;p&gt;This constructor prevents the class from being instantiated.
 93      */
 94     private XMLReaderFactory ()
 95     {
 96     }
 97 
 98     private static final String property = &quot;org.xml.sax.driver&quot;;
 99 
100     /**
101      * Obtains a new instance of a {@link org.xml.sax.XMLReader}.
102      * This method uses the following ordered lookup procedure to find and load
103      * the {@link org.xml.sax.XMLReader} implementation class:
104      * &lt;ol&gt;
105      * &lt;li&gt;If the system property {@code org.xml.sax.driver}
106      * has a value, that is used as an XMLReader class name. &lt;/li&gt;
107      * &lt;li&gt;
108      * Use the service-provider loading facility, defined by the
109      * {@link java.util.ServiceLoader} class, to attempt to locate and load an
110      * implementation of the service {@link org.xml.sax.XMLReader} by using the
111      * {@linkplain java.lang.Thread#getContextClassLoader() current thread&#39;s context class loader}.
112      * If the context class loader is null, the
113      * {@linkplain ClassLoader#getSystemClassLoader() system class loader} will
114      * be used.
115      * &lt;/li&gt;
116      * &lt;li&gt;
117      * Deprecated. Look for a class name in the {@code META-INF/services/org.xml.sax.driver}
118      * file in a jar file available to the runtime.&lt;/li&gt;
119      * &lt;li&gt;
120      * &lt;p&gt;
121      * Otherwise, the system-default implementation is returned.
122      * &lt;/li&gt;
123      * &lt;/ol&gt;
124      *
125      * @apiNote
126      * The process that looks for a class name in the
127      * {@code META-INF/services/org.xml.sax.driver} file in a jar file does not
128      * conform to the specification of the service-provider loading facility
129      * as defined in {@link java.util.ServiceLoader} and therefore does not
130      * support modularization. It is deprecated as of Java SE 9 and subject to
131      * removal in a future release.
132      *
133      * @return a new XMLReader.
134      * @exception org.xml.sax.SAXException If no default XMLReader class
135      *            can be identified and instantiated.
136      * @see #createXMLReader(java.lang.String)
137      */
138     public static XMLReader createXMLReader ()
139         throws SAXException
140     {
141         String          className = null;
142         ClassLoader     cl = SecuritySupport.getClassLoader();
143 
144         // 1. try the JVM-instance-wide system property
145         try {
146             className = SecuritySupport.getSystemProperty(property);
147         }
148         catch (RuntimeException e) { /* continue searching */ }
149 
150         // 2. try the ServiceLoader
151         if (className == null) {
152             final XMLReader provider = findServiceProvider(XMLReader.class, cl);
153             if (provider != null) {
154                 return provider;
155             }
156         }
157 
158         // 3. try META-INF/services/org.xml.sax.driver. This old process allows
159         // legacy providers to be found
160         if (className == null) {
161             className = jarLookup(cl);
162         }
163 
164         // 4. Distro-specific fallback
165         if (className == null) {
166             return new com.sun.org.apache.xerces.internal.parsers.SAXParser();
167         }
168 
169         return loadClass (cl, className);
170     }
171 
172 
173     /**
174      * Attempt to create an XML reader from a class name.
175      *
176      * &lt;p&gt;Given a class name, this method attempts to load
177      * and instantiate the class as an XML reader.
178      *
179      * &lt;p&gt;Note that this method will not be usable in environments where
180      * the caller (perhaps an applet) is not permitted to load classes
181      * dynamically.
182      *
183      * @return A new XML reader.
184      * @exception org.xml.sax.SAXException If the class cannot be
185      *            loaded, instantiated, and cast to XMLReader.
186      * @see #createXMLReader()
187      */
188     public static XMLReader createXMLReader (String className)
189         throws SAXException
190     {
191         return loadClass (SecuritySupport.getClassLoader(), className);
192     }
193 
194     private static XMLReader loadClass (ClassLoader loader, String className)
195     throws SAXException
196     {
197         try {
198             return NewInstance.newInstance (XMLReader.class, loader, className);
199         } catch (ClassNotFoundException e1) {
200             throw new SAXException(&quot;SAX2 driver class &quot; + className +
201                                    &quot; not found&quot;, e1);
202         } catch (IllegalAccessException e2) {
203             throw new SAXException(&quot;SAX2 driver class &quot; + className +
204                                    &quot; found but cannot be loaded&quot;, e2);
205         } catch (InstantiationException e3) {
206             throw new SAXException(&quot;SAX2 driver class &quot; + className +
207            &quot; loaded but cannot be instantiated (no empty public constructor?)&quot;,
208                                    e3);
209         } catch (ClassCastException e4) {
210             throw new SAXException(&quot;SAX2 driver class &quot; + className +
211                                    &quot; does not implement XMLReader&quot;, e4);
212         }
213     }
214 
215     /**
216      * Locates a provider by directly reading the jar service file.
217      * @param loader the ClassLoader to be used to read the service file
218      * @return the name of the provider, or null if nothing is found
219      */
220     private static String jarLookup(final ClassLoader loader) {
221         final ClassLoader cl = Objects.requireNonNull(loader);
222         String clsFromJar = null;
223         String service = &quot;META-INF/services/&quot; + property;
224         InputStream in;
225         BufferedReader      reader;
226 
227         try {
228             in = SecuritySupport.getResourceAsStream(cl, service);
229 
230             // If no provider found then try the current ClassLoader
231             if (in == null) {
232                 in = SecuritySupport.getResourceAsStream(null, service);
233             }
234 
235             if (in != null) {
236                 reader = new BufferedReader (new InputStreamReader (in, &quot;UTF8&quot;));
237                 clsFromJar = reader.readLine ();
238                 in.close ();
239             }
240         } catch (IOException e) {
241         }
242         return clsFromJar;
243     }
244 
245     /*
246      * Try to find provider using the ServiceLoader API
247      *
248      * @param type Base class / Service interface of the factory to find.
249      *
250      * @return instance of provider class if found or null
251      */
252     private static &lt;T&gt; T findServiceProvider(final Class&lt;T&gt; type, final ClassLoader loader)
253             throws SAXException {
254         ClassLoader cl = Objects.requireNonNull(loader);
255         try {
256             return AccessController.doPrivileged((PrivilegedAction&lt;T&gt;) () -&gt; {
257                 final ServiceLoader&lt;T&gt; serviceLoader;
258                 serviceLoader = ServiceLoader.load(type, cl);
259                 final Iterator&lt;T&gt; iterator = serviceLoader.iterator();
260                 if (iterator.hasNext()) {
261                     return iterator.next();
262                 } else {
263                     return null;
264                 }
265             });
266         } catch(ServiceConfigurationError e) {
267             final RuntimeException x = new RuntimeException(
268                     &quot;Provider for &quot; + type + &quot; cannot be created&quot;, e);
269             throw new SAXException(&quot;Provider for &quot; + type + &quot; cannot be created&quot;, x);
270 
271           }
272       }
273 
274 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.xml/share/classes/org/xml/sax/helpers/NamespaceSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package org.xml.sax.helpers;
 27 
 28 import java.util.ArrayList;
 29 import java.util.Collections;
 30 import java.util.EmptyStackException;
 31 import java.util.Enumeration;
 32 import java.util.HashMap;
 33 import java.util.List;
 34 import java.util.Map;
 35 
 36 
 37 /**
 38  * Encapsulate Namespace logic for use by applications using SAX,
 39  * or internally by SAX drivers.
 40  *
 41  * &lt;p&gt;This class encapsulates the logic of Namespace processing: it
 42  * tracks the declarations currently in force for each context and
 43  * automatically processes qualified XML names into their Namespace
 44  * parts; it can also be used in reverse for generating XML qnames
 45  * from Namespaces.&lt;/p&gt;
 46  *
 47  * &lt;p&gt;Namespace support objects are reusable, but the reset method
 48  * must be invoked between each session.&lt;/p&gt;
 49  *
 50  * &lt;p&gt;Here is a simple session:&lt;/p&gt;
 51  *
 52  * &lt;pre&gt;
 53  * String parts[] = new String[3];
 54  * NamespaceSupport support = new NamespaceSupport();
 55  *
 56  * support.pushContext();
 57  * support.declarePrefix(&quot;&quot;, &quot;http://www.w3.org/1999/xhtml&quot;);
 58  * support.declarePrefix(&quot;dc&quot;, &quot;http://www.purl.org/dc#&quot;);
 59  *
 60  * parts = support.processName(&quot;p&quot;, parts, false);
 61  * System.out.println(&quot;Namespace URI: &quot; + parts[0]);
 62  * System.out.println(&quot;Local name: &quot; + parts[1]);
 63  * System.out.println(&quot;Raw name: &quot; + parts[2]);
 64  *
 65  * parts = support.processName(&quot;dc:title&quot;, parts, false);
 66  * System.out.println(&quot;Namespace URI: &quot; + parts[0]);
 67  * System.out.println(&quot;Local name: &quot; + parts[1]);
 68  * System.out.println(&quot;Raw name: &quot; + parts[2]);
 69  *
 70  * support.popContext();
 71  * &lt;/pre&gt;
 72  *
 73  * &lt;p&gt;Note that this class is optimized for the use case where most
 74  * elements do not contain Namespace declarations: if the same
 75  * prefix/URI mapping is repeated for each context (for example), this
 76  * class will be somewhat less efficient.&lt;/p&gt;
 77  *
 78  * &lt;p&gt;Although SAX drivers (parsers) may choose to use this class to
 79  * implement namespace handling, they are not required to do so.
 80  * Applications must track namespace information themselves if they
 81  * want to use namespace information.
 82  *
 83  * @since 1.4, SAX 2.0
 84  * @author David Megginson
 85  */
 86 public class NamespaceSupport
 87 {
 88 
 89 
 90     ////////////////////////////////////////////////////////////////////
 91     // Constants.
 92     ////////////////////////////////////////////////////////////////////
 93 
 94 
 95     /**
 96      * The XML Namespace URI as a constant.
 97      * The value is &lt;code&gt;http://www.w3.org/XML/1998/namespace&lt;/code&gt;
 98      * as defined in the &quot;Namespaces in XML&quot; * recommendation.
 99      *
100      * &lt;p&gt;This is the Namespace URI that is automatically mapped
101      * to the &quot;xml&quot; prefix.&lt;/p&gt;
102      */
103     public final static String XMLNS =
104         &quot;http://www.w3.org/XML/1998/namespace&quot;;
105 
106 
107     /**
108      * The namespace declaration URI as a constant.
109      * The value is &lt;code&gt;http://www.w3.org/xmlns/2000/&lt;/code&gt;, as defined
110      * in a backwards-incompatible erratum to the &quot;Namespaces in XML&quot;
111      * recommendation.  Because that erratum postdated SAX2, SAX2 defaults
112      * to the original recommendation, and does not normally use this URI.
113      *
114      *
115      * &lt;p&gt;This is the Namespace URI that is optionally applied to
116      * &lt;em&gt;xmlns&lt;/em&gt; and &lt;em&gt;xmlns:*&lt;/em&gt; attributes, which are used to
117      * declare namespaces.  &lt;/p&gt;
118      *
119      * @since 1.5, SAX 2.1alpha
120      * @see #setNamespaceDeclUris
121      * @see #isNamespaceDeclUris
122      */
123     public final static String NSDECL =
124         &quot;http://www.w3.org/xmlns/2000/&quot;;
125 
126 
127     /**
128      * An empty enumeration.
129      */
130     private final static Enumeration&lt;String&gt; EMPTY_ENUMERATION =
131             Collections.enumeration(new ArrayList&lt;String&gt;());
132 
133 
134     ////////////////////////////////////////////////////////////////////
135     // Constructor.
136     ////////////////////////////////////////////////////////////////////
137 
138 
139     /**
140      * Create a new Namespace support object.
141      */
142     public NamespaceSupport ()
143     {
144         reset();
145     }
146 
147 
148 
149     ////////////////////////////////////////////////////////////////////
150     // Context management.
151     ////////////////////////////////////////////////////////////////////
152 
153 
154     /**
155      * Reset this Namespace support object for reuse.
156      *
157      * &lt;p&gt;It is necessary to invoke this method before reusing the
158      * Namespace support object for a new session.  If namespace
159      * declaration URIs are to be supported, that flag must also
160      * be set to a non-default value.
161      * &lt;/p&gt;
162      *
163      * @see #setNamespaceDeclUris
164      */
165     public void reset ()
166     {
167         contexts = new Context[32];
168         namespaceDeclUris = false;
169         contextPos = 0;
170         contexts[contextPos] = currentContext = new Context();
171         currentContext.declarePrefix(&quot;xml&quot;, XMLNS);
172     }
173 
174 
175     /**
176      * Start a new Namespace context.
177      * The new context will automatically inherit
178      * the declarations of its parent context, but it will also keep
179      * track of which declarations were made within this context.
180      *
181      * &lt;p&gt;Event callback code should start a new context once per element.
182      * This means being ready to call this in either of two places.
183      * For elements that don&#39;t include namespace declarations, the
184      * &lt;em&gt;ContentHandler.startElement()&lt;/em&gt; callback is the right place.
185      * For elements with such a declaration, it&#39;d done in the first
186      * &lt;em&gt;ContentHandler.startPrefixMapping()&lt;/em&gt; callback.
187      * A boolean flag can be used to
188      * track whether a context has been started yet.  When either of
189      * those methods is called, it checks the flag to see if a new context
190      * needs to be started.  If so, it starts the context and sets the
191      * flag.  After &lt;em&gt;ContentHandler.startElement()&lt;/em&gt;
192      * does that, it always clears the flag.
193      *
194      * &lt;p&gt;Normally, SAX drivers would push a new context at the beginning
195      * of each XML element.  Then they perform a first pass over the
196      * attributes to process all namespace declarations, making
197      * &lt;em&gt;ContentHandler.startPrefixMapping()&lt;/em&gt; callbacks.
198      * Then a second pass is made, to determine the namespace-qualified
199      * names for all attributes and for the element name.
200      * Finally all the information for the
201      * &lt;em&gt;ContentHandler.startElement()&lt;/em&gt; callback is available,
202      * so it can then be made.
203      *
204      * &lt;p&gt;The Namespace support object always starts with a base context
205      * already in force: in this context, only the &quot;xml&quot; prefix is
206      * declared.&lt;/p&gt;
207      *
208      * @see org.xml.sax.ContentHandler
209      * @see #popContext
210      */
211     public void pushContext ()
212     {
213         int max = contexts.length;
214 
215         contextPos++;
216 
217                                 // Extend the array if necessary
218         if (contextPos &gt;= max) {
219             Context newContexts[] = new Context[max*2];
220             System.arraycopy(contexts, 0, newContexts, 0, max);
221             max *= 2;
222             contexts = newContexts;
223         }
224 
225                                 // Allocate the context if necessary.
226         currentContext = contexts[contextPos];
227         if (currentContext == null) {
228             contexts[contextPos] = currentContext = new Context();
229         }
230 
231                                 // Set the parent, if any.
232         if (contextPos &gt; 0) {
233             currentContext.setParent(contexts[contextPos - 1]);
234         }
235     }
236 
237 
238     /**
239      * Revert to the previous Namespace context.
240      *
241      * &lt;p&gt;Normally, you should pop the context at the end of each
242      * XML element.  After popping the context, all Namespace prefix
243      * mappings that were previously in force are restored.&lt;/p&gt;
244      *
245      * &lt;p&gt;You must not attempt to declare additional Namespace
246      * prefixes after popping a context, unless you push another
247      * context first.&lt;/p&gt;
248      *
249      * @see #pushContext
250      */
251     public void popContext ()
252     {
253         contexts[contextPos].clear();
254         contextPos--;
255         if (contextPos &lt; 0) {
256             throw new EmptyStackException();
257         }
258         currentContext = contexts[contextPos];
259     }
260 
261 
262 
263     ////////////////////////////////////////////////////////////////////
264     // Operations within a context.
265     ////////////////////////////////////////////////////////////////////
266 
267 
268     /**
269      * Declare a Namespace prefix.  All prefixes must be declared
270      * before they are referenced.  For example, a SAX driver (parser)
271      * would scan an element&#39;s attributes
272      * in two passes:  first for namespace declarations,
273      * then a second pass using {@link #processName processName()} to
274      * interpret prefixes against (potentially redefined) prefixes.
275      *
276      * &lt;p&gt;This method declares a prefix in the current Namespace
277      * context; the prefix will remain in force until this context
278      * is popped, unless it is shadowed in a descendant context.&lt;/p&gt;
279      *
280      * &lt;p&gt;To declare the default element Namespace, use the empty string as
281      * the prefix.&lt;/p&gt;
282      *
283      * &lt;p&gt;Note that there is an asymmetry in this library: {@link
284      * #getPrefix getPrefix} will not return the &quot;&quot; prefix,
285      * even if you have declared a default element namespace.
286      * To check for a default namespace,
287      * you have to look it up explicitly using {@link #getURI getURI}.
288      * This asymmetry exists to make it easier to look up prefixes
289      * for attribute names, where the default prefix is not allowed.&lt;/p&gt;
290      *
291      * @param prefix The prefix to declare, or the empty string to
292      *  indicate the default element namespace.  This may never have
293      *  the value &quot;xml&quot; or &quot;xmlns&quot;.
294      * @param uri The Namespace URI to associate with the prefix.
295      * @return true if the prefix was legal, false otherwise
296      *
297      * @see #processName
298      * @see #getURI
299      * @see #getPrefix
300      */
301     public boolean declarePrefix (String prefix, String uri)
302     {
303         if (prefix.equals(&quot;xml&quot;) || prefix.equals(&quot;xmlns&quot;)) {
304             return false;
305         } else {
306             currentContext.declarePrefix(prefix, uri);
307             return true;
308         }
309     }
310 
311 
312     /**
313      * Process a raw XML qualified name, after all declarations in the
314      * current context have been handled by {@link #declarePrefix
315      * declarePrefix()}.
316      *
317      * &lt;p&gt;This method processes a raw XML qualified name in the
318      * current context by removing the prefix and looking it up among
319      * the prefixes currently declared.  The return value will be the
320      * array supplied by the caller, filled in as follows:&lt;/p&gt;
321      *
322      * &lt;dl&gt;
323      * &lt;dt&gt;parts[0]&lt;/dt&gt;
324      * &lt;dd&gt;The Namespace URI, or an empty string if none is
325      *  in use.&lt;/dd&gt;
326      * &lt;dt&gt;parts[1]&lt;/dt&gt;
327      * &lt;dd&gt;The local name (without prefix).&lt;/dd&gt;
328      * &lt;dt&gt;parts[2]&lt;/dt&gt;
329      * &lt;dd&gt;The original raw name.&lt;/dd&gt;
330      * &lt;/dl&gt;
331      *
332      * &lt;p&gt;All of the strings in the array will be internalized.  If
333      * the raw name has a prefix that has not been declared, then
334      * the return value will be null.&lt;/p&gt;
335      *
336      * &lt;p&gt;Note that attribute names are processed differently than
337      * element names: an unprefixed element name will receive the
338      * default Namespace (if any), while an unprefixed attribute name
339      * will not.&lt;/p&gt;
340      *
341      * @param qName The XML qualified name to be processed.
342      * @param parts An array supplied by the caller, capable of
343      *        holding at least three members.
344      * @param isAttribute A flag indicating whether this is an
345      *        attribute name (true) or an element name (false).
346      * @return The supplied array holding three internalized strings
347      *        representing the Namespace URI (or empty string), the
348      *        local name, and the XML qualified name; or null if there
349      *        is an undeclared prefix.
350      * @see #declarePrefix
351      * @see java.lang.String#intern */
352     public String [] processName (String qName, String parts[],
353                                   boolean isAttribute)
354     {
355         String myParts[] = currentContext.processName(qName, isAttribute);
356         if (myParts == null) {
357             return null;
358         } else {
359             parts[0] = myParts[0];
360             parts[1] = myParts[1];
361             parts[2] = myParts[2];
362             return parts;
363         }
364     }
365 
366 
367     /**
368      * Look up a prefix and get the currently-mapped Namespace URI.
369      *
370      * &lt;p&gt;This method looks up the prefix in the current context.
371      * Use the empty string (&quot;&quot;) for the default Namespace.&lt;/p&gt;
372      *
373      * @param prefix The prefix to look up.
374      * @return The associated Namespace URI, or null if the prefix
375      *         is undeclared in this context.
376      * @see #getPrefix
377      * @see #getPrefixes
378      */
379     public String getURI (String prefix)
380     {
381         return currentContext.getURI(prefix);
382     }
383 
384 
385     /**
386      * Return an enumeration of all prefixes whose declarations are
387      * active in the current context.
388      * This includes declarations from parent contexts that have
389      * not been overridden.
390      *
391      * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; if there is a default prefix, it will not be
392      * returned in this enumeration; check for the default prefix
393      * using the {@link #getURI getURI} with an argument of &quot;&quot;.&lt;/p&gt;
394      *
395      * @return An enumeration of prefixes (never empty).
396      * @see #getDeclaredPrefixes
397      * @see #getURI
398      */
399     public Enumeration&lt;String&gt; getPrefixes ()
400     {
401         return currentContext.getPrefixes();
402     }
403 
404 
405     /**
406      * Return one of the prefixes mapped to a Namespace URI.
407      *
408      * &lt;p&gt;If more than one prefix is currently mapped to the same
409      * URI, this method will make an arbitrary selection; if you
410      * want all of the prefixes, use the {@link #getPrefixes}
411      * method instead.&lt;/p&gt;
412      *
413      * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; this will never return the empty (default) prefix;
414      * to check for a default prefix, use the {@link #getURI getURI}
415      * method with an argument of &quot;&quot;.&lt;/p&gt;
416      *
417      * @param uri the namespace URI
418      * @return one of the prefixes currently mapped to the URI supplied,
419      *         or null if none is mapped or if the URI is assigned to
420      *         the default namespace
421      * @see #getPrefixes(java.lang.String)
422      * @see #getURI
423      */
424     public String getPrefix (String uri)
425     {
426         return currentContext.getPrefix(uri);
427     }
428 
429 
430     /**
431      * Return an enumeration of all prefixes for a given URI whose
432      * declarations are active in the current context.
433      * This includes declarations from parent contexts that have
434      * not been overridden.
435      *
436      * &lt;p&gt;This method returns prefixes mapped to a specific Namespace
437      * URI.  The xml: prefix will be included.  If you want only one
438      * prefix that&#39;s mapped to the Namespace URI, and you don&#39;t care
439      * which one you get, use the {@link #getPrefix getPrefix}
440      *  method instead.&lt;/p&gt;
441      *
442      * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the empty (default) prefix is &lt;em&gt;never&lt;/em&gt; included
443      * in this enumeration; to check for the presence of a default
444      * Namespace, use the {@link #getURI getURI} method with an
445      * argument of &quot;&quot;.&lt;/p&gt;
446      *
447      * @param uri The Namespace URI.
448      * @return An enumeration of prefixes (never empty).
449      * @see #getPrefix
450      * @see #getDeclaredPrefixes
451      * @see #getURI
452      */
453     public Enumeration&lt;String&gt; getPrefixes (String uri)
454     {
455         List&lt;String&gt; prefixes = new ArrayList&lt;&gt;();
456         Enumeration&lt;String&gt; allPrefixes = getPrefixes();
457         while (allPrefixes.hasMoreElements()) {
458             String prefix = allPrefixes.nextElement();
459             if (uri.equals(getURI(prefix))) {
460                 prefixes.add(prefix);
461             }
462         }
463         return Collections.enumeration(prefixes);
464     }
465 
466 
467     /**
468      * Return an enumeration of all prefixes declared in this context.
469      *
470      * &lt;p&gt;The empty (default) prefix will be included in this
471      * enumeration; note that this behaviour differs from that of
472      * {@link #getPrefix} and {@link #getPrefixes}.&lt;/p&gt;
473      *
474      * @return An enumeration of all prefixes declared in this
475      *         context.
476      * @see #getPrefixes
477      * @see #getURI
478      */
479     public Enumeration&lt;String&gt; getDeclaredPrefixes ()
480     {
481         return currentContext.getDeclaredPrefixes();
482     }
483 
484     /**
485      * Controls whether namespace declaration attributes are placed
486      * into the {@link #NSDECL NSDECL} namespace
487      * by {@link #processName processName()}.  This may only be
488      * changed before any contexts have been pushed.
489      *
490      * @since 1.5, SAX 2.1alpha
491      *
492      * @exception IllegalStateException when attempting to set this
493      *  after any context has been pushed.
494      */
495     public void setNamespaceDeclUris (boolean value)
496     {
497         if (contextPos != 0)
498             throw new IllegalStateException ();
499         if (value == namespaceDeclUris)
500             return;
501         namespaceDeclUris = value;
502         if (value)
503             currentContext.declarePrefix (&quot;xmlns&quot;, NSDECL);
504         else {
505             contexts[contextPos] = currentContext = new Context();
506             currentContext.declarePrefix(&quot;xml&quot;, XMLNS);
507         }
508     }
509 
510     /**
511      * Returns true if namespace declaration attributes are placed into
512      * a namespace.  This behavior is not the default.
513      *
514      * @since 1.5, SAX 2.1alpha
515      */
516     public boolean isNamespaceDeclUris ()
517         { return namespaceDeclUris; }
518 
519 
520 
521     ////////////////////////////////////////////////////////////////////
522     // Internal state.
523     ////////////////////////////////////////////////////////////////////
524 
525     private Context contexts[];
526     private Context currentContext;
527     private int contextPos;
528     private boolean namespaceDeclUris;
529 
530 
531     ////////////////////////////////////////////////////////////////////
532     // Internal classes.
533     ////////////////////////////////////////////////////////////////////
534 
535     /**
536      * Internal class for a single Namespace context.
537      *
538      * &lt;p&gt;This module caches and reuses Namespace contexts,
539      * so the number allocated
540      * will be equal to the element depth of the document, not to the total
541      * number of elements (i.e. 5-10 rather than tens of thousands).
542      * Also, data structures used to represent contexts are shared when
543      * possible (child contexts without declarations) to further reduce
544      * the amount of memory that&#39;s consumed.
545      * &lt;/p&gt;
546      */
547     final class Context {
548 
549         /**
550          * Create the root-level Namespace context.
551          */
552         Context ()
553         {
554             copyTables();
555         }
556 
557 
558         /**
559          * (Re)set the parent of this Namespace context.
560          * The context must either have been freshly constructed,
561          * or must have been cleared.
562          *
563          * @param context The parent Namespace context object.
564          */
565         void setParent (Context parent)
566         {
567             this.parent = parent;
568             declarations = null;
569             prefixTable = parent.prefixTable;
570             uriTable = parent.uriTable;
571             elementNameTable = parent.elementNameTable;
572             attributeNameTable = parent.attributeNameTable;
573             defaultNS = parent.defaultNS;
574             declSeen = false;
575         }
576 
577         /**
578          * Makes associated state become collectible,
579          * invalidating this context.
580          * {@link #setParent} must be called before
581          * this context may be used again.
582          */
583         void clear ()
584         {
585             parent = null;
586             prefixTable = null;
587             uriTable = null;
588             elementNameTable = null;
589             attributeNameTable = null;
590             defaultNS = null;
591         }
592 
593 
594         /**
595          * Declare a Namespace prefix for this context.
596          *
597          * @param prefix The prefix to declare.
598          * @param uri The associated Namespace URI.
599          * @see org.xml.sax.helpers.NamespaceSupport#declarePrefix
600          */
601         void declarePrefix (String prefix, String uri)
602         {
603                                 // Lazy processing...
604 //          if (!declsOK)
605 //              throw new IllegalStateException (
606 //                  &quot;can&#39;t declare any more prefixes in this context&quot;);
607             if (!declSeen) {
608                 copyTables();
609             }
610             if (declarations == null) {
611                 declarations = new ArrayList&lt;&gt;();
612             }
613 
614             prefix = prefix.intern();
615             uri = uri.intern();
616             if (&quot;&quot;.equals(prefix)) {
617                 if (&quot;&quot;.equals(uri)) {
618                     defaultNS = null;
619                 } else {
620                     defaultNS = uri;
621                 }
622             } else {
623                 prefixTable.put(prefix, uri);
624                 uriTable.put(uri, prefix); // may wipe out another prefix
625             }
626             declarations.add(prefix);
627         }
628 
629 
630         /**
631          * Process an XML qualified name in this context.
632          *
633          * @param qName The XML qualified name.
634          * @param isAttribute true if this is an attribute name.
635          * @return An array of three strings containing the
636          *         URI part (or empty string), the local part,
637          *         and the raw name, all internalized, or null
638          *         if there is an undeclared prefix.
639          * @see org.xml.sax.helpers.NamespaceSupport#processName
640          */
641         String [] processName (String qName, boolean isAttribute)
642         {
643             String name[];
644             Map&lt;String, String[]&gt; table;
645 
646             // Select the appropriate table.
647             if (isAttribute) {
648                 table = attributeNameTable;
649             } else {
650                 table = elementNameTable;
651             }
652 
653             // Start by looking in the cache, and
654             // return immediately if the name
655             // is already known in this content
656             name = table.get(qName);
657             if (name != null) {
658                 return name;
659             }
660 
661             // We haven&#39;t seen this name in this
662             // context before.  Maybe in the parent
663             // context, but we can&#39;t assume prefix
664             // bindings are the same.
665             name = new String[3];
666             name[2] = qName.intern();
667             int index = qName.indexOf(&#39;:&#39;);
668 
669 
670             // No prefix.
671             if (index == -1) {
672                 if (isAttribute) {
673                     if (qName == &quot;xmlns&quot; &amp;&amp; namespaceDeclUris)
674                         name[0] = NSDECL;
675                     else
676                         name[0] = &quot;&quot;;
677                 } else if (defaultNS == null) {
678                     name[0] = &quot;&quot;;
679                 } else {
680                     name[0] = defaultNS;
681                 }
682                 name[1] = name[2];
683             }
684 
685             // Prefix
686             else {
687                 String prefix = qName.substring(0, index);
688                 String local = qName.substring(index+1);
689                 String uri;
690                 if (&quot;&quot;.equals(prefix)) {
691                     uri = defaultNS;
692                 } else {
693                     uri = prefixTable.get(prefix);
694                 }
695                 if (uri == null
696                         || (!isAttribute &amp;&amp; &quot;xmlns&quot;.equals (prefix))) {
697                     return null;
698                 }
699                 name[0] = uri;
700                 name[1] = local.intern();
701             }
702 
703             // Save in the cache for future use.
704             // (Could be shared with parent context...)
705             table.put(name[2], name);
706             return name;
707         }
708 
709 
710         /**
711          * Look up the URI associated with a prefix in this context.
712          *
713          * @param prefix The prefix to look up.
714          * @return The associated Namespace URI, or null if none is
715          *         declared.
716          * @see org.xml.sax.helpers.NamespaceSupport#getURI
717          */
718         String getURI (String prefix)
719         {
720             if (&quot;&quot;.equals(prefix)) {
721                 return defaultNS;
722             } else if (prefixTable == null) {
723                 return null;
724             } else {
725                 return prefixTable.get(prefix);
726             }
727         }
728 
729 
730         /**
731          * Look up one of the prefixes associated with a URI in this context.
732          *
733          * &lt;p&gt;Since many prefixes may be mapped to the same URI,
734          * the return value may be unreliable.&lt;/p&gt;
735          *
736          * @param uri The URI to look up.
737          * @return The associated prefix, or null if none is declared.
738          * @see org.xml.sax.helpers.NamespaceSupport#getPrefix
739          */
740         String getPrefix (String uri)
741         {
742             if (uriTable == null) {
743                 return null;
744             } else {
745                 return uriTable.get(uri);
746             }
747         }
748 
749 
750         /**
751          * Return an enumeration of prefixes declared in this context.
752          *
753          * @return An enumeration of prefixes (possibly empty).
754          * @see org.xml.sax.helpers.NamespaceSupport#getDeclaredPrefixes
755          */
756         Enumeration&lt;String&gt; getDeclaredPrefixes ()
757         {
758             if (declarations == null) {
759                 return EMPTY_ENUMERATION;
760             } else {
761                 return Collections.enumeration(declarations);
762             }
763         }
764 
765         /**
766          * Return an enumeration of all prefixes currently in force.
767          *
768          * &lt;p&gt;The default prefix, if in force, is &lt;em&gt;not&lt;/em&gt;
769          * returned, and will have to be checked for separately.&lt;/p&gt;
770          *
771          * @return An enumeration of prefixes (never empty).
772          * @see org.xml.sax.helpers.NamespaceSupport#getPrefixes
773          */
774         Enumeration&lt;String&gt; getPrefixes ()
775         {
776             if (prefixTable == null) {
777                 return EMPTY_ENUMERATION;
778             } else {
779                 return Collections.enumeration(prefixTable.keySet());
780             }
781         }
782 
783 
784 
785         ////////////////////////////////////////////////////////////////
786         // Internal methods.
787         ////////////////////////////////////////////////////////////////
788 
789 
790         /**
791          * Copy on write for the internal tables in this context.
792          *
793          * &lt;p&gt;This class is optimized for the normal case where most
794          * elements do not contain Namespace declarations.&lt;/p&gt;
795          */
796         private void copyTables ()
797         {
798             if (prefixTable != null) {
799                 prefixTable = new HashMap&lt;&gt;(prefixTable);
800             } else {
801                 prefixTable = new HashMap&lt;&gt;();
802             }
803             if (uriTable != null) {
804                 uriTable = new HashMap&lt;&gt;(uriTable);
805             } else {
806                 uriTable = new HashMap&lt;&gt;();
807             }
808             elementNameTable = new HashMap&lt;&gt;();
809             attributeNameTable = new HashMap&lt;&gt;();
810             declSeen = true;
811         }
812 
813 
814 
815         ////////////////////////////////////////////////////////////////
816         // Protected state.
817         ////////////////////////////////////////////////////////////////
818 
819         Map&lt;String, String&gt; prefixTable;
820         Map&lt;String, String&gt; uriTable;
821         Map&lt;String, String[]&gt; elementNameTable;
822         Map&lt;String, String[]&gt; attributeNameTable;
823         String defaultNS = null;
824 
825 
826 
827         ////////////////////////////////////////////////////////////////
828         // Internal state.
829         ////////////////////////////////////////////////////////////////
830 
831         private List&lt;String&gt; declarations = null;
832         private boolean declSeen = false;
833         private Context parent = null;
834     }
835 }
836 
837 // end of NamespaceSupport.java
    </pre>
  </body>
</html>
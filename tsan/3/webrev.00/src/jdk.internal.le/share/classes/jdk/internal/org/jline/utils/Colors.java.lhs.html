<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/Colors.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="1" id="anc1"></a><span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.io.BufferedReader;
 12 import java.io.IOError;
 13 import java.io.IOException;
 14 import java.io.InputStream;
 15 import java.nio.charset.StandardCharsets;
 16 import java.util.LinkedHashMap;
 17 import java.util.Map;
 18 import java.util.stream.Stream;
 19 
 20 import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_COLOR_DISTANCE;
 21 
 22 public class Colors {
 23 
 24     /**
 25      * Default 256 colors palette
 26      */
 27     public static final int[] DEFAULT_COLORS_256 = {
 28             0x000000, 0x800000, 0x008000, 0x808000, 0x000080, 0x800080, 0x008080, 0xc0c0c0,
 29             0x808080, 0xff0000, 0x00ff00, 0xffff00, 0x0000ff, 0xff00ff, 0x00ffff, 0xffffff,
 30 
 31             0x000000, 0x00005f, 0x000087, 0x0000af, 0x0000d7, 0x0000ff, 0x005f00, 0x005f5f,
 32             0x005f87, 0x005faf, 0x005fd7, 0x005fff, 0x008700, 0x00875f, 0x008787, 0x0087af,
 33             0x0087d7, 0x0087ff, 0x00af00, 0x00af5f, 0x00af87, 0x00afaf, 0x00afd7, 0x00afff,
 34             0x00d700, 0x00d75f, 0x00d787, 0x00d7af, 0x00d7d7, 0x00d7ff, 0x00ff00, 0x00ff5f,
 35             0x00ff87, 0x00ffaf, 0x00ffd7, 0x00ffff, 0x5f0000, 0x5f005f, 0x5f0087, 0x5f00af,
 36             0x5f00d7, 0x5f00ff, 0x5f5f00, 0x5f5f5f, 0x5f5f87, 0x5f5faf, 0x5f5fd7, 0x5f5fff,
 37             0x5f8700, 0x5f875f, 0x5f8787, 0x5f87af, 0x5f87d7, 0x5f87ff, 0x5faf00, 0x5faf5f,
 38             0x5faf87, 0x5fafaf, 0x5fafd7, 0x5fafff, 0x5fd700, 0x5fd75f, 0x5fd787, 0x5fd7af,
 39             0x5fd7d7, 0x5fd7ff, 0x5fff00, 0x5fff5f, 0x5fff87, 0x5fffaf, 0x5fffd7, 0x5fffff,
 40             0x870000, 0x87005f, 0x870087, 0x8700af, 0x8700d7, 0x8700ff, 0x875f00, 0x875f5f,
 41             0x875f87, 0x875faf, 0x875fd7, 0x875fff, 0x878700, 0x87875f, 0x878787, 0x8787af,
 42             0x8787d7, 0x8787ff, 0x87af00, 0x87af5f, 0x87af87, 0x87afaf, 0x87afd7, 0x87afff,
 43             0x87d700, 0x87d75f, 0x87d787, 0x87d7af, 0x87d7d7, 0x87d7ff, 0x87ff00, 0x87ff5f,
 44             0x87ff87, 0x87ffaf, 0x87ffd7, 0x87ffff, 0xaf0000, 0xaf005f, 0xaf0087, 0xaf00af,
 45             0xaf00d7, 0xaf00ff, 0xaf5f00, 0xaf5f5f, 0xaf5f87, 0xaf5faf, 0xaf5fd7, 0xaf5fff,
 46             0xaf8700, 0xaf875f, 0xaf8787, 0xaf87af, 0xaf87d7, 0xaf87ff, 0xafaf00, 0xafaf5f,
 47             0xafaf87, 0xafafaf, 0xafafd7, 0xafafff, 0xafd700, 0xafd75f, 0xafd787, 0xafd7af,
 48             0xafd7d7, 0xafd7ff, 0xafff00, 0xafff5f, 0xafff87, 0xafffaf, 0xafffd7, 0xafffff,
 49             0xd70000, 0xd7005f, 0xd70087, 0xd700af, 0xd700d7, 0xd700ff, 0xd75f00, 0xd75f5f,
 50             0xd75f87, 0xd75faf, 0xd75fd7, 0xd75fff, 0xd78700, 0xd7875f, 0xd78787, 0xd787af,
 51             0xd787d7, 0xd787ff, 0xd7af00, 0xd7af5f, 0xd7af87, 0xd7afaf, 0xd7afd7, 0xd7afff,
 52             0xd7d700, 0xd7d75f, 0xd7d787, 0xd7d7af, 0xd7d7d7, 0xd7d7ff, 0xd7ff00, 0xd7ff5f,
 53             0xd7ff87, 0xd7ffaf, 0xd7ffd7, 0xd7ffff, 0xff0000, 0xff005f, 0xff0087, 0xff00af,
 54             0xff00d7, 0xff00ff, 0xff5f00, 0xff5f5f, 0xff5f87, 0xff5faf, 0xff5fd7, 0xff5fff,
 55             0xff8700, 0xff875f, 0xff8787, 0xff87af, 0xff87d7, 0xff87ff, 0xffaf00, 0xffaf5f,
 56             0xffaf87, 0xffafaf, 0xffafd7, 0xffafff, 0xffd700, 0xffd75f, 0xffd787, 0xffd7af,
 57             0xffd7d7, 0xffd7ff, 0xffff00, 0xffff5f, 0xffff87, 0xffffaf, 0xffffd7, 0xffffff,
 58 
 59             0x080808, 0x121212, 0x1c1c1c, 0x262626, 0x303030, 0x3a3a3a, 0x444444, 0x4e4e4e,
 60             0x585858, 0x626262, 0x6c6c6c, 0x767676, 0x808080, 0x8a8a8a, 0x949494, 0x9e9e9e,
 61             0xa8a8a8, 0xb2b2b2, 0xbcbcbc, 0xc6c6c6, 0xd0d0d0, 0xdadada, 0xe4e4e4, 0xeeeeee,
 62     };
 63 
 64     /** D50 illuminant for CAM color spaces */
 65     public static final double[] D50 = new double[] { 96.422f, 100.0f,  82.521f };
 66     /** D65 illuminant for CAM color spaces */
 67     public static final double[] D65 = new double[] { 95.047, 100.0, 108.883 };
 68 
 69     /** Average surrounding for CAM color spaces */
 70     public static final double[] averageSurrounding = new double[] { 1.0, 0.690, 1.0 };
 71     /** Dim surrounding for CAM color spaces */
 72     public static final double[] dimSurrounding =     new double[] { 0.9, 0.590, 0.9 };
 73     /** Dark surrounding for CAM color spaces */
 74     public static final double[] darkSurrounding =    new double[] { 0.8, 0.525, 0.8 };
 75 
 76     /** sRGB encoding environment */
 77     public static final double[] sRGB_encoding_environment = vc(D50,  64.0,  64/5, dimSurrounding);
 78     /** sRGB typical environment */
 79     public static final double[] sRGB_typical_environment  = vc(D50, 200.0, 200/5, averageSurrounding);
 80     /** Adobe RGB environment */
 81     public static final double[] AdobeRGB_environment      = vc(D65, 160.0, 160/5, averageSurrounding);
 82 
 83     private static int[] COLORS_256 = DEFAULT_COLORS_256;
 84 
 85     private static Map&lt;String, Integer&gt; COLOR_NAMES;
 86 
 87     public static void setRgbColors(int[] colors) {
 88         if (colors == null || colors.length != 256) {
 89             throw new IllegalArgumentException();
 90         }
 91         COLORS_256 = colors;
 92     }
 93 
 94     public static int rgbColor(int col) {
 95         return COLORS_256[col];
 96     }
 97 
 98     public static Integer rgbColor(String name) {
 99         if (COLOR_NAMES == null) {
100             Map&lt;String, Integer&gt; colors = new LinkedHashMap&lt;&gt;();
101             try (InputStream is = InfoCmp.class.getResourceAsStream(&quot;colors.txt&quot;);
102                  BufferedReader br = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
103                 br.lines().map(String::trim)
104                         .filter(s -&gt; !s.startsWith(&quot;#&quot;))
105                         .filter(s -&gt; !s.isEmpty())
106                         .forEachOrdered(s -&gt; {
107                             colors.put(s, colors.size());
108                         });
109                 COLOR_NAMES = colors;
110             } catch (IOException e) {
111                 throw new IOError(e);
112             }
113         }
114         return COLOR_NAMES.get(name);
115     }
116 
117     public static int roundColor(int col, int max) {
118         return roundColor(col, max, null);
119     }
120 
121     public static int roundColor(int col, int max, String dist) {
122         if (col &gt;= max) {
123             int c = COLORS_256[col];
124             col = roundColor(c, COLORS_256, max, dist);
125         }
126         return col;
127     }
128 
129     public static int roundRgbColor(int r, int g, int b, int max) {
130         return roundColor((r &lt;&lt; 16) + (g &lt;&lt; 8) + b, COLORS_256, max, (String) null);
131     }
132 
133     private static int roundColor(int color, int[] colors, int max, String dist) {
134         return roundColor(color, colors, max, getDistance(dist));
135     }
136 
137     private interface Distance {
138         double compute(int c1, int c2);
139     }
140 
141     private static int roundColor(int color, int[] colors, int max, Distance distance) {
142         double best_distance = Integer.MAX_VALUE;
143         int best_index = Integer.MAX_VALUE;
144         for (int idx = 0; idx &lt; max; idx++) {
145             double d = distance.compute(color, colors[idx]);
146             if (d &lt;= best_distance) {
147                 best_index = idx;
148                 best_distance = d;
149             }
150         }
151         return best_index;
152     }
153 
154     private static Distance getDistance(String dist) {
155         if (dist == null) {
156             dist = System.getProperty(PROP_COLOR_DISTANCE, &quot;cie76&quot;);
157         }
158         return doGetDistance(dist);
159     }
160 
161     private static Distance doGetDistance(String dist) {
162         if (dist.equals(&quot;rgb&quot;)) {
163             return (p1, p2) -&gt; {
164                 // rgb: see https://www.compuphase.com/cmetric.htm
165                 double[] c1 = rgb(p1);
166                 double[] c2 = rgb(p2);
167                 double rmean = (c1[0] + c2[0]) / 2.0;
168                 double[] w = { 2.0 + rmean, 4.0, 3.0 - rmean };
169                 return scalar(c1, c2, w);
170             };
171         }
172         if (dist.matches(&quot;rgb\\(([0-9]+(\\.[0-9]+)?),([0-9]+(\\.[0-9]+)?),([0-9]+(\\.[0-9]+)?)\\)&quot;)) {
173             return (p1, p2) -&gt; scalar(rgb(p1), rgb(p2), getWeights(dist));
174         }
175         if (dist.equals(&quot;lab&quot;) || dist.equals(&quot;cie76&quot;)) {
176             return (p1, p2) -&gt; scalar(rgb2cielab(p1), rgb2cielab(p2));
177         }
178         if (dist.matches(&quot;lab\\(([0-9]+(\\.[0-9]+)?),([0-9]+(\\.[0-9]+)?)\\)&quot;)) {
179             double[] w = getWeights(dist);
180             return (p1, p2) -&gt; scalar(rgb2cielab(p1), rgb2cielab(p2), new double[] { w[0], w[1], w[1] });
181         }
182         if (dist.equals(&quot;cie94&quot;)) {
183             return (p1, p2) -&gt; cie94(rgb2cielab(p1), rgb2cielab(p2));
184         }
185         if (dist.equals(&quot;cie00&quot;) || dist.equals(&quot;cie2000&quot;)) {
186             return (p1, p2) -&gt; cie00(rgb2cielab(p1), rgb2cielab(p2));
187         }
188         if (dist.equals(&quot;cam02&quot;)) {
189             return (p1, p2) -&gt; cam02(p1, p2, sRGB_typical_environment);
190         }
191         if (dist.equals(&quot;camlab&quot;)) {
192             return (p1, p2) -&gt; {
193                 double[] c1 = camlab(p1, sRGB_typical_environment);
194                 double[] c2 = camlab(p2, sRGB_typical_environment);
195                 return scalar(c1, c2);
196             };
197         }
198         if (dist.matches(&quot;camlab\\(([0-9]+(\\.[0-9]+)?),([0-9]+(\\.[0-9]+)?)\\)&quot;)) {
199             return (p1, p2) -&gt; {
200                 double[] c1 = camlab(p1, sRGB_typical_environment);
201                 double[] c2 = camlab(p2, sRGB_typical_environment);
202                 double[] w = getWeights(dist);
203                 return scalar(c1, c2, new double[] { w[0], w[1], w[1] });
204             };
205         }
206         if (dist.matches(&quot;camlch&quot;)) {
207             return (p1, p2) -&gt; {
208                 double[] c1 = camlch(p1, sRGB_typical_environment);
209                 double[] c2 = camlch(p2, sRGB_typical_environment);
210                 return camlch(c1, c2);
211             };
212         }
213         if (dist.matches(&quot;camlch\\(([0-9]+(\\.[0-9]+)?),([0-9]+(\\.[0-9]+)?),([0-9]+(\\.[0-9]+)?)\\)&quot;)) {
214             return (p1, p2) -&gt; {
215                 double[] c1 = camlch(p1, sRGB_typical_environment);
216                 double[] c2 = camlch(p2, sRGB_typical_environment);
217                 double[] w = getWeights(dist);
218                 return camlch(c1, c2, w);
219             };
220         }
221         throw new IllegalArgumentException(&quot;Unsupported distance function: &quot; + dist);
222     }
223 
224     private static double[] getWeights(String dist) {
225         String[] weights = dist.substring(dist.indexOf(&#39;(&#39;) + 1, dist.length() - 1).split(&quot;,&quot;);
226         return Stream.of(weights).mapToDouble(Double::parseDouble).toArray();
227     }
228 
229     private static double scalar(double[] c1, double[] c2, double[] w) {
230         return sqr((c1[0] - c2[0]) * w[0])
231              + sqr((c1[1] - c2[1]) * w[1])
232              + sqr((c1[2] - c2[2]) * w[2]);
233     }
234 
235     private static double scalar(double[] c1, double[] c2) {
236         return sqr(c1[0] - c2[0])
237              + sqr(c1[1] - c2[1])
238              + sqr(c1[2] - c2[2]);
239     }
240 
241     private static final int L = 0;
242     private static final int A = 1;
243     private static final int B = 2;
244     private static final int X = 0;
245     private static final int Y = 1;
246     private static final int Z = 2;
247     private static final double kl = 2.0;
248     private static final double kc = 1.0;
249     private static final double kh = 1.0;
250     private static final double k1 = 0.045;
251     private static final double k2 = 0.015;
252 
253     private static double cie94(double[] lab1, double[] lab2) {
254         double dl = lab1[L] - lab2[L];
255         double da = lab1[A] - lab2[A];
256         double db = lab1[B] - lab2[B];
257         double c1 = Math.sqrt(lab1[A] * lab1[A] + lab1[B] * lab1[B]);
258         double c2 = Math.sqrt(lab2[A] * lab2[A] + lab2[B] * lab2[B]);
259         double dc = c1 - c2;
260         double dh = da * da + db * db - dc * dc;
261         dh = dh &lt; 0.0 ? 0.0 : Math.sqrt(dh);
262         double sl = 1.0;
263         double sc = 1.0 + k1 * c1;
264         double sh = 1.0 + k2 * c1;
265         double dLKlsl = dl / (kl * sl);
266         double dCkcsc = dc / (kc * sc);
267         double dHkhsh = dh / (kh * sh);
268         return dLKlsl * dLKlsl + dCkcsc * dCkcsc + dHkhsh * dHkhsh;
269     }
270 
271     private static double cie00(double[] lab1, double[] lab2) {
272         double c_star_1_ab = Math.sqrt(lab1[A] * lab1[A] + lab1[B] * lab1[B]);
273         double c_star_2_ab = Math.sqrt(lab2[A] * lab2[A] + lab2[B] * lab2[B]);
274         double c_star_average_ab = (c_star_1_ab + c_star_2_ab) / 2.0;
275         double c_star_average_ab_pot_3 = c_star_average_ab * c_star_average_ab * c_star_average_ab;
276         double c_star_average_ab_pot_7 = c_star_average_ab_pot_3 * c_star_average_ab_pot_3 * c_star_average_ab;
277         double G = 0.5 * (1.0 - Math.sqrt(c_star_average_ab_pot_7 / (c_star_average_ab_pot_7 + 6103515625.0))); //25^7
278         double a1_prime = (1.0 + G) * lab1[A];
279         double a2_prime = (1.0 + G) * lab2[A];
280         double C_prime_1 = Math.sqrt(a1_prime * a1_prime + lab1[B] * lab1[B]);
281         double C_prime_2 = Math.sqrt(a2_prime * a2_prime + lab2[B] * lab2[B]);
282         double h_prime_1 = (Math.toDegrees(Math.atan2(lab1[B], a1_prime)) + 360.0) % 360.0;
283         double h_prime_2 = (Math.toDegrees(Math.atan2(lab2[B], a2_prime)) + 360.0) % 360.0;
284         double delta_L_prime = lab2[L] - lab1[L];
285         double delta_C_prime = C_prime_2 - C_prime_1;
286         double h_bar = Math.abs(h_prime_1 - h_prime_2);
287         double delta_h_prime;
288         if (C_prime_1 * C_prime_2 == 0.0) {
289             delta_h_prime = 0.0;
290         } else if (h_bar &lt;= 180.0) {
291             delta_h_prime = h_prime_2 - h_prime_1;
292         } else if (h_prime_2 &lt;= h_prime_1) {
293             delta_h_prime = h_prime_2 - h_prime_1 + 360.0;
294         } else {
295             delta_h_prime = h_prime_2 - h_prime_1 - 360.0;
296         }
297         double delta_H_prime = 2.0 * Math.sqrt(C_prime_1 * C_prime_2) * Math.sin(Math.toRadians(delta_h_prime / 2.0));
298         double L_prime_average = (lab1[L] + lab2[L]) / 2.0;
299         double C_prime_average = (C_prime_1 + C_prime_2) / 2.0;
300         double h_prime_average;
301         if (C_prime_1 * C_prime_2 == 0.0) {
302             h_prime_average = 0.0;
303         } else if (h_bar &lt;= 180.0) {
304             h_prime_average = (h_prime_1 + h_prime_2) / 2.0;
305         } else if ((h_prime_1 + h_prime_2) &lt; 360.0) {
306             h_prime_average = (h_prime_1 + h_prime_2 + 360.0) / 2.0;
307         } else {
308             h_prime_average = (h_prime_1 + h_prime_2 - 360.0) / 2.0;
309         }
310         double L_prime_average_minus_50 = L_prime_average - 50.0;
311         double L_prime_average_minus_50_square = L_prime_average_minus_50 * L_prime_average_minus_50;
312         double T = 1.0
313                 - 0.17 * Math.cos(Math.toRadians(h_prime_average - 30.0))
314                 + 0.24 * Math.cos(Math.toRadians(h_prime_average * 2.0))
315                 + 0.32 * Math.cos(Math.toRadians(h_prime_average * 3.0 + 6.0))
316                 - 0.20 * Math.cos(Math.toRadians(h_prime_average * 4.0 - 63.0));
317         double S_L = 1.0 + ((0.015 * L_prime_average_minus_50_square) / Math.sqrt(20.0 + L_prime_average_minus_50_square));
318         double S_C = 1.0 + 0.045 * C_prime_average;
319         double S_H = 1.0 + 0.015 * T * C_prime_average;
320         double h_prime_average_minus_275_div_25 = (h_prime_average - 275.0) / (25.0);
321         double h_prime_average_minus_275_div_25_square = h_prime_average_minus_275_div_25 * h_prime_average_minus_275_div_25;
322         double delta_theta = 30.0 * Math.exp(-h_prime_average_minus_275_div_25_square);
323         double C_prime_average_pot_3 = C_prime_average * C_prime_average * C_prime_average;
324         double C_prime_average_pot_7 = C_prime_average_pot_3 * C_prime_average_pot_3 * C_prime_average;
325         double R_C = 2.0 * Math.sqrt(C_prime_average_pot_7 / (C_prime_average_pot_7 + 6103515625.0)); //25^7
326         double R_T = - Math.sin(Math.toRadians(2.0 * delta_theta)) * R_C;
327         double dLKlsl = delta_L_prime / (kl * S_L);
328         double dCkcsc = delta_C_prime / (kc * S_C);
329         double dHkhsh = delta_H_prime / (kh * S_H);
330         return dLKlsl * dLKlsl + dCkcsc * dCkcsc + dHkhsh * dHkhsh + R_T * dCkcsc * dHkhsh;
331     }
332 
333     private static double cam02(int p1, int p2, double[] vc) {
334         double[] c1 = jmh2ucs(camlch(p1, vc));
335         double[] c2 = jmh2ucs(camlch(p2, vc));
336         return scalar(c1, c2);
337     }
338 
339     private static double[] jmh2ucs(double[] lch) {
340         double sJ = ((1.0 + 100 * 0.007) * lch[0]) / (1.0 + 0.007 * lch[0]);
341         double sM = ((1.0 / 0.0228) * Math.log(1.0 + 0.0228 * lch[1]));
342         double a = sM * Math.cos(Math.toRadians(lch[2]));
343         double b = sM * Math.sin(Math.toRadians(lch[2]));
344         return new double[] {sJ, a, b };
345     }
346 
347     static double camlch(double[] c1, double[] c2) {
348         return camlch(c1, c2, new double[] { 1.0, 1.0, 1.0 });
349     }
350 
351     static double camlch(double[] c1, double[] c2, double[] w) {
352         // normalize weights to correlate range
353         double lightnessWeight = w[0] / 100.0;
354         double colorfulnessWeight = w[1] / 120.0;
355         double hueWeight = w[2] / 360.0;
356         // calculate sort-of polar distance
357         double dl = (c1[0] - c2[0]) * lightnessWeight;
358         double dc = (c1[1] - c2[1]) * colorfulnessWeight;
359         double dh = hueDifference(c1[2], c2[2], 360.0) * hueWeight;
360         return dl * dl + dc * dc + dh * dh;
361     }
362 
363     private static double hueDifference(double hue1, double hue2, double c) {
364         double difference = (hue2 - hue1) % c;
365         double ch = c / 2;
366         if (difference &gt; ch)
367             difference -= c;
368         if (difference &lt; -ch)
369             difference += c;
370         return difference;
371     }
372 
373     private static double[] rgb(int color) {
374         int r = (color &gt;&gt; 16) &amp; 0xFF;
375         int g = (color &gt;&gt;  8) &amp; 0xFF;
376         int b = (color &gt;&gt;  0) &amp; 0xFF;
377         return new double[] { r / 255.0, g / 255.0, b / 255.0 };
378     }
379 
380     static double[] rgb2xyz(int color) {
381         return rgb2xyz(rgb(color));
382     }
383 
384     static double[] rgb2cielab(int color) {
385         return rgb2cielab(rgb(color));
386     }
387 
388     static double[] camlch(int color) {
389         return camlch(color, sRGB_typical_environment);
390     }
391 
392     static double[] camlch(int color, double[] vc) {
393         return xyz2camlch(rgb2xyz(color), vc);
394     }
395 
396     static double[] camlab(int color) {
397         return camlab(color, sRGB_typical_environment);
398     }
399 
400     static double[] camlab(int color, double[] vc) {
401         return lch2lab(camlch(color, vc));
402     }
403 
404     static double[] lch2lab(double[] lch) {
405         double toRad = Math.PI / 180;
406         return new double[] { lch[0], lch[1] * Math.cos(lch[2] * toRad), lch[1] * Math.sin(lch[2] * toRad) };
407     }
408 
409     private static double[] xyz2camlch(double[] xyz, double[] vc) {
410         double[] XYZ = new double[] {xyz[0] * 100.0, xyz[1] * 100.0, xyz[2] * 100.0};
411         double[] cam = forwardTransform(XYZ, vc);
412         return new double[] { cam[J], cam[M], cam[h] };
413     }
414 
415     /** Lightness */
416     public static final int J = 0;
417     /** Brightness */
418     public static final int Q = 1;
419     /** Chroma */
420     public static final int C = 2;
421     /** Colorfulness */
422     public static final int M = 3;
423     /** Saturation */
424     public static final int s = 4;
425     /** Hue Composition / Hue Quadrature */
426     public static final int H = 5;
427     /** Hue */
428     public static final int h = 6;
429 
430 
431     /** CIECAM02 appearance correlates */
432     private static double[] forwardTransform(double[] XYZ, double[] vc) {
433         // calculate sharpened cone response
434         double[] RGB = forwardPreAdaptationConeResponse(XYZ);
435         // calculate corresponding (sharpened) cone response considering various luminance level and surround conditions in D
436         double[] RGB_c = forwardPostAdaptationConeResponse(RGB, vc);
437         // calculate HPE equal area cone fundamentals
438         double[] RGBPrime = CAT02toHPE(RGB_c);
439         // calculate response-compressed postadaptation cone response
440         double[] RGBPrime_a = forwardResponseCompression(RGBPrime, vc);
441         // calculate achromatic response
442         double A = (2.0 * RGBPrime_a[0] + RGBPrime_a[1] + RGBPrime_a[2] / 20.0 - 0.305) * vc[VC_N_BB];
443         // calculate lightness
444         double J = 100.0 * Math.pow(A / vc[VC_A_W], vc[VC_Z] * vc[VC_C]);
445         // calculate redness-greenness and yellowness-blueness color opponent values
446         double a = RGBPrime_a[0] + (-12.0 * RGBPrime_a[1] + RGBPrime_a[2]) / 11.0;
447         double b = (RGBPrime_a[0] + RGBPrime_a[1] - 2.0 * RGBPrime_a[2]) / 9.0;
448         // calculate hue angle
449         double h = (Math.toDegrees(Math.atan2(b, a)) + 360.0) % 360.0;
450         // calculate eccentricity
451         double e = ((12500.0 / 13.0) * vc[VC_N_C] * vc[VC_N_CB]) * (Math.cos(Math.toRadians(h) + 2.0) + 3.8);
452         // get t
453         double t = e * Math.sqrt(Math.pow(a, 2.0) + Math.pow(b, 2.0)) / (RGBPrime_a[0] + RGBPrime_a[1] + 1.05 * RGBPrime_a[2]);
454         // calculate brightness
455         double Q = (4.0 / vc[VC_C]) * Math.sqrt(J / 100.0) * (vc[VC_A_W] + 4.0) * Math.pow(vc[VC_F_L], 0.25);
456         // calculate the correlates of chroma, colorfulness, and saturation
457         double C = Math.signum(t) * Math.pow(Math.abs(t), 0.9) * Math.sqrt(J / 100.0) * Math.pow(1.64- Math.pow(0.29, vc[VC_N]), 0.73);
458         double M = C * Math.pow(vc[VC_F_L], 0.25);
459         double s = 100.0 * Math.sqrt(M / Q);
460         // calculate hue composition
461         double H = calculateH(h);
462         return new double[] { J, Q, C, M, s, H, h };
463     }
464 
465     private static double calculateH(double h) {
466         if (h &lt; 20.14)
467             h = h + 360;
468         double i;
469         if (h &gt;= 20.14 &amp;&amp; h &lt; 90.0) {  // index i = 1
470             i = (h - 20.14) / 0.8;
471             return 100.0 * i / (i + (90 - h) / 0.7);
472         } else if (h &lt; 164.25) { // index i = 2
473             i = (h - 90) / 0.7;
474             return 100.0 + 100.0 * i / (i + (164.25 - h) / 1);
475         } else if (h &lt; 237.53) {  // index i = 3
476             i = (h - 164.25) / 1.0;
477             return 200.0 + 100.0 * i / (i + (237.53 - h) / 1.2);
478         } else if (h &lt;= 380.14) {  // index i = 4
479             i = (h - 237.53) / 1.2;
480             double H = 300.0 + 100.0 * i / (i + (380.14 - h) / 0.8);
481             // don&#39;t use 400 if we can use 0
482             if (H &lt;= 400.0 &amp;&amp; H &gt;= 399.999)
483                 H = 0;
484             return H;
485         } else {
486             throw new IllegalArgumentException(&quot;h outside assumed range 0..360: &quot; + Double.toString(h));
487         }
488     }
489 
490     private static double[] forwardResponseCompression(double[] RGB, double[] vc) {
491         double[] result = new double[3];
492         for(int channel = 0; channel &lt; RGB.length; channel++) {
493             if(RGB[channel] &gt;= 0) {
494                 double n = Math.pow(vc[VC_F_L] * RGB[channel] / 100.0, 0.42);
495                 result[channel] = 400.0 * n / (n + 27.13) + 0.1;
496             } else {
497                 double n = Math.pow(-1.0 * vc[VC_F_L] * RGB[channel] / 100.0, 0.42);
498                 result[channel] = -400.0 * n / (n + 27.13) + 0.1;
499             }
500         }
501         return result;
502     }
503 
504     private static double[] forwardPostAdaptationConeResponse(double[] RGB, double[] vc) {
505         return new double[] { vc[VC_D_RGB_R] * RGB[0], vc[VC_D_RGB_G] * RGB[1], vc[VC_D_RGB_B] * RGB[2] };
506     }
507 
508     public static double[] CAT02toHPE(double[] RGB) {
509         double[] RGBPrime = new double[3];
510         RGBPrime[0] =  0.7409792 * RGB[0] + 0.2180250 * RGB[1] + 0.0410058 * RGB[2];
511         RGBPrime[1] =  0.2853532 * RGB[0] + 0.6242014 * RGB[1] + 0.0904454 * RGB[2];
512         RGBPrime[2] = -0.0096280 * RGB[0] - 0.0056980 * RGB[1] + 1.0153260 * RGB[2];
513         return RGBPrime;
514     }
515 
516     private static double[] forwardPreAdaptationConeResponse(double[] XYZ) {
517         double[] RGB = new double[3];
518         RGB[0] =  0.7328 * XYZ[0] + 0.4296 * XYZ[1] - 0.1624 * XYZ[2];
519         RGB[1] = -0.7036 * XYZ[0] + 1.6975 * XYZ[1] + 0.0061 * XYZ[2];
520         RGB[2] =  0.0030 * XYZ[0] + 0.0136 * XYZ[1] + 0.9834 * XYZ[2];
521         return RGB;
522     }
523 
524     static final int SUR_F = 0;
525     static final int SUR_C = 1;
526     static final int SUR_N_C = 2;
527 
528     static final int VC_X_W = 0;
529     static final int VC_Y_W = 1;
530     static final int VC_Z_W = 2;
531     static final int VC_L_A = 3;
532     static final int VC_Y_B = 4;
533     static final int VC_F =   5;
534     static final int VC_C =   6;
535     static final int VC_N_C = 7;
536 
537     static final int VC_Z = 8;
538     static final int VC_N = 9;
539     static final int VC_N_BB = 10;
540     static final int VC_N_CB = 11;
541     static final int VC_A_W = 12;
542     static final int VC_F_L = 13;
543     static final int VC_D_RGB_R = 14;
544     static final int VC_D_RGB_G = 15;
545     static final int VC_D_RGB_B = 16;
546 
547     static double[] vc(double[] xyz_w, double L_A, double Y_b, double[] surrounding) {
548         double[] vc = new double[17];
549         vc[VC_X_W] = xyz_w[0];
550         vc[VC_Y_W] = xyz_w[1];
551         vc[VC_Z_W] = xyz_w[2];
552         vc[VC_L_A] = L_A;
553         vc[VC_Y_B] = Y_b;
554         vc[VC_F] = surrounding[SUR_F];
555         vc[VC_C] = surrounding[SUR_C];
556         vc[VC_N_C] = surrounding[SUR_N_C];
557 
558         double[] RGB_w = forwardPreAdaptationConeResponse(xyz_w);
559         double D = Math.max(0.0, Math.min(1.0, vc[VC_F] * (1.0 - (1.0 / 3.6) * Math.pow(Math.E, (-L_A - 42.0) / 92.0))));
560         double Yw = xyz_w[1];
561         double[] RGB_c = new double[] {
562                 (D * Yw / RGB_w[0]) + (1.0 - D),
563                 (D * Yw / RGB_w[1]) + (1.0 - D),
564                 (D * Yw / RGB_w[2]) + (1.0 - D),
565         };
566 
567         // calculate increase in brightness and colorfulness caused by brighter viewing environments
568         double L_Ax5 = 5.0 * L_A;
569         double k = 1.0 / (L_Ax5 + 1.0);
570         double kpow4 = Math.pow(k, 4.0);
571         vc[VC_F_L] = 0.2 * kpow4 * (L_Ax5) + 0.1 * Math.pow(1.0 - kpow4, 2.0) * Math.pow(L_Ax5, 1.0/3.0);
572 
573         // calculate response compression on J and C caused by background lightness.
574         vc[VC_N] = Y_b / Yw;
575         vc[VC_Z] = 1.48 + Math.sqrt(vc[VC_N]);
576 
577         vc[VC_N_BB] = 0.725 * Math.pow(1.0 / vc[VC_N], 0.2);
578         vc[VC_N_CB] = vc[VC_N_BB]; // chromatic contrast factors (calculate increase in J, Q, and C caused by dark backgrounds)
579 
580         // calculate achromatic response to white
581         double[] RGB_wc = new double[] {RGB_c[0] * RGB_w[0], RGB_c[1] * RGB_w[1], RGB_c[2] * RGB_w[2]};
582         double[] RGBPrime_w = CAT02toHPE(RGB_wc);
583         double[] RGBPrime_aw = new double[3];
584         for(int channel = 0; channel &lt; RGBPrime_w.length; channel++) {
585             if(RGBPrime_w[channel] &gt;= 0) {
586                 double n = Math.pow(vc[VC_F_L] * RGBPrime_w[channel] / 100.0, 0.42);
587                 RGBPrime_aw[channel] = 400.0 * n / (n + 27.13) + 0.1;
588             } else {
589                 double n = Math.pow(-1.0 * vc[VC_F_L] * RGBPrime_w[channel] / 100.0, 0.42);
590                 RGBPrime_aw[channel] = -400.0 * n / (n + 27.13) + 0.1;
591             }
592         }
593         vc[VC_A_W] = (2.0 * RGBPrime_aw[0] + RGBPrime_aw[1] + RGBPrime_aw[2] / 20.0 - 0.305) * vc[VC_N_BB];
594         vc[VC_D_RGB_R] = RGB_c[0];
595         vc[VC_D_RGB_G] = RGB_c[1];
596         vc[VC_D_RGB_B] = RGB_c[2];
597         return vc;
598     }
599 
600     public static double[] rgb2cielab(double[] rgb) {
601         return xyz2lab(rgb2xyz(rgb));
602     }
603 
604     private static double[] rgb2xyz(double[] rgb) {
605         double vr = pivotRgb(rgb[0]);
606         double vg = pivotRgb(rgb[1]);
607         double vb = pivotRgb(rgb[2]);
608         // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
609         double x = vr * 0.4124564 + vg * 0.3575761 + vb * 0.1804375;
610         double y = vr * 0.2126729 + vg * 0.7151522 + vb * 0.0721750;
611         double z = vr * 0.0193339 + vg * 0.1191920 + vb * 0.9503041;
612         return new double[] { x, y, z };
613     }
614 
615     private static double pivotRgb(double n) {
616         return n &gt; 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
617     }
618 
619     private static double[] xyz2lab(double[] xyz) {
620         double fx = pivotXyz(xyz[0]);
621         double fy = pivotXyz(xyz[1]);
622         double fz = pivotXyz(xyz[2]);
623         double l = 116.0 * fy - 16.0;
624         double a = 500.0 * (fx - fy);
625         double b = 200.0 * (fy - fz);
626         return new double[] { l, a, b };
627     }
628 
629     private static final double epsilon = 216.0 / 24389.0;
630     private static final double kappa = 24389.0 / 27.0;
631     private static double pivotXyz(double n) {
632         return n &gt; epsilon ? Math.cbrt(n) : (kappa * n + 16) / 116;
633     }
634 
635     private static double sqr(double n) {
636         return n * n;
637     }
638 
639 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
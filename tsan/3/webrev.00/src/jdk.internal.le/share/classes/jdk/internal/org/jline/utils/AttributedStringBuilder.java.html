<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedStringBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.ArrayList;
 12 import java.util.Arrays;
 13 import java.util.List;
 14 import java.util.function.Consumer;
 15 import java.util.function.Function;
 16 import java.util.regex.Matcher;
 17 import java.util.regex.Pattern;
 18 
 19 /**
 20  * Attributed string builder
 21  *
 22  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 23  */
 24 public class AttributedStringBuilder extends AttributedCharSequence implements Appendable {
 25 
 26     private char[] buffer;
 27     private int[] style;
 28     private int length;
 29     private TabStops tabs = new TabStops(0);
 30     private int lastLineLength = 0;
 31     private AttributedStyle current = AttributedStyle.DEFAULT;
 32 
 33     public static AttributedString append(CharSequence... strings) {
 34         AttributedStringBuilder sb = new AttributedStringBuilder();
 35         for (CharSequence s : strings) {
 36             sb.append(s);
 37         }
 38         return sb.toAttributedString();
 39     }
 40 
 41     public AttributedStringBuilder() {
 42         this(64);
 43     }
 44 
 45     public AttributedStringBuilder(int capacity) {
 46         buffer = new char[capacity];
 47         style = new int[capacity];
 48         length = 0;
 49     }
 50 
 51     @Override
 52     public int length() {
 53         return length;
 54     }
 55 
 56     @Override
 57     public char charAt(int index) {
 58         return buffer[index];
 59     }
 60 
 61     @Override
 62     public AttributedStyle styleAt(int index) {
 63         return new AttributedStyle(style[index], style[index]);
 64     }
 65 
 66     @Override
 67     int styleCodeAt(int index) {
 68         return style[index];
 69     }
 70 
 71     @Override
 72     protected char[] buffer() {
 73         return buffer;
 74     }
 75 
 76     @Override
 77     protected int offset() {
 78         return 0;
 79     }
 80 
 81     @Override
 82     public AttributedString subSequence(int start, int end) {
 83         return new AttributedString(
 84                 Arrays.copyOfRange(buffer, start, end),
 85                 Arrays.copyOfRange(style, start, end),
 86                 0,
 87                 end - start);
 88     }
 89 
 90     @Override
 91     public AttributedStringBuilder append(CharSequence csq) {
 92         return append(new AttributedString(csq, current));
 93     }
 94 
 95     @Override
 96     public AttributedStringBuilder append(CharSequence csq, int start, int end) {
 97         return append(csq.subSequence(start, end));
 98     }
 99 
100     @Override
101     public AttributedStringBuilder append(char c) {
102         return append(Character.toString(c));
103     }
104 
105     public AttributedStringBuilder append(CharSequence csq, AttributedStyle style) {
106         return append(new AttributedString(csq, style));
107     }
108 
109     public AttributedStringBuilder style(AttributedStyle style) {
110         current = style;
111         return this;
112     }
113 
114     public AttributedStringBuilder style(Function&lt;AttributedStyle,AttributedStyle&gt; style) {
115         current = style.apply(current);
116         return this;
117     }
118 
119     public AttributedStringBuilder styled(Function&lt;AttributedStyle,AttributedStyle&gt; style, CharSequence cs) {
120         return styled(style, sb -&gt; sb.append(cs));
121     }
122 
123     public AttributedStringBuilder styled(AttributedStyle style, CharSequence cs) {
124         return styled(s -&gt; style, sb -&gt; sb.append(cs));
125     }
126 
127     public AttributedStringBuilder styled(Function&lt;AttributedStyle,AttributedStyle&gt; style, Consumer&lt;AttributedStringBuilder&gt; consumer) {
128         AttributedStyle prev = current;
129         current = style.apply(prev);
130         consumer.accept(this);
131         current = prev;
132         return this;
133     }
134 
135     public AttributedStyle style() {
136         return current;
137     }
138 
139     public AttributedStringBuilder append(AttributedString str) {
140         return append((AttributedCharSequence) str, 0, str.length());
141     }
142 
143     public AttributedStringBuilder append(AttributedString str, int start, int end) {
144         return append((AttributedCharSequence) str, start, end);
145     }
146 
147     public AttributedStringBuilder append(AttributedCharSequence str) {
148         return append(str, 0, str.length());
149     }
150 
151     public AttributedStringBuilder append(AttributedCharSequence str, int start, int end) {
152         ensureCapacity(length + end - start);
153         for (int i = start; i &lt; end; i++) {
154             char c = str.charAt(i);
155             int s = str.styleCodeAt(i) &amp; ~current.getMask() | current.getStyle();
156             if (tabs.defined() &amp;&amp; c == &#39;\t&#39;) {
157                 insertTab(new AttributedStyle(s, 0));
158             } else {
159                 ensureCapacity(length + 1);
160                 buffer[length] = c;
161                 style[length] = s;
162                 if (c == &#39;\n&#39;) {
163                     lastLineLength = 0;
164                 } else {
165                     lastLineLength++;
166                 }
167                 length++;
168             }
169         }
170         return this;
171     }
172 
173     protected void ensureCapacity(int nl) {
174         if (nl &gt; buffer.length) {
175             int s = Math.max(buffer.length, 1);
176             while (s &lt;= nl) {
177                 s *= 2;
178             }
179             buffer = Arrays.copyOf(buffer, s);
180             style = Arrays.copyOf(style, s);
181         }
182     }
183 
184     public void appendAnsi(String ansi) {
185         ansiAppend(ansi);
186     }
187 
188     public AttributedStringBuilder ansiAppend(String ansi) {
189         int ansiStart = 0;
190         int ansiState = 0;
191         ensureCapacity(length + ansi.length());
192         for (int i = 0; i &lt; ansi.length(); i++) {
193             char c = ansi.charAt(i);
194             if (ansiState == 0 &amp;&amp; c == 27) {
195                 ansiState++;
196             } else if (ansiState == 1 &amp;&amp; c == &#39;[&#39;) {
197                 ansiState++;
198                 ansiStart = i + 1;
199             } else if (ansiState == 2) {
200                 if (c == &#39;m&#39;) {
201                     String[] params = ansi.substring(ansiStart, i).split(&quot;;&quot;);
202                     int j = 0;
203                     while (j &lt; params.length) {
204                         int ansiParam = params[j].isEmpty() ? 0 : Integer.parseInt(params[j]);
205                         switch (ansiParam) {
206                             case 0:
207                                 current = AttributedStyle.DEFAULT;
208                                 break;
209                             case 1:
210                                 current = current.bold();
211                                 break;
212                             case 2:
213                                 current = current.faint();
214                                 break;
215                             case 3:
216                                 current = current.italic();
217                                 break;
218                             case 4:
219                                 current = current.underline();
220                                 break;
221                             case 5:
222                                 current = current.blink();
223                                 break;
224                             case 7:
225                                 current = current.inverse();
226                                 break;
227                             case 8:
228                                 current = current.conceal();
229                                 break;
230                             case 9:
231                                 current = current.crossedOut();
232                                 break;
233                             case 22:
234                                 current = current.boldOff().faintOff();
235                                 break;
236                             case 23:
237                                 current = current.italicOff();
238                                 break;
239                             case 24:
240                                 current = current.underlineOff();
241                                 break;
242                             case 25:
243                                 current = current.blinkOff();
244                                 break;
245                             case 27:
246                                 current = current.inverseOff();
247                                 break;
248                             case 28:
249                                 current = current.concealOff();
250                                 break;
251                             case 29:
252                                 current = current.crossedOutOff();
253                                 break;
254                             case 30:
255                             case 31:
256                             case 32:
257                             case 33:
258                             case 34:
259                             case 35:
260                             case 36:
261                             case 37:
262                                 current = current.foreground(ansiParam - 30);
263                                 break;
264                             case 39:
265                                 current = current.foregroundOff();
266                                 break;
267                             case 40:
268                             case 41:
269                             case 42:
270                             case 43:
271                             case 44:
272                             case 45:
273                             case 46:
274                             case 47:
275                                 current = current.background(ansiParam - 40);
276                                 break;
277                             case 49:
278                                 current = current.backgroundOff();
279                                 break;
280                             case 38:
281                             case 48:
282                                 if (j + 1 &lt; params.length) {
283                                     int ansiParam2 = Integer.parseInt(params[++j]);
284                                     if (ansiParam2 == 2) {
285                                         if (j + 3 &lt; params.length) {
286                                             int r = Integer.parseInt(params[++j]);
287                                             int g = Integer.parseInt(params[++j]);
288                                             int b = Integer.parseInt(params[++j]);
289                                             // convert to 256 colors
290                                             int col = 16 + (r &gt;&gt; 3) * 36 + (g &gt;&gt; 3) * 6 + (b &gt;&gt; 3);
291                                             if (ansiParam == 38) {
292                                                 current = current.foreground(col);
293                                             } else {
294                                                 current = current.background(col);
295                                             }
296                                         }
297                                     } else if (ansiParam2 == 5) {
298                                         if (j + 1 &lt; params.length) {
299                                             int col = Integer.parseInt(params[++j]);
300                                             if (ansiParam == 38) {
301                                                 current = current.foreground(col);
302                                             } else {
303                                                 current = current.background(col);
304                                             }
305                                         }
306                                     }
307                                 }
308                                 break;
309                             case 90:
310                             case 91:
311                             case 92:
312                             case 93:
313                             case 94:
314                             case 95:
315                             case 96:
316                             case 97:
317                                 current = current.foreground(ansiParam - 90 + 8);
318                                 break;
319                             case 100:
320                             case 101:
321                             case 102:
322                             case 103:
323                             case 104:
324                             case 105:
325                             case 106:
326                             case 107:
327                                 current = current.background(ansiParam - 100 + 8);
328                                 break;
329                         }
330                         j++;
331                     }
332                     ansiState = 0;
333                 } else if (!(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39; || c == &#39;;&#39;)) {
334                     // This is not a SGR code, so ignore
335                     ansiState = 0;
336                 }
337             } else if (c == &#39;\t&#39; &amp;&amp; tabs.defined()) {
338                 insertTab(current);
339             } else {
340                 ensureCapacity(length + 1);
341                 buffer[length] = c;
342                 style[length] = this.current.getStyle();
343                 if (c == &#39;\n&#39;) {
344                     lastLineLength = 0;
345                 } else {
346                     lastLineLength++;
347                 }
348                 length++;
349             }
350         }
351         return this;
352     }
353 
354     protected void insertTab(AttributedStyle s) {
355         int nb = tabs.spaces(lastLineLength);
356         ensureCapacity(length + nb);
357         for (int i = 0; i &lt; nb; i++) {
358             buffer[length] = &#39; &#39;;
359             style[length] = s.getStyle();
360             length++;
361         }
362         lastLineLength += nb;
363     }
364 
365     public void setLength(int l) {
366         length = l;
367     }
368 
369     /**
370      * Set the number of spaces a tab is expanded to. Tab size cannot be changed
371      * after text has been added to prevent inconsistent indentation.
372      *
373      * If tab size is set to 0, tabs are not expanded (the default).
374      * @param tabsize Spaces per tab or 0 for no tab expansion. Must be non-negative
375      * @return this
376      */
377     public AttributedStringBuilder tabs(int tabsize) {
378         if (tabsize &lt; 0) {
379             throw new IllegalArgumentException(&quot;Tab size must be non negative&quot;);
380         }
381         return tabs(Arrays.asList(tabsize));
382     }
383 
384     public AttributedStringBuilder tabs(List&lt;Integer&gt; tabs) {
385         if (length &gt; 0) {
386             throw new IllegalStateException(&quot;Cannot change tab size after appending text&quot;);
387         }
388         this.tabs = new TabStops(tabs);
389         return this;
390     }
391 
392     public AttributedStringBuilder styleMatches(Pattern pattern, AttributedStyle s) {
393         Matcher matcher = pattern.matcher(this);
394         while (matcher.find()) {
395             for (int i = matcher.start(); i &lt; matcher.end(); i++) {
396                 style[i] = (style[i] &amp; ~s.getMask()) | s.getStyle();
397             }
398         }
399         return this;
400     }
401 
402     public AttributedStringBuilder styleMatches(Pattern pattern, List&lt;AttributedStyle&gt; styles) {
403         Matcher matcher = pattern.matcher(this);
404         while (matcher.find()) {
405             for (int group = 0; group &lt; matcher.groupCount(); group++) {
406                 AttributedStyle s = styles.get(group);
407                 for (int i = matcher.start(group + 1); i &lt; matcher.end(group + 1); i++) {
408                     style[i] = (style[i] &amp; ~s.getMask()) | s.getStyle();
409                 }
410             }
411         }
412         return this;
413     }
414 
415     private class TabStops {
416         private List&lt;Integer&gt; tabs = new ArrayList&lt;&gt;();
417         private int lastStop = 0;
418         private int lastSize = 0;
419 
420         public TabStops(int tabs) {
421             this.lastSize = tabs;
422         }
423 
424         public TabStops(List&lt;Integer&gt; tabs) {
425             this.tabs = tabs;
426             int p = 0;
427             for (int s: tabs) {
428                 if (s &lt;= p) {
429                     continue;
430                 }
431                 lastStop = s;
432                 lastSize = s - p;
433                 p = s;
434             }
435         }
436 
437         boolean defined() {
438             return lastSize &gt; 0;
439         }
440 
441         int spaces(int lastLineLength) {
442             int out = 0;
443             if (lastLineLength &gt;= lastStop) {
444                 out = lastSize - (lastLineLength - lastStop) % lastSize;
445             } else {
446                 for (int s: tabs) {
447                     if (s &gt; lastLineLength) {
448                         out = s - lastLineLength;
449                         break;
450                     }
451                 }
452             }
453             return out;
454         }
455 
456     }
457 
458 }
    </pre>
  </body>
</html>
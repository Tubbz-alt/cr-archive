<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedCharSequence.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../terminal/spi/Pty.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttributedString.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedCharSequence.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002-2016, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.ArrayList;
 12 import java.util.List;
 13 
 14 import jdk.internal.org.jline.terminal.Terminal;
 15 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
 16 import jdk.internal.org.jline.utils.InfoCmp.Capability;
 17 
 18 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR;
 19 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR_EXP;
 20 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR;
 21 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR_EXP;
 22 import static jdk.internal.org.jline.utils.AttributedStyle.F_BACKGROUND;
 23 import static jdk.internal.org.jline.utils.AttributedStyle.F_BLINK;
 24 import static jdk.internal.org.jline.utils.AttributedStyle.F_BOLD;
 25 import static jdk.internal.org.jline.utils.AttributedStyle.F_CONCEAL;
 26 import static jdk.internal.org.jline.utils.AttributedStyle.F_CROSSED_OUT;
 27 import static jdk.internal.org.jline.utils.AttributedStyle.F_FAINT;
 28 import static jdk.internal.org.jline.utils.AttributedStyle.F_FOREGROUND;
 29 import static jdk.internal.org.jline.utils.AttributedStyle.F_INVERSE;
 30 import static jdk.internal.org.jline.utils.AttributedStyle.F_ITALIC;
 31 import static jdk.internal.org.jline.utils.AttributedStyle.F_UNDERLINE;
 32 import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;
 33 import static jdk.internal.org.jline.utils.AttributedStyle.MASK;
 34 import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;
 35 
 36 public abstract class AttributedCharSequence implements CharSequence {
 37 
 38     // cache the value here as we can&#39;t afford to get it each time
 39     static final boolean DISABLE_ALTERNATE_CHARSET = Boolean.getBoolean(PROP_DISABLE_ALTERNATE_CHARSET);
 40 








 41     public String toAnsi() {
 42         return toAnsi(null);
 43     }
 44 
 45     public String toAnsi(Terminal terminal) {
 46         if (terminal != null &amp;&amp; Terminal.TYPE_DUMB.equals(terminal.getType())) {
 47             return toString();
 48         }
 49         int colors = 256;
 50         boolean force256colors = false;
 51         String alternateIn = null, alternateOut = null;
 52         if (terminal != null) {
 53             Integer max_colors = terminal.getNumericCapability(Capability.max_colors);
 54             if (max_colors != null) {
 55                 colors = max_colors;
 56             }
<span class="line-modified"> 57             force256colors = AbstractWindowsTerminal.TYPE_WINDOWS_256_COLOR.equals(terminal.getType());</span>

 58             if (!DISABLE_ALTERNATE_CHARSET) {
 59                 alternateIn = Curses.tputs(terminal.getStringCapability(Capability.enter_alt_charset_mode));
 60                 alternateOut = Curses.tputs(terminal.getStringCapability(Capability.exit_alt_charset_mode));
 61             }
 62         }
 63         return toAnsi(colors, force256colors, alternateIn, alternateOut);
 64     }
 65 
 66     public String toAnsi(int colors, boolean force256colors) {
 67         return toAnsi(colors, force256colors, null, null);
 68     }
 69 
 70     public String toAnsi(int colors, boolean force256colors, String altIn, String altOut) {
 71         StringBuilder sb = new StringBuilder();
 72         int style = 0;
 73         int foreground = -1;
 74         int background = -1;
 75         boolean alt = false;
 76         for (int i = 0; i &lt; length(); i++) {
 77             char c = charAt(i);
</pre>
<hr />
<pre>
276         int cols = 0;
277         int len = length();
278         for (int cur = 0; cur &lt; len; ) {
279             int cp = codePointAt(cur);
280             if (!isHidden(cur))
281                 cols += WCWidth.wcwidth(cp);
282             cur += Character.charCount(cp);
283         }
284         return cols;
285     }
286 
287     public AttributedString columnSubSequence(int start, int stop) {
288         int begin = 0;
289         int col = 0;
290         while (begin &lt; this.length()) {
291             int cp = codePointAt(begin);
292             int w = isHidden(begin) ? 0 : WCWidth.wcwidth(cp);
293             if (col + w &gt; start) {
294                 break;
295             }
<span class="line-modified">296             begin++;</span>
297             col += w;
298         }
299         int end = begin;
300         while (end &lt; this.length()) {
301             int cp = codePointAt(end);
302             if (cp == &#39;\n&#39;)
303                 break;
304             int w = isHidden(end) ? 0 : WCWidth.wcwidth(cp);
305             if (col + w &gt; stop) {
306                 break;
307             }
<span class="line-modified">308             end++;</span>
309             col += w;
310         }
311         return subSequence(begin, end);
312     }
313 
314     public List&lt;AttributedString&gt; columnSplitLength(int columns) {
315         return columnSplitLength(columns, false, true);
316     }
317 
318     public List&lt;AttributedString&gt; columnSplitLength(int columns, boolean includeNewlines, boolean delayLineWrap) {
319         List&lt;AttributedString&gt; strings = new ArrayList&lt;&gt;();
320         int cur = 0;
321         int beg = cur;
322         int col = 0;
323         while (cur &lt; length()) {
324             int cp = codePointAt(cur);
325             int w = isHidden(cur) ? 0 : WCWidth.wcwidth(cp);
326             if (cp == &#39;\n&#39;) {
327                 strings.add(subSequence(beg, includeNewlines ? cur+1 : cur));
328                 beg = cur + 1;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002-2019, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * https://opensource.org/licenses/BSD-3-Clause</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.ArrayList;
 12 import java.util.List;
 13 
 14 import jdk.internal.org.jline.terminal.Terminal;
 15 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
 16 import jdk.internal.org.jline.utils.InfoCmp.Capability;
 17 
 18 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR;
 19 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR_EXP;
 20 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR;
 21 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR_EXP;
 22 import static jdk.internal.org.jline.utils.AttributedStyle.F_BACKGROUND;
 23 import static jdk.internal.org.jline.utils.AttributedStyle.F_BLINK;
 24 import static jdk.internal.org.jline.utils.AttributedStyle.F_BOLD;
 25 import static jdk.internal.org.jline.utils.AttributedStyle.F_CONCEAL;
 26 import static jdk.internal.org.jline.utils.AttributedStyle.F_CROSSED_OUT;
 27 import static jdk.internal.org.jline.utils.AttributedStyle.F_FAINT;
 28 import static jdk.internal.org.jline.utils.AttributedStyle.F_FOREGROUND;
 29 import static jdk.internal.org.jline.utils.AttributedStyle.F_INVERSE;
 30 import static jdk.internal.org.jline.utils.AttributedStyle.F_ITALIC;
 31 import static jdk.internal.org.jline.utils.AttributedStyle.F_UNDERLINE;
 32 import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;
 33 import static jdk.internal.org.jline.utils.AttributedStyle.MASK;
 34 import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;
 35 
 36 public abstract class AttributedCharSequence implements CharSequence {
 37 
 38     // cache the value here as we can&#39;t afford to get it each time
 39     static final boolean DISABLE_ALTERNATE_CHARSET = Boolean.getBoolean(PROP_DISABLE_ALTERNATE_CHARSET);
 40 
<span class="line-added"> 41     public void print(Terminal terminal) {</span>
<span class="line-added"> 42         terminal.writer().print(toAnsi(terminal));</span>
<span class="line-added"> 43     }</span>
<span class="line-added"> 44 </span>
<span class="line-added"> 45     public void println(Terminal terminal) {</span>
<span class="line-added"> 46         terminal.writer().println(toAnsi(terminal));</span>
<span class="line-added"> 47     }</span>
<span class="line-added"> 48 </span>
 49     public String toAnsi() {
 50         return toAnsi(null);
 51     }
 52 
 53     public String toAnsi(Terminal terminal) {
 54         if (terminal != null &amp;&amp; Terminal.TYPE_DUMB.equals(terminal.getType())) {
 55             return toString();
 56         }
 57         int colors = 256;
 58         boolean force256colors = false;
 59         String alternateIn = null, alternateOut = null;
 60         if (terminal != null) {
 61             Integer max_colors = terminal.getNumericCapability(Capability.max_colors);
 62             if (max_colors != null) {
 63                 colors = max_colors;
 64             }
<span class="line-modified"> 65             force256colors = AbstractWindowsTerminal.TYPE_WINDOWS_256_COLOR.equals(terminal.getType())</span>
<span class="line-added"> 66                 || AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType());</span>
 67             if (!DISABLE_ALTERNATE_CHARSET) {
 68                 alternateIn = Curses.tputs(terminal.getStringCapability(Capability.enter_alt_charset_mode));
 69                 alternateOut = Curses.tputs(terminal.getStringCapability(Capability.exit_alt_charset_mode));
 70             }
 71         }
 72         return toAnsi(colors, force256colors, alternateIn, alternateOut);
 73     }
 74 
 75     public String toAnsi(int colors, boolean force256colors) {
 76         return toAnsi(colors, force256colors, null, null);
 77     }
 78 
 79     public String toAnsi(int colors, boolean force256colors, String altIn, String altOut) {
 80         StringBuilder sb = new StringBuilder();
 81         int style = 0;
 82         int foreground = -1;
 83         int background = -1;
 84         boolean alt = false;
 85         for (int i = 0; i &lt; length(); i++) {
 86             char c = charAt(i);
</pre>
<hr />
<pre>
285         int cols = 0;
286         int len = length();
287         for (int cur = 0; cur &lt; len; ) {
288             int cp = codePointAt(cur);
289             if (!isHidden(cur))
290                 cols += WCWidth.wcwidth(cp);
291             cur += Character.charCount(cp);
292         }
293         return cols;
294     }
295 
296     public AttributedString columnSubSequence(int start, int stop) {
297         int begin = 0;
298         int col = 0;
299         while (begin &lt; this.length()) {
300             int cp = codePointAt(begin);
301             int w = isHidden(begin) ? 0 : WCWidth.wcwidth(cp);
302             if (col + w &gt; start) {
303                 break;
304             }
<span class="line-modified">305             begin += Character.charCount(cp);</span>
306             col += w;
307         }
308         int end = begin;
309         while (end &lt; this.length()) {
310             int cp = codePointAt(end);
311             if (cp == &#39;\n&#39;)
312                 break;
313             int w = isHidden(end) ? 0 : WCWidth.wcwidth(cp);
314             if (col + w &gt; stop) {
315                 break;
316             }
<span class="line-modified">317             end += Character.charCount(cp);</span>
318             col += w;
319         }
320         return subSequence(begin, end);
321     }
322 
323     public List&lt;AttributedString&gt; columnSplitLength(int columns) {
324         return columnSplitLength(columns, false, true);
325     }
326 
327     public List&lt;AttributedString&gt; columnSplitLength(int columns, boolean includeNewlines, boolean delayLineWrap) {
328         List&lt;AttributedString&gt; strings = new ArrayList&lt;&gt;();
329         int cur = 0;
330         int beg = cur;
331         int col = 0;
332         while (cur &lt; length()) {
333             int cp = codePointAt(cur);
334             int w = isHidden(cur) ? 0 : WCWidth.wcwidth(cp);
335             if (cp == &#39;\n&#39;) {
336                 strings.add(subSequence(beg, includeNewlines ? cur+1 : cur));
337                 beg = cur + 1;
</pre>
</td>
</tr>
</table>
<center><a href="../terminal/spi/Pty.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttributedString.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedString.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="1" id="anc1"></a><span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.security.InvalidParameterException;
 12 import java.util.Arrays;
<a name="2" id="anc2"></a>
 13 import java.util.Objects;
 14 import java.util.regex.Matcher;
 15 import java.util.regex.Pattern;
 16 
 17 /**
 18  * Attributed string.
 19  * Instances of this class are immutables.
 20  * Substrings are created without any memory copy.
 21  *
 22  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 23  */
 24 public class AttributedString extends AttributedCharSequence {
 25 
 26     final char[] buffer;
 27     final int[] style;
 28     final int start;
 29     final int end;
 30     public static final AttributedString EMPTY = new AttributedString(&quot;&quot;);
 31     public static final AttributedString NEWLINE = new AttributedString(&quot;\n&quot;);
 32 
 33     public AttributedString(CharSequence str) {
 34         this(str, 0, str.length(), null);
 35     }
 36 
 37     public AttributedString(CharSequence str, int start, int end) {
 38         this(str, start, end, null);
 39     }
 40 
 41     public AttributedString(CharSequence str, AttributedStyle s) {
 42         this(str, 0, str.length(), s);
 43     }
 44 
 45     public AttributedString(CharSequence str, int start, int end, AttributedStyle s) {
 46         if (end &lt; start) {
 47             throw new InvalidParameterException();
 48         }
 49         if (str instanceof AttributedString) {
 50             AttributedString as = (AttributedString) str;
 51             this.buffer = as.buffer;
 52             if (s != null) {
 53                 this.style = as.style.clone();
 54                 for (int i = 0; i &lt; style.length; i++) {
 55                     this.style[i] = (this.style[i] &amp; ~s.getMask()) | s.getStyle();
 56                 }
 57             } else {
 58                 this.style = as.style;
 59             }
 60             this.start = as.start + start;
 61             this.end = as.start + end;
 62         } else if (str instanceof AttributedStringBuilder) {
 63             AttributedStringBuilder asb = (AttributedStringBuilder) str;
 64             AttributedString as = asb.subSequence(start, end);
 65             this.buffer = as.buffer;
 66             this.style = as.style;
 67             if (s != null) {
 68                 for (int i = 0; i &lt; style.length; i++) {
 69                     this.style[i] = (this.style[i] &amp; ~s.getMask()) | s.getStyle();
 70                 }
 71             }
 72             this.start = as.start;
 73             this.end = as.end;
 74         } else {
 75             int l = end - start;
 76             buffer = new char[l];
 77             for (int i = 0; i &lt; l; i++) {
 78                 buffer[i] = str.charAt(start + i);
 79             }
 80             style = new int[l];
 81             if (s != null) {
 82                 Arrays.fill(style, s.getStyle());
 83             }
 84             this.start = 0;
 85             this.end = l;
 86         }
 87     }
 88 
 89     AttributedString(char[] buffer, int[] style, int start, int end) {
 90         this.buffer = buffer;
 91         this.style = style;
 92         this.start = start;
 93         this.end = end;
 94     }
 95 
 96     public static AttributedString fromAnsi(String ansi) {
 97         return fromAnsi(ansi, 0);
 98     }
 99 
100     public static AttributedString fromAnsi(String ansi, int tabs) {
<a name="3" id="anc3"></a>



101         if (ansi == null) {
102             return null;
103         }
104         return new AttributedStringBuilder(ansi.length())
105                 .tabs(tabs)
106                 .ansiAppend(ansi)
107                 .toAttributedString();
108     }
109 
110     public static String stripAnsi(String ansi) {
111         if (ansi == null) {
112             return null;
113         }
114         return new AttributedStringBuilder(ansi.length())
115                 .ansiAppend(ansi)
116                 .toString();
117     }
118 
119     @Override
120     protected char[] buffer() {
121         return buffer;
122     }
123 
124     @Override
125     protected int offset() {
126         return start;
127     }
128 
129     @Override
130     public int length() {
131         return end - start;
132     }
133 
134     @Override
135     public AttributedStyle styleAt(int index) {
136         return new AttributedStyle(style[start + index], style[start + index]);
137     }
138 
139     @Override
140     int styleCodeAt(int index) {
141         return style[start + index];
142     }
143 
144     @Override
145     public AttributedString subSequence(int start, int end) {
146         return new AttributedString(this, start, end);
147     }
148 
149     public AttributedString styleMatches(Pattern pattern, AttributedStyle style) {
150         Matcher matcher = pattern.matcher(this);
151         boolean result = matcher.find();
152         if (result) {
153             int[] newstyle = this.style.clone();
154             do {
155                 for (int i = matcher.start(); i &lt; matcher.end(); i++) {
156                     newstyle[this.start + i] = (newstyle[this.start + i] &amp; ~style.getMask()) | style.getStyle();
157                 }
158                 result = matcher.find();
159             } while (result);
160             return new AttributedString(buffer, newstyle, start , end);
161         }
162         return this;
163     }
164 
165     @Override
166     public boolean equals(Object o) {
167         if (this == o) return true;
168         if (o == null || getClass() != o.getClass()) return false;
169         AttributedString that = (AttributedString) o;
170         return end - start == that.end - that.start
171                 &amp;&amp; arrEq(buffer, that.buffer, start, that.start, end - start)
172                 &amp;&amp; arrEq(style, that.style, start, that.start, end - start);
173     }
174 
175     private boolean arrEq(char[] a1, char[] a2, int s1, int s2, int l) {
176         for (int i = 0; i &lt; l; i++) {
177             if (a1[s1+i] != a2[s2+i]) {
178                 return false;
179             }
180         }
181         return true;
182     }
183     private boolean arrEq(int[] a1, int[] a2, int s1, int s2, int l) {
184         for (int i = 0; i &lt; l; i++) {
185             if (a1[s1+i] != a2[s2+i]) {
186                 return false;
187             }
188         }
189         return true;
190     }
191 
192     @Override
193     public int hashCode() {
194         int result = Arrays.hashCode(buffer);
195         result = 31 * result + Arrays.hashCode(style);
196         result = 31 * result + start;
197         result = 31 * result + end;
198         return result;
199     }
200 
201     public static AttributedString join(AttributedString delimiter, AttributedString... elements) {
202         Objects.requireNonNull(delimiter);
203         Objects.requireNonNull(elements);
204         return join(delimiter, Arrays.asList(elements));
205     }
206 
207     public static AttributedString join(AttributedString delimiter, Iterable&lt;AttributedString&gt; elements) {
208         Objects.requireNonNull(elements);
209         AttributedStringBuilder sb = new AttributedStringBuilder();
210         int i = 0;
211         for (AttributedString str : elements) {
212             if (i++ &gt; 0 &amp;&amp; delimiter != null) {
213                 sb.append(delimiter);
214             }
215             sb.append(str);
216         }
217         return sb.toAttributedString();
218     }
219 
220 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
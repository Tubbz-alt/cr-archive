<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/KillRing.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="1" id="anc1"></a><span class="line-modified">  7  * https://opensource.org/licenses/BSD-3-Clause</span>
  8  */
  9 package jdk.internal.org.jline.reader.impl;
 10 
 11 /**
 12  * The kill ring class keeps killed text in a fixed size ring. In this
 13  * class we also keep record of whether or not the last command was a
 14  * kill or a yank. Depending on this, the class may behave
 15  * different. For instance, two consecutive kill-word commands fill
 16  * the same slot such that the next yank will return the two
 17  * previously killed words instead that only the last one. Likewise
 18  * yank pop requires that the previous command was either a yank or a
 19  * yank-pop.
 20  */
 21 public final class KillRing {
 22 
 23     /**
 24      * Default size is 60, like in emacs.
 25      */
 26     private static final int DEFAULT_SIZE = 60;
 27 
 28     private final String[] slots;
 29     private int head = 0;
 30     private boolean lastKill = false;
 31     private boolean lastYank = false;
 32 
 33     /**
 34      * Creates a new kill ring of the given size.
 35      *
 36      * @param size the size of the ring
 37      */
 38     public KillRing(int size) {
 39         slots = new String[size];
 40     }
 41 
 42     /**
 43      * Creates a new kill ring of the default size. See {@link #DEFAULT_SIZE}.
 44      */
 45     public KillRing() {
 46         this(DEFAULT_SIZE);
 47     }
 48 
 49     /**
 50      * Resets the last-yank state.
 51      */
 52     public void resetLastYank() {
 53         lastYank = false;
 54     }
 55 
 56     /**
 57      * Resets the last-kill state.
 58      */
 59     public void resetLastKill() {
 60         lastKill = false;
 61     }
 62 
 63     /**
 64      * Returns {@code true} if the last command was a yank.
 65      * @return {@code true} if the last command was a yank
 66      */
 67     public boolean lastYank() {
 68         return lastYank;
 69     }
 70 
 71     /**
 72      * Adds the string to the kill-ring. Also sets lastYank to false
 73      * and lastKill to true.
 74      * @param str the string to add
 75      */
 76     public void add(String str) {
 77         lastYank = false;
 78 
 79         if (lastKill) {
 80             if (slots[head] != null) {
 81                 slots[head] += str;
 82                 return;
 83             }
 84         }
 85 
 86         lastKill = true;
 87         next();
 88         slots[head] = str;
 89     }
 90 
 91     /**
 92      * Adds the string to the kill-ring product of killing
 93      * backwards. If the previous command was a kill text one then
 94      * adds the text at the beginning of the previous kill to avoid
 95      * that two consecutive backwards kills followed by a yank leaves
 96      * things reversed.
 97      * @param str the string to add
 98      */
 99     public void addBackwards(String str) {
100         lastYank = false;
101 
102         if (lastKill) {
103             if (slots[head] != null) {
104                 slots[head] = str + slots[head];
105                 return;
106             }
107         }
108 
109         lastKill = true;
110         next();
111         slots[head] = str;
112     }
113 
114     /**
115      * Yanks a previously killed text. Returns {@code null} if the
116      * ring is empty.
117      * @return the text in the current position
118      */
119     public String yank() {
120         lastKill = false;
121         lastYank = true;
122         return slots[head];
123     }
124 
125     /**
126      * Moves the pointer to the current slot back and returns the text
127      * in that position. If the previous command was not yank returns
128      * null.
129      * @return the text in the previous position
130      */
131     public String yankPop() {
132         lastKill = false;
133         if (lastYank) {
134             prev();
135             return slots[head];
136         }
137         return null;
138     }
139 
140     /**
141      * Moves the pointer to the current slot forward. If the end of
142      * the slots is reached then points back to the beginning.
143      */
144     private void next() {
145         if (head == 0 &amp;&amp; slots[0] == null) {
146             return;
147         }
148         head++;
149         if (head == slots.length) {
150             head = 0;
151         }
152     }
153 
154     /**
155      * Moves the pointer to the current slot backwards. If the
156      * beginning of the slots is reached then traverses the slot
157      * backwards until one with not null content is found.
158      */
159     private void prev() {
160         head--;
161         if (head == -1) {
162             int x = (slots.length - 1);
163             for (; x &gt;= 0; x--) {
164                 if (slots[x] != null) {
165                     break;
166                 }
167             }
168             head = x;
169         }
170     }
171 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
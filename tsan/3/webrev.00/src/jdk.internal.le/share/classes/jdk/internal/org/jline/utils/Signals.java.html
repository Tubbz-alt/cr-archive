<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/Signals.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.lang.reflect.Constructor;
 12 import java.lang.reflect.Proxy;
 13 import java.util.Objects;
 14 
 15 /**
 16  * Signals helpers.
 17  *
 18  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 19  * @since 3.0
 20  */
 21 public final class Signals {
 22 
 23     private Signals() {
 24     }
 25 
 26     /**
 27      *
 28      * @param name the signal, CONT, STOP, etc...
 29      * @param handler the callback to run
 30      *
 31      * @return an object that needs to be passed to the {@link #unregister(String, Object)}
 32      *         method to unregister the handler
 33      */
 34     public static Object register(String name, Runnable handler) {
 35         Objects.requireNonNull(handler);
 36         return register(name, handler, handler.getClass().getClassLoader());
 37     }
 38 
 39     public static Object register(String name, final Runnable handler, ClassLoader loader) {
 40         try {
 41             Class&lt;?&gt; signalHandlerClass = Class.forName(&quot;sun.misc.SignalHandler&quot;);
 42             // Implement signal handler
 43             Object signalHandler = Proxy.newProxyInstance(loader,
 44                     new Class&lt;?&gt;[]{signalHandlerClass}, (proxy, method, args) -&gt; {
 45                         // only method we are proxying is handle()
 46                         if (method.getDeclaringClass() == Object.class) {
 47                             if (&quot;toString&quot;.equals(method.getName())) {
 48                                 return handler.toString();
 49                             }
 50                         } else if (method.getDeclaringClass() == signalHandlerClass) {
 51                             Log.trace(() -&gt; &quot;Calling handler &quot; + toString(handler) + &quot; for signal &quot; + name);
 52                             handler.run();
 53                         }
 54                         return null;
 55                     });
 56             return doRegister(name, signalHandler);
 57         } catch (Exception e) {
 58             // Ignore this one too, if the above failed, the signal API is incompatible with what we&#39;re expecting
 59             Log.debug(&quot;Error registering handler for signal &quot;, name, e);
 60             return null;
 61         }
 62     }
 63 
 64     public static Object registerDefault(String name) {
 65         try {
 66             Class&lt;?&gt; signalHandlerClass = Class.forName(&quot;sun.misc.SignalHandler&quot;);
 67             return doRegister(name, signalHandlerClass.getField(&quot;SIG_DFL&quot;).get(null));
 68         } catch (Exception e) {
 69             // Ignore this one too, if the above failed, the signal API is incompatible with what we&#39;re expecting
 70             Log.debug(&quot;Error registering default handler for signal &quot;, name, e);
 71             return null;
 72         }
 73     }
 74 
 75     public static void unregister(String name, Object previous) {
 76         try {
 77             // We should make sure the current signal is the one we registered
 78             if (previous != null) {
 79                 doRegister(name, previous);
 80             }
 81         } catch (Exception e) {
 82             // Ignore
 83             Log.debug(&quot;Error unregistering handler for signal &quot;, name, e);
 84         }
 85     }
 86 
 87     private static Object doRegister(String name, Object handler) throws Exception {
 88         Log.trace(() -&gt; &quot;Registering signal &quot; + name + &quot; with handler &quot; + toString(handler));
 89         Class&lt;?&gt; signalClass = Class.forName(&quot;sun.misc.Signal&quot;);
 90         Constructor&lt;?&gt; constructor = signalClass.getConstructor(String.class);
 91         Object signal;
 92         try {
 93             signal = constructor.newInstance(name);
 94         } catch (IllegalArgumentException e) {
 95             Log.trace(() -&gt; &quot;Ignoring unsupported signal &quot; + name);
 96             return null;
 97         }
 98         Class&lt;?&gt; signalHandlerClass = Class.forName(&quot;sun.misc.SignalHandler&quot;);
 99         return signalClass.getMethod(&quot;handle&quot;, signalClass, signalHandlerClass)
100                 .invoke(null, signal, handler);
101     }
102 
103     @SuppressWarnings(&quot;&quot;)
104     private static String toString(Object handler) {
105         try {
106             Class&lt;?&gt; signalHandlerClass = Class.forName(&quot;sun.misc.SignalHandler&quot;);
107             if (handler == signalHandlerClass.getField(&quot;SIG_DFL&quot;).get(null)) {
108                 return &quot;SIG_DFL&quot;;
109             }
110             if (handler == signalHandlerClass.getField(&quot;SIG_IGN&quot;).get(null)) {
111                 return &quot;SIG_IGN&quot;;
112             }
113         } catch (Throwable t) {
114             // ignore
115         }
116         return handler != null ? handler.toString() : &quot;null&quot;;
117     }
118 
119 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/InputStreamReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="1" id="anc1"></a><span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.io.IOException;
 12 import java.io.InputStream;
 13 import java.io.OutputStreamWriter;
 14 import java.io.Reader;
 15 import java.io.UnsupportedEncodingException;
 16 import java.nio.ByteBuffer;
 17 import java.nio.CharBuffer;
 18 import java.nio.charset.Charset;
 19 import java.nio.charset.CharsetDecoder;
 20 import java.nio.charset.CoderResult;
 21 import java.nio.charset.CodingErrorAction;
 22 import java.nio.charset.MalformedInputException;
 23 import java.nio.charset.UnmappableCharacterException;
 24 
 25 
 26 /**
 27  *
 28  * NOTE for JLine: the default InputStreamReader that comes from the JRE
 29  * usually read more bytes than needed from the input stream, which
 30  * is not usable in a character per character model used in the terminal.
 31  * We thus use the harmony code which only reads the minimal number of bytes.
 32  */
 33 
 34 /**
 35  * A class for turning a byte stream into a character stream. Data read from the
 36  * source input stream is converted into characters by either a default or a
 37  * provided character converter. The default encoding is taken from the
 38  * &quot;file.encoding&quot; system property. {@code InputStreamReader} contains a buffer
 39  * of bytes read from the source stream and converts these into characters as
 40  * needed. The buffer size is 8K.
 41  *
 42  * @see OutputStreamWriter
 43  */
 44 public class InputStreamReader extends Reader {
 45     private InputStream in;
 46 
 47     private static final int BUFFER_SIZE = 4;
 48 
 49     private boolean endOfInput = false;
 50 
 51     CharsetDecoder decoder;
 52 
 53     ByteBuffer bytes = ByteBuffer.allocate(BUFFER_SIZE);
 54 
 55     char pending = (char) -1;
 56 
 57     /**
 58      * Constructs a new {@code InputStreamReader} on the {@link InputStream}
 59      * {@code in}. This constructor sets the character converter to the encoding
 60      * specified in the &quot;file.encoding&quot; property and falls back to ISO 8859_1
 61      * (ISO-Latin-1) if the property doesn&#39;t exist.
 62      *
 63      * @param in
 64      *            the input stream from which to read characters.
 65      */
 66     public InputStreamReader(InputStream in) {
 67         super(in);
 68         this.in = in;
 69         decoder = Charset.defaultCharset().newDecoder().onMalformedInput(
 70                 CodingErrorAction.REPLACE).onUnmappableCharacter(
 71                 CodingErrorAction.REPLACE);
 72         bytes.limit(0);
 73     }
 74 
 75     /**
 76      * Constructs a new InputStreamReader on the InputStream {@code in}. The
 77      * character converter that is used to decode bytes into characters is
 78      * identified by name by {@code enc}. If the encoding cannot be found, an
 79      * UnsupportedEncodingException error is thrown.
 80      *
 81      * @param in
 82      *            the InputStream from which to read characters.
 83      * @param enc
 84      *            identifies the character converter to use.
 85      * @throws NullPointerException
 86      *             if {@code enc} is {@code null}.
 87      * @throws UnsupportedEncodingException
 88      *             if the encoding specified by {@code enc} cannot be found.
 89      */
 90     public InputStreamReader(InputStream in, final String enc)
 91             throws UnsupportedEncodingException {
 92         super(in);
 93         if (enc == null) {
 94             throw new NullPointerException();
 95         }
 96         this.in = in;
 97         try {
 98             decoder = Charset.forName(enc).newDecoder().onMalformedInput(
 99                     CodingErrorAction.REPLACE).onUnmappableCharacter(
100                     CodingErrorAction.REPLACE);
101         } catch (IllegalArgumentException e) {
102             throw (UnsupportedEncodingException)
103                     new UnsupportedEncodingException(enc).initCause(e);
104         }
105         bytes.limit(0);
106     }
107 
108     /**
109      * Constructs a new InputStreamReader on the InputStream {@code in} and
110      * CharsetDecoder {@code dec}.
111      *
112      * @param in
113      *            the source InputStream from which to read characters.
114      * @param dec
115      *            the CharsetDecoder used by the character conversion.
116      */
117     public InputStreamReader(InputStream in, CharsetDecoder dec) {
118         super(in);
119         dec.averageCharsPerByte();
120         this.in = in;
121         decoder = dec;
122         bytes.limit(0);
123     }
124 
125     /**
126      * Constructs a new InputStreamReader on the InputStream {@code in} and
127      * Charset {@code charset}.
128      *
129      * @param in
130      *            the source InputStream from which to read characters.
131      * @param charset
132      *            the Charset that defines the character converter
133      */
134     public InputStreamReader(InputStream in, Charset charset) {
135         super(in);
136         this.in = in;
137         decoder = charset.newDecoder().onMalformedInput(
138                 CodingErrorAction.REPLACE).onUnmappableCharacter(
139                 CodingErrorAction.REPLACE);
140         bytes.limit(0);
141     }
142 
143     /**
144      * Closes this reader. This implementation closes the source InputStream and
145      * releases all local storage.
146      *
147      * @throws IOException
148      *             if an error occurs attempting to close this reader.
149      */
150     @Override
151     public void close() throws IOException {
152         synchronized (lock) {
153             decoder = null;
154             if (in != null) {
155                 in.close();
156                 in = null;
157             }
158         }
159     }
160 
161     /**
162      * Returns the name of the encoding used to convert bytes into characters.
163      * The value {@code null} is returned if this reader has been closed.
164      *
165      * @return the name of the character converter or {@code null} if this
166      *         reader is closed.
167      */
168     public String getEncoding() {
169         if (!isOpen()) {
170             return null;
171         }
172         return decoder.charset().name();
173     }
174 
175     /**
176      * Reads a single character from this reader and returns it as an integer
177      * with the two higher-order bytes set to 0. Returns -1 if the end of the
178      * reader has been reached. The byte value is either obtained from
179      * converting bytes in this reader&#39;s buffer or by first filling the buffer
180      * from the source InputStream and then reading from the buffer.
181      *
182      * @return the character read or -1 if the end of the reader has been
183      *         reached.
184      * @throws IOException
185      *             if this reader is closed or some other I/O error occurs.
186      */
187     @Override
188     public int read() throws IOException {
189         synchronized (lock) {
190             if (!isOpen()) {
191                 throw new ClosedException(&quot;InputStreamReader is closed.&quot;);
192             }
193 
194             if (pending != (char) -1) {
195                 char c = pending;
196                 pending = (char) -1;
197                 return c;
198             }
199             char buf[] = new char[2];
200             int nb = read(buf, 0, 2);
201             if (nb == 2) {
202                 pending = buf[1];
203             }
204             if (nb &gt; 0) {
205                 return buf[0];
206             } else {
207                 return -1;
208             }
209         }
210     }
211 
212     /**
213      * Reads at most {@code length} characters from this reader and stores them
214      * at position {@code offset} in the character array {@code buf}. Returns
215      * the number of characters actually read or -1 if the end of the reader has
216      * been reached. The bytes are either obtained from converting bytes in this
217      * reader&#39;s buffer or by first filling the buffer from the source
218      * InputStream and then reading from the buffer.
219      *
220      * @param buf
221      *            the array to store the characters read.
222      * @param offset
223      *            the initial position in {@code buf} to store the characters
224      *            read from this reader.
225      * @param length
226      *            the maximum number of characters to read.
227      * @return the number of characters read or -1 if the end of the reader has
228      *         been reached.
229      * @throws IndexOutOfBoundsException
230      *             if {@code offset &lt; 0} or {@code length &lt; 0}, or if
231      *             {@code offset + length} is greater than the length of
232      *             {@code buf}.
233      * @throws IOException
234      *             if this reader is closed or some other I/O error occurs.
235      */
236     @Override
237     public int read(char[] buf, int offset, int length) throws IOException {
238         synchronized (lock) {
239             if (!isOpen()) {
240                 throw new IOException(&quot;InputStreamReader is closed.&quot;);
241             }
242             if (offset &lt; 0 || offset &gt; buf.length - length || length &lt; 0) {
243                 throw new IndexOutOfBoundsException();
244             }
245             if (length == 0) {
246                 return 0;
247             }
248 
249             CharBuffer out = CharBuffer.wrap(buf, offset, length);
250             CoderResult result = CoderResult.UNDERFLOW;
251 
252             // bytes.remaining() indicates number of bytes in buffer
253             // when 1-st time entered, it&#39;ll be equal to zero
254             boolean needInput = !bytes.hasRemaining();
255 
256             while (out.position() == offset) {
257                 // fill the buffer if needed
258                 if (needInput) {
259                     try {
260                         if ((in.available() == 0)
261                             &amp;&amp; (out.position() &gt; offset)) {
262                             // we could return the result without blocking read
263                             break;
264                         }
265                     } catch (IOException e) {
266                         // available didn&#39;t work so just try the read
267                     }
268 
269                     int off = bytes.arrayOffset() + bytes.limit();
270                     int was_red = in.read(bytes.array(), off, 1);
271 
272                     if (was_red == -1) {
273                         endOfInput = true;
274                         break;
275                     } else if (was_red == 0) {
276                         break;
277                     }
278                     bytes.limit(bytes.limit() + was_red);
279                 }
280 
281                 // decode bytes
282                 result = decoder.decode(bytes, out, false);
283 
284                 if (result.isUnderflow()) {
285                     // compact the buffer if no space left
286                     if (bytes.limit() == bytes.capacity()) {
287                         bytes.compact();
288                         bytes.limit(bytes.position());
289                         bytes.position(0);
290                     }
291                     needInput = true;
292                 } else {
293                     break;
294                 }
295             }
296 
297             if (result == CoderResult.UNDERFLOW &amp;&amp; endOfInput) {
298                 result = decoder.decode(bytes, out, true);
299                 decoder.flush(out);
300                 decoder.reset();
301             }
302             if (result.isMalformed()) {
303                 throw new MalformedInputException(result.length());
304             } else if (result.isUnmappable()) {
305                 throw new UnmappableCharacterException(result.length());
306             }
307 
308             return out.position() - offset == 0 ? -1 : out.position() - offset;
309         }
310     }
311 
312     /*
313      * Answer a boolean indicating whether or not this InputStreamReader is
314      * open.
315      */
316     private boolean isOpen() {
317         return in != null;
318     }
319 
320     /**
321      * Indicates whether this reader is ready to be read without blocking. If
322      * the result is {@code true}, the next {@code read()} will not block. If
323      * the result is {@code false} then this reader may or may not block when
324      * {@code read()} is called. This implementation returns {@code true} if
325      * there are bytes available in the buffer or the source stream has bytes
326      * available.
327      *
328      * @return {@code true} if the receiver will not block when {@code read()}
329      *         is called, {@code false} if unknown or blocking will occur.
330      * @throws IOException
331      *             if this reader is closed or some other I/O error occurs.
332      */
333     @Override
334     public boolean ready() throws IOException {
335         synchronized (lock) {
336             if (in == null) {
337                 throw new IOException(&quot;InputStreamReader is closed.&quot;);
338             }
339             try {
340                 return bytes.hasRemaining() || in.available() &gt; 0;
341             } catch (IOException e) {
342                 return false;
343             }
344         }
345     }
346 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/StyleResolver.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="1" id="anc1"></a><span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.Locale;
 12 import java.util.function.Function;
 13 //import java.util.logging.Level;
 14 //import java.util.logging.Logger;
 15 
 16 import static java.util.Objects.requireNonNull;
 17 import static jdk.internal.org.jline.utils.AttributedStyle.*;
 18 
 19 // TODO: document style specification
 20 
 21 /**
 22  * Resolves named (or source-referenced) {@link AttributedStyle}.
 23  *
 24  * @since 3.6
 25  */
 26 public class StyleResolver {
 27 //    private static final Logger log = Logger.getLogger(StyleResolver.class.getName());
 28 
 29     private final Function&lt;String, String&gt; source;
 30 
 31     public StyleResolver(final Function&lt;String, String&gt; source) {
 32         this.source = requireNonNull(source);
 33     }
 34 
 35     /**
 36      * Returns the color identifier for the given name.
 37      * &lt;p&gt;
 38      * Bright color can be specified with: {@code !&lt;color&gt;} or {@code bright-&lt;color&gt;}.
 39      * &lt;p&gt;
 40      * Full xterm256 color can be specified with: {@code ~&lt;color&gt;}.
 41      *
 42      * @param name the name of the color
 43      * @return color code, or {@code null} if unable to determine.
 44      */
 45     private static Integer color(String name) {
 46         int flags = 0;
 47         name = name.toLowerCase(Locale.US);
 48 
 49         // extract bright flag from color name
 50         if (name.charAt(0) == &#39;!&#39;) {
 51             name = name.substring(1, name.length());
 52             flags = BRIGHT;
 53         } else if (name.startsWith(&quot;bright-&quot;)) {
 54             name = name.substring(7, name.length());
 55             flags = BRIGHT;
 56         } else if (name.charAt(0) == &#39;~&#39;) {
 57             try {
 58                 // TODO: if the palette is not the default one, should be
 59                 // TODO: translate into 24-bits first and let the #toAnsi() call
 60                 // TODO: round with the current palette ?
 61                 name = name.substring(1, name.length());
 62                 return Colors.rgbColor(name);
 63             } catch (IllegalArgumentException e) {
 64 //                log.warning(&quot;Invalid style-color name: &quot; + name);
 65                 return null;
 66             }
 67         }
 68 
 69         switch (name) {
 70             case &quot;black&quot;:
 71             case &quot;k&quot;:
 72                 return flags + BLACK;
 73 
 74             case &quot;red&quot;:
 75             case &quot;r&quot;:
 76                 return flags + RED;
 77 
 78             case &quot;green&quot;:
 79             case &quot;g&quot;:
 80                 return flags + GREEN;
 81 
 82             case &quot;yellow&quot;:
 83             case &quot;y&quot;:
 84                 return flags + YELLOW;
 85 
 86             case &quot;blue&quot;:
 87             case &quot;b&quot;:
 88                 return flags + BLUE;
 89 
 90             case &quot;magenta&quot;:
 91             case &quot;m&quot;:
 92                 return flags + MAGENTA;
 93 
 94             case &quot;cyan&quot;:
 95             case &quot;c&quot;:
 96                 return flags + CYAN;
 97 
 98             case &quot;white&quot;:
 99             case &quot;w&quot;:
100                 return flags + WHITE;
101         }
102 
103         return null;
104     }
105 
106     // TODO: could consider a small cache to reduce style calculations?
107 
108     /**
109      * Resolve the given style specification.
110      * &lt;p&gt;
111      * If for some reason the specification is invalid, then {@link AttributedStyle#DEFAULT} will be used.
112      *
113      * @param spec the specification
114      * @return the style
115      */
116     public AttributedStyle resolve(final String spec) {
117         requireNonNull(spec);
118 
119 //        if (log.isLoggable(Level.FINEST)) {
120 //            log.finest(&quot;Resolve: &quot; + spec);
121 //        }
122 
123         int i = spec.indexOf(&quot;:-&quot;);
124         if (i != -1) {
125             String[] parts = spec.split(&quot;:-&quot;);
126             return resolve(parts[0].trim(), parts[1].trim());
127         }
128 
129         return apply(DEFAULT, spec);
130     }
131 
132     /**
133      * Resolve the given style specification.
134      * &lt;p&gt;
135      * If this resolves to {@link AttributedStyle#DEFAULT} then given default specification is used if non-null.
136      *
137      * @param spec the specification
138      * @param defaultSpec the default specifiaction
139      * @return the style
140      */
141     public AttributedStyle resolve(final String spec, final String defaultSpec) {
142         requireNonNull(spec);
143 
144 //        if (log.isLoggable(Level.FINEST)) {
145 //            log.finest(String.format(&quot;Resolve: %s; default: %s&quot;, spec, defaultSpec));
146 //        }
147 
148         AttributedStyle style = apply(DEFAULT, spec);
149         if (style == DEFAULT &amp;&amp; defaultSpec != null) {
150             style = apply(style, defaultSpec);
151         }
152         return style;
153     }
154 
155     /**
156      * Apply style specification.
157      *
158      * @param style the style to apply to
159      * @param spec the specification
160      * @return the new style
161      */
162     private AttributedStyle apply(AttributedStyle style, final String spec) {
163 //        if (log.isLoggable(Level.FINEST)) {
164 //            log.finest(&quot;Apply: &quot; + spec);
165 //        }
166 
167         for (String item : spec.split(&quot;,&quot;)) {
168             item = item.trim();
169             if (item.isEmpty()) {
170                 continue;
171             }
172 
173             if (item.startsWith(&quot;.&quot;)) {
174                 style = applyReference(style, item);
175             } else if (item.contains(&quot;:&quot;)) {
176                 style = applyColor(style, item);
177             } else if (item.matches(&quot;[0-9]+(;[0-9]+)*&quot;)) {
178                 style = applyAnsi(style, item);
179             } else {
180                 style = applyNamed(style, item);
181             }
182         }
183 
184         return style;
185     }
186 
187     private AttributedStyle applyAnsi(final AttributedStyle style, final String spec) {
188 //        if (log.isLoggable(Level.FINEST)) {
189 //            log.finest(&quot;Apply-ansi: &quot; + spec);
190 //        }
191 
192         return new AttributedStringBuilder()
193                 .style(style)
194                 .ansiAppend(&quot;\033[&quot; + spec + &quot;m&quot;)
195                 .style();
196     }
197 
198     /**
199      * Apply source-referenced named style.
200      *
201      * @param style the style to apply to
202      * @param spec the specification
203      * @return the new style
204      */
205     private AttributedStyle applyReference(final AttributedStyle style, final String spec) {
206 //        if (log.isLoggable(Level.FINEST)) {
207 //            log.finest(&quot;Apply-reference: &quot; + spec);
208 //        }
209 
210         if (spec.length() == 1) {
211 //            log.warning(&quot;Invalid style-reference; missing discriminator: &quot; + spec);
212         } else {
213             String name = spec.substring(1, spec.length());
214             String resolvedSpec = source.apply(name);
215             if (resolvedSpec != null) {
216                 return apply(style, resolvedSpec);
217             }
218             // null is normal if source has not be configured with named style
219         }
220 
221         return style;
222     }
223 
224     /**
225      * Apply default named styles.
226      *
227      * @param style the style to apply to
228      * @param name the named style
229      * @return the new style
230      */
231     private AttributedStyle applyNamed(final AttributedStyle style, final String name) {
232 //        if (log.isLoggable(Level.FINEST)) {
233 //            log.finest(&quot;Apply-named: &quot; + name);
234 //        }
235 
236         // TODO: consider short aliases for named styles
237 
238         switch (name.toLowerCase(Locale.US)) {
239             case &quot;default&quot;:
240                 return DEFAULT;
241 
242             case &quot;bold&quot;:
243                 return style.bold();
244 
245             case &quot;faint&quot;:
246                 return style.faint();
247 
248             case &quot;italic&quot;:
249                 return style.italic();
250 
251             case &quot;underline&quot;:
252                 return style.underline();
253 
254             case &quot;blink&quot;:
255                 return style.blink();
256 
257             case &quot;inverse&quot;:
258                 return style.inverse();
259 
260             case &quot;inverse-neg&quot;:
261             case &quot;inverseneg&quot;:
262                 return style.inverseNeg();
263 
264             case &quot;conceal&quot;:
265                 return style.conceal();
266 
267             case &quot;crossed-out&quot;:
268             case &quot;crossedout&quot;:
269                 return style.crossedOut();
270 
271             case &quot;hidden&quot;:
272                 return style.hidden();
273 
274             default:
275 //                log.warning(&quot;Unknown style: &quot; + name);
276                 return style;
277         }
278     }
279 
280     // TODO: consider simplify and always using StyleColor, for now for compat with other bits leaving syntax complexity
281 
282     /**
283      * Apply color styles specification.
284      *
285      * @param style The style to apply to
286      * @param spec  Color specification: {@code &lt;color-mode&gt;:&lt;color-name&gt;}
287      * @return      The new style
288      */
289     private AttributedStyle applyColor(final AttributedStyle style, final String spec) {
290 //        if (log.isLoggable(Level.FINEST)) {
291 //            log.finest(&quot;Apply-color: &quot; + spec);
292 //        }
293 
294         // extract color-mode:color-name
295         String[] parts = spec.split(&quot;:&quot;, 2);
296         String colorMode = parts[0].trim();
297         String colorName = parts[1].trim();
298 
299         // resolve the color-name
300         Integer color = color(colorName);
301         if (color == null) {
302 //            log.warning(&quot;Invalid color-name: &quot; + colorName);
303         } else {
304             // resolve and apply color-mode
305             switch (colorMode.toLowerCase(Locale.US)) {
306                 case &quot;foreground&quot;:
307                 case &quot;fg&quot;:
308                 case &quot;f&quot;:
309                     return style.foreground(color);
310 
311                 case &quot;background&quot;:
312                 case &quot;bg&quot;:
313                 case &quot;b&quot;:
314                     return style.background(color);
315 
316                 default:
317 //                    log.warning(&quot;Invalid color-mode: &quot; + colorMode);
318             }
319         }
320         return style;
321     }
322 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
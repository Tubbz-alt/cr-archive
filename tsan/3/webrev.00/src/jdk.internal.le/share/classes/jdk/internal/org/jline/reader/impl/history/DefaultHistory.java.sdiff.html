<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/history/DefaultHistory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../completer/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/history/DefaultHistory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.reader.impl.history;
 10 
 11 import java.io.*;
 12 import java.nio.file.*;

 13 import java.time.Instant;
 14 import java.util.*;
 15 
 16 import jdk.internal.org.jline.reader.History;
 17 import jdk.internal.org.jline.reader.LineReader;
 18 import jdk.internal.org.jline.utils.Log;
 19 
 20 import static jdk.internal.org.jline.reader.LineReader.HISTORY_IGNORE;
 21 import static jdk.internal.org.jline.reader.impl.ReaderUtils.*;
 22 
 23 /**
 24  * {@link History} using a file for persistent backing.
 25  * &lt;p&gt;
 26  * Implementers should install shutdown hook to call {@link DefaultHistory#save}
 27  * to save history to disk.
 28  * &lt;/p&gt;
 29  */
 30 public class DefaultHistory implements History {
 31 
 32     public static final int DEFAULT_HISTORY_SIZE = 500;
 33     public static final int DEFAULT_HISTORY_FILE_SIZE = 10000;
 34 
 35     private final LinkedList&lt;Entry&gt; items = new LinkedList&lt;&gt;();
 36 
 37     private LineReader reader;
 38 
<span class="line-modified"> 39     private int lastLoaded = 0;</span>
<span class="line-removed"> 40     private int nbEntriesInFile = 0;</span>
 41     private int offset = 0;
 42     private int index = 0;
 43 
 44     public DefaultHistory() {
 45     }
 46 
 47     public DefaultHistory(LineReader reader) {
 48         attach(reader);
 49     }
 50 
 51     private Path getPath() {
 52         Object obj = reader != null ? reader.getVariables().get(LineReader.HISTORY_FILE) : null;
 53         if (obj instanceof Path) {
 54             return (Path) obj;
 55         } else if (obj instanceof File) {
 56             return ((File) obj).toPath();
 57         } else if (obj != null) {
 58             return Paths.get(obj.toString());
 59         } else {
 60             return null;
 61         }
 62     }
 63 
 64     @Override
 65     public void attach(LineReader reader) {
 66         if (this.reader != reader) {
 67             this.reader = reader;
 68             try {
 69                 load();
 70             }
<span class="line-modified"> 71             catch (IOException e) {</span>
 72                 Log.warn(&quot;Failed to load history&quot;, e);
 73             }
 74         }
 75     }
 76 
 77     @Override
 78     public void load() throws IOException {
 79         Path path = getPath();
 80         if (path != null) {
 81             try {
 82                 if (Files.exists(path)) {
 83                     Log.trace(&quot;Loading history from: &quot;, path);
 84                     try (BufferedReader reader = Files.newBufferedReader(path)) {
 85                         internalClear();
 86                         reader.lines().forEach(line -&gt; addHistoryLine(path, line));
<span class="line-modified"> 87                         lastLoaded = items.size();</span>
<span class="line-removed"> 88                         nbEntriesInFile = lastLoaded;</span>
 89                         maybeResize();
 90                     }
 91                 }
<span class="line-modified"> 92             } catch (IOException e) {</span>
 93                 Log.debug(&quot;Failed to load history; clearing&quot;, e);
 94                 internalClear();
 95                 throw e;
 96             }
 97         }
 98     }
 99 





































































100     protected void addHistoryLine(Path path, String line) {




101         if (reader.isSet(LineReader.Option.HISTORY_TIMESTAMPED)) {
102             int idx = line.indexOf(&#39;:&#39;);



103             if (idx &lt; 0) {
<span class="line-modified">104                 throw new IllegalArgumentException(&quot;Bad history file syntax! &quot; +</span>
<span class="line-modified">105                         &quot;The history file `&quot; + path + &quot;` may be an older history: &quot; +</span>
<span class="line-modified">106                         &quot;please remove it or use a different history file.&quot;);</span>




107             }
<span class="line-modified">108             Instant time = Instant.ofEpochMilli(Long.parseLong(line.substring(0, idx)));</span>
109             String unescaped = unescape(line.substring(idx + 1));
<span class="line-modified">110             internalAdd(time, unescaped);</span>
111         }
112         else {
<span class="line-modified">113             internalAdd(Instant.now(), unescape(line));</span>
114         }
115     }
116 
117     @Override
118     public void purge() throws IOException {
119         internalClear();
120         Path path = getPath();
121         if (path != null) {
122             Log.trace(&quot;Purging history from: &quot;, path);
123             Files.deleteIfExists(path);
124         }
125     }
126 















127     @Override
128     public void save() throws IOException {
<span class="line-modified">129         Path path = getPath();</span>



130         if (path != null) {
131             Log.trace(&quot;Saving history to: &quot;, path);
132             Files.createDirectories(path.toAbsolutePath().getParent());
133             // Append new items to the history file
134             try (BufferedWriter writer = Files.newBufferedWriter(path.toAbsolutePath(),
135               StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE)) {
<span class="line-modified">136                 for (Entry entry : items.subList(lastLoaded, items.size())) {</span>
137                     if (isPersistable(entry)) {
138                         writer.append(format(entry));
139                     }
140                 }
141             }
<span class="line-modified">142             nbEntriesInFile += items.size() - lastLoaded;</span>
<span class="line-removed">143             // If we are over 25% max size, trim history file</span>
144             int max = getInt(reader, LineReader.HISTORY_FILE_SIZE, DEFAULT_HISTORY_FILE_SIZE);
<span class="line-modified">145             if (nbEntriesInFile &gt; max + max / 4) {</span>
146                 trimHistory(path, max);
147             }
148         }
<span class="line-modified">149         lastLoaded = items.size();</span>
150     }
151 
152     protected void trimHistory(Path path, int max) throws IOException {
153         Log.trace(&quot;Trimming history path: &quot;, path);
154         // Load all history entries
155         LinkedList&lt;Entry&gt; allItems = new LinkedList&lt;&gt;();
156         try (BufferedReader reader = Files.newBufferedReader(path)) {
157             reader.lines().forEach(l -&gt; {
158                 int idx = l.indexOf(&#39;:&#39;);
159                 Instant time = Instant.ofEpochMilli(Long.parseLong(l.substring(0, idx)));
160                 String line = unescape(l.substring(idx + 1));
161                 allItems.add(createEntry(allItems.size(), time, line));
162             });
163         }
164         // Remove duplicates
165         doTrimHistory(allItems, max);
166         // Write history
167         Path temp = Files.createTempFile(path.toAbsolutePath().getParent(), path.getFileName().toString(), &quot;.tmp&quot;);
168         try (BufferedWriter writer = Files.newBufferedWriter(temp, StandardOpenOption.WRITE)) {
169             for (Entry entry : allItems) {
170                 writer.append(format(entry));
171             }
172         }
173         Files.move(temp, path, StandardCopyOption.REPLACE_EXISTING);
174         // Keep items in memory
<span class="line-modified">175         internalClear();</span>
<span class="line-modified">176         offset = allItems.get(0).index();</span>
<span class="line-modified">177         items.addAll(allItems);</span>
<span class="line-modified">178         lastLoaded = items.size();</span>
<span class="line-modified">179         nbEntriesInFile = items.size();</span>



180         maybeResize();
181     }
182 
183     /**
184      * Create a history entry. Subclasses may override to use their own entry implementations.
185      * @param index index of history entry
186      * @param time entry creation time
187      * @param line the entry text
188      * @return entry object
189      */
190     protected EntryImpl createEntry(int index, Instant time, String line) {
191         return new EntryImpl(index, time, line);
192     }
193 
194     private void internalClear() {
195         offset = 0;
196         index = 0;
<span class="line-modified">197         lastLoaded = 0;</span>
<span class="line-removed">198         nbEntriesInFile = 0;</span>
199         items.clear();
200     }
201 
202     static void doTrimHistory(List&lt;Entry&gt; allItems, int max) {
203         int idx = 0;
204         while (idx &lt; allItems.size()) {
205             int ridx = allItems.size() - idx - 1;
206             String line = allItems.get(ridx).line().trim();
207             ListIterator&lt;Entry&gt; iterator = allItems.listIterator(ridx);
208             while (iterator.hasPrevious()) {
209                 String l = iterator.previous().line();
210                 if (line.equals(l.trim())) {
211                     iterator.remove();
212                 }
213             }
214             idx++;
215         }
216         while (allItems.size() &gt; max) {
217             allItems.remove(0);
218         }
</pre>
<hr />
<pre>
285     protected boolean matchPatterns(String patterns, String line) {
286         if (patterns == null || patterns.isEmpty()) {
287             return false;
288         }
289         StringBuilder sb = new StringBuilder();
290         for (int i = 0; i &lt; patterns.length(); i++) {
291             char ch = patterns.charAt(i);
292             if (ch == &#39;\\&#39;) {
293                 ch = patterns.charAt(++i);
294                 sb.append(ch);
295             } else if (ch == &#39;:&#39;) {
296                 sb.append(&#39;|&#39;);
297             } else if (ch == &#39;*&#39;) {
298                 sb.append(&#39;.&#39;).append(&#39;*&#39;);
299             }
300         }
301         return line.matches(sb.toString());
302     }
303 
304     protected void internalAdd(Instant time, String line) {




305         Entry entry = new EntryImpl(offset + items.size(), time, line);







306         items.add(entry);
307         maybeResize();
308     }
309 
310     private void maybeResize() {
311         while (size() &gt; getInt(reader, LineReader.HISTORY_SIZE, DEFAULT_HISTORY_SIZE)) {
312             items.removeFirst();
<span class="line-modified">313             lastLoaded--;</span>


314             offset++;
315         }
316         index = size();
317     }
318 
319     public ListIterator&lt;Entry&gt; iterator(int index) {
320         return items.listIterator(index - offset);
321     }
322 
323     @Override
324     public Spliterator&lt;Entry&gt; spliterator() {
325         return items.spliterator();
326     }
327 
328     protected static class EntryImpl implements Entry {
329 
330         private final int index;
331         private final Instant time;
332         private final String line;
333 
</pre>
<hr />
<pre>
486             char ch = s.charAt(i);
487             switch (ch) {
488                 case &#39;\\&#39;:
489                     ch = s.charAt(++i);
490                     if (ch == &#39;n&#39;) {
491                         sb.append(&#39;\n&#39;);
492                     } else if (ch == &#39;r&#39;) {
493                         sb.append(&#39;\r&#39;);
494                     } else {
495                         sb.append(ch);
496                     }
497                     break;
498                 default:
499                     sb.append(ch);
500                     break;
501             }
502         }
503         return sb.toString();
504     }
505 









































506 }
507 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * https://opensource.org/licenses/BSD-3-Clause</span>
  8  */
  9 package jdk.internal.org.jline.reader.impl.history;
 10 
 11 import java.io.*;
 12 import java.nio.file.*;
<span class="line-added"> 13 import java.time.DateTimeException;</span>
 14 import java.time.Instant;
 15 import java.util.*;
 16 
 17 import jdk.internal.org.jline.reader.History;
 18 import jdk.internal.org.jline.reader.LineReader;
 19 import jdk.internal.org.jline.utils.Log;
 20 
 21 import static jdk.internal.org.jline.reader.LineReader.HISTORY_IGNORE;
 22 import static jdk.internal.org.jline.reader.impl.ReaderUtils.*;
 23 
 24 /**
 25  * {@link History} using a file for persistent backing.
 26  * &lt;p&gt;
 27  * Implementers should install shutdown hook to call {@link DefaultHistory#save}
 28  * to save history to disk.
 29  * &lt;/p&gt;
 30  */
 31 public class DefaultHistory implements History {
 32 
 33     public static final int DEFAULT_HISTORY_SIZE = 500;
 34     public static final int DEFAULT_HISTORY_FILE_SIZE = 10000;
 35 
 36     private final LinkedList&lt;Entry&gt; items = new LinkedList&lt;&gt;();
 37 
 38     private LineReader reader;
 39 
<span class="line-modified"> 40     private Map&lt;String, HistoryFileData&gt; historyFiles = new HashMap&lt;&gt;();</span>

 41     private int offset = 0;
 42     private int index = 0;
 43 
 44     public DefaultHistory() {
 45     }
 46 
 47     public DefaultHistory(LineReader reader) {
 48         attach(reader);
 49     }
 50 
 51     private Path getPath() {
 52         Object obj = reader != null ? reader.getVariables().get(LineReader.HISTORY_FILE) : null;
 53         if (obj instanceof Path) {
 54             return (Path) obj;
 55         } else if (obj instanceof File) {
 56             return ((File) obj).toPath();
 57         } else if (obj != null) {
 58             return Paths.get(obj.toString());
 59         } else {
 60             return null;
 61         }
 62     }
 63 
 64     @Override
 65     public void attach(LineReader reader) {
 66         if (this.reader != reader) {
 67             this.reader = reader;
 68             try {
 69                 load();
 70             }
<span class="line-modified"> 71             catch (IllegalArgumentException | IOException e) {</span>
 72                 Log.warn(&quot;Failed to load history&quot;, e);
 73             }
 74         }
 75     }
 76 
 77     @Override
 78     public void load() throws IOException {
 79         Path path = getPath();
 80         if (path != null) {
 81             try {
 82                 if (Files.exists(path)) {
 83                     Log.trace(&quot;Loading history from: &quot;, path);
 84                     try (BufferedReader reader = Files.newBufferedReader(path)) {
 85                         internalClear();
 86                         reader.lines().forEach(line -&gt; addHistoryLine(path, line));
<span class="line-modified"> 87                         setHistoryFileData(path, new HistoryFileData(items.size(), items.size()));</span>

 88                         maybeResize();
 89                     }
 90                 }
<span class="line-modified"> 91             } catch (IllegalArgumentException | IOException e) {</span>
 92                 Log.debug(&quot;Failed to load history; clearing&quot;, e);
 93                 internalClear();
 94                 throw e;
 95             }
 96         }
 97     }
 98 
<span class="line-added"> 99     @Override</span>
<span class="line-added">100     public void read(Path file, boolean incremental) throws IOException {</span>
<span class="line-added">101         Path path = file != null ? file : getPath();</span>
<span class="line-added">102         if (path != null) {</span>
<span class="line-added">103             try {</span>
<span class="line-added">104                 if (Files.exists(path)) {</span>
<span class="line-added">105                     Log.trace(&quot;Reading history from: &quot;, path);</span>
<span class="line-added">106                     try (BufferedReader reader = Files.newBufferedReader(path)) {</span>
<span class="line-added">107                         reader.lines().forEach(line -&gt; addHistoryLine(path, line, incremental));</span>
<span class="line-added">108                         setHistoryFileData(path, new HistoryFileData(items.size(), items.size()));</span>
<span class="line-added">109                         maybeResize();</span>
<span class="line-added">110                     }</span>
<span class="line-added">111                 }</span>
<span class="line-added">112             } catch (IllegalArgumentException | IOException e) {</span>
<span class="line-added">113                 Log.debug(&quot;Failed to read history; clearing&quot;, e);</span>
<span class="line-added">114                 internalClear();</span>
<span class="line-added">115                 throw e;</span>
<span class="line-added">116             }</span>
<span class="line-added">117         }</span>
<span class="line-added">118     }</span>
<span class="line-added">119 </span>
<span class="line-added">120     private String doHistoryFileDataKey (Path path){</span>
<span class="line-added">121         return path != null ? path.toAbsolutePath().toString() : null;</span>
<span class="line-added">122     }</span>
<span class="line-added">123 </span>
<span class="line-added">124     private HistoryFileData getHistoryFileData(Path path) {</span>
<span class="line-added">125         String key = doHistoryFileDataKey(path);</span>
<span class="line-added">126         if (!historyFiles.containsKey(key)){</span>
<span class="line-added">127             historyFiles.put(key, new HistoryFileData());</span>
<span class="line-added">128         }</span>
<span class="line-added">129         return historyFiles.get(key);</span>
<span class="line-added">130     }</span>
<span class="line-added">131 </span>
<span class="line-added">132     private void setHistoryFileData(Path path, HistoryFileData historyFileData) {</span>
<span class="line-added">133         historyFiles.put(doHistoryFileDataKey(path), historyFileData);</span>
<span class="line-added">134     }</span>
<span class="line-added">135 </span>
<span class="line-added">136     private boolean isLineReaderHistory (Path path) throws IOException {</span>
<span class="line-added">137         Path lrp = getPath();</span>
<span class="line-added">138         if (lrp == null) {</span>
<span class="line-added">139             if (path != null) {</span>
<span class="line-added">140                 return false;</span>
<span class="line-added">141             } else {</span>
<span class="line-added">142                 return true;</span>
<span class="line-added">143             }</span>
<span class="line-added">144         }</span>
<span class="line-added">145         return Files.isSameFile(lrp, path);</span>
<span class="line-added">146     }</span>
<span class="line-added">147 </span>
<span class="line-added">148     private void setLastLoaded(Path path, int lastloaded){</span>
<span class="line-added">149         getHistoryFileData(path).setLastLoaded(lastloaded);</span>
<span class="line-added">150     }</span>
<span class="line-added">151 </span>
<span class="line-added">152     private void setEntriesInFile(Path path, int entriesInFile){</span>
<span class="line-added">153         getHistoryFileData(path).setEntriesInFile(entriesInFile);</span>
<span class="line-added">154     }</span>
<span class="line-added">155 </span>
<span class="line-added">156     private void incEntriesInFile(Path path, int amount){</span>
<span class="line-added">157         getHistoryFileData(path).incEntriesInFile(amount);</span>
<span class="line-added">158     }</span>
<span class="line-added">159 </span>
<span class="line-added">160     private int getLastLoaded(Path path){</span>
<span class="line-added">161         return getHistoryFileData(path).getLastLoaded();</span>
<span class="line-added">162     }</span>
<span class="line-added">163 </span>
<span class="line-added">164     private int getEntriesInFile(Path path){</span>
<span class="line-added">165         return getHistoryFileData(path).getEntriesInFile();</span>
<span class="line-added">166     }</span>
<span class="line-added">167 </span>
168     protected void addHistoryLine(Path path, String line) {
<span class="line-added">169         addHistoryLine(path, line, false);</span>
<span class="line-added">170     }</span>
<span class="line-added">171 </span>
<span class="line-added">172     protected void addHistoryLine(Path path, String line, boolean checkDuplicates) {</span>
173         if (reader.isSet(LineReader.Option.HISTORY_TIMESTAMPED)) {
174             int idx = line.indexOf(&#39;:&#39;);
<span class="line-added">175             final String badHistoryFileSyntax = &quot;Bad history file syntax! &quot; +</span>
<span class="line-added">176                 &quot;The history file `&quot; + path + &quot;` may be an older history: &quot; +</span>
<span class="line-added">177                 &quot;please remove it or use a different history file.&quot;;</span>
178             if (idx &lt; 0) {
<span class="line-modified">179                 throw new IllegalArgumentException(badHistoryFileSyntax);</span>
<span class="line-modified">180             }</span>
<span class="line-modified">181             Instant time;</span>
<span class="line-added">182             try {</span>
<span class="line-added">183                 time = Instant.ofEpochMilli(Long.parseLong(line.substring(0, idx)));</span>
<span class="line-added">184             } catch (DateTimeException | NumberFormatException e) {</span>
<span class="line-added">185                 throw new IllegalArgumentException(badHistoryFileSyntax);</span>
186             }
<span class="line-modified">187 </span>
188             String unescaped = unescape(line.substring(idx + 1));
<span class="line-modified">189             internalAdd(time, unescaped, checkDuplicates);</span>
190         }
191         else {
<span class="line-modified">192             internalAdd(Instant.now(), unescape(line), checkDuplicates);</span>
193         }
194     }
195 
196     @Override
197     public void purge() throws IOException {
198         internalClear();
199         Path path = getPath();
200         if (path != null) {
201             Log.trace(&quot;Purging history from: &quot;, path);
202             Files.deleteIfExists(path);
203         }
204     }
205 
<span class="line-added">206     @Override</span>
<span class="line-added">207     public void write(Path file, boolean incremental) throws IOException {</span>
<span class="line-added">208         Path path = file != null ? file : getPath();</span>
<span class="line-added">209         if (path != null &amp;&amp; Files.exists(path)) {</span>
<span class="line-added">210             path.toFile().delete();</span>
<span class="line-added">211         }</span>
<span class="line-added">212         internalWrite(path, incremental ? getLastLoaded(path) : 0);</span>
<span class="line-added">213     }</span>
<span class="line-added">214 </span>
<span class="line-added">215     @Override</span>
<span class="line-added">216     public void append(Path file, boolean incremental) throws IOException {</span>
<span class="line-added">217         internalWrite(file != null ? file : getPath(),</span>
<span class="line-added">218                       incremental ? getLastLoaded(file) : 0);</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
221     @Override
222     public void save() throws IOException {
<span class="line-modified">223         internalWrite(getPath(), getLastLoaded(getPath()));</span>
<span class="line-added">224     }</span>
<span class="line-added">225 </span>
<span class="line-added">226     private void internalWrite(Path path, int from) throws IOException {</span>
227         if (path != null) {
228             Log.trace(&quot;Saving history to: &quot;, path);
229             Files.createDirectories(path.toAbsolutePath().getParent());
230             // Append new items to the history file
231             try (BufferedWriter writer = Files.newBufferedWriter(path.toAbsolutePath(),
232               StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE)) {
<span class="line-modified">233                 for (Entry entry : items.subList(from, items.size())) {</span>
234                     if (isPersistable(entry)) {
235                         writer.append(format(entry));
236                     }
237                 }
238             }
<span class="line-modified">239             incEntriesInFile(path, items.size() - from);</span>

240             int max = getInt(reader, LineReader.HISTORY_FILE_SIZE, DEFAULT_HISTORY_FILE_SIZE);
<span class="line-modified">241             if (getEntriesInFile(path) &gt; max + max / 4) {</span>
242                 trimHistory(path, max);
243             }
244         }
<span class="line-modified">245         setLastLoaded(path, items.size());</span>
246     }
247 
248     protected void trimHistory(Path path, int max) throws IOException {
249         Log.trace(&quot;Trimming history path: &quot;, path);
250         // Load all history entries
251         LinkedList&lt;Entry&gt; allItems = new LinkedList&lt;&gt;();
252         try (BufferedReader reader = Files.newBufferedReader(path)) {
253             reader.lines().forEach(l -&gt; {
254                 int idx = l.indexOf(&#39;:&#39;);
255                 Instant time = Instant.ofEpochMilli(Long.parseLong(l.substring(0, idx)));
256                 String line = unescape(l.substring(idx + 1));
257                 allItems.add(createEntry(allItems.size(), time, line));
258             });
259         }
260         // Remove duplicates
261         doTrimHistory(allItems, max);
262         // Write history
263         Path temp = Files.createTempFile(path.toAbsolutePath().getParent(), path.getFileName().toString(), &quot;.tmp&quot;);
264         try (BufferedWriter writer = Files.newBufferedWriter(temp, StandardOpenOption.WRITE)) {
265             for (Entry entry : allItems) {
266                 writer.append(format(entry));
267             }
268         }
269         Files.move(temp, path, StandardCopyOption.REPLACE_EXISTING);
270         // Keep items in memory
<span class="line-modified">271         if (isLineReaderHistory(path)) {</span>
<span class="line-modified">272             internalClear();</span>
<span class="line-modified">273             offset = allItems.get(0).index();</span>
<span class="line-modified">274             items.addAll(allItems);</span>
<span class="line-modified">275             setHistoryFileData(path, new HistoryFileData(items.size(), items.size()));</span>
<span class="line-added">276         } else {</span>
<span class="line-added">277             setEntriesInFile(path, allItems.size());</span>
<span class="line-added">278         }</span>
279         maybeResize();
280     }
281 
282     /**
283      * Create a history entry. Subclasses may override to use their own entry implementations.
284      * @param index index of history entry
285      * @param time entry creation time
286      * @param line the entry text
287      * @return entry object
288      */
289     protected EntryImpl createEntry(int index, Instant time, String line) {
290         return new EntryImpl(index, time, line);
291     }
292 
293     private void internalClear() {
294         offset = 0;
295         index = 0;
<span class="line-modified">296         historyFiles = new HashMap&lt;&gt;();</span>

297         items.clear();
298     }
299 
300     static void doTrimHistory(List&lt;Entry&gt; allItems, int max) {
301         int idx = 0;
302         while (idx &lt; allItems.size()) {
303             int ridx = allItems.size() - idx - 1;
304             String line = allItems.get(ridx).line().trim();
305             ListIterator&lt;Entry&gt; iterator = allItems.listIterator(ridx);
306             while (iterator.hasPrevious()) {
307                 String l = iterator.previous().line();
308                 if (line.equals(l.trim())) {
309                     iterator.remove();
310                 }
311             }
312             idx++;
313         }
314         while (allItems.size() &gt; max) {
315             allItems.remove(0);
316         }
</pre>
<hr />
<pre>
383     protected boolean matchPatterns(String patterns, String line) {
384         if (patterns == null || patterns.isEmpty()) {
385             return false;
386         }
387         StringBuilder sb = new StringBuilder();
388         for (int i = 0; i &lt; patterns.length(); i++) {
389             char ch = patterns.charAt(i);
390             if (ch == &#39;\\&#39;) {
391                 ch = patterns.charAt(++i);
392                 sb.append(ch);
393             } else if (ch == &#39;:&#39;) {
394                 sb.append(&#39;|&#39;);
395             } else if (ch == &#39;*&#39;) {
396                 sb.append(&#39;.&#39;).append(&#39;*&#39;);
397             }
398         }
399         return line.matches(sb.toString());
400     }
401 
402     protected void internalAdd(Instant time, String line) {
<span class="line-added">403         internalAdd(time, line, false);</span>
<span class="line-added">404     }</span>
<span class="line-added">405 </span>
<span class="line-added">406     protected void internalAdd(Instant time, String line, boolean checkDuplicates) {</span>
407         Entry entry = new EntryImpl(offset + items.size(), time, line);
<span class="line-added">408         if (checkDuplicates) {</span>
<span class="line-added">409             for (Entry e: items) {</span>
<span class="line-added">410                 if (e.line().trim().equals(line.trim())) {</span>
<span class="line-added">411                     return;</span>
<span class="line-added">412                 }</span>
<span class="line-added">413             }</span>
<span class="line-added">414         }</span>
415         items.add(entry);
416         maybeResize();
417     }
418 
419     private void maybeResize() {
420         while (size() &gt; getInt(reader, LineReader.HISTORY_SIZE, DEFAULT_HISTORY_SIZE)) {
421             items.removeFirst();
<span class="line-modified">422             for (HistoryFileData hfd: historyFiles.values()) {</span>
<span class="line-added">423                 hfd.decLastLoaded();</span>
<span class="line-added">424             }</span>
425             offset++;
426         }
427         index = size();
428     }
429 
430     public ListIterator&lt;Entry&gt; iterator(int index) {
431         return items.listIterator(index - offset);
432     }
433 
434     @Override
435     public Spliterator&lt;Entry&gt; spliterator() {
436         return items.spliterator();
437     }
438 
439     protected static class EntryImpl implements Entry {
440 
441         private final int index;
442         private final Instant time;
443         private final String line;
444 
</pre>
<hr />
<pre>
597             char ch = s.charAt(i);
598             switch (ch) {
599                 case &#39;\\&#39;:
600                     ch = s.charAt(++i);
601                     if (ch == &#39;n&#39;) {
602                         sb.append(&#39;\n&#39;);
603                     } else if (ch == &#39;r&#39;) {
604                         sb.append(&#39;\r&#39;);
605                     } else {
606                         sb.append(ch);
607                     }
608                     break;
609                 default:
610                     sb.append(ch);
611                     break;
612             }
613         }
614         return sb.toString();
615     }
616 
<span class="line-added">617     private class HistoryFileData {</span>
<span class="line-added">618         private int lastLoaded = 0;</span>
<span class="line-added">619         private int entriesInFile = 0;</span>
<span class="line-added">620 </span>
<span class="line-added">621         public HistoryFileData() {</span>
<span class="line-added">622         }</span>
<span class="line-added">623 </span>
<span class="line-added">624         public HistoryFileData(int lastLoaded, int entriesInFile) {</span>
<span class="line-added">625             this.lastLoaded = lastLoaded;</span>
<span class="line-added">626             this.entriesInFile = entriesInFile;</span>
<span class="line-added">627         }</span>
<span class="line-added">628 </span>
<span class="line-added">629         public int getLastLoaded() {</span>
<span class="line-added">630             return lastLoaded;</span>
<span class="line-added">631         }</span>
<span class="line-added">632 </span>
<span class="line-added">633         public void setLastLoaded(int lastLoaded) {</span>
<span class="line-added">634             this.lastLoaded = lastLoaded;</span>
<span class="line-added">635         }</span>
<span class="line-added">636 </span>
<span class="line-added">637         public void decLastLoaded() {</span>
<span class="line-added">638             lastLoaded = lastLoaded - 1;</span>
<span class="line-added">639             if (lastLoaded &lt; 0) {</span>
<span class="line-added">640                 lastLoaded = 0;</span>
<span class="line-added">641             }</span>
<span class="line-added">642         }</span>
<span class="line-added">643 </span>
<span class="line-added">644         public int getEntriesInFile() {</span>
<span class="line-added">645             return entriesInFile;</span>
<span class="line-added">646         }</span>
<span class="line-added">647 </span>
<span class="line-added">648         public void setEntriesInFile(int entriesInFile) {</span>
<span class="line-added">649             this.entriesInFile = entriesInFile;</span>
<span class="line-added">650         }</span>
<span class="line-added">651 </span>
<span class="line-added">652         public void incEntriesInFile(int amount) {</span>
<span class="line-added">653             entriesInFile = entriesInFile + amount;</span>
<span class="line-added">654         }</span>
<span class="line-added">655 </span>
<span class="line-added">656     }</span>
<span class="line-added">657 </span>
658 }
659 
</pre>
</td>
</tr>
</table>
<center><a href="../completer/package-info.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="package-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedStringBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AttributedString.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttributedStyle.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedStringBuilder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 

 11 import java.util.Arrays;

 12 import java.util.function.Consumer;
 13 import java.util.function.Function;
 14 import java.util.regex.Matcher;
 15 import java.util.regex.Pattern;
 16 
 17 /**
 18  * Attributed string builder
 19  *
 20  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 21  */
 22 public class AttributedStringBuilder extends AttributedCharSequence implements Appendable {
 23 
 24     private char[] buffer;
 25     private int[] style;
 26     private int length;
<span class="line-modified"> 27     private int tabs = 0;</span>
 28     private int lastLineLength = 0;
 29     private AttributedStyle current = AttributedStyle.DEFAULT;
 30 
 31     public static AttributedString append(CharSequence... strings) {
 32         AttributedStringBuilder sb = new AttributedStringBuilder();
 33         for (CharSequence s : strings) {
 34             sb.append(s);
 35         }
 36         return sb.toAttributedString();
 37     }
 38 
 39     public AttributedStringBuilder() {
 40         this(64);
 41     }
 42 
 43     public AttributedStringBuilder(int capacity) {
 44         buffer = new char[capacity];
 45         style = new int[capacity];
 46         length = 0;
 47     }
</pre>
<hr />
<pre>
134         return current;
135     }
136 
137     public AttributedStringBuilder append(AttributedString str) {
138         return append((AttributedCharSequence) str, 0, str.length());
139     }
140 
141     public AttributedStringBuilder append(AttributedString str, int start, int end) {
142         return append((AttributedCharSequence) str, start, end);
143     }
144 
145     public AttributedStringBuilder append(AttributedCharSequence str) {
146         return append(str, 0, str.length());
147     }
148 
149     public AttributedStringBuilder append(AttributedCharSequence str, int start, int end) {
150         ensureCapacity(length + end - start);
151         for (int i = start; i &lt; end; i++) {
152             char c = str.charAt(i);
153             int s = str.styleCodeAt(i) &amp; ~current.getMask() | current.getStyle();
<span class="line-modified">154             if (tabs &gt; 0 &amp;&amp; c == &#39;\t&#39;) {</span>
155                 insertTab(new AttributedStyle(s, 0));
156             } else {
157                 ensureCapacity(length + 1);
158                 buffer[length] = c;
159                 style[length] = s;
160                 if (c == &#39;\n&#39;) {
161                     lastLineLength = 0;
162                 } else {
163                     lastLineLength++;
164                 }
165                 length++;
166             }
167         }
168         return this;
169     }
170 
171     protected void ensureCapacity(int nl) {
172         if (nl &gt; buffer.length) {
173             int s = Math.max(buffer.length, 1);
174             while (s &lt;= nl) {
</pre>
<hr />
<pre>
315                                 current = current.foreground(ansiParam - 90 + 8);
316                                 break;
317                             case 100:
318                             case 101:
319                             case 102:
320                             case 103:
321                             case 104:
322                             case 105:
323                             case 106:
324                             case 107:
325                                 current = current.background(ansiParam - 100 + 8);
326                                 break;
327                         }
328                         j++;
329                     }
330                     ansiState = 0;
331                 } else if (!(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39; || c == &#39;;&#39;)) {
332                     // This is not a SGR code, so ignore
333                     ansiState = 0;
334                 }
<span class="line-modified">335             } else if (c == &#39;\t&#39; &amp;&amp; tabs &gt; 0) {</span>
336                 insertTab(current);
337             } else {
338                 ensureCapacity(length + 1);
339                 buffer[length] = c;
340                 style[length] = this.current.getStyle();
341                 if (c == &#39;\n&#39;) {
342                     lastLineLength = 0;
343                 } else {
344                     lastLineLength++;
345                 }
346                 length++;
347             }
348         }
349         return this;
350     }
351 
352     protected void insertTab(AttributedStyle s) {
<span class="line-modified">353         int nb = tabs - lastLineLength % tabs;</span>
354         ensureCapacity(length + nb);
355         for (int i = 0; i &lt; nb; i++) {
356             buffer[length] = &#39; &#39;;
357             style[length] = s.getStyle();
358             length++;
359         }
360         lastLineLength += nb;
361     }
362 
363     public void setLength(int l) {
364         length = l;
365     }
366 
367     /**
368      * Set the number of spaces a tab is expanded to. Tab size cannot be changed
369      * after text has been added to prevent inconsistent indentation.
370      *
371      * If tab size is set to 0, tabs are not expanded (the default).
372      * @param tabsize Spaces per tab or 0 for no tab expansion. Must be non-negative
373      * @return this
374      */
375     public AttributedStringBuilder tabs(int tabsize) {
<span class="line-removed">376         if (length &gt; 0) {</span>
<span class="line-removed">377             throw new IllegalStateException(&quot;Cannot change tab size after appending text&quot;);</span>
<span class="line-removed">378         }</span>
379         if (tabsize &lt; 0) {
380             throw new IllegalArgumentException(&quot;Tab size must be non negative&quot;);
381         }
<span class="line-modified">382         this.tabs = tabsize;</span>







383         return this;
384     }
385 
386     public AttributedStringBuilder styleMatches(Pattern pattern, AttributedStyle s) {
387         Matcher matcher = pattern.matcher(this);
388         while (matcher.find()) {
389             for (int i = matcher.start(); i &lt; matcher.end(); i++) {
390                 style[i] = (style[i] &amp; ~s.getMask()) | s.getStyle();
391             }
392         }
393         return this;
394     }
395 
























































396 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * https://opensource.org/licenses/BSD-3-Clause</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
<span class="line-added"> 11 import java.util.ArrayList;</span>
 12 import java.util.Arrays;
<span class="line-added"> 13 import java.util.List;</span>
 14 import java.util.function.Consumer;
 15 import java.util.function.Function;
 16 import java.util.regex.Matcher;
 17 import java.util.regex.Pattern;
 18 
 19 /**
 20  * Attributed string builder
 21  *
 22  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 23  */
 24 public class AttributedStringBuilder extends AttributedCharSequence implements Appendable {
 25 
 26     private char[] buffer;
 27     private int[] style;
 28     private int length;
<span class="line-modified"> 29     private TabStops tabs = new TabStops(0);</span>
 30     private int lastLineLength = 0;
 31     private AttributedStyle current = AttributedStyle.DEFAULT;
 32 
 33     public static AttributedString append(CharSequence... strings) {
 34         AttributedStringBuilder sb = new AttributedStringBuilder();
 35         for (CharSequence s : strings) {
 36             sb.append(s);
 37         }
 38         return sb.toAttributedString();
 39     }
 40 
 41     public AttributedStringBuilder() {
 42         this(64);
 43     }
 44 
 45     public AttributedStringBuilder(int capacity) {
 46         buffer = new char[capacity];
 47         style = new int[capacity];
 48         length = 0;
 49     }
</pre>
<hr />
<pre>
136         return current;
137     }
138 
139     public AttributedStringBuilder append(AttributedString str) {
140         return append((AttributedCharSequence) str, 0, str.length());
141     }
142 
143     public AttributedStringBuilder append(AttributedString str, int start, int end) {
144         return append((AttributedCharSequence) str, start, end);
145     }
146 
147     public AttributedStringBuilder append(AttributedCharSequence str) {
148         return append(str, 0, str.length());
149     }
150 
151     public AttributedStringBuilder append(AttributedCharSequence str, int start, int end) {
152         ensureCapacity(length + end - start);
153         for (int i = start; i &lt; end; i++) {
154             char c = str.charAt(i);
155             int s = str.styleCodeAt(i) &amp; ~current.getMask() | current.getStyle();
<span class="line-modified">156             if (tabs.defined() &amp;&amp; c == &#39;\t&#39;) {</span>
157                 insertTab(new AttributedStyle(s, 0));
158             } else {
159                 ensureCapacity(length + 1);
160                 buffer[length] = c;
161                 style[length] = s;
162                 if (c == &#39;\n&#39;) {
163                     lastLineLength = 0;
164                 } else {
165                     lastLineLength++;
166                 }
167                 length++;
168             }
169         }
170         return this;
171     }
172 
173     protected void ensureCapacity(int nl) {
174         if (nl &gt; buffer.length) {
175             int s = Math.max(buffer.length, 1);
176             while (s &lt;= nl) {
</pre>
<hr />
<pre>
317                                 current = current.foreground(ansiParam - 90 + 8);
318                                 break;
319                             case 100:
320                             case 101:
321                             case 102:
322                             case 103:
323                             case 104:
324                             case 105:
325                             case 106:
326                             case 107:
327                                 current = current.background(ansiParam - 100 + 8);
328                                 break;
329                         }
330                         j++;
331                     }
332                     ansiState = 0;
333                 } else if (!(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39; || c == &#39;;&#39;)) {
334                     // This is not a SGR code, so ignore
335                     ansiState = 0;
336                 }
<span class="line-modified">337             } else if (c == &#39;\t&#39; &amp;&amp; tabs.defined()) {</span>
338                 insertTab(current);
339             } else {
340                 ensureCapacity(length + 1);
341                 buffer[length] = c;
342                 style[length] = this.current.getStyle();
343                 if (c == &#39;\n&#39;) {
344                     lastLineLength = 0;
345                 } else {
346                     lastLineLength++;
347                 }
348                 length++;
349             }
350         }
351         return this;
352     }
353 
354     protected void insertTab(AttributedStyle s) {
<span class="line-modified">355         int nb = tabs.spaces(lastLineLength);</span>
356         ensureCapacity(length + nb);
357         for (int i = 0; i &lt; nb; i++) {
358             buffer[length] = &#39; &#39;;
359             style[length] = s.getStyle();
360             length++;
361         }
362         lastLineLength += nb;
363     }
364 
365     public void setLength(int l) {
366         length = l;
367     }
368 
369     /**
370      * Set the number of spaces a tab is expanded to. Tab size cannot be changed
371      * after text has been added to prevent inconsistent indentation.
372      *
373      * If tab size is set to 0, tabs are not expanded (the default).
374      * @param tabsize Spaces per tab or 0 for no tab expansion. Must be non-negative
375      * @return this
376      */
377     public AttributedStringBuilder tabs(int tabsize) {



378         if (tabsize &lt; 0) {
379             throw new IllegalArgumentException(&quot;Tab size must be non negative&quot;);
380         }
<span class="line-modified">381         return tabs(Arrays.asList(tabsize));</span>
<span class="line-added">382     }</span>
<span class="line-added">383 </span>
<span class="line-added">384     public AttributedStringBuilder tabs(List&lt;Integer&gt; tabs) {</span>
<span class="line-added">385         if (length &gt; 0) {</span>
<span class="line-added">386             throw new IllegalStateException(&quot;Cannot change tab size after appending text&quot;);</span>
<span class="line-added">387         }</span>
<span class="line-added">388         this.tabs = new TabStops(tabs);</span>
389         return this;
390     }
391 
392     public AttributedStringBuilder styleMatches(Pattern pattern, AttributedStyle s) {
393         Matcher matcher = pattern.matcher(this);
394         while (matcher.find()) {
395             for (int i = matcher.start(); i &lt; matcher.end(); i++) {
396                 style[i] = (style[i] &amp; ~s.getMask()) | s.getStyle();
397             }
398         }
399         return this;
400     }
401 
<span class="line-added">402     public AttributedStringBuilder styleMatches(Pattern pattern, List&lt;AttributedStyle&gt; styles) {</span>
<span class="line-added">403         Matcher matcher = pattern.matcher(this);</span>
<span class="line-added">404         while (matcher.find()) {</span>
<span class="line-added">405             for (int group = 0; group &lt; matcher.groupCount(); group++) {</span>
<span class="line-added">406                 AttributedStyle s = styles.get(group);</span>
<span class="line-added">407                 for (int i = matcher.start(group + 1); i &lt; matcher.end(group + 1); i++) {</span>
<span class="line-added">408                     style[i] = (style[i] &amp; ~s.getMask()) | s.getStyle();</span>
<span class="line-added">409                 }</span>
<span class="line-added">410             }</span>
<span class="line-added">411         }</span>
<span class="line-added">412         return this;</span>
<span class="line-added">413     }</span>
<span class="line-added">414 </span>
<span class="line-added">415     private class TabStops {</span>
<span class="line-added">416         private List&lt;Integer&gt; tabs = new ArrayList&lt;&gt;();</span>
<span class="line-added">417         private int lastStop = 0;</span>
<span class="line-added">418         private int lastSize = 0;</span>
<span class="line-added">419 </span>
<span class="line-added">420         public TabStops(int tabs) {</span>
<span class="line-added">421             this.lastSize = tabs;</span>
<span class="line-added">422         }</span>
<span class="line-added">423 </span>
<span class="line-added">424         public TabStops(List&lt;Integer&gt; tabs) {</span>
<span class="line-added">425             this.tabs = tabs;</span>
<span class="line-added">426             int p = 0;</span>
<span class="line-added">427             for (int s: tabs) {</span>
<span class="line-added">428                 if (s &lt;= p) {</span>
<span class="line-added">429                     continue;</span>
<span class="line-added">430                 }</span>
<span class="line-added">431                 lastStop = s;</span>
<span class="line-added">432                 lastSize = s - p;</span>
<span class="line-added">433                 p = s;</span>
<span class="line-added">434             }</span>
<span class="line-added">435         }</span>
<span class="line-added">436 </span>
<span class="line-added">437         boolean defined() {</span>
<span class="line-added">438             return lastSize &gt; 0;</span>
<span class="line-added">439         }</span>
<span class="line-added">440 </span>
<span class="line-added">441         int spaces(int lastLineLength) {</span>
<span class="line-added">442             int out = 0;</span>
<span class="line-added">443             if (lastLineLength &gt;= lastStop) {</span>
<span class="line-added">444                 out = lastSize - (lastLineLength - lastStop) % lastSize;</span>
<span class="line-added">445             } else {</span>
<span class="line-added">446                 for (int s: tabs) {</span>
<span class="line-added">447                     if (s &gt; lastLineLength) {</span>
<span class="line-added">448                         out = s - lastLineLength;</span>
<span class="line-added">449                         break;</span>
<span class="line-added">450                     }</span>
<span class="line-added">451                 }</span>
<span class="line-added">452             }</span>
<span class="line-added">453             return out;</span>
<span class="line-added">454         }</span>
<span class="line-added">455 </span>
<span class="line-added">456     }</span>
<span class="line-added">457 </span>
458 }
</pre>
</td>
</tr>
</table>
<center><a href="AttributedString.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttributedStyle.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedCharSequence.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.ArrayList;
 12 import java.util.List;
 13 
 14 import jdk.internal.org.jline.terminal.Terminal;
 15 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
 16 import jdk.internal.org.jline.utils.InfoCmp.Capability;
 17 
 18 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR;
 19 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR_EXP;
 20 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR;
 21 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR_EXP;
 22 import static jdk.internal.org.jline.utils.AttributedStyle.F_BACKGROUND;
 23 import static jdk.internal.org.jline.utils.AttributedStyle.F_BLINK;
 24 import static jdk.internal.org.jline.utils.AttributedStyle.F_BOLD;
 25 import static jdk.internal.org.jline.utils.AttributedStyle.F_CONCEAL;
 26 import static jdk.internal.org.jline.utils.AttributedStyle.F_CROSSED_OUT;
 27 import static jdk.internal.org.jline.utils.AttributedStyle.F_FAINT;
 28 import static jdk.internal.org.jline.utils.AttributedStyle.F_FOREGROUND;
 29 import static jdk.internal.org.jline.utils.AttributedStyle.F_INVERSE;
 30 import static jdk.internal.org.jline.utils.AttributedStyle.F_ITALIC;
 31 import static jdk.internal.org.jline.utils.AttributedStyle.F_UNDERLINE;
 32 import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;
 33 import static jdk.internal.org.jline.utils.AttributedStyle.MASK;
 34 import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;
 35 
 36 public abstract class AttributedCharSequence implements CharSequence {
 37 
 38     // cache the value here as we can&#39;t afford to get it each time
 39     static final boolean DISABLE_ALTERNATE_CHARSET = Boolean.getBoolean(PROP_DISABLE_ALTERNATE_CHARSET);
 40 
 41     public String toAnsi() {
 42         return toAnsi(null);
 43     }
 44 
 45     public String toAnsi(Terminal terminal) {
 46         if (terminal != null &amp;&amp; Terminal.TYPE_DUMB.equals(terminal.getType())) {
 47             return toString();
 48         }
 49         int colors = 256;
 50         boolean force256colors = false;
 51         String alternateIn = null, alternateOut = null;
 52         if (terminal != null) {
 53             Integer max_colors = terminal.getNumericCapability(Capability.max_colors);
 54             if (max_colors != null) {
 55                 colors = max_colors;
 56             }
 57             force256colors = AbstractWindowsTerminal.TYPE_WINDOWS_256_COLOR.equals(terminal.getType());
 58             if (!DISABLE_ALTERNATE_CHARSET) {
 59                 alternateIn = Curses.tputs(terminal.getStringCapability(Capability.enter_alt_charset_mode));
 60                 alternateOut = Curses.tputs(terminal.getStringCapability(Capability.exit_alt_charset_mode));
 61             }
 62         }
 63         return toAnsi(colors, force256colors, alternateIn, alternateOut);
 64     }
 65 
 66     public String toAnsi(int colors, boolean force256colors) {
 67         return toAnsi(colors, force256colors, null, null);
 68     }
 69 
 70     public String toAnsi(int colors, boolean force256colors, String altIn, String altOut) {
 71         StringBuilder sb = new StringBuilder();
 72         int style = 0;
 73         int foreground = -1;
 74         int background = -1;
 75         boolean alt = false;
 76         for (int i = 0; i &lt; length(); i++) {
 77             char c = charAt(i);
 78             if (altIn != null &amp;&amp; altOut != null) {
 79                 char pc = c;
 80                 switch (c) {
 81                     case &#39;\u2518&#39;: c = &#39;j&#39;; break;
 82                     case &#39;\u2510&#39;: c = &#39;k&#39;; break;
 83                     case &#39;\u250C&#39;: c = &#39;l&#39;; break;
 84                     case &#39;\u2514&#39;: c = &#39;m&#39;; break;
 85                     case &#39;\u253C&#39;: c = &#39;n&#39;; break;
 86                     case &#39;\u2500&#39;: c = &#39;q&#39;; break;
 87                     case &#39;\u251C&#39;: c = &#39;t&#39;; break;
 88                     case &#39;\u2524&#39;: c = &#39;u&#39;; break;
 89                     case &#39;\u2534&#39;: c = &#39;v&#39;; break;
 90                     case &#39;\u252C&#39;: c = &#39;w&#39;; break;
 91                     case &#39;\u2502&#39;: c = &#39;x&#39;; break;
 92                 }
 93                 boolean oldalt = alt;
 94                 alt = c != pc;
 95                 if (oldalt ^ alt) {
 96                     sb.append(alt ? altIn : altOut);
 97                 }
 98             }
 99             int  s = styleCodeAt(i) &amp; ~F_HIDDEN; // The hidden flag does not change the ansi styles
100             if (style != s) {
101                 int  d = (style ^ s) &amp; MASK;
102                 int fg = (s &amp; F_FOREGROUND) != 0 ? (s &amp; FG_COLOR) &gt;&gt;&gt; FG_COLOR_EXP : -1;
103                 int bg = (s &amp; F_BACKGROUND) != 0 ? (s &amp; BG_COLOR) &gt;&gt;&gt; BG_COLOR_EXP : -1;
104                 if (s == 0) {
105                     sb.append(&quot;\033[0m&quot;);
106                     foreground = background = -1;
107                 } else {
108                     sb.append(&quot;\033[&quot;);
109                     boolean first = true;
110                     if ((d &amp; F_ITALIC) != 0) {
111                         first = attr(sb, (s &amp; F_ITALIC) != 0 ? &quot;3&quot; : &quot;23&quot;, first);
112                     }
113                     if ((d &amp; F_UNDERLINE) != 0) {
114                         first = attr(sb, (s &amp; F_UNDERLINE) != 0 ? &quot;4&quot; : &quot;24&quot;, first);
115                     }
116                     if ((d &amp; F_BLINK) != 0) {
117                         first = attr(sb, (s &amp; F_BLINK) != 0 ? &quot;5&quot; : &quot;25&quot;, first);
118                     }
119                     if ((d &amp; F_INVERSE) != 0) {
120                         first = attr(sb, (s &amp; F_INVERSE) != 0 ? &quot;7&quot; : &quot;27&quot;, first);
121                     }
122                     if ((d &amp; F_CONCEAL) != 0) {
123                         first = attr(sb, (s &amp; F_CONCEAL) != 0 ? &quot;8&quot; : &quot;28&quot;, first);
124                     }
125                     if ((d &amp; F_CROSSED_OUT) != 0) {
126                         first = attr(sb, (s &amp; F_CROSSED_OUT) != 0 ? &quot;9&quot; : &quot;29&quot;, first);
127                     }
128                     if (foreground != fg) {
129                         if (fg &gt;= 0) {
130                             int rounded = Colors.roundColor(fg, colors);
131                             if (rounded &lt; 8 &amp;&amp; !force256colors) {
132                                 first = attr(sb, &quot;3&quot; + Integer.toString(rounded), first);
133                                 // small hack to force setting bold again after a foreground color change
134                                 d |= (s &amp; F_BOLD);
135                             } else if (rounded &lt; 16 &amp;&amp; !force256colors) {
136                                 first = attr(sb, &quot;9&quot; + Integer.toString(rounded - 8), first);
137                                 // small hack to force setting bold again after a foreground color change
138                                 d |= (s &amp; F_BOLD);
139                             } else {
140                                 first = attr(sb, &quot;38;5;&quot; + Integer.toString(rounded), first);
141                             }
142                         } else {
143                             first = attr(sb, &quot;39&quot;, first);
144                         }
145                         foreground = fg;
146                     }
147                     if (background != bg) {
148                         if (bg &gt;= 0) {
149                             int rounded = Colors.roundColor(bg, colors);
150                             if (rounded &lt; 8 &amp;&amp; !force256colors) {
151                                 first = attr(sb, &quot;4&quot; + Integer.toString(rounded), first);
152                             } else if (rounded &lt; 16 &amp;&amp; !force256colors) {
153                                 first = attr(sb, &quot;10&quot; + Integer.toString(rounded - 8), first);
154                             } else {
155                                 first = attr(sb, &quot;48;5;&quot; + Integer.toString(rounded), first);
156                             }
157                         } else {
158                             first = attr(sb, &quot;49&quot;, first);
159                         }
160                         background = bg;
161                     }
162                     if ((d &amp; (F_BOLD | F_FAINT)) != 0) {
163                         if (    (d &amp; F_BOLD)  != 0 &amp;&amp; (s &amp; F_BOLD)  == 0
164                                 || (d &amp; F_FAINT) != 0 &amp;&amp; (s &amp; F_FAINT) == 0) {
165                             first = attr(sb, &quot;22&quot;, first);
166                         }
167                         if ((d &amp; F_BOLD) != 0 &amp;&amp; (s &amp; F_BOLD) != 0) {
168                             first = attr(sb, &quot;1&quot;, first);
169                         }
170                         if ((d &amp; F_FAINT) != 0 &amp;&amp; (s &amp; F_FAINT) != 0) {
171                             first = attr(sb, &quot;2&quot;, first);
172                         }
173                     }
174                     sb.append(&quot;m&quot;);
175                 }
176                 style = s;
177             }
178             sb.append(c);
179         }
180         if (alt) {
181             sb.append(altOut);
182         }
183         if (style != 0) {
184             sb.append(&quot;\033[0m&quot;);
185         }
186         return sb.toString();
187     }
188 
189     @Deprecated
190     public static int rgbColor(int col) {
191         return Colors.rgbColor(col);
192     }
193 
194     @Deprecated
195     public static int roundColor(int col, int max) {
196         return Colors.roundColor(col, max);
197     }
198 
199     @Deprecated
200     public static int roundRgbColor(int r, int g, int b, int max) {
201         return Colors.roundRgbColor(r, g, b, max);
202     }
203 
204     private static boolean attr(StringBuilder sb, String s, boolean first) {
205         if (!first) {
206             sb.append(&quot;;&quot;);
207         }
208         sb.append(s);
209         return false;
210     }
211 
212     public abstract AttributedStyle styleAt(int index);
213 
214     int styleCodeAt(int index) {
215         return styleAt(index).getStyle();
216     }
217 
218     public boolean isHidden(int index) {
219         return (styleCodeAt(index) &amp; F_HIDDEN) != 0;
220     }
221 
222     public int runStart(int index) {
223         AttributedStyle style = styleAt(index);
224         while (index &gt; 0 &amp;&amp; styleAt(index - 1).equals(style)) {
225             index--;
226         }
227         return index;
228     }
229 
230     public int runLimit(int index) {
231         AttributedStyle style = styleAt(index);
232         while (index &lt; length() - 1 &amp;&amp; styleAt(index + 1).equals(style)) {
233             index++;
234         }
235         return index + 1;
236     }
237 
238     @Override
239     public abstract AttributedString subSequence(int start, int end);
240 
241     public AttributedString substring(int start, int end) {
242         return subSequence(start, end);
243     }
244 
245     protected abstract char[] buffer();
246 
247     protected abstract int offset();
248 
249     @Override
250     public char charAt(int index) {
251         return buffer()[offset() + index];
252     }
253 
254     public int codePointAt(int index) {
255         return Character.codePointAt(buffer(), index + offset());
256     }
257 
258     public boolean contains(char c) {
259         for (int i = 0; i &lt; length(); i++) {
260             if (charAt(i) == c) {
261                 return true;
262             }
263         }
264         return false;
265     }
266 
267     public int codePointBefore(int index) {
268         return Character.codePointBefore(buffer(), index + offset());
269     }
270 
271     public int codePointCount(int index, int length) {
272         return Character.codePointCount(buffer(), index + offset(), length);
273     }
274 
275     public int columnLength() {
276         int cols = 0;
277         int len = length();
278         for (int cur = 0; cur &lt; len; ) {
279             int cp = codePointAt(cur);
280             if (!isHidden(cur))
281                 cols += WCWidth.wcwidth(cp);
282             cur += Character.charCount(cp);
283         }
284         return cols;
285     }
286 
287     public AttributedString columnSubSequence(int start, int stop) {
288         int begin = 0;
289         int col = 0;
290         while (begin &lt; this.length()) {
291             int cp = codePointAt(begin);
292             int w = isHidden(begin) ? 0 : WCWidth.wcwidth(cp);
293             if (col + w &gt; start) {
294                 break;
295             }
296             begin++;
297             col += w;
298         }
299         int end = begin;
300         while (end &lt; this.length()) {
301             int cp = codePointAt(end);
302             if (cp == &#39;\n&#39;)
303                 break;
304             int w = isHidden(end) ? 0 : WCWidth.wcwidth(cp);
305             if (col + w &gt; stop) {
306                 break;
307             }
308             end++;
309             col += w;
310         }
311         return subSequence(begin, end);
312     }
313 
314     public List&lt;AttributedString&gt; columnSplitLength(int columns) {
315         return columnSplitLength(columns, false, true);
316     }
317 
318     public List&lt;AttributedString&gt; columnSplitLength(int columns, boolean includeNewlines, boolean delayLineWrap) {
319         List&lt;AttributedString&gt; strings = new ArrayList&lt;&gt;();
320         int cur = 0;
321         int beg = cur;
322         int col = 0;
323         while (cur &lt; length()) {
324             int cp = codePointAt(cur);
325             int w = isHidden(cur) ? 0 : WCWidth.wcwidth(cp);
326             if (cp == &#39;\n&#39;) {
327                 strings.add(subSequence(beg, includeNewlines ? cur+1 : cur));
328                 beg = cur + 1;
329                 col = 0;
330             } else if ((col += w) &gt; columns) {
331                 strings.add(subSequence(beg, cur));
332                 beg = cur;
333                 col = w;
334             }
335             cur += Character.charCount(cp);
336         }
337         strings.add(subSequence(beg, cur));
338         return strings;
339     }
340 
341     @Override
342     public String toString() {
343         return new String(buffer(), offset(), length());
344     }
345 
346     public AttributedString toAttributedString() {
347         return substring(0, length());
348     }
349 
350 }
    </pre>
  </body>
</html>
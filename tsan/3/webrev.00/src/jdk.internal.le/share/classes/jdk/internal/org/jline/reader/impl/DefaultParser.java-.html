<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/DefaultParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.reader.impl;
 10 
 11 import java.util.*;
 12 import java.util.function.Predicate;
 13 
 14 import jdk.internal.org.jline.reader.CompletingParsedLine;
 15 import jdk.internal.org.jline.reader.EOFError;
 16 import jdk.internal.org.jline.reader.ParsedLine;
 17 import jdk.internal.org.jline.reader.Parser;
 18 
 19 public class DefaultParser implements Parser {
 20 
 21     private char[] quoteChars = {&#39;\&#39;&#39;, &#39;&quot;&#39;};
 22 
 23     private char[] escapeChars = {&#39;\\&#39;};
 24 
 25     private boolean eofOnUnclosedQuote;
 26 
 27     private boolean eofOnEscapedNewLine;
 28 
 29     //
 30     // Chainable setters
 31     //
 32 
 33     public DefaultParser quoteChars(final char[] chars) {
 34         this.quoteChars = chars;
 35         return this;
 36     }
 37 
 38     public DefaultParser escapeChars(final char[] chars) {
 39         this.escapeChars = chars;
 40         return this;
 41     }
 42 
 43     public DefaultParser eofOnUnclosedQuote(boolean eofOnUnclosedQuote) {
 44         this.eofOnUnclosedQuote = eofOnUnclosedQuote;
 45         return this;
 46     }
 47 
 48     public DefaultParser eofOnEscapedNewLine(boolean eofOnEscapedNewLine) {
 49         this.eofOnEscapedNewLine = eofOnEscapedNewLine;
 50         return this;
 51     }
 52 
 53     //
 54     // Java bean getters and setters
 55     //
 56 
 57     public void setQuoteChars(final char[] chars) {
 58         this.quoteChars = chars;
 59     }
 60 
 61     public char[] getQuoteChars() {
 62         return this.quoteChars;
 63     }
 64 
 65     public void setEscapeChars(final char[] chars) {
 66         this.escapeChars = chars;
 67     }
 68 
 69     public char[] getEscapeChars() {
 70         return this.escapeChars;
 71     }
 72 
 73     public void setEofOnUnclosedQuote(boolean eofOnUnclosedQuote) {
 74         this.eofOnUnclosedQuote = eofOnUnclosedQuote;
 75     }
 76 
 77     public boolean isEofOnUnclosedQuote() {
 78         return eofOnUnclosedQuote;
 79     }
 80 
 81     public void setEofOnEscapedNewLine(boolean eofOnEscapedNewLine) {
 82         this.eofOnEscapedNewLine = eofOnEscapedNewLine;
 83     }
 84 
 85     public boolean isEofOnEscapedNewLine() {
 86         return eofOnEscapedNewLine;
 87     }
 88 
 89     public ParsedLine parse(final String line, final int cursor, ParseContext context) {
 90         List&lt;String&gt; words = new LinkedList&lt;&gt;();
 91         StringBuilder current = new StringBuilder();
 92         int wordCursor = -1;
 93         int wordIndex = -1;
 94         int quoteStart = -1;
 95         int rawWordCursor = -1;
 96         int rawWordLength = -1;
 97         int rawWordStart = 0;
 98 
 99         for (int i = 0; (line != null) &amp;&amp; (i &lt; line.length()); i++) {
100             // once we reach the cursor, set the
101             // position of the selected index
102             if (i == cursor) {
103                 wordIndex = words.size();
104                 // the position in the current argument is just the
105                 // length of the current argument
106                 wordCursor = current.length();
107                 rawWordCursor = i - rawWordStart;
108             }
109 
110             if (quoteStart &lt; 0 &amp;&amp; isQuoteChar(line, i)) {
111                 // Start a quote block
112                 quoteStart = i;
113             } else if (quoteStart &gt;= 0) {
114                 // In a quote block
115                 if (line.charAt(quoteStart) == line.charAt(i) &amp;&amp; !isEscaped(line, i)) {
116                     // End the block; arg could be empty, but that&#39;s fine
117                     words.add(current.toString());
118                     current.setLength(0);
119                     quoteStart = -1;
120                     if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {
121                         rawWordLength = i - rawWordStart + 1;
122                     }
123                 } else {
124                     if (!isEscapeChar(line, i)) {
125                         // Take the next character
126                         current.append(line.charAt(i));
127                     }
128                 }
129             } else {
130                 // Not in a quote block
131                 if (isDelimiter(line, i)) {
132                     if (current.length() &gt; 0) {
133                         words.add(current.toString());
134                         current.setLength(0); // reset the arg
135                         if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {
136                             rawWordLength = i - rawWordStart;
137                         }
138                     }
139                     rawWordStart = i + 1;
140                 } else {
141                     if (!isEscapeChar(line, i)) {
142                         current.append(line.charAt(i));
143                     }
144                 }
145             }
146         }
147 
148         if (current.length() &gt; 0 || cursor == line.length()) {
149             words.add(current.toString());
150             if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {
151                 rawWordLength = line.length() - rawWordStart;
152             }
153         }
154 
155         if (cursor == line.length()) {
156             wordIndex = words.size() - 1;
157             wordCursor = words.get(words.size() - 1).length();
158             rawWordCursor = cursor - rawWordStart;
159             rawWordLength = rawWordCursor;
160         }
161 
162         if (eofOnEscapedNewLine &amp;&amp; isEscapeChar(line, line.length() - 1)) {
163             throw new EOFError(-1, -1, &quot;Escaped new line&quot;, &quot;newline&quot;);
164         }
165         if (eofOnUnclosedQuote &amp;&amp; quoteStart &gt;= 0 &amp;&amp; context != ParseContext.COMPLETE) {
166             throw new EOFError(-1, -1, &quot;Missing closing quote&quot;, line.charAt(quoteStart) == &#39;\&#39;&#39;
167                     ? &quot;quote&quot; : &quot;dquote&quot;);
168         }
169 
170         String openingQuote = quoteStart &gt;= 0 ? line.substring(quoteStart, quoteStart + 1) : null;
171         return new ArgumentList(line, words, wordIndex, wordCursor, cursor, openingQuote, rawWordCursor, rawWordLength);
172     }
173 
174     /**
175      * Returns true if the specified character is a whitespace parameter. Check to ensure that the character is not
176      * escaped by any of {@link #getQuoteChars}, and is not escaped by ant of the {@link #getEscapeChars}, and
177      * returns true from {@link #isDelimiterChar}.
178      *
179      * @param buffer    The complete command buffer
180      * @param pos       The index of the character in the buffer
181      * @return          True if the character should be a delimiter
182      */
183     public boolean isDelimiter(final CharSequence buffer, final int pos) {
184         return !isQuoted(buffer, pos) &amp;&amp; !isEscaped(buffer, pos) &amp;&amp; isDelimiterChar(buffer, pos);
185     }
186 
187     public boolean isQuoted(final CharSequence buffer, final int pos) {
188         return false;
189     }
190 
191     public boolean isQuoteChar(final CharSequence buffer, final int pos) {
192         if (pos &lt; 0) {
193             return false;
194         }
195         if (quoteChars != null) {
196             for (char e : quoteChars) {
197                 if (e == buffer.charAt(pos)) {
198                     return !isEscaped(buffer, pos);
199                 }
200             }
201         }
202         return false;
203     }
204 
205     /**
206      * Check if this character is a valid escape char (i.e. one that has not been escaped)
207      *
208      * @param buffer
209      *          the buffer to check in
210      * @param pos
211      *          the position of the character to check
212      * @return true if the character at the specified position in the given buffer is an escape
213      *         character and the character immediately preceding it is not an escape character.
214      */
215     public boolean isEscapeChar(final CharSequence buffer, final int pos) {
216         if (pos &lt; 0) {
217             return false;
218         }
219         if (escapeChars != null) {
220             for (char e : escapeChars) {
221                 if (e == buffer.charAt(pos)) {
222                     return !isEscaped(buffer, pos);
223                 }
224             }
225         }
226         return false;
227     }
228 
229     /**
230      * Check if a character is escaped (i.e. if the previous character is an escape)
231      *
232      * @param buffer
233      *          the buffer to check in
234      * @param pos
235      *          the position of the character to check
236      * @return true if the character at the specified position in the given buffer is an escape
237      *         character and the character immediately preceding it is an escape character.
238      */
239     public boolean isEscaped(final CharSequence buffer, final int pos) {
240         if (pos &lt;= 0) {
241             return false;
242         }
243         return isEscapeChar(buffer, pos - 1);
244     }
245 
246     /**
247      * Returns true if the character at the specified position if a delimiter. This method will only be called if
248      * the character is not enclosed in any of the {@link #getQuoteChars}, and is not escaped by ant of the
249      * {@link #getEscapeChars}. To perform escaping manually, override {@link #isDelimiter} instead.
250      *
251      * @param buffer
252      *          the buffer to check in
253      * @param pos
254      *          the position of the character to check
255      * @return true if the character at the specified position in the given buffer is a delimiter.
256      */
257     public boolean isDelimiterChar(CharSequence buffer, int pos) {
258         return Character.isWhitespace(buffer.charAt(pos));
259     }
260 
261     private boolean isRawEscapeChar(char key) {
262         if (escapeChars != null) {
263             for (char e : escapeChars) {
264                 if (e == key) {
265                     return true;
266                 }
267             }
268         }
269         return false;
270     }
271 
272     private boolean isRawQuoteChar(char key) {
273         if (quoteChars != null) {
274             for (char e : quoteChars) {
275                 if (e == key) {
276                     return true;
277                 }
278             }
279         }
280         return false;
281     }
282 
283     /**
284      * The result of a delimited buffer.
285      *
286      * @author &lt;a href=&quot;mailto:mwp1@cornell.edu&quot;&gt;Marc Prud&#39;hommeaux&lt;/a&gt;
287      */
288     public class ArgumentList implements ParsedLine, CompletingParsedLine
289     {
290         private final String line;
291 
292         private final List&lt;String&gt; words;
293 
294         private final int wordIndex;
295 
296         private final int wordCursor;
297 
298         private final int cursor;
299 
300         private final String openingQuote;
301 
302         private final int rawWordCursor;
303 
304         private final int rawWordLength;
305 
306         @Deprecated
307         public ArgumentList(final String line, final List&lt;String&gt; words,
308                             final int wordIndex, final int wordCursor,
309                             final int cursor) {
310             this(line, words, wordIndex, wordCursor, cursor,
311                     null, wordCursor, words.get(wordIndex).length());
312         }
313 
314         /**
315          *
316          * @param line the command line being edited
317          * @param words the list of words
318          * @param wordIndex the index of the current word in the list of words
319          * @param wordCursor the cursor position within the current word
320          * @param cursor the cursor position within the line
321          * @param openingQuote the opening quote (usually &#39;\&quot;&#39; or &#39;\&#39;&#39;) or null
322          * @param rawWordCursor the cursor position inside the raw word (i.e. including quotes and escape characters)
323          * @param rawWordLength the raw word length, including quotes and escape characters
324          */
325         public ArgumentList(final String line, final List&lt;String&gt; words,
326                             final int wordIndex, final int wordCursor,
327                             final int cursor, final String openingQuote,
328                             final int rawWordCursor, final int rawWordLength) {
329             this.line = line;
330             this.words = Collections.unmodifiableList(Objects.requireNonNull(words));
331             this.wordIndex = wordIndex;
332             this.wordCursor = wordCursor;
333             this.cursor = cursor;
334             this.openingQuote = openingQuote;
335             this.rawWordCursor = rawWordCursor;
336             this.rawWordLength = rawWordLength;
337         }
338 
339         public int wordIndex() {
340             return this.wordIndex;
341         }
342 
343         public String word() {
344             // TODO: word() should always be contained in words()
345             if ((wordIndex &lt; 0) || (wordIndex &gt;= words.size())) {
346                 return &quot;&quot;;
347             }
348             return words.get(wordIndex);
349         }
350 
351         public int wordCursor() {
352             return this.wordCursor;
353         }
354 
355         public List&lt;String&gt; words() {
356             return this.words;
357         }
358 
359         public int cursor() {
360             return this.cursor;
361         }
362 
363         public String line() {
364             return line;
365         }
366 
367         public CharSequence escape(CharSequence candidate, boolean complete) {
368             StringBuilder sb = new StringBuilder(candidate);
369             Predicate&lt;Integer&gt; needToBeEscaped;
370             // Completion is protected by an opening quote:
371             // Delimiters (spaces) don&#39;t need to be escaped, nor do other quotes, but everything else does.
372             // Also, close the quote at the end
373             if (openingQuote != null) {
374                 needToBeEscaped = i -&gt; isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);
375             }
376             // No quote protection, need to escape everything: delimiter chars (spaces), quote chars
377             // and escapes themselves
378             else {
379                 needToBeEscaped = i -&gt; isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));
380             }
381             for (int i = 0; i &lt; sb.length(); i++) {
382                 if (needToBeEscaped.test(i)) {
383                     sb.insert(i++, escapeChars[0]);
384                 }
385             }
386             if (openingQuote != null) {
387                 sb.insert(0, openingQuote);
388                 if (complete) {
389                     sb.append(openingQuote);
390                 }
391             }
392             return sb;
393         }
394 
395         @Override
396         public int rawWordCursor() {
397             return rawWordCursor;
398         }
399 
400         @Override
401         public int rawWordLength() {
402             return rawWordLength;
403         }
404     }
405 
406 }
    </pre>
  </body>
</html>
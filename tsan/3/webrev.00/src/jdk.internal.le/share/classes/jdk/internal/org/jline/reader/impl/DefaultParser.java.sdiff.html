<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/DefaultParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultHighlighter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="KillRing.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/DefaultParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.reader.impl;
 10 
 11 import java.util.*;
 12 import java.util.function.Predicate;
 13 
 14 import jdk.internal.org.jline.reader.CompletingParsedLine;
 15 import jdk.internal.org.jline.reader.EOFError;
 16 import jdk.internal.org.jline.reader.ParsedLine;
 17 import jdk.internal.org.jline.reader.Parser;
 18 
 19 public class DefaultParser implements Parser {
 20 







 21     private char[] quoteChars = {&#39;\&#39;&#39;, &#39;&quot;&#39;};
 22 
 23     private char[] escapeChars = {&#39;\\&#39;};
 24 
 25     private boolean eofOnUnclosedQuote;
 26 
 27     private boolean eofOnEscapedNewLine;
 28 




 29     //
 30     // Chainable setters
 31     //
 32 
 33     public DefaultParser quoteChars(final char[] chars) {
 34         this.quoteChars = chars;
 35         return this;
 36     }
 37 
 38     public DefaultParser escapeChars(final char[] chars) {
 39         this.escapeChars = chars;
 40         return this;
 41     }
 42 
 43     public DefaultParser eofOnUnclosedQuote(boolean eofOnUnclosedQuote) {
 44         this.eofOnUnclosedQuote = eofOnUnclosedQuote;
 45         return this;
 46     }
 47 





 48     public DefaultParser eofOnEscapedNewLine(boolean eofOnEscapedNewLine) {
 49         this.eofOnEscapedNewLine = eofOnEscapedNewLine;
 50         return this;
 51     }
 52 
 53     //
 54     // Java bean getters and setters
 55     //
 56 
 57     public void setQuoteChars(final char[] chars) {
 58         this.quoteChars = chars;
 59     }
 60 
 61     public char[] getQuoteChars() {
 62         return this.quoteChars;
 63     }
 64 
 65     public void setEscapeChars(final char[] chars) {
 66         this.escapeChars = chars;
 67     }
</pre>
<hr />
<pre>
 69     public char[] getEscapeChars() {
 70         return this.escapeChars;
 71     }
 72 
 73     public void setEofOnUnclosedQuote(boolean eofOnUnclosedQuote) {
 74         this.eofOnUnclosedQuote = eofOnUnclosedQuote;
 75     }
 76 
 77     public boolean isEofOnUnclosedQuote() {
 78         return eofOnUnclosedQuote;
 79     }
 80 
 81     public void setEofOnEscapedNewLine(boolean eofOnEscapedNewLine) {
 82         this.eofOnEscapedNewLine = eofOnEscapedNewLine;
 83     }
 84 
 85     public boolean isEofOnEscapedNewLine() {
 86         return eofOnEscapedNewLine;
 87     }
 88 

































 89     public ParsedLine parse(final String line, final int cursor, ParseContext context) {
 90         List&lt;String&gt; words = new LinkedList&lt;&gt;();
 91         StringBuilder current = new StringBuilder();
 92         int wordCursor = -1;
 93         int wordIndex = -1;
 94         int quoteStart = -1;
 95         int rawWordCursor = -1;
 96         int rawWordLength = -1;
 97         int rawWordStart = 0;


 98 
 99         for (int i = 0; (line != null) &amp;&amp; (i &lt; line.length()); i++) {
100             // once we reach the cursor, set the
101             // position of the selected index
102             if (i == cursor) {
103                 wordIndex = words.size();
104                 // the position in the current argument is just the
105                 // length of the current argument
106                 wordCursor = current.length();
107                 rawWordCursor = i - rawWordStart;
108             }
109 
110             if (quoteStart &lt; 0 &amp;&amp; isQuoteChar(line, i)) {
111                 // Start a quote block
112                 quoteStart = i;
<span class="line-modified">113             } else if (quoteStart &gt;= 0) {</span>
<span class="line-modified">114                 // In a quote block</span>
<span class="line-modified">115                 if (line.charAt(quoteStart) == line.charAt(i) &amp;&amp; !isEscaped(line, i)) {</span>
<span class="line-modified">116                     // End the block; arg could be empty, but that&#39;s fine</span>













117                     words.add(current.toString());
<span class="line-modified">118                     current.setLength(0);</span>
<span class="line-removed">119                     quoteStart = -1;</span>
120                     if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {
<span class="line-modified">121                         rawWordLength = i - rawWordStart + 1;</span>
<span class="line-removed">122                     }</span>
<span class="line-removed">123                 } else {</span>
<span class="line-removed">124                     if (!isEscapeChar(line, i)) {</span>
<span class="line-removed">125                         // Take the next character</span>
<span class="line-removed">126                         current.append(line.charAt(i));</span>
127                     }
128                 }

129             } else {
<span class="line-modified">130                 // Not in a quote block</span>
<span class="line-modified">131                 if (isDelimiter(line, i)) {</span>
<span class="line-modified">132                     if (current.length() &gt; 0) {</span>
<span class="line-modified">133                         words.add(current.toString());</span>
<span class="line-removed">134                         current.setLength(0); // reset the arg</span>
<span class="line-removed">135                         if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {</span>
<span class="line-removed">136                             rawWordLength = i - rawWordStart;</span>
<span class="line-removed">137                         }</span>
<span class="line-removed">138                     }</span>
<span class="line-removed">139                     rawWordStart = i + 1;</span>
<span class="line-removed">140                 } else {</span>
<span class="line-removed">141                     if (!isEscapeChar(line, i)) {</span>
<span class="line-removed">142                         current.append(line.charAt(i));</span>
143                     }
144                 }
145             }
146         }
147 
148         if (current.length() &gt; 0 || cursor == line.length()) {
149             words.add(current.toString());
150             if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {
151                 rawWordLength = line.length() - rawWordStart;
152             }
153         }
154 
155         if (cursor == line.length()) {
156             wordIndex = words.size() - 1;
157             wordCursor = words.get(words.size() - 1).length();
158             rawWordCursor = cursor - rawWordStart;
159             rawWordLength = rawWordCursor;
160         }
161 
<span class="line-modified">162         if (eofOnEscapedNewLine &amp;&amp; isEscapeChar(line, line.length() - 1)) {</span>
<span class="line-modified">163             throw new EOFError(-1, -1, &quot;Escaped new line&quot;, &quot;newline&quot;);</span>
<span class="line-modified">164         }</span>
<span class="line-modified">165         if (eofOnUnclosedQuote &amp;&amp; quoteStart &gt;= 0 &amp;&amp; context != ParseContext.COMPLETE) {</span>
<span class="line-modified">166             throw new EOFError(-1, -1, &quot;Missing closing quote&quot;, line.charAt(quoteStart) == &#39;\&#39;&#39;</span>
<span class="line-modified">167                     ? &quot;quote&quot; : &quot;dquote&quot;);</span>








168         }
169 
<span class="line-modified">170         String openingQuote = quoteStart &gt;= 0 ? line.substring(quoteStart, quoteStart + 1) : null;</span>
171         return new ArgumentList(line, words, wordIndex, wordCursor, cursor, openingQuote, rawWordCursor, rawWordLength);
172     }
173 
174     /**
175      * Returns true if the specified character is a whitespace parameter. Check to ensure that the character is not
<span class="line-modified">176      * escaped by any of {@link #getQuoteChars}, and is not escaped by ant of the {@link #getEscapeChars}, and</span>
177      * returns true from {@link #isDelimiterChar}.
178      *
179      * @param buffer    The complete command buffer
180      * @param pos       The index of the character in the buffer
181      * @return          True if the character should be a delimiter
182      */
183     public boolean isDelimiter(final CharSequence buffer, final int pos) {
184         return !isQuoted(buffer, pos) &amp;&amp; !isEscaped(buffer, pos) &amp;&amp; isDelimiterChar(buffer, pos);
185     }
186 
187     public boolean isQuoted(final CharSequence buffer, final int pos) {
188         return false;
189     }
190 
191     public boolean isQuoteChar(final CharSequence buffer, final int pos) {
192         if (pos &lt; 0) {
193             return false;
194         }
195         if (quoteChars != null) {
196             for (char e : quoteChars) {
197                 if (e == buffer.charAt(pos)) {
198                     return !isEscaped(buffer, pos);
199                 }
200             }
201         }
202         return false;
203     }
204 












205     /**
206      * Check if this character is a valid escape char (i.e. one that has not been escaped)
207      *
208      * @param buffer
209      *          the buffer to check in
210      * @param pos
211      *          the position of the character to check
212      * @return true if the character at the specified position in the given buffer is an escape
213      *         character and the character immediately preceding it is not an escape character.
214      */
215     public boolean isEscapeChar(final CharSequence buffer, final int pos) {
216         if (pos &lt; 0) {
217             return false;
218         }
<span class="line-modified">219         if (escapeChars != null) {</span>
<span class="line-modified">220             for (char e : escapeChars) {</span>
<span class="line-removed">221                 if (e == buffer.charAt(pos)) {</span>
<span class="line-removed">222                     return !isEscaped(buffer, pos);</span>
<span class="line-removed">223                 }</span>
<span class="line-removed">224             }</span>
<span class="line-removed">225         }</span>
<span class="line-removed">226         return false;</span>
227     }
228 
229     /**
230      * Check if a character is escaped (i.e. if the previous character is an escape)
231      *
232      * @param buffer
233      *          the buffer to check in
234      * @param pos
235      *          the position of the character to check
236      * @return true if the character at the specified position in the given buffer is an escape
237      *         character and the character immediately preceding it is an escape character.
238      */
239     public boolean isEscaped(final CharSequence buffer, final int pos) {
240         if (pos &lt;= 0) {
241             return false;
242         }
243         return isEscapeChar(buffer, pos - 1);
244     }
245 
246     /**
247      * Returns true if the character at the specified position if a delimiter. This method will only be called if
<span class="line-modified">248      * the character is not enclosed in any of the {@link #getQuoteChars}, and is not escaped by ant of the</span>
249      * {@link #getEscapeChars}. To perform escaping manually, override {@link #isDelimiter} instead.
250      *
251      * @param buffer
252      *          the buffer to check in
253      * @param pos
254      *          the position of the character to check
255      * @return true if the character at the specified position in the given buffer is a delimiter.
256      */
257     public boolean isDelimiterChar(CharSequence buffer, int pos) {
258         return Character.isWhitespace(buffer.charAt(pos));
259     }
260 
261     private boolean isRawEscapeChar(char key) {
262         if (escapeChars != null) {
263             for (char e : escapeChars) {
264                 if (e == key) {
265                     return true;
266                 }
267             }
268         }
269         return false;
270     }
271 
272     private boolean isRawQuoteChar(char key) {
273         if (quoteChars != null) {
274             for (char e : quoteChars) {
275                 if (e == key) {
276                     return true;
277                 }
278             }
279         }
280         return false;
281     }
282 





























































283     /**
284      * The result of a delimited buffer.
285      *
286      * @author &lt;a href=&quot;mailto:mwp1@cornell.edu&quot;&gt;Marc Prud&#39;hommeaux&lt;/a&gt;
287      */
288     public class ArgumentList implements ParsedLine, CompletingParsedLine
289     {
290         private final String line;
291 
292         private final List&lt;String&gt; words;
293 
294         private final int wordIndex;
295 
296         private final int wordCursor;
297 
298         private final int cursor;
299 
300         private final String openingQuote;
301 
302         private final int rawWordCursor;
</pre>
<hr />
<pre>
350 
351         public int wordCursor() {
352             return this.wordCursor;
353         }
354 
355         public List&lt;String&gt; words() {
356             return this.words;
357         }
358 
359         public int cursor() {
360             return this.cursor;
361         }
362 
363         public String line() {
364             return line;
365         }
366 
367         public CharSequence escape(CharSequence candidate, boolean complete) {
368             StringBuilder sb = new StringBuilder(candidate);
369             Predicate&lt;Integer&gt; needToBeEscaped;
<span class="line-modified">370             // Completion is protected by an opening quote:</span>
<span class="line-modified">371             // Delimiters (spaces) don&#39;t need to be escaped, nor do other quotes, but everything else does.</span>
<span class="line-modified">372             // Also, close the quote at the end</span>
<span class="line-modified">373             if (openingQuote != null) {</span>
<span class="line-modified">374                 needToBeEscaped = i -&gt; isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);</span>
<span class="line-modified">375             }</span>
<span class="line-modified">376             // No quote protection, need to escape everything: delimiter chars (spaces), quote chars</span>
<span class="line-modified">377             // and escapes themselves</span>
<span class="line-modified">378             else {</span>
<span class="line-removed">379                 needToBeEscaped = i -&gt; isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));</span>
380             }
<span class="line-modified">381             for (int i = 0; i &lt; sb.length(); i++) {</span>
<span class="line-modified">382                 if (needToBeEscaped.test(i)) {</span>
<span class="line-modified">383                     sb.insert(i++, escapeChars[0]);</span>

























384                 }
385             }
<span class="line-modified">386             if (openingQuote != null) {</span>
<span class="line-modified">387                 sb.insert(0, openingQuote);</span>
388                 if (complete) {
<span class="line-modified">389                     sb.append(openingQuote);</span>
390                 }
391             }
392             return sb;
393         }
394 
395         @Override
396         public int rawWordCursor() {
397             return rawWordCursor;
398         }
399 
400         @Override
401         public int rawWordLength() {
402             return rawWordLength;
403         }
404     }
405 
406 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * https://opensource.org/licenses/BSD-3-Clause</span>
  8  */
  9 package jdk.internal.org.jline.reader.impl;
 10 
 11 import java.util.*;
 12 import java.util.function.Predicate;
 13 
 14 import jdk.internal.org.jline.reader.CompletingParsedLine;
 15 import jdk.internal.org.jline.reader.EOFError;
 16 import jdk.internal.org.jline.reader.ParsedLine;
 17 import jdk.internal.org.jline.reader.Parser;
 18 
 19 public class DefaultParser implements Parser {
 20 
<span class="line-added"> 21     public enum Bracket {</span>
<span class="line-added"> 22         ROUND,   // ()</span>
<span class="line-added"> 23         CURLY,   // {}</span>
<span class="line-added"> 24         SQUARE,  // []</span>
<span class="line-added"> 25         ANGLE;   // &lt;&gt;</span>
<span class="line-added"> 26     }</span>
<span class="line-added"> 27 </span>
 28     private char[] quoteChars = {&#39;\&#39;&#39;, &#39;&quot;&#39;};
 29 
 30     private char[] escapeChars = {&#39;\\&#39;};
 31 
 32     private boolean eofOnUnclosedQuote;
 33 
 34     private boolean eofOnEscapedNewLine;
 35 
<span class="line-added"> 36     private char[] openingBrackets = null;</span>
<span class="line-added"> 37 </span>
<span class="line-added"> 38     private char[] closingBrackets = null;</span>
<span class="line-added"> 39 </span>
 40     //
 41     // Chainable setters
 42     //
 43 
 44     public DefaultParser quoteChars(final char[] chars) {
 45         this.quoteChars = chars;
 46         return this;
 47     }
 48 
 49     public DefaultParser escapeChars(final char[] chars) {
 50         this.escapeChars = chars;
 51         return this;
 52     }
 53 
 54     public DefaultParser eofOnUnclosedQuote(boolean eofOnUnclosedQuote) {
 55         this.eofOnUnclosedQuote = eofOnUnclosedQuote;
 56         return this;
 57     }
 58 
<span class="line-added"> 59     public DefaultParser eofOnUnclosedBracket(Bracket... brackets){</span>
<span class="line-added"> 60         setEofOnUnclosedBracket(brackets);</span>
<span class="line-added"> 61         return this;</span>
<span class="line-added"> 62     }</span>
<span class="line-added"> 63 </span>
 64     public DefaultParser eofOnEscapedNewLine(boolean eofOnEscapedNewLine) {
 65         this.eofOnEscapedNewLine = eofOnEscapedNewLine;
 66         return this;
 67     }
 68 
 69     //
 70     // Java bean getters and setters
 71     //
 72 
 73     public void setQuoteChars(final char[] chars) {
 74         this.quoteChars = chars;
 75     }
 76 
 77     public char[] getQuoteChars() {
 78         return this.quoteChars;
 79     }
 80 
 81     public void setEscapeChars(final char[] chars) {
 82         this.escapeChars = chars;
 83     }
</pre>
<hr />
<pre>
 85     public char[] getEscapeChars() {
 86         return this.escapeChars;
 87     }
 88 
 89     public void setEofOnUnclosedQuote(boolean eofOnUnclosedQuote) {
 90         this.eofOnUnclosedQuote = eofOnUnclosedQuote;
 91     }
 92 
 93     public boolean isEofOnUnclosedQuote() {
 94         return eofOnUnclosedQuote;
 95     }
 96 
 97     public void setEofOnEscapedNewLine(boolean eofOnEscapedNewLine) {
 98         this.eofOnEscapedNewLine = eofOnEscapedNewLine;
 99     }
100 
101     public boolean isEofOnEscapedNewLine() {
102         return eofOnEscapedNewLine;
103     }
104 
<span class="line-added">105     public void setEofOnUnclosedBracket(Bracket... brackets){</span>
<span class="line-added">106         if (brackets == null) {</span>
<span class="line-added">107             openingBrackets = null;</span>
<span class="line-added">108             closingBrackets = null;</span>
<span class="line-added">109         } else {</span>
<span class="line-added">110             Set&lt;Bracket&gt; bs = new HashSet&lt;&gt;(Arrays.asList(brackets));</span>
<span class="line-added">111             openingBrackets = new char[bs.size()];</span>
<span class="line-added">112             closingBrackets = new char[bs.size()];</span>
<span class="line-added">113             int i = 0;</span>
<span class="line-added">114             for (Bracket b : bs) {</span>
<span class="line-added">115                 switch (b) {</span>
<span class="line-added">116                 case ROUND:</span>
<span class="line-added">117                     openingBrackets[i] = &#39;(&#39;;</span>
<span class="line-added">118                     closingBrackets[i] = &#39;)&#39;;</span>
<span class="line-added">119                     break;</span>
<span class="line-added">120                 case CURLY:</span>
<span class="line-added">121                     openingBrackets[i] = &#39;{&#39;;</span>
<span class="line-added">122                     closingBrackets[i] = &#39;}&#39;;</span>
<span class="line-added">123                     break;</span>
<span class="line-added">124                 case SQUARE:</span>
<span class="line-added">125                     openingBrackets[i] = &#39;[&#39;;</span>
<span class="line-added">126                     closingBrackets[i] = &#39;]&#39;;</span>
<span class="line-added">127                     break;</span>
<span class="line-added">128                 case ANGLE:</span>
<span class="line-added">129                     openingBrackets[i] = &#39;&lt;&#39;;</span>
<span class="line-added">130                     closingBrackets[i] = &#39;&gt;&#39;;</span>
<span class="line-added">131                     break;</span>
<span class="line-added">132                 }</span>
<span class="line-added">133                 i++;</span>
<span class="line-added">134             }</span>
<span class="line-added">135         }</span>
<span class="line-added">136     }</span>
<span class="line-added">137 </span>
138     public ParsedLine parse(final String line, final int cursor, ParseContext context) {
139         List&lt;String&gt; words = new LinkedList&lt;&gt;();
140         StringBuilder current = new StringBuilder();
141         int wordCursor = -1;
142         int wordIndex = -1;
143         int quoteStart = -1;
144         int rawWordCursor = -1;
145         int rawWordLength = -1;
146         int rawWordStart = 0;
<span class="line-added">147         BracketChecker bracketChecker = new BracketChecker();</span>
<span class="line-added">148         boolean quotedWord = false;</span>
149 
150         for (int i = 0; (line != null) &amp;&amp; (i &lt; line.length()); i++) {
151             // once we reach the cursor, set the
152             // position of the selected index
153             if (i == cursor) {
154                 wordIndex = words.size();
155                 // the position in the current argument is just the
156                 // length of the current argument
157                 wordCursor = current.length();
158                 rawWordCursor = i - rawWordStart;
159             }
160 
161             if (quoteStart &lt; 0 &amp;&amp; isQuoteChar(line, i)) {
162                 // Start a quote block
163                 quoteStart = i;
<span class="line-modified">164                 if (current.length()==0) {</span>
<span class="line-modified">165                     quotedWord = true;</span>
<span class="line-modified">166                 } else {</span>
<span class="line-modified">167                     current.append(line.charAt(i));</span>
<span class="line-added">168                 }</span>
<span class="line-added">169             } else if (quoteStart &gt;= 0 &amp;&amp; line.charAt(quoteStart) == line.charAt(i) &amp;&amp; !isEscaped(line, i)) {</span>
<span class="line-added">170                 // End quote block</span>
<span class="line-added">171                 if (!quotedWord) {</span>
<span class="line-added">172                     current.append(line.charAt(i));</span>
<span class="line-added">173                 } else if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {</span>
<span class="line-added">174                     rawWordLength = i - rawWordStart + 1;</span>
<span class="line-added">175                 }</span>
<span class="line-added">176                 quoteStart = -1;</span>
<span class="line-added">177                 quotedWord = false;</span>
<span class="line-added">178             } else if (quoteStart &lt; 0 &amp;&amp; isDelimiter(line, i)) {</span>
<span class="line-added">179                 // Delimiter</span>
<span class="line-added">180                 if (current.length() &gt; 0) {</span>
181                     words.add(current.toString());
<span class="line-modified">182                     current.setLength(0); // reset the arg</span>

183                     if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {
<span class="line-modified">184                         rawWordLength = i - rawWordStart;</span>





185                     }
186                 }
<span class="line-added">187                 rawWordStart = i + 1;</span>
188             } else {
<span class="line-modified">189                 if (!isEscapeChar(line, i)) {</span>
<span class="line-modified">190                     current.append(line.charAt(i));</span>
<span class="line-modified">191                     if (quoteStart &lt; 0) {</span>
<span class="line-modified">192                         bracketChecker.check(line, i);</span>









193                     }
194                 }
195             }
196         }
197 
198         if (current.length() &gt; 0 || cursor == line.length()) {
199             words.add(current.toString());
200             if (rawWordCursor &gt;= 0 &amp;&amp; rawWordLength &lt; 0) {
201                 rawWordLength = line.length() - rawWordStart;
202             }
203         }
204 
205         if (cursor == line.length()) {
206             wordIndex = words.size() - 1;
207             wordCursor = words.get(words.size() - 1).length();
208             rawWordCursor = cursor - rawWordStart;
209             rawWordLength = rawWordCursor;
210         }
211 
<span class="line-modified">212         if (context != ParseContext.COMPLETE) {</span>
<span class="line-modified">213             if (eofOnEscapedNewLine &amp;&amp; isEscapeChar(line, line.length() - 1)) {</span>
<span class="line-modified">214                 throw new EOFError(-1, -1, &quot;Escaped new line&quot;, &quot;newline&quot;);</span>
<span class="line-modified">215             }</span>
<span class="line-modified">216             if (eofOnUnclosedQuote &amp;&amp; quoteStart &gt;= 0) {</span>
<span class="line-modified">217                 throw new EOFError(-1, -1, &quot;Missing closing quote&quot;, line.charAt(quoteStart) == &#39;\&#39;&#39;</span>
<span class="line-added">218                         ? &quot;quote&quot; : &quot;dquote&quot;);</span>
<span class="line-added">219             }</span>
<span class="line-added">220             if (bracketChecker.isOpeningBracketMissing()) {</span>
<span class="line-added">221                 throw new EOFError(-1, -1, &quot;Missing opening bracket&quot;, &quot;missing: &quot; + bracketChecker.getMissingOpeningBracket());</span>
<span class="line-added">222             }</span>
<span class="line-added">223             if (bracketChecker.isClosingBracketMissing()) {</span>
<span class="line-added">224                 throw new EOFError(-1, -1, &quot;Missing closing brackets&quot;, &quot;add: &quot; + bracketChecker.getMissingClosingBrackets());</span>
<span class="line-added">225             }</span>
226         }
227 
<span class="line-modified">228         String openingQuote = quotedWord ? line.substring(quoteStart, quoteStart + 1) : null;</span>
229         return new ArgumentList(line, words, wordIndex, wordCursor, cursor, openingQuote, rawWordCursor, rawWordLength);
230     }
231 
232     /**
233      * Returns true if the specified character is a whitespace parameter. Check to ensure that the character is not
<span class="line-modified">234      * escaped by any of {@link #getQuoteChars}, and is not escaped by any of the {@link #getEscapeChars}, and</span>
235      * returns true from {@link #isDelimiterChar}.
236      *
237      * @param buffer    The complete command buffer
238      * @param pos       The index of the character in the buffer
239      * @return          True if the character should be a delimiter
240      */
241     public boolean isDelimiter(final CharSequence buffer, final int pos) {
242         return !isQuoted(buffer, pos) &amp;&amp; !isEscaped(buffer, pos) &amp;&amp; isDelimiterChar(buffer, pos);
243     }
244 
245     public boolean isQuoted(final CharSequence buffer, final int pos) {
246         return false;
247     }
248 
249     public boolean isQuoteChar(final CharSequence buffer, final int pos) {
250         if (pos &lt; 0) {
251             return false;
252         }
253         if (quoteChars != null) {
254             for (char e : quoteChars) {
255                 if (e == buffer.charAt(pos)) {
256                     return !isEscaped(buffer, pos);
257                 }
258             }
259         }
260         return false;
261     }
262 
<span class="line-added">263     @Override</span>
<span class="line-added">264     public boolean isEscapeChar(char ch) {</span>
<span class="line-added">265         if (escapeChars != null) {</span>
<span class="line-added">266             for (char e : escapeChars) {</span>
<span class="line-added">267                 if (e == ch) {</span>
<span class="line-added">268                     return true;</span>
<span class="line-added">269                 }</span>
<span class="line-added">270             }</span>
<span class="line-added">271         }</span>
<span class="line-added">272         return false;</span>
<span class="line-added">273     }</span>
<span class="line-added">274 </span>
275     /**
276      * Check if this character is a valid escape char (i.e. one that has not been escaped)
277      *
278      * @param buffer
279      *          the buffer to check in
280      * @param pos
281      *          the position of the character to check
282      * @return true if the character at the specified position in the given buffer is an escape
283      *         character and the character immediately preceding it is not an escape character.
284      */
285     public boolean isEscapeChar(final CharSequence buffer, final int pos) {
286         if (pos &lt; 0) {
287             return false;
288         }
<span class="line-modified">289         char ch = buffer.charAt(pos);</span>
<span class="line-modified">290         return isEscapeChar(ch) &amp;&amp; !isEscaped(buffer, pos);</span>






291     }
292 
293     /**
294      * Check if a character is escaped (i.e. if the previous character is an escape)
295      *
296      * @param buffer
297      *          the buffer to check in
298      * @param pos
299      *          the position of the character to check
300      * @return true if the character at the specified position in the given buffer is an escape
301      *         character and the character immediately preceding it is an escape character.
302      */
303     public boolean isEscaped(final CharSequence buffer, final int pos) {
304         if (pos &lt;= 0) {
305             return false;
306         }
307         return isEscapeChar(buffer, pos - 1);
308     }
309 
310     /**
311      * Returns true if the character at the specified position if a delimiter. This method will only be called if
<span class="line-modified">312      * the character is not enclosed in any of the {@link #getQuoteChars}, and is not escaped by any of the</span>
313      * {@link #getEscapeChars}. To perform escaping manually, override {@link #isDelimiter} instead.
314      *
315      * @param buffer
316      *          the buffer to check in
317      * @param pos
318      *          the position of the character to check
319      * @return true if the character at the specified position in the given buffer is a delimiter.
320      */
321     public boolean isDelimiterChar(CharSequence buffer, int pos) {
322         return Character.isWhitespace(buffer.charAt(pos));
323     }
324 
325     private boolean isRawEscapeChar(char key) {
326         if (escapeChars != null) {
327             for (char e : escapeChars) {
328                 if (e == key) {
329                     return true;
330                 }
331             }
332         }
333         return false;
334     }
335 
336     private boolean isRawQuoteChar(char key) {
337         if (quoteChars != null) {
338             for (char e : quoteChars) {
339                 if (e == key) {
340                     return true;
341                 }
342             }
343         }
344         return false;
345     }
346 
<span class="line-added">347     private class BracketChecker {</span>
<span class="line-added">348         private int missingOpeningBracket = -1;</span>
<span class="line-added">349         private List&lt;Integer&gt; nested = new ArrayList&lt;&gt;();</span>
<span class="line-added">350 </span>
<span class="line-added">351         public BracketChecker(){}</span>
<span class="line-added">352 </span>
<span class="line-added">353         public void check(final CharSequence buffer, final int pos){</span>
<span class="line-added">354             if (openingBrackets == null || pos &lt; 0) {</span>
<span class="line-added">355                 return;</span>
<span class="line-added">356             }</span>
<span class="line-added">357             int bid = bracketId(openingBrackets, buffer, pos);</span>
<span class="line-added">358             if (bid &gt;= 0) {</span>
<span class="line-added">359                 nested.add(bid);</span>
<span class="line-added">360             } else {</span>
<span class="line-added">361                 bid = bracketId(closingBrackets, buffer, pos);</span>
<span class="line-added">362                 if (bid &gt;= 0) {</span>
<span class="line-added">363                     if (!nested.isEmpty() &amp;&amp; bid == nested.get(nested.size()-1)) {</span>
<span class="line-added">364                         nested.remove(nested.size()-1);</span>
<span class="line-added">365                     } else {</span>
<span class="line-added">366                         missingOpeningBracket = bid;</span>
<span class="line-added">367                     }</span>
<span class="line-added">368                 }</span>
<span class="line-added">369             }</span>
<span class="line-added">370         }</span>
<span class="line-added">371 </span>
<span class="line-added">372         public boolean isOpeningBracketMissing(){</span>
<span class="line-added">373             return missingOpeningBracket != -1;</span>
<span class="line-added">374         }</span>
<span class="line-added">375 </span>
<span class="line-added">376         public String getMissingOpeningBracket(){</span>
<span class="line-added">377             if (!isOpeningBracketMissing()) {</span>
<span class="line-added">378                 return null;</span>
<span class="line-added">379             }</span>
<span class="line-added">380             return Character.toString(openingBrackets[missingOpeningBracket]);</span>
<span class="line-added">381         }</span>
<span class="line-added">382 </span>
<span class="line-added">383         public boolean isClosingBracketMissing(){</span>
<span class="line-added">384             return !nested.isEmpty();</span>
<span class="line-added">385         }</span>
<span class="line-added">386 </span>
<span class="line-added">387         public String getMissingClosingBrackets(){</span>
<span class="line-added">388             if (!isClosingBracketMissing()) {</span>
<span class="line-added">389                 return null;</span>
<span class="line-added">390             }</span>
<span class="line-added">391             StringBuilder out = new StringBuilder();</span>
<span class="line-added">392             for (int i = nested.size() - 1; i &gt; -1; i--) {</span>
<span class="line-added">393                 out.append(closingBrackets[nested.get(i)]);</span>
<span class="line-added">394             }</span>
<span class="line-added">395             return out.toString();</span>
<span class="line-added">396         }</span>
<span class="line-added">397 </span>
<span class="line-added">398         private int bracketId(final char[] brackets, final CharSequence buffer, final int pos){</span>
<span class="line-added">399             for (int i=0; i &lt; brackets.length; i++) {</span>
<span class="line-added">400                 if (buffer.charAt(pos) == brackets[i]) {</span>
<span class="line-added">401                     return i;</span>
<span class="line-added">402                 }</span>
<span class="line-added">403             }</span>
<span class="line-added">404             return -1;</span>
<span class="line-added">405         }</span>
<span class="line-added">406     }</span>
<span class="line-added">407 </span>
408     /**
409      * The result of a delimited buffer.
410      *
411      * @author &lt;a href=&quot;mailto:mwp1@cornell.edu&quot;&gt;Marc Prud&#39;hommeaux&lt;/a&gt;
412      */
413     public class ArgumentList implements ParsedLine, CompletingParsedLine
414     {
415         private final String line;
416 
417         private final List&lt;String&gt; words;
418 
419         private final int wordIndex;
420 
421         private final int wordCursor;
422 
423         private final int cursor;
424 
425         private final String openingQuote;
426 
427         private final int rawWordCursor;
</pre>
<hr />
<pre>
475 
476         public int wordCursor() {
477             return this.wordCursor;
478         }
479 
480         public List&lt;String&gt; words() {
481             return this.words;
482         }
483 
484         public int cursor() {
485             return this.cursor;
486         }
487 
488         public String line() {
489             return line;
490         }
491 
492         public CharSequence escape(CharSequence candidate, boolean complete) {
493             StringBuilder sb = new StringBuilder(candidate);
494             Predicate&lt;Integer&gt; needToBeEscaped;
<span class="line-modified">495             String quote = openingQuote;</span>
<span class="line-modified">496             boolean middleQuotes = false;</span>
<span class="line-modified">497             if (openingQuote==null) {</span>
<span class="line-modified">498                 for (int i=0; i &lt; sb.length(); i++) {</span>
<span class="line-modified">499                     if (isQuoteChar(sb, i)) {</span>
<span class="line-modified">500                         middleQuotes = true;</span>
<span class="line-modified">501                         break;</span>
<span class="line-modified">502                     }</span>
<span class="line-modified">503                 }</span>

504             }
<span class="line-modified">505             if (escapeChars != null) {</span>
<span class="line-modified">506                 // Completion is protected by an opening quote:</span>
<span class="line-modified">507                 // Delimiters (spaces) don&#39;t need to be escaped, nor do other quotes, but everything else does.</span>
<span class="line-added">508                 // Also, close the quote at the end</span>
<span class="line-added">509                 if (openingQuote != null) {</span>
<span class="line-added">510                     needToBeEscaped = i -&gt; isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);</span>
<span class="line-added">511                 }</span>
<span class="line-added">512                 // Completion is protected by middle quotes:</span>
<span class="line-added">513                 // Delimiters (spaces) don&#39;t need to be escaped, nor do quotes, but everything else does.</span>
<span class="line-added">514                 else if (middleQuotes) {</span>
<span class="line-added">515                     needToBeEscaped = i -&gt; isRawEscapeChar(sb.charAt(i));</span>
<span class="line-added">516                 }</span>
<span class="line-added">517                 // No quote protection, need to escape everything: delimiter chars (spaces), quote chars</span>
<span class="line-added">518                 // and escapes themselves</span>
<span class="line-added">519                 else {</span>
<span class="line-added">520                     needToBeEscaped = i -&gt; isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));</span>
<span class="line-added">521                 }</span>
<span class="line-added">522                 for (int i = 0; i &lt; sb.length(); i++) {</span>
<span class="line-added">523                     if (needToBeEscaped.test(i)) {</span>
<span class="line-added">524                         sb.insert(i++, escapeChars[0]);</span>
<span class="line-added">525                     }</span>
<span class="line-added">526                 }</span>
<span class="line-added">527             } else if (openingQuote == null &amp;&amp; !middleQuotes) {</span>
<span class="line-added">528                 for (int i = 0; i &lt; sb.length(); i++) {</span>
<span class="line-added">529                     if (isDelimiterChar(sb, i)) {</span>
<span class="line-added">530                         quote = &quot;&#39;&quot;;</span>
<span class="line-added">531                         break;</span>
<span class="line-added">532                     }</span>
533                 }
534             }
<span class="line-modified">535             if (quote != null) {</span>
<span class="line-modified">536                 sb.insert(0, quote);</span>
537                 if (complete) {
<span class="line-modified">538                     sb.append(quote);</span>
539                 }
540             }
541             return sb;
542         }
543 
544         @Override
545         public int rawWordCursor() {
546             return rawWordCursor;
547         }
548 
549         @Override
550         public int rawWordLength() {
551             return rawWordLength;
552         }
553     }
554 
555 }
</pre>
</td>
</tr>
</table>
<center><a href="DefaultHighlighter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="KillRing.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
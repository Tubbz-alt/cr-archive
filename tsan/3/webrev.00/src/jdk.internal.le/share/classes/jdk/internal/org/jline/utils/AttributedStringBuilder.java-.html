<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedStringBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.Arrays;
 12 import java.util.function.Consumer;
 13 import java.util.function.Function;
 14 import java.util.regex.Matcher;
 15 import java.util.regex.Pattern;
 16 
 17 /**
 18  * Attributed string builder
 19  *
 20  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 21  */
 22 public class AttributedStringBuilder extends AttributedCharSequence implements Appendable {
 23 
 24     private char[] buffer;
 25     private int[] style;
 26     private int length;
 27     private int tabs = 0;
 28     private int lastLineLength = 0;
 29     private AttributedStyle current = AttributedStyle.DEFAULT;
 30 
 31     public static AttributedString append(CharSequence... strings) {
 32         AttributedStringBuilder sb = new AttributedStringBuilder();
 33         for (CharSequence s : strings) {
 34             sb.append(s);
 35         }
 36         return sb.toAttributedString();
 37     }
 38 
 39     public AttributedStringBuilder() {
 40         this(64);
 41     }
 42 
 43     public AttributedStringBuilder(int capacity) {
 44         buffer = new char[capacity];
 45         style = new int[capacity];
 46         length = 0;
 47     }
 48 
 49     @Override
 50     public int length() {
 51         return length;
 52     }
 53 
 54     @Override
 55     public char charAt(int index) {
 56         return buffer[index];
 57     }
 58 
 59     @Override
 60     public AttributedStyle styleAt(int index) {
 61         return new AttributedStyle(style[index], style[index]);
 62     }
 63 
 64     @Override
 65     int styleCodeAt(int index) {
 66         return style[index];
 67     }
 68 
 69     @Override
 70     protected char[] buffer() {
 71         return buffer;
 72     }
 73 
 74     @Override
 75     protected int offset() {
 76         return 0;
 77     }
 78 
 79     @Override
 80     public AttributedString subSequence(int start, int end) {
 81         return new AttributedString(
 82                 Arrays.copyOfRange(buffer, start, end),
 83                 Arrays.copyOfRange(style, start, end),
 84                 0,
 85                 end - start);
 86     }
 87 
 88     @Override
 89     public AttributedStringBuilder append(CharSequence csq) {
 90         return append(new AttributedString(csq, current));
 91     }
 92 
 93     @Override
 94     public AttributedStringBuilder append(CharSequence csq, int start, int end) {
 95         return append(csq.subSequence(start, end));
 96     }
 97 
 98     @Override
 99     public AttributedStringBuilder append(char c) {
100         return append(Character.toString(c));
101     }
102 
103     public AttributedStringBuilder append(CharSequence csq, AttributedStyle style) {
104         return append(new AttributedString(csq, style));
105     }
106 
107     public AttributedStringBuilder style(AttributedStyle style) {
108         current = style;
109         return this;
110     }
111 
112     public AttributedStringBuilder style(Function&lt;AttributedStyle,AttributedStyle&gt; style) {
113         current = style.apply(current);
114         return this;
115     }
116 
117     public AttributedStringBuilder styled(Function&lt;AttributedStyle,AttributedStyle&gt; style, CharSequence cs) {
118         return styled(style, sb -&gt; sb.append(cs));
119     }
120 
121     public AttributedStringBuilder styled(AttributedStyle style, CharSequence cs) {
122         return styled(s -&gt; style, sb -&gt; sb.append(cs));
123     }
124 
125     public AttributedStringBuilder styled(Function&lt;AttributedStyle,AttributedStyle&gt; style, Consumer&lt;AttributedStringBuilder&gt; consumer) {
126         AttributedStyle prev = current;
127         current = style.apply(prev);
128         consumer.accept(this);
129         current = prev;
130         return this;
131     }
132 
133     public AttributedStyle style() {
134         return current;
135     }
136 
137     public AttributedStringBuilder append(AttributedString str) {
138         return append((AttributedCharSequence) str, 0, str.length());
139     }
140 
141     public AttributedStringBuilder append(AttributedString str, int start, int end) {
142         return append((AttributedCharSequence) str, start, end);
143     }
144 
145     public AttributedStringBuilder append(AttributedCharSequence str) {
146         return append(str, 0, str.length());
147     }
148 
149     public AttributedStringBuilder append(AttributedCharSequence str, int start, int end) {
150         ensureCapacity(length + end - start);
151         for (int i = start; i &lt; end; i++) {
152             char c = str.charAt(i);
153             int s = str.styleCodeAt(i) &amp; ~current.getMask() | current.getStyle();
154             if (tabs &gt; 0 &amp;&amp; c == &#39;\t&#39;) {
155                 insertTab(new AttributedStyle(s, 0));
156             } else {
157                 ensureCapacity(length + 1);
158                 buffer[length] = c;
159                 style[length] = s;
160                 if (c == &#39;\n&#39;) {
161                     lastLineLength = 0;
162                 } else {
163                     lastLineLength++;
164                 }
165                 length++;
166             }
167         }
168         return this;
169     }
170 
171     protected void ensureCapacity(int nl) {
172         if (nl &gt; buffer.length) {
173             int s = Math.max(buffer.length, 1);
174             while (s &lt;= nl) {
175                 s *= 2;
176             }
177             buffer = Arrays.copyOf(buffer, s);
178             style = Arrays.copyOf(style, s);
179         }
180     }
181 
182     public void appendAnsi(String ansi) {
183         ansiAppend(ansi);
184     }
185 
186     public AttributedStringBuilder ansiAppend(String ansi) {
187         int ansiStart = 0;
188         int ansiState = 0;
189         ensureCapacity(length + ansi.length());
190         for (int i = 0; i &lt; ansi.length(); i++) {
191             char c = ansi.charAt(i);
192             if (ansiState == 0 &amp;&amp; c == 27) {
193                 ansiState++;
194             } else if (ansiState == 1 &amp;&amp; c == &#39;[&#39;) {
195                 ansiState++;
196                 ansiStart = i + 1;
197             } else if (ansiState == 2) {
198                 if (c == &#39;m&#39;) {
199                     String[] params = ansi.substring(ansiStart, i).split(&quot;;&quot;);
200                     int j = 0;
201                     while (j &lt; params.length) {
202                         int ansiParam = params[j].isEmpty() ? 0 : Integer.parseInt(params[j]);
203                         switch (ansiParam) {
204                             case 0:
205                                 current = AttributedStyle.DEFAULT;
206                                 break;
207                             case 1:
208                                 current = current.bold();
209                                 break;
210                             case 2:
211                                 current = current.faint();
212                                 break;
213                             case 3:
214                                 current = current.italic();
215                                 break;
216                             case 4:
217                                 current = current.underline();
218                                 break;
219                             case 5:
220                                 current = current.blink();
221                                 break;
222                             case 7:
223                                 current = current.inverse();
224                                 break;
225                             case 8:
226                                 current = current.conceal();
227                                 break;
228                             case 9:
229                                 current = current.crossedOut();
230                                 break;
231                             case 22:
232                                 current = current.boldOff().faintOff();
233                                 break;
234                             case 23:
235                                 current = current.italicOff();
236                                 break;
237                             case 24:
238                                 current = current.underlineOff();
239                                 break;
240                             case 25:
241                                 current = current.blinkOff();
242                                 break;
243                             case 27:
244                                 current = current.inverseOff();
245                                 break;
246                             case 28:
247                                 current = current.concealOff();
248                                 break;
249                             case 29:
250                                 current = current.crossedOutOff();
251                                 break;
252                             case 30:
253                             case 31:
254                             case 32:
255                             case 33:
256                             case 34:
257                             case 35:
258                             case 36:
259                             case 37:
260                                 current = current.foreground(ansiParam - 30);
261                                 break;
262                             case 39:
263                                 current = current.foregroundOff();
264                                 break;
265                             case 40:
266                             case 41:
267                             case 42:
268                             case 43:
269                             case 44:
270                             case 45:
271                             case 46:
272                             case 47:
273                                 current = current.background(ansiParam - 40);
274                                 break;
275                             case 49:
276                                 current = current.backgroundOff();
277                                 break;
278                             case 38:
279                             case 48:
280                                 if (j + 1 &lt; params.length) {
281                                     int ansiParam2 = Integer.parseInt(params[++j]);
282                                     if (ansiParam2 == 2) {
283                                         if (j + 3 &lt; params.length) {
284                                             int r = Integer.parseInt(params[++j]);
285                                             int g = Integer.parseInt(params[++j]);
286                                             int b = Integer.parseInt(params[++j]);
287                                             // convert to 256 colors
288                                             int col = 16 + (r &gt;&gt; 3) * 36 + (g &gt;&gt; 3) * 6 + (b &gt;&gt; 3);
289                                             if (ansiParam == 38) {
290                                                 current = current.foreground(col);
291                                             } else {
292                                                 current = current.background(col);
293                                             }
294                                         }
295                                     } else if (ansiParam2 == 5) {
296                                         if (j + 1 &lt; params.length) {
297                                             int col = Integer.parseInt(params[++j]);
298                                             if (ansiParam == 38) {
299                                                 current = current.foreground(col);
300                                             } else {
301                                                 current = current.background(col);
302                                             }
303                                         }
304                                     }
305                                 }
306                                 break;
307                             case 90:
308                             case 91:
309                             case 92:
310                             case 93:
311                             case 94:
312                             case 95:
313                             case 96:
314                             case 97:
315                                 current = current.foreground(ansiParam - 90 + 8);
316                                 break;
317                             case 100:
318                             case 101:
319                             case 102:
320                             case 103:
321                             case 104:
322                             case 105:
323                             case 106:
324                             case 107:
325                                 current = current.background(ansiParam - 100 + 8);
326                                 break;
327                         }
328                         j++;
329                     }
330                     ansiState = 0;
331                 } else if (!(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39; || c == &#39;;&#39;)) {
332                     // This is not a SGR code, so ignore
333                     ansiState = 0;
334                 }
335             } else if (c == &#39;\t&#39; &amp;&amp; tabs &gt; 0) {
336                 insertTab(current);
337             } else {
338                 ensureCapacity(length + 1);
339                 buffer[length] = c;
340                 style[length] = this.current.getStyle();
341                 if (c == &#39;\n&#39;) {
342                     lastLineLength = 0;
343                 } else {
344                     lastLineLength++;
345                 }
346                 length++;
347             }
348         }
349         return this;
350     }
351 
352     protected void insertTab(AttributedStyle s) {
353         int nb = tabs - lastLineLength % tabs;
354         ensureCapacity(length + nb);
355         for (int i = 0; i &lt; nb; i++) {
356             buffer[length] = &#39; &#39;;
357             style[length] = s.getStyle();
358             length++;
359         }
360         lastLineLength += nb;
361     }
362 
363     public void setLength(int l) {
364         length = l;
365     }
366 
367     /**
368      * Set the number of spaces a tab is expanded to. Tab size cannot be changed
369      * after text has been added to prevent inconsistent indentation.
370      *
371      * If tab size is set to 0, tabs are not expanded (the default).
372      * @param tabsize Spaces per tab or 0 for no tab expansion. Must be non-negative
373      * @return this
374      */
375     public AttributedStringBuilder tabs(int tabsize) {
376         if (length &gt; 0) {
377             throw new IllegalStateException(&quot;Cannot change tab size after appending text&quot;);
378         }
379         if (tabsize &lt; 0) {
380             throw new IllegalArgumentException(&quot;Tab size must be non negative&quot;);
381         }
382         this.tabs = tabsize;
383         return this;
384     }
385 
386     public AttributedStringBuilder styleMatches(Pattern pattern, AttributedStyle s) {
387         Matcher matcher = pattern.matcher(this);
388         while (matcher.find()) {
389             for (int i = matcher.start(); i &lt; matcher.end(); i++) {
390                 style[i] = (style[i] &amp; ~s.getMask()) | s.getStyle();
391             }
392         }
393         return this;
394     }
395 
396 }
    </pre>
  </body>
</html>
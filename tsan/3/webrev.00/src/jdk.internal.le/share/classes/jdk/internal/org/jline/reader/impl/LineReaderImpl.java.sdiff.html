<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="KillRing.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ReaderUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002-2018, the original author or authors.</span>
   3  *
   4  * This software is distributable under the BSD license. See the terms of the
   5  * BSD license in the documentation provided with this software.
   6  *
<span class="line-modified">   7  * http://www.opensource.org/licenses/bsd-license.php</span>
   8  */
   9 package jdk.internal.org.jline.reader.impl;
  10 
  11 import java.io.Flushable;
  12 import java.io.IOError;
  13 import java.io.IOException;
  14 import java.io.InputStream;
  15 import java.io.InterruptedIOException;
  16 import java.time.Instant;
  17 import java.util.*;
  18 import java.util.Map.Entry;
  19 import java.util.concurrent.atomic.AtomicBoolean;


  20 import java.util.function.*;
  21 import java.util.regex.Matcher;
  22 import java.util.regex.Pattern;
  23 import java.util.stream.Collectors;

  24 import java.util.stream.StreamSupport;
  25 
  26 import jdk.internal.org.jline.keymap.BindingReader;
  27 import jdk.internal.org.jline.keymap.KeyMap;
  28 import jdk.internal.org.jline.reader.*;
  29 import jdk.internal.org.jline.reader.Parser.ParseContext;
  30 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  31 import jdk.internal.org.jline.terminal.*;
  32 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  33 import jdk.internal.org.jline.terminal.Terminal.Signal;
  34 import jdk.internal.org.jline.terminal.Terminal.SignalHandler;

  35 import jdk.internal.org.jline.utils.AttributedString;
  36 import jdk.internal.org.jline.utils.AttributedStringBuilder;
  37 import jdk.internal.org.jline.utils.AttributedStyle;
  38 import jdk.internal.org.jline.utils.Curses;
  39 import jdk.internal.org.jline.utils.Display;
  40 import jdk.internal.org.jline.utils.InfoCmp.Capability;
  41 import jdk.internal.org.jline.utils.Levenshtein;
  42 import jdk.internal.org.jline.utils.Log;
  43 import jdk.internal.org.jline.utils.Status;
  44 import jdk.internal.org.jline.utils.WCWidth;
  45 
  46 import static jdk.internal.org.jline.keymap.KeyMap.alt;
  47 import static jdk.internal.org.jline.keymap.KeyMap.ctrl;
  48 import static jdk.internal.org.jline.keymap.KeyMap.del;
  49 import static jdk.internal.org.jline.keymap.KeyMap.esc;
  50 import static jdk.internal.org.jline.keymap.KeyMap.range;
  51 import static jdk.internal.org.jline.keymap.KeyMap.translate;
  52 
  53 /**
  54  * A reader for terminal applications. It supports custom tab-completion,
</pre>
<hr />
<pre>
 142     //
 143     // Configuration
 144     //
 145     protected final Map&lt;String, Object&gt; variables;
 146     protected History history = new DefaultHistory();
 147     protected Completer completer = null;
 148     protected Highlighter highlighter = new DefaultHighlighter();
 149     protected Parser parser = new DefaultParser();
 150     protected Expander expander = new DefaultExpander();
 151 
 152     //
 153     // State variables
 154     //
 155 
 156     protected final Map&lt;Option, Boolean&gt; options = new HashMap&lt;&gt;();
 157 
 158     protected final Buffer buf = new BufferImpl();
 159 
 160     protected final Size size = new Size();
 161 
<span class="line-modified"> 162     protected AttributedString prompt;</span>
<span class="line-modified"> 163     protected AttributedString rightPrompt;</span>
 164 
 165     protected MaskingCallback maskingCallback;
 166 
 167     protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
 168     protected Buffer historyBuffer = null;
 169     protected CharSequence searchBuffer;
 170     protected StringBuffer searchTerm = null;
 171     protected boolean searchFailing;
 172     protected boolean searchBackward;
 173     protected int searchIndex = -1;
 174 
 175 
 176     // Reading buffers
 177     protected final BindingReader bindingReader;
 178 
 179 
 180     /**
 181      * VI character find
 182      */
 183     protected int findChar;
</pre>
<hr />
<pre>
 193      * Region state
 194      */
 195     protected int regionMark;
 196     protected RegionType regionActive;
 197 
 198     private boolean forceChar;
 199     private boolean forceLine;
 200 
 201     /**
 202      * The vi yank buffer
 203      */
 204     protected String yankBuffer = &quot;&quot;;
 205 
 206     protected ViMoveMode viMoveMode = ViMoveMode.NORMAL;
 207 
 208     protected KillRing killRing = new KillRing();
 209 
 210     protected UndoTree&lt;Buffer&gt; undo = new UndoTree&lt;&gt;(this::setBuffer);
 211     protected boolean isUndo;
 212 




 213     /*
 214      * Current internal state of the line reader
 215      */
 216     protected State   state = State.DONE;
 217     protected final AtomicBoolean startedReading = new AtomicBoolean();
 218     protected boolean reading;
 219 
 220     protected Supplier&lt;AttributedString&gt; post;
 221 
 222     protected Map&lt;String, Widget&gt; builtinWidgets;
 223     protected Map&lt;String, Widget&gt; widgets;
 224 
 225     protected int count;
 226     protected int mult;
 227     protected int universal = 4;
 228     protected int repeatCount;
 229     protected boolean isArgDigit;
 230 
 231     protected ParsedLine parsedLine;
 232 
 233     protected boolean skipRedisplay;
 234     protected Display display;
 235 
 236     protected boolean overTyping = false;
 237 
 238     protected String keyMap;
 239 
 240     protected int smallTerminalOffset = 0;
 241 





 242 
 243 
 244     public LineReaderImpl(Terminal terminal) throws IOException {
 245         this(terminal, null, null);
 246     }
 247 
 248     public LineReaderImpl(Terminal terminal, String appName) throws IOException {
 249         this(terminal, appName, null);
 250     }
 251 
 252     public LineReaderImpl(Terminal terminal, String appName, Map&lt;String, Object&gt; variables) {
 253         Objects.requireNonNull(terminal, &quot;terminal can not be null&quot;);
 254         this.terminal = terminal;
 255         if (appName == null) {
 256             appName = &quot;JLine&quot;;
 257         }
 258         this.appName = appName;
 259         if (variables != null) {
 260             this.variables = variables;
 261         } else {
 262             this.variables = new HashMap&lt;&gt;();
 263         }
 264         this.keyMaps = defaultKeyMaps();
 265 
 266         builtinWidgets = builtinWidgets();
 267         widgets = new HashMap&lt;&gt;(builtinWidgets);
 268         bindingReader = new BindingReader(terminal.reader());

 269     }
 270 
 271     public Terminal getTerminal() {
 272         return terminal;
 273     }
 274 
 275     public String getAppName() {
 276         return appName;
 277     }
 278 
 279     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; getKeyMaps() {
 280         return keyMaps;
 281     }
 282 
 283     public KeyMap&lt;Binding&gt; getKeys() {
 284         return keyMaps.get(keyMap);
 285     }
 286 
 287     @Override
 288     public Map&lt;String, Widget&gt; getWidgets() {
</pre>
<hr />
<pre>
 450      * @param prompt          The prompt to issue to the terminal, may be null.
 451      * @param rightPrompt     The prompt to issue to the right of the terminal, may be null.
 452      * @param maskingCallback The callback used to mask parts of the edited line.
 453      * @param buffer          A string that will be set for editing.
 454      * @return                A line that is read from the terminal, can never be null.
 455      */
 456     public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {
 457         // prompt may be null
 458         // maskingCallback may be null
 459         // buffer may be null
 460 
 461         if (!startedReading.compareAndSet(false, true)) {
 462             throw new IllegalStateException();
 463         }
 464 
 465         Thread readLineThread = Thread.currentThread();
 466         SignalHandler previousIntrHandler = null;
 467         SignalHandler previousWinchHandler = null;
 468         SignalHandler previousContHandler = null;
 469         Attributes originalAttributes = null;
<span class="line-modified"> 470         boolean dumb = Terminal.TYPE_DUMB.equals(terminal.getType())</span>
<span class="line-removed"> 471                     || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());</span>
 472         try {
 473 
 474             this.maskingCallback = maskingCallback;
 475 
 476             /*
 477              * This is the accumulator for VI-mode repeat count. That is, while in
 478              * move mode, if you type 30x it will delete 30 characters. This is
 479              * where the &quot;30&quot; is accumulated until the command is struck.
 480              */
 481             repeatCount = 0;
 482             mult = 1;
 483             regionActive = RegionType.NONE;
 484             regionMark = -1;
 485 
 486             smallTerminalOffset = 0;
 487 
 488             state = State.NORMAL;
 489 
 490             modifiedHistory.clear();
 491 
 492             setPrompt(prompt);
 493             setRightPrompt(rightPrompt);
 494             buf.clear();
 495             if (buffer != null) {
 496                 buf.write(buffer);
 497             }











 498             undo.clear();
 499             parsedLine = null;
 500             keyMap = MAIN;
 501 
 502             if (history != null) {
 503                 history.attach(this);
 504             }
 505 
<span class="line-modified"> 506             synchronized (this) {</span>


 507                 this.reading = true;
 508 
 509                 previousIntrHandler = terminal.handle(Signal.INT, signal -&gt; readLineThread.interrupt());
 510                 previousWinchHandler = terminal.handle(Signal.WINCH, this::handleSignal);
 511                 previousContHandler = terminal.handle(Signal.CONT, this::handleSignal);
 512                 originalAttributes = terminal.enterRawMode();
 513 
<span class="line-modified"> 514                 // Cache terminal size for the duration of the call to readLine()</span>
<span class="line-removed"> 515                 // It will eventually be updated with WINCH signals</span>
<span class="line-removed"> 516                 size.copy(terminal.getSize());</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518                 display = new Display(terminal, false);</span>
<span class="line-removed"> 519                 if (size.getRows() == 0 || size.getColumns() == 0) {</span>
<span class="line-removed"> 520                     display.resize(1, Integer.MAX_VALUE);</span>
<span class="line-removed"> 521                 } else {</span>
<span class="line-removed"> 522                     display.resize(size.getRows(), size.getColumns());</span>
<span class="line-removed"> 523                 }</span>
<span class="line-removed"> 524                 if (isSet(Option.DELAY_LINE_WRAP))</span>
<span class="line-removed"> 525                     display.setDelayLineWrap(true);</span>
 526 
 527                 // Move into application mode
 528                 if (!dumb) {
 529                     terminal.puts(Capability.keypad_xmit);
 530                     if (isSet(Option.AUTO_FRESH_LINE))
 531                         callWidget(FRESH_LINE);
 532                     if (isSet(Option.MOUSE))
 533                         terminal.trackMouse(Terminal.MouseTracking.Normal);
 534                     if (isSet(Option.BRACKETED_PASTE))
 535                         terminal.writer().write(BRACKETED_PASTE_ON);
 536                 } else {
 537                     // For dumb terminals, we need to make sure that CR are ignored
 538                     Attributes attr = new Attributes(originalAttributes);
 539                     attr.setInputFlag(Attributes.InputFlag.IGNCR, true);
 540                     terminal.setAttributes(attr);
 541                 }
 542 
 543                 callWidget(CALLBACK_INIT);
 544 
 545                 undo.newState(buf.copy());
 546 
 547                 // Draw initial prompt
 548                 redrawLine();
 549                 redisplay();


 550             }
 551 
 552             while (true) {
 553 
 554                 KeyMap&lt;Binding&gt; local = null;
 555                 if (isInViCmdMode() &amp;&amp; regionActive != RegionType.NONE) {
 556                     local = keyMaps.get(VISUAL);
 557                 }
 558                 Binding o = readBinding(getKeys(), local);
 559                 if (o == null) {
 560                     throw new EndOfFileException();
 561                 }
 562                 Log.trace(&quot;Binding: &quot;, o);
 563                 if (buf.length() == 0 &amp;&amp; getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {
 564                     throw new EndOfFileException();
 565                 }
 566 
 567                 // If this is still false after handling the binding, then
 568                 // we reset our repeatCount to 0.
 569                 isArgDigit = false;
 570                 // Every command that can be repeated a specified number
 571                 // of times, needs to know how many times to repeat, so
 572                 // we figure that out here.
 573                 count = ((repeatCount == 0) ? 1 : repeatCount) * mult;
 574                 // Reset undo/redo flag
 575                 isUndo = false;
 576                 // Reset region after a paste
 577                 if (regionActive == RegionType.PASTE) {
 578                     regionActive = RegionType.NONE;
 579                 }
 580 
<span class="line-modified"> 581                 synchronized (this) {</span>

 582                     // Get executable widget
 583                     Buffer copy = buf.copy();
 584                     Widget w = getWidget(o);
 585                     if (!w.apply()) {
 586                         beep();
 587                     }
 588                     if (!isUndo &amp;&amp; !copy.toString().equals(buf.toString())) {
 589                         undo.newState(buf.copy());
 590                     }
 591 
 592                     switch (state) {
 593                         case DONE:
 594                             return finishBuffer();
 595                         case EOF:
 596                             throw new EndOfFileException();
 597                         case INTERRUPT:
 598                             throw new UserInterruptException(buf.toString());
 599                     }
 600 
 601                     if (!isArgDigit) {
 602                         /*
 603                          * If the operation performed wasn&#39;t a vi argument
 604                          * digit, then clear out the current repeatCount;
 605                          */
 606                         repeatCount = 0;
 607                         mult = 1;
 608                     }
 609 
 610                     if (!dumb) {
 611                         redisplay();
 612                     }


 613                 }
 614             }
 615         } catch (IOError e) {
 616             if (e.getCause() instanceof InterruptedIOException) {
 617                 throw new UserInterruptException(buf.toString());
 618             } else {
 619                 throw e;
 620             }
 621         }
 622         finally {
<span class="line-modified"> 623             synchronized (this) {</span>


 624                 this.reading = false;
 625 
 626                 cleanup();
 627                 if (originalAttributes != null) {
 628                     terminal.setAttributes(originalAttributes);
 629                 }
 630                 if (previousIntrHandler != null) {
 631                     terminal.handle(Signal.INT, previousIntrHandler);
 632                 }
 633                 if (previousWinchHandler != null) {
 634                     terminal.handle(Signal.WINCH, previousWinchHandler);
 635                 }
 636                 if (previousContHandler != null) {
 637                     terminal.handle(Signal.CONT, previousContHandler);
 638                 }


 639             }
 640             startedReading.set(false);
 641         }
 642     }
 643 
<span class="line-modified"> 644     @Override</span>
<span class="line-modified"> 645     public synchronized void printAbove(String str) {</span>
<span class="line-modified"> 646         boolean reading = this.reading;</span>
<span class="line-modified"> 647         if (reading) {</span>
<span class="line-modified"> 648             display.update(Collections.emptyList(), 0);</span>
<span class="line-modified"> 649         }</span>
<span class="line-modified"> 650         if (str.endsWith(&quot;\n&quot;)) {</span>
<span class="line-modified"> 651             terminal.writer().print(str);</span>





 652         } else {
<span class="line-modified"> 653             terminal.writer().println(str);</span>
 654         }
<span class="line-modified"> 655         if (reading) {</span>
<span class="line-modified"> 656             redisplay(false);</span>






















 657         }
<span class="line-removed"> 658         terminal.flush();</span>
 659     }
 660 
 661     @Override
 662     public void printAbove(AttributedString str) {
 663         printAbove(str.toAnsi(terminal));
 664     }
 665 
 666     @Override
<span class="line-modified"> 667     public synchronized boolean isReading() {</span>
<span class="line-modified"> 668         return reading;</span>





 669     }
 670 
 671     /* Make sure we position the cursor on column 0 */
 672     protected boolean freshLine() {
 673         boolean wrapAtEol = terminal.getBooleanCapability(Capability.auto_right_margin);
 674         boolean delayedWrapAtEol = wrapAtEol &amp;&amp; terminal.getBooleanCapability(Capability.eat_newline_glitch);
 675         AttributedStringBuilder sb = new AttributedStringBuilder();
 676         sb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLACK + AttributedStyle.BRIGHT));
 677         sb.append(&quot;~&quot;);
 678         sb.style(AttributedStyle.DEFAULT);
 679         if (!wrapAtEol || delayedWrapAtEol) {
 680             for (int i = 0; i &lt; size.getColumns() - 1; i++) {
 681                 sb.append(&quot; &quot;);
 682             }
 683             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 684             sb.append(&quot; &quot;);
 685             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 686         } else {
 687             // Given the terminal will wrap automatically,
 688             // we need to print one less than needed.
 689             // This means that the last character will not
 690             // be overwritten, and that&#39;s why we&#39;re using
 691             // a clr_eol first if possible.
 692             String el = terminal.getStringCapability(Capability.clr_eol);
 693             if (el != null) {
 694                 Curses.tputs(sb, el);
 695             }
 696             for (int i = 0; i &lt; size.getColumns() - 2; i++) {
 697                 sb.append(&quot; &quot;);
 698             }
 699             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 700             sb.append(&quot; &quot;);
 701             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 702         }
<span class="line-modified"> 703         print(sb.toAnsi(terminal));</span>
 704         return true;
 705     }
 706 
 707     @Override
<span class="line-modified"> 708     public synchronized void callWidget(String name) {</span>
<span class="line-removed"> 709         if (!reading) {</span>
<span class="line-removed"> 710             throw new IllegalStateException(&quot;Widgets can only be called during a `readLine` call&quot;);</span>
<span class="line-removed"> 711         }</span>
 712         try {
<span class="line-modified"> 713             Widget w;</span>
<span class="line-modified"> 714             if (name.startsWith(&quot;.&quot;)) {</span>
<span class="line-modified"> 715                 w = builtinWidgets.get(name.substring(1));</span>
<span class="line-removed"> 716             } else {</span>
<span class="line-removed"> 717                 w = widgets.get(name);</span>
 718             }
<span class="line-modified"> 719             if (w != null) {</span>
<span class="line-modified"> 720                 w.apply();</span>










 721             }
<span class="line-modified"> 722         } catch (Throwable t) {</span>
<span class="line-modified"> 723             Log.debug(&quot;Error executing widget &#39;&quot;, name, &quot;&#39;&quot;, t);</span>
 724         }
 725     }
 726 
 727     /**
 728      * Clear the line and redraw it.
 729      * @return &lt;code&gt;true&lt;/code&gt;
 730      */
 731     public boolean redrawLine() {
 732         display.reset();
 733         return true;
 734     }
 735 
 736     /**
 737      * Write out the specified string to the buffer and the output stream.
 738      * @param str the char sequence to write in the buffer
 739      */
 740     public void putString(final CharSequence str) {
 741         buf.write(str, overTyping);
 742     }
 743 
 744     /**
 745      * Flush the terminal output stream. This is important for printout out single
 746      * characters (like a buf.backspace or keyboard) that we want the terminal to
 747      * handle immediately.
 748      */
 749     public void flush() {
 750         terminal.flush();
 751     }
 752 
 753     public boolean isKeyMap(String name) {
 754         return keyMap.equals(name);
 755     }
 756 
 757     /**
 758      * Read a character from the terminal.
 759      *
 760      * @return the character, or -1 if an EOF is received.
 761      */
 762     public int readCharacter() {
<span class="line-modified"> 763         return bindingReader.readCharacter();</span>









 764     }
 765 
 766     public int peekCharacter(long timeout) {
 767         return bindingReader.peekCharacter(timeout);
 768     }
 769 













 770     /**
 771      * Read from the input stream and decode an operation from the key map.
 772      *
 773      * The input stream will be read character by character until a matching
 774      * binding can be found.  Characters that can&#39;t possibly be matched to
 775      * any binding will be discarded.
 776      *
 777      * @param keys the KeyMap to use for decoding the input stream
 778      * @return the decoded binding or &lt;code&gt;null&lt;/code&gt; if the end of
 779      *         stream has been reached
 780      */
 781     public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
 782         return readBinding(keys, null);
 783     }
 784 
 785     public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
<span class="line-modified"> 786         Binding o = bindingReader.readBinding(keys, local);</span>
 787         /*
 788          * The kill ring keeps record of whether or not the
 789          * previous command was a yank or a kill. We reset
 790          * that state here if needed.
 791          */
 792         if (o instanceof Reference) {
 793             String ref = ((Reference) o).name();
 794             if (!YANK_POP.equals(ref) &amp;&amp; !YANK.equals(ref)) {
 795                 killRing.resetLastYank();
 796             }
 797             if (!KILL_LINE.equals(ref) &amp;&amp; !KILL_WHOLE_LINE.equals(ref)
 798                     &amp;&amp; !BACKWARD_KILL_WORD.equals(ref) &amp;&amp; !KILL_WORD.equals(ref)) {
 799                 killRing.resetLastKill();
 800             }
 801         }
 802         return o;
 803     }
 804 
 805     @Override
 806     public ParsedLine getParsedLine() {
</pre>
<hr />
<pre>
 909 
 910     /**
 911      * Clear the buffer and add its contents to the history.
 912      *
 913      * @return the former contents of the buffer.
 914      */
 915     protected String finishBuffer() {
 916         String str = buf.toString();
 917         String historyLine = str;
 918 
 919         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
 920             StringBuilder sb = new StringBuilder();
 921             boolean escaped = false;
 922             for (int i = 0; i &lt; str.length(); i++) {
 923                 char ch = str.charAt(i);
 924                 if (escaped) {
 925                     escaped = false;
 926                     if (ch != &#39;\n&#39;) {
 927                         sb.append(ch);
 928                     }
<span class="line-modified"> 929                 } else if (ch == &#39;\\&#39;) {</span>
 930                     escaped = true;
 931                 } else {
 932                     sb.append(ch);
 933                 }
 934             }
 935             str = sb.toString();
 936         }
 937 
 938         if (maskingCallback != null) {
 939             historyLine = maskingCallback.history(historyLine);
 940         }
 941 
 942         // we only add it to the history if the buffer is not empty
 943         if (historyLine != null &amp;&amp; historyLine.length() &gt; 0 ) {
 944             history.add(Instant.now(), historyLine);
 945         }
 946         return str;
 947     }
 948 
 949     protected void handleSignal(Signal signal) {
 950         if (signal == Signal.WINCH) {
<span class="line-modified"> 951             size.copy(terminal.getSize());</span>




 952             display.resize(size.getRows(), size.getColumns());

 953             redisplay();
 954         }
 955         else if (signal == Signal.CONT) {
 956             terminal.enterRawMode();
<span class="line-modified"> 957             size.copy(terminal.getSize());</span>
 958             display.resize(size.getRows(), size.getColumns());
 959             terminal.puts(Capability.keypad_xmit);
 960             redrawLine();
 961             redisplay();
 962         }
 963     }
 964 
 965     @SuppressWarnings(&quot;unchecked&quot;)
 966     protected Widget getWidget(Object binding) {
 967         Widget w;
 968         if (binding instanceof Widget) {
 969             w = (Widget) binding;
 970         } else if (binding instanceof Macro) {
 971             String macro = ((Macro) binding).getSequence();
 972             w = () -&gt; {
 973                 bindingReader.runMacro(macro);
 974                 return true;
 975             };
 976         } else if (binding instanceof Reference) {
 977             String name = ((Reference) binding).name();
</pre>
<hr />
<pre>
1886         searchDir = -searchDir;
1887         ret = viRepeatSearch();
1888         searchDir = -searchDir;
1889         return ret;
1890     }
1891 
1892     private boolean getViSearchString() {
1893         if (searchDir == 0) {
1894             return false;
1895         }
1896         String searchPrompt = searchDir &lt; 0 ? &quot;?&quot; : &quot;/&quot;;
1897         Buffer searchBuffer = new BufferImpl();
1898 
1899         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MAIN);
1900         if (keyMap == null) {
1901             keyMap = keyMaps.get(SAFE);
1902         }
1903         while (true) {
1904             post = () -&gt; new AttributedString(searchPrompt + searchBuffer.toString() + &quot;_&quot;);
1905             redisplay();
<span class="line-modified">1906             Binding b = bindingReader.readBinding(keyMap);</span>
1907             if (b instanceof Reference) {
1908                 String func = ((Reference) b).name();
1909                 switch (func) {
1910                     case SEND_BREAK:
1911                         post = null;
1912                         return false;
1913                     case ACCEPT_LINE:
1914                     case VI_CMD_MODE:
1915                         searchString = searchBuffer.toString();
1916                         post = null;
1917                         return true;
1918                     case MAGIC_SPACE:
1919                         searchBuffer.write(&#39; &#39;);
1920                         break;
1921                     case REDISPLAY:
1922                         redisplay();
1923                         break;
1924                     case CLEAR_SCREEN:
1925                         clearScreen();
1926                         break;
</pre>
<hr />
<pre>
2283             return false;
2284         }
2285     }
2286 
2287     /*
2288     protected int getViRange(Reference cmd, ViMoveMode mode) {
2289         Buffer buffer = buf.copy();
2290         int oldMark = mark;
2291         int pos = buf.cursor();
2292         String bind = getLastBinding();
2293 
2294         if (visual != 0) {
2295             if (buf.length() == 0) {
2296                 return -1;
2297             }
2298             pos = mark;
2299             v
2300         } else {
2301             viMoveMode = mode;
2302             mark = -1;
<span class="line-modified">2303             Binding b = bindingReader.readBinding(getKeys(), keyMaps.get(VIOPP));</span>
2304             if (b == null || new Reference(SEND_BREAK).equals(b)) {
2305                 viMoveMode = ViMoveMode.NORMAL;
2306                 mark = oldMark;
2307                 return -1;
2308             }
2309             if (cmd.equals(b)) {
2310                 doViLineRange();
2311             }
2312             Widget w = getWidget(b);
2313             if (w )
2314             if (b instanceof Reference) {
2315 
2316             }
2317         }
2318 
2319     }
2320     */
2321 
2322     protected void cleanup() {
2323         if (isSet(Option.ERASE_LINE_ON_FINISH)) {
</pre>
<hr />
<pre>
2693      * @return index where this substring has been found, or -1 else.
2694      */
2695     public int searchForwards(String searchTerm, int startIndex) {
2696         return searchForwards(searchTerm, startIndex, false);
2697     }
2698     /**
2699      * Search forwards in history from the current position.
2700      *
2701      * @param searchTerm substring to search for.
2702      * @return index where the substring has been found, or -1 else.
2703      */
2704     public int searchForwards(String searchTerm) {
2705         return searchForwards(searchTerm, history.index());
2706     }
2707 
2708     protected boolean quit() {
2709         getBuffer().clear();
2710         return acceptLine();
2711     }
2712 




































2713     protected boolean acceptLine() {
2714         parsedLine = null;
2715         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
2716             try {
2717                 String str = buf.toString();
2718                 String exp = expander.expandHistory(history, str);
2719                 if (!exp.equals(str)) {
2720                     buf.clear();
2721                     buf.write(exp);
2722                     if (isSet(Option.HISTORY_VERIFY)) {
2723                         return true;
2724                     }
2725                 }
2726             } catch (IllegalArgumentException e) {
2727                 // Ignore
2728             }
2729         }
2730         try {
2731             parsedLine = parser.parse(buf.toString(), buf.cursor(), ParseContext.ACCEPT_LINE);
2732         } catch (EOFError e) {
</pre>
<hr />
<pre>
3326                 sb.append(&quot;EOF&quot;);
3327             }
3328             sb.append(&quot;   &quot;);
3329             sb.append(&quot;point &quot;);
3330             sb.append(Integer.toString(buf.cursor() + 1));
3331             sb.append(&quot; of &quot;);
3332             sb.append(Integer.toString(buf.length() + 1));
3333             sb.append(&quot; (&quot;);
3334             sb.append(Integer.toString(buf.length() == 0 ? 100 : ((100 * buf.cursor()) / buf.length())));
3335             sb.append(&quot;%)&quot;);
3336             sb.append(&quot;   &quot;);
3337             sb.append(&quot;column &quot;);
3338             sb.append(Integer.toString(buf.cursor() - findbol()));
3339             return sb.toAttributedString();
3340         };
3341         return true;
3342     }
3343 
3344     protected Map&lt;String, Widget&gt; builtinWidgets() {
3345         Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
<span class="line-modified">3346         widgets.put(ACCEPT_LINE, this::acceptLine);</span>
<span class="line-modified">3347         widgets.put(ARGUMENT_BASE, this::argumentBase);</span>
<span class="line-modified">3348         widgets.put(BACKWARD_CHAR, this::backwardChar);</span>
<span class="line-modified">3349         widgets.put(BACKWARD_DELETE_CHAR, this::backwardDeleteChar);</span>
<span class="line-modified">3350         widgets.put(BACKWARD_DELETE_WORD, this::backwardDeleteWord);</span>
<span class="line-modified">3351         widgets.put(BACKWARD_KILL_LINE, this::backwardKillLine);</span>
<span class="line-modified">3352         widgets.put(BACKWARD_KILL_WORD, this::backwardKillWord);</span>
<span class="line-modified">3353         widgets.put(BACKWARD_WORD, this::backwardWord);</span>
<span class="line-modified">3354         widgets.put(BEEP, this::beep);</span>
<span class="line-modified">3355         widgets.put(BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);</span>
<span class="line-modified">3356         widgets.put(BEGINNING_OF_HISTORY, this::beginningOfHistory);</span>
<span class="line-modified">3357         widgets.put(BEGINNING_OF_LINE, this::beginningOfLine);</span>
<span class="line-modified">3358         widgets.put(BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);</span>
<span class="line-modified">3359         widgets.put(CAPITALIZE_WORD, this::capitalizeWord);</span>
<span class="line-modified">3360         widgets.put(CLEAR, this::clear);</span>
<span class="line-modified">3361         widgets.put(CLEAR_SCREEN, this::clearScreen);</span>
<span class="line-modified">3362         widgets.put(COMPLETE_PREFIX, this::completePrefix);</span>
<span class="line-modified">3363         widgets.put(COMPLETE_WORD, this::completeWord);</span>
<span class="line-modified">3364         widgets.put(COPY_PREV_WORD, this::copyPrevWord);</span>
<span class="line-modified">3365         widgets.put(COPY_REGION_AS_KILL, this::copyRegionAsKill);</span>
<span class="line-modified">3366         widgets.put(DELETE_CHAR, this::deleteChar);</span>
<span class="line-modified">3367         widgets.put(DELETE_CHAR_OR_LIST, this::deleteCharOrList);</span>
<span class="line-modified">3368         widgets.put(DELETE_WORD, this::deleteWord);</span>
<span class="line-modified">3369         widgets.put(DIGIT_ARGUMENT, this::digitArgument);</span>
<span class="line-modified">3370         widgets.put(DO_LOWERCASE_VERSION, this::doLowercaseVersion);</span>
<span class="line-modified">3371         widgets.put(DOWN_CASE_WORD, this::downCaseWord);</span>
<span class="line-modified">3372         widgets.put(DOWN_LINE, this::downLine);</span>
<span class="line-modified">3373         widgets.put(DOWN_LINE_OR_HISTORY, this::downLineOrHistory);</span>
<span class="line-modified">3374         widgets.put(DOWN_LINE_OR_SEARCH, this::downLineOrSearch);</span>
<span class="line-modified">3375         widgets.put(DOWN_HISTORY, this::downHistory);</span>
<span class="line-modified">3376         widgets.put(EMACS_EDITING_MODE, this::emacsEditingMode);</span>
<span class="line-modified">3377         widgets.put(EMACS_BACKWARD_WORD, this::emacsBackwardWord);</span>
<span class="line-modified">3378         widgets.put(EMACS_FORWARD_WORD, this::emacsForwardWord);</span>
<span class="line-modified">3379         widgets.put(END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);</span>
<span class="line-modified">3380         widgets.put(END_OF_HISTORY, this::endOfHistory);</span>
<span class="line-modified">3381         widgets.put(END_OF_LINE, this::endOfLine);</span>
<span class="line-modified">3382         widgets.put(END_OF_LINE_HIST, this::endOfLineHist);</span>
<span class="line-modified">3383         widgets.put(EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);</span>
<span class="line-modified">3384         widgets.put(EXPAND_HISTORY, this::expandHistory);</span>
<span class="line-modified">3385         widgets.put(EXPAND_OR_COMPLETE, this::expandOrComplete);</span>
<span class="line-modified">3386         widgets.put(EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);</span>
<span class="line-modified">3387         widgets.put(EXPAND_WORD, this::expandWord);</span>
<span class="line-modified">3388         widgets.put(FRESH_LINE, this::freshLine);</span>
<span class="line-modified">3389         widgets.put(FORWARD_CHAR, this::forwardChar);</span>
<span class="line-modified">3390         widgets.put(FORWARD_WORD, this::forwardWord);</span>
<span class="line-modified">3391         widgets.put(HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);</span>
<span class="line-modified">3392         widgets.put(HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);</span>
<span class="line-modified">3393         widgets.put(HISTORY_SEARCH_BACKWARD, this::historySearchBackward);</span>
<span class="line-modified">3394         widgets.put(HISTORY_SEARCH_FORWARD, this::historySearchForward);</span>
<span class="line-modified">3395         widgets.put(INSERT_CLOSE_CURLY, this::insertCloseCurly);</span>
<span class="line-modified">3396         widgets.put(INSERT_CLOSE_PAREN, this::insertCloseParen);</span>
<span class="line-modified">3397         widgets.put(INSERT_CLOSE_SQUARE, this::insertCloseSquare);</span>
<span class="line-modified">3398         widgets.put(INSERT_COMMENT, this::insertComment);</span>
<span class="line-modified">3399         widgets.put(KILL_BUFFER, this::killBuffer);</span>
<span class="line-modified">3400         widgets.put(KILL_LINE, this::killLine);</span>
<span class="line-modified">3401         widgets.put(KILL_REGION, this::killRegion);</span>
<span class="line-modified">3402         widgets.put(KILL_WHOLE_LINE, this::killWholeLine);</span>
<span class="line-modified">3403         widgets.put(KILL_WORD, this::killWord);</span>
<span class="line-modified">3404         widgets.put(LIST_CHOICES, this::listChoices);</span>
<span class="line-modified">3405         widgets.put(MENU_COMPLETE, this::menuComplete);</span>
<span class="line-modified">3406         widgets.put(MENU_EXPAND_OR_COMPLETE, this::menuExpandOrComplete);</span>
<span class="line-modified">3407         widgets.put(NEG_ARGUMENT, this::negArgument);</span>
<span class="line-modified">3408         widgets.put(OVERWRITE_MODE, this::overwriteMode);</span>
<span class="line-modified">3409 //        widgets.put(QUIT, this::quit);</span>
<span class="line-modified">3410         widgets.put(QUOTED_INSERT, this::quotedInsert);</span>
<span class="line-modified">3411         widgets.put(REDISPLAY, this::redisplay);</span>
<span class="line-modified">3412         widgets.put(REDRAW_LINE, this::redrawLine);</span>
<span class="line-modified">3413         widgets.put(REDO, this::redo);</span>
<span class="line-modified">3414         widgets.put(SELF_INSERT, this::selfInsert);</span>
<span class="line-modified">3415         widgets.put(SELF_INSERT_UNMETA, this::selfInsertUnmeta);</span>
<span class="line-modified">3416         widgets.put(SEND_BREAK, this::sendBreak);</span>
<span class="line-modified">3417         widgets.put(SET_MARK_COMMAND, this::setMarkCommand);</span>
<span class="line-modified">3418         widgets.put(TRANSPOSE_CHARS, this::transposeChars);</span>
<span class="line-modified">3419         widgets.put(TRANSPOSE_WORDS, this::transposeWords);</span>
<span class="line-modified">3420         widgets.put(UNDEFINED_KEY, this::undefinedKey);</span>
<span class="line-modified">3421         widgets.put(UNIVERSAL_ARGUMENT, this::universalArgument);</span>
<span class="line-modified">3422         widgets.put(UNDO, this::undo);</span>
<span class="line-modified">3423         widgets.put(UP_CASE_WORD, this::upCaseWord);</span>
<span class="line-modified">3424         widgets.put(UP_HISTORY, this::upHistory);</span>
<span class="line-modified">3425         widgets.put(UP_LINE, this::upLine);</span>
<span class="line-modified">3426         widgets.put(UP_LINE_OR_HISTORY, this::upLineOrHistory);</span>
<span class="line-modified">3427         widgets.put(UP_LINE_OR_SEARCH, this::upLineOrSearch);</span>
<span class="line-modified">3428         widgets.put(VI_ADD_EOL, this::viAddEol);</span>
<span class="line-modified">3429         widgets.put(VI_ADD_NEXT, this::viAddNext);</span>
<span class="line-modified">3430         widgets.put(VI_BACKWARD_CHAR, this::viBackwardChar);</span>
<span class="line-modified">3431         widgets.put(VI_BACKWARD_DELETE_CHAR, this::viBackwardDeleteChar);</span>
<span class="line-modified">3432         widgets.put(VI_BACKWARD_BLANK_WORD, this::viBackwardBlankWord);</span>
<span class="line-modified">3433         widgets.put(VI_BACKWARD_BLANK_WORD_END, this::viBackwardBlankWordEnd);</span>
<span class="line-modified">3434         widgets.put(VI_BACKWARD_KILL_WORD, this::viBackwardKillWord);</span>
<span class="line-modified">3435         widgets.put(VI_BACKWARD_WORD, this::viBackwardWord);</span>
<span class="line-modified">3436         widgets.put(VI_BACKWARD_WORD_END, this::viBackwardWordEnd);</span>
<span class="line-modified">3437         widgets.put(VI_BEGINNING_OF_LINE, this::viBeginningOfLine);</span>
<span class="line-modified">3438         widgets.put(VI_CMD_MODE, this::viCmdMode);</span>
<span class="line-modified">3439         widgets.put(VI_DIGIT_OR_BEGINNING_OF_LINE, this::viDigitOrBeginningOfLine);</span>
<span class="line-modified">3440         widgets.put(VI_DOWN_LINE_OR_HISTORY, this::viDownLineOrHistory);</span>
<span class="line-modified">3441         widgets.put(VI_CHANGE, this::viChange);</span>
<span class="line-modified">3442         widgets.put(VI_CHANGE_EOL, this::viChangeEol);</span>
<span class="line-modified">3443         widgets.put(VI_CHANGE_WHOLE_LINE, this::viChangeWholeLine);</span>
<span class="line-modified">3444         widgets.put(VI_DELETE_CHAR, this::viDeleteChar);</span>
<span class="line-modified">3445         widgets.put(VI_DELETE, this::viDelete);</span>
<span class="line-modified">3446         widgets.put(VI_END_OF_LINE, this::viEndOfLine);</span>
<span class="line-modified">3447         widgets.put(VI_KILL_EOL, this::viKillEol);</span>
<span class="line-modified">3448         widgets.put(VI_FIRST_NON_BLANK, this::viFirstNonBlank);</span>
<span class="line-modified">3449         widgets.put(VI_FIND_NEXT_CHAR, this::viFindNextChar);</span>
<span class="line-modified">3450         widgets.put(VI_FIND_NEXT_CHAR_SKIP, this::viFindNextCharSkip);</span>
<span class="line-modified">3451         widgets.put(VI_FIND_PREV_CHAR, this::viFindPrevChar);</span>
<span class="line-modified">3452         widgets.put(VI_FIND_PREV_CHAR_SKIP, this::viFindPrevCharSkip);</span>
<span class="line-modified">3453         widgets.put(VI_FORWARD_BLANK_WORD, this::viForwardBlankWord);</span>
<span class="line-modified">3454         widgets.put(VI_FORWARD_BLANK_WORD_END, this::viForwardBlankWordEnd);</span>
<span class="line-modified">3455         widgets.put(VI_FORWARD_CHAR, this::viForwardChar);</span>
<span class="line-modified">3456         widgets.put(VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">3457         widgets.put(VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">3458         widgets.put(VI_FORWARD_WORD_END, this::viForwardWordEnd);</span>
<span class="line-modified">3459         widgets.put(VI_HISTORY_SEARCH_BACKWARD, this::viHistorySearchBackward);</span>
<span class="line-modified">3460         widgets.put(VI_HISTORY_SEARCH_FORWARD, this::viHistorySearchForward);</span>
<span class="line-modified">3461         widgets.put(VI_INSERT, this::viInsert);</span>
<span class="line-modified">3462         widgets.put(VI_INSERT_BOL, this::viInsertBol);</span>
<span class="line-modified">3463         widgets.put(VI_INSERT_COMMENT, this::viInsertComment);</span>
<span class="line-modified">3464         widgets.put(VI_JOIN, this::viJoin);</span>
<span class="line-modified">3465         widgets.put(VI_KILL_LINE, this::viKillWholeLine);</span>
<span class="line-modified">3466         widgets.put(VI_MATCH_BRACKET, this::viMatchBracket);</span>
<span class="line-modified">3467         widgets.put(VI_OPEN_LINE_ABOVE, this::viOpenLineAbove);</span>
<span class="line-modified">3468         widgets.put(VI_OPEN_LINE_BELOW, this::viOpenLineBelow);</span>
<span class="line-modified">3469         widgets.put(VI_PUT_AFTER, this::viPutAfter);</span>
<span class="line-modified">3470         widgets.put(VI_PUT_BEFORE, this::viPutBefore);</span>
<span class="line-modified">3471         widgets.put(VI_REPEAT_FIND, this::viRepeatFind);</span>
<span class="line-modified">3472         widgets.put(VI_REPEAT_SEARCH, this::viRepeatSearch);</span>
<span class="line-modified">3473         widgets.put(VI_REPLACE_CHARS, this::viReplaceChars);</span>
<span class="line-modified">3474         widgets.put(VI_REV_REPEAT_FIND, this::viRevRepeatFind);</span>
<span class="line-modified">3475         widgets.put(VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);</span>
<span class="line-modified">3476         widgets.put(VI_SWAP_CASE, this::viSwapCase);</span>
<span class="line-modified">3477         widgets.put(VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);</span>
<span class="line-modified">3478         widgets.put(VI_YANK, this::viYankTo);</span>
<span class="line-modified">3479         widgets.put(VI_YANK_WHOLE_LINE, this::viYankWholeLine);</span>
<span class="line-modified">3480         widgets.put(VISUAL_LINE_MODE, this::visualLineMode);</span>
<span class="line-modified">3481         widgets.put(VISUAL_MODE, this::visualMode);</span>
<span class="line-modified">3482         widgets.put(WHAT_CURSOR_POSITION, this::whatCursorPosition);</span>
<span class="line-modified">3483         widgets.put(YANK, this::yank);</span>
<span class="line-modified">3484         widgets.put(YANK_POP, this::yankPop);</span>
<span class="line-modified">3485         widgets.put(MOUSE, this::mouse);</span>
<span class="line-modified">3486         widgets.put(BEGIN_PASTE, this::beginPaste);</span>
<span class="line-modified">3487         widgets.put(FOCUS_IN, this::focusIn);</span>
<span class="line-modified">3488         widgets.put(FOCUS_OUT, this::focusOut);</span>



3489         return widgets;
3490     }
3491 

















3492     public boolean redisplay() {
3493         redisplay(true);
3494         return true;
3495     }
3496 
<span class="line-modified">3497     protected synchronized void redisplay(boolean flush) {</span>
<span class="line-modified">3498         if (skipRedisplay) {</span>
<span class="line-modified">3499             skipRedisplay = false;</span>
<span class="line-removed">3500             return;</span>
<span class="line-removed">3501         }</span>
3502 
<span class="line-modified">3503         Status status = Status.getStatus(terminal, false);</span>
<span class="line-modified">3504         if (status != null) {</span>
<span class="line-modified">3505             status.redraw();</span>
<span class="line-modified">3506         }</span>
3507 
<span class="line-modified">3508         if (size.getRows() &gt; 0 &amp;&amp; size.getRows() &lt; MIN_ROWS) {</span>
<span class="line-modified">3509             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>


3510 
<span class="line-modified">3511             sb.append(prompt);</span>
<span class="line-modified">3512             concat(getHighlightedBuffer(buf.toString()).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-removed">3513             AttributedString full = sb.toAttributedString();</span>
3514 
<span class="line-modified">3515             sb.setLength(0);</span>
<span class="line-modified">3516             sb.append(prompt);</span>
<span class="line-modified">3517             String line = buf.upToCursor();</span>
<span class="line-modified">3518             if(maskingCallback != null) {</span>
<span class="line-modified">3519                 line = maskingCallback.display(line);</span>



































3520             }
3521 
<span class="line-modified">3522             concat(new AttributedString(line).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-modified">3523             AttributedString toCursor = sb.toAttributedString();</span>
3524 
<span class="line-modified">3525             int w = WCWidth.wcwidth(&#39;\u2026&#39;);</span>
<span class="line-modified">3526             int width = size.getColumns();</span>
<span class="line-modified">3527             int cursor = toCursor.columnLength();</span>
<span class="line-modified">3528             int inc = width /2 + 1;</span>
<span class="line-modified">3529             while (cursor &lt;= smallTerminalOffset + w) {</span>
<span class="line-modified">3530                 smallTerminalOffset -= inc;</span>
3531             }
<span class="line-modified">3532             while (cursor &gt;= smallTerminalOffset + width - w) {</span>
<span class="line-modified">3533                 smallTerminalOffset += inc;</span>




3534             }
<span class="line-modified">3535             if (smallTerminalOffset &gt; 0) {</span>
<span class="line-modified">3536                 sb.setLength(0);</span>
<span class="line-removed">3537                 sb.append(&quot;\u2026&quot;);</span>
<span class="line-removed">3538                 sb.append(full.columnSubSequence(smallTerminalOffset + w, Integer.MAX_VALUE));</span>
<span class="line-removed">3539                 full = sb.toAttributedString();</span>
3540             }
<span class="line-modified">3541             int length = full.columnLength();</span>
<span class="line-modified">3542             if (length &gt;= smallTerminalOffset + width) {</span>
<span class="line-modified">3543                 sb.setLength(0);</span>
<span class="line-removed">3544                 sb.append(full.columnSubSequence(0, width - w));</span>
<span class="line-removed">3545                 sb.append(&quot;\u2026&quot;);</span>
<span class="line-removed">3546                 full = sb.toAttributedString();</span>
3547             }
3548 
<span class="line-modified">3549             display.update(Collections.singletonList(full), cursor - smallTerminalOffset, flush);</span>
<span class="line-modified">3550             return;</span>
<span class="line-modified">3551         }</span>
<span class="line-modified">3552 </span>
<span class="line-modified">3553         List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">3554         AttributedString full = getDisplayedBufferWithPrompts(secondaryPrompts);</span>
<span class="line-modified">3555 </span>
<span class="line-modified">3556         List&lt;AttributedString&gt; newLines;</span>
<span class="line-modified">3557         if (size.getColumns() &lt;= 0) {</span>
<span class="line-modified">3558             newLines = new ArrayList&lt;&gt;();</span>
<span class="line-modified">3559             newLines.add(full);</span>
<span class="line-modified">3560         } else {</span>
<span class="line-modified">3561             newLines = full.columnSplitLength(size.getColumns(), true, display.delayLineWrap());</span>
<span class="line-modified">3562         }</span>
<span class="line-modified">3563 </span>
<span class="line-modified">3564         List&lt;AttributedString&gt; rightPromptLines;</span>
<span class="line-modified">3565         if (rightPrompt.length() == 0 || size.getColumns() &lt;= 0) {</span>
<span class="line-removed">3566             rightPromptLines = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3567         } else {</span>
<span class="line-removed">3568             rightPromptLines = rightPrompt.columnSplitLength(size.getColumns());</span>
<span class="line-removed">3569         }</span>
<span class="line-removed">3570         while (newLines.size() &lt; rightPromptLines.size()) {</span>
<span class="line-removed">3571             newLines.add(new AttributedString(&quot;&quot;));</span>
<span class="line-removed">3572         }</span>
<span class="line-removed">3573         for (int i = 0; i &lt; rightPromptLines.size(); i++) {</span>
<span class="line-removed">3574             AttributedString line = rightPromptLines.get(i);</span>
<span class="line-removed">3575             newLines.set(i, addRightPrompt(line, newLines.get(i)));</span>
<span class="line-removed">3576         }</span>
<span class="line-removed">3577 </span>
<span class="line-removed">3578         int cursorPos = -1;</span>
<span class="line-removed">3579         if (size.getColumns() &gt; 0) {</span>
<span class="line-removed">3580             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>
<span class="line-removed">3581             sb.append(prompt);</span>
<span class="line-removed">3582             String buffer = buf.upToCursor();</span>
<span class="line-removed">3583             if (maskingCallback != null) {</span>
<span class="line-removed">3584                 buffer = maskingCallback.display(buffer);</span>
3585             }
<span class="line-modified">3586             sb.append(insertSecondaryPrompts(new AttributedString(buffer), secondaryPrompts, false));</span>
<span class="line-modified">3587             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());</span>
<span class="line-modified">3588             if (!promptLines.isEmpty()) {</span>
<span class="line-modified">3589                 cursorPos = size.cursorPos(promptLines.size() - 1,</span>
<span class="line-modified">3590                                            promptLines.get(promptLines.size() - 1).columnLength());</span>




























3591             }



3592         }
<span class="line-removed">3593 </span>
<span class="line-removed">3594         display.update(newLines, cursorPos, flush);</span>
3595     }
3596 
3597     private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
3598         if (lines.size() &gt; 1) {
3599             for (int i = 0; i &lt; lines.size() - 1; i++) {
3600                 sb.append(lines.get(i));
3601                 sb.style(sb.style().inverse());
3602                 sb.append(&quot;\\n&quot;);
3603                 sb.style(sb.style().inverseOff());
3604             }
3605         }
3606         sb.append(lines.get(lines.size() - 1));
3607     }
3608 
3609     /**
3610      * Compute the full string to be displayed with the left, right and secondary prompts
3611      * @param secondaryPrompts a list to store the secondary prompts
3612      * @return the displayed string including the buffer, left prompts and the help below
3613      */
3614     public AttributedString getDisplayedBufferWithPrompts(List&lt;AttributedString&gt; secondaryPrompts) {
</pre>
<hr />
<pre>
3639                                                  String message, int line) {
3640         ArrayList&lt;AttributedString&gt; parts = new ArrayList&lt;&gt;();
3641         boolean isHidden = false;
3642         int padPartIndex = -1;
3643         StringBuilder padPartString = null;
3644         StringBuilder sb = new StringBuilder();
3645         // Add &quot;%{&quot; to avoid special case for end of string.
3646         pattern = pattern + &quot;%{&quot;;
3647         int plen = pattern.length();
3648         int padChar = -1;
3649         int padPos = -1;
3650         int cols = 0;
3651         for (int i = 0; i &lt; plen; ) {
3652             char ch = pattern.charAt(i++);
3653             if (ch == &#39;%&#39; &amp;&amp; i &lt; plen) {
3654                 int count = 0;
3655                 boolean countSeen = false;
3656                 decode: while (true) {
3657                     ch = pattern.charAt(i++);
3658                     switch (ch) {
<span class="line-modified">3659                        case &#39;{&#39;:</span>
<span class="line-modified">3660                        case &#39;}&#39;:</span>
<span class="line-modified">3661                            String str = sb.toString();</span>
<span class="line-modified">3662                            AttributedString astr;</span>
<span class="line-modified">3663                            if (!isHidden) {</span>
<span class="line-modified">3664                                astr = AttributedString.fromAnsi(str);</span>
<span class="line-modified">3665                                cols += astr.columnLength();</span>
<span class="line-modified">3666                            } else {</span>
<span class="line-modified">3667                                astr = new AttributedString(str, AttributedStyle.HIDDEN);</span>
<span class="line-modified">3668                            }</span>
<span class="line-modified">3669                            if (padPartIndex == parts.size()) {</span>
<span class="line-modified">3670                                padPartString = sb;</span>
<span class="line-modified">3671                                if (i &lt; plen) {</span>
<span class="line-modified">3672                                    sb = new StringBuilder();</span>
<span class="line-modified">3673                                }</span>
<span class="line-modified">3674                            } else {</span>
<span class="line-modified">3675                                sb.setLength(0);</span>
<span class="line-modified">3676                            }</span>
<span class="line-modified">3677                            parts.add(astr);</span>
<span class="line-modified">3678                            isHidden = ch == &#39;{&#39;;</span>
3679                             break decode;
3680                         case &#39;%&#39;:
3681                             sb.append(ch);
3682                             break decode;
3683                         case &#39;N&#39;:
3684                             sb.append(getInt(LINE_OFFSET, 0) + line);
3685                             break decode;
3686                         case &#39;M&#39;:
3687                             if (message != null)
3688                                 sb.append(message);
3689                             break decode;
3690                         case &#39;P&#39;:
3691                             if (countSeen &amp;&amp; count &gt;= 0)
3692                                 padToWidth = count;
3693                             if (i &lt; plen) {
3694                                 padChar = pattern.charAt(i++);
3695                                 // FIXME check surrogate
3696                             }
3697                             padPos = sb.length();
3698                             padPartIndex = parts.size();
</pre>
<hr />
<pre>
4031                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),
4032                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),
4033                     typoMatcher(wdi, errors, caseInsensitive)
4034             );
4035             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4036         }
4037         // Find matching candidates
4038         Map&lt;String, List&lt;Candidate&gt;&gt; matching = Collections.emptyMap();
4039         for (Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4040                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt; matcher : matchers) {
4041             matching = matcher.apply(sortedCandidates);
4042             if (!matching.isEmpty()) {
4043                 break;
4044             }
4045         }
4046 
4047         // If we have no matches, bail out
4048         if (matching.isEmpty()) {
4049             return false;
4050         }



























































4051 
<span class="line-removed">4052         // If we only need to display the list, do it now</span>
<span class="line-removed">4053         if (lst == CompletionType.List) {</span>
4054             List&lt;Candidate&gt; possible = matching.entrySet().stream()
4055                     .flatMap(e -&gt; e.getValue().stream())
4056                     .collect(Collectors.toList());
<span class="line-modified">4057             doList(possible, line.word(), false, line::escape);</span>
<span class="line-modified">4058             return !possible.isEmpty();</span>
<span class="line-modified">4059         }</span>
<span class="line-modified">4060 </span>
<span class="line-modified">4061         // Check if there&#39;s a single possible match</span>
<span class="line-modified">4062         Candidate completion = null;</span>
<span class="line-modified">4063         // If there&#39;s a single possible completion</span>
<span class="line-modified">4064         if (matching.size() == 1) {</span>
<span class="line-modified">4065             completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-modified">4066                     .findFirst().orElse(null);</span>
<span class="line-removed">4067         }</span>
<span class="line-removed">4068         // Or if RECOGNIZE_EXACT is set, try to find an exact match</span>
<span class="line-removed">4069         else if (isSet(Option.RECOGNIZE_EXACT)) {</span>
<span class="line-removed">4070             completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-removed">4071                     .filter(Candidate::complete)</span>
<span class="line-removed">4072                     .filter(c -&gt; exact.test(c.value()))</span>
<span class="line-removed">4073                     .findFirst().orElse(null);</span>
<span class="line-removed">4074         }</span>
<span class="line-removed">4075         // Complete and exit</span>
<span class="line-removed">4076         if (completion != null &amp;&amp; !completion.value().isEmpty()) {</span>
4077             if (prefix) {
<span class="line-modified">4078                 buf.backspace(line.rawWordCursor());</span>
4079             } else {

4080                 buf.move(line.rawWordLength() - line.rawWordCursor());
<span class="line-removed">4081                 buf.backspace(line.rawWordLength());</span>
4082             }
<span class="line-modified">4083             buf.write(line.escape(completion.value(), completion.complete()));</span>
<span class="line-modified">4084             if (completion.complete()) {</span>
<span class="line-modified">4085                 if (buf.currChar() != &#39; &#39;) {</span>
<span class="line-modified">4086                     buf.write(&quot; &quot;);</span>
<span class="line-modified">4087                 } else {</span>
<span class="line-removed">4088                     buf.move(1);</span>
<span class="line-removed">4089                 }</span>
4090             }
<span class="line-modified">4091             if (completion.suffix() != null) {</span>
<span class="line-modified">4092                 redisplay();</span>
<span class="line-modified">4093                 Binding op = readBinding(getKeys());</span>
<span class="line-modified">4094                 if (op != null) {</span>
<span class="line-modified">4095                     String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);</span>
<span class="line-modified">4096                     String ref = op instanceof Reference ? ((Reference) op).name() : null;</span>
<span class="line-modified">4097                     if (SELF_INSERT.equals(ref) &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0</span>
<span class="line-modified">4098                             || ACCEPT_LINE.equals(ref)) {</span>
<span class="line-modified">4099                         buf.backspace(completion.suffix().length());</span>
<span class="line-modified">4100                         if (getLastBinding().charAt(0) != &#39; &#39;) {</span>
<span class="line-removed">4101                             buf.write(&#39; &#39;);</span>
<span class="line-removed">4102                         }</span>
4103                     }
<span class="line-removed">4104                     pushBackBinding(true);</span>
4105                 }
4106             }
<span class="line-modified">4107             return true;</span>
<span class="line-modified">4108         }</span>
<span class="line-removed">4109 </span>
<span class="line-removed">4110         List&lt;Candidate&gt; possible = matching.entrySet().stream()</span>
<span class="line-removed">4111                 .flatMap(e -&gt; e.getValue().stream())</span>
<span class="line-removed">4112                 .collect(Collectors.toList());</span>
<span class="line-removed">4113 </span>
<span class="line-removed">4114         if (useMenu) {</span>
<span class="line-removed">4115             buf.move(line.word().length() - line.wordCursor());</span>
<span class="line-removed">4116             buf.backspace(line.word().length());</span>
<span class="line-removed">4117             doMenu(possible, line.word(), line::escape);</span>
<span class="line-removed">4118             return true;</span>
<span class="line-removed">4119         }</span>
<span class="line-removed">4120 </span>
<span class="line-removed">4121         // Find current word and move to end</span>
<span class="line-removed">4122         String current;</span>
<span class="line-removed">4123         if (prefix) {</span>
<span class="line-removed">4124             current = line.word().substring(0, line.wordCursor());</span>
<span class="line-removed">4125         } else {</span>
<span class="line-removed">4126             current = line.word();</span>
<span class="line-removed">4127             buf.move(line.rawWordLength() - line.rawWordCursor());</span>
<span class="line-removed">4128         }</span>
<span class="line-removed">4129         // Now, we need to find the unambiguous completion</span>
<span class="line-removed">4130         // TODO: need to find common suffix</span>
<span class="line-removed">4131         String commonPrefix = null;</span>
<span class="line-removed">4132         for (String key : matching.keySet()) {</span>
<span class="line-removed">4133             commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);</span>
<span class="line-removed">4134         }</span>
<span class="line-removed">4135         boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);</span>
<span class="line-removed">4136 </span>
<span class="line-removed">4137         if (hasUnambiguous) {</span>
<span class="line-removed">4138             buf.backspace(line.rawWordLength());</span>
<span class="line-removed">4139             buf.write(line.escape(commonPrefix, false));</span>
<span class="line-removed">4140             current = commonPrefix;</span>
<span class="line-removed">4141             if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))</span>
<span class="line-removed">4142                     || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {</span>
<span class="line-removed">4143                 if (!nextBindingIsComplete()) {</span>
4144                     return true;
4145                 }
4146             }
<span class="line-modified">4147         }</span>
<span class="line-modified">4148         if (isSet(Option.AUTO_LIST)) {</span>
<span class="line-modified">4149             if (!doList(possible, current, true, line::escape)) {</span>
<span class="line-removed">4150                 return true;</span>
4151             }



4152         }
<span class="line-removed">4153         if (isSet(Option.AUTO_MENU)) {</span>
<span class="line-removed">4154             buf.backspace(current.length());</span>
<span class="line-removed">4155             doMenu(possible, line.word(), line::escape);</span>
<span class="line-removed">4156         }</span>
<span class="line-removed">4157         return true;</span>
4158     }
4159 
4160     private CompletingParsedLine wrap(ParsedLine line) {
4161         if (line instanceof CompletingParsedLine) {
4162             return (CompletingParsedLine) line;
4163         } else {
4164             return new CompletingParsedLine() {
4165                 public String word() {
4166                     return line.word();
4167                 }
4168                 public int wordCursor() {
4169                     return line.wordCursor();
4170                 }
4171                 public int wordIndex() {
4172                     return line.wordIndex();
4173                 }
4174                 public List&lt;String&gt; words() {
4175                     return line.words();
4176                 }
4177                 public String line() {
</pre>
<hr />
<pre>
4517             }
4518             redisplay();
4519         }
4520         return false;
4521     }
4522 
4523     protected boolean doList(List&lt;Candidate&gt; possible, String completed, boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4524         // If we list only and if there&#39;s a big
4525         // number of items, we should ask the user
4526         // for confirmation, display the list
4527         // and redraw the line at the bottom
4528         mergeCandidates(possible);
4529         AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4530         int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4531         PostResult postResult = computePost(possible, null, null, completed);
4532         int lines = postResult.lines;
4533         int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
4534         if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
4535                 || lines &gt;= size.getRows() - promptLines) {
4536             // prompt
<span class="line-modified">4537             post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see to see all &quot; + possible.size()</span>
4538                     + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);
4539             redisplay(true);
4540             int c = readCharacter();
4541             if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {
4542                 post = null;
4543                 return false;
4544             }
4545         }
4546 
4547         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4548         StringBuilder sb = new StringBuilder();
4549         while (true) {
4550             String current = completed + sb.toString();
4551             List&lt;Candidate&gt; cands;
4552             if (sb.length() &gt; 0) {
4553                 cands = possible.stream()
4554                         .filter(c -&gt; caseInsensitive
4555                                     ? c.value().toLowerCase().startsWith(current.toLowerCase())
4556                                     : c.value().startsWith(current))
4557                         .sorted(getCandidateComparator(caseInsensitive, current))
</pre>
<hr />
<pre>
4569                     post = null;
4570                     int oldCursor = buf.cursor();
4571                     buf.cursor(buf.length());
4572                     redisplay(false);
4573                     buf.cursor(oldCursor);
4574                     println();
4575                     List&lt;AttributedString&gt; ls = postResult.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
4576                     Display d = new Display(terminal, false);
4577                     d.resize(size.getRows(), size.getColumns());
4578                     d.update(ls, -1);
4579                     redrawLine();
4580                     return new AttributedString(&quot;&quot;);
4581                 }
4582                 return pr.post;
4583             };
4584             if (!runLoop) {
4585                 return false;
4586             }
4587             redisplay();
4588             // TODO: use a different keyMap ?
<span class="line-modified">4589             Binding b = bindingReader.readBinding(getKeys());</span>
4590             if (b instanceof Reference) {
4591                 String name = ((Reference) b).name();
4592                 if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
4593                     if (sb.length() == 0) {
4594                         pushBackBinding();
4595                         post = null;
4596                         return false;
4597                     } else {
4598                         sb.setLength(sb.length() - 1);
4599                         buf.backspace();
4600                     }
4601                 } else if (SELF_INSERT.equals(name)) {
4602                     sb.append(getLastBinding());
4603                     buf.write(getLastBinding());
4604                     if (cands.isEmpty()) {
4605                         post = null;
4606                         return false;
4607                     }
4608                 } else if (&quot;\t&quot;.equals(getLastBinding())) {
4609                     if (cands.size() == 1 || sb.length() &gt; 0) {
</pre>
<hr />
<pre>
4714                         len += wcwidth.apply(cand.descr());
4715                         len += DESC_SUFFIX.length();
4716                     }
4717                     maxWidth = Math.max(maxWidth, len);
4718                 }
4719             }
4720         }
4721         // Build columns
4722         AttributedStringBuilder sb = new AttributedStringBuilder();
4723         for (Object list : items) {
4724             toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, out);
4725         }
4726         if (sb.length() &gt; 0 &amp;&amp; sb.charAt(sb.length() - 1) == &#39;\n&#39;) {
4727             sb.setLength(sb.length() - 1);
4728         }
4729         return new PostResult(sb.toAttributedString(), out[0], out[1]);
4730     }
4731 
4732     @SuppressWarnings(&quot;unchecked&quot;)
4733     protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {
<span class="line-modified">4734         if (maxWidth &lt;= 0) {</span>
4735             return;
4736         }
4737         // This is a group
4738         if (items instanceof String) {
4739             sb.style(getCompletionStyleGroup())
4740                     .append((String) items)
4741                     .style(AttributedStyle.DEFAULT)
4742                     .append(&quot;\n&quot;);
4743             out[0]++;
4744         }
4745         // This is a Candidate list
4746         else if (items instanceof List) {
4747             List&lt;Candidate&gt; candidates = (List&lt;Candidate&gt;) items;
4748             maxWidth = Math.min(width, maxWidth);
4749             int c = width / maxWidth;
4750             while (c &gt; 1 &amp;&amp; c * maxWidth + (c - 1) * MARGIN_BETWEEN_COLUMNS &gt;= width) {
4751                 c--;
4752             }
4753             int lines = (candidates.size() + c - 1) / c;
4754             // Try to minimize the number of columns for the given number of rows
</pre>
<hr />
<pre>
4968             while (buf.atChar(end) != 0 &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
4969                 end++;
4970             }
4971             start = end;
4972             for (int count = -this.count; count &gt; 0; --count) {
4973                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
4974                     start--;
4975                 }
4976                 start--;
4977             }
4978         } else {
4979             start = buf.cursor();
4980             while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
4981                 start--;
4982             }
4983             end = start;
4984             while (count-- &gt; 0) {
4985                 while (end &lt; buf.length() &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
4986                     end++;
4987                 }
<span class="line-modified">4988                 end++;</span>


4989             }
4990         }
4991         String killed = buf.substring(start, end);
4992         buf.cursor(start);
4993         buf.delete(end - start);
4994         killRing.add(killed);
4995         return true;
4996     }
4997 
4998     /**
4999      * Kill the buffer ahead of the current cursor position.
5000      *
5001      * @return true if successful
5002      */
5003     public boolean killLine() {
5004         if (count &lt; 0) {
5005             return callNeg(this::backwardKillLine);
5006         }
5007         if (buf.cursor() == buf.length()) {
5008             return false;
</pre>
<hr />
<pre>
5171             int currentLine = promptLines.size() - 1;
5172             int wantedLine = Math.max(0, Math.min(currentLine + event.getY() - cursor.getY(), secondaryPrompts.size()));
5173             int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();
5174             int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();
5175             int adjust = pl1 - pl0;
5176             buf.moveXY(event.getX() - cursor.getX() - adjust, event.getY() - cursor.getY());
5177         }
5178         return true;
5179     }
5180 
5181     public boolean beginPaste() {
5182         final Object SELF_INSERT = new Object();
5183         final Object END_PASTE = new Object();
5184         KeyMap&lt;Object&gt; keyMap = new KeyMap&lt;&gt;();
5185         keyMap.setUnicode(SELF_INSERT);
5186         keyMap.setNomatch(SELF_INSERT);
5187         keyMap.setAmbiguousTimeout(0);
5188         keyMap.bind(END_PASTE, BRACKETED_PASTE_END);
5189         StringBuilder sb = new StringBuilder();
5190         while (true) {
<span class="line-modified">5191             Object b = bindingReader.readBinding(keyMap);</span>
5192             if (b == END_PASTE) {
5193                 break;
5194             }
5195             String s = getLastBinding();
5196             if (&quot;\r&quot;.equals(s)) {
5197                 s = &quot;\n&quot;;
5198             }
5199             sb.append(s);
5200         }
5201         regionActive = RegionType.PASTE;
5202         regionMark = getBuffer().cursor();
5203         getBuffer().write(sb);
5204         return true;
5205     }
5206 
5207     public boolean focusIn() {
5208         return false;
5209     }
5210 
5211     public boolean focusOut() {
5212         return false;
5213     }
5214 
5215     /**
5216      * Clean the used display
5217      * @return &lt;code&gt;true&lt;/code&gt;
5218      */
5219     public boolean clear() {
5220         display.update(Collections.emptyList(), 0);
5221         return true;
5222     }
5223 
5224     /**
5225      * Clear the screen by issuing the ANSI &quot;clear screen&quot; code.
5226      * @return &lt;code&gt;true&lt;/code&gt;
5227      */
5228     public boolean clearScreen() {
5229         if (terminal.puts(Capability.clear_screen)) {





5230             Status status = Status.getStatus(terminal, false);
5231             if (status != null) {
5232                 status.reset();
5233             }
5234             redrawLine();
5235         } else {
5236             println();
5237         }
5238         return true;
5239     }
5240 
5241     /**
5242      * Issue an audible keyboard bell.
5243      * @return &lt;code&gt;true&lt;/code&gt;
5244      */
5245     public boolean beep() {
5246         BellType bell_preference = BellType.AUDIBLE;
5247         switch (getString(BELL_STYLE, DEFAULT_BELL_STYLE).toLowerCase()) {
5248             case &quot;none&quot;:
5249             case &quot;off&quot;:
</pre>
<hr />
<pre>
5341         keyMaps.put(VIOPP, viOpp());
5342         keyMaps.put(VISUAL, visual());
5343         keyMaps.put(SAFE, safe());
5344         if (getBoolean(BIND_TTY_SPECIAL_CHARS, true)) {
5345             Attributes attr = terminal.getAttributes();
5346             bindConsoleChars(keyMaps.get(EMACS), attr);
5347             bindConsoleChars(keyMaps.get(VIINS), attr);
5348         }
5349         // Put default
5350         for (KeyMap&lt;Binding&gt; keyMap : keyMaps.values()) {
5351             keyMap.setUnicode(new Reference(SELF_INSERT));
5352             keyMap.setAmbiguousTimeout(getLong(AMBIGUOUS_BINDING, DEFAULT_AMBIGUOUS_BINDING));
5353         }
5354         // By default, link main to emacs
5355         keyMaps.put(MAIN, keyMaps.get(EMACS));
5356         return keyMaps;
5357     }
5358 
5359     public KeyMap&lt;Binding&gt; emacs() {
5360         KeyMap&lt;Binding&gt; emacs = new KeyMap&lt;&gt;();

5361         bind(emacs, SET_MARK_COMMAND,                       ctrl(&#39;@&#39;));
5362         bind(emacs, BEGINNING_OF_LINE,                      ctrl(&#39;A&#39;));
5363         bind(emacs, BACKWARD_CHAR,                          ctrl(&#39;B&#39;));
5364         bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl(&#39;D&#39;));
5365         bind(emacs, END_OF_LINE,                            ctrl(&#39;E&#39;));
5366         bind(emacs, FORWARD_CHAR,                           ctrl(&#39;F&#39;));
5367         bind(emacs, SEND_BREAK,                             ctrl(&#39;G&#39;));
5368         bind(emacs, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5369         bind(emacs, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5370         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5371         bind(emacs, KILL_LINE,                              ctrl(&#39;K&#39;));
5372         bind(emacs, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5373         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5374         bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));

5375         bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
5376         bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5377         bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5378         bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5379         bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5380         bind(emacs, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5381         bind(emacs, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5382         bind(emacs, YANK,                                   ctrl(&#39;Y&#39;));
5383         bind(emacs, CHARACTER_SEARCH,                       ctrl(&#39;]&#39;));
5384         bind(emacs, UNDO,                                   ctrl(&#39;_&#39;));
5385         bind(emacs, SELF_INSERT,                            range(&quot; -~&quot;));
5386         bind(emacs, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5387         bind(emacs, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5388         bind(emacs, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5389         bind(emacs, BACKWARD_DELETE_CHAR,                   del());
5390         bind(emacs, VI_MATCH_BRACKET,                       translate(&quot;^X^B&quot;));
5391         bind(emacs, SEND_BREAK,                             translate(&quot;^X^G&quot;));
5392         bind(emacs, VI_FIND_NEXT_CHAR,                      translate(&quot;^X^F&quot;));
5393         bind(emacs, VI_JOIN,                                translate(&quot;^X^J&quot;));
5394         bind(emacs, KILL_BUFFER,                            translate(&quot;^X^K&quot;));
</pre>
<hr />
<pre>
5398         bind(emacs, UNDO,                                   translate(&quot;^X^U&quot;));
5399         bind(emacs, VI_CMD_MODE,                            translate(&quot;^X^V&quot;));
5400         bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(&quot;^X^X&quot;));
5401         bind(emacs, DO_LOWERCASE_VERSION,                   translate(&quot;^XA-^XZ&quot;));
5402         bind(emacs, WHAT_CURSOR_POSITION,                   translate(&quot;^X=&quot;));
5403         bind(emacs, KILL_LINE,                              translate(&quot;^X^?&quot;));
5404         bind(emacs, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5405         bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5406         bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5407         bind(emacs, COMPLETE_WORD,                          alt(esc()));
5408         bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5409         bind(emacs, COPY_PREV_WORD,                         alt(ctrl(&#39;_&#39;)));
5410         bind(emacs, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5411         bind(emacs, NEG_ARGUMENT,                           alt(&#39;-&#39;));
5412         bind(emacs, DIGIT_ARGUMENT,                         range(&quot;\\E0-\\E9&quot;));
5413         bind(emacs, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5414         bind(emacs, LIST_CHOICES,                           alt(&#39;=&#39;));
5415         bind(emacs, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5416         bind(emacs, LIST_CHOICES,                           alt(&#39;?&#39;));
5417         bind(emacs, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));

5418         bind(emacs, BACKWARD_WORD,                          alt(&#39;b&#39;));
5419         bind(emacs, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5420         bind(emacs, KILL_WORD,                              alt(&#39;d&#39;));
5421         bind(emacs, KILL_WORD,                              translate(&quot;^[[3;5~&quot;)); // ctrl-delete
5422         bind(emacs, FORWARD_WORD,                           alt(&#39;f&#39;));
5423         bind(emacs, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5424         bind(emacs, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5425         bind(emacs, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5426         bind(emacs, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5427         bind(emacs, UP_CASE_WORD,                           alt(&#39;u&#39;));
5428         bind(emacs, YANK_POP,                               alt(&#39;y&#39;));
5429         bind(emacs, BACKWARD_KILL_WORD,                     alt(del()));
5430         bindArrowKeys(emacs);
5431         bind(emacs, FORWARD_WORD,                           translate(&quot;^[[1;5C&quot;)); // ctrl-left
5432         bind(emacs, BACKWARD_WORD,                          translate(&quot;^[[1;5D&quot;)); // ctrl-right
5433         bind(emacs, FORWARD_WORD,                           alt(key(Capability.key_right)));
5434         bind(emacs, BACKWARD_WORD,                          alt(key(Capability.key_left)));
5435         bind(emacs, FORWARD_WORD,                           alt(translate(&quot;^[[C&quot;)));
5436         bind(emacs, BACKWARD_WORD,                          alt(translate(&quot;^[[D&quot;)));
5437         return emacs;
5438     }
5439 
5440     public KeyMap&lt;Binding&gt; viInsertion() {
5441         KeyMap&lt;Binding&gt; viins = new KeyMap&lt;&gt;();

5442         bind(viins, SELF_INSERT,                            range(&quot;^@-^_&quot;));
5443         bind(viins, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5444         bind(viins, SEND_BREAK,                             ctrl(&#39;G&#39;));
5445         bind(viins, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5446         bind(viins, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5447         bind(viins, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5448         bind(viins, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5449         bind(viins, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5450         bind(viins, MENU_COMPLETE,                          ctrl(&#39;N&#39;));
5451         bind(viins, REVERSE_MENU_COMPLETE,                  ctrl(&#39;P&#39;));
5452         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5453         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5454         bind(viins, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5455         bind(viins, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5456         bind(viins, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5457         bind(viins, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5458         bind(viins, YANK,                                   ctrl(&#39;Y&#39;));
5459         bind(viins, VI_CMD_MODE,                            ctrl(&#39;[&#39;));
5460         bind(viins, UNDO,                                   ctrl(&#39;_&#39;));
5461         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
</pre>
<hr />
<pre>
5621         bind(viOpp, VI_CMD_MODE,                esc());
5622         return viOpp;
5623     }
5624 
5625     private void bind(KeyMap&lt;Binding&gt; map, String widget, Iterable&lt;? extends CharSequence&gt; keySeqs) {
5626         map.bind(new Reference(widget), keySeqs);
5627     }
5628 
5629     private void bind(KeyMap&lt;Binding&gt; map, String widget, CharSequence... keySeqs) {
5630         map.bind(new Reference(widget), keySeqs);
5631     }
5632 
5633     private void bind(KeyMap&lt;Binding&gt; map, Widget widget, CharSequence... keySeqs) {
5634         map.bind(widget, keySeqs);
5635     }
5636 
5637     private String key(Capability capability) {
5638         return KeyMap.key(terminal, capability);
5639     }
5640 








5641     private void bindArrowKeys(KeyMap&lt;Binding&gt; map) {
5642         bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));
5643         bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));
5644         bind(map, BACKWARD_CHAR,        key(Capability.key_left));
5645         bind(map, FORWARD_CHAR,         key(Capability.key_right));
5646         bind(map, BEGINNING_OF_LINE,    key(Capability.key_home));
5647         bind(map, END_OF_LINE,          key(Capability.key_end));
5648         bind(map, DELETE_CHAR,          key(Capability.key_dc));
5649         bind(map, KILL_WHOLE_LINE,      key(Capability.key_dl));
5650         bind(map, OVERWRITE_MODE,       key(Capability.key_ic));
5651         bind(map, MOUSE,                key(Capability.key_mouse));
5652         bind(map, BEGIN_PASTE,          BRACKETED_PASTE_BEGIN);
5653         bind(map, FOCUS_IN,             FOCUS_IN_SEQ);
5654         bind(map, FOCUS_OUT,            FOCUS_OUT_SEQ);
5655     }
5656 
5657     /**
5658      * Bind special chars defined by the terminal instead of
5659      * the default bindings
5660      */
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002-2019, the original author or authors.</span>
   3  *
   4  * This software is distributable under the BSD license. See the terms of the
   5  * BSD license in the documentation provided with this software.
   6  *
<span class="line-modified">   7  * https://opensource.org/licenses/BSD-3-Clause</span>
   8  */
   9 package jdk.internal.org.jline.reader.impl;
  10 
  11 import java.io.Flushable;
  12 import java.io.IOError;
  13 import java.io.IOException;
  14 import java.io.InputStream;
  15 import java.io.InterruptedIOException;
  16 import java.time.Instant;
  17 import java.util.*;
  18 import java.util.Map.Entry;
  19 import java.util.concurrent.atomic.AtomicBoolean;
<span class="line-added">  20 import java.util.concurrent.locks.Lock;</span>
<span class="line-added">  21 import java.util.concurrent.locks.ReentrantLock;</span>
  22 import java.util.function.*;
  23 import java.util.regex.Matcher;
  24 import java.util.regex.Pattern;
  25 import java.util.stream.Collectors;
<span class="line-added">  26 import java.util.stream.Stream;</span>
  27 import java.util.stream.StreamSupport;
  28 
  29 import jdk.internal.org.jline.keymap.BindingReader;
  30 import jdk.internal.org.jline.keymap.KeyMap;
  31 import jdk.internal.org.jline.reader.*;
  32 import jdk.internal.org.jline.reader.Parser.ParseContext;
  33 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  34 import jdk.internal.org.jline.terminal.*;
  35 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  36 import jdk.internal.org.jline.terminal.Terminal.Signal;
  37 import jdk.internal.org.jline.terminal.Terminal.SignalHandler;
<span class="line-added">  38 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;</span>
  39 import jdk.internal.org.jline.utils.AttributedString;
  40 import jdk.internal.org.jline.utils.AttributedStringBuilder;
  41 import jdk.internal.org.jline.utils.AttributedStyle;
  42 import jdk.internal.org.jline.utils.Curses;
  43 import jdk.internal.org.jline.utils.Display;
  44 import jdk.internal.org.jline.utils.InfoCmp.Capability;
  45 import jdk.internal.org.jline.utils.Levenshtein;
  46 import jdk.internal.org.jline.utils.Log;
  47 import jdk.internal.org.jline.utils.Status;
  48 import jdk.internal.org.jline.utils.WCWidth;
  49 
  50 import static jdk.internal.org.jline.keymap.KeyMap.alt;
  51 import static jdk.internal.org.jline.keymap.KeyMap.ctrl;
  52 import static jdk.internal.org.jline.keymap.KeyMap.del;
  53 import static jdk.internal.org.jline.keymap.KeyMap.esc;
  54 import static jdk.internal.org.jline.keymap.KeyMap.range;
  55 import static jdk.internal.org.jline.keymap.KeyMap.translate;
  56 
  57 /**
  58  * A reader for terminal applications. It supports custom tab-completion,
</pre>
<hr />
<pre>
 146     //
 147     // Configuration
 148     //
 149     protected final Map&lt;String, Object&gt; variables;
 150     protected History history = new DefaultHistory();
 151     protected Completer completer = null;
 152     protected Highlighter highlighter = new DefaultHighlighter();
 153     protected Parser parser = new DefaultParser();
 154     protected Expander expander = new DefaultExpander();
 155 
 156     //
 157     // State variables
 158     //
 159 
 160     protected final Map&lt;Option, Boolean&gt; options = new HashMap&lt;&gt;();
 161 
 162     protected final Buffer buf = new BufferImpl();
 163 
 164     protected final Size size = new Size();
 165 
<span class="line-modified"> 166     protected AttributedString prompt = AttributedString.EMPTY;</span>
<span class="line-modified"> 167     protected AttributedString rightPrompt = AttributedString.EMPTY;</span>
 168 
 169     protected MaskingCallback maskingCallback;
 170 
 171     protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
 172     protected Buffer historyBuffer = null;
 173     protected CharSequence searchBuffer;
 174     protected StringBuffer searchTerm = null;
 175     protected boolean searchFailing;
 176     protected boolean searchBackward;
 177     protected int searchIndex = -1;
 178 
 179 
 180     // Reading buffers
 181     protected final BindingReader bindingReader;
 182 
 183 
 184     /**
 185      * VI character find
 186      */
 187     protected int findChar;
</pre>
<hr />
<pre>
 197      * Region state
 198      */
 199     protected int regionMark;
 200     protected RegionType regionActive;
 201 
 202     private boolean forceChar;
 203     private boolean forceLine;
 204 
 205     /**
 206      * The vi yank buffer
 207      */
 208     protected String yankBuffer = &quot;&quot;;
 209 
 210     protected ViMoveMode viMoveMode = ViMoveMode.NORMAL;
 211 
 212     protected KillRing killRing = new KillRing();
 213 
 214     protected UndoTree&lt;Buffer&gt; undo = new UndoTree&lt;&gt;(this::setBuffer);
 215     protected boolean isUndo;
 216 
<span class="line-added"> 217     /**</span>
<span class="line-added"> 218      * State lock</span>
<span class="line-added"> 219      */</span>
<span class="line-added"> 220     protected final ReentrantLock lock = new ReentrantLock();</span>
 221     /*
 222      * Current internal state of the line reader
 223      */
 224     protected State   state = State.DONE;
 225     protected final AtomicBoolean startedReading = new AtomicBoolean();
 226     protected boolean reading;
 227 
 228     protected Supplier&lt;AttributedString&gt; post;
 229 
 230     protected Map&lt;String, Widget&gt; builtinWidgets;
 231     protected Map&lt;String, Widget&gt; widgets;
 232 
 233     protected int count;
 234     protected int mult;
 235     protected int universal = 4;
 236     protected int repeatCount;
 237     protected boolean isArgDigit;
 238 
 239     protected ParsedLine parsedLine;
 240 
 241     protected boolean skipRedisplay;
 242     protected Display display;
 243 
 244     protected boolean overTyping = false;
 245 
 246     protected String keyMap;
 247 
 248     protected int smallTerminalOffset = 0;
 249 
<span class="line-added"> 250     /*</span>
<span class="line-added"> 251      * accept-and-infer-next-history, accept-and-hold &amp; accept-line-and-down-history</span>
<span class="line-added"> 252      */</span>
<span class="line-added"> 253     protected boolean nextCommandFromHistory = false;</span>
<span class="line-added"> 254     protected int nextHistoryId = -1;</span>
 255 
 256 
 257     public LineReaderImpl(Terminal terminal) throws IOException {
 258         this(terminal, null, null);
 259     }
 260 
 261     public LineReaderImpl(Terminal terminal, String appName) throws IOException {
 262         this(terminal, appName, null);
 263     }
 264 
 265     public LineReaderImpl(Terminal terminal, String appName, Map&lt;String, Object&gt; variables) {
 266         Objects.requireNonNull(terminal, &quot;terminal can not be null&quot;);
 267         this.terminal = terminal;
 268         if (appName == null) {
 269             appName = &quot;JLine&quot;;
 270         }
 271         this.appName = appName;
 272         if (variables != null) {
 273             this.variables = variables;
 274         } else {
 275             this.variables = new HashMap&lt;&gt;();
 276         }
 277         this.keyMaps = defaultKeyMaps();
 278 
 279         builtinWidgets = builtinWidgets();
 280         widgets = new HashMap&lt;&gt;(builtinWidgets);
 281         bindingReader = new BindingReader(terminal.reader());
<span class="line-added"> 282         doDisplay();</span>
 283     }
 284 
 285     public Terminal getTerminal() {
 286         return terminal;
 287     }
 288 
 289     public String getAppName() {
 290         return appName;
 291     }
 292 
 293     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; getKeyMaps() {
 294         return keyMaps;
 295     }
 296 
 297     public KeyMap&lt;Binding&gt; getKeys() {
 298         return keyMaps.get(keyMap);
 299     }
 300 
 301     @Override
 302     public Map&lt;String, Widget&gt; getWidgets() {
</pre>
<hr />
<pre>
 464      * @param prompt          The prompt to issue to the terminal, may be null.
 465      * @param rightPrompt     The prompt to issue to the right of the terminal, may be null.
 466      * @param maskingCallback The callback used to mask parts of the edited line.
 467      * @param buffer          A string that will be set for editing.
 468      * @return                A line that is read from the terminal, can never be null.
 469      */
 470     public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {
 471         // prompt may be null
 472         // maskingCallback may be null
 473         // buffer may be null
 474 
 475         if (!startedReading.compareAndSet(false, true)) {
 476             throw new IllegalStateException();
 477         }
 478 
 479         Thread readLineThread = Thread.currentThread();
 480         SignalHandler previousIntrHandler = null;
 481         SignalHandler previousWinchHandler = null;
 482         SignalHandler previousContHandler = null;
 483         Attributes originalAttributes = null;
<span class="line-modified"> 484         boolean dumb = isTerminalDumb();</span>

 485         try {
 486 
 487             this.maskingCallback = maskingCallback;
 488 
 489             /*
 490              * This is the accumulator for VI-mode repeat count. That is, while in
 491              * move mode, if you type 30x it will delete 30 characters. This is
 492              * where the &quot;30&quot; is accumulated until the command is struck.
 493              */
 494             repeatCount = 0;
 495             mult = 1;
 496             regionActive = RegionType.NONE;
 497             regionMark = -1;
 498 
 499             smallTerminalOffset = 0;
 500 
 501             state = State.NORMAL;
 502 
 503             modifiedHistory.clear();
 504 
 505             setPrompt(prompt);
 506             setRightPrompt(rightPrompt);
 507             buf.clear();
 508             if (buffer != null) {
 509                 buf.write(buffer);
 510             }
<span class="line-added"> 511             if (nextCommandFromHistory &amp;&amp; nextHistoryId &gt; 0) {</span>
<span class="line-added"> 512                 if (history.size() &gt; nextHistoryId) {</span>
<span class="line-added"> 513                     history.moveTo(nextHistoryId);</span>
<span class="line-added"> 514                 } else {</span>
<span class="line-added"> 515                     history.moveTo(history.last());</span>
<span class="line-added"> 516                 }</span>
<span class="line-added"> 517                 buf.write(history.current());</span>
<span class="line-added"> 518             } else {</span>
<span class="line-added"> 519                 nextHistoryId = -1;</span>
<span class="line-added"> 520             }</span>
<span class="line-added"> 521             nextCommandFromHistory = false;</span>
 522             undo.clear();
 523             parsedLine = null;
 524             keyMap = MAIN;
 525 
 526             if (history != null) {
 527                 history.attach(this);
 528             }
 529 
<span class="line-modified"> 530             try {</span>
<span class="line-added"> 531                 lock.lock();</span>
<span class="line-added"> 532 </span>
 533                 this.reading = true;
 534 
 535                 previousIntrHandler = terminal.handle(Signal.INT, signal -&gt; readLineThread.interrupt());
 536                 previousWinchHandler = terminal.handle(Signal.WINCH, this::handleSignal);
 537                 previousContHandler = terminal.handle(Signal.CONT, this::handleSignal);
 538                 originalAttributes = terminal.enterRawMode();
 539 
<span class="line-modified"> 540                 doDisplay();</span>











 541 
 542                 // Move into application mode
 543                 if (!dumb) {
 544                     terminal.puts(Capability.keypad_xmit);
 545                     if (isSet(Option.AUTO_FRESH_LINE))
 546                         callWidget(FRESH_LINE);
 547                     if (isSet(Option.MOUSE))
 548                         terminal.trackMouse(Terminal.MouseTracking.Normal);
 549                     if (isSet(Option.BRACKETED_PASTE))
 550                         terminal.writer().write(BRACKETED_PASTE_ON);
 551                 } else {
 552                     // For dumb terminals, we need to make sure that CR are ignored
 553                     Attributes attr = new Attributes(originalAttributes);
 554                     attr.setInputFlag(Attributes.InputFlag.IGNCR, true);
 555                     terminal.setAttributes(attr);
 556                 }
 557 
 558                 callWidget(CALLBACK_INIT);
 559 
 560                 undo.newState(buf.copy());
 561 
 562                 // Draw initial prompt
 563                 redrawLine();
 564                 redisplay();
<span class="line-added"> 565             } finally {</span>
<span class="line-added"> 566                 lock.unlock();</span>
 567             }
 568 
 569             while (true) {
 570 
 571                 KeyMap&lt;Binding&gt; local = null;
 572                 if (isInViCmdMode() &amp;&amp; regionActive != RegionType.NONE) {
 573                     local = keyMaps.get(VISUAL);
 574                 }
 575                 Binding o = readBinding(getKeys(), local);
 576                 if (o == null) {
 577                     throw new EndOfFileException();
 578                 }
 579                 Log.trace(&quot;Binding: &quot;, o);
 580                 if (buf.length() == 0 &amp;&amp; getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {
 581                     throw new EndOfFileException();
 582                 }
 583 
 584                 // If this is still false after handling the binding, then
 585                 // we reset our repeatCount to 0.
 586                 isArgDigit = false;
 587                 // Every command that can be repeated a specified number
 588                 // of times, needs to know how many times to repeat, so
 589                 // we figure that out here.
 590                 count = ((repeatCount == 0) ? 1 : repeatCount) * mult;
 591                 // Reset undo/redo flag
 592                 isUndo = false;
 593                 // Reset region after a paste
 594                 if (regionActive == RegionType.PASTE) {
 595                     regionActive = RegionType.NONE;
 596                 }
 597 
<span class="line-modified"> 598                 try {</span>
<span class="line-added"> 599                     lock.lock();</span>
 600                     // Get executable widget
 601                     Buffer copy = buf.copy();
 602                     Widget w = getWidget(o);
 603                     if (!w.apply()) {
 604                         beep();
 605                     }
 606                     if (!isUndo &amp;&amp; !copy.toString().equals(buf.toString())) {
 607                         undo.newState(buf.copy());
 608                     }
 609 
 610                     switch (state) {
 611                         case DONE:
 612                             return finishBuffer();
 613                         case EOF:
 614                             throw new EndOfFileException();
 615                         case INTERRUPT:
 616                             throw new UserInterruptException(buf.toString());
 617                     }
 618 
 619                     if (!isArgDigit) {
 620                         /*
 621                          * If the operation performed wasn&#39;t a vi argument
 622                          * digit, then clear out the current repeatCount;
 623                          */
 624                         repeatCount = 0;
 625                         mult = 1;
 626                     }
 627 
 628                     if (!dumb) {
 629                         redisplay();
 630                     }
<span class="line-added"> 631                 } finally {</span>
<span class="line-added"> 632                     lock.unlock();</span>
 633                 }
 634             }
 635         } catch (IOError e) {
 636             if (e.getCause() instanceof InterruptedIOException) {
 637                 throw new UserInterruptException(buf.toString());
 638             } else {
 639                 throw e;
 640             }
 641         }
 642         finally {
<span class="line-modified"> 643             try {</span>
<span class="line-added"> 644                 lock.lock();</span>
<span class="line-added"> 645 </span>
 646                 this.reading = false;
 647 
 648                 cleanup();
 649                 if (originalAttributes != null) {
 650                     terminal.setAttributes(originalAttributes);
 651                 }
 652                 if (previousIntrHandler != null) {
 653                     terminal.handle(Signal.INT, previousIntrHandler);
 654                 }
 655                 if (previousWinchHandler != null) {
 656                     terminal.handle(Signal.WINCH, previousWinchHandler);
 657                 }
 658                 if (previousContHandler != null) {
 659                     terminal.handle(Signal.CONT, previousContHandler);
 660                 }
<span class="line-added"> 661             } finally {</span>
<span class="line-added"> 662                 lock.unlock();</span>
 663             }
 664             startedReading.set(false);
 665         }
 666     }
 667 
<span class="line-modified"> 668     private boolean isTerminalDumb(){</span>
<span class="line-modified"> 669         return Terminal.TYPE_DUMB.equals(terminal.getType())</span>
<span class="line-modified"> 670                 || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());</span>
<span class="line-modified"> 671     }</span>
<span class="line-modified"> 672 </span>
<span class="line-modified"> 673     private void doDisplay(){</span>
<span class="line-modified"> 674         // Cache terminal size for the duration of the call to readLine()</span>
<span class="line-modified"> 675         // It will eventually be updated with WINCH signals</span>
<span class="line-added"> 676         size.copy(terminal.getBufferSize());</span>
<span class="line-added"> 677 </span>
<span class="line-added"> 678         display = new Display(terminal, false);</span>
<span class="line-added"> 679         if (size.getRows() == 0 || size.getColumns() == 0) {</span>
<span class="line-added"> 680             display.resize(1, Integer.MAX_VALUE);</span>
 681         } else {
<span class="line-modified"> 682             display.resize(size.getRows(), size.getColumns());</span>
 683         }
<span class="line-modified"> 684         if (isSet(Option.DELAY_LINE_WRAP))</span>
<span class="line-modified"> 685             display.setDelayLineWrap(true);</span>
<span class="line-added"> 686     }</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688     @Override</span>
<span class="line-added"> 689     public void printAbove(String str) {</span>
<span class="line-added"> 690         try {</span>
<span class="line-added"> 691             lock.lock();</span>
<span class="line-added"> 692 </span>
<span class="line-added"> 693             boolean reading = this.reading;</span>
<span class="line-added"> 694             if (reading) {</span>
<span class="line-added"> 695                 display.update(Collections.emptyList(), 0);</span>
<span class="line-added"> 696             }</span>
<span class="line-added"> 697             if (str.endsWith(&quot;\n&quot;) || str.endsWith(&quot;\n\033[m&quot;) || str.endsWith(&quot;\n\033[0m&quot;)) {</span>
<span class="line-added"> 698                 terminal.writer().print(str);</span>
<span class="line-added"> 699             } else {</span>
<span class="line-added"> 700                 terminal.writer().println(str);</span>
<span class="line-added"> 701             }</span>
<span class="line-added"> 702             if (reading) {</span>
<span class="line-added"> 703                 redisplay(false);</span>
<span class="line-added"> 704             }</span>
<span class="line-added"> 705             terminal.flush();</span>
<span class="line-added"> 706         } finally {</span>
<span class="line-added"> 707             lock.unlock();</span>
 708         }

 709     }
 710 
 711     @Override
 712     public void printAbove(AttributedString str) {
 713         printAbove(str.toAnsi(terminal));
 714     }
 715 
 716     @Override
<span class="line-modified"> 717     public boolean isReading() {</span>
<span class="line-modified"> 718         try {</span>
<span class="line-added"> 719             lock.lock();</span>
<span class="line-added"> 720             return reading;</span>
<span class="line-added"> 721         } finally {</span>
<span class="line-added"> 722             lock.unlock();</span>
<span class="line-added"> 723         }</span>
 724     }
 725 
 726     /* Make sure we position the cursor on column 0 */
 727     protected boolean freshLine() {
 728         boolean wrapAtEol = terminal.getBooleanCapability(Capability.auto_right_margin);
 729         boolean delayedWrapAtEol = wrapAtEol &amp;&amp; terminal.getBooleanCapability(Capability.eat_newline_glitch);
 730         AttributedStringBuilder sb = new AttributedStringBuilder();
 731         sb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLACK + AttributedStyle.BRIGHT));
 732         sb.append(&quot;~&quot;);
 733         sb.style(AttributedStyle.DEFAULT);
 734         if (!wrapAtEol || delayedWrapAtEol) {
 735             for (int i = 0; i &lt; size.getColumns() - 1; i++) {
 736                 sb.append(&quot; &quot;);
 737             }
 738             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 739             sb.append(&quot; &quot;);
 740             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 741         } else {
 742             // Given the terminal will wrap automatically,
 743             // we need to print one less than needed.
 744             // This means that the last character will not
 745             // be overwritten, and that&#39;s why we&#39;re using
 746             // a clr_eol first if possible.
 747             String el = terminal.getStringCapability(Capability.clr_eol);
 748             if (el != null) {
 749                 Curses.tputs(sb, el);
 750             }
 751             for (int i = 0; i &lt; size.getColumns() - 2; i++) {
 752                 sb.append(&quot; &quot;);
 753             }
 754             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 755             sb.append(&quot; &quot;);
 756             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 757         }
<span class="line-modified"> 758         sb.print(terminal);</span>
 759         return true;
 760     }
 761 
 762     @Override
<span class="line-modified"> 763     public void callWidget(String name) {</span>



 764         try {
<span class="line-modified"> 765             lock.lock();</span>
<span class="line-modified"> 766             if (!reading) {</span>
<span class="line-modified"> 767                 throw new IllegalStateException(&quot;Widgets can only be called during a `readLine` call&quot;);</span>


 768             }
<span class="line-modified"> 769             try {</span>
<span class="line-modified"> 770                 Widget w;</span>
<span class="line-added"> 771                 if (name.startsWith(&quot;.&quot;)) {</span>
<span class="line-added"> 772                     w = builtinWidgets.get(name.substring(1));</span>
<span class="line-added"> 773                 } else {</span>
<span class="line-added"> 774                     w = widgets.get(name);</span>
<span class="line-added"> 775                 }</span>
<span class="line-added"> 776                 if (w != null) {</span>
<span class="line-added"> 777                     w.apply();</span>
<span class="line-added"> 778                 }</span>
<span class="line-added"> 779             } catch (Throwable t) {</span>
<span class="line-added"> 780                 Log.debug(&quot;Error executing widget &#39;&quot;, name, &quot;&#39;&quot;, t);</span>
 781             }
<span class="line-modified"> 782         } finally {</span>
<span class="line-modified"> 783             lock.unlock();</span>
 784         }
 785     }
 786 
 787     /**
 788      * Clear the line and redraw it.
 789      * @return &lt;code&gt;true&lt;/code&gt;
 790      */
 791     public boolean redrawLine() {
 792         display.reset();
 793         return true;
 794     }
 795 
 796     /**
 797      * Write out the specified string to the buffer and the output stream.
 798      * @param str the char sequence to write in the buffer
 799      */
 800     public void putString(final CharSequence str) {
 801         buf.write(str, overTyping);
 802     }
 803 
 804     /**
 805      * Flush the terminal output stream. This is important for printout out single
 806      * characters (like a buf.backspace or keyboard) that we want the terminal to
 807      * handle immediately.
 808      */
 809     public void flush() {
 810         terminal.flush();
 811     }
 812 
 813     public boolean isKeyMap(String name) {
 814         return keyMap.equals(name);
 815     }
 816 
 817     /**
 818      * Read a character from the terminal.
 819      *
 820      * @return the character, or -1 if an EOF is received.
 821      */
 822     public int readCharacter() {
<span class="line-modified"> 823         if (lock.isHeldByCurrentThread()) {</span>
<span class="line-added"> 824             try {</span>
<span class="line-added"> 825                 lock.unlock();</span>
<span class="line-added"> 826                 return bindingReader.readCharacter();</span>
<span class="line-added"> 827             } finally {</span>
<span class="line-added"> 828                 lock.lock();</span>
<span class="line-added"> 829             }</span>
<span class="line-added"> 830         } else {</span>
<span class="line-added"> 831             return bindingReader.readCharacter();</span>
<span class="line-added"> 832         }</span>
 833     }
 834 
 835     public int peekCharacter(long timeout) {
 836         return bindingReader.peekCharacter(timeout);
 837     }
 838 
<span class="line-added"> 839     protected &lt;T&gt; T doReadBinding(KeyMap&lt;T&gt; keys, KeyMap&lt;T&gt; local) {</span>
<span class="line-added"> 840         if (lock.isHeldByCurrentThread()) {</span>
<span class="line-added"> 841             try {</span>
<span class="line-added"> 842                 lock.unlock();</span>
<span class="line-added"> 843                 return bindingReader.readBinding(keys, local);</span>
<span class="line-added"> 844             } finally {</span>
<span class="line-added"> 845                 lock.lock();</span>
<span class="line-added"> 846             }</span>
<span class="line-added"> 847         } else {</span>
<span class="line-added"> 848             return bindingReader.readBinding(keys, local);</span>
<span class="line-added"> 849         }</span>
<span class="line-added"> 850     }</span>
<span class="line-added"> 851 </span>
 852     /**
 853      * Read from the input stream and decode an operation from the key map.
 854      *
 855      * The input stream will be read character by character until a matching
 856      * binding can be found.  Characters that can&#39;t possibly be matched to
 857      * any binding will be discarded.
 858      *
 859      * @param keys the KeyMap to use for decoding the input stream
 860      * @return the decoded binding or &lt;code&gt;null&lt;/code&gt; if the end of
 861      *         stream has been reached
 862      */
 863     public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
 864         return readBinding(keys, null);
 865     }
 866 
 867     public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
<span class="line-modified"> 868         Binding o = doReadBinding(keys, local);</span>
 869         /*
 870          * The kill ring keeps record of whether or not the
 871          * previous command was a yank or a kill. We reset
 872          * that state here if needed.
 873          */
 874         if (o instanceof Reference) {
 875             String ref = ((Reference) o).name();
 876             if (!YANK_POP.equals(ref) &amp;&amp; !YANK.equals(ref)) {
 877                 killRing.resetLastYank();
 878             }
 879             if (!KILL_LINE.equals(ref) &amp;&amp; !KILL_WHOLE_LINE.equals(ref)
 880                     &amp;&amp; !BACKWARD_KILL_WORD.equals(ref) &amp;&amp; !KILL_WORD.equals(ref)) {
 881                 killRing.resetLastKill();
 882             }
 883         }
 884         return o;
 885     }
 886 
 887     @Override
 888     public ParsedLine getParsedLine() {
</pre>
<hr />
<pre>
 991 
 992     /**
 993      * Clear the buffer and add its contents to the history.
 994      *
 995      * @return the former contents of the buffer.
 996      */
 997     protected String finishBuffer() {
 998         String str = buf.toString();
 999         String historyLine = str;
1000 
1001         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
1002             StringBuilder sb = new StringBuilder();
1003             boolean escaped = false;
1004             for (int i = 0; i &lt; str.length(); i++) {
1005                 char ch = str.charAt(i);
1006                 if (escaped) {
1007                     escaped = false;
1008                     if (ch != &#39;\n&#39;) {
1009                         sb.append(ch);
1010                     }
<span class="line-modified">1011                 } else if (parser.isEscapeChar(ch)) {</span>
1012                     escaped = true;
1013                 } else {
1014                     sb.append(ch);
1015                 }
1016             }
1017             str = sb.toString();
1018         }
1019 
1020         if (maskingCallback != null) {
1021             historyLine = maskingCallback.history(historyLine);
1022         }
1023 
1024         // we only add it to the history if the buffer is not empty
1025         if (historyLine != null &amp;&amp; historyLine.length() &gt; 0 ) {
1026             history.add(Instant.now(), historyLine);
1027         }
1028         return str;
1029     }
1030 
1031     protected void handleSignal(Signal signal) {
1032         if (signal == Signal.WINCH) {
<span class="line-modified">1033             Status status = Status.getStatus(terminal, false);</span>
<span class="line-added">1034             if (status != null) {</span>
<span class="line-added">1035                 status.hardReset();</span>
<span class="line-added">1036             }</span>
<span class="line-added">1037             size.copy(terminal.getBufferSize());</span>
1038             display.resize(size.getRows(), size.getColumns());
<span class="line-added">1039             redrawLine();</span>
1040             redisplay();
1041         }
1042         else if (signal == Signal.CONT) {
1043             terminal.enterRawMode();
<span class="line-modified">1044             size.copy(terminal.getBufferSize());</span>
1045             display.resize(size.getRows(), size.getColumns());
1046             terminal.puts(Capability.keypad_xmit);
1047             redrawLine();
1048             redisplay();
1049         }
1050     }
1051 
1052     @SuppressWarnings(&quot;unchecked&quot;)
1053     protected Widget getWidget(Object binding) {
1054         Widget w;
1055         if (binding instanceof Widget) {
1056             w = (Widget) binding;
1057         } else if (binding instanceof Macro) {
1058             String macro = ((Macro) binding).getSequence();
1059             w = () -&gt; {
1060                 bindingReader.runMacro(macro);
1061                 return true;
1062             };
1063         } else if (binding instanceof Reference) {
1064             String name = ((Reference) binding).name();
</pre>
<hr />
<pre>
1973         searchDir = -searchDir;
1974         ret = viRepeatSearch();
1975         searchDir = -searchDir;
1976         return ret;
1977     }
1978 
1979     private boolean getViSearchString() {
1980         if (searchDir == 0) {
1981             return false;
1982         }
1983         String searchPrompt = searchDir &lt; 0 ? &quot;?&quot; : &quot;/&quot;;
1984         Buffer searchBuffer = new BufferImpl();
1985 
1986         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MAIN);
1987         if (keyMap == null) {
1988             keyMap = keyMaps.get(SAFE);
1989         }
1990         while (true) {
1991             post = () -&gt; new AttributedString(searchPrompt + searchBuffer.toString() + &quot;_&quot;);
1992             redisplay();
<span class="line-modified">1993             Binding b = doReadBinding(keyMap, null);</span>
1994             if (b instanceof Reference) {
1995                 String func = ((Reference) b).name();
1996                 switch (func) {
1997                     case SEND_BREAK:
1998                         post = null;
1999                         return false;
2000                     case ACCEPT_LINE:
2001                     case VI_CMD_MODE:
2002                         searchString = searchBuffer.toString();
2003                         post = null;
2004                         return true;
2005                     case MAGIC_SPACE:
2006                         searchBuffer.write(&#39; &#39;);
2007                         break;
2008                     case REDISPLAY:
2009                         redisplay();
2010                         break;
2011                     case CLEAR_SCREEN:
2012                         clearScreen();
2013                         break;
</pre>
<hr />
<pre>
2370             return false;
2371         }
2372     }
2373 
2374     /*
2375     protected int getViRange(Reference cmd, ViMoveMode mode) {
2376         Buffer buffer = buf.copy();
2377         int oldMark = mark;
2378         int pos = buf.cursor();
2379         String bind = getLastBinding();
2380 
2381         if (visual != 0) {
2382             if (buf.length() == 0) {
2383                 return -1;
2384             }
2385             pos = mark;
2386             v
2387         } else {
2388             viMoveMode = mode;
2389             mark = -1;
<span class="line-modified">2390             Binding b = doReadBinding(getKeys(), keyMaps.get(VIOPP));</span>
2391             if (b == null || new Reference(SEND_BREAK).equals(b)) {
2392                 viMoveMode = ViMoveMode.NORMAL;
2393                 mark = oldMark;
2394                 return -1;
2395             }
2396             if (cmd.equals(b)) {
2397                 doViLineRange();
2398             }
2399             Widget w = getWidget(b);
2400             if (w )
2401             if (b instanceof Reference) {
2402 
2403             }
2404         }
2405 
2406     }
2407     */
2408 
2409     protected void cleanup() {
2410         if (isSet(Option.ERASE_LINE_ON_FINISH)) {
</pre>
<hr />
<pre>
2780      * @return index where this substring has been found, or -1 else.
2781      */
2782     public int searchForwards(String searchTerm, int startIndex) {
2783         return searchForwards(searchTerm, startIndex, false);
2784     }
2785     /**
2786      * Search forwards in history from the current position.
2787      *
2788      * @param searchTerm substring to search for.
2789      * @return index where the substring has been found, or -1 else.
2790      */
2791     public int searchForwards(String searchTerm) {
2792         return searchForwards(searchTerm, history.index());
2793     }
2794 
2795     protected boolean quit() {
2796         getBuffer().clear();
2797         return acceptLine();
2798     }
2799 
<span class="line-added">2800     protected boolean acceptAndHold() {</span>
<span class="line-added">2801         nextCommandFromHistory = false;</span>
<span class="line-added">2802         acceptLine();</span>
<span class="line-added">2803         if (!buf.toString().isEmpty()) {</span>
<span class="line-added">2804             nextHistoryId = Integer.MAX_VALUE;</span>
<span class="line-added">2805             nextCommandFromHistory = true;</span>
<span class="line-added">2806         }</span>
<span class="line-added">2807         return nextCommandFromHistory;</span>
<span class="line-added">2808     }</span>
<span class="line-added">2809 </span>
<span class="line-added">2810     protected boolean acceptLineAndDownHistory() {</span>
<span class="line-added">2811         nextCommandFromHistory = false;</span>
<span class="line-added">2812         acceptLine();</span>
<span class="line-added">2813         if (nextHistoryId &lt; 0) {</span>
<span class="line-added">2814             nextHistoryId = history.index();</span>
<span class="line-added">2815         }</span>
<span class="line-added">2816         if (history.size() &gt; nextHistoryId + 1) {</span>
<span class="line-added">2817             nextHistoryId++;</span>
<span class="line-added">2818             nextCommandFromHistory = true;</span>
<span class="line-added">2819         }</span>
<span class="line-added">2820         return nextCommandFromHistory;</span>
<span class="line-added">2821     }</span>
<span class="line-added">2822 </span>
<span class="line-added">2823     protected boolean acceptAndInferNextHistory() {</span>
<span class="line-added">2824         nextCommandFromHistory = false;</span>
<span class="line-added">2825         acceptLine();</span>
<span class="line-added">2826         if (!buf.toString().isEmpty()) {</span>
<span class="line-added">2827             nextHistoryId = searchBackwards(buf.toString(), history.last());</span>
<span class="line-added">2828             if (nextHistoryId &gt;= 0 &amp;&amp; history.size() &gt; nextHistoryId + 1) {</span>
<span class="line-added">2829                 nextHistoryId++;</span>
<span class="line-added">2830                 nextCommandFromHistory = true;</span>
<span class="line-added">2831             }</span>
<span class="line-added">2832         }</span>
<span class="line-added">2833         return nextCommandFromHistory;</span>
<span class="line-added">2834     }</span>
<span class="line-added">2835 </span>
2836     protected boolean acceptLine() {
2837         parsedLine = null;
2838         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
2839             try {
2840                 String str = buf.toString();
2841                 String exp = expander.expandHistory(history, str);
2842                 if (!exp.equals(str)) {
2843                     buf.clear();
2844                     buf.write(exp);
2845                     if (isSet(Option.HISTORY_VERIFY)) {
2846                         return true;
2847                     }
2848                 }
2849             } catch (IllegalArgumentException e) {
2850                 // Ignore
2851             }
2852         }
2853         try {
2854             parsedLine = parser.parse(buf.toString(), buf.cursor(), ParseContext.ACCEPT_LINE);
2855         } catch (EOFError e) {
</pre>
<hr />
<pre>
3449                 sb.append(&quot;EOF&quot;);
3450             }
3451             sb.append(&quot;   &quot;);
3452             sb.append(&quot;point &quot;);
3453             sb.append(Integer.toString(buf.cursor() + 1));
3454             sb.append(&quot; of &quot;);
3455             sb.append(Integer.toString(buf.length() + 1));
3456             sb.append(&quot; (&quot;);
3457             sb.append(Integer.toString(buf.length() == 0 ? 100 : ((100 * buf.cursor()) / buf.length())));
3458             sb.append(&quot;%)&quot;);
3459             sb.append(&quot;   &quot;);
3460             sb.append(&quot;column &quot;);
3461             sb.append(Integer.toString(buf.cursor() - findbol()));
3462             return sb.toAttributedString();
3463         };
3464         return true;
3465     }
3466 
3467     protected Map&lt;String, Widget&gt; builtinWidgets() {
3468         Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
<span class="line-modified">3469         addBuiltinWidget(widgets, ACCEPT_AND_INFER_NEXT_HISTORY, this::acceptAndInferNextHistory);</span>
<span class="line-modified">3470         addBuiltinWidget(widgets, ACCEPT_AND_HOLD, this::acceptAndHold);</span>
<span class="line-modified">3471         addBuiltinWidget(widgets, ACCEPT_LINE, this::acceptLine);</span>
<span class="line-modified">3472         addBuiltinWidget(widgets, ACCEPT_LINE_AND_DOWN_HISTORY, this::acceptLineAndDownHistory);</span>
<span class="line-modified">3473         addBuiltinWidget(widgets, ARGUMENT_BASE, this::argumentBase);</span>
<span class="line-modified">3474         addBuiltinWidget(widgets, BACKWARD_CHAR, this::backwardChar);</span>
<span class="line-modified">3475         addBuiltinWidget(widgets, BACKWARD_DELETE_CHAR, this::backwardDeleteChar);</span>
<span class="line-modified">3476         addBuiltinWidget(widgets, BACKWARD_DELETE_WORD, this::backwardDeleteWord);</span>
<span class="line-modified">3477         addBuiltinWidget(widgets, BACKWARD_KILL_LINE, this::backwardKillLine);</span>
<span class="line-modified">3478         addBuiltinWidget(widgets, BACKWARD_KILL_WORD, this::backwardKillWord);</span>
<span class="line-modified">3479         addBuiltinWidget(widgets, BACKWARD_WORD, this::backwardWord);</span>
<span class="line-modified">3480         addBuiltinWidget(widgets, BEEP, this::beep);</span>
<span class="line-modified">3481         addBuiltinWidget(widgets, BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);</span>
<span class="line-modified">3482         addBuiltinWidget(widgets, BEGINNING_OF_HISTORY, this::beginningOfHistory);</span>
<span class="line-modified">3483         addBuiltinWidget(widgets, BEGINNING_OF_LINE, this::beginningOfLine);</span>
<span class="line-modified">3484         addBuiltinWidget(widgets, BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);</span>
<span class="line-modified">3485         addBuiltinWidget(widgets, CAPITALIZE_WORD, this::capitalizeWord);</span>
<span class="line-modified">3486         addBuiltinWidget(widgets, CLEAR, this::clear);</span>
<span class="line-modified">3487         addBuiltinWidget(widgets, CLEAR_SCREEN, this::clearScreen);</span>
<span class="line-modified">3488         addBuiltinWidget(widgets, COMPLETE_PREFIX, this::completePrefix);</span>
<span class="line-modified">3489         addBuiltinWidget(widgets, COMPLETE_WORD, this::completeWord);</span>
<span class="line-modified">3490         addBuiltinWidget(widgets, COPY_PREV_WORD, this::copyPrevWord);</span>
<span class="line-modified">3491         addBuiltinWidget(widgets, COPY_REGION_AS_KILL, this::copyRegionAsKill);</span>
<span class="line-modified">3492         addBuiltinWidget(widgets, DELETE_CHAR, this::deleteChar);</span>
<span class="line-modified">3493         addBuiltinWidget(widgets, DELETE_CHAR_OR_LIST, this::deleteCharOrList);</span>
<span class="line-modified">3494         addBuiltinWidget(widgets, DELETE_WORD, this::deleteWord);</span>
<span class="line-modified">3495         addBuiltinWidget(widgets, DIGIT_ARGUMENT, this::digitArgument);</span>
<span class="line-modified">3496         addBuiltinWidget(widgets, DO_LOWERCASE_VERSION, this::doLowercaseVersion);</span>
<span class="line-modified">3497         addBuiltinWidget(widgets, DOWN_CASE_WORD, this::downCaseWord);</span>
<span class="line-modified">3498         addBuiltinWidget(widgets, DOWN_LINE, this::downLine);</span>
<span class="line-modified">3499         addBuiltinWidget(widgets, DOWN_LINE_OR_HISTORY, this::downLineOrHistory);</span>
<span class="line-modified">3500         addBuiltinWidget(widgets, DOWN_LINE_OR_SEARCH, this::downLineOrSearch);</span>
<span class="line-modified">3501         addBuiltinWidget(widgets, DOWN_HISTORY, this::downHistory);</span>
<span class="line-modified">3502         addBuiltinWidget(widgets, EMACS_EDITING_MODE, this::emacsEditingMode);</span>
<span class="line-modified">3503         addBuiltinWidget(widgets, EMACS_BACKWARD_WORD, this::emacsBackwardWord);</span>
<span class="line-modified">3504         addBuiltinWidget(widgets, EMACS_FORWARD_WORD, this::emacsForwardWord);</span>
<span class="line-modified">3505         addBuiltinWidget(widgets, END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);</span>
<span class="line-modified">3506         addBuiltinWidget(widgets, END_OF_HISTORY, this::endOfHistory);</span>
<span class="line-modified">3507         addBuiltinWidget(widgets, END_OF_LINE, this::endOfLine);</span>
<span class="line-modified">3508         addBuiltinWidget(widgets, END_OF_LINE_HIST, this::endOfLineHist);</span>
<span class="line-modified">3509         addBuiltinWidget(widgets, EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);</span>
<span class="line-modified">3510         addBuiltinWidget(widgets, EXPAND_HISTORY, this::expandHistory);</span>
<span class="line-modified">3511         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE, this::expandOrComplete);</span>
<span class="line-modified">3512         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);</span>
<span class="line-modified">3513         addBuiltinWidget(widgets, EXPAND_WORD, this::expandWord);</span>
<span class="line-modified">3514         addBuiltinWidget(widgets, FRESH_LINE, this::freshLine);</span>
<span class="line-modified">3515         addBuiltinWidget(widgets, FORWARD_CHAR, this::forwardChar);</span>
<span class="line-modified">3516         addBuiltinWidget(widgets, FORWARD_WORD, this::forwardWord);</span>
<span class="line-modified">3517         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);</span>
<span class="line-modified">3518         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);</span>
<span class="line-modified">3519         addBuiltinWidget(widgets, HISTORY_SEARCH_BACKWARD, this::historySearchBackward);</span>
<span class="line-modified">3520         addBuiltinWidget(widgets, HISTORY_SEARCH_FORWARD, this::historySearchForward);</span>
<span class="line-modified">3521         addBuiltinWidget(widgets, INSERT_CLOSE_CURLY, this::insertCloseCurly);</span>
<span class="line-modified">3522         addBuiltinWidget(widgets, INSERT_CLOSE_PAREN, this::insertCloseParen);</span>
<span class="line-modified">3523         addBuiltinWidget(widgets, INSERT_CLOSE_SQUARE, this::insertCloseSquare);</span>
<span class="line-modified">3524         addBuiltinWidget(widgets, INSERT_COMMENT, this::insertComment);</span>
<span class="line-modified">3525         addBuiltinWidget(widgets, KILL_BUFFER, this::killBuffer);</span>
<span class="line-modified">3526         addBuiltinWidget(widgets, KILL_LINE, this::killLine);</span>
<span class="line-modified">3527         addBuiltinWidget(widgets, KILL_REGION, this::killRegion);</span>
<span class="line-modified">3528         addBuiltinWidget(widgets, KILL_WHOLE_LINE, this::killWholeLine);</span>
<span class="line-modified">3529         addBuiltinWidget(widgets, KILL_WORD, this::killWord);</span>
<span class="line-modified">3530         addBuiltinWidget(widgets, LIST_CHOICES, this::listChoices);</span>
<span class="line-modified">3531         addBuiltinWidget(widgets, MENU_COMPLETE, this::menuComplete);</span>
<span class="line-modified">3532         addBuiltinWidget(widgets, MENU_EXPAND_OR_COMPLETE, this::menuExpandOrComplete);</span>
<span class="line-modified">3533         addBuiltinWidget(widgets, NEG_ARGUMENT, this::negArgument);</span>
<span class="line-modified">3534         addBuiltinWidget(widgets, OVERWRITE_MODE, this::overwriteMode);</span>
<span class="line-modified">3535 //        addBuiltinWidget(widgets, QUIT, this::quit);</span>
<span class="line-modified">3536         addBuiltinWidget(widgets, QUOTED_INSERT, this::quotedInsert);</span>
<span class="line-modified">3537         addBuiltinWidget(widgets, REDISPLAY, this::redisplay);</span>
<span class="line-modified">3538         addBuiltinWidget(widgets, REDRAW_LINE, this::redrawLine);</span>
<span class="line-modified">3539         addBuiltinWidget(widgets, REDO, this::redo);</span>
<span class="line-modified">3540         addBuiltinWidget(widgets, SELF_INSERT, this::selfInsert);</span>
<span class="line-modified">3541         addBuiltinWidget(widgets, SELF_INSERT_UNMETA, this::selfInsertUnmeta);</span>
<span class="line-modified">3542         addBuiltinWidget(widgets, SEND_BREAK, this::sendBreak);</span>
<span class="line-modified">3543         addBuiltinWidget(widgets, SET_MARK_COMMAND, this::setMarkCommand);</span>
<span class="line-modified">3544         addBuiltinWidget(widgets, TRANSPOSE_CHARS, this::transposeChars);</span>
<span class="line-modified">3545         addBuiltinWidget(widgets, TRANSPOSE_WORDS, this::transposeWords);</span>
<span class="line-modified">3546         addBuiltinWidget(widgets, UNDEFINED_KEY, this::undefinedKey);</span>
<span class="line-modified">3547         addBuiltinWidget(widgets, UNIVERSAL_ARGUMENT, this::universalArgument);</span>
<span class="line-modified">3548         addBuiltinWidget(widgets, UNDO, this::undo);</span>
<span class="line-modified">3549         addBuiltinWidget(widgets, UP_CASE_WORD, this::upCaseWord);</span>
<span class="line-modified">3550         addBuiltinWidget(widgets, UP_HISTORY, this::upHistory);</span>
<span class="line-modified">3551         addBuiltinWidget(widgets, UP_LINE, this::upLine);</span>
<span class="line-modified">3552         addBuiltinWidget(widgets, UP_LINE_OR_HISTORY, this::upLineOrHistory);</span>
<span class="line-modified">3553         addBuiltinWidget(widgets, UP_LINE_OR_SEARCH, this::upLineOrSearch);</span>
<span class="line-modified">3554         addBuiltinWidget(widgets, VI_ADD_EOL, this::viAddEol);</span>
<span class="line-modified">3555         addBuiltinWidget(widgets, VI_ADD_NEXT, this::viAddNext);</span>
<span class="line-modified">3556         addBuiltinWidget(widgets, VI_BACKWARD_CHAR, this::viBackwardChar);</span>
<span class="line-modified">3557         addBuiltinWidget(widgets, VI_BACKWARD_DELETE_CHAR, this::viBackwardDeleteChar);</span>
<span class="line-modified">3558         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD, this::viBackwardBlankWord);</span>
<span class="line-modified">3559         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD_END, this::viBackwardBlankWordEnd);</span>
<span class="line-modified">3560         addBuiltinWidget(widgets, VI_BACKWARD_KILL_WORD, this::viBackwardKillWord);</span>
<span class="line-modified">3561         addBuiltinWidget(widgets, VI_BACKWARD_WORD, this::viBackwardWord);</span>
<span class="line-modified">3562         addBuiltinWidget(widgets, VI_BACKWARD_WORD_END, this::viBackwardWordEnd);</span>
<span class="line-modified">3563         addBuiltinWidget(widgets, VI_BEGINNING_OF_LINE, this::viBeginningOfLine);</span>
<span class="line-modified">3564         addBuiltinWidget(widgets, VI_CMD_MODE, this::viCmdMode);</span>
<span class="line-modified">3565         addBuiltinWidget(widgets, VI_DIGIT_OR_BEGINNING_OF_LINE, this::viDigitOrBeginningOfLine);</span>
<span class="line-modified">3566         addBuiltinWidget(widgets, VI_DOWN_LINE_OR_HISTORY, this::viDownLineOrHistory);</span>
<span class="line-modified">3567         addBuiltinWidget(widgets, VI_CHANGE, this::viChange);</span>
<span class="line-modified">3568         addBuiltinWidget(widgets, VI_CHANGE_EOL, this::viChangeEol);</span>
<span class="line-modified">3569         addBuiltinWidget(widgets, VI_CHANGE_WHOLE_LINE, this::viChangeWholeLine);</span>
<span class="line-modified">3570         addBuiltinWidget(widgets, VI_DELETE_CHAR, this::viDeleteChar);</span>
<span class="line-modified">3571         addBuiltinWidget(widgets, VI_DELETE, this::viDelete);</span>
<span class="line-modified">3572         addBuiltinWidget(widgets, VI_END_OF_LINE, this::viEndOfLine);</span>
<span class="line-modified">3573         addBuiltinWidget(widgets, VI_KILL_EOL, this::viKillEol);</span>
<span class="line-modified">3574         addBuiltinWidget(widgets, VI_FIRST_NON_BLANK, this::viFirstNonBlank);</span>
<span class="line-modified">3575         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR, this::viFindNextChar);</span>
<span class="line-modified">3576         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR_SKIP, this::viFindNextCharSkip);</span>
<span class="line-modified">3577         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR, this::viFindPrevChar);</span>
<span class="line-modified">3578         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR_SKIP, this::viFindPrevCharSkip);</span>
<span class="line-modified">3579         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD, this::viForwardBlankWord);</span>
<span class="line-modified">3580         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD_END, this::viForwardBlankWordEnd);</span>
<span class="line-modified">3581         addBuiltinWidget(widgets, VI_FORWARD_CHAR, this::viForwardChar);</span>
<span class="line-modified">3582         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">3583         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">3584         addBuiltinWidget(widgets, VI_FORWARD_WORD_END, this::viForwardWordEnd);</span>
<span class="line-modified">3585         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_BACKWARD, this::viHistorySearchBackward);</span>
<span class="line-modified">3586         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_FORWARD, this::viHistorySearchForward);</span>
<span class="line-modified">3587         addBuiltinWidget(widgets, VI_INSERT, this::viInsert);</span>
<span class="line-modified">3588         addBuiltinWidget(widgets, VI_INSERT_BOL, this::viInsertBol);</span>
<span class="line-modified">3589         addBuiltinWidget(widgets, VI_INSERT_COMMENT, this::viInsertComment);</span>
<span class="line-modified">3590         addBuiltinWidget(widgets, VI_JOIN, this::viJoin);</span>
<span class="line-modified">3591         addBuiltinWidget(widgets, VI_KILL_LINE, this::viKillWholeLine);</span>
<span class="line-modified">3592         addBuiltinWidget(widgets, VI_MATCH_BRACKET, this::viMatchBracket);</span>
<span class="line-modified">3593         addBuiltinWidget(widgets, VI_OPEN_LINE_ABOVE, this::viOpenLineAbove);</span>
<span class="line-modified">3594         addBuiltinWidget(widgets, VI_OPEN_LINE_BELOW, this::viOpenLineBelow);</span>
<span class="line-modified">3595         addBuiltinWidget(widgets, VI_PUT_AFTER, this::viPutAfter);</span>
<span class="line-modified">3596         addBuiltinWidget(widgets, VI_PUT_BEFORE, this::viPutBefore);</span>
<span class="line-modified">3597         addBuiltinWidget(widgets, VI_REPEAT_FIND, this::viRepeatFind);</span>
<span class="line-modified">3598         addBuiltinWidget(widgets, VI_REPEAT_SEARCH, this::viRepeatSearch);</span>
<span class="line-modified">3599         addBuiltinWidget(widgets, VI_REPLACE_CHARS, this::viReplaceChars);</span>
<span class="line-modified">3600         addBuiltinWidget(widgets, VI_REV_REPEAT_FIND, this::viRevRepeatFind);</span>
<span class="line-modified">3601         addBuiltinWidget(widgets, VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);</span>
<span class="line-modified">3602         addBuiltinWidget(widgets, VI_SWAP_CASE, this::viSwapCase);</span>
<span class="line-modified">3603         addBuiltinWidget(widgets, VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);</span>
<span class="line-modified">3604         addBuiltinWidget(widgets, VI_YANK, this::viYankTo);</span>
<span class="line-modified">3605         addBuiltinWidget(widgets, VI_YANK_WHOLE_LINE, this::viYankWholeLine);</span>
<span class="line-modified">3606         addBuiltinWidget(widgets, VISUAL_LINE_MODE, this::visualLineMode);</span>
<span class="line-modified">3607         addBuiltinWidget(widgets, VISUAL_MODE, this::visualMode);</span>
<span class="line-modified">3608         addBuiltinWidget(widgets, WHAT_CURSOR_POSITION, this::whatCursorPosition);</span>
<span class="line-modified">3609         addBuiltinWidget(widgets, YANK, this::yank);</span>
<span class="line-modified">3610         addBuiltinWidget(widgets, YANK_POP, this::yankPop);</span>
<span class="line-modified">3611         addBuiltinWidget(widgets, MOUSE, this::mouse);</span>
<span class="line-added">3612         addBuiltinWidget(widgets, BEGIN_PASTE, this::beginPaste);</span>
<span class="line-added">3613         addBuiltinWidget(widgets, FOCUS_IN, this::focusIn);</span>
<span class="line-added">3614         addBuiltinWidget(widgets, FOCUS_OUT, this::focusOut);</span>
3615         return widgets;
3616     }
3617 
<span class="line-added">3618     private void addBuiltinWidget(Map&lt;String, Widget&gt; widgets, String name, Widget widget) {</span>
<span class="line-added">3619         widgets.put(name, namedWidget(name, widget));</span>
<span class="line-added">3620     }</span>
<span class="line-added">3621 </span>
<span class="line-added">3622     private Widget namedWidget(String name, Widget widget) {</span>
<span class="line-added">3623         return new Widget() {</span>
<span class="line-added">3624             @Override</span>
<span class="line-added">3625             public String toString() {</span>
<span class="line-added">3626                 return name;</span>
<span class="line-added">3627             }</span>
<span class="line-added">3628             @Override</span>
<span class="line-added">3629             public boolean apply() {</span>
<span class="line-added">3630                 return widget.apply();</span>
<span class="line-added">3631             }</span>
<span class="line-added">3632         };</span>
<span class="line-added">3633     }</span>
<span class="line-added">3634 </span>
3635     public boolean redisplay() {
3636         redisplay(true);
3637         return true;
3638     }
3639 
<span class="line-modified">3640     protected void redisplay(boolean flush) {</span>
<span class="line-modified">3641         try {</span>
<span class="line-modified">3642             lock.lock();</span>


3643 
<span class="line-modified">3644             if (skipRedisplay) {</span>
<span class="line-modified">3645                 skipRedisplay = false;</span>
<span class="line-modified">3646                 return;</span>
<span class="line-modified">3647             }</span>
3648 
<span class="line-modified">3649             Status status = Status.getStatus(terminal, false);</span>
<span class="line-modified">3650             if (status != null) {</span>
<span class="line-added">3651                 status.redraw();</span>
<span class="line-added">3652             }</span>
3653 
<span class="line-modified">3654             if (size.getRows() &gt; 0 &amp;&amp; size.getRows() &lt; MIN_ROWS) {</span>
<span class="line-modified">3655                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>

3656 
<span class="line-modified">3657                 sb.append(prompt);</span>
<span class="line-modified">3658                 concat(getHighlightedBuffer(buf.toString()).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-modified">3659                 AttributedString full = sb.toAttributedString();</span>
<span class="line-modified">3660 </span>
<span class="line-modified">3661                 sb.setLength(0);</span>
<span class="line-added">3662                 sb.append(prompt);</span>
<span class="line-added">3663                 String line = buf.upToCursor();</span>
<span class="line-added">3664                 if (maskingCallback != null) {</span>
<span class="line-added">3665                     line = maskingCallback.display(line);</span>
<span class="line-added">3666                 }</span>
<span class="line-added">3667 </span>
<span class="line-added">3668                 concat(new AttributedString(line).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-added">3669                 AttributedString toCursor = sb.toAttributedString();</span>
<span class="line-added">3670 </span>
<span class="line-added">3671                 int w = WCWidth.wcwidth(&#39;\u2026&#39;);</span>
<span class="line-added">3672                 int width = size.getColumns();</span>
<span class="line-added">3673                 int cursor = toCursor.columnLength();</span>
<span class="line-added">3674                 int inc = width / 2 + 1;</span>
<span class="line-added">3675                 while (cursor &lt;= smallTerminalOffset + w) {</span>
<span class="line-added">3676                     smallTerminalOffset -= inc;</span>
<span class="line-added">3677                 }</span>
<span class="line-added">3678                 while (cursor &gt;= smallTerminalOffset + width - w) {</span>
<span class="line-added">3679                     smallTerminalOffset += inc;</span>
<span class="line-added">3680                 }</span>
<span class="line-added">3681                 if (smallTerminalOffset &gt; 0) {</span>
<span class="line-added">3682                     sb.setLength(0);</span>
<span class="line-added">3683                     sb.append(&quot;\u2026&quot;);</span>
<span class="line-added">3684                     sb.append(full.columnSubSequence(smallTerminalOffset + w, Integer.MAX_VALUE));</span>
<span class="line-added">3685                     full = sb.toAttributedString();</span>
<span class="line-added">3686                 }</span>
<span class="line-added">3687                 int length = full.columnLength();</span>
<span class="line-added">3688                 if (length &gt;= smallTerminalOffset + width) {</span>
<span class="line-added">3689                     sb.setLength(0);</span>
<span class="line-added">3690                     sb.append(full.columnSubSequence(0, width - w));</span>
<span class="line-added">3691                     sb.append(&quot;\u2026&quot;);</span>
<span class="line-added">3692                     full = sb.toAttributedString();</span>
<span class="line-added">3693                 }</span>
<span class="line-added">3694 </span>
<span class="line-added">3695                 display.update(Collections.singletonList(full), cursor - smallTerminalOffset, flush);</span>
<span class="line-added">3696                 return;</span>
3697             }
3698 
<span class="line-modified">3699             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">3700             AttributedString full = getDisplayedBufferWithPrompts(secondaryPrompts);</span>
3701 
<span class="line-modified">3702             List&lt;AttributedString&gt; newLines;</span>
<span class="line-modified">3703             if (size.getColumns() &lt;= 0) {</span>
<span class="line-modified">3704                 newLines = new ArrayList&lt;&gt;();</span>
<span class="line-modified">3705                 newLines.add(full);</span>
<span class="line-modified">3706             } else {</span>
<span class="line-modified">3707                 newLines = full.columnSplitLength(size.getColumns(), true, display.delayLineWrap());</span>
3708             }
<span class="line-modified">3709 </span>
<span class="line-modified">3710             List&lt;AttributedString&gt; rightPromptLines;</span>
<span class="line-added">3711             if (rightPrompt.length() == 0 || size.getColumns() &lt;= 0) {</span>
<span class="line-added">3712                 rightPromptLines = new ArrayList&lt;&gt;();</span>
<span class="line-added">3713             } else {</span>
<span class="line-added">3714                 rightPromptLines = rightPrompt.columnSplitLength(size.getColumns());</span>
3715             }
<span class="line-modified">3716             while (newLines.size() &lt; rightPromptLines.size()) {</span>
<span class="line-modified">3717                 newLines.add(new AttributedString(&quot;&quot;));</span>



3718             }
<span class="line-modified">3719             for (int i = 0; i &lt; rightPromptLines.size(); i++) {</span>
<span class="line-modified">3720                 AttributedString line = rightPromptLines.get(i);</span>
<span class="line-modified">3721                 newLines.set(i, addRightPrompt(line, newLines.get(i)));</span>



3722             }
3723 
<span class="line-modified">3724             int cursorPos = -1;</span>
<span class="line-modified">3725             int cursorNewLinesId = -1;</span>
<span class="line-modified">3726             int cursorColPos = -1;</span>
<span class="line-modified">3727             if (size.getColumns() &gt; 0) {</span>
<span class="line-modified">3728                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>
<span class="line-modified">3729                 sb.append(prompt);</span>
<span class="line-modified">3730                 String buffer = buf.upToCursor();</span>
<span class="line-modified">3731                 if (maskingCallback != null) {</span>
<span class="line-modified">3732                     buffer = maskingCallback.display(buffer);</span>
<span class="line-modified">3733                 }</span>
<span class="line-modified">3734                 sb.append(insertSecondaryPrompts(new AttributedString(buffer), secondaryPrompts, false));</span>
<span class="line-modified">3735                 List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());</span>
<span class="line-modified">3736                 if (!promptLines.isEmpty()) {</span>
<span class="line-modified">3737                     cursorNewLinesId = promptLines.size() - 1;</span>
<span class="line-modified">3738                     cursorColPos = promptLines.get(promptLines.size() - 1).columnLength();</span>
<span class="line-modified">3739                     cursorPos = size.cursorPos(cursorNewLinesId, cursorColPos);</span>
<span class="line-modified">3740                 }</span>



















3741             }
<span class="line-modified">3742 </span>
<span class="line-modified">3743             List&lt;AttributedString&gt; newLinesToDisplay = new ArrayList&lt;&gt;();</span>
<span class="line-modified">3744             int displaySize = size.getRows() - (status != null ? status.size() : 0);</span>
<span class="line-modified">3745             if (newLines.size() &gt; displaySize &amp;&amp; !isTerminalDumb()) {</span>
<span class="line-modified">3746                 StringBuilder sb = new StringBuilder(&quot;&gt;....&quot;);</span>
<span class="line-added">3747                 // blanks are needed when displaying command completion candidate list</span>
<span class="line-added">3748                 for (int i = sb.toString().length(); i &lt; size.getColumns(); i++) {</span>
<span class="line-added">3749                     sb.append(&quot; &quot;);</span>
<span class="line-added">3750                 }</span>
<span class="line-added">3751                 AttributedString partialCommandInfo = new AttributedString(sb.toString());</span>
<span class="line-added">3752                 int lineId = newLines.size() - displaySize + 1;</span>
<span class="line-added">3753                 int endId = displaySize;</span>
<span class="line-added">3754                 int startId = 1;</span>
<span class="line-added">3755                 if (lineId  &gt; cursorNewLinesId) {</span>
<span class="line-added">3756                     lineId = cursorNewLinesId;</span>
<span class="line-added">3757                     endId = displaySize - 1;</span>
<span class="line-added">3758                     startId = 0;</span>
<span class="line-added">3759                 } else {</span>
<span class="line-added">3760                     newLinesToDisplay.add(partialCommandInfo);</span>
<span class="line-added">3761                 }</span>
<span class="line-added">3762                 int cursorRowPos = 0;</span>
<span class="line-added">3763                 for (int i = startId; i &lt; endId; i++) {</span>
<span class="line-added">3764                     if (cursorNewLinesId == lineId) {</span>
<span class="line-added">3765                         cursorRowPos = i;</span>
<span class="line-added">3766                     }</span>
<span class="line-added">3767                     newLinesToDisplay.add(newLines.get(lineId++));</span>
<span class="line-added">3768                 }</span>
<span class="line-added">3769                 if (startId == 0) {</span>
<span class="line-added">3770                     newLinesToDisplay.add(partialCommandInfo);</span>
<span class="line-added">3771                 }</span>
<span class="line-added">3772                 cursorPos = size.cursorPos(cursorRowPos, cursorColPos);</span>
<span class="line-added">3773             } else {</span>
<span class="line-added">3774                 newLinesToDisplay = newLines;</span>
3775             }
<span class="line-added">3776             display.update(newLinesToDisplay, cursorPos, flush);</span>
<span class="line-added">3777         } finally {</span>
<span class="line-added">3778             lock.unlock();</span>
3779         }


3780     }
3781 
3782     private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
3783         if (lines.size() &gt; 1) {
3784             for (int i = 0; i &lt; lines.size() - 1; i++) {
3785                 sb.append(lines.get(i));
3786                 sb.style(sb.style().inverse());
3787                 sb.append(&quot;\\n&quot;);
3788                 sb.style(sb.style().inverseOff());
3789             }
3790         }
3791         sb.append(lines.get(lines.size() - 1));
3792     }
3793 
3794     /**
3795      * Compute the full string to be displayed with the left, right and secondary prompts
3796      * @param secondaryPrompts a list to store the secondary prompts
3797      * @return the displayed string including the buffer, left prompts and the help below
3798      */
3799     public AttributedString getDisplayedBufferWithPrompts(List&lt;AttributedString&gt; secondaryPrompts) {
</pre>
<hr />
<pre>
3824                                                  String message, int line) {
3825         ArrayList&lt;AttributedString&gt; parts = new ArrayList&lt;&gt;();
3826         boolean isHidden = false;
3827         int padPartIndex = -1;
3828         StringBuilder padPartString = null;
3829         StringBuilder sb = new StringBuilder();
3830         // Add &quot;%{&quot; to avoid special case for end of string.
3831         pattern = pattern + &quot;%{&quot;;
3832         int plen = pattern.length();
3833         int padChar = -1;
3834         int padPos = -1;
3835         int cols = 0;
3836         for (int i = 0; i &lt; plen; ) {
3837             char ch = pattern.charAt(i++);
3838             if (ch == &#39;%&#39; &amp;&amp; i &lt; plen) {
3839                 int count = 0;
3840                 boolean countSeen = false;
3841                 decode: while (true) {
3842                     ch = pattern.charAt(i++);
3843                     switch (ch) {
<span class="line-modified">3844                         case &#39;{&#39;:</span>
<span class="line-modified">3845                         case &#39;}&#39;:</span>
<span class="line-modified">3846                             String str = sb.toString();</span>
<span class="line-modified">3847                             AttributedString astr;</span>
<span class="line-modified">3848                             if (!isHidden) {</span>
<span class="line-modified">3849                                 astr = AttributedString.fromAnsi(str);</span>
<span class="line-modified">3850                                 cols += astr.columnLength();</span>
<span class="line-modified">3851                             } else {</span>
<span class="line-modified">3852                                 astr = new AttributedString(str, AttributedStyle.HIDDEN);</span>
<span class="line-modified">3853                             }</span>
<span class="line-modified">3854                             if (padPartIndex == parts.size()) {</span>
<span class="line-modified">3855                                 padPartString = sb;</span>
<span class="line-modified">3856                                 if (i &lt; plen) {</span>
<span class="line-modified">3857                                     sb = new StringBuilder();</span>
<span class="line-modified">3858                                 }</span>
<span class="line-modified">3859                             } else {</span>
<span class="line-modified">3860                                 sb.setLength(0);</span>
<span class="line-modified">3861                             }</span>
<span class="line-modified">3862                             parts.add(astr);</span>
<span class="line-modified">3863                             isHidden = ch == &#39;{&#39;;</span>
3864                             break decode;
3865                         case &#39;%&#39;:
3866                             sb.append(ch);
3867                             break decode;
3868                         case &#39;N&#39;:
3869                             sb.append(getInt(LINE_OFFSET, 0) + line);
3870                             break decode;
3871                         case &#39;M&#39;:
3872                             if (message != null)
3873                                 sb.append(message);
3874                             break decode;
3875                         case &#39;P&#39;:
3876                             if (countSeen &amp;&amp; count &gt;= 0)
3877                                 padToWidth = count;
3878                             if (i &lt; plen) {
3879                                 padChar = pattern.charAt(i++);
3880                                 // FIXME check surrogate
3881                             }
3882                             padPos = sb.length();
3883                             padPartIndex = parts.size();
</pre>
<hr />
<pre>
4216                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),
4217                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),
4218                     typoMatcher(wdi, errors, caseInsensitive)
4219             );
4220             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4221         }
4222         // Find matching candidates
4223         Map&lt;String, List&lt;Candidate&gt;&gt; matching = Collections.emptyMap();
4224         for (Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4225                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt; matcher : matchers) {
4226             matching = matcher.apply(sortedCandidates);
4227             if (!matching.isEmpty()) {
4228                 break;
4229             }
4230         }
4231 
4232         // If we have no matches, bail out
4233         if (matching.isEmpty()) {
4234             return false;
4235         }
<span class="line-added">4236         size.copy(terminal.getSize());</span>
<span class="line-added">4237         try {</span>
<span class="line-added">4238             // If we only need to display the list, do it now</span>
<span class="line-added">4239             if (lst == CompletionType.List) {</span>
<span class="line-added">4240                 List&lt;Candidate&gt; possible = matching.entrySet().stream()</span>
<span class="line-added">4241                         .flatMap(e -&gt; e.getValue().stream())</span>
<span class="line-added">4242                         .collect(Collectors.toList());</span>
<span class="line-added">4243                 doList(possible, line.word(), false, line::escape);</span>
<span class="line-added">4244                 return !possible.isEmpty();</span>
<span class="line-added">4245             }</span>
<span class="line-added">4246 </span>
<span class="line-added">4247             // Check if there&#39;s a single possible match</span>
<span class="line-added">4248             Candidate completion = null;</span>
<span class="line-added">4249             // If there&#39;s a single possible completion</span>
<span class="line-added">4250             if (matching.size() == 1) {</span>
<span class="line-added">4251                 completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-added">4252                         .findFirst().orElse(null);</span>
<span class="line-added">4253             }</span>
<span class="line-added">4254             // Or if RECOGNIZE_EXACT is set, try to find an exact match</span>
<span class="line-added">4255             else if (isSet(Option.RECOGNIZE_EXACT)) {</span>
<span class="line-added">4256                 completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-added">4257                         .filter(Candidate::complete)</span>
<span class="line-added">4258                         .filter(c -&gt; exact.test(c.value()))</span>
<span class="line-added">4259                         .findFirst().orElse(null);</span>
<span class="line-added">4260             }</span>
<span class="line-added">4261             // Complete and exit</span>
<span class="line-added">4262             if (completion != null &amp;&amp; !completion.value().isEmpty()) {</span>
<span class="line-added">4263                 if (prefix) {</span>
<span class="line-added">4264                     buf.backspace(line.rawWordCursor());</span>
<span class="line-added">4265                 } else {</span>
<span class="line-added">4266                     buf.move(line.rawWordLength() - line.rawWordCursor());</span>
<span class="line-added">4267                     buf.backspace(line.rawWordLength());</span>
<span class="line-added">4268                 }</span>
<span class="line-added">4269                 buf.write(line.escape(completion.value(), completion.complete()));</span>
<span class="line-added">4270                 if (completion.complete()) {</span>
<span class="line-added">4271                     if (buf.currChar() != &#39; &#39;) {</span>
<span class="line-added">4272                         buf.write(&quot; &quot;);</span>
<span class="line-added">4273                     } else {</span>
<span class="line-added">4274                         buf.move(1);</span>
<span class="line-added">4275                     }</span>
<span class="line-added">4276                 }</span>
<span class="line-added">4277                 if (completion.suffix() != null) {</span>
<span class="line-added">4278                     redisplay();</span>
<span class="line-added">4279                     Binding op = readBinding(getKeys());</span>
<span class="line-added">4280                     if (op != null) {</span>
<span class="line-added">4281                         String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);</span>
<span class="line-added">4282                         String ref = op instanceof Reference ? ((Reference) op).name() : null;</span>
<span class="line-added">4283                         if (SELF_INSERT.equals(ref) &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0</span>
<span class="line-added">4284                                 || ACCEPT_LINE.equals(ref)) {</span>
<span class="line-added">4285                             buf.backspace(completion.suffix().length());</span>
<span class="line-added">4286                             if (getLastBinding().charAt(0) != &#39; &#39;) {</span>
<span class="line-added">4287                                 buf.write(&#39; &#39;);</span>
<span class="line-added">4288                             }</span>
<span class="line-added">4289                         }</span>
<span class="line-added">4290                         pushBackBinding(true);</span>
<span class="line-added">4291                     }</span>
<span class="line-added">4292                 }</span>
<span class="line-added">4293                 return true;</span>
<span class="line-added">4294             }</span>
4295 


4296             List&lt;Candidate&gt; possible = matching.entrySet().stream()
4297                     .flatMap(e -&gt; e.getValue().stream())
4298                     .collect(Collectors.toList());
<span class="line-modified">4299 </span>
<span class="line-modified">4300             if (useMenu) {</span>
<span class="line-modified">4301                 buf.move(line.word().length() - line.wordCursor());</span>
<span class="line-modified">4302                 buf.backspace(line.word().length());</span>
<span class="line-modified">4303                 doMenu(possible, line.word(), line::escape);</span>
<span class="line-modified">4304                 return true;</span>
<span class="line-modified">4305             }</span>
<span class="line-modified">4306 </span>
<span class="line-modified">4307             // Find current word and move to end</span>
<span class="line-modified">4308             String current;</span>










4309             if (prefix) {
<span class="line-modified">4310                 current = line.word().substring(0, line.wordCursor());</span>
4311             } else {
<span class="line-added">4312                 current = line.word();</span>
4313                 buf.move(line.rawWordLength() - line.rawWordCursor());

4314             }
<span class="line-modified">4315             // Now, we need to find the unambiguous completion</span>
<span class="line-modified">4316             // TODO: need to find common suffix</span>
<span class="line-modified">4317             String commonPrefix = null;</span>
<span class="line-modified">4318             for (String key : matching.keySet()) {</span>
<span class="line-modified">4319                 commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);</span>


4320             }
<span class="line-modified">4321             boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);</span>
<span class="line-modified">4322 </span>
<span class="line-modified">4323             if (hasUnambiguous) {</span>
<span class="line-modified">4324                 buf.backspace(line.rawWordLength());</span>
<span class="line-modified">4325                 buf.write(line.escape(commonPrefix, false));</span>
<span class="line-modified">4326                 current = commonPrefix;</span>
<span class="line-modified">4327                 if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))</span>
<span class="line-modified">4328                         || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {</span>
<span class="line-modified">4329                     if (!nextBindingIsComplete()) {</span>
<span class="line-modified">4330                         return true;</span>


4331                     }

4332                 }
4333             }
<span class="line-modified">4334             if (isSet(Option.AUTO_LIST)) {</span>
<span class="line-modified">4335                 if (!doList(possible, current, true, line::escape)) {</span>



































4336                     return true;
4337                 }
4338             }
<span class="line-modified">4339             if (isSet(Option.AUTO_MENU)) {</span>
<span class="line-modified">4340                 buf.backspace(current.length());</span>
<span class="line-modified">4341                 doMenu(possible, line.word(), line::escape);</span>

4342             }
<span class="line-added">4343             return true;</span>
<span class="line-added">4344         } finally {</span>
<span class="line-added">4345             size.copy(terminal.getBufferSize());</span>
4346         }





4347     }
4348 
4349     private CompletingParsedLine wrap(ParsedLine line) {
4350         if (line instanceof CompletingParsedLine) {
4351             return (CompletingParsedLine) line;
4352         } else {
4353             return new CompletingParsedLine() {
4354                 public String word() {
4355                     return line.word();
4356                 }
4357                 public int wordCursor() {
4358                     return line.wordCursor();
4359                 }
4360                 public int wordIndex() {
4361                     return line.wordIndex();
4362                 }
4363                 public List&lt;String&gt; words() {
4364                     return line.words();
4365                 }
4366                 public String line() {
</pre>
<hr />
<pre>
4706             }
4707             redisplay();
4708         }
4709         return false;
4710     }
4711 
4712     protected boolean doList(List&lt;Candidate&gt; possible, String completed, boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4713         // If we list only and if there&#39;s a big
4714         // number of items, we should ask the user
4715         // for confirmation, display the list
4716         // and redraw the line at the bottom
4717         mergeCandidates(possible);
4718         AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4719         int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4720         PostResult postResult = computePost(possible, null, null, completed);
4721         int lines = postResult.lines;
4722         int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
4723         if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
4724                 || lines &gt;= size.getRows() - promptLines) {
4725             // prompt
<span class="line-modified">4726             post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see all &quot; + possible.size()</span>
4727                     + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);
4728             redisplay(true);
4729             int c = readCharacter();
4730             if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {
4731                 post = null;
4732                 return false;
4733             }
4734         }
4735 
4736         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4737         StringBuilder sb = new StringBuilder();
4738         while (true) {
4739             String current = completed + sb.toString();
4740             List&lt;Candidate&gt; cands;
4741             if (sb.length() &gt; 0) {
4742                 cands = possible.stream()
4743                         .filter(c -&gt; caseInsensitive
4744                                     ? c.value().toLowerCase().startsWith(current.toLowerCase())
4745                                     : c.value().startsWith(current))
4746                         .sorted(getCandidateComparator(caseInsensitive, current))
</pre>
<hr />
<pre>
4758                     post = null;
4759                     int oldCursor = buf.cursor();
4760                     buf.cursor(buf.length());
4761                     redisplay(false);
4762                     buf.cursor(oldCursor);
4763                     println();
4764                     List&lt;AttributedString&gt; ls = postResult.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
4765                     Display d = new Display(terminal, false);
4766                     d.resize(size.getRows(), size.getColumns());
4767                     d.update(ls, -1);
4768                     redrawLine();
4769                     return new AttributedString(&quot;&quot;);
4770                 }
4771                 return pr.post;
4772             };
4773             if (!runLoop) {
4774                 return false;
4775             }
4776             redisplay();
4777             // TODO: use a different keyMap ?
<span class="line-modified">4778             Binding b = doReadBinding(getKeys(), null);</span>
4779             if (b instanceof Reference) {
4780                 String name = ((Reference) b).name();
4781                 if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
4782                     if (sb.length() == 0) {
4783                         pushBackBinding();
4784                         post = null;
4785                         return false;
4786                     } else {
4787                         sb.setLength(sb.length() - 1);
4788                         buf.backspace();
4789                     }
4790                 } else if (SELF_INSERT.equals(name)) {
4791                     sb.append(getLastBinding());
4792                     buf.write(getLastBinding());
4793                     if (cands.isEmpty()) {
4794                         post = null;
4795                         return false;
4796                     }
4797                 } else if (&quot;\t&quot;.equals(getLastBinding())) {
4798                     if (cands.size() == 1 || sb.length() &gt; 0) {
</pre>
<hr />
<pre>
4903                         len += wcwidth.apply(cand.descr());
4904                         len += DESC_SUFFIX.length();
4905                     }
4906                     maxWidth = Math.max(maxWidth, len);
4907                 }
4908             }
4909         }
4910         // Build columns
4911         AttributedStringBuilder sb = new AttributedStringBuilder();
4912         for (Object list : items) {
4913             toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, out);
4914         }
4915         if (sb.length() &gt; 0 &amp;&amp; sb.charAt(sb.length() - 1) == &#39;\n&#39;) {
4916             sb.setLength(sb.length() - 1);
4917         }
4918         return new PostResult(sb.toAttributedString(), out[0], out[1]);
4919     }
4920 
4921     @SuppressWarnings(&quot;unchecked&quot;)
4922     protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {
<span class="line-modified">4923         if (maxWidth &lt;= 0 || width &lt;= 0) {</span>
4924             return;
4925         }
4926         // This is a group
4927         if (items instanceof String) {
4928             sb.style(getCompletionStyleGroup())
4929                     .append((String) items)
4930                     .style(AttributedStyle.DEFAULT)
4931                     .append(&quot;\n&quot;);
4932             out[0]++;
4933         }
4934         // This is a Candidate list
4935         else if (items instanceof List) {
4936             List&lt;Candidate&gt; candidates = (List&lt;Candidate&gt;) items;
4937             maxWidth = Math.min(width, maxWidth);
4938             int c = width / maxWidth;
4939             while (c &gt; 1 &amp;&amp; c * maxWidth + (c - 1) * MARGIN_BETWEEN_COLUMNS &gt;= width) {
4940                 c--;
4941             }
4942             int lines = (candidates.size() + c - 1) / c;
4943             // Try to minimize the number of columns for the given number of rows
</pre>
<hr />
<pre>
5157             while (buf.atChar(end) != 0 &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
5158                 end++;
5159             }
5160             start = end;
5161             for (int count = -this.count; count &gt; 0; --count) {
5162                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5163                     start--;
5164                 }
5165                 start--;
5166             }
5167         } else {
5168             start = buf.cursor();
5169             while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5170                 start--;
5171             }
5172             end = start;
5173             while (count-- &gt; 0) {
5174                 while (end &lt; buf.length() &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
5175                     end++;
5176                 }
<span class="line-modified">5177                 if (end &lt; buf.length()) {</span>
<span class="line-added">5178                     end++;</span>
<span class="line-added">5179                 }</span>
5180             }
5181         }
5182         String killed = buf.substring(start, end);
5183         buf.cursor(start);
5184         buf.delete(end - start);
5185         killRing.add(killed);
5186         return true;
5187     }
5188 
5189     /**
5190      * Kill the buffer ahead of the current cursor position.
5191      *
5192      * @return true if successful
5193      */
5194     public boolean killLine() {
5195         if (count &lt; 0) {
5196             return callNeg(this::backwardKillLine);
5197         }
5198         if (buf.cursor() == buf.length()) {
5199             return false;
</pre>
<hr />
<pre>
5362             int currentLine = promptLines.size() - 1;
5363             int wantedLine = Math.max(0, Math.min(currentLine + event.getY() - cursor.getY(), secondaryPrompts.size()));
5364             int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();
5365             int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();
5366             int adjust = pl1 - pl0;
5367             buf.moveXY(event.getX() - cursor.getX() - adjust, event.getY() - cursor.getY());
5368         }
5369         return true;
5370     }
5371 
5372     public boolean beginPaste() {
5373         final Object SELF_INSERT = new Object();
5374         final Object END_PASTE = new Object();
5375         KeyMap&lt;Object&gt; keyMap = new KeyMap&lt;&gt;();
5376         keyMap.setUnicode(SELF_INSERT);
5377         keyMap.setNomatch(SELF_INSERT);
5378         keyMap.setAmbiguousTimeout(0);
5379         keyMap.bind(END_PASTE, BRACKETED_PASTE_END);
5380         StringBuilder sb = new StringBuilder();
5381         while (true) {
<span class="line-modified">5382             Object b = doReadBinding(keyMap, null);</span>
5383             if (b == END_PASTE) {
5384                 break;
5385             }
5386             String s = getLastBinding();
5387             if (&quot;\r&quot;.equals(s)) {
5388                 s = &quot;\n&quot;;
5389             }
5390             sb.append(s);
5391         }
5392         regionActive = RegionType.PASTE;
5393         regionMark = getBuffer().cursor();
5394         getBuffer().write(sb);
5395         return true;
5396     }
5397 
5398     public boolean focusIn() {
5399         return false;
5400     }
5401 
5402     public boolean focusOut() {
5403         return false;
5404     }
5405 
5406     /**
5407      * Clean the used display
5408      * @return &lt;code&gt;true&lt;/code&gt;
5409      */
5410     public boolean clear() {
5411         display.update(Collections.emptyList(), 0);
5412         return true;
5413     }
5414 
5415     /**
5416      * Clear the screen by issuing the ANSI &quot;clear screen&quot; code.
5417      * @return &lt;code&gt;true&lt;/code&gt;
5418      */
5419     public boolean clearScreen() {
5420         if (terminal.puts(Capability.clear_screen)) {
<span class="line-added">5421             // ConEMU extended fonts support</span>
<span class="line-added">5422             if (AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType())</span>
<span class="line-added">5423                     &amp;&amp; !Boolean.getBoolean(&quot;org.jline.terminal.conemu.disable-activate&quot;)) {</span>
<span class="line-added">5424                 terminal.writer().write(&quot;\u001b[9999E&quot;);</span>
<span class="line-added">5425             }</span>
5426             Status status = Status.getStatus(terminal, false);
5427             if (status != null) {
5428                 status.reset();
5429             }
5430             redrawLine();
5431         } else {
5432             println();
5433         }
5434         return true;
5435     }
5436 
5437     /**
5438      * Issue an audible keyboard bell.
5439      * @return &lt;code&gt;true&lt;/code&gt;
5440      */
5441     public boolean beep() {
5442         BellType bell_preference = BellType.AUDIBLE;
5443         switch (getString(BELL_STYLE, DEFAULT_BELL_STYLE).toLowerCase()) {
5444             case &quot;none&quot;:
5445             case &quot;off&quot;:
</pre>
<hr />
<pre>
5537         keyMaps.put(VIOPP, viOpp());
5538         keyMaps.put(VISUAL, visual());
5539         keyMaps.put(SAFE, safe());
5540         if (getBoolean(BIND_TTY_SPECIAL_CHARS, true)) {
5541             Attributes attr = terminal.getAttributes();
5542             bindConsoleChars(keyMaps.get(EMACS), attr);
5543             bindConsoleChars(keyMaps.get(VIINS), attr);
5544         }
5545         // Put default
5546         for (KeyMap&lt;Binding&gt; keyMap : keyMaps.values()) {
5547             keyMap.setUnicode(new Reference(SELF_INSERT));
5548             keyMap.setAmbiguousTimeout(getLong(AMBIGUOUS_BINDING, DEFAULT_AMBIGUOUS_BINDING));
5549         }
5550         // By default, link main to emacs
5551         keyMaps.put(MAIN, keyMaps.get(EMACS));
5552         return keyMaps;
5553     }
5554 
5555     public KeyMap&lt;Binding&gt; emacs() {
5556         KeyMap&lt;Binding&gt; emacs = new KeyMap&lt;&gt;();
<span class="line-added">5557         bindKeys(emacs);</span>
5558         bind(emacs, SET_MARK_COMMAND,                       ctrl(&#39;@&#39;));
5559         bind(emacs, BEGINNING_OF_LINE,                      ctrl(&#39;A&#39;));
5560         bind(emacs, BACKWARD_CHAR,                          ctrl(&#39;B&#39;));
5561         bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl(&#39;D&#39;));
5562         bind(emacs, END_OF_LINE,                            ctrl(&#39;E&#39;));
5563         bind(emacs, FORWARD_CHAR,                           ctrl(&#39;F&#39;));
5564         bind(emacs, SEND_BREAK,                             ctrl(&#39;G&#39;));
5565         bind(emacs, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5566         bind(emacs, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5567         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5568         bind(emacs, KILL_LINE,                              ctrl(&#39;K&#39;));
5569         bind(emacs, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5570         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5571         bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));
<span class="line-added">5572         bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl(&#39;O&#39;));</span>
5573         bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
5574         bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5575         bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5576         bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5577         bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5578         bind(emacs, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5579         bind(emacs, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5580         bind(emacs, YANK,                                   ctrl(&#39;Y&#39;));
5581         bind(emacs, CHARACTER_SEARCH,                       ctrl(&#39;]&#39;));
5582         bind(emacs, UNDO,                                   ctrl(&#39;_&#39;));
5583         bind(emacs, SELF_INSERT,                            range(&quot; -~&quot;));
5584         bind(emacs, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5585         bind(emacs, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5586         bind(emacs, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5587         bind(emacs, BACKWARD_DELETE_CHAR,                   del());
5588         bind(emacs, VI_MATCH_BRACKET,                       translate(&quot;^X^B&quot;));
5589         bind(emacs, SEND_BREAK,                             translate(&quot;^X^G&quot;));
5590         bind(emacs, VI_FIND_NEXT_CHAR,                      translate(&quot;^X^F&quot;));
5591         bind(emacs, VI_JOIN,                                translate(&quot;^X^J&quot;));
5592         bind(emacs, KILL_BUFFER,                            translate(&quot;^X^K&quot;));
</pre>
<hr />
<pre>
5596         bind(emacs, UNDO,                                   translate(&quot;^X^U&quot;));
5597         bind(emacs, VI_CMD_MODE,                            translate(&quot;^X^V&quot;));
5598         bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(&quot;^X^X&quot;));
5599         bind(emacs, DO_LOWERCASE_VERSION,                   translate(&quot;^XA-^XZ&quot;));
5600         bind(emacs, WHAT_CURSOR_POSITION,                   translate(&quot;^X=&quot;));
5601         bind(emacs, KILL_LINE,                              translate(&quot;^X^?&quot;));
5602         bind(emacs, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5603         bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5604         bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5605         bind(emacs, COMPLETE_WORD,                          alt(esc()));
5606         bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5607         bind(emacs, COPY_PREV_WORD,                         alt(ctrl(&#39;_&#39;)));
5608         bind(emacs, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5609         bind(emacs, NEG_ARGUMENT,                           alt(&#39;-&#39;));
5610         bind(emacs, DIGIT_ARGUMENT,                         range(&quot;\\E0-\\E9&quot;));
5611         bind(emacs, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5612         bind(emacs, LIST_CHOICES,                           alt(&#39;=&#39;));
5613         bind(emacs, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5614         bind(emacs, LIST_CHOICES,                           alt(&#39;?&#39;));
5615         bind(emacs, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
<span class="line-added">5616         bind(emacs, ACCEPT_AND_HOLD,                        alt(&#39;a&#39;));</span>
5617         bind(emacs, BACKWARD_WORD,                          alt(&#39;b&#39;));
5618         bind(emacs, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5619         bind(emacs, KILL_WORD,                              alt(&#39;d&#39;));
5620         bind(emacs, KILL_WORD,                              translate(&quot;^[[3;5~&quot;)); // ctrl-delete
5621         bind(emacs, FORWARD_WORD,                           alt(&#39;f&#39;));
5622         bind(emacs, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5623         bind(emacs, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5624         bind(emacs, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5625         bind(emacs, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5626         bind(emacs, UP_CASE_WORD,                           alt(&#39;u&#39;));
5627         bind(emacs, YANK_POP,                               alt(&#39;y&#39;));
5628         bind(emacs, BACKWARD_KILL_WORD,                     alt(del()));
5629         bindArrowKeys(emacs);
5630         bind(emacs, FORWARD_WORD,                           translate(&quot;^[[1;5C&quot;)); // ctrl-left
5631         bind(emacs, BACKWARD_WORD,                          translate(&quot;^[[1;5D&quot;)); // ctrl-right
5632         bind(emacs, FORWARD_WORD,                           alt(key(Capability.key_right)));
5633         bind(emacs, BACKWARD_WORD,                          alt(key(Capability.key_left)));
5634         bind(emacs, FORWARD_WORD,                           alt(translate(&quot;^[[C&quot;)));
5635         bind(emacs, BACKWARD_WORD,                          alt(translate(&quot;^[[D&quot;)));
5636         return emacs;
5637     }
5638 
5639     public KeyMap&lt;Binding&gt; viInsertion() {
5640         KeyMap&lt;Binding&gt; viins = new KeyMap&lt;&gt;();
<span class="line-added">5641         bindKeys(viins);</span>
5642         bind(viins, SELF_INSERT,                            range(&quot;^@-^_&quot;));
5643         bind(viins, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5644         bind(viins, SEND_BREAK,                             ctrl(&#39;G&#39;));
5645         bind(viins, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5646         bind(viins, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5647         bind(viins, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5648         bind(viins, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5649         bind(viins, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5650         bind(viins, MENU_COMPLETE,                          ctrl(&#39;N&#39;));
5651         bind(viins, REVERSE_MENU_COMPLETE,                  ctrl(&#39;P&#39;));
5652         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5653         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5654         bind(viins, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5655         bind(viins, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5656         bind(viins, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5657         bind(viins, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5658         bind(viins, YANK,                                   ctrl(&#39;Y&#39;));
5659         bind(viins, VI_CMD_MODE,                            ctrl(&#39;[&#39;));
5660         bind(viins, UNDO,                                   ctrl(&#39;_&#39;));
5661         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
</pre>
<hr />
<pre>
5821         bind(viOpp, VI_CMD_MODE,                esc());
5822         return viOpp;
5823     }
5824 
5825     private void bind(KeyMap&lt;Binding&gt; map, String widget, Iterable&lt;? extends CharSequence&gt; keySeqs) {
5826         map.bind(new Reference(widget), keySeqs);
5827     }
5828 
5829     private void bind(KeyMap&lt;Binding&gt; map, String widget, CharSequence... keySeqs) {
5830         map.bind(new Reference(widget), keySeqs);
5831     }
5832 
5833     private void bind(KeyMap&lt;Binding&gt; map, Widget widget, CharSequence... keySeqs) {
5834         map.bind(widget, keySeqs);
5835     }
5836 
5837     private String key(Capability capability) {
5838         return KeyMap.key(terminal, capability);
5839     }
5840 
<span class="line-added">5841     private void bindKeys(KeyMap&lt;Binding&gt; emacs) {</span>
<span class="line-added">5842         Widget beep = namedWidget(&quot;beep&quot;, this::beep);</span>
<span class="line-added">5843         Stream.of(Capability.values())</span>
<span class="line-added">5844                 .filter(c -&gt; c.name().startsWith(&quot;key_&quot;))</span>
<span class="line-added">5845                 .map(this::key)</span>
<span class="line-added">5846                 .forEach(k -&gt; bind(emacs, beep, k));</span>
<span class="line-added">5847     }</span>
<span class="line-added">5848 </span>
5849     private void bindArrowKeys(KeyMap&lt;Binding&gt; map) {
5850         bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));
5851         bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));
5852         bind(map, BACKWARD_CHAR,        key(Capability.key_left));
5853         bind(map, FORWARD_CHAR,         key(Capability.key_right));
5854         bind(map, BEGINNING_OF_LINE,    key(Capability.key_home));
5855         bind(map, END_OF_LINE,          key(Capability.key_end));
5856         bind(map, DELETE_CHAR,          key(Capability.key_dc));
5857         bind(map, KILL_WHOLE_LINE,      key(Capability.key_dl));
5858         bind(map, OVERWRITE_MODE,       key(Capability.key_ic));
5859         bind(map, MOUSE,                key(Capability.key_mouse));
5860         bind(map, BEGIN_PASTE,          BRACKETED_PASTE_BEGIN);
5861         bind(map, FOCUS_IN,             FOCUS_IN_SEQ);
5862         bind(map, FOCUS_OUT,            FOCUS_OUT_SEQ);
5863     }
5864 
5865     /**
5866      * Bind special chars defined by the terminal instead of
5867      * the default bindings
5868      */
</pre>
</td>
</tr>
</table>
<center><a href="KillRing.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ReaderUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
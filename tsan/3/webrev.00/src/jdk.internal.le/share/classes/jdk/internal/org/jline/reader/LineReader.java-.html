<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/LineReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.reader;
 10 
 11 import java.io.InputStream;
 12 import java.util.Map;
 13 import java.util.function.IntConsumer;
 14 
 15 import jdk.internal.org.jline.keymap.KeyMap;
 16 import jdk.internal.org.jline.terminal.MouseEvent;
 17 import jdk.internal.org.jline.terminal.Terminal;
 18 import jdk.internal.org.jline.utils.AttributedString;
 19 
 20 /** Read lines from the console, with input editing.
 21  *
 22  * &lt;h3&gt;Thread safety&lt;/h3&gt;
 23  * The &lt;code&gt;LineReader&lt;/code&gt; implementations are not thread safe,
 24  * thus you should not attempt to use a single reader in several threads.
 25  * Any attempt to call one of the &lt;code&gt;readLine&lt;/code&gt; call while one is
 26  * already executing in a different thread will immediately result in an
 27  * &lt;code&gt;IllegalStateException&lt;/code&gt; being thrown.  Other calls may lead to
 28  * unknown behaviors. There is one exception though: users are allowed to call
 29  * {@link #printAbove(String)} or {@link #printAbove(AttributedString)} at
 30  * any time to allow text to be printed above the current prompt.
 31  *
 32  * &lt;h3&gt;Prompt strings&lt;/h3&gt;
 33  * It is traditional for an interactive console-based program
 34  * to print a short prompt string to signal that the user is expected
 35  * to type a command.  JLine supports 3 kinds of prompt string:
 36  * &lt;ul&gt;
 37  * &lt;li&gt; The normal prompt at the start (left) of the initial line of a command.
 38  * &lt;li&gt; An optional right prompt at the right border of the initial line.
 39  * &lt;li&gt; A start (left) prompt for continuation lines.  I.e. the lines
 40  * after the first line of a multi-line command.
 41  * &lt;/ul&gt;
 42  * &lt;p&gt;
 43  * All of these are specified with prompt templates,
 44  * which are similar to {@code printf} format strings,
 45  * using the character {@code &#39;%&#39;} to indicate special functionality.
 46  * &lt;/p&gt;
 47  * The pattern may include ANSI escapes.
 48  * It may include these template markers:
 49  * &lt;dl&gt;
 50  * &lt;dt&gt;{@code %N}&lt;/dt&gt;
 51  * &lt;dd&gt;A line number. This is the sum of {@code getLineNumber()}
 52  *   and a counter starting with 1 for the first continuation line.
 53  * &lt;/dd&gt;
 54  * &lt;dt&gt;{@code %M}&lt;/dt&gt;
 55  * &lt;dd&gt;A short word explaining what is &quot;missing&quot;. This is supplied from
 56  * the {@link EOFError#getMissing()} method, if provided.
 57  * Defaults to an empty string.
 58  * &lt;/dd&gt;
 59  * &lt;dt&gt;{@code %}&lt;var&gt;n&lt;/var&gt;{@code P}&lt;var&gt;c&lt;/var&gt;&lt;/dt&gt;
 60  * &lt;dd&gt;Insert padding at this possion, repeating the following
 61  *   character &lt;var&gt;c&lt;/var&gt; as needed to bring the total prompt
 62  *   column width as specified by the digits &lt;var&gt;n&lt;/var&gt;.
 63  * &lt;/dd&gt;
 64  * &lt;dt&gt;{@code %P}&lt;var&gt;c&lt;/var&gt;&lt;/dt&gt;
 65  * &lt;dd&gt;As before, but use width from the initial prompt.
 66  * &lt;/dd&gt;
 67  * &lt;dt&gt;{@code %%}&lt;/dt&gt;
 68  * &lt;dd&gt;A literal {@code &#39;%&#39;}.
 69  * &lt;/dd&gt;
 70  * &lt;dt&gt;&lt;code&gt;%{&lt;/code&gt;&lt;/dt&gt;&lt;dt&gt;&lt;code&gt;%}&lt;/code&gt;&lt;/dt&gt;
 71  * &lt;dd&gt;Text between a &lt;code&gt;%{&lt;/code&gt;...&lt;code&gt;%}&lt;/code&gt; pair is printed as
 72  * part of a prompt, but not interpreted by JLine
 73  * (except that {@code &#39;%&#39;}-escapes are processed).  The text is assumed
 74  * to take zero columns (not move the cursor).  If it changes the style,
 75  * you&#39;re responsible for changing it back.  Standard ANSI escape sequences
 76  * do not need to be within a &lt;code&gt;%{&lt;/code&gt;...&lt;code&gt;%}&lt;/code&gt; pair
 77  * (though can be) since JLine knows how to deal with them.  However,
 78  * these delimiters are needed for unusual non-standard escape sequences.
 79  * &lt;/dd&gt;
 80  * &lt;/dl&gt;
 81  */
 82 
 83 public interface LineReader {
 84 
 85     /**
 86      * System property that can be set to avoid a warning being logged
 87      * when using a Parser which does not return {@link CompletingParsedLine} objects.
 88      */
 89     String PROP_SUPPORT_PARSEDLINE = &quot;org.jline.reader.support.parsedline&quot;;
 90 
 91     //
 92     // Widget names
 93     //
 94     String CALLBACK_INIT = &quot;callback-init&quot;;
 95     String CALLBACK_FINISH = &quot;callback-finish&quot;;
 96     String CALLBACK_KEYMAP = &quot;callback-keymap&quot;;
 97 
 98     String ACCEPT_LINE = &quot;accept-line&quot;;
 99     String ARGUMENT_BASE = &quot;argument-base&quot;;
100     String BACKWARD_CHAR = &quot;backward-char&quot;;
101     String BACKWARD_DELETE_CHAR = &quot;backward-delete-char&quot;;
102     String BACKWARD_DELETE_WORD = &quot;backward-delete-word&quot;;
103     String BACKWARD_KILL_LINE = &quot;backward-kill-line&quot;;
104     String BACKWARD_KILL_WORD = &quot;backward-kill-word&quot;;
105     String BACKWARD_WORD = &quot;backward-word&quot;;
106     String BEEP = &quot;beep&quot;;
107     String BEGINNING_OF_BUFFER_OR_HISTORY = &quot;beginning-of-buffer-or-history&quot;;
108     String BEGINNING_OF_HISTORY = &quot;beginning-of-history&quot;;
109     String BEGINNING_OF_LINE = &quot;beginning-of-line&quot;;
110     String BEGINNING_OF_LINE_HIST = &quot;beginning-of-line-hist&quot;;
111     String CAPITALIZE_WORD = &quot;capitalize-word&quot;;
112     String CHARACTER_SEARCH = &quot;character-search&quot;;
113     String CHARACTER_SEARCH_BACKWARD = &quot;character-search-backward&quot;;
114     String CLEAR = &quot;clear&quot;;
115     String CLEAR_SCREEN = &quot;clear-screen&quot;;
116     String COMPLETE_PREFIX = &quot;complete-prefix&quot;;
117     String COMPLETE_WORD = &quot;complete-word&quot;;
118     String COPY_PREV_WORD = &quot;copy-prev-word&quot;;
119     String COPY_REGION_AS_KILL = &quot;copy-region-as-kill&quot;;
120     String DELETE_CHAR = &quot;delete-char&quot;;
121     String DELETE_CHAR_OR_LIST = &quot;delete-char-or-list&quot;;
122     String DELETE_WORD = &quot;delete-word&quot;;
123     String DIGIT_ARGUMENT = &quot;digit-argument&quot;;
124     String DO_LOWERCASE_VERSION = &quot;do-lowercase-version&quot;;
125     String DOWN_CASE_WORD = &quot;down-case-word&quot;;
126     String DOWN_HISTORY = &quot;down-history&quot;;
127     String DOWN_LINE = &quot;down-line&quot;;
128     String DOWN_LINE_OR_HISTORY = &quot;down-line-or-history&quot;;
129     String DOWN_LINE_OR_SEARCH = &quot;down-line-or-search&quot;;
130     String EMACS_BACKWARD_WORD = &quot;emacs-backward-word&quot;;
131     String EMACS_EDITING_MODE = &quot;emacs-editing-mode&quot;;
132     String EMACS_FORWARD_WORD = &quot;emacs-forward-word&quot;;
133     String END_OF_BUFFER_OR_HISTORY = &quot;end-of-buffer-or-history&quot;;
134     String END_OF_HISTORY = &quot;end-of-history&quot;;
135     String END_OF_LINE = &quot;end-of-line&quot;;
136     String END_OF_LINE_HIST = &quot;end-of-line-hist&quot;;
137     String EXCHANGE_POINT_AND_MARK = &quot;exchange-point-and-mark&quot;;
138     String EXECUTE_NAMED_CMD = &quot;execute-named-cmd&quot;;
139     String EXPAND_HISTORY = &quot;expand-history&quot;;
140     String EXPAND_OR_COMPLETE = &quot;expand-or-complete&quot;;
141     String EXPAND_OR_COMPLETE_PREFIX = &quot;expand-or-complete-prefix&quot;;
142     String EXPAND_WORD = &quot;expand-word&quot;;
143     String FRESH_LINE = &quot;fresh-line&quot;;
144     String FORWARD_CHAR = &quot;forward-char&quot;;
145     String FORWARD_WORD = &quot;forward-word&quot;;
146     String HISTORY_BEGINNING_SEARCH_BACKWARD = &quot;history-beginning-search-backward&quot;;
147     String HISTORY_BEGINNING_SEARCH_FORWARD = &quot;history-beginning-search-forward&quot;;
148     String HISTORY_INCREMENTAL_PATTERN_SEARCH_BACKWARD = &quot;history-incremental-pattern-search-backward&quot;;
149     String HISTORY_INCREMENTAL_PATTERN_SEARCH_FORWARD = &quot;history-incremental-pattern-search-forward&quot;;
150     String HISTORY_INCREMENTAL_SEARCH_BACKWARD = &quot;history-incremental-search-backward&quot;;
151     String HISTORY_INCREMENTAL_SEARCH_FORWARD = &quot;history-incremental-search-forward&quot;;
152     String HISTORY_SEARCH_BACKWARD = &quot;history-search-backward&quot;;
153     String HISTORY_SEARCH_FORWARD = &quot;history-search-forward&quot;;
154     String INSERT_CLOSE_CURLY = &quot;insert-close-curly&quot;;
155     String INSERT_CLOSE_PAREN = &quot;insert-close-paren&quot;;
156     String INSERT_CLOSE_SQUARE = &quot;insert-close-square&quot;;
157     String INFER_NEXT_HISTORY = &quot;infer-next-history&quot;;
158     String INSERT_COMMENT = &quot;insert-comment&quot;;
159     String INSERT_LAST_WORD = &quot;insert-last-word&quot;;
160     String KILL_BUFFER = &quot;kill-buffer&quot;;
161     String KILL_LINE = &quot;kill-line&quot;;
162     String KILL_REGION = &quot;kill-region&quot;;
163     String KILL_WHOLE_LINE = &quot;kill-whole-line&quot;;
164     String KILL_WORD = &quot;kill-word&quot;;
165     String LIST_CHOICES = &quot;list-choices&quot;;
166     String LIST_EXPAND = &quot;list-expand&quot;;
167     String MAGIC_SPACE = &quot;magic-space&quot;;
168     String MENU_EXPAND_OR_COMPLETE = &quot;menu-expand-or-complete&quot;;
169     String MENU_COMPLETE = &quot;menu-complete&quot;;
170     String MENU_SELECT = &quot;menu-select&quot;;
171     String NEG_ARGUMENT = &quot;neg-argument&quot;;
172     String OVERWRITE_MODE = &quot;overwrite-mode&quot;;
173     String PUT_REPLACE_SELECTION = &quot;put-replace-selection&quot;;
174     String QUOTED_INSERT = &quot;quoted-insert&quot;;
175     String READ_COMMAND = &quot;read-command&quot;;
176     String RECURSIVE_EDIT = &quot;recursive-edit&quot;;
177     String REDISPLAY = &quot;redisplay&quot;;
178     String REDRAW_LINE = &quot;redraw-line&quot;;
179     String REDO = &quot;redo&quot;;
180     String REVERSE_MENU_COMPLETE = &quot;reverse-menu-complete&quot;;
181     String SELF_INSERT = &quot;self-insert&quot;;
182     String SELF_INSERT_UNMETA = &quot;self-insert-unmeta&quot;;
183     String SEND_BREAK = &quot;abort&quot;;
184     String SET_LOCAL_HISTORY = &quot;set-local-history&quot;;
185     String SET_MARK_COMMAND = &quot;set-mark-command&quot;;
186     String SPELL_WORD = &quot;spell-word&quot;;
187     String SPLIT_UNDO = &quot;split-undo&quot;;
188     String TRANSPOSE_CHARS = &quot;transpose-chars&quot;;
189     String TRANSPOSE_WORDS = &quot;transpose-words&quot;;
190     String UNDEFINED_KEY = &quot;undefined-key&quot;;
191     String UNDO = &quot;undo&quot;;
192     String UNIVERSAL_ARGUMENT = &quot;universal-argument&quot;;
193     String UP_CASE_WORD = &quot;up-case-word&quot;;
194     String UP_HISTORY = &quot;up-history&quot;;
195     String UP_LINE = &quot;up-line&quot;;
196     String UP_LINE_OR_HISTORY = &quot;up-line-or-history&quot;;
197     String UP_LINE_OR_SEARCH = &quot;up-line-or-search&quot;;
198     String VI_ADD_EOL = &quot;vi-add-eol&quot;;
199     String VI_ADD_NEXT = &quot;vi-add-next&quot;;
200     String VI_BACKWARD_BLANK_WORD = &quot;vi-backward-blank-word&quot;;
201     String VI_BACKWARD_BLANK_WORD_END = &quot;vi-backward-blank-word-end&quot;;
202     String VI_BACKWARD_CHAR = &quot;vi-backward-char&quot;;
203     String VI_BACKWARD_DELETE_CHAR = &quot;vi-backward-delete-char&quot;;
204     String VI_BACKWARD_KILL_WORD = &quot;vi-backward-kill-word&quot;;
205     String VI_BACKWARD_WORD = &quot;vi-backward-word&quot;;
206     String VI_BACKWARD_WORD_END = &quot;vi-backward-word-end&quot;;
207     String VI_BEGINNING_OF_LINE = &quot;vi-beginning-of-line&quot;;
208     String VI_CHANGE = &quot;vi-change-to&quot;;
209     String VI_CHANGE_EOL = &quot;vi-change-eol&quot;;
210     String VI_CHANGE_WHOLE_LINE = &quot;vi-change-whole-line&quot;;
211     String VI_CMD_MODE = &quot;vi-cmd-mode&quot;;
212     String VI_DELETE = &quot;vi-delete&quot;;
213     String VI_DELETE_CHAR = &quot;vi-delete-char&quot;;
214     String VI_DIGIT_OR_BEGINNING_OF_LINE = &quot;vi-digit-or-beginning-of-line&quot;;
215     String VI_DOWN_LINE_OR_HISTORY = &quot;vi-down-line-or-history&quot;;
216     String VI_END_OF_LINE = &quot;vi-end-of-line&quot;;
217     String VI_FETCH_HISTORY = &quot;vi-fetch-history&quot;;
218     String VI_FIND_NEXT_CHAR = &quot;vi-find-next-char&quot;;
219     String VI_FIND_NEXT_CHAR_SKIP = &quot;vi-find-next-char-skip&quot;;
220     String VI_FIND_PREV_CHAR = &quot;vi-find-prev-char&quot;;
221     String VI_FIND_PREV_CHAR_SKIP = &quot;vi-find-prev-char-skip&quot;;
222     String VI_FIRST_NON_BLANK = &quot;vi-first-non-blank&quot;;
223     String VI_FORWARD_BLANK_WORD = &quot;vi-forward-blank-word&quot;;
224     String VI_FORWARD_BLANK_WORD_END = &quot;vi-forward-blank-word-end&quot;;
225     String VI_FORWARD_CHAR = &quot;vi-forward-char&quot;;
226     String VI_FORWARD_WORD = &quot;vi-forward-word&quot;;
227     String VI_FORWARD_WORD_END = &quot;vi-forward-word-end&quot;;
228     String VI_GOTO_COLUMN = &quot;vi-goto-column&quot;;
229     String VI_HISTORY_SEARCH_BACKWARD = &quot;vi-history-search-backward&quot;;
230     String VI_HISTORY_SEARCH_FORWARD = &quot;vi-history-search-forward&quot;;
231     String VI_INSERT = &quot;vi-insert&quot;;
232     String VI_INSERT_BOL = &quot;vi-insert-bol&quot;;
233     String VI_INSERT_COMMENT = &quot;vi-insert-comment&quot;;
234     String VI_JOIN = &quot;vi-join&quot;;
235     String VI_KILL_EOL = &quot;vi-kill-eol&quot;;
236     String VI_KILL_LINE = &quot;vi-kill-line&quot;;
237     String VI_MATCH_BRACKET = &quot;vi-match-bracket&quot;;
238     String VI_OPEN_LINE_ABOVE = &quot;vi-open-line-above&quot;;
239     String VI_OPEN_LINE_BELOW = &quot;vi-open-line-below&quot;;
240     String VI_OPER_SWAP_CASE = &quot;vi-oper-swap-case&quot;;
241     String VI_PUT_AFTER = &quot;vi-put-after&quot;;
242     String VI_PUT_BEFORE = &quot;vi-put-before&quot;;
243     String VI_QUOTED_INSERT = &quot;vi-quoted-insert&quot;;
244     String VI_REPEAT_CHANGE = &quot;vi-repeat-change&quot;;
245     String VI_REPEAT_FIND = &quot;vi-repeat-find&quot;;
246     String VI_REPEAT_SEARCH = &quot;vi-repeat-search&quot;;
247     String VI_REPLACE = &quot;vi-replace&quot;;
248     String VI_REPLACE_CHARS = &quot;vi-replace-chars&quot;;
249     String VI_REV_REPEAT_FIND = &quot;vi-rev-repeat-find&quot;;
250     String VI_REV_REPEAT_SEARCH = &quot;vi-rev-repeat-search&quot;;
251     String VI_SET_BUFFER = &quot;vi-set-buffer&quot;;
252     String VI_SUBSTITUTE = &quot;vi-substitute&quot;;
253     String VI_SWAP_CASE = &quot;vi-swap-case&quot;;
254     String VI_UNDO_CHANGE = &quot;vi-undo-change&quot;;
255     String VI_UP_LINE_OR_HISTORY = &quot;vi-up-line-or-history&quot;;
256     String VI_YANK = &quot;vi-yank&quot;;
257     String VI_YANK_EOL = &quot;vi-yank-eol&quot;;
258     String VI_YANK_WHOLE_LINE = &quot;vi-yank-whole-line&quot;;
259     String VISUAL_LINE_MODE = &quot;visual-line-mode&quot;;
260     String VISUAL_MODE = &quot;visual-mode&quot;;
261     String WHAT_CURSOR_POSITION = &quot;what-cursor-position&quot;;
262     String YANK = &quot;yank&quot;;
263     String YANK_POP = &quot;yank-pop&quot;;
264     String MOUSE = &quot;mouse&quot;;
265     String FOCUS_IN = &quot;terminal-focus-in&quot;;
266     String FOCUS_OUT = &quot;terminal-focus-out&quot;;
267 
268     String BEGIN_PASTE = &quot;begin-paste&quot;;
269 
270     //
271     // KeyMap names
272     //
273 
274     String VICMD = &quot;vicmd&quot;;
275     String VIINS = &quot;viins&quot;;
276     String VIOPP = &quot;viopp&quot;;
277     String VISUAL = &quot;visual&quot;;
278     String MAIN = &quot;main&quot;;
279     String EMACS = &quot;emacs&quot;;
280     String SAFE = &quot;.safe&quot;;
281     String MENU = &quot;menu&quot;;
282 
283     //
284     // Variable names
285     //
286 
287     String BIND_TTY_SPECIAL_CHARS = &quot;bind-tty-special-chars&quot;;
288     String COMMENT_BEGIN = &quot;comment-begin&quot;;
289     String BELL_STYLE = &quot;bell-style&quot;;
290     String PREFER_VISIBLE_BELL = &quot;prefer-visible-bell&quot;;
291     String LIST_MAX = &quot;list-max&quot;;
292     String DISABLE_HISTORY = &quot;disable-history&quot;;
293     String DISABLE_COMPLETION = &quot;disable-completion&quot;;
294     String EDITING_MODE = &quot;editing-mode&quot;;
295     String KEYMAP = &quot;keymap&quot;;
296     String BLINK_MATCHING_PAREN = &quot;blink-matching-paren&quot;;
297     String WORDCHARS = &quot;WORDCHARS&quot;;
298     String REMOVE_SUFFIX_CHARS = &quot;REMOVE_SUFFIX_CHARS&quot;;
299     String SEARCH_TERMINATORS = &quot;search-terminators&quot;;
300     String ERRORS = &quot;errors&quot;;
301     /** Property for the &quot;others&quot; group name */
302     String OTHERS_GROUP_NAME = &quot;OTHERS_GROUP_NAME&quot;;
303     /** Property for the &quot;original&quot; group name */
304     String ORIGINAL_GROUP_NAME = &quot;ORIGINAL_GROUP_NAME&quot;;
305     /** Completion style for displaying groups name */
306     String COMPLETION_STYLE_GROUP = &quot;COMPLETION_STYLE_GROUP&quot;;
307     /** Completion style for displaying the current selected item */
308     String COMPLETION_STYLE_SELECTION = &quot;COMPLETION_STYLE_SELECTION&quot;;
309     /** Completion style for displaying the candidate description */
310     String COMPLETION_STYLE_DESCRIPTION = &quot;COMPLETION_STYLE_DESCRIPTION&quot;;
311     /** Completion style for displaying the matching part of candidates */
312     String COMPLETION_STYLE_STARTING = &quot;COMPLETION_STYLE_STARTING&quot;;
313     /**
314      * Set the template for prompts for secondary (continuation) lines.
315      * This is a prompt template as described in the class header.
316      */
317     String SECONDARY_PROMPT_PATTERN = &quot;secondary-prompt-pattern&quot;;
318     /**
319      * When in multiline edit mode, this variable can be used
320      * to offset the line number displayed.
321      */
322     String LINE_OFFSET = &quot;line-offset&quot;;
323 
324     /**
325      * Timeout for ambiguous key sequences.
326      * If the key sequence is ambiguous, i.e. there is a matching
327      * sequence but the sequence is also a prefix for other bindings,
328      * the next key press will be waited for a specified amount of
329      * time.  If the timeout elapses, the matched sequence will be
330      * used.
331      */
332     String AMBIGUOUS_BINDING = &quot;ambiguous-binding&quot;;
333 
334     /**
335      * Columns separated list of patterns that will not be saved in history.
336      */
337     String HISTORY_IGNORE = &quot;history-ignore&quot;;
338 
339     /**
340      * File system history path.
341      */
342     String HISTORY_FILE = &quot;history-file&quot;;
343 
344     /**
345      * Number of history items to keep in memory.
346      */
347     String HISTORY_SIZE = &quot;history-size&quot;;
348 
349     /**
350      * Number of history items to keep in the history file.
351      */
352     String HISTORY_FILE_SIZE = &quot;history-file-size&quot;;
353 
354     Map&lt;String, KeyMap&lt;Binding&gt;&gt; defaultKeyMaps();
355 
356     enum Option {
357         COMPLETE_IN_WORD,
358         DISABLE_EVENT_EXPANSION,
359         HISTORY_VERIFY,
360         HISTORY_IGNORE_SPACE(true),
361         HISTORY_IGNORE_DUPS(true),
362         HISTORY_REDUCE_BLANKS(true),
363         HISTORY_BEEP(true),
364         HISTORY_INCREMENTAL(true),
365         HISTORY_TIMESTAMPED(true),
366         /** when displaying candidates, group them by {@link Candidate#group()} */
367         AUTO_GROUP(true),
368         AUTO_MENU(true),
369         AUTO_LIST(true),
370         RECOGNIZE_EXACT,
371         /** display group name before each group (else display all group names first) */
372         GROUP(true),
373         /** if completion is case insensitive or not */
374         CASE_INSENSITIVE,
375         LIST_AMBIGUOUS,
376         LIST_PACKED,
377         LIST_ROWS_FIRST,
378         GLOB_COMPLETE,
379         MENU_COMPLETE,
380         /** if set and not at start of line before prompt, move to new line */
381         AUTO_FRESH_LINE,
382 
383         /** After writing into the rightmost column, do we immediately
384          * move to the next line (the default)? Or do we wait until
385          * the next character.
386          * If set, an input line that is exactly {@code N*columns} wide will
387          * use {@code N} screen lines; otherwise it will use {@code N+1} lines.
388          * When the cursor position is the right margin of the last line
389          * (i.e. after {@code N*columns} normal characters), if this option
390          * it set, the cursor will be remain on the last line (line {@code N-1},
391          * zero-origin); if unset the cursor will be on the empty next line.
392          * Regardless, for all except the last screen line if the cursor is at
393          * the right margin, it will be shown at the start of the next line.
394          */
395         DELAY_LINE_WRAP,
396         AUTO_PARAM_SLASH(true),
397         AUTO_REMOVE_SLASH(true),
398         /** When hitting the &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt; key at the beginning of the line, insert a tabulation
399          *  instead of completing.  This is mainly useful when {@link #BRACKETED_PASTE} is
400          *  disabled, so that copy/paste of indented text does not trigger completion.
401          */
402         INSERT_TAB,
403         MOUSE,
404         DISABLE_HIGHLIGHTER,
405         BRACKETED_PASTE(true),
406         /**
407          * Instead of printing a new line when the line is read, the entire line
408          * (including the prompt) will be erased, thereby leaving the screen as it
409          * was before the readLine call.
410          */
411         ERASE_LINE_ON_FINISH,
412 
413         /** if history search is fully case insensitive */
414         CASE_INSENSITIVE_SEARCH,
415         ;
416 
417         private final boolean def;
418 
419         Option() {
420             this(false);
421         }
422 
423         Option(boolean def) {
424             this.def = def;
425         }
426 
427         public boolean isDef() {
428             return def;
429         }
430     }
431 
432     enum RegionType {
433         NONE,
434         CHAR,
435         LINE,
436         PASTE
437     }
438 
439     /**
440      * Read the next line and return the contents of the buffer.
441      *
442      * Equivalent to &lt;code&gt;readLine(null, null, null)&lt;/code&gt;.
443      *
444      * @return the line read
445      * @throws UserInterruptException If the call was interrupted by the user.
446      * @throws EndOfFileException     If the end of the input stream was reached.
447      */
448     String readLine() throws UserInterruptException, EndOfFileException;
449 
450     /**
451      * Read the next line with the specified character mask. If null, then
452      * characters will be echoed. If 0, then no characters will be echoed.
453      *
454      * Equivalent to &lt;code&gt;readLine(null, mask, null)&lt;/code&gt;
455      *
456      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
457      * @return          A line that is read from the terminal, can never be null.
458      * @throws UserInterruptException If the call was interrupted by the user.
459      * @throws EndOfFileException     If the end of the input stream was reached.
460      */
461     String readLine(Character mask) throws UserInterruptException, EndOfFileException;
462 
463     /**
464      * Read the next line with the specified prompt.
465      * If null, then the default prompt will be used.
466      *
467      * Equivalent to &lt;code&gt;readLine(prompt, null, null)&lt;/code&gt;
468      *
469      * @param prompt    The prompt to issue to the terminal, may be null.
470      * @return          A line that is read from the terminal, can never be null.
471      * @throws UserInterruptException If the call was interrupted by the user.
472      * @throws EndOfFileException     If the end of the input stream was reached.
473      */
474     String readLine(String prompt) throws UserInterruptException, EndOfFileException;
475 
476     /**
477      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
478      * (without any trailing newlines).
479      *
480      * Equivalent to &lt;code&gt;readLine(prompt, mask, null)&lt;/code&gt;
481      *
482      * @param prompt    The prompt to issue to the terminal, may be null.
483      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
484      * @return          A line that is read from the terminal, can never be null.
485      * @throws UserInterruptException If the call was interrupted by the user.
486      * @throws EndOfFileException     If the end of the input stream was reached.
487      */
488     String readLine(String prompt, Character mask) throws UserInterruptException, EndOfFileException;
489 
490     /**
491      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
492      * (without any trailing newlines).
493      *
494      * Equivalent to &lt;code&gt;readLine(prompt, null, mask, buffer)&lt;/code&gt;
495      *
496      * @param prompt    The prompt to issue to the terminal, may be null.
497      *   This is a template, with optional {@code &#39;%&#39;} escapes, as
498      *   described in the class header.
499      * @param mask      The character mask, may be null.
500      * @param buffer    The default value presented to the user to edit, may be null.
501      * @return          A line that is read from the terminal, can never be null.
502      * @throws UserInterruptException If the call was interrupted by the user.
503      * @throws EndOfFileException     If the end of the input stream was reached.
504      */
505     String readLine(String prompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException;
506 
507     /**
508      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
509      * (without any trailing newlines).
510      *
511      * @param prompt      The prompt to issue to the terminal, may be null.
512      *   This is a template, with optional {@code &#39;%&#39;} escapes, as
513      *   described in the class header.
514      * @param rightPrompt The right prompt
515      *   This is a template, with optional {@code &#39;%&#39;} escapes, as
516      *   described in the class header.
517      * @param mask        The character mask, may be null.
518      * @param buffer      The default value presented to the user to edit, may be null.
519      * @return            A line that is read from the terminal, can never be null.
520      *
521      * @throws UserInterruptException if readLine was interrupted (using Ctrl-C for example)
522      * @throws EndOfFileException if an EOF has been found (using Ctrl-D for example)
523      * @throws java.io.IOError in case of other i/o errors
524      * @throws UserInterruptException If the call was interrupted by the user.
525      * @throws EndOfFileException     If the end of the input stream was reached.
526      */
527     String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException;
528 
529     /**
530      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
531      * (without any trailing newlines).
532      *
533      * @param prompt      The prompt to issue to the terminal, may be null.
534      *   This is a template, with optional {@code &#39;%&#39;} escapes, as
535      *   described in the class header.
536      * @param rightPrompt The right prompt
537      *   This is a template, with optional {@code &#39;%&#39;} escapes, as
538      *   described in the class header.
539      * @param maskingCallback  The {@link MaskingCallback} to use when displaying lines and adding them to the line {@link History}
540      * @param buffer      The default value presented to the user to edit, may be null.
541      * @return            A line that is read from the terminal, can never be null.
542      *
543      * @throws UserInterruptException if readLine was interrupted (using Ctrl-C for example)
544      * @throws EndOfFileException if an EOF has been found (using Ctrl-D for example)
545      * @throws java.io.IOError in case of other i/o errors
546      * @throws UserInterruptException If the call was interrupted by the user.
547      * @throws EndOfFileException     If the end of the input stream was reached.
548      */
549     String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException;
550 
551     /**
552      * Prints a line above the prompt and redraw everything.
553      * If the LineReader is not actually reading a line, the string will simply be printed to the terminal.
554      *
555      * @see #printAbove(AttributedString)
556      * @param str the string to print
557      */
558     void printAbove(String str);
559 
560     /**
561      * Prints a string before the prompt and redraw everything.
562      * If the LineReader is not actually reading a line, the string will simply be printed to the terminal.
563      *
564      * @see #printAbove(String)
565      * @param str the string to print
566      */
567     void printAbove(AttributedString str);
568 
569     /**
570      * Check if a thread is currently in a &lt;code&gt;readLine()&lt;/code&gt; call.
571      *
572      * @return &lt;code&gt;true&lt;/code&gt; if there is an ongoing &lt;code&gt;readLine()&lt;/code&gt; call.
573      */
574     boolean isReading();
575 
576     //
577     // Chainable setters
578     //
579 
580     LineReader variable(String name, Object value);
581 
582     LineReader option(Option option, boolean value);
583 
584     void callWidget(String name);
585 
586     Map&lt;String, Object&gt; getVariables();
587 
588     Object getVariable(String name);
589 
590     void setVariable(String name, Object value);
591 
592     boolean isSet(Option option);
593 
594     void setOpt(Option option);
595 
596     void unsetOpt(Option option);
597 
598     Terminal getTerminal();
599 
600     Map&lt;String, Widget&gt; getWidgets();
601 
602     Map&lt;String, Widget&gt; getBuiltinWidgets();
603 
604     Buffer getBuffer();
605 
606     String getAppName();
607 
608     /**
609      * Push back a key sequence that will be later consumed by the line reader.
610      * This method can be used after reading the cursor position using
611      * {@link Terminal#getCursorPosition(IntConsumer)}.
612      *
613      * @param macro the key sequence to push back
614      * @see Terminal#getCursorPosition(IntConsumer)
615      * @see #readMouseEvent()
616      */
617     void runMacro(String macro);
618 
619     /**
620      * Read a mouse event when the {@link org.jline.utils.InfoCmp.Capability#key_mouse} sequence
621      * has just been read on the input stream.
622      * Compared to {@link Terminal#readMouseEvent()}, this method takes into account keys
623      * that have been pushed back using {@link #runMacro(String)}.
624      *
625      * @return the mouse event
626      * @see #runMacro(String)
627      * @see Terminal#getCursorPosition(IntConsumer)
628      */
629     MouseEvent readMouseEvent();
630 
631     History getHistory();
632 
633     Parser getParser();
634 
635     Highlighter getHighlighter();
636 
637     Expander getExpander();
638 
639     Map&lt;String, KeyMap&lt;Binding&gt;&gt; getKeyMaps();
640 
641     String getKeyMap();
642 
643     boolean setKeyMap(String name);
644 
645     KeyMap&lt;Binding&gt; getKeys();
646 
647     ParsedLine getParsedLine();
648 
649     String getSearchTerm();
650 
651     RegionType getRegionActive();
652 
653     int getRegionMark();
654 
655 }
    </pre>
  </body>
</html>
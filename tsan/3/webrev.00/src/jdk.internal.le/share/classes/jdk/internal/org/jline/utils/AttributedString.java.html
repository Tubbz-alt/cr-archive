<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedString.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.security.InvalidParameterException;
 12 import java.util.Arrays;
 13 import java.util.List;
 14 import java.util.Objects;
 15 import java.util.regex.Matcher;
 16 import java.util.regex.Pattern;
 17 
 18 /**
 19  * Attributed string.
 20  * Instances of this class are immutables.
 21  * Substrings are created without any memory copy.
 22  *
 23  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 24  */
 25 public class AttributedString extends AttributedCharSequence {
 26 
 27     final char[] buffer;
 28     final int[] style;
 29     final int start;
 30     final int end;
 31     public static final AttributedString EMPTY = new AttributedString(&quot;&quot;);
 32     public static final AttributedString NEWLINE = new AttributedString(&quot;\n&quot;);
 33 
 34     public AttributedString(CharSequence str) {
 35         this(str, 0, str.length(), null);
 36     }
 37 
 38     public AttributedString(CharSequence str, int start, int end) {
 39         this(str, start, end, null);
 40     }
 41 
 42     public AttributedString(CharSequence str, AttributedStyle s) {
 43         this(str, 0, str.length(), s);
 44     }
 45 
 46     public AttributedString(CharSequence str, int start, int end, AttributedStyle s) {
 47         if (end &lt; start) {
 48             throw new InvalidParameterException();
 49         }
 50         if (str instanceof AttributedString) {
 51             AttributedString as = (AttributedString) str;
 52             this.buffer = as.buffer;
 53             if (s != null) {
 54                 this.style = as.style.clone();
 55                 for (int i = 0; i &lt; style.length; i++) {
 56                     this.style[i] = (this.style[i] &amp; ~s.getMask()) | s.getStyle();
 57                 }
 58             } else {
 59                 this.style = as.style;
 60             }
 61             this.start = as.start + start;
 62             this.end = as.start + end;
 63         } else if (str instanceof AttributedStringBuilder) {
 64             AttributedStringBuilder asb = (AttributedStringBuilder) str;
 65             AttributedString as = asb.subSequence(start, end);
 66             this.buffer = as.buffer;
 67             this.style = as.style;
 68             if (s != null) {
 69                 for (int i = 0; i &lt; style.length; i++) {
 70                     this.style[i] = (this.style[i] &amp; ~s.getMask()) | s.getStyle();
 71                 }
 72             }
 73             this.start = as.start;
 74             this.end = as.end;
 75         } else {
 76             int l = end - start;
 77             buffer = new char[l];
 78             for (int i = 0; i &lt; l; i++) {
 79                 buffer[i] = str.charAt(start + i);
 80             }
 81             style = new int[l];
 82             if (s != null) {
 83                 Arrays.fill(style, s.getStyle());
 84             }
 85             this.start = 0;
 86             this.end = l;
 87         }
 88     }
 89 
 90     AttributedString(char[] buffer, int[] style, int start, int end) {
 91         this.buffer = buffer;
 92         this.style = style;
 93         this.start = start;
 94         this.end = end;
 95     }
 96 
 97     public static AttributedString fromAnsi(String ansi) {
 98         return fromAnsi(ansi, 0);
 99     }
100 
101     public static AttributedString fromAnsi(String ansi, int tabs) {
102         return fromAnsi(ansi, Arrays.asList(tabs));
103     }
104 
105     public static AttributedString fromAnsi(String ansi, List&lt;Integer&gt; tabs) {
106         if (ansi == null) {
107             return null;
108         }
109         return new AttributedStringBuilder(ansi.length())
110                 .tabs(tabs)
111                 .ansiAppend(ansi)
112                 .toAttributedString();
113     }
114 
115     public static String stripAnsi(String ansi) {
116         if (ansi == null) {
117             return null;
118         }
119         return new AttributedStringBuilder(ansi.length())
120                 .ansiAppend(ansi)
121                 .toString();
122     }
123 
124     @Override
125     protected char[] buffer() {
126         return buffer;
127     }
128 
129     @Override
130     protected int offset() {
131         return start;
132     }
133 
134     @Override
135     public int length() {
136         return end - start;
137     }
138 
139     @Override
140     public AttributedStyle styleAt(int index) {
141         return new AttributedStyle(style[start + index], style[start + index]);
142     }
143 
144     @Override
145     int styleCodeAt(int index) {
146         return style[start + index];
147     }
148 
149     @Override
150     public AttributedString subSequence(int start, int end) {
151         return new AttributedString(this, start, end);
152     }
153 
154     public AttributedString styleMatches(Pattern pattern, AttributedStyle style) {
155         Matcher matcher = pattern.matcher(this);
156         boolean result = matcher.find();
157         if (result) {
158             int[] newstyle = this.style.clone();
159             do {
160                 for (int i = matcher.start(); i &lt; matcher.end(); i++) {
161                     newstyle[this.start + i] = (newstyle[this.start + i] &amp; ~style.getMask()) | style.getStyle();
162                 }
163                 result = matcher.find();
164             } while (result);
165             return new AttributedString(buffer, newstyle, start , end);
166         }
167         return this;
168     }
169 
170     @Override
171     public boolean equals(Object o) {
172         if (this == o) return true;
173         if (o == null || getClass() != o.getClass()) return false;
174         AttributedString that = (AttributedString) o;
175         return end - start == that.end - that.start
176                 &amp;&amp; arrEq(buffer, that.buffer, start, that.start, end - start)
177                 &amp;&amp; arrEq(style, that.style, start, that.start, end - start);
178     }
179 
180     private boolean arrEq(char[] a1, char[] a2, int s1, int s2, int l) {
181         for (int i = 0; i &lt; l; i++) {
182             if (a1[s1+i] != a2[s2+i]) {
183                 return false;
184             }
185         }
186         return true;
187     }
188     private boolean arrEq(int[] a1, int[] a2, int s1, int s2, int l) {
189         for (int i = 0; i &lt; l; i++) {
190             if (a1[s1+i] != a2[s2+i]) {
191                 return false;
192             }
193         }
194         return true;
195     }
196 
197     @Override
198     public int hashCode() {
199         int result = Arrays.hashCode(buffer);
200         result = 31 * result + Arrays.hashCode(style);
201         result = 31 * result + start;
202         result = 31 * result + end;
203         return result;
204     }
205 
206     public static AttributedString join(AttributedString delimiter, AttributedString... elements) {
207         Objects.requireNonNull(delimiter);
208         Objects.requireNonNull(elements);
209         return join(delimiter, Arrays.asList(elements));
210     }
211 
212     public static AttributedString join(AttributedString delimiter, Iterable&lt;AttributedString&gt; elements) {
213         Objects.requireNonNull(elements);
214         AttributedStringBuilder sb = new AttributedStringBuilder();
215         int i = 0;
216         for (AttributedString str : elements) {
217             if (i++ &gt; 0 &amp;&amp; delimiter != null) {
218                 sb.append(delimiter);
219             }
220             sb.append(str);
221         }
222         return sb.toAttributedString();
223     }
224 
225 }
    </pre>
  </body>
</html>
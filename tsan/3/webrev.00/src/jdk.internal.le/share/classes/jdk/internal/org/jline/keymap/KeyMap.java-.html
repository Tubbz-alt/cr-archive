<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/keymap/KeyMap.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.keymap;
 10 
 11 import java.io.IOException;
 12 import java.io.StringWriter;
 13 import java.util.ArrayList;
 14 import java.util.Collection;
 15 import java.util.Comparator;
 16 import java.util.Map;
 17 import java.util.TreeMap;
 18 
 19 import jdk.internal.org.jline.terminal.Terminal;
 20 import jdk.internal.org.jline.utils.Curses;
 21 import jdk.internal.org.jline.utils.InfoCmp.Capability;
 22 
 23 /**
 24  * The KeyMap class contains all bindings from keys to operations.
 25  *
 26  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
 27  * @since 2.6
 28  */
 29 public class KeyMap&lt;T&gt; {
 30 
 31     public static final int KEYMAP_LENGTH = 128;
 32     public static final long DEFAULT_AMBIGUOUS_TIMEOUT = 1000L;
 33 
 34     private Object[] mapping = new Object[KEYMAP_LENGTH];
 35     private T anotherKey = null;
 36     private T unicode;
 37     private T nomatch;
 38     private long ambiguousTimeout = DEFAULT_AMBIGUOUS_TIMEOUT;
 39 
 40     public static String display(String key) {
 41         StringBuilder sb = new StringBuilder();
 42         sb.append(&quot;\&quot;&quot;);
 43         for (int i = 0; i &lt; key.length(); i++) {
 44             char c = key.charAt(i);
 45             if (c &lt; 32) {
 46                 sb.append(&#39;^&#39;);
 47                 sb.append((char) (c + &#39;A&#39; - 1));
 48             } else if (c == 127) {
 49                 sb.append(&quot;^?&quot;);
 50             } else if (c == &#39;^&#39; || c == &#39;\\&#39;) {
 51                 sb.append(&#39;\\&#39;).append(c);
 52             } else if (c &gt;= 128) {
 53                 sb.append(String.format(&quot;\\u%04x&quot;, (int) c));
 54             } else {
 55                 sb.append(c);
 56             }
 57         }
 58         sb.append(&quot;\&quot;&quot;);
 59         return sb.toString();
 60     }
 61 
 62     public static String translate(String str) {
 63         int i;
 64         if (!str.isEmpty()) {
 65             char c = str.charAt(0);
 66             if ((c == &#39;\&#39;&#39; || c == &#39;&quot;&#39;) &amp;&amp; str.charAt(str.length() - 1) == c) {
 67                 str = str.substring(1, str.length() - 1);
 68             }
 69         }
 70         StringBuilder keySeq = new StringBuilder();
 71         for (i = 0; i &lt; str.length(); i++) {
 72             char c = str.charAt(i);
 73             if (c == &#39;\\&#39;) {
 74                 if (++i &gt;= str.length()) {
 75                     break;
 76                 }
 77                 c = str.charAt(i);
 78                 switch (c) {
 79                     case &#39;a&#39;:
 80                         c = 0x07;
 81                         break;
 82                     case &#39;b&#39;:
 83                         c = &#39;\b&#39;;
 84                         break;
 85                     case &#39;d&#39;:
 86                         c = 0x7f;
 87                         break;
 88                     case &#39;e&#39;:
 89                     case &#39;E&#39;:
 90                         c = 0x1b;
 91                         break;
 92                     case &#39;f&#39;:
 93                         c = &#39;\f&#39;;
 94                         break;
 95                     case &#39;n&#39;:
 96                         c = &#39;\n&#39;;
 97                         break;
 98                     case &#39;r&#39;:
 99                         c = &#39;\r&#39;;
100                         break;
101                     case &#39;t&#39;:
102                         c = &#39;\t&#39;;
103                         break;
104                     case &#39;v&#39;:
105                         c = 0x0b;
106                         break;
107                     case &#39;\\&#39;:
108                         c = &#39;\\&#39;;
109                         break;
110                     case &#39;0&#39;:
111                     case &#39;1&#39;:
112                     case &#39;2&#39;:
113                     case &#39;3&#39;:
114                     case &#39;4&#39;:
115                     case &#39;5&#39;:
116                     case &#39;6&#39;:
117                     case &#39;7&#39;:
118                         c = 0;
119                         for (int j = 0; j &lt; 3; j++, i++) {
120                             if (i &gt;= str.length()) {
121                                 break;
122                             }
123                             int k = Character.digit(str.charAt(i), 8);
124                             if (k &lt; 0) {
125                                 break;
126                             }
127                             c = (char) (c * 8 + k);
128                         }
129                         i--;
130                         c &amp;= 0xFF;
131                         break;
132                     case &#39;x&#39;:
133                         i++;
134                         c = 0;
135                         for (int j = 0; j &lt; 2; j++, i++) {
136                             if (i &gt;= str.length()) {
137                                 break;
138                             }
139                             int k = Character.digit(str.charAt(i), 16);
140                             if (k &lt; 0) {
141                                 break;
142                             }
143                             c = (char) (c * 16 + k);
144                         }
145                         i--;
146                         c &amp;= 0xFF;
147                         break;
148                     case &#39;u&#39;:
149                         i++;
150                         c = 0;
151                         for (int j = 0; j &lt; 4; j++, i++) {
152                             if (i &gt;= str.length()) {
153                                 break;
154                             }
155                             int k = Character.digit(str.charAt(i), 16);
156                             if (k &lt; 0) {
157                                 break;
158                             }
159                             c = (char) (c * 16 + k);
160                         }
161                         break;
162                     case &#39;C&#39;:
163                         if (++i &gt;= str.length()) {
164                             break;
165                         }
166                         c = str.charAt(i);
167                         if (c == &#39;-&#39;) {
168                             if (++i &gt;= str.length()) {
169                                 break;
170                             }
171                             c = str.charAt(i);
172                         }
173                         c = c == &#39;?&#39; ? 0x7f : (char) (Character.toUpperCase(c) &amp; 0x1f);
174                         break;
175                 }
176             } else if (c == &#39;^&#39;) {
177                 if (++i &gt;= str.length()) {
178                     break;
179                 }
180                 c = str.charAt(i);
181                 if (c != &#39;^&#39;) {
182                     c = c == &#39;?&#39; ? 0x7f : (char) (Character.toUpperCase(c) &amp; 0x1f);
183                 }
184             }
185             keySeq.append(c);
186         }
187         return keySeq.toString();
188     }
189 
190     public static Collection&lt;String&gt; range(String range) {
191         String[] keys = range.split(&quot;-&quot;);
192         if (keys.length != 2) {
193             return null;
194         }
195         keys[0] = translate(keys[0]);
196         keys[1] = translate(keys[1]);
197         if (keys[0].length() != keys[1].length()) {
198             return null;
199         }
200         String pfx;
201         if (keys[0].length() &gt; 1) {
202             pfx = keys[0].substring(0, keys[0].length() - 1);
203             if (!keys[1].startsWith(pfx)) {
204                 return null;
205             }
206         } else {
207             pfx = &quot;&quot;;
208         }
209         char c0 = keys[0].charAt(keys[0].length() - 1);
210         char c1 = keys[1].charAt(keys[1].length() - 1);
211         if (c0 &gt; c1) {
212             return null;
213         }
214         Collection&lt;String&gt; seqs = new ArrayList&lt;&gt;();
215         for (char c = c0; c &lt;= c1; c++) {
216             seqs.add(pfx + c);
217         }
218         return seqs;
219     }
220 
221 
222     public static String esc() {
223         return &quot;\033&quot;;
224     }
225 
226     public static String alt(char c) {
227         return &quot;\033&quot; + c;
228     }
229 
230     public static String alt(String c) {
231         return &quot;\033&quot; + c;
232     }
233 
234     public static String del() {
235         return &quot;\177&quot;;
236     }
237 
238     public static String ctrl(char key) {
239         return key == &#39;?&#39; ? del() : Character.toString((char) (Character.toUpperCase(key) &amp; 0x1f));
240     }
241 
242     public static String key(Terminal terminal, Capability capability) {
243         return Curses.tputs(terminal.getStringCapability(capability));
244     }
245 
246     public static final Comparator&lt;String&gt; KEYSEQ_COMPARATOR = (s1, s2) -&gt; {
247         int len1 = s1.length();
248         int len2 = s2.length();
249         int lim = Math.min(len1, len2);
250         int k = 0;
251         while (k &lt; lim) {
252             char c1 = s1.charAt(k);
253             char c2 = s2.charAt(k);
254             if (c1 != c2) {
255                 int l = len1 - len2;
256                 return l != 0 ? l : c1 - c2;
257             }
258             k++;
259         }
260         return len1 - len2;
261     };
262 
263     //
264     // Methods
265     //
266 
267 
268     public T getUnicode() {
269         return unicode;
270     }
271 
272     public void setUnicode(T unicode) {
273         this.unicode = unicode;
274     }
275 
276     public T getNomatch() {
277         return nomatch;
278     }
279 
280     public void setNomatch(T nomatch) {
281         this.nomatch = nomatch;
282     }
283 
284     public long getAmbiguousTimeout() {
285         return ambiguousTimeout;
286     }
287 
288     public void setAmbiguousTimeout(long ambiguousTimeout) {
289         this.ambiguousTimeout = ambiguousTimeout;
290     }
291 
292     public T getAnotherKey() {
293         return anotherKey;
294     }
295 
296     public Map&lt;String, T&gt; getBoundKeys() {
297         Map&lt;String, T&gt; bound = new TreeMap&lt;&gt;(KEYSEQ_COMPARATOR);
298         doGetBoundKeys(this, &quot;&quot;, bound);
299         return bound;
300     }
301 
302     @SuppressWarnings(&quot;unchecked&quot;)
303     private static &lt;T&gt; void doGetBoundKeys(KeyMap&lt;T&gt; keyMap, String prefix, Map&lt;String, T&gt; bound) {
304         if (keyMap.anotherKey != null) {
305             bound.put(prefix, keyMap.anotherKey);
306         }
307         for (int c = 0; c &lt; keyMap.mapping.length; c++) {
308             if (keyMap.mapping[c] instanceof KeyMap) {
309                 doGetBoundKeys((KeyMap&lt;T&gt;) keyMap.mapping[c],
310                         prefix + (char) (c),
311                         bound);
312             } else if (keyMap.mapping[c] != null) {
313                 bound.put(prefix + (char) (c), (T) keyMap.mapping[c]);
314             }
315         }
316     }
317 
318     @SuppressWarnings(&quot;unchecked&quot;)
319     public T getBound(CharSequence keySeq, int[] remaining) {
320         remaining[0] = -1;
321         if (keySeq != null &amp;&amp; keySeq.length() &gt; 0) {
322             char c = keySeq.charAt(0);
323             if (c &gt;= mapping.length) {
324                 remaining[0] = Character.codePointCount(keySeq, 0, keySeq.length());
325                 return null;
326             } else {
327                 if (mapping[c] instanceof KeyMap) {
328                     CharSequence sub = keySeq.subSequence(1, keySeq.length());
329                     return ((KeyMap&lt;T&gt;) mapping[c]).getBound(sub, remaining);
330                 } else if (mapping[c] != null) {
331                     remaining[0] = keySeq.length() - 1;
332                     return (T) mapping[c];
333                 } else {
334                     remaining[0] = keySeq.length();
335                     return anotherKey;
336                 }
337             }
338         } else {
339             return anotherKey;
340         }
341     }
342 
343     public T getBound(CharSequence keySeq) {
344         int[] remaining = new int[1];
345         T res = getBound(keySeq, remaining);
346         return remaining[0] &lt;= 0 ? res : null;
347     }
348 
349     public void bindIfNotBound(T function, CharSequence keySeq) {
350         if (function != null &amp;&amp; keySeq != null) {
351             bind(this, keySeq, function, true);
352         }
353     }
354 
355     public void bind(T function, CharSequence... keySeqs) {
356         for (CharSequence keySeq : keySeqs) {
357             bind(function, keySeq);
358         }
359     }
360 
361     public void bind(T function, Iterable&lt;? extends CharSequence&gt; keySeqs) {
362         for (CharSequence keySeq : keySeqs) {
363             bind(function, keySeq);
364         }
365     }
366 
367     public void bind(T function, CharSequence keySeq) {
368         if (keySeq != null) {
369             if (function == null) {
370                 unbind(keySeq);
371             } else {
372                 bind(this, keySeq, function, false);
373             }
374         }
375     }
376 
377     public void unbind(CharSequence... keySeqs) {
378         for (CharSequence keySeq : keySeqs) {
379             unbind(keySeq);
380         }
381     }
382 
383     public void unbind(CharSequence keySeq) {
384         if (keySeq != null) {
385             unbind(this, keySeq);
386         }
387     }
388 
389     @SuppressWarnings(&quot;unchecked&quot;)
390     private static &lt;T&gt; T unbind(KeyMap&lt;T&gt; map, CharSequence keySeq) {
391         KeyMap&lt;T&gt; prev = null;
392         if (keySeq != null &amp;&amp; keySeq.length() &gt; 0) {
393             for (int i = 0; i &lt; keySeq.length() - 1; i++) {
394                 char c = keySeq.charAt(i);
395                 if (c &gt; map.mapping.length) {
396                     return null;
397                 }
398                 if (!(map.mapping[c] instanceof KeyMap)) {
399                     return null;
400                 }
401                 prev = map;
402                 map = (KeyMap&lt;T&gt;) map.mapping[c];
403             }
404             char c = keySeq.charAt(keySeq.length() - 1);
405             if (c &gt; map.mapping.length) {
406                 return null;
407             }
408             if (map.mapping[c] instanceof KeyMap) {
409                 KeyMap&lt;?&gt; sub = (KeyMap) map.mapping[c];
410                 Object res = sub.anotherKey;
411                 sub.anotherKey = null;
412                 return (T) res;
413             } else {
414                 Object res = map.mapping[c];
415                 map.mapping[c] = null;
416                 int nb = 0;
417                 for (int i = 0; i &lt; map.mapping.length; i++) {
418                     if (map.mapping[i] != null) {
419                         nb++;
420                     }
421                 }
422                 if (nb == 0 &amp;&amp; prev != null) {
423                     prev.mapping[keySeq.charAt(keySeq.length() - 2)] = map.anotherKey;
424                 }
425                 return (T) res;
426             }
427         }
428         return null;
429     }
430 
431     @SuppressWarnings(&quot;unchecked&quot;)
432     private static &lt;T&gt; void bind(KeyMap&lt;T&gt; map, CharSequence keySeq, T function, boolean onlyIfNotBound) {
433         if (keySeq != null &amp;&amp; keySeq.length() &gt; 0) {
434             for (int i = 0; i &lt; keySeq.length(); i++) {
435                 char c = keySeq.charAt(i);
436                 if (c &gt;= map.mapping.length) {
437                     return;
438                 }
439                 if (i &lt; keySeq.length() - 1) {
440                     if (!(map.mapping[c] instanceof KeyMap)) {
441                         KeyMap&lt;T&gt; m = new KeyMap&lt;&gt;();
442                         m.anotherKey = (T) map.mapping[c];
443                         map.mapping[c] = m;
444                     }
445                     map = (KeyMap) map.mapping[c];
446                 } else {
447                     if (map.mapping[c] instanceof KeyMap) {
448                         ((KeyMap) map.mapping[c]).anotherKey = function;
449                     } else {
450                         Object op = map.mapping[c];
451                         if (!onlyIfNotBound || op == null) {
452                             map.mapping[c] = function;
453                         }
454                     }
455                 }
456             }
457         }
458     }
459 
460 }
    </pre>
  </body>
</html>
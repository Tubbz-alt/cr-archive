diff a/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/DefaultParser.java b/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/DefaultParser.java
--- a/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/DefaultParser.java
+++ b/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/DefaultParser.java
@@ -2,11 +2,11 @@
  * Copyright (c) 2002-2018, the original author or authors.
  *
  * This software is distributable under the BSD license. See the terms of the
  * BSD license in the documentation provided with this software.
  *
- * http://www.opensource.org/licenses/bsd-license.php
+ * https://opensource.org/licenses/BSD-3-Clause
  */
 package jdk.internal.org.jline.reader.impl;
 
 import java.util.*;
 import java.util.function.Predicate;
@@ -16,18 +16,29 @@
 import jdk.internal.org.jline.reader.ParsedLine;
 import jdk.internal.org.jline.reader.Parser;
 
 public class DefaultParser implements Parser {
 
+    public enum Bracket {
+        ROUND,   // ()
+        CURLY,   // {}
+        SQUARE,  // []
+        ANGLE;   // <>
+    }
+
     private char[] quoteChars = {'\'', '"'};
 
     private char[] escapeChars = {'\\'};
 
     private boolean eofOnUnclosedQuote;
 
     private boolean eofOnEscapedNewLine;
 
+    private char[] openingBrackets = null;
+
+    private char[] closingBrackets = null;
+
     //
     // Chainable setters
     //
 
     public DefaultParser quoteChars(final char[] chars) {
@@ -43,10 +54,15 @@
     public DefaultParser eofOnUnclosedQuote(boolean eofOnUnclosedQuote) {
         this.eofOnUnclosedQuote = eofOnUnclosedQuote;
         return this;
     }
 
+    public DefaultParser eofOnUnclosedBracket(Bracket... brackets){
+        setEofOnUnclosedBracket(brackets);
+        return this;
+    }
+
     public DefaultParser eofOnEscapedNewLine(boolean eofOnEscapedNewLine) {
         this.eofOnEscapedNewLine = eofOnEscapedNewLine;
         return this;
     }
 
@@ -84,19 +100,54 @@
 
     public boolean isEofOnEscapedNewLine() {
         return eofOnEscapedNewLine;
     }
 
+    public void setEofOnUnclosedBracket(Bracket... brackets){
+        if (brackets == null) {
+            openingBrackets = null;
+            closingBrackets = null;
+        } else {
+            Set<Bracket> bs = new HashSet<>(Arrays.asList(brackets));
+            openingBrackets = new char[bs.size()];
+            closingBrackets = new char[bs.size()];
+            int i = 0;
+            for (Bracket b : bs) {
+                switch (b) {
+                case ROUND:
+                    openingBrackets[i] = '(';
+                    closingBrackets[i] = ')';
+                    break;
+                case CURLY:
+                    openingBrackets[i] = '{';
+                    closingBrackets[i] = '}';
+                    break;
+                case SQUARE:
+                    openingBrackets[i] = '[';
+                    closingBrackets[i] = ']';
+                    break;
+                case ANGLE:
+                    openingBrackets[i] = '<';
+                    closingBrackets[i] = '>';
+                    break;
+                }
+                i++;
+            }
+        }
+    }
+
     public ParsedLine parse(final String line, final int cursor, ParseContext context) {
         List<String> words = new LinkedList<>();
         StringBuilder current = new StringBuilder();
         int wordCursor = -1;
         int wordIndex = -1;
         int quoteStart = -1;
         int rawWordCursor = -1;
         int rawWordLength = -1;
         int rawWordStart = 0;
+        BracketChecker bracketChecker = new BracketChecker();
+        boolean quotedWord = false;
 
         for (int i = 0; (line != null) && (i < line.length()); i++) {
             // once we reach the cursor, set the
             // position of the selected index
             if (i == cursor) {
@@ -108,40 +159,39 @@
             }
 
             if (quoteStart < 0 && isQuoteChar(line, i)) {
                 // Start a quote block
                 quoteStart = i;
-            } else if (quoteStart >= 0) {
-                // In a quote block
-                if (line.charAt(quoteStart) == line.charAt(i) && !isEscaped(line, i)) {
-                    // End the block; arg could be empty, but that's fine
+                if (current.length()==0) {
+                    quotedWord = true;
+                } else {
+                    current.append(line.charAt(i));
+                }
+            } else if (quoteStart >= 0 && line.charAt(quoteStart) == line.charAt(i) && !isEscaped(line, i)) {
+                // End quote block
+                if (!quotedWord) {
+                    current.append(line.charAt(i));
+                } else if (rawWordCursor >= 0 && rawWordLength < 0) {
+                    rawWordLength = i - rawWordStart + 1;
+                }
+                quoteStart = -1;
+                quotedWord = false;
+            } else if (quoteStart < 0 && isDelimiter(line, i)) {
+                // Delimiter
+                if (current.length() > 0) {
                     words.add(current.toString());
-                    current.setLength(0);
-                    quoteStart = -1;
+                    current.setLength(0); // reset the arg
                     if (rawWordCursor >= 0 && rawWordLength < 0) {
-                        rawWordLength = i - rawWordStart + 1;
-                    }
-                } else {
-                    if (!isEscapeChar(line, i)) {
-                        // Take the next character
-                        current.append(line.charAt(i));
+                        rawWordLength = i - rawWordStart;
                     }
                 }
+                rawWordStart = i + 1;
             } else {
-                // Not in a quote block
-                if (isDelimiter(line, i)) {
-                    if (current.length() > 0) {
-                        words.add(current.toString());
-                        current.setLength(0); // reset the arg
-                        if (rawWordCursor >= 0 && rawWordLength < 0) {
-                            rawWordLength = i - rawWordStart;
-                        }
-                    }
-                    rawWordStart = i + 1;
-                } else {
-                    if (!isEscapeChar(line, i)) {
-                        current.append(line.charAt(i));
+                if (!isEscapeChar(line, i)) {
+                    current.append(line.charAt(i));
+                    if (quoteStart < 0) {
+                        bracketChecker.check(line, i);
                     }
                 }
             }
         }
 
@@ -157,25 +207,33 @@
             wordCursor = words.get(words.size() - 1).length();
             rawWordCursor = cursor - rawWordStart;
             rawWordLength = rawWordCursor;
         }
 
-        if (eofOnEscapedNewLine && isEscapeChar(line, line.length() - 1)) {
-            throw new EOFError(-1, -1, "Escaped new line", "newline");
-        }
-        if (eofOnUnclosedQuote && quoteStart >= 0 && context != ParseContext.COMPLETE) {
-            throw new EOFError(-1, -1, "Missing closing quote", line.charAt(quoteStart) == '\''
-                    ? "quote" : "dquote");
+        if (context != ParseContext.COMPLETE) {
+            if (eofOnEscapedNewLine && isEscapeChar(line, line.length() - 1)) {
+                throw new EOFError(-1, -1, "Escaped new line", "newline");
+            }
+            if (eofOnUnclosedQuote && quoteStart >= 0) {
+                throw new EOFError(-1, -1, "Missing closing quote", line.charAt(quoteStart) == '\''
+                        ? "quote" : "dquote");
+            }
+            if (bracketChecker.isOpeningBracketMissing()) {
+                throw new EOFError(-1, -1, "Missing opening bracket", "missing: " + bracketChecker.getMissingOpeningBracket());
+            }
+            if (bracketChecker.isClosingBracketMissing()) {
+                throw new EOFError(-1, -1, "Missing closing brackets", "add: " + bracketChecker.getMissingClosingBrackets());
+            }
         }
 
-        String openingQuote = quoteStart >= 0 ? line.substring(quoteStart, quoteStart + 1) : null;
+        String openingQuote = quotedWord ? line.substring(quoteStart, quoteStart + 1) : null;
         return new ArgumentList(line, words, wordIndex, wordCursor, cursor, openingQuote, rawWordCursor, rawWordLength);
     }
 
     /**
      * Returns true if the specified character is a whitespace parameter. Check to ensure that the character is not
-     * escaped by any of {@link #getQuoteChars}, and is not escaped by ant of the {@link #getEscapeChars}, and
+     * escaped by any of {@link #getQuoteChars}, and is not escaped by any of the {@link #getEscapeChars}, and
      * returns true from {@link #isDelimiterChar}.
      *
      * @param buffer    The complete command buffer
      * @param pos       The index of the character in the buffer
      * @return          True if the character should be a delimiter
@@ -200,10 +258,22 @@
             }
         }
         return false;
     }
 
+    @Override
+    public boolean isEscapeChar(char ch) {
+        if (escapeChars != null) {
+            for (char e : escapeChars) {
+                if (e == ch) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
     /**
      * Check if this character is a valid escape char (i.e. one that has not been escaped)
      *
      * @param buffer
      *          the buffer to check in
@@ -214,18 +284,12 @@
      */
     public boolean isEscapeChar(final CharSequence buffer, final int pos) {
         if (pos < 0) {
             return false;
         }
-        if (escapeChars != null) {
-            for (char e : escapeChars) {
-                if (e == buffer.charAt(pos)) {
-                    return !isEscaped(buffer, pos);
-                }
-            }
-        }
-        return false;
+        char ch = buffer.charAt(pos);
+        return isEscapeChar(ch) && !isEscaped(buffer, pos);
     }
 
     /**
      * Check if a character is escaped (i.e. if the previous character is an escape)
      *
@@ -243,11 +307,11 @@
         return isEscapeChar(buffer, pos - 1);
     }
 
     /**
      * Returns true if the character at the specified position if a delimiter. This method will only be called if
-     * the character is not enclosed in any of the {@link #getQuoteChars}, and is not escaped by ant of the
+     * the character is not enclosed in any of the {@link #getQuoteChars}, and is not escaped by any of the
      * {@link #getEscapeChars}. To perform escaping manually, override {@link #isDelimiter} instead.
      *
      * @param buffer
      *          the buffer to check in
      * @param pos
@@ -278,10 +342,71 @@
             }
         }
         return false;
     }
 
+    private class BracketChecker {
+        private int missingOpeningBracket = -1;
+        private List<Integer> nested = new ArrayList<>();
+
+        public BracketChecker(){}
+
+        public void check(final CharSequence buffer, final int pos){
+            if (openingBrackets == null || pos < 0) {
+                return;
+            }
+            int bid = bracketId(openingBrackets, buffer, pos);
+            if (bid >= 0) {
+                nested.add(bid);
+            } else {
+                bid = bracketId(closingBrackets, buffer, pos);
+                if (bid >= 0) {
+                    if (!nested.isEmpty() && bid == nested.get(nested.size()-1)) {
+                        nested.remove(nested.size()-1);
+                    } else {
+                        missingOpeningBracket = bid;
+                    }
+                }
+            }
+        }
+
+        public boolean isOpeningBracketMissing(){
+            return missingOpeningBracket != -1;
+        }
+
+        public String getMissingOpeningBracket(){
+            if (!isOpeningBracketMissing()) {
+                return null;
+            }
+            return Character.toString(openingBrackets[missingOpeningBracket]);
+        }
+
+        public boolean isClosingBracketMissing(){
+            return !nested.isEmpty();
+        }
+
+        public String getMissingClosingBrackets(){
+            if (!isClosingBracketMissing()) {
+                return null;
+            }
+            StringBuilder out = new StringBuilder();
+            for (int i = nested.size() - 1; i > -1; i--) {
+                out.append(closingBrackets[nested.get(i)]);
+            }
+            return out.toString();
+        }
+
+        private int bracketId(final char[] brackets, final CharSequence buffer, final int pos){
+            for (int i=0; i < brackets.length; i++) {
+                if (buffer.charAt(pos) == brackets[i]) {
+                    return i;
+                }
+            }
+            return -1;
+        }
+    }
+
     /**
      * The result of a delimited buffer.
      *
      * @author <a href="mailto:mwp1@cornell.edu">Marc Prud'hommeaux</a>
      */
@@ -365,30 +490,54 @@
         }
 
         public CharSequence escape(CharSequence candidate, boolean complete) {
             StringBuilder sb = new StringBuilder(candidate);
             Predicate<Integer> needToBeEscaped;
-            // Completion is protected by an opening quote:
-            // Delimiters (spaces) don't need to be escaped, nor do other quotes, but everything else does.
-            // Also, close the quote at the end
-            if (openingQuote != null) {
-                needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);
-            }
-            // No quote protection, need to escape everything: delimiter chars (spaces), quote chars
-            // and escapes themselves
-            else {
-                needToBeEscaped = i -> isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));
+            String quote = openingQuote;
+            boolean middleQuotes = false;
+            if (openingQuote==null) {
+                for (int i=0; i < sb.length(); i++) {
+                    if (isQuoteChar(sb, i)) {
+                        middleQuotes = true;
+                        break;
+                    }
+                }
             }
-            for (int i = 0; i < sb.length(); i++) {
-                if (needToBeEscaped.test(i)) {
-                    sb.insert(i++, escapeChars[0]);
+            if (escapeChars != null) {
+                // Completion is protected by an opening quote:
+                // Delimiters (spaces) don't need to be escaped, nor do other quotes, but everything else does.
+                // Also, close the quote at the end
+                if (openingQuote != null) {
+                    needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);
+                }
+                // Completion is protected by middle quotes:
+                // Delimiters (spaces) don't need to be escaped, nor do quotes, but everything else does.
+                else if (middleQuotes) {
+                    needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i));
+                }
+                // No quote protection, need to escape everything: delimiter chars (spaces), quote chars
+                // and escapes themselves
+                else {
+                    needToBeEscaped = i -> isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));
+                }
+                for (int i = 0; i < sb.length(); i++) {
+                    if (needToBeEscaped.test(i)) {
+                        sb.insert(i++, escapeChars[0]);
+                    }
+                }
+            } else if (openingQuote == null && !middleQuotes) {
+                for (int i = 0; i < sb.length(); i++) {
+                    if (isDelimiterChar(sb, i)) {
+                        quote = "'";
+                        break;
+                    }
                 }
             }
-            if (openingQuote != null) {
-                sb.insert(0, openingQuote);
+            if (quote != null) {
+                sb.insert(0, quote);
                 if (complete) {
-                    sb.append(openingQuote);
+                    sb.append(quote);
                 }
             }
             return sb;
         }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/PumpReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2017, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.io.IOException;
 12 import java.io.InterruptedIOException;
 13 import java.io.Reader;
 14 import java.nio.ByteBuffer;
 15 import java.nio.CharBuffer;
 16 import java.nio.charset.Charset;
 17 import java.nio.charset.CharsetEncoder;
 18 import java.nio.charset.CoderResult;
 19 import java.nio.charset.CodingErrorAction;
 20 
 21 public class PumpReader extends Reader {
 22 
 23     private static final int EOF = -1;
 24     private static final int DEFAULT_BUFFER_SIZE = 4096;
 25 
 26     // Read and write buffer are backed by the same array
 27     private final CharBuffer readBuffer;
 28     private final CharBuffer writeBuffer;
 29 
 30     private final Writer writer;
 31 
 32     private boolean closed;
 33 
 34     public PumpReader() {
 35         this(DEFAULT_BUFFER_SIZE);
 36     }
 37 
 38     public PumpReader(int bufferSize) {
 39         char[] buf = new char[bufferSize];
 40         this.readBuffer = CharBuffer.wrap(buf);
 41         this.writeBuffer = CharBuffer.wrap(buf);
 42         this.writer = new Writer(this);
 43 
 44         // There are no bytes available to read after initialization
 45         readBuffer.limit(0);
 46     }
 47 
 48     public java.io.Writer getWriter() {
 49         return this.writer;
 50     }
 51 
 52     public java.io.InputStream createInputStream(Charset charset) {
 53         return new InputStream(this, charset);
 54     }
 55 
 56     private boolean wait(CharBuffer buffer) throws InterruptedIOException {
 57         if (closed) {
 58             return false;
 59         }
 60 
 61         while (!buffer.hasRemaining()) {
 62             // Wake up waiting readers/writers
 63             notifyAll();
 64 
 65             try {
 66                 wait();
 67             } catch (InterruptedException e) {
 68                 throw new InterruptedIOException();
 69             }
 70 
 71             if (closed) {
 72                 return false;
 73             }
 74         }
 75 
 76         return true;
 77     }
 78 
 79     /**
 80      * Blocks until more input is available or the reader is closed.
 81      *
 82      * @return true if more input is available, false if the reader is closed
 83      * @throws InterruptedIOException If {@link #wait()} is interrupted
 84      */
 85     private boolean waitForInput() throws InterruptedIOException {
 86         return wait(readBuffer);
 87     }
 88 
 89     /**
 90      * Blocks until there is new space available for buffering or the
 91      * reader is closed.
 92      *
 93      * @throws InterruptedIOException If {@link #wait()} is interrupted
 94      * @throws ClosedException If the reader was closed
 95      */
 96     private void waitForBufferSpace() throws InterruptedIOException, ClosedException {
 97         if (!wait(writeBuffer)) {
 98             throw new ClosedException();
 99         }
100     }
101 
102     private static boolean rewind(CharBuffer buffer, CharBuffer other) {
103         // Extend limit of other buffer if there is additional input/output available
104         if (buffer.position() &gt; other.position()) {
105             other.limit(buffer.position());
106         }
107 
108         // If we have reached the end of the buffer, rewind and set the new limit
109         if (buffer.position() == buffer.capacity()) {
110             buffer.rewind();
111             buffer.limit(other.position());
112             return true;
113         } else {
114             return false;
115         }
116     }
117 
118     /**
119      * Attempts to find additional input by rewinding the {@link #readBuffer}.
120      * Updates the {@link #writeBuffer} to make read bytes available for buffering.
121      *
122      * @return If more input is available
123      */
124     private boolean rewindReadBuffer() {
125         return rewind(readBuffer, writeBuffer) &amp;&amp; readBuffer.hasRemaining();
126     }
127 
128     /**
129      * Attempts to find additional buffer space by rewinding the {@link #writeBuffer}.
130      * Updates the {@link #readBuffer} to make written bytes available to the reader.
131      */
132     private void rewindWriteBuffer() {
133         rewind(writeBuffer, readBuffer);
134     }
135 
136     @Override
137     public synchronized boolean ready() {
138         return readBuffer.hasRemaining();
139     }
140 
141     public synchronized int available() {
142         int count = readBuffer.remaining();
143         if (writeBuffer.position() &lt; readBuffer.position()) {
144             count += writeBuffer.position();
145         }
146         return count;
147     }
148 
149     @Override
150     public synchronized int read() throws IOException {
151         if (!waitForInput()) {
152             return EOF;
153         }
154 
155         int b = readBuffer.get();
156         rewindReadBuffer();
157         return b;
158     }
159 
160     private int copyFromBuffer(char[] cbuf, int off, int len) {
161         len = Math.min(len, readBuffer.remaining());
162         readBuffer.get(cbuf, off, len);
163         return len;
164     }
165 
166     @Override
167     public synchronized int read(char[] cbuf, int off, int len) throws IOException {
168         if (len == 0) {
169             return 0;
170         }
171 
172         if (!waitForInput()) {
173             return EOF;
174         }
175 
176         int count = copyFromBuffer(cbuf, off, len);
177         if (rewindReadBuffer() &amp;&amp; count &lt; len) {
178             count += copyFromBuffer(cbuf, off + count, len - count);
179             rewindReadBuffer();
180         }
181 
182         return count;
183     }
184 
185     @Override
186     public int read(CharBuffer target) throws IOException {
187         if (!target.hasRemaining()) {
188             return 0;
189         }
190 
191         if (!waitForInput()) {
192             return EOF;
193         }
194 
195         int count = readBuffer.read(target);
196         if (rewindReadBuffer() &amp;&amp; target.hasRemaining()) {
197             count += readBuffer.read(target);
198             rewindReadBuffer();
199         }
200 
201         return count;
202     }
203 
204     private void encodeBytes(CharsetEncoder encoder, ByteBuffer output) throws IOException {
205         CoderResult result = encoder.encode(readBuffer, output, false);
206         if (rewindReadBuffer() &amp;&amp; result.isUnderflow()) {
207             encoder.encode(readBuffer, output, false);
208             rewindReadBuffer();
209         }
210     }
211 
212     synchronized int readBytes(CharsetEncoder encoder, byte[] b, int off, int len) throws IOException {
213         if (!waitForInput()) {
214             return 0;
215         }
216 
217         ByteBuffer output = ByteBuffer.wrap(b, off, len);
218         encodeBytes(encoder, output);
219         return output.position() - off;
220     }
221 
222     synchronized void readBytes(CharsetEncoder encoder, ByteBuffer output) throws IOException {
223         if (!waitForInput()) {
224             return;
225         }
226 
227         encodeBytes(encoder, output);
228     }
229 
230     synchronized void write(char c) throws IOException {
231         waitForBufferSpace();
232         writeBuffer.put(c);
233         rewindWriteBuffer();
234     }
235 
236     synchronized void write(char[] cbuf, int off, int len) throws IOException {
237         while (len &gt; 0) {
238             waitForBufferSpace();
239 
240             // Copy as much characters as we can
241             int count = Math.min(len, writeBuffer.remaining());
242             writeBuffer.put(cbuf, off, count);
243 
244             off += count;
245             len -= count;
246 
247             // Update buffer states and rewind if necessary
248             rewindWriteBuffer();
249         }
250     }
251 
252     synchronized void write(String str, int off, int len) throws IOException {
253         char[] buf = writeBuffer.array();
254 
255         while (len &gt; 0) {
256             waitForBufferSpace();
257 
258             // Copy as much characters as we can
259             int count = Math.min(len, writeBuffer.remaining());
260             // CharBuffer.put(String) doesn&#39;t use getChars so do it manually
261             str.getChars(off, off + count, buf, writeBuffer.position());
262             writeBuffer.position(writeBuffer.position() + count);
263 
264             off += count;
265             len -= count;
266 
267             // Update buffer states and rewind if necessary
268             rewindWriteBuffer();
269         }
270     }
271 
272     synchronized void flush() {
273         // Avoid waking up readers when there is nothing to read
274         if (readBuffer.hasRemaining()) {
275             // Notify readers
276             notifyAll();
277         }
278     }
279 
280     @Override
281     public synchronized void close() throws IOException {
282         this.closed = true;
283         notifyAll();
284     }
285 
286     private static class Writer extends java.io.Writer {
287 
288         private final PumpReader reader;
289 
290         private Writer(PumpReader reader) {
291             this.reader = reader;
292         }
293 
294         @Override
295         public void write(int c) throws IOException {
296             reader.write((char) c);
297         }
298 
299         @Override
300         public void write(char[] cbuf, int off, int len) throws IOException {
301             reader.write(cbuf, off, len);
302         }
303 
304         @Override
305         public void write(String str, int off, int len) throws IOException {
306             reader.write(str, off, len);
307         }
308 
309         @Override
310         public void flush() throws IOException {
311             reader.flush();
312         }
313 
314         @Override
315         public void close() throws IOException {
316             reader.close();
317         }
318 
319     }
320 
321     private static class InputStream extends java.io.InputStream {
322 
323         private final PumpReader reader;
324         private final CharsetEncoder encoder;
325 
326         // To encode a character with multiple bytes (e.g. certain Unicode characters)
327         // we need enough space to encode them. Reading would fail if the read() method
328         // is used to read a single byte in these cases.
329         // Use this buffer to ensure we always have enough space to encode a character.
330         private final ByteBuffer buffer;
331 
332         private InputStream(PumpReader reader, Charset charset) {
333             this.reader = reader;
334             this.encoder = charset.newEncoder()
335                     .onUnmappableCharacter(CodingErrorAction.REPLACE)
336                     .onMalformedInput(CodingErrorAction.REPLACE);
337             this.buffer = ByteBuffer.allocate((int) Math.ceil(encoder.maxBytesPerChar()));
338 
339             // No input available after initialization
340             buffer.limit(0);
341         }
342 
343         @Override
344         public int available() throws IOException {
345             return (int) (reader.available() * (double) this.encoder.averageBytesPerChar()) + buffer.remaining();
346         }
347 
348         @Override
349         public int read() throws IOException {
350             if (!buffer.hasRemaining() &amp;&amp; !readUsingBuffer()) {
351                 return EOF;
352             }
353 
354             return buffer.get();
355         }
356 
357         private boolean readUsingBuffer() throws IOException {
358             buffer.clear(); // Reset buffer
359             reader.readBytes(encoder, buffer);
360             buffer.flip();
361             return buffer.hasRemaining();
362         }
363 
364         private int copyFromBuffer(byte[] b, int off, int len) {
365             len = Math.min(len, buffer.remaining());
366             buffer.get(b, off, len);
367             return len;
368         }
369 
370         @Override
371         public int read(byte[] b, int off, int len) throws IOException {
372             if (len == 0) {
373                 return 0;
374             }
375 
376             int read;
377             if (buffer.hasRemaining()) {
378                 read = copyFromBuffer(b, off, len);
379                 if (read == len) {
380                     return len;
381                 }
382 
383                 off += read;
384                 len -= read;
385             } else {
386                 read = 0;
387             }
388 
389             // Do we have enough space to avoid buffering?
390             if (len &gt;= buffer.capacity()) {
391                 read += reader.readBytes(this.encoder, b, off, len);
392             } else if (readUsingBuffer()) {
393                 read += copyFromBuffer(b, off, len);
394             }
395 
396             // Return EOF if we didn&#39;t read any bytes
397             return read == 0 ? EOF : read;
398         }
399 
400         @Override
401         public void close() throws IOException {
402             reader.close();
403         }
404 
405     }
406 
407 }
    </pre>
  </body>
</html>
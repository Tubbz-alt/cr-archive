<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/NonBlockingPumpInputStream.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2017, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.io.IOException;
 12 import java.io.InterruptedIOException;
 13 import java.io.OutputStream;
 14 import java.nio.ByteBuffer;
 15 
 16 public class NonBlockingPumpInputStream extends NonBlockingInputStream {
 17 
 18     private static final int DEFAULT_BUFFER_SIZE = 4096;
 19 
 20     // Read and write buffer are backed by the same array
 21     private final ByteBuffer readBuffer;
 22     private final ByteBuffer writeBuffer;
 23 
 24     private final OutputStream output;
 25 
 26     private boolean closed;
 27 
 28     private IOException ioException;
 29 
 30     public NonBlockingPumpInputStream() {
 31         this(DEFAULT_BUFFER_SIZE);
 32     }
 33 
 34     public NonBlockingPumpInputStream(int bufferSize) {
 35         byte[] buf = new byte[bufferSize];
 36         this.readBuffer = ByteBuffer.wrap(buf);
 37         this.writeBuffer = ByteBuffer.wrap(buf);
 38         this.output = new NbpOutputStream();
 39         // There are no bytes available to read after initialization
 40         readBuffer.limit(0);
 41     }
 42 
 43     public OutputStream getOutputStream() {
 44         return this.output;
 45     }
 46 
 47     private int wait(ByteBuffer buffer, long timeout) throws IOException {
 48         boolean isInfinite = (timeout &lt;= 0L);
 49         long end = 0;
 50         if (!isInfinite) {
 51             end = System.currentTimeMillis() + timeout;
 52         }
 53         while (!closed &amp;&amp; !buffer.hasRemaining() &amp;&amp; (isInfinite || timeout &gt; 0L)) {
 54             // Wake up waiting readers/writers
 55             notifyAll();
 56             try {
 57                 wait(timeout);
 58                 checkIoException();
 59             } catch (InterruptedException e) {
 60                 checkIoException();
 61                 throw new InterruptedIOException();
 62             }
 63             if (!isInfinite) {
 64                 timeout = end - System.currentTimeMillis();
 65             }
 66         }
 67         return buffer.hasRemaining()
 68                 ? 0
 69                 : closed
 70                     ? EOF
 71                     : READ_EXPIRED;
 72     }
 73 
 74     private static boolean rewind(ByteBuffer buffer, ByteBuffer other) {
 75         // Extend limit of other buffer if there is additional input/output available
 76         if (buffer.position() &gt; other.position()) {
 77             other.limit(buffer.position());
 78         }
 79         // If we have reached the end of the buffer, rewind and set the new limit
 80         if (buffer.position() == buffer.capacity()) {
 81             buffer.rewind();
 82             buffer.limit(other.position());
 83             return true;
 84         } else {
 85             return false;
 86         }
 87     }
 88 
 89     public synchronized int available() {
 90         int count = readBuffer.remaining();
 91         if (writeBuffer.position() &lt; readBuffer.position()) {
 92             count += writeBuffer.position();
 93         }
 94         return count;
 95     }
 96 
 97     @Override
 98     public synchronized int read(long timeout, boolean isPeek) throws IOException {
 99         checkIoException();
100         // Blocks until more input is available or the reader is closed.
101         int res = wait(readBuffer, timeout);
102         if (res &gt;= 0) {
103             res = readBuffer.get() &amp; 0x00FF;
104         }
105         rewind(readBuffer, writeBuffer);
106         return res;
107     }
108 
109     public synchronized void setIoException(IOException exception) {
110         this.ioException = exception;
111         notifyAll();
112     }
113 
114     protected synchronized void checkIoException() throws IOException {
115         if (ioException != null) {
116             throw ioException;
117         }
118     }
119 
120     synchronized void write(byte[] cbuf, int off, int len) throws IOException {
121         while (len &gt; 0) {
122             // Blocks until there is new space available for buffering or the
123             // reader is closed.
124             if (wait(writeBuffer, 0L) == EOF) {
125                 throw new ClosedException();
126             }
127             // Copy as much characters as we can
128             int count = Math.min(len, writeBuffer.remaining());
129             writeBuffer.put(cbuf, off, count);
130             off += count;
131             len -= count;
132             // Update buffer states and rewind if necessary
133             rewind(writeBuffer, readBuffer);
134         }
135     }
136 
137     synchronized void flush() {
138         // Avoid waking up readers when there is nothing to read
139         if (readBuffer.hasRemaining()) {
140             // Notify readers
141             notifyAll();
142         }
143     }
144 
145     @Override
146     public synchronized void close() throws IOException {
147         this.closed = true;
148         notifyAll();
149     }
150 
151     private class NbpOutputStream extends OutputStream {
152 
153         @Override
154         public void write(int b) throws IOException {
155             NonBlockingPumpInputStream.this.write(new byte[] { (byte) b }, 0, 1);
156         }
157 
158         @Override
159         public void write(byte[] cbuf, int off, int len) throws IOException {
160             NonBlockingPumpInputStream.this.write(cbuf, off, len);
161         }
162 
163         @Override
164         public void flush() throws IOException {
165             NonBlockingPumpInputStream.this.flush();
166         }
167 
168         @Override
169         public void close() throws IOException {
170             NonBlockingPumpInputStream.this.close();
171         }
172 
173     }
174 
175 }
    </pre>
  </body>
</html>
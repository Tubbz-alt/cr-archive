<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2002-2018, the original author or authors.</span>
   3  *
   4  * This software is distributable under the BSD license. See the terms of the
   5  * BSD license in the documentation provided with this software.
   6  *
<a name="2" id="anc2"></a><span class="line-modified">   7  * http://www.opensource.org/licenses/bsd-license.php</span>
   8  */
   9 package jdk.internal.org.jline.reader.impl;
  10 
  11 import java.io.Flushable;
  12 import java.io.IOError;
  13 import java.io.IOException;
  14 import java.io.InputStream;
  15 import java.io.InterruptedIOException;
  16 import java.time.Instant;
  17 import java.util.*;
  18 import java.util.Map.Entry;
  19 import java.util.concurrent.atomic.AtomicBoolean;
<a name="3" id="anc3"></a>

  20 import java.util.function.*;
  21 import java.util.regex.Matcher;
  22 import java.util.regex.Pattern;
  23 import java.util.stream.Collectors;
<a name="4" id="anc4"></a>
  24 import java.util.stream.StreamSupport;
  25 
  26 import jdk.internal.org.jline.keymap.BindingReader;
  27 import jdk.internal.org.jline.keymap.KeyMap;
  28 import jdk.internal.org.jline.reader.*;
  29 import jdk.internal.org.jline.reader.Parser.ParseContext;
  30 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  31 import jdk.internal.org.jline.terminal.*;
  32 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  33 import jdk.internal.org.jline.terminal.Terminal.Signal;
  34 import jdk.internal.org.jline.terminal.Terminal.SignalHandler;
<a name="5" id="anc5"></a>
  35 import jdk.internal.org.jline.utils.AttributedString;
  36 import jdk.internal.org.jline.utils.AttributedStringBuilder;
  37 import jdk.internal.org.jline.utils.AttributedStyle;
  38 import jdk.internal.org.jline.utils.Curses;
  39 import jdk.internal.org.jline.utils.Display;
  40 import jdk.internal.org.jline.utils.InfoCmp.Capability;
  41 import jdk.internal.org.jline.utils.Levenshtein;
  42 import jdk.internal.org.jline.utils.Log;
  43 import jdk.internal.org.jline.utils.Status;
  44 import jdk.internal.org.jline.utils.WCWidth;
  45 
  46 import static jdk.internal.org.jline.keymap.KeyMap.alt;
  47 import static jdk.internal.org.jline.keymap.KeyMap.ctrl;
  48 import static jdk.internal.org.jline.keymap.KeyMap.del;
  49 import static jdk.internal.org.jline.keymap.KeyMap.esc;
  50 import static jdk.internal.org.jline.keymap.KeyMap.range;
  51 import static jdk.internal.org.jline.keymap.KeyMap.translate;
  52 
  53 /**
  54  * A reader for terminal applications. It supports custom tab-completion,
  55  * saveable command history, and command line editing.
  56  *
  57  * @author &lt;a href=&quot;mailto:mwp1@cornell.edu&quot;&gt;Marc Prud&#39;hommeaux&lt;/a&gt;
  58  * @author &lt;a href=&quot;mailto:jason@planet57.com&quot;&gt;Jason Dillon&lt;/a&gt;
  59  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
  60  */
  61 @SuppressWarnings(&quot;StatementWithEmptyBody&quot;)
  62 public class LineReaderImpl implements LineReader, Flushable
  63 {
  64     public static final char NULL_MASK = 0;
  65 
  66     public static final int TAB_WIDTH = 4;
  67 
  68 
  69     public static final String DEFAULT_WORDCHARS = &quot;*?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;&quot;;
  70     public static final String DEFAULT_REMOVE_SUFFIX_CHARS = &quot; \t\n;&amp;|&quot;;
  71     public static final String DEFAULT_COMMENT_BEGIN = &quot;#&quot;;
  72     public static final String DEFAULT_SEARCH_TERMINATORS = &quot;\033\012&quot;;
  73     public static final String DEFAULT_BELL_STYLE = &quot;&quot;;
  74     public static final int    DEFAULT_LIST_MAX = 100;
  75     public static final int    DEFAULT_ERRORS = 2;
  76     public static final long   DEFAULT_BLINK_MATCHING_PAREN = 500L;
  77     public static final long   DEFAULT_AMBIGUOUS_BINDING = 1000L;
  78     public static final String DEFAULT_SECONDARY_PROMPT_PATTERN = &quot;%M&gt; &quot;;
  79     public static final String DEFAULT_OTHERS_GROUP_NAME = &quot;others&quot;;
  80     public static final String DEFAULT_ORIGINAL_GROUP_NAME = &quot;original&quot;;
  81     public static final String DEFAULT_COMPLETION_STYLE_STARTING = &quot;36&quot;;    // cyan
  82     public static final String DEFAULT_COMPLETION_STYLE_DESCRIPTION = &quot;90&quot;; // dark gray
  83     public static final String DEFAULT_COMPLETION_STYLE_GROUP = &quot;35;1&quot;;     // magenta
  84     public static final String DEFAULT_COMPLETION_STYLE_SELECTION = &quot;7&quot;;    // inverted
  85 
  86     private static final int MIN_ROWS = 3;
  87 
  88     public static final String BRACKETED_PASTE_ON = &quot;\033[?2004h&quot;;
  89     public static final String BRACKETED_PASTE_OFF = &quot;\033[?2004l&quot;;
  90     public static final String BRACKETED_PASTE_BEGIN = &quot;\033[200~&quot;;
  91     public static final String BRACKETED_PASTE_END = &quot;\033[201~&quot;;
  92 
  93     public static final String FOCUS_IN_SEQ = &quot;\033[I&quot;;
  94     public static final String FOCUS_OUT_SEQ = &quot;\033[O&quot;;
  95 
  96     /**
  97      * Possible states in which the current readline operation may be in.
  98      */
  99     protected enum State {
 100         /**
 101          * The user is just typing away
 102          */
 103         NORMAL,
 104         /**
 105          * readLine should exit and return the buffer content
 106          */
 107         DONE,
 108         /**
 109          * readLine should exit and throw an EOFException
 110          */
 111         EOF,
 112         /**
 113          * readLine should exit and throw an UserInterruptException
 114          */
 115         INTERRUPT
 116     }
 117 
 118     protected enum ViMoveMode {
 119         NORMAL,
 120         YANK,
 121         DELETE,
 122         CHANGE
 123     }
 124 
 125     protected enum BellType {
 126         NONE,
 127         AUDIBLE,
 128         VISIBLE
 129     }
 130 
 131     //
 132     // Constructor variables
 133     //
 134 
 135     /** The terminal to use */
 136     protected final Terminal terminal;
 137     /** The application name */
 138     protected final String appName;
 139     /** The terminal keys mapping */
 140     protected final Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps;
 141 
 142     //
 143     // Configuration
 144     //
 145     protected final Map&lt;String, Object&gt; variables;
 146     protected History history = new DefaultHistory();
 147     protected Completer completer = null;
 148     protected Highlighter highlighter = new DefaultHighlighter();
 149     protected Parser parser = new DefaultParser();
 150     protected Expander expander = new DefaultExpander();
 151 
 152     //
 153     // State variables
 154     //
 155 
 156     protected final Map&lt;Option, Boolean&gt; options = new HashMap&lt;&gt;();
 157 
 158     protected final Buffer buf = new BufferImpl();
 159 
 160     protected final Size size = new Size();
 161 
<a name="6" id="anc6"></a><span class="line-modified"> 162     protected AttributedString prompt;</span>
<span class="line-modified"> 163     protected AttributedString rightPrompt;</span>
 164 
 165     protected MaskingCallback maskingCallback;
 166 
 167     protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
 168     protected Buffer historyBuffer = null;
 169     protected CharSequence searchBuffer;
 170     protected StringBuffer searchTerm = null;
 171     protected boolean searchFailing;
 172     protected boolean searchBackward;
 173     protected int searchIndex = -1;
 174 
 175 
 176     // Reading buffers
 177     protected final BindingReader bindingReader;
 178 
 179 
 180     /**
 181      * VI character find
 182      */
 183     protected int findChar;
 184     protected int findDir;
 185     protected int findTailAdd;
 186     /**
 187      * VI history string search
 188      */
 189     private int searchDir;
 190     private String searchString;
 191 
 192     /**
 193      * Region state
 194      */
 195     protected int regionMark;
 196     protected RegionType regionActive;
 197 
 198     private boolean forceChar;
 199     private boolean forceLine;
 200 
 201     /**
 202      * The vi yank buffer
 203      */
 204     protected String yankBuffer = &quot;&quot;;
 205 
 206     protected ViMoveMode viMoveMode = ViMoveMode.NORMAL;
 207 
 208     protected KillRing killRing = new KillRing();
 209 
 210     protected UndoTree&lt;Buffer&gt; undo = new UndoTree&lt;&gt;(this::setBuffer);
 211     protected boolean isUndo;
 212 
<a name="7" id="anc7"></a>



 213     /*
 214      * Current internal state of the line reader
 215      */
 216     protected State   state = State.DONE;
 217     protected final AtomicBoolean startedReading = new AtomicBoolean();
 218     protected boolean reading;
 219 
 220     protected Supplier&lt;AttributedString&gt; post;
 221 
 222     protected Map&lt;String, Widget&gt; builtinWidgets;
 223     protected Map&lt;String, Widget&gt; widgets;
 224 
 225     protected int count;
 226     protected int mult;
 227     protected int universal = 4;
 228     protected int repeatCount;
 229     protected boolean isArgDigit;
 230 
 231     protected ParsedLine parsedLine;
 232 
 233     protected boolean skipRedisplay;
 234     protected Display display;
 235 
 236     protected boolean overTyping = false;
 237 
 238     protected String keyMap;
 239 
 240     protected int smallTerminalOffset = 0;
 241 
<a name="8" id="anc8"></a>




 242 
 243 
 244     public LineReaderImpl(Terminal terminal) throws IOException {
 245         this(terminal, null, null);
 246     }
 247 
 248     public LineReaderImpl(Terminal terminal, String appName) throws IOException {
 249         this(terminal, appName, null);
 250     }
 251 
 252     public LineReaderImpl(Terminal terminal, String appName, Map&lt;String, Object&gt; variables) {
 253         Objects.requireNonNull(terminal, &quot;terminal can not be null&quot;);
 254         this.terminal = terminal;
 255         if (appName == null) {
 256             appName = &quot;JLine&quot;;
 257         }
 258         this.appName = appName;
 259         if (variables != null) {
 260             this.variables = variables;
 261         } else {
 262             this.variables = new HashMap&lt;&gt;();
 263         }
 264         this.keyMaps = defaultKeyMaps();
 265 
 266         builtinWidgets = builtinWidgets();
 267         widgets = new HashMap&lt;&gt;(builtinWidgets);
 268         bindingReader = new BindingReader(terminal.reader());
<a name="9" id="anc9"></a>
 269     }
 270 
 271     public Terminal getTerminal() {
 272         return terminal;
 273     }
 274 
 275     public String getAppName() {
 276         return appName;
 277     }
 278 
 279     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; getKeyMaps() {
 280         return keyMaps;
 281     }
 282 
 283     public KeyMap&lt;Binding&gt; getKeys() {
 284         return keyMaps.get(keyMap);
 285     }
 286 
 287     @Override
 288     public Map&lt;String, Widget&gt; getWidgets() {
 289         return widgets;
 290     }
 291 
 292     @Override
 293     public Map&lt;String, Widget&gt; getBuiltinWidgets() {
 294         return Collections.unmodifiableMap(builtinWidgets);
 295     }
 296 
 297     @Override
 298     public Buffer getBuffer() {
 299         return buf;
 300     }
 301 
 302     @Override
 303     public void runMacro(String macro) {
 304         bindingReader.runMacro(macro);
 305     }
 306 
 307     @Override
 308     public MouseEvent readMouseEvent() {
 309         return terminal.readMouseEvent(bindingReader::readCharacter);
 310     }
 311 
 312     /**
 313      * Set the completer.
 314      *
 315      * @param completer the completer to use
 316      */
 317     public void setCompleter(Completer completer) {
 318         this.completer = completer;
 319     }
 320 
 321     /**
 322      * Returns the completer.
 323      *
 324      * @return the completer
 325      */
 326     public Completer getCompleter() {
 327         return completer;
 328     }
 329 
 330     //
 331     // History
 332     //
 333 
 334     public void setHistory(final History history) {
 335         Objects.requireNonNull(history);
 336         this.history = history;
 337     }
 338 
 339     public History getHistory() {
 340         return history;
 341     }
 342 
 343     //
 344     // Highlighter
 345     //
 346 
 347     public void setHighlighter(Highlighter highlighter) {
 348         this.highlighter = highlighter;
 349     }
 350 
 351     public Highlighter getHighlighter() {
 352         return highlighter;
 353     }
 354 
 355     public Parser getParser() {
 356         return parser;
 357     }
 358 
 359     public void setParser(Parser parser) {
 360         this.parser = parser;
 361     }
 362 
 363     @Override
 364     public Expander getExpander() {
 365         return expander;
 366     }
 367 
 368     public void setExpander(Expander expander) {
 369         this.expander = expander;
 370     }
 371 
 372     //
 373     // Line Reading
 374     //
 375 
 376     /**
 377      * Read the next line and return the contents of the buffer.
 378      *
 379      * @return          A line that is read from the terminal, can never be null.
 380      */
 381     public String readLine() throws UserInterruptException, EndOfFileException {
 382         return readLine(null, null, (MaskingCallback) null, null);
 383     }
 384 
 385     /**
 386      * Read the next line with the specified character mask. If null, then
 387      * characters will be echoed. If 0, then no characters will be echoed.
 388      *
 389      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 390      * @return          A line that is read from the terminal, can never be null.
 391      */
 392     public String readLine(Character mask) throws UserInterruptException, EndOfFileException {
 393         return readLine(null, null, mask, null);
 394     }
 395 
 396     /**
 397      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 398      * (without any trailing newlines).
 399      *
 400      * @param prompt    The prompt to issue to the terminal, may be null.
 401      * @return          A line that is read from the terminal, can never be null.
 402      */
 403     public String readLine(String prompt) throws UserInterruptException, EndOfFileException {
 404         return readLine(prompt, null, (MaskingCallback) null, null);
 405     }
 406 
 407     /**
 408      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 409      * (without any trailing newlines).
 410      *
 411      * @param prompt    The prompt to issue to the terminal, may be null.
 412      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 413      * @return          A line that is read from the terminal, can never be null.
 414      */
 415     public String readLine(String prompt, Character mask) throws UserInterruptException, EndOfFileException {
 416         return readLine(prompt, null, mask, null);
 417     }
 418 
 419     /**
 420      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 421      * (without any trailing newlines).
 422      *
 423      * @param prompt    The prompt to issue to the terminal, may be null.
 424      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 425      * @param buffer    A string that will be set for editing.
 426      * @return          A line that is read from the terminal, can never be null.
 427      */
 428     public String readLine(String prompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 429         return readLine(prompt, null, mask, buffer);
 430     }
 431 
 432     /**
 433      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 434      * (without any trailing newlines).
 435      *
 436      * @param prompt      The prompt to issue to the terminal, may be null.
 437      * @param rightPrompt The prompt to issue to the right of the terminal, may be null.
 438      * @param mask        The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 439      * @param buffer      A string that will be set for editing.
 440      * @return            A line that is read from the terminal, can never be null.
 441      */
 442     public String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 443         return readLine(prompt, rightPrompt, mask != null ? new SimpleMaskingCallback(mask) : null, buffer);
 444     }
 445 
 446     /**
 447      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 448      * (without any trailing newlines).
 449      *
 450      * @param prompt          The prompt to issue to the terminal, may be null.
 451      * @param rightPrompt     The prompt to issue to the right of the terminal, may be null.
 452      * @param maskingCallback The callback used to mask parts of the edited line.
 453      * @param buffer          A string that will be set for editing.
 454      * @return                A line that is read from the terminal, can never be null.
 455      */
 456     public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {
 457         // prompt may be null
 458         // maskingCallback may be null
 459         // buffer may be null
 460 
 461         if (!startedReading.compareAndSet(false, true)) {
 462             throw new IllegalStateException();
 463         }
 464 
 465         Thread readLineThread = Thread.currentThread();
 466         SignalHandler previousIntrHandler = null;
 467         SignalHandler previousWinchHandler = null;
 468         SignalHandler previousContHandler = null;
 469         Attributes originalAttributes = null;
<a name="10" id="anc10"></a><span class="line-modified"> 470         boolean dumb = Terminal.TYPE_DUMB.equals(terminal.getType())</span>
<span class="line-removed"> 471                     || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());</span>
 472         try {
 473 
 474             this.maskingCallback = maskingCallback;
 475 
 476             /*
 477              * This is the accumulator for VI-mode repeat count. That is, while in
 478              * move mode, if you type 30x it will delete 30 characters. This is
 479              * where the &quot;30&quot; is accumulated until the command is struck.
 480              */
 481             repeatCount = 0;
 482             mult = 1;
 483             regionActive = RegionType.NONE;
 484             regionMark = -1;
 485 
 486             smallTerminalOffset = 0;
 487 
 488             state = State.NORMAL;
 489 
 490             modifiedHistory.clear();
 491 
 492             setPrompt(prompt);
 493             setRightPrompt(rightPrompt);
 494             buf.clear();
 495             if (buffer != null) {
 496                 buf.write(buffer);
 497             }
<a name="11" id="anc11"></a>










 498             undo.clear();
 499             parsedLine = null;
 500             keyMap = MAIN;
 501 
 502             if (history != null) {
 503                 history.attach(this);
 504             }
 505 
<a name="12" id="anc12"></a><span class="line-modified"> 506             synchronized (this) {</span>


 507                 this.reading = true;
 508 
 509                 previousIntrHandler = terminal.handle(Signal.INT, signal -&gt; readLineThread.interrupt());
 510                 previousWinchHandler = terminal.handle(Signal.WINCH, this::handleSignal);
 511                 previousContHandler = terminal.handle(Signal.CONT, this::handleSignal);
 512                 originalAttributes = terminal.enterRawMode();
 513 
<a name="13" id="anc13"></a><span class="line-modified"> 514                 // Cache terminal size for the duration of the call to readLine()</span>
<span class="line-removed"> 515                 // It will eventually be updated with WINCH signals</span>
<span class="line-removed"> 516                 size.copy(terminal.getSize());</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518                 display = new Display(terminal, false);</span>
<span class="line-removed"> 519                 if (size.getRows() == 0 || size.getColumns() == 0) {</span>
<span class="line-removed"> 520                     display.resize(1, Integer.MAX_VALUE);</span>
<span class="line-removed"> 521                 } else {</span>
<span class="line-removed"> 522                     display.resize(size.getRows(), size.getColumns());</span>
<span class="line-removed"> 523                 }</span>
<span class="line-removed"> 524                 if (isSet(Option.DELAY_LINE_WRAP))</span>
<span class="line-removed"> 525                     display.setDelayLineWrap(true);</span>
 526 
 527                 // Move into application mode
 528                 if (!dumb) {
 529                     terminal.puts(Capability.keypad_xmit);
 530                     if (isSet(Option.AUTO_FRESH_LINE))
 531                         callWidget(FRESH_LINE);
 532                     if (isSet(Option.MOUSE))
 533                         terminal.trackMouse(Terminal.MouseTracking.Normal);
 534                     if (isSet(Option.BRACKETED_PASTE))
 535                         terminal.writer().write(BRACKETED_PASTE_ON);
 536                 } else {
 537                     // For dumb terminals, we need to make sure that CR are ignored
 538                     Attributes attr = new Attributes(originalAttributes);
 539                     attr.setInputFlag(Attributes.InputFlag.IGNCR, true);
 540                     terminal.setAttributes(attr);
 541                 }
 542 
 543                 callWidget(CALLBACK_INIT);
 544 
 545                 undo.newState(buf.copy());
 546 
 547                 // Draw initial prompt
 548                 redrawLine();
 549                 redisplay();
<a name="14" id="anc14"></a>

 550             }
 551 
 552             while (true) {
 553 
 554                 KeyMap&lt;Binding&gt; local = null;
 555                 if (isInViCmdMode() &amp;&amp; regionActive != RegionType.NONE) {
 556                     local = keyMaps.get(VISUAL);
 557                 }
 558                 Binding o = readBinding(getKeys(), local);
 559                 if (o == null) {
 560                     throw new EndOfFileException();
 561                 }
 562                 Log.trace(&quot;Binding: &quot;, o);
 563                 if (buf.length() == 0 &amp;&amp; getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {
 564                     throw new EndOfFileException();
 565                 }
 566 
 567                 // If this is still false after handling the binding, then
 568                 // we reset our repeatCount to 0.
 569                 isArgDigit = false;
 570                 // Every command that can be repeated a specified number
 571                 // of times, needs to know how many times to repeat, so
 572                 // we figure that out here.
 573                 count = ((repeatCount == 0) ? 1 : repeatCount) * mult;
 574                 // Reset undo/redo flag
 575                 isUndo = false;
 576                 // Reset region after a paste
 577                 if (regionActive == RegionType.PASTE) {
 578                     regionActive = RegionType.NONE;
 579                 }
 580 
<a name="15" id="anc15"></a><span class="line-modified"> 581                 synchronized (this) {</span>

 582                     // Get executable widget
 583                     Buffer copy = buf.copy();
 584                     Widget w = getWidget(o);
 585                     if (!w.apply()) {
 586                         beep();
 587                     }
 588                     if (!isUndo &amp;&amp; !copy.toString().equals(buf.toString())) {
 589                         undo.newState(buf.copy());
 590                     }
 591 
 592                     switch (state) {
 593                         case DONE:
 594                             return finishBuffer();
 595                         case EOF:
 596                             throw new EndOfFileException();
 597                         case INTERRUPT:
 598                             throw new UserInterruptException(buf.toString());
 599                     }
 600 
 601                     if (!isArgDigit) {
 602                         /*
 603                          * If the operation performed wasn&#39;t a vi argument
 604                          * digit, then clear out the current repeatCount;
 605                          */
 606                         repeatCount = 0;
 607                         mult = 1;
 608                     }
 609 
 610                     if (!dumb) {
 611                         redisplay();
 612                     }
<a name="16" id="anc16"></a>

 613                 }
 614             }
 615         } catch (IOError e) {
 616             if (e.getCause() instanceof InterruptedIOException) {
 617                 throw new UserInterruptException(buf.toString());
 618             } else {
 619                 throw e;
 620             }
 621         }
 622         finally {
<a name="17" id="anc17"></a><span class="line-modified"> 623             synchronized (this) {</span>


 624                 this.reading = false;
 625 
 626                 cleanup();
 627                 if (originalAttributes != null) {
 628                     terminal.setAttributes(originalAttributes);
 629                 }
 630                 if (previousIntrHandler != null) {
 631                     terminal.handle(Signal.INT, previousIntrHandler);
 632                 }
 633                 if (previousWinchHandler != null) {
 634                     terminal.handle(Signal.WINCH, previousWinchHandler);
 635                 }
 636                 if (previousContHandler != null) {
 637                     terminal.handle(Signal.CONT, previousContHandler);
 638                 }
<a name="18" id="anc18"></a>

 639             }
 640             startedReading.set(false);
 641         }
 642     }
 643 
<a name="19" id="anc19"></a><span class="line-modified"> 644     @Override</span>
<span class="line-modified"> 645     public synchronized void printAbove(String str) {</span>
<span class="line-modified"> 646         boolean reading = this.reading;</span>
<span class="line-modified"> 647         if (reading) {</span>
<span class="line-modified"> 648             display.update(Collections.emptyList(), 0);</span>
<span class="line-modified"> 649         }</span>
<span class="line-modified"> 650         if (str.endsWith(&quot;\n&quot;)) {</span>
<span class="line-modified"> 651             terminal.writer().print(str);</span>





 652         } else {
<a name="20" id="anc20"></a><span class="line-modified"> 653             terminal.writer().println(str);</span>
 654         }
<a name="21" id="anc21"></a><span class="line-modified"> 655         if (reading) {</span>
<span class="line-modified"> 656             redisplay(false);</span>






















 657         }
<a name="22" id="anc22"></a><span class="line-removed"> 658         terminal.flush();</span>
 659     }
 660 
 661     @Override
 662     public void printAbove(AttributedString str) {
 663         printAbove(str.toAnsi(terminal));
 664     }
 665 
 666     @Override
<a name="23" id="anc23"></a><span class="line-modified"> 667     public synchronized boolean isReading() {</span>
<span class="line-modified"> 668         return reading;</span>





 669     }
 670 
 671     /* Make sure we position the cursor on column 0 */
 672     protected boolean freshLine() {
 673         boolean wrapAtEol = terminal.getBooleanCapability(Capability.auto_right_margin);
 674         boolean delayedWrapAtEol = wrapAtEol &amp;&amp; terminal.getBooleanCapability(Capability.eat_newline_glitch);
 675         AttributedStringBuilder sb = new AttributedStringBuilder();
 676         sb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLACK + AttributedStyle.BRIGHT));
 677         sb.append(&quot;~&quot;);
 678         sb.style(AttributedStyle.DEFAULT);
 679         if (!wrapAtEol || delayedWrapAtEol) {
 680             for (int i = 0; i &lt; size.getColumns() - 1; i++) {
 681                 sb.append(&quot; &quot;);
 682             }
 683             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 684             sb.append(&quot; &quot;);
 685             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 686         } else {
 687             // Given the terminal will wrap automatically,
 688             // we need to print one less than needed.
 689             // This means that the last character will not
 690             // be overwritten, and that&#39;s why we&#39;re using
 691             // a clr_eol first if possible.
 692             String el = terminal.getStringCapability(Capability.clr_eol);
 693             if (el != null) {
 694                 Curses.tputs(sb, el);
 695             }
 696             for (int i = 0; i &lt; size.getColumns() - 2; i++) {
 697                 sb.append(&quot; &quot;);
 698             }
 699             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 700             sb.append(&quot; &quot;);
 701             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 702         }
<a name="24" id="anc24"></a><span class="line-modified"> 703         print(sb.toAnsi(terminal));</span>
 704         return true;
 705     }
 706 
 707     @Override
<a name="25" id="anc25"></a><span class="line-modified"> 708     public synchronized void callWidget(String name) {</span>
<span class="line-removed"> 709         if (!reading) {</span>
<span class="line-removed"> 710             throw new IllegalStateException(&quot;Widgets can only be called during a `readLine` call&quot;);</span>
<span class="line-removed"> 711         }</span>
 712         try {
<a name="26" id="anc26"></a><span class="line-modified"> 713             Widget w;</span>
<span class="line-modified"> 714             if (name.startsWith(&quot;.&quot;)) {</span>
<span class="line-modified"> 715                 w = builtinWidgets.get(name.substring(1));</span>
<span class="line-removed"> 716             } else {</span>
<span class="line-removed"> 717                 w = widgets.get(name);</span>
 718             }
<a name="27" id="anc27"></a><span class="line-modified"> 719             if (w != null) {</span>
<span class="line-modified"> 720                 w.apply();</span>










 721             }
<a name="28" id="anc28"></a><span class="line-modified"> 722         } catch (Throwable t) {</span>
<span class="line-modified"> 723             Log.debug(&quot;Error executing widget &#39;&quot;, name, &quot;&#39;&quot;, t);</span>
 724         }
 725     }
 726 
 727     /**
 728      * Clear the line and redraw it.
 729      * @return &lt;code&gt;true&lt;/code&gt;
 730      */
 731     public boolean redrawLine() {
 732         display.reset();
 733         return true;
 734     }
 735 
 736     /**
 737      * Write out the specified string to the buffer and the output stream.
 738      * @param str the char sequence to write in the buffer
 739      */
 740     public void putString(final CharSequence str) {
 741         buf.write(str, overTyping);
 742     }
 743 
 744     /**
 745      * Flush the terminal output stream. This is important for printout out single
 746      * characters (like a buf.backspace or keyboard) that we want the terminal to
 747      * handle immediately.
 748      */
 749     public void flush() {
 750         terminal.flush();
 751     }
 752 
 753     public boolean isKeyMap(String name) {
 754         return keyMap.equals(name);
 755     }
 756 
 757     /**
 758      * Read a character from the terminal.
 759      *
 760      * @return the character, or -1 if an EOF is received.
 761      */
 762     public int readCharacter() {
<a name="29" id="anc29"></a><span class="line-modified"> 763         return bindingReader.readCharacter();</span>









 764     }
 765 
 766     public int peekCharacter(long timeout) {
 767         return bindingReader.peekCharacter(timeout);
 768     }
 769 
<a name="30" id="anc30"></a>












 770     /**
 771      * Read from the input stream and decode an operation from the key map.
 772      *
 773      * The input stream will be read character by character until a matching
 774      * binding can be found.  Characters that can&#39;t possibly be matched to
 775      * any binding will be discarded.
 776      *
 777      * @param keys the KeyMap to use for decoding the input stream
 778      * @return the decoded binding or &lt;code&gt;null&lt;/code&gt; if the end of
 779      *         stream has been reached
 780      */
 781     public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
 782         return readBinding(keys, null);
 783     }
 784 
 785     public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
<a name="31" id="anc31"></a><span class="line-modified"> 786         Binding o = bindingReader.readBinding(keys, local);</span>
 787         /*
 788          * The kill ring keeps record of whether or not the
 789          * previous command was a yank or a kill. We reset
 790          * that state here if needed.
 791          */
 792         if (o instanceof Reference) {
 793             String ref = ((Reference) o).name();
 794             if (!YANK_POP.equals(ref) &amp;&amp; !YANK.equals(ref)) {
 795                 killRing.resetLastYank();
 796             }
 797             if (!KILL_LINE.equals(ref) &amp;&amp; !KILL_WHOLE_LINE.equals(ref)
 798                     &amp;&amp; !BACKWARD_KILL_WORD.equals(ref) &amp;&amp; !KILL_WORD.equals(ref)) {
 799                 killRing.resetLastKill();
 800             }
 801         }
 802         return o;
 803     }
 804 
 805     @Override
 806     public ParsedLine getParsedLine() {
 807         return parsedLine;
 808     }
 809 
 810     public String getLastBinding() {
 811         return bindingReader.getLastBinding();
 812     }
 813 
 814     public String getSearchTerm() {
 815         return searchTerm != null ? searchTerm.toString() : null;
 816     }
 817 
 818     @Override
 819     public RegionType getRegionActive() {
 820         return regionActive;
 821     }
 822 
 823     @Override
 824     public int getRegionMark() {
 825         return regionMark;
 826     }
 827 
 828     //
 829     // Key Bindings
 830     //
 831 
 832     /**
 833      * Sets the current keymap by name. Supported keymaps are &quot;emacs&quot;,
 834      * &quot;viins&quot;, &quot;vicmd&quot;.
 835      * @param name The name of the keymap to switch to
 836      * @return true if the keymap was set, or false if the keymap is
 837      *    not recognized.
 838      */
 839     public boolean setKeyMap(String name) {
 840         KeyMap&lt;Binding&gt; map = keyMaps.get(name);
 841         if (map == null) {
 842             return false;
 843         }
 844         this.keyMap = name;
 845         if (reading) {
 846             callWidget(CALLBACK_KEYMAP);
 847         }
 848         return true;
 849     }
 850 
 851     /**
 852      * Returns the name of the current key mapping.
 853      * @return the name of the key mapping. This will be the canonical name
 854      *   of the current mode of the key map and may not reflect the name that
 855      *   was used with {@link #setKeyMap(String)}.
 856      */
 857     public String getKeyMap() {
 858         return keyMap;
 859     }
 860 
 861     @Override
 862     public LineReader variable(String name, Object value) {
 863         variables.put(name, value);
 864         return this;
 865     }
 866 
 867     @Override
 868     public Map&lt;String, Object&gt; getVariables() {
 869         return variables;
 870     }
 871 
 872     @Override
 873     public Object getVariable(String name) {
 874         return variables.get(name);
 875     }
 876 
 877     @Override
 878     public void setVariable(String name, Object value) {
 879         variables.put(name, value);
 880     }
 881 
 882     @Override
 883     public LineReader option(Option option, boolean value) {
 884         options.put(option, value);
 885         return this;
 886     }
 887 
 888     @Override
 889     public boolean isSet(Option option) {
 890         Boolean b = options.get(option);
 891         return b != null ? b : option.isDef();
 892     }
 893 
 894     @Override
 895     public void setOpt(Option option) {
 896         options.put(option, Boolean.TRUE);
 897     }
 898 
 899     @Override
 900     public void unsetOpt(Option option) {
 901         options.put(option, Boolean.FALSE);
 902     }
 903 
 904 
 905 
 906     //
 907     // Widget implementation
 908     //
 909 
 910     /**
 911      * Clear the buffer and add its contents to the history.
 912      *
 913      * @return the former contents of the buffer.
 914      */
 915     protected String finishBuffer() {
 916         String str = buf.toString();
 917         String historyLine = str;
 918 
 919         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
 920             StringBuilder sb = new StringBuilder();
 921             boolean escaped = false;
 922             for (int i = 0; i &lt; str.length(); i++) {
 923                 char ch = str.charAt(i);
 924                 if (escaped) {
 925                     escaped = false;
 926                     if (ch != &#39;\n&#39;) {
 927                         sb.append(ch);
 928                     }
<a name="32" id="anc32"></a><span class="line-modified"> 929                 } else if (ch == &#39;\\&#39;) {</span>
 930                     escaped = true;
 931                 } else {
 932                     sb.append(ch);
 933                 }
 934             }
 935             str = sb.toString();
 936         }
 937 
 938         if (maskingCallback != null) {
 939             historyLine = maskingCallback.history(historyLine);
 940         }
 941 
 942         // we only add it to the history if the buffer is not empty
 943         if (historyLine != null &amp;&amp; historyLine.length() &gt; 0 ) {
 944             history.add(Instant.now(), historyLine);
 945         }
 946         return str;
 947     }
 948 
 949     protected void handleSignal(Signal signal) {
 950         if (signal == Signal.WINCH) {
<a name="33" id="anc33"></a><span class="line-modified"> 951             size.copy(terminal.getSize());</span>




 952             display.resize(size.getRows(), size.getColumns());
<a name="34" id="anc34"></a>
 953             redisplay();
 954         }
 955         else if (signal == Signal.CONT) {
 956             terminal.enterRawMode();
<a name="35" id="anc35"></a><span class="line-modified"> 957             size.copy(terminal.getSize());</span>
 958             display.resize(size.getRows(), size.getColumns());
 959             terminal.puts(Capability.keypad_xmit);
 960             redrawLine();
 961             redisplay();
 962         }
 963     }
 964 
 965     @SuppressWarnings(&quot;unchecked&quot;)
 966     protected Widget getWidget(Object binding) {
 967         Widget w;
 968         if (binding instanceof Widget) {
 969             w = (Widget) binding;
 970         } else if (binding instanceof Macro) {
 971             String macro = ((Macro) binding).getSequence();
 972             w = () -&gt; {
 973                 bindingReader.runMacro(macro);
 974                 return true;
 975             };
 976         } else if (binding instanceof Reference) {
 977             String name = ((Reference) binding).name();
 978             w = widgets.get(name);
 979             if (w == null) {
 980                 w = () -&gt; {
 981                     post = () -&gt; new AttributedString(&quot;No such widget `&quot; + name + &quot;&#39;&quot;);
 982                     return false;
 983                 };
 984             }
 985         } else {
 986             w = () -&gt; {
 987                 post = () -&gt; new AttributedString(&quot;Unsupported widget&quot;);
 988                 return false;
 989             };
 990         }
 991         return w;
 992     }
 993 
 994     //
 995     // Helper methods
 996     //
 997 
 998     public void setPrompt(final String prompt) {
 999         this.prompt = (prompt == null ? AttributedString.EMPTY
1000                        : expandPromptPattern(prompt, 0, &quot;&quot;, 0));
1001     }
1002 
1003     public void setRightPrompt(final String rightPrompt) {
1004         this.rightPrompt = (rightPrompt == null ? AttributedString.EMPTY
1005                             : expandPromptPattern(rightPrompt, 0, &quot;&quot;, 0));
1006     }
1007 
1008     protected void setBuffer(Buffer buffer) {
1009         buf.copyFrom(buffer);
1010     }
1011 
1012     /**
1013      * Set the current buffer&#39;s content to the specified {@link String}. The
1014      * visual terminal will be modified to show the current buffer.
1015      *
1016      * @param buffer the new contents of the buffer.
1017      */
1018     protected void setBuffer(final String buffer) {
1019         buf.clear();
1020         buf.write(buffer);
1021     }
1022 
1023     /**
1024      * This method is calling while doing a delete-to (&quot;d&quot;), change-to (&quot;c&quot;),
1025      * or yank-to (&quot;y&quot;) and it filters out only those movement operations
1026      * that are allowable during those operations. Any operation that isn&#39;t
1027      * allow drops you back into movement mode.
1028      *
1029      * @param op The incoming operation to remap
1030      * @return The remaped operation
1031      */
1032     protected String viDeleteChangeYankToRemap (String op) {
1033         switch (op) {
1034             case SEND_BREAK:
1035             case BACKWARD_CHAR:
1036             case FORWARD_CHAR:
1037             case END_OF_LINE:
1038             case VI_MATCH_BRACKET:
1039             case VI_DIGIT_OR_BEGINNING_OF_LINE:
1040             case NEG_ARGUMENT:
1041             case DIGIT_ARGUMENT:
1042             case VI_BACKWARD_CHAR:
1043             case VI_BACKWARD_WORD:
1044             case VI_FORWARD_CHAR:
1045             case VI_FORWARD_WORD:
1046             case VI_FORWARD_WORD_END:
1047             case VI_FIRST_NON_BLANK:
1048             case VI_GOTO_COLUMN:
1049             case VI_DELETE:
1050             case VI_YANK:
1051             case VI_CHANGE:
1052             case VI_FIND_NEXT_CHAR:
1053             case VI_FIND_NEXT_CHAR_SKIP:
1054             case VI_FIND_PREV_CHAR:
1055             case VI_FIND_PREV_CHAR_SKIP:
1056             case VI_REPEAT_FIND:
1057             case VI_REV_REPEAT_FIND:
1058                 return op;
1059 
1060             default:
1061                 return VI_CMD_MODE;
1062         }
1063     }
1064 
1065     protected int switchCase(int ch) {
1066         if (Character.isUpperCase(ch)) {
1067             return Character.toLowerCase(ch);
1068         } else if (Character.isLowerCase(ch)) {
1069             return Character.toUpperCase(ch);
1070         } else {
1071             return ch;
1072         }
1073     }
1074 
1075     /**
1076      * @return true if line reader is in the middle of doing a change-to
1077      *   delete-to or yank-to.
1078      */
1079     protected boolean isInViMoveOperation() {
1080         return viMoveMode != ViMoveMode.NORMAL;
1081     }
1082 
1083     protected boolean isInViChangeOperation() {
1084         return viMoveMode == ViMoveMode.CHANGE;
1085     }
1086 
1087     protected boolean isInViCmdMode() {
1088         return VICMD.equals(keyMap);
1089     }
1090 
1091 
1092     //
1093     // Movement
1094     //
1095 
1096     protected boolean viForwardChar() {
1097         if (count &lt; 0) {
1098             return callNeg(this::viBackwardChar);
1099         }
1100         int lim = findeol();
1101         if (isInViCmdMode() &amp;&amp; !isInViMoveOperation()) {
1102             lim--;
1103         }
1104         if (buf.cursor() &gt;= lim) {
1105             return false;
1106         }
1107         while (count-- &gt; 0 &amp;&amp; buf.cursor() &lt; lim) {
1108             buf.move(1);
1109         }
1110         return true;
1111     }
1112 
1113     protected boolean viBackwardChar() {
1114         if (count &lt; 0) {
1115             return callNeg(this::viForwardChar);
1116         }
1117         int lim = findbol();
1118         if (buf.cursor() == lim) {
1119             return false;
1120         }
1121         while (count-- &gt; 0 &amp;&amp; buf.cursor() &gt; 0) {
1122             buf.move(-1);
1123             if (buf.currChar() == &#39;\n&#39;) {
1124                 buf.move(1);
1125                 break;
1126             }
1127         }
1128         return true;
1129     }
1130 
1131 
1132     //
1133     // Word movement
1134     //
1135 
1136     protected boolean forwardWord() {
1137         if (count &lt; 0) {
1138             return callNeg(this::backwardWord);
1139         }
1140         while (count-- &gt; 0) {
1141             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1142                 buf.move(1);
1143             }
1144             if (isInViChangeOperation() &amp;&amp; count == 0) {
1145                 break;
1146             }
1147             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1148                 buf.move(1);
1149             }
1150         }
1151         return true;
1152     }
1153 
1154     protected boolean viForwardWord() {
1155         if (count &lt; 0) {
1156             return callNeg(this::backwardWord);
1157         }
1158         while (count-- &gt; 0) {
1159             if (isViAlphaNum(buf.currChar())) {
1160                 while (buf.cursor() &lt; buf.length() &amp;&amp; isViAlphaNum(buf.currChar())) {
1161                     buf.move(1);
1162                 }
1163             } else {
1164                 while (buf.cursor() &lt; buf.length()
1165                         &amp;&amp; !isViAlphaNum(buf.currChar())
1166                         &amp;&amp; !isWhitespace(buf.currChar())) {
1167                     buf.move(1);
1168                 }
1169             }
1170             if (isInViChangeOperation() &amp;&amp; count == 0) {
1171                 return true;
1172             }
1173             int nl = buf.currChar() == &#39;\n&#39; ? 1 : 0;
1174             while (buf.cursor() &lt; buf.length()
1175                     &amp;&amp; nl &lt; 2
1176                     &amp;&amp; isWhitespace(buf.currChar())) {
1177                 buf.move(1);
1178                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1179             }
1180         }
1181         return true;
1182     }
1183 
1184     protected boolean viForwardBlankWord() {
1185         if (count &lt; 0) {
1186             return callNeg(this::viBackwardBlankWord);
1187         }
1188         while (count-- &gt; 0) {
1189             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWhitespace(buf.currChar())) {
1190                 buf.move(1);
1191             }
1192             if (isInViChangeOperation() &amp;&amp; count == 0) {
1193                 return true;
1194             }
1195             int nl = buf.currChar() == &#39;\n&#39; ? 1 : 0;
1196             while (buf.cursor() &lt; buf.length()
1197                     &amp;&amp; nl &lt; 2
1198                     &amp;&amp; isWhitespace(buf.currChar())) {
1199                 buf.move(1);
1200                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1201             }
1202         }
1203         return true;
1204     }
1205 
1206     protected boolean emacsForwardWord() {
1207         if (count &lt; 0) {
1208             return callNeg(this::emacsBackwardWord);
1209         }
1210         while (count-- &gt; 0) {
1211             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1212                 buf.move(1);
1213             }
1214             if (isInViChangeOperation() &amp;&amp; count == 0) {
1215                 return true;
1216             }
1217             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1218                 buf.move(1);
1219             }
1220         }
1221         return true;
1222     }
1223 
1224     protected boolean viForwardBlankWordEnd() {
1225         if (count &lt; 0) {
1226             return false;
1227         }
1228         while (count-- &gt; 0) {
1229             while (buf.cursor() &lt; buf.length()) {
1230                 buf.move(1);
1231                 if (!isWhitespace(buf.currChar())) {
1232                     break;
1233                 }
1234             }
1235             while (buf.cursor() &lt; buf.length()) {
1236                 buf.move(1);
1237                 if (isWhitespace(buf.currChar())) {
1238                     break;
1239                 }
1240             }
1241         }
1242         return true;
1243     }
1244 
1245     protected boolean viForwardWordEnd() {
1246         if (count &lt; 0) {
1247             return callNeg(this::backwardWord);
1248         }
1249         while (count-- &gt; 0) {
1250             while (buf.cursor() &lt; buf.length()) {
1251                 if (!isWhitespace(buf.nextChar())) {
1252                     break;
1253                 }
1254                 buf.move(1);
1255             }
1256             if (buf.cursor() &lt; buf.length()) {
1257                 if (isViAlphaNum(buf.nextChar())) {
1258                     buf.move(1);
1259                     while (buf.cursor() &lt; buf.length() &amp;&amp; isViAlphaNum(buf.nextChar())) {
1260                         buf.move(1);
1261                     }
1262                 } else {
1263                     buf.move(1);
1264                     while (buf.cursor() &lt; buf.length() &amp;&amp; !isViAlphaNum(buf.nextChar()) &amp;&amp; !isWhitespace(buf.nextChar())) {
1265                         buf.move(1);
1266                     }
1267                 }
1268             }
1269         }
1270         if (buf.cursor() &lt; buf.length() &amp;&amp; isInViMoveOperation()) {
1271             buf.move(1);
1272         }
1273         return true;
1274     }
1275 
1276     protected boolean backwardWord() {
1277         if (count &lt; 0) {
1278             return callNeg(this::forwardWord);
1279         }
1280         while (count-- &gt; 0) {
1281             while (buf.cursor() &gt; 0 &amp;&amp; !isWord(buf.atChar(buf.cursor() - 1))) {
1282                 buf.move(-1);
1283             }
1284             while (buf.cursor() &gt; 0 &amp;&amp; isWord(buf.atChar(buf.cursor() - 1))) {
1285                 buf.move(-1);
1286             }
1287         }
1288         return true;
1289     }
1290 
1291     protected boolean viBackwardWord() {
1292         if (count &lt; 0) {
1293             return callNeg(this::backwardWord);
1294         }
1295         while (count-- &gt; 0) {
1296             int nl = 0;
1297             while (buf.cursor() &gt; 0) {
1298                 buf.move(-1);
1299                 if (!isWhitespace(buf.currChar())) {
1300                     break;
1301                 }
1302                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1303                 if (nl == 2) {
1304                     buf.move(1);
1305                     break;
1306                 }
1307             }
1308             if (buf.cursor() &gt; 0) {
1309                 if (isViAlphaNum(buf.currChar())) {
1310                     while (buf.cursor() &gt; 0) {
1311                         if (!isViAlphaNum(buf.prevChar())) {
1312                             break;
1313                         }
1314                         buf.move(-1);
1315                     }
1316                 } else {
1317                     while (buf.cursor() &gt; 0) {
1318                         if (isViAlphaNum(buf.prevChar()) || isWhitespace(buf.prevChar())) {
1319                             break;
1320                         }
1321                         buf.move(-1);
1322                     }
1323                 }
1324             }
1325         }
1326         return true;
1327     }
1328 
1329     protected boolean viBackwardBlankWord() {
1330         if (count &lt; 0) {
1331             return callNeg(this::viForwardBlankWord);
1332         }
1333         while (count-- &gt; 0) {
1334             while (buf.cursor() &gt; 0) {
1335                 buf.move(-1);
1336                 if (!isWhitespace(buf.currChar())) {
1337                     break;
1338                 }
1339             }
1340             while (buf.cursor() &gt; 0) {
1341                 buf.move(-1);
1342                 if (isWhitespace(buf.currChar())) {
1343                     break;
1344                 }
1345             }
1346         }
1347         return true;
1348     }
1349 
1350     protected boolean viBackwardWordEnd() {
1351         if (count &lt; 0) {
1352             return callNeg(this::viForwardWordEnd);
1353         }
1354         while (count-- &gt; 0 &amp;&amp; buf.cursor() &gt; 1) {
1355             int start;
1356             if (isViAlphaNum(buf.currChar())) {
1357                 start = 1;
1358             } else if (!isWhitespace(buf.currChar())) {
1359                 start = 2;
1360             } else {
1361                 start = 0;
1362             }
1363             while (buf.cursor() &gt; 0) {
1364                 boolean same = (start != 1) &amp;&amp; isWhitespace(buf.currChar());
1365                 if (start != 0) {
1366                     same |= isViAlphaNum(buf.currChar());
1367                 }
1368                 if (same == (start == 2)) {
1369                     break;
1370                 }
1371                 buf.move(-1);
1372             }
1373             while (buf.cursor() &gt; 0 &amp;&amp; isWhitespace(buf.currChar())) {
1374                 buf.move(-1);
1375             }
1376         }
1377         return true;
1378     }
1379 
1380     protected boolean viBackwardBlankWordEnd() {
1381         if (count &lt; 0) {
1382             return callNeg(this::viForwardBlankWordEnd);
1383         }
1384         while (count-- &gt; 0) {
1385             while (buf.cursor() &gt; 0 &amp;&amp; !isWhitespace(buf.currChar())) {
1386                 buf.move(-1);
1387             }
1388             while (buf.cursor() &gt; 0 &amp;&amp; isWhitespace(buf.currChar())) {
1389                 buf.move(-1);
1390             }
1391         }
1392         return true;
1393     }
1394 
1395     protected boolean emacsBackwardWord() {
1396         if (count &lt; 0) {
1397             return callNeg(this::emacsForwardWord);
1398         }
1399         while (count-- &gt; 0) {
1400             while (buf.cursor() &gt; 0) {
1401                 buf.move(-1);
1402                 if (isWord(buf.currChar())) {
1403                     break;
1404                 }
1405             }
1406             while (buf.cursor() &gt; 0) {
1407                 buf.move(-1);
1408                 if (!isWord(buf.currChar())) {
1409                     break;
1410                 }
1411             }
1412         }
1413         return true;
1414     }
1415 
1416     protected boolean backwardDeleteWord() {
1417         if (count &lt; 0) {
1418             return callNeg(this::deleteWord);
1419         }
1420         int cursor = buf.cursor();
1421         while (count-- &gt; 0) {
1422             while (cursor &gt; 0 &amp;&amp; !isWord(buf.atChar(cursor - 1))) {
1423                 cursor--;
1424             }
1425             while (cursor &gt; 0 &amp;&amp; isWord(buf.atChar(cursor - 1))) {
1426                 cursor--;
1427             }
1428         }
1429         buf.backspace(buf.cursor() - cursor);
1430         return true;
1431     }
1432 
1433     protected boolean viBackwardKillWord() {
1434         if (count &lt; 0) {
1435             return false;
1436         }
1437         int lim = findbol();
1438         int x = buf.cursor();
1439         while (count-- &gt; 0) {
1440             while (x &gt; lim &amp;&amp; isWhitespace(buf.atChar(x - 1))) {
1441                 x--;
1442             }
1443             if (x &gt; lim) {
1444                 if (isViAlphaNum(buf.atChar(x - 1))) {
1445                     while (x &gt; lim &amp;&amp; isViAlphaNum(buf.atChar(x - 1))) {
1446                         x--;
1447                     }
1448                 } else {
1449                     while (x &gt; lim &amp;&amp; !isViAlphaNum(buf.atChar(x - 1)) &amp;&amp; !isWhitespace(buf.atChar(x - 1))) {
1450                         x--;
1451                     }
1452                 }
1453             }
1454         }
1455         killRing.addBackwards(buf.substring(x, buf.cursor()));
1456         buf.backspace(buf.cursor() - x);
1457         return true;
1458     }
1459 
1460     protected boolean backwardKillWord() {
1461         if (count &lt; 0) {
1462             return callNeg(this::killWord);
1463         }
1464         int x = buf.cursor();
1465         while (count-- &gt; 0) {
1466             while (x &gt; 0 &amp;&amp; !isWord(buf.atChar(x - 1))) {
1467                 x--;
1468             }
1469             while (x &gt; 0 &amp;&amp; isWord(buf.atChar(x - 1))) {
1470                 x--;
1471             }
1472         }
1473         killRing.addBackwards(buf.substring(x, buf.cursor()));
1474         buf.backspace(buf.cursor() - x);
1475         return true;
1476     }
1477 
1478     protected boolean copyPrevWord() {
1479         if (count &lt;= 0) {
1480             return false;
1481         }
1482         int t1, t0 = buf.cursor();
1483         while (true) {
1484             t1 = t0;
1485             while (t0 &gt; 0 &amp;&amp; !isWord(buf.atChar(t0 - 1))) {
1486                 t0--;
1487             }
1488             while (t0 &gt; 0 &amp;&amp; isWord(buf.atChar(t0 - 1))) {
1489                 t0--;
1490             }
1491             if (--count == 0) {
1492                 break;
1493             }
1494             if (t0 == 0) {
1495                 return false;
1496             }
1497         }
1498         buf.write(buf.substring(t0, t1));
1499         return true;
1500     }
1501 
1502     protected boolean upCaseWord() {
1503         int count = Math.abs(this.count);
1504         int cursor = buf.cursor();
1505         while (count-- &gt; 0) {
1506             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1507                 buf.move(1);
1508             }
1509             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1510                 buf.currChar(Character.toUpperCase(buf.currChar()));
1511                 buf.move(1);
1512             }
1513         }
1514         if (this.count &lt; 0) {
1515             buf.cursor(cursor);
1516         }
1517         return true;
1518     }
1519 
1520     protected boolean downCaseWord() {
1521         int count = Math.abs(this.count);
1522         int cursor = buf.cursor();
1523         while (count-- &gt; 0) {
1524             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1525                 buf.move(1);
1526             }
1527             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1528                 buf.currChar(Character.toLowerCase(buf.currChar()));
1529                 buf.move(1);
1530             }
1531         }
1532         if (this.count &lt; 0) {
1533             buf.cursor(cursor);
1534         }
1535         return true;
1536     }
1537 
1538     protected boolean capitalizeWord() {
1539         int count = Math.abs(this.count);
1540         int cursor = buf.cursor();
1541         while (count-- &gt; 0) {
1542             boolean first = true;
1543             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1544                 buf.move(1);
1545             }
1546             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar()) &amp;&amp; !isAlpha(buf.currChar())) {
1547                 buf.move(1);
1548             }
1549             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1550                 buf.currChar(first
1551                         ? Character.toUpperCase(buf.currChar())
1552                         : Character.toLowerCase(buf.currChar()));
1553                 buf.move(1);
1554                 first = false;
1555             }
1556         }
1557         if (this.count &lt; 0) {
1558             buf.cursor(cursor);
1559         }
1560         return true;
1561     }
1562 
1563     protected boolean deleteWord() {
1564         if (count &lt; 0) {
1565             return callNeg(this::backwardDeleteWord);
1566         }
1567         int x = buf.cursor();
1568         while (count-- &gt; 0) {
1569             while (x &lt; buf.length() &amp;&amp; !isWord(buf.atChar(x))) {
1570                 x++;
1571             }
1572             while (x &lt; buf.length() &amp;&amp; isWord(buf.atChar(x))) {
1573                 x++;
1574             }
1575         }
1576         buf.delete(x - buf.cursor());
1577         return true;
1578     }
1579 
1580     protected boolean killWord() {
1581         if (count &lt; 0) {
1582             return callNeg(this::backwardKillWord);
1583         }
1584         int x = buf.cursor();
1585         while (count-- &gt; 0) {
1586             while (x &lt; buf.length() &amp;&amp; !isWord(buf.atChar(x))) {
1587                 x++;
1588             }
1589             while (x &lt; buf.length() &amp;&amp; isWord(buf.atChar(x))) {
1590                 x++;
1591             }
1592         }
1593         killRing.add(buf.substring(buf.cursor(), x));
1594         buf.delete(x - buf.cursor());
1595         return true;
1596     }
1597 
1598     protected boolean transposeWords() {
1599         int lstart = buf.cursor() - 1;
1600         int lend = buf.cursor();
1601         while (buf.atChar(lstart) != 0 &amp;&amp; buf.atChar(lstart) != &#39;\n&#39;) {
1602             lstart--;
1603         }
1604         lstart++;
1605         while (buf.atChar(lend) != 0 &amp;&amp; buf.atChar(lend) != &#39;\n&#39;) {
1606             lend++;
1607         }
1608         if (lend - lstart &lt; 2) {
1609             return false;
1610         }
1611         int words = 0;
1612         boolean inWord = false;
1613         if (!isDelimiter(buf.atChar(lstart))) {
1614             words++;
1615             inWord = true;
1616         }
1617         for (int i = lstart; i &lt; lend; i++) {
1618             if (isDelimiter(buf.atChar(i))) {
1619                 inWord = false;
1620             } else {
1621                 if (!inWord) {
1622                     words++;
1623                 }
1624                 inWord = true;
1625             }
1626         }
1627         if (words &lt; 2) {
1628             return false;
1629         }
1630         // TODO: use isWord instead of isDelimiter
1631         boolean neg = this.count &lt; 0;
1632         for (int count = Math.max(this.count, -this.count); count &gt; 0; --count) {
1633             int sta1, end1, sta2, end2;
1634             // Compute current word boundaries
1635             sta1 = buf.cursor();
1636             while (sta1 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta1 - 1))) {
1637                 sta1--;
1638             }
1639             end1 = sta1;
1640             while (end1 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end1)));
1641             if (neg) {
1642                 end2 = sta1 - 1;
1643                 while (end2 &gt; lstart &amp;&amp; isDelimiter(buf.atChar(end2 - 1))) {
1644                     end2--;
1645                 }
1646                 if (end2 &lt; lstart) {
1647                     // No word before, use the word after
1648                     sta2 = end1;
1649                     while (isDelimiter(buf.atChar(++sta2)));
1650                     end2 = sta2;
1651                     while (end2 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end2)));
1652                 } else {
1653                     sta2 = end2;
1654                     while (sta2 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta2 - 1))) {
1655                         sta2--;
1656                     }
1657                 }
1658             } else {
1659                 sta2 = end1;
1660                 while (sta2 &lt; lend &amp;&amp; isDelimiter(buf.atChar(++sta2)));
1661                 if (sta2 == lend) {
1662                     // No word after, use the word before
1663                     end2 = sta1;
1664                     while (isDelimiter(buf.atChar(end2 - 1))) {
1665                         end2--;
1666                     }
1667                     sta2 = end2;
1668                     while (sta2 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta2 - 1))) {
1669                         sta2--;
1670                     }
1671                 } else {
1672                     end2 = sta2;
1673                     while (end2 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end2))) ;
1674                 }
1675             }
1676             if (sta1 &lt; sta2) {
1677                 String res = buf.substring(0, sta1) + buf.substring(sta2, end2)
1678                         + buf.substring(end1, sta2) + buf.substring(sta1, end1)
1679                         + buf.substring(end2);
1680                 buf.clear();
1681                 buf.write(res);
1682                 buf.cursor(neg ? end1 : end2);
1683             } else {
1684                 String res = buf.substring(0, sta2) + buf.substring(sta1, end1)
1685                         + buf.substring(end2, sta1) + buf.substring(sta2, end2)
1686                         + buf.substring(end1);
1687                 buf.clear();
1688                 buf.write(res);
1689                 buf.cursor(neg ? end2 : end1);
1690             }
1691         }
1692         return true;
1693     }
1694 
1695     private int findbol() {
1696         int x = buf.cursor();
1697         while (x &gt; 0 &amp;&amp; buf.atChar(x - 1) != &#39;\n&#39;) {
1698             x--;
1699         }
1700         return x;
1701     }
1702 
1703     private int findeol() {
1704         int x = buf.cursor();
1705         while (x &lt; buf.length() &amp;&amp; buf.atChar(x) != &#39;\n&#39;) {
1706             x++;
1707         }
1708         return x;
1709     }
1710 
1711     protected boolean insertComment() {
1712         return doInsertComment(false);
1713     }
1714 
1715     protected boolean viInsertComment() {
1716         return doInsertComment(true);
1717     }
1718 
1719     protected boolean doInsertComment(boolean isViMode) {
1720         String comment = getString(COMMENT_BEGIN, DEFAULT_COMMENT_BEGIN);
1721         beginningOfLine();
1722         putString(comment);
1723         if (isViMode) {
1724             setKeyMap(VIINS);
1725         }
1726         return acceptLine();
1727     }
1728 
1729     protected boolean viFindNextChar() {
1730         if ((findChar = vigetkey()) &gt; 0) {
1731             findDir = 1;
1732             findTailAdd = 0;
1733             return vifindchar(false);
1734         }
1735         return false;
1736     }
1737 
1738     protected boolean viFindPrevChar() {
1739         if ((findChar = vigetkey()) &gt; 0) {
1740             findDir = -1;
1741             findTailAdd = 0;
1742             return vifindchar(false);
1743         }
1744         return false;
1745     }
1746 
1747     protected boolean viFindNextCharSkip() {
1748         if ((findChar = vigetkey()) &gt; 0) {
1749             findDir = 1;
1750             findTailAdd = -1;
1751             return vifindchar(false);
1752         }
1753         return false;
1754     }
1755 
1756     protected boolean viFindPrevCharSkip() {
1757         if ((findChar = vigetkey()) &gt; 0) {
1758             findDir = -1;
1759             findTailAdd = 1;
1760             return vifindchar(false);
1761         }
1762         return false;
1763     }
1764 
1765     protected boolean viRepeatFind() {
1766         return vifindchar(true);
1767     }
1768 
1769     protected boolean viRevRepeatFind() {
1770         if (count &lt; 0) {
1771             return callNeg(() -&gt; vifindchar(true));
1772         }
1773         findTailAdd = -findTailAdd;
1774         findDir = -findDir;
1775         boolean ret = vifindchar(true);
1776         findTailAdd = -findTailAdd;
1777         findDir = -findDir;
1778         return ret;
1779     }
1780 
1781     private int vigetkey() {
1782         int ch = readCharacter();
1783         KeyMap&lt;Binding&gt; km = keyMaps.get(MAIN);
1784         if (km != null) {
1785             Binding b = km.getBound(new String(Character.toChars(ch)));
1786             if (b instanceof Reference) {
1787                 String func = ((Reference) b).name();
1788                 if (SEND_BREAK.equals(func)) {
1789                     return -1;
1790                 }
1791             }
1792         }
1793         return ch;
1794     }
1795 
1796     private boolean vifindchar(boolean repeat) {
1797         if (findDir == 0) {
1798             return false;
1799         }
1800         if (count &lt; 0) {
1801             return callNeg(this::viRevRepeatFind);
1802         }
1803         if (repeat &amp;&amp; findTailAdd != 0) {
1804             if (findDir &gt; 0) {
1805                 if (buf.cursor() &lt; buf.length() &amp;&amp; buf.nextChar() == findChar) {
1806                     buf.move(1);
1807                 }
1808             } else {
1809                 if (buf.cursor() &gt; 0 &amp;&amp; buf.prevChar() == findChar) {
1810                     buf.move(-1);
1811                 }
1812             }
1813         }
1814         int cursor = buf.cursor();
1815         while (count-- &gt; 0) {
1816             do {
1817                 buf.move(findDir);
1818             } while (buf.cursor() &gt; 0 &amp;&amp; buf.cursor() &lt; buf.length()
1819                     &amp;&amp; buf.currChar() != findChar
1820                     &amp;&amp; buf.currChar() != &#39;\n&#39;);
1821             if (buf.cursor() &lt;= 0 || buf.cursor() &gt;= buf.length()
1822                     || buf.currChar() == &#39;\n&#39;) {
1823                 buf.cursor(cursor);
1824                 return false;
1825             }
1826         }
1827         if (findTailAdd != 0) {
1828             buf.move(findTailAdd);
1829         }
1830         if (findDir == 1 &amp;&amp; isInViMoveOperation()) {
1831             buf.move(1);
1832         }
1833         return true;
1834     }
1835 
1836     private boolean callNeg(Widget widget) {
1837         this.count = -this.count;
1838         boolean ret = widget.apply();
1839         this.count = -this.count;
1840         return ret;
1841     }
1842 
1843     /**
1844      * Implements vi search (&quot;/&quot; or &quot;?&quot;).
1845      *
1846      * @return &lt;code&gt;true&lt;/code&gt; if the search was successful
1847      */
1848     protected boolean viHistorySearchForward() {
1849         searchDir = 1;
1850         searchIndex = 0;
1851         return getViSearchString() &amp;&amp; viRepeatSearch();
1852     }
1853 
1854     protected boolean viHistorySearchBackward() {
1855         searchDir = -1;
1856         searchIndex = history.size() - 1;
1857         return getViSearchString() &amp;&amp; viRepeatSearch();
1858     }
1859 
1860     protected boolean viRepeatSearch() {
1861         if (searchDir == 0) {
1862             return false;
1863         }
1864         int si = searchDir &lt; 0
1865                 ? searchBackwards(searchString, searchIndex, false)
1866                 : searchForwards(searchString, searchIndex, false);
1867         if (si == -1 || si == history.index()) {
1868             return false;
1869         }
1870         searchIndex = si;
1871 
1872         /*
1873          * Show the match.
1874          */
1875         buf.clear();
1876         history.moveTo(searchIndex);
1877         buf.write(history.get(searchIndex));
1878         if (VICMD.equals(keyMap)) {
1879             buf.move(-1);
1880         }
1881         return true;
1882     }
1883 
1884     protected boolean viRevRepeatSearch() {
1885         boolean ret;
1886         searchDir = -searchDir;
1887         ret = viRepeatSearch();
1888         searchDir = -searchDir;
1889         return ret;
1890     }
1891 
1892     private boolean getViSearchString() {
1893         if (searchDir == 0) {
1894             return false;
1895         }
1896         String searchPrompt = searchDir &lt; 0 ? &quot;?&quot; : &quot;/&quot;;
1897         Buffer searchBuffer = new BufferImpl();
1898 
1899         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MAIN);
1900         if (keyMap == null) {
1901             keyMap = keyMaps.get(SAFE);
1902         }
1903         while (true) {
1904             post = () -&gt; new AttributedString(searchPrompt + searchBuffer.toString() + &quot;_&quot;);
1905             redisplay();
<a name="36" id="anc36"></a><span class="line-modified">1906             Binding b = bindingReader.readBinding(keyMap);</span>
1907             if (b instanceof Reference) {
1908                 String func = ((Reference) b).name();
1909                 switch (func) {
1910                     case SEND_BREAK:
1911                         post = null;
1912                         return false;
1913                     case ACCEPT_LINE:
1914                     case VI_CMD_MODE:
1915                         searchString = searchBuffer.toString();
1916                         post = null;
1917                         return true;
1918                     case MAGIC_SPACE:
1919                         searchBuffer.write(&#39; &#39;);
1920                         break;
1921                     case REDISPLAY:
1922                         redisplay();
1923                         break;
1924                     case CLEAR_SCREEN:
1925                         clearScreen();
1926                         break;
1927                     case SELF_INSERT:
1928                         searchBuffer.write(getLastBinding());
1929                         break;
1930                     case SELF_INSERT_UNMETA:
1931                         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
1932                             String s = getLastBinding().substring(1);
1933                             if (&quot;\r&quot;.equals(s)) {
1934                                 s = &quot;\n&quot;;
1935                             }
1936                             searchBuffer.write(s);
1937                         }
1938                         break;
1939                     case BACKWARD_DELETE_CHAR:
1940                     case VI_BACKWARD_DELETE_CHAR:
1941                         if (searchBuffer.length() &gt; 0) {
1942                             searchBuffer.backspace();
1943                         }
1944                         break;
1945                     case BACKWARD_KILL_WORD:
1946                     case VI_BACKWARD_KILL_WORD:
1947                         if (searchBuffer.length() &gt; 0 &amp;&amp; !isWhitespace(searchBuffer.prevChar())) {
1948                             searchBuffer.backspace();
1949                         }
1950                         if (searchBuffer.length() &gt; 0 &amp;&amp; isWhitespace(searchBuffer.prevChar())) {
1951                             searchBuffer.backspace();
1952                         }
1953                         break;
1954                     case QUOTED_INSERT:
1955                     case VI_QUOTED_INSERT:
1956                         int c = readCharacter();
1957                         if (c &gt;= 0) {
1958                             searchBuffer.write(c);
1959                         } else {
1960                             beep();
1961                         }
1962                         break;
1963                     default:
1964                         beep();
1965                         break;
1966                 }
1967             }
1968         }
1969     }
1970 
1971     protected boolean insertCloseCurly() {
1972         return insertClose(&quot;}&quot;);
1973     }
1974 
1975     protected boolean insertCloseParen() {
1976         return insertClose(&quot;)&quot;);
1977     }
1978 
1979     protected boolean insertCloseSquare() {
1980         return insertClose(&quot;]&quot;);
1981     }
1982 
1983     protected boolean insertClose(String s) {
1984         putString(s);
1985 
1986         long blink = getLong(BLINK_MATCHING_PAREN, DEFAULT_BLINK_MATCHING_PAREN);
1987         if (blink &lt;= 0) {
1988             return true;
1989         }
1990 
1991         int closePosition = buf.cursor();
1992 
1993         buf.move(-1);
1994         doViMatchBracket();
1995         redisplay();
1996 
1997         peekCharacter(blink);
1998 
1999         buf.cursor(closePosition);
2000         return true;
2001     }
2002 
2003     protected boolean viMatchBracket() {
2004         return doViMatchBracket();
2005     }
2006 
2007     protected boolean undefinedKey() {
2008         return false;
2009     }
2010 
2011     /**
2012      * Implements vi style bracket matching (&quot;%&quot; command). The matching
2013      * bracket for the current bracket type that you are sitting on is matched.
2014      *
2015      * @return true if it worked, false if the cursor was not on a bracket
2016      *   character or if there was no matching bracket.
2017      */
2018     protected boolean doViMatchBracket() {
2019         int pos        = buf.cursor();
2020 
2021         if (pos == buf.length()) {
2022             return false;
2023         }
2024 
2025         int type       = getBracketType(buf.atChar(pos));
2026         int move       = (type &lt; 0) ? -1 : 1;
2027         int count      = 1;
2028 
2029         if (type == 0)
2030             return false;
2031 
2032         while (count &gt; 0) {
2033             pos += move;
2034 
2035             // Fell off the start or end.
2036             if (pos &lt; 0 || pos &gt;= buf.length()) {
2037                 return false;
2038             }
2039 
2040             int curType = getBracketType(buf.atChar(pos));
2041             if (curType == type) {
2042                 ++count;
2043             }
2044             else if (curType == -type) {
2045                 --count;
2046             }
2047         }
2048 
2049         /*
2050          * Slight adjustment for delete-to, yank-to, change-to to ensure
2051          * that the matching paren is consumed
2052          */
2053         if (move &gt; 0 &amp;&amp; isInViMoveOperation())
2054             ++pos;
2055 
2056         buf.cursor(pos);
2057         return true;
2058     }
2059 
2060     /**
2061      * Given a character determines what type of bracket it is (paren,
2062      * square, curly, or none).
2063      * @param ch The character to check
2064      * @return 1 is square, 2 curly, 3 parent, or zero for none.  The value
2065      *   will be negated if it is the closing form of the bracket.
2066      */
2067     protected int getBracketType (int ch) {
2068         switch (ch) {
2069             case &#39;[&#39;: return  1;
2070             case &#39;]&#39;: return -1;
2071             case &#39;{&#39;: return  2;
2072             case &#39;}&#39;: return -2;
2073             case &#39;(&#39;: return  3;
2074             case &#39;)&#39;: return -3;
2075             default:
2076                 return 0;
2077         }
2078     }
2079 
2080     /**
2081      * Performs character transpose. The character prior to the cursor and the
2082      * character under the cursor are swapped and the cursor is advanced one.
2083      * Do not cross line breaks.
2084      * @return true
2085      */
2086     protected boolean transposeChars() {
2087         int lstart = buf.cursor() - 1;
2088         int lend = buf.cursor();
2089         while (buf.atChar(lstart) != 0 &amp;&amp; buf.atChar(lstart) != &#39;\n&#39;) {
2090             lstart--;
2091         }
2092         lstart++;
2093         while (buf.atChar(lend) != 0 &amp;&amp; buf.atChar(lend) != &#39;\n&#39;) {
2094             lend++;
2095         }
2096         if (lend - lstart &lt; 2) {
2097             return false;
2098         }
2099         boolean neg = this.count &lt; 0;
2100         for (int count = Math.max(this.count, -this.count); count &gt; 0; --count) {
2101             while (buf.cursor() &lt;= lstart) {
2102                 buf.move(1);
2103             }
2104             while (buf.cursor() &gt;= lend) {
2105                 buf.move(-1);
2106             }
2107             int c = buf.currChar();
2108             buf.currChar(buf.prevChar());
2109             buf.move(-1);
2110             buf.currChar(c);
2111             buf.move(neg ? 0 : 2);
2112         }
2113         return true;
2114     }
2115 
2116     protected boolean undo() {
2117         isUndo = true;
2118         if (undo.canUndo()) {
2119             undo.undo();
2120             return true;
2121         }
2122         return false;
2123     }
2124 
2125     protected boolean redo() {
2126         isUndo = true;
2127         if (undo.canRedo()) {
2128             undo.redo();
2129             return true;
2130         }
2131         return false;
2132     }
2133 
2134     protected boolean sendBreak() {
2135         if (searchTerm == null) {
2136             buf.clear();
2137             println();
2138             redrawLine();
2139 //            state = State.INTERRUPT;
2140             return false;
2141         }
2142         return true;
2143     }
2144 
2145     protected boolean backwardChar() {
2146         return buf.move(-count) != 0;
2147     }
2148 
2149     protected boolean forwardChar() {
2150         return buf.move(count) != 0;
2151     }
2152 
2153     protected boolean viDigitOrBeginningOfLine() {
2154         if (repeatCount &gt; 0) {
2155             return digitArgument();
2156         } else {
2157             return beginningOfLine();
2158         }
2159     }
2160 
2161     protected boolean universalArgument() {
2162         mult *= universal;
2163         isArgDigit = true;
2164         return true;
2165     }
2166 
2167     protected boolean argumentBase() {
2168         if (repeatCount &gt; 0 &amp;&amp; repeatCount &lt; 32) {
2169             universal = repeatCount;
2170             isArgDigit = true;
2171             return true;
2172         } else {
2173             return false;
2174         }
2175     }
2176 
2177     protected boolean negArgument() {
2178         mult *= -1;
2179         isArgDigit = true;
2180         return true;
2181     }
2182 
2183     protected boolean digitArgument() {
2184         String s = getLastBinding();
2185         repeatCount = (repeatCount * 10) + s.charAt(s.length() - 1) - &#39;0&#39;;
2186         isArgDigit = true;
2187         return true;
2188     }
2189 
2190     protected boolean viDelete() {
2191         int cursorStart = buf.cursor();
2192         Binding o = readBinding(getKeys());
2193         if (o instanceof Reference) {
2194             // TODO: be smarter on how to get the vi range
2195             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2196             // This is a weird special case. In vi
2197             // &quot;dd&quot; deletes the current line. So if we
2198             // get a delete-to, followed by a delete-to,
2199             // we delete the line.
2200             if (VI_DELETE.equals(op)) {
2201                 killWholeLine();
2202             } else {
2203                 viMoveMode = ViMoveMode.DELETE;
2204                 Widget widget = widgets.get(op);
2205                 if (widget != null &amp;&amp; !widget.apply()) {
2206                     viMoveMode = ViMoveMode.NORMAL;
2207                     return false;
2208                 }
2209                 viMoveMode = ViMoveMode.NORMAL;
2210             }
2211             return viDeleteTo(cursorStart, buf.cursor());
2212         } else {
2213             pushBackBinding();
2214             return false;
2215         }
2216     }
2217 
2218     protected boolean viYankTo() {
2219         int cursorStart = buf.cursor();
2220         Binding o = readBinding(getKeys());
2221         if (o instanceof Reference) {
2222             // TODO: be smarter on how to get the vi range
2223             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2224             // Similar to delete-to, a &quot;yy&quot; yanks the whole line.
2225             if (VI_YANK.equals(op)) {
2226                 yankBuffer = buf.toString();
2227                 return true;
2228             } else {
2229                 viMoveMode = ViMoveMode.YANK;
2230                 Widget widget = widgets.get(op);
2231                 if (widget != null &amp;&amp; !widget.apply()) {
2232                     return false;
2233                 }
2234                 viMoveMode = ViMoveMode.NORMAL;
2235             }
2236             return viYankTo(cursorStart, buf.cursor());
2237         } else {
2238             pushBackBinding();
2239             return false;
2240         }
2241     }
2242 
2243     protected boolean viYankWholeLine() {
2244         int s, e;
2245         int p = buf.cursor();
2246         while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
2247         s = buf.cursor();
2248         for (int i = 0; i &lt; repeatCount; i++) {
2249             while (buf.move(1) == 1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
2250         }
2251         e = buf.cursor();
2252         yankBuffer = buf.substring(s, e);
2253         if (!yankBuffer.endsWith(&quot;\n&quot;)) {
2254             yankBuffer += &quot;\n&quot;;
2255         }
2256         buf.cursor(p);
2257         return true;
2258     }
2259 
2260     protected boolean viChange() {
2261         int cursorStart = buf.cursor();
2262         Binding o = readBinding(getKeys());
2263         if (o instanceof Reference) {
2264             // TODO: be smarter on how to get the vi range
2265             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2266             // change whole line
2267             if (VI_CHANGE.equals(op)) {
2268                 killWholeLine();
2269             } else {
2270                 viMoveMode = ViMoveMode.CHANGE;
2271                 Widget widget = widgets.get(op);
2272                 if (widget != null &amp;&amp; !widget.apply()) {
2273                     viMoveMode = ViMoveMode.NORMAL;
2274                     return false;
2275                 }
2276                 viMoveMode = ViMoveMode.NORMAL;
2277             }
2278             boolean res = viChange(cursorStart, buf.cursor());
2279             setKeyMap(VIINS);
2280             return res;
2281         } else {
2282             pushBackBinding();
2283             return false;
2284         }
2285     }
2286 
2287     /*
2288     protected int getViRange(Reference cmd, ViMoveMode mode) {
2289         Buffer buffer = buf.copy();
2290         int oldMark = mark;
2291         int pos = buf.cursor();
2292         String bind = getLastBinding();
2293 
2294         if (visual != 0) {
2295             if (buf.length() == 0) {
2296                 return -1;
2297             }
2298             pos = mark;
2299             v
2300         } else {
2301             viMoveMode = mode;
2302             mark = -1;
<a name="37" id="anc37"></a><span class="line-modified">2303             Binding b = bindingReader.readBinding(getKeys(), keyMaps.get(VIOPP));</span>
2304             if (b == null || new Reference(SEND_BREAK).equals(b)) {
2305                 viMoveMode = ViMoveMode.NORMAL;
2306                 mark = oldMark;
2307                 return -1;
2308             }
2309             if (cmd.equals(b)) {
2310                 doViLineRange();
2311             }
2312             Widget w = getWidget(b);
2313             if (w )
2314             if (b instanceof Reference) {
2315 
2316             }
2317         }
2318 
2319     }
2320     */
2321 
2322     protected void cleanup() {
2323         if (isSet(Option.ERASE_LINE_ON_FINISH)) {
2324             Buffer oldBuffer = buf.copy();
2325             AttributedString oldPrompt = prompt;
2326             buf.clear();
2327             prompt = new AttributedString(&quot;&quot;);
2328             doCleanup(false);
2329             prompt = oldPrompt;
2330             buf.copyFrom(oldBuffer);
2331         } else {
2332             doCleanup(true);
2333         }
2334     }
2335 
2336     protected void doCleanup(boolean nl) {
2337         buf.cursor(buf.length());
2338         post = null;
2339         if (size.getColumns() &gt; 0 || size.getRows() &gt; 0) {
2340             redisplay(false);
2341             if (nl) {
2342                 println();
2343             }
2344             terminal.puts(Capability.keypad_local);
2345             terminal.trackMouse(Terminal.MouseTracking.Off);
2346             if (isSet(Option.BRACKETED_PASTE))
2347                 terminal.writer().write(BRACKETED_PASTE_OFF);
2348             flush();
2349         }
2350         history.moveToEnd();
2351     }
2352 
2353     protected boolean historyIncrementalSearchForward() {
2354         return doSearchHistory(false);
2355     }
2356 
2357     protected boolean historyIncrementalSearchBackward() {
2358         return doSearchHistory(true);
2359     }
2360 
2361     static class Pair&lt;U,V&gt; {
2362         final U u; final V v;
2363         public Pair(U u, V v) {
2364             this.u = u;
2365             this.v = v;
2366         }
2367         public U getU() {
2368             return u;
2369         }
2370         public V getV() {
2371             return v;
2372         }
2373     }
2374 
2375     protected boolean doSearchHistory(boolean backward) {
2376         if (history.isEmpty()) {
2377             return false;
2378         }
2379 
2380         KeyMap&lt;Binding&gt; terminators = new KeyMap&lt;&gt;();
2381         getString(SEARCH_TERMINATORS, DEFAULT_SEARCH_TERMINATORS)
2382                 .codePoints().forEach(c -&gt; bind(terminators, ACCEPT_LINE, new String(Character.toChars(c))));
2383 
2384         Buffer originalBuffer = buf.copy();
2385         searchIndex = -1;
2386         searchTerm = new StringBuffer();
2387         searchBackward = backward;
2388         searchFailing = false;
2389         post = () -&gt; new AttributedString((searchFailing ? &quot;failing&quot; + &quot; &quot; : &quot;&quot;)
2390                         + (searchBackward ? &quot;bck-i-search&quot; : &quot;fwd-i-search&quot;)
2391                         + &quot;: &quot; + searchTerm + &quot;_&quot;);
2392 
2393         redisplay();
2394         try {
2395             while (true) {
2396                 int prevSearchIndex = searchIndex;
2397                 Binding operation = readBinding(getKeys(), terminators);
2398                 String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
2399                 boolean next = false;
2400                 switch (ref) {
2401                     case SEND_BREAK:
2402                         beep();
2403                         buf.copyFrom(originalBuffer);
2404                         return true;
2405                     case HISTORY_INCREMENTAL_SEARCH_BACKWARD:
2406                         searchBackward = true;
2407                         next = true;
2408                         break;
2409                     case HISTORY_INCREMENTAL_SEARCH_FORWARD:
2410                         searchBackward = false;
2411                         next = true;
2412                         break;
2413                     case BACKWARD_DELETE_CHAR:
2414                         if (searchTerm.length() &gt; 0) {
2415                             searchTerm.deleteCharAt(searchTerm.length() - 1);
2416                         }
2417                         break;
2418                     case SELF_INSERT:
2419                         searchTerm.append(getLastBinding());
2420                         break;
2421                     default:
2422                         // Set buffer and cursor position to the found string.
2423                         if (searchIndex != -1) {
2424                             history.moveTo(searchIndex);
2425                         }
2426                         pushBackBinding();
2427                         return true;
2428                 }
2429 
2430                 // print the search status
2431                 String pattern = doGetSearchPattern();
2432                 if (pattern.length() == 0) {
2433                     buf.copyFrom(originalBuffer);
2434                     searchFailing = false;
2435                 } else {
2436                     boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2437                     Pattern pat = Pattern.compile(pattern, caseInsensitive ? Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE
2438                                                                            : Pattern.UNICODE_CASE);
2439                     Pair&lt;Integer, Integer&gt; pair = null;
2440                     if (searchBackward) {
2441                         boolean nextOnly = next;
2442                         pair = matches(pat, buf.toString(), searchIndex).stream()
2443                                 .filter(p -&gt; nextOnly ? p.v &lt; buf.cursor() : p.v &lt;= buf.cursor())
2444                                 .max(Comparator.comparing(Pair::getV))
2445                                 .orElse(null);
2446                         if (pair == null) {
2447                             pair = StreamSupport.stream(
2448                                     Spliterators.spliteratorUnknownSize(history.reverseIterator(searchIndex &lt; 0 ? history.last() : searchIndex - 1), Spliterator.ORDERED), false)
2449                                     .flatMap(e -&gt; matches(pat, e.line(), e.index()).stream())
2450                                     .findFirst()
2451                                     .orElse(null);
2452                         }
2453                     } else {
2454                         boolean nextOnly = next;
2455                         pair = matches(pat, buf.toString(), searchIndex).stream()
2456                                 .filter(p -&gt; nextOnly ? p.v &gt; buf.cursor() : p.v &gt;= buf.cursor())
2457                                 .min(Comparator.comparing(Pair::getV))
2458                                 .orElse(null);
2459                         if (pair == null) {
2460                             pair = StreamSupport.stream(
2461                                     Spliterators.spliteratorUnknownSize(history.iterator((searchIndex &lt; 0 ? history.last() : searchIndex) + 1), Spliterator.ORDERED), false)
2462                                     .flatMap(e -&gt; matches(pat, e.line(), e.index()).stream())
2463                                     .findFirst()
2464                                     .orElse(null);
2465                             if (pair == null &amp;&amp; searchIndex &gt;= 0) {
2466                                 pair = matches(pat, originalBuffer.toString(), -1).stream()
2467                                         .min(Comparator.comparing(Pair::getV))
2468                                         .orElse(null);
2469                             }
2470                         }
2471                     }
2472                     if (pair != null) {
2473                         searchIndex = pair.u;
2474                         buf.clear();
2475                         if (searchIndex &gt;= 0) {
2476                             buf.write(history.get(searchIndex));
2477                         } else {
2478                             buf.write(originalBuffer.toString());
2479                         }
2480                         buf.cursor(pair.v);
2481                         searchFailing = false;
2482                     } else {
2483                         searchFailing = true;
2484                         beep();
2485                     }
2486                 }
2487                 redisplay();
2488             }
2489         } catch (IOError e) {
2490             // Ignore Ctrl+C interrupts and just exit the loop
2491             if (!(e.getCause() instanceof InterruptedException)) {
2492                 throw e;
2493             }
2494             return true;
2495         } finally {
2496             searchTerm = null;
2497             searchIndex = -1;
2498             post = null;
2499         }
2500     }
2501 
2502     private List&lt;Pair&lt;Integer, Integer&gt;&gt; matches(Pattern p, String line, int index) {
2503         List&lt;Pair&lt;Integer, Integer&gt;&gt; starts = new ArrayList&lt;&gt;();
2504         Matcher m = p.matcher(line);
2505         while (m.find()) {
2506             starts.add(new Pair&lt;&gt;(index, m.start()));
2507         }
2508         return starts;
2509    }
2510 
2511     private String doGetSearchPattern() {
2512         StringBuilder sb = new StringBuilder();
2513         boolean inQuote = false;
2514         for (int i = 0; i &lt; searchTerm.length(); i++) {
2515             char c = searchTerm.charAt(i);
2516             if (Character.isLowerCase(c)) {
2517                 if (inQuote) {
2518                     sb.append(&quot;\\E&quot;);
2519                     inQuote = false;
2520                 }
2521                 sb.append(&quot;[&quot;).append(Character.toLowerCase(c)).append(Character.toUpperCase(c)).append(&quot;]&quot;);
2522             } else {
2523                 if (!inQuote) {
2524                     sb.append(&quot;\\Q&quot;);
2525                     inQuote = true;
2526                 }
2527                 sb.append(c);
2528             }
2529         }
2530         if (inQuote) {
2531             sb.append(&quot;\\E&quot;);
2532         }
2533         return sb.toString();
2534     }
2535 
2536     private void pushBackBinding() {
2537         pushBackBinding(false);
2538     }
2539 
2540     private void pushBackBinding(boolean skip) {
2541         String s = getLastBinding();
2542         if (s != null) {
2543             bindingReader.runMacro(s);
2544             skipRedisplay = skip;
2545         }
2546     }
2547 
2548     protected boolean historySearchForward() {
2549         if (historyBuffer == null || buf.length() == 0
2550                 || !buf.toString().equals(history.current())) {
2551             historyBuffer = buf.copy();
2552             searchBuffer = getFirstWord();
2553         }
2554         int index = history.index() + 1;
2555 
2556         if (index &lt; history.last() + 1) {
2557             int searchIndex = searchForwards(searchBuffer.toString(), index, true);
2558             if (searchIndex == -1) {
2559                 history.moveToEnd();
2560                 if (!buf.toString().equals(historyBuffer.toString())) {
2561                     setBuffer(historyBuffer.toString());
2562                     historyBuffer = null;
2563                 } else {
2564                     return false;
2565                 }
2566             } else {
2567                 // Maintain cursor position while searching.
2568                 if (history.moveTo(searchIndex)) {
2569                     setBuffer(history.current());
2570                 } else {
2571                     history.moveToEnd();
2572                     setBuffer(historyBuffer.toString());
2573                     return false;
2574                 }
2575             }
2576         } else {
2577             history.moveToEnd();
2578             if (!buf.toString().equals(historyBuffer.toString())) {
2579                 setBuffer(historyBuffer.toString());
2580                 historyBuffer = null;
2581             } else {
2582                 return false;
2583             }
2584         }
2585         return true;
2586     }
2587 
2588     private CharSequence getFirstWord() {
2589         String s = buf.toString();
2590         int i = 0;
2591         while (i &lt; s.length() &amp;&amp; !Character.isWhitespace(s.charAt(i))) {
2592             i++;
2593         }
2594         return s.substring(0, i);
2595     }
2596 
2597     protected boolean historySearchBackward() {
2598         if (historyBuffer == null || buf.length() == 0
2599                 || !buf.toString().equals(history.current())) {
2600             historyBuffer = buf.copy();
2601             searchBuffer = getFirstWord();
2602         }
2603         int searchIndex = searchBackwards(searchBuffer.toString(), history.index(), true);
2604 
2605         if (searchIndex == -1) {
2606             return false;
2607         } else {
2608             // Maintain cursor position while searching.
2609             if (history.moveTo(searchIndex)) {
2610                 setBuffer(history.current());
2611             } else {
2612                 return false;
2613             }
2614         }
2615         return true;
2616     }
2617 
2618     //
2619     // History search
2620     //
2621     /**
2622      * Search backward in history from a given position.
2623      *
2624      * @param searchTerm substring to search for.
2625      * @param startIndex the index from which on to search
2626      * @return index where this substring has been found, or -1 else.
2627      */
2628     public int searchBackwards(String searchTerm, int startIndex) {
2629         return searchBackwards(searchTerm, startIndex, false);
2630     }
2631 
2632     /**
2633      * Search backwards in history from the current position.
2634      *
2635      * @param searchTerm substring to search for.
2636      * @return index where the substring has been found, or -1 else.
2637      */
2638     public int searchBackwards(String searchTerm) {
2639         return searchBackwards(searchTerm, history.index(), false);
2640     }
2641 
2642     public int searchBackwards(String searchTerm, int startIndex, boolean startsWith) {
2643         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2644         if (caseInsensitive) {
2645             searchTerm = searchTerm.toLowerCase();
2646         }
2647         ListIterator&lt;History.Entry&gt; it = history.iterator(startIndex);
2648         while (it.hasPrevious()) {
2649             History.Entry e = it.previous();
2650             String line = e.line();
2651             if (caseInsensitive) {
2652                 line = line.toLowerCase();
2653             }
2654             int idx = line.indexOf(searchTerm);
2655             if ((startsWith &amp;&amp; idx == 0) || (!startsWith &amp;&amp; idx &gt;= 0)) {
2656                 return e.index();
2657             }
2658         }
2659         return -1;
2660     }
2661 
2662     public int searchForwards(String searchTerm, int startIndex, boolean startsWith) {
2663         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2664         if (caseInsensitive) {
2665             searchTerm = searchTerm.toLowerCase();
2666         }
2667         if (startIndex &gt; history.last()) {
2668             startIndex = history.last();
2669         }
2670         ListIterator&lt;History.Entry&gt; it = history.iterator(startIndex);
2671         if (searchIndex != -1 &amp;&amp; it.hasNext()) {
2672             it.next();
2673         }
2674         while (it.hasNext()) {
2675             History.Entry e = it.next();
2676             String line = e.line();
2677             if (caseInsensitive) {
2678                 line = line.toLowerCase();
2679             }
2680             int idx = line.indexOf(searchTerm);
2681             if ((startsWith &amp;&amp; idx == 0) || (!startsWith &amp;&amp; idx &gt;= 0)) {
2682                 return e.index();
2683             }
2684         }
2685         return -1;
2686     }
2687 
2688     /**
2689      * Search forward in history from a given position.
2690      *
2691      * @param searchTerm substring to search for.
2692      * @param startIndex the index from which on to search
2693      * @return index where this substring has been found, or -1 else.
2694      */
2695     public int searchForwards(String searchTerm, int startIndex) {
2696         return searchForwards(searchTerm, startIndex, false);
2697     }
2698     /**
2699      * Search forwards in history from the current position.
2700      *
2701      * @param searchTerm substring to search for.
2702      * @return index where the substring has been found, or -1 else.
2703      */
2704     public int searchForwards(String searchTerm) {
2705         return searchForwards(searchTerm, history.index());
2706     }
2707 
2708     protected boolean quit() {
2709         getBuffer().clear();
2710         return acceptLine();
2711     }
2712 
<a name="38" id="anc38"></a>



































2713     protected boolean acceptLine() {
2714         parsedLine = null;
2715         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
2716             try {
2717                 String str = buf.toString();
2718                 String exp = expander.expandHistory(history, str);
2719                 if (!exp.equals(str)) {
2720                     buf.clear();
2721                     buf.write(exp);
2722                     if (isSet(Option.HISTORY_VERIFY)) {
2723                         return true;
2724                     }
2725                 }
2726             } catch (IllegalArgumentException e) {
2727                 // Ignore
2728             }
2729         }
2730         try {
2731             parsedLine = parser.parse(buf.toString(), buf.cursor(), ParseContext.ACCEPT_LINE);
2732         } catch (EOFError e) {
2733             buf.write(&quot;\n&quot;);
2734             return true;
2735         } catch (SyntaxError e) {
2736             // do nothing
2737         }
2738         callWidget(CALLBACK_FINISH);
2739         state = State.DONE;
2740         return true;
2741     }
2742 
2743     protected boolean selfInsert() {
2744         for (int count = this.count; count &gt; 0; count--) {
2745             putString(getLastBinding());
2746         }
2747         return true;
2748     }
2749 
2750     protected boolean selfInsertUnmeta() {
2751         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
2752             String s = getLastBinding().substring(1);
2753             if (&quot;\r&quot;.equals(s)) {
2754                 s = &quot;\n&quot;;
2755             }
2756             for (int count = this.count; count &gt; 0; count--) {
2757                 putString(s);
2758             }
2759             return true;
2760         } else {
2761             return false;
2762         }
2763     }
2764 
2765     protected boolean overwriteMode() {
2766         overTyping = !overTyping;
2767         return true;
2768     }
2769 
2770 
2771     //
2772     // History Control
2773     //
2774 
2775     protected boolean beginningOfBufferOrHistory() {
2776         if (findbol() != 0) {
2777             buf.cursor(0);
2778             return true;
2779         } else {
2780             return beginningOfHistory();
2781         }
2782     }
2783 
2784     protected boolean beginningOfHistory() {
2785         if (history.moveToFirst()) {
2786             setBuffer(history.current());
2787             return true;
2788         } else {
2789             return false;
2790         }
2791     }
2792 
2793     protected boolean endOfBufferOrHistory() {
2794         if (findeol() != buf.length()) {
2795             buf.cursor(buf.length());
2796             return true;
2797         } else {
2798             return endOfHistory();
2799         }
2800     }
2801 
2802     protected boolean endOfHistory() {
2803         if (history.moveToLast()) {
2804             setBuffer(history.current());
2805             return true;
2806         } else {
2807             return false;
2808         }
2809     }
2810 
2811     protected boolean beginningOfLineHist() {
2812         if (count &lt; 0) {
2813             return callNeg(this::endOfLineHist);
2814         }
2815         while (count-- &gt; 0) {
2816             int bol = findbol();
2817             if (bol != buf.cursor()) {
2818                 buf.cursor(bol);
2819             } else {
2820                 moveHistory(false);
2821                 buf.cursor(0);
2822             }
2823         }
2824         return true;
2825     }
2826 
2827     protected boolean endOfLineHist() {
2828         if (count &lt; 0) {
2829             return callNeg(this::beginningOfLineHist);
2830         }
2831         while (count-- &gt; 0) {
2832             int eol = findeol();
2833             if (eol != buf.cursor()) {
2834                 buf.cursor(eol);
2835             } else {
2836                 moveHistory(true);
2837             }
2838         }
2839         return true;
2840     }
2841 
2842     protected boolean upHistory() {
2843         while (count-- &gt; 0) {
2844             if (!moveHistory(false)) {
2845                 return !isSet(Option.HISTORY_BEEP);
2846             }
2847         }
2848         return true;
2849     }
2850 
2851     protected boolean downHistory() {
2852         while (count-- &gt; 0) {
2853             if (!moveHistory(true)) {
2854                 return !isSet(Option.HISTORY_BEEP);
2855             }
2856         }
2857         return true;
2858     }
2859 
2860     protected boolean viUpLineOrHistory() {
2861         return upLine()
2862                 || upHistory() &amp;&amp; viFirstNonBlank();
2863     }
2864 
2865     protected boolean viDownLineOrHistory() {
2866         return downLine()
2867                 || downHistory() &amp;&amp; viFirstNonBlank();
2868     }
2869 
2870     protected boolean upLine() {
2871         return buf.up();
2872     }
2873 
2874     protected boolean downLine() {
2875         return buf.down();
2876     }
2877 
2878     protected boolean upLineOrHistory() {
2879         return upLine() || upHistory();
2880     }
2881 
2882     protected boolean upLineOrSearch() {
2883         return upLine() || historySearchBackward();
2884     }
2885 
2886     protected boolean downLineOrHistory() {
2887         return downLine() || downHistory();
2888     }
2889 
2890     protected boolean downLineOrSearch() {
2891         return downLine() || historySearchForward();
2892     }
2893 
2894     protected boolean viCmdMode() {
2895         // If we are re-entering move mode from an
2896         // aborted yank-to, delete-to, change-to then
2897         // don&#39;t move the cursor back. The cursor is
2898         // only move on an explicit entry to movement
2899         // mode.
2900         if (state == State.NORMAL) {
2901             buf.move(-1);
2902         }
2903         return setKeyMap(VICMD);
2904     }
2905 
2906     protected boolean viInsert() {
2907         return setKeyMap(VIINS);
2908     }
2909 
2910     protected boolean viAddNext() {
2911         buf.move(1);
2912         return setKeyMap(VIINS);
2913     }
2914 
2915     protected boolean viAddEol() {
2916         return endOfLine() &amp;&amp; setKeyMap(VIINS);
2917     }
2918 
2919     protected boolean emacsEditingMode() {
2920         return setKeyMap(EMACS);
2921     }
2922 
2923     protected boolean viChangeWholeLine() {
2924         return viFirstNonBlank() &amp;&amp; viChangeEol();
2925     }
2926 
2927     protected boolean viChangeEol() {
2928         return viChange(buf.cursor(), buf.length())
2929                 &amp;&amp; setKeyMap(VIINS);
2930     }
2931 
2932     protected boolean viKillEol() {
2933         int eol = findeol();
2934         if (buf.cursor() == eol) {
2935             return false;
2936         }
2937         killRing.add(buf.substring(buf.cursor(), eol));
2938         buf.delete(eol - buf.cursor());
2939         return true;
2940     }
2941 
2942     protected boolean quotedInsert() {
2943         int c = readCharacter();
2944         while (count-- &gt; 0) {
2945             putString(new String(Character.toChars(c)));
2946         }
2947         return true;
2948     }
2949 
2950     protected boolean viJoin() {
2951         if (buf.down()) {
2952             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
2953             buf.backspace();
2954             buf.write(&#39; &#39;);
2955             buf.move(-1);
2956             return true;
2957         }
2958         return false;
2959     }
2960 
2961     protected boolean viKillWholeLine() {
2962         return killWholeLine() &amp;&amp; setKeyMap(VIINS);
2963     }
2964 
2965     protected boolean viInsertBol() {
2966         return beginningOfLine() &amp;&amp; setKeyMap(VIINS);
2967     }
2968 
2969     protected boolean backwardDeleteChar() {
2970         if (count &lt; 0) {
2971             return callNeg(this::deleteChar);
2972         }
2973         if (buf.cursor() == 0) {
2974             return false;
2975         }
2976         buf.backspace(count);
2977         return true;
2978     }
2979 
2980     protected boolean viFirstNonBlank() {
2981         beginningOfLine();
2982         while (buf.cursor() &lt; buf.length() &amp;&amp; isWhitespace(buf.currChar())) {
2983             buf.move(1);
2984         }
2985         return true;
2986     }
2987 
2988     protected boolean viBeginningOfLine() {
2989         buf.cursor(findbol());
2990         return true;
2991     }
2992 
2993     protected boolean viEndOfLine() {
2994         if (count &lt; 0) {
2995             return false;
2996         }
2997         while (count-- &gt; 0) {
2998             buf.cursor(findeol() + 1);
2999         }
3000         buf.move(-1);
3001         return true;
3002     }
3003 
3004     protected boolean beginningOfLine() {
3005         while (count-- &gt; 0) {
3006             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3007         }
3008         return true;
3009     }
3010 
3011     protected boolean endOfLine() {
3012         while (count-- &gt; 0) {
3013             while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;) ;
3014         }
3015         return true;
3016     }
3017 
3018     protected boolean deleteChar() {
3019         if (count &lt; 0) {
3020             return callNeg(this::backwardDeleteChar);
3021         }
3022         if (buf.cursor() == buf.length()) {
3023             return false;
3024         }
3025         buf.delete(count);
3026         return true;
3027     }
3028 
3029     /**
3030      * Deletes the previous character from the cursor position
3031      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3032      */
3033     protected boolean viBackwardDeleteChar() {
3034         for (int i = 0; i &lt; count; i++) {
3035             if (!buf.backspace()) {
3036                 return false;
3037             }
3038         }
3039         return true;
3040     }
3041 
3042     /**
3043      * Deletes the character you are sitting on and sucks the rest of
3044      * the line in from the right.
3045      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3046      */
3047     protected boolean viDeleteChar() {
3048         for (int i = 0; i &lt; count; i++) {
3049             if (!buf.delete()) {
3050                 return false;
3051             }
3052         }
3053         return true;
3054     }
3055 
3056     /**
3057      * Switches the case of the current character from upper to lower
3058      * or lower to upper as necessary and advances the cursor one
3059      * position to the right.
3060      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3061      */
3062     protected boolean viSwapCase() {
3063         for (int i = 0; i &lt; count; i++) {
3064             if (buf.cursor() &lt; buf.length()) {
3065                 int ch = buf.atChar(buf.cursor());
3066                 ch = switchCase(ch);
3067                 buf.currChar(ch);
3068                 buf.move(1);
3069             } else {
3070                 return false;
3071             }
3072         }
3073         return true;
3074     }
3075 
3076     /**
3077      * Implements the vi change character command (in move-mode &quot;r&quot;
3078      * followed by the character to change to).
3079      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3080      */
3081     protected boolean viReplaceChars() {
3082         int c = readCharacter();
3083         // EOF, ESC, or CTRL-C aborts.
3084         if (c &lt; 0 || c == &#39;\033&#39; || c == &#39;\003&#39;) {
3085             return true;
3086         }
3087 
3088         for (int i = 0; i &lt; count; i++) {
3089             if (buf.currChar((char) c)) {
3090                 if (i &lt; count - 1) {
3091                     buf.move(1);
3092                 }
3093             } else {
3094                 return false;
3095             }
3096         }
3097         return true;
3098     }
3099 
3100     protected boolean viChange(int startPos, int endPos) {
3101         return doViDeleteOrChange(startPos, endPos, true);
3102     }
3103 
3104     protected boolean viDeleteTo(int startPos, int endPos) {
3105         return doViDeleteOrChange(startPos, endPos, false);
3106     }
3107 
3108     /**
3109      * Performs the vi &quot;delete-to&quot; action, deleting characters between a given
3110      * span of the input line.
3111      * @param startPos The start position
3112      * @param endPos The end position.
3113      * @param isChange If true, then the delete is part of a change operationg
3114      *    (e.g. &quot;c$&quot; is change-to-end-of line, so we first must delete to end
3115      *    of line to start the change
3116      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3117      */
3118     protected boolean doViDeleteOrChange(int startPos, int endPos, boolean isChange) {
3119         if (startPos == endPos) {
3120             return true;
3121         }
3122 
3123         if (endPos &lt; startPos) {
3124             int tmp = endPos;
3125             endPos = startPos;
3126             startPos = tmp;
3127         }
3128 
3129         buf.cursor(startPos);
3130         buf.delete(endPos - startPos);
3131 
3132         // If we are doing a delete operation (e.g. &quot;d$&quot;) then don&#39;t leave the
3133         // cursor dangling off the end. In reality the &quot;isChange&quot; flag is silly
3134         // what is really happening is that if we are in &quot;move-mode&quot; then the
3135         // cursor can&#39;t be moved off the end of the line, but in &quot;edit-mode&quot; it
3136         // is ok, but I have no easy way of knowing which mode we are in.
3137         if (! isChange &amp;&amp; startPos &gt; 0 &amp;&amp; startPos == buf.length()) {
3138             buf.move(-1);
3139         }
3140         return true;
3141     }
3142 
3143     /**
3144      * Implement the &quot;vi&quot; yank-to operation.  This operation allows you
3145      * to yank the contents of the current line based upon a move operation,
3146      * for example &quot;yw&quot; yanks the current word, &quot;3yw&quot; yanks 3 words, etc.
3147      *
3148      * @param startPos The starting position from which to yank
3149      * @param endPos The ending position to which to yank
3150      * @return &lt;code&gt;true&lt;/code&gt; if the yank succeeded
3151      */
3152     protected boolean viYankTo(int startPos, int endPos) {
3153         int cursorPos = startPos;
3154 
3155         if (endPos &lt; startPos) {
3156             int tmp = endPos;
3157             endPos = startPos;
3158             startPos = tmp;
3159         }
3160 
3161         if (startPos == endPos) {
3162             yankBuffer = &quot;&quot;;
3163             return true;
3164         }
3165 
3166         yankBuffer = buf.substring(startPos, endPos);
3167 
3168         /*
3169          * It was a movement command that moved the cursor to find the
3170          * end position, so put the cursor back where it started.
3171          */
3172         buf.cursor(cursorPos);
3173         return true;
3174     }
3175 
3176     protected boolean viOpenLineAbove() {
3177         while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3178         buf.write(&#39;\n&#39;);
3179         buf.move(-1);
3180         return setKeyMap(VIINS);
3181     }
3182 
3183     protected boolean viOpenLineBelow() {
3184         while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;) ;
3185         buf.write(&#39;\n&#39;);
3186         return setKeyMap(VIINS);
3187     }
3188 
3189     /**
3190      * Pasts the yank buffer to the right of the current cursor position
3191      * and moves the cursor to the end of the pasted region.
3192      * @return &lt;code&gt;true&lt;/code&gt;
3193      */
3194     protected boolean viPutAfter() {
3195         if (yankBuffer.indexOf(&#39;\n&#39;) &gt;= 0) {
3196             while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;);
3197             buf.move(1);
3198             putString(yankBuffer);
3199             buf.move(- yankBuffer.length());
3200         } else if (yankBuffer.length () != 0) {
3201             if (buf.cursor() &lt; buf.length()) {
3202                 buf.move(1);
3203             }
3204             for (int i = 0; i &lt; count; i++) {
3205                 putString(yankBuffer);
3206             }
3207             buf.move(-1);
3208         }
3209         return true;
3210     }
3211 
3212     protected boolean viPutBefore() {
3213         if (yankBuffer.indexOf(&#39;\n&#39;) &gt;= 0) {
3214             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;);
3215             putString(yankBuffer);
3216             buf.move(- yankBuffer.length());
3217         } else if (yankBuffer.length () != 0) {
3218             if (buf.cursor() &gt; 0) {
3219                 buf.move(-1);
3220             }
3221             for (int i = 0; i &lt; count; i++) {
3222                 putString(yankBuffer);
3223             }
3224             buf.move(-1);
3225         }
3226         return true;
3227     }
3228 
3229     protected boolean doLowercaseVersion() {
3230         bindingReader.runMacro(getLastBinding().toLowerCase());
3231         return true;
3232     }
3233 
3234     protected boolean setMarkCommand() {
3235         if (count &lt; 0) {
3236             regionActive = RegionType.NONE;
3237             return true;
3238         }
3239         regionMark = buf.cursor();
3240         regionActive = RegionType.CHAR;
3241         return true;
3242     }
3243 
3244     protected boolean exchangePointAndMark() {
3245         if (count == 0) {
3246             regionActive = RegionType.CHAR;
3247             return true;
3248         }
3249         int x = regionMark;
3250         regionMark = buf.cursor();
3251         buf.cursor(x);
3252         if (buf.cursor() &gt; buf.length()) {
3253             buf.cursor(buf.length());
3254         }
3255         if (count &gt; 0) {
3256             regionActive = RegionType.CHAR;
3257         }
3258         return true;
3259     }
3260 
3261     protected boolean visualMode() {
3262         if (isInViMoveOperation()) {
3263             isArgDigit = true;
3264             forceLine = false;
3265             forceChar = true;
3266             return true;
3267         }
3268         if (regionActive == RegionType.NONE) {
3269             regionMark = buf.cursor();
3270             regionActive = RegionType.CHAR;
3271         } else if (regionActive == RegionType.CHAR) {
3272             regionActive = RegionType.NONE;
3273         } else if (regionActive == RegionType.LINE) {
3274             regionActive = RegionType.CHAR;
3275         }
3276         return true;
3277     }
3278 
3279     protected boolean visualLineMode() {
3280         if (isInViMoveOperation()) {
3281             isArgDigit = true;
3282             forceLine = true;
3283             forceChar = false;
3284             return true;
3285         }
3286         if (regionActive == RegionType.NONE) {
3287             regionMark = buf.cursor();
3288             regionActive = RegionType.LINE;
3289         } else if (regionActive == RegionType.CHAR) {
3290             regionActive = RegionType.LINE;
3291         } else if (regionActive == RegionType.LINE) {
3292             regionActive = RegionType.NONE;
3293         }
3294         return true;
3295     }
3296 
3297     protected boolean deactivateRegion() {
3298         regionActive = RegionType.NONE;
3299         return true;
3300     }
3301 
3302     protected boolean whatCursorPosition() {
3303         post = () -&gt; {
3304             AttributedStringBuilder sb = new AttributedStringBuilder();
3305             if (buf.cursor() &lt; buf.length()) {
3306                 int c = buf.currChar();
3307                 sb.append(&quot;Char: &quot;);
3308                 if (c == &#39; &#39;) {
3309                     sb.append(&quot;SPC&quot;);
3310                 } else if (c == &#39;\n&#39;) {
3311                     sb.append(&quot;LFD&quot;);
3312                 } else if (c &lt; 32) {
3313                     sb.append(&#39;^&#39;);
3314                     sb.append((char) (c + &#39;A&#39; - 1));
3315                 } else if (c == 127) {
3316                     sb.append(&quot;^?&quot;);
3317                 } else {
3318                     sb.append((char) c);
3319                 }
3320                 sb.append(&quot; (&quot;);
3321                 sb.append(&quot;0&quot;).append(Integer.toOctalString(c)).append(&quot; &quot;);
3322                 sb.append(Integer.toString(c)).append(&quot; &quot;);
3323                 sb.append(&quot;0x&quot;).append(Integer.toHexString(c)).append(&quot; &quot;);
3324                 sb.append(&quot;)&quot;);
3325             } else {
3326                 sb.append(&quot;EOF&quot;);
3327             }
3328             sb.append(&quot;   &quot;);
3329             sb.append(&quot;point &quot;);
3330             sb.append(Integer.toString(buf.cursor() + 1));
3331             sb.append(&quot; of &quot;);
3332             sb.append(Integer.toString(buf.length() + 1));
3333             sb.append(&quot; (&quot;);
3334             sb.append(Integer.toString(buf.length() == 0 ? 100 : ((100 * buf.cursor()) / buf.length())));
3335             sb.append(&quot;%)&quot;);
3336             sb.append(&quot;   &quot;);
3337             sb.append(&quot;column &quot;);
3338             sb.append(Integer.toString(buf.cursor() - findbol()));
3339             return sb.toAttributedString();
3340         };
3341         return true;
3342     }
3343 
3344     protected Map&lt;String, Widget&gt; builtinWidgets() {
3345         Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
<a name="39" id="anc39"></a><span class="line-modified">3346         widgets.put(ACCEPT_LINE, this::acceptLine);</span>
<span class="line-modified">3347         widgets.put(ARGUMENT_BASE, this::argumentBase);</span>
<span class="line-modified">3348         widgets.put(BACKWARD_CHAR, this::backwardChar);</span>
<span class="line-modified">3349         widgets.put(BACKWARD_DELETE_CHAR, this::backwardDeleteChar);</span>
<span class="line-modified">3350         widgets.put(BACKWARD_DELETE_WORD, this::backwardDeleteWord);</span>
<span class="line-modified">3351         widgets.put(BACKWARD_KILL_LINE, this::backwardKillLine);</span>
<span class="line-modified">3352         widgets.put(BACKWARD_KILL_WORD, this::backwardKillWord);</span>
<span class="line-modified">3353         widgets.put(BACKWARD_WORD, this::backwardWord);</span>
<span class="line-modified">3354         widgets.put(BEEP, this::beep);</span>
<span class="line-modified">3355         widgets.put(BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);</span>
<span class="line-modified">3356         widgets.put(BEGINNING_OF_HISTORY, this::beginningOfHistory);</span>
<span class="line-modified">3357         widgets.put(BEGINNING_OF_LINE, this::beginningOfLine);</span>
<span class="line-modified">3358         widgets.put(BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);</span>
<span class="line-modified">3359         widgets.put(CAPITALIZE_WORD, this::capitalizeWord);</span>
<span class="line-modified">3360         widgets.put(CLEAR, this::clear);</span>
<span class="line-modified">3361         widgets.put(CLEAR_SCREEN, this::clearScreen);</span>
<span class="line-modified">3362         widgets.put(COMPLETE_PREFIX, this::completePrefix);</span>
<span class="line-modified">3363         widgets.put(COMPLETE_WORD, this::completeWord);</span>
<span class="line-modified">3364         widgets.put(COPY_PREV_WORD, this::copyPrevWord);</span>
<span class="line-modified">3365         widgets.put(COPY_REGION_AS_KILL, this::copyRegionAsKill);</span>
<span class="line-modified">3366         widgets.put(DELETE_CHAR, this::deleteChar);</span>
<span class="line-modified">3367         widgets.put(DELETE_CHAR_OR_LIST, this::deleteCharOrList);</span>
<span class="line-modified">3368         widgets.put(DELETE_WORD, this::deleteWord);</span>
<span class="line-modified">3369         widgets.put(DIGIT_ARGUMENT, this::digitArgument);</span>
<span class="line-modified">3370         widgets.put(DO_LOWERCASE_VERSION, this::doLowercaseVersion);</span>
<span class="line-modified">3371         widgets.put(DOWN_CASE_WORD, this::downCaseWord);</span>
<span class="line-modified">3372         widgets.put(DOWN_LINE, this::downLine);</span>
<span class="line-modified">3373         widgets.put(DOWN_LINE_OR_HISTORY, this::downLineOrHistory);</span>
<span class="line-modified">3374         widgets.put(DOWN_LINE_OR_SEARCH, this::downLineOrSearch);</span>
<span class="line-modified">3375         widgets.put(DOWN_HISTORY, this::downHistory);</span>
<span class="line-modified">3376         widgets.put(EMACS_EDITING_MODE, this::emacsEditingMode);</span>
<span class="line-modified">3377         widgets.put(EMACS_BACKWARD_WORD, this::emacsBackwardWord);</span>
<span class="line-modified">3378         widgets.put(EMACS_FORWARD_WORD, this::emacsForwardWord);</span>
<span class="line-modified">3379         widgets.put(END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);</span>
<span class="line-modified">3380         widgets.put(END_OF_HISTORY, this::endOfHistory);</span>
<span class="line-modified">3381         widgets.put(END_OF_LINE, this::endOfLine);</span>
<span class="line-modified">3382         widgets.put(END_OF_LINE_HIST, this::endOfLineHist);</span>
<span class="line-modified">3383         widgets.put(EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);</span>
<span class="line-modified">3384         widgets.put(EXPAND_HISTORY, this::expandHistory);</span>
<span class="line-modified">3385         widgets.put(EXPAND_OR_COMPLETE, this::expandOrComplete);</span>
<span class="line-modified">3386         widgets.put(EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);</span>
<span class="line-modified">3387         widgets.put(EXPAND_WORD, this::expandWord);</span>
<span class="line-modified">3388         widgets.put(FRESH_LINE, this::freshLine);</span>
<span class="line-modified">3389         widgets.put(FORWARD_CHAR, this::forwardChar);</span>
<span class="line-modified">3390         widgets.put(FORWARD_WORD, this::forwardWord);</span>
<span class="line-modified">3391         widgets.put(HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);</span>
<span class="line-modified">3392         widgets.put(HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);</span>
<span class="line-modified">3393         widgets.put(HISTORY_SEARCH_BACKWARD, this::historySearchBackward);</span>
<span class="line-modified">3394         widgets.put(HISTORY_SEARCH_FORWARD, this::historySearchForward);</span>
<span class="line-modified">3395         widgets.put(INSERT_CLOSE_CURLY, this::insertCloseCurly);</span>
<span class="line-modified">3396         widgets.put(INSERT_CLOSE_PAREN, this::insertCloseParen);</span>
<span class="line-modified">3397         widgets.put(INSERT_CLOSE_SQUARE, this::insertCloseSquare);</span>
<span class="line-modified">3398         widgets.put(INSERT_COMMENT, this::insertComment);</span>
<span class="line-modified">3399         widgets.put(KILL_BUFFER, this::killBuffer);</span>
<span class="line-modified">3400         widgets.put(KILL_LINE, this::killLine);</span>
<span class="line-modified">3401         widgets.put(KILL_REGION, this::killRegion);</span>
<span class="line-modified">3402         widgets.put(KILL_WHOLE_LINE, this::killWholeLine);</span>
<span class="line-modified">3403         widgets.put(KILL_WORD, this::killWord);</span>
<span class="line-modified">3404         widgets.put(LIST_CHOICES, this::listChoices);</span>
<span class="line-modified">3405         widgets.put(MENU_COMPLETE, this::menuComplete);</span>
<span class="line-modified">3406         widgets.put(MENU_EXPAND_OR_COMPLETE, this::menuExpandOrComplete);</span>
<span class="line-modified">3407         widgets.put(NEG_ARGUMENT, this::negArgument);</span>
<span class="line-modified">3408         widgets.put(OVERWRITE_MODE, this::overwriteMode);</span>
<span class="line-modified">3409 //        widgets.put(QUIT, this::quit);</span>
<span class="line-modified">3410         widgets.put(QUOTED_INSERT, this::quotedInsert);</span>
<span class="line-modified">3411         widgets.put(REDISPLAY, this::redisplay);</span>
<span class="line-modified">3412         widgets.put(REDRAW_LINE, this::redrawLine);</span>
<span class="line-modified">3413         widgets.put(REDO, this::redo);</span>
<span class="line-modified">3414         widgets.put(SELF_INSERT, this::selfInsert);</span>
<span class="line-modified">3415         widgets.put(SELF_INSERT_UNMETA, this::selfInsertUnmeta);</span>
<span class="line-modified">3416         widgets.put(SEND_BREAK, this::sendBreak);</span>
<span class="line-modified">3417         widgets.put(SET_MARK_COMMAND, this::setMarkCommand);</span>
<span class="line-modified">3418         widgets.put(TRANSPOSE_CHARS, this::transposeChars);</span>
<span class="line-modified">3419         widgets.put(TRANSPOSE_WORDS, this::transposeWords);</span>
<span class="line-modified">3420         widgets.put(UNDEFINED_KEY, this::undefinedKey);</span>
<span class="line-modified">3421         widgets.put(UNIVERSAL_ARGUMENT, this::universalArgument);</span>
<span class="line-modified">3422         widgets.put(UNDO, this::undo);</span>
<span class="line-modified">3423         widgets.put(UP_CASE_WORD, this::upCaseWord);</span>
<span class="line-modified">3424         widgets.put(UP_HISTORY, this::upHistory);</span>
<span class="line-modified">3425         widgets.put(UP_LINE, this::upLine);</span>
<span class="line-modified">3426         widgets.put(UP_LINE_OR_HISTORY, this::upLineOrHistory);</span>
<span class="line-modified">3427         widgets.put(UP_LINE_OR_SEARCH, this::upLineOrSearch);</span>
<span class="line-modified">3428         widgets.put(VI_ADD_EOL, this::viAddEol);</span>
<span class="line-modified">3429         widgets.put(VI_ADD_NEXT, this::viAddNext);</span>
<span class="line-modified">3430         widgets.put(VI_BACKWARD_CHAR, this::viBackwardChar);</span>
<span class="line-modified">3431         widgets.put(VI_BACKWARD_DELETE_CHAR, this::viBackwardDeleteChar);</span>
<span class="line-modified">3432         widgets.put(VI_BACKWARD_BLANK_WORD, this::viBackwardBlankWord);</span>
<span class="line-modified">3433         widgets.put(VI_BACKWARD_BLANK_WORD_END, this::viBackwardBlankWordEnd);</span>
<span class="line-modified">3434         widgets.put(VI_BACKWARD_KILL_WORD, this::viBackwardKillWord);</span>
<span class="line-modified">3435         widgets.put(VI_BACKWARD_WORD, this::viBackwardWord);</span>
<span class="line-modified">3436         widgets.put(VI_BACKWARD_WORD_END, this::viBackwardWordEnd);</span>
<span class="line-modified">3437         widgets.put(VI_BEGINNING_OF_LINE, this::viBeginningOfLine);</span>
<span class="line-modified">3438         widgets.put(VI_CMD_MODE, this::viCmdMode);</span>
<span class="line-modified">3439         widgets.put(VI_DIGIT_OR_BEGINNING_OF_LINE, this::viDigitOrBeginningOfLine);</span>
<span class="line-modified">3440         widgets.put(VI_DOWN_LINE_OR_HISTORY, this::viDownLineOrHistory);</span>
<span class="line-modified">3441         widgets.put(VI_CHANGE, this::viChange);</span>
<span class="line-modified">3442         widgets.put(VI_CHANGE_EOL, this::viChangeEol);</span>
<span class="line-modified">3443         widgets.put(VI_CHANGE_WHOLE_LINE, this::viChangeWholeLine);</span>
<span class="line-modified">3444         widgets.put(VI_DELETE_CHAR, this::viDeleteChar);</span>
<span class="line-modified">3445         widgets.put(VI_DELETE, this::viDelete);</span>
<span class="line-modified">3446         widgets.put(VI_END_OF_LINE, this::viEndOfLine);</span>
<span class="line-modified">3447         widgets.put(VI_KILL_EOL, this::viKillEol);</span>
<span class="line-modified">3448         widgets.put(VI_FIRST_NON_BLANK, this::viFirstNonBlank);</span>
<span class="line-modified">3449         widgets.put(VI_FIND_NEXT_CHAR, this::viFindNextChar);</span>
<span class="line-modified">3450         widgets.put(VI_FIND_NEXT_CHAR_SKIP, this::viFindNextCharSkip);</span>
<span class="line-modified">3451         widgets.put(VI_FIND_PREV_CHAR, this::viFindPrevChar);</span>
<span class="line-modified">3452         widgets.put(VI_FIND_PREV_CHAR_SKIP, this::viFindPrevCharSkip);</span>
<span class="line-modified">3453         widgets.put(VI_FORWARD_BLANK_WORD, this::viForwardBlankWord);</span>
<span class="line-modified">3454         widgets.put(VI_FORWARD_BLANK_WORD_END, this::viForwardBlankWordEnd);</span>
<span class="line-modified">3455         widgets.put(VI_FORWARD_CHAR, this::viForwardChar);</span>
<span class="line-modified">3456         widgets.put(VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">3457         widgets.put(VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">3458         widgets.put(VI_FORWARD_WORD_END, this::viForwardWordEnd);</span>
<span class="line-modified">3459         widgets.put(VI_HISTORY_SEARCH_BACKWARD, this::viHistorySearchBackward);</span>
<span class="line-modified">3460         widgets.put(VI_HISTORY_SEARCH_FORWARD, this::viHistorySearchForward);</span>
<span class="line-modified">3461         widgets.put(VI_INSERT, this::viInsert);</span>
<span class="line-modified">3462         widgets.put(VI_INSERT_BOL, this::viInsertBol);</span>
<span class="line-modified">3463         widgets.put(VI_INSERT_COMMENT, this::viInsertComment);</span>
<span class="line-modified">3464         widgets.put(VI_JOIN, this::viJoin);</span>
<span class="line-modified">3465         widgets.put(VI_KILL_LINE, this::viKillWholeLine);</span>
<span class="line-modified">3466         widgets.put(VI_MATCH_BRACKET, this::viMatchBracket);</span>
<span class="line-modified">3467         widgets.put(VI_OPEN_LINE_ABOVE, this::viOpenLineAbove);</span>
<span class="line-modified">3468         widgets.put(VI_OPEN_LINE_BELOW, this::viOpenLineBelow);</span>
<span class="line-modified">3469         widgets.put(VI_PUT_AFTER, this::viPutAfter);</span>
<span class="line-modified">3470         widgets.put(VI_PUT_BEFORE, this::viPutBefore);</span>
<span class="line-modified">3471         widgets.put(VI_REPEAT_FIND, this::viRepeatFind);</span>
<span class="line-modified">3472         widgets.put(VI_REPEAT_SEARCH, this::viRepeatSearch);</span>
<span class="line-modified">3473         widgets.put(VI_REPLACE_CHARS, this::viReplaceChars);</span>
<span class="line-modified">3474         widgets.put(VI_REV_REPEAT_FIND, this::viRevRepeatFind);</span>
<span class="line-modified">3475         widgets.put(VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);</span>
<span class="line-modified">3476         widgets.put(VI_SWAP_CASE, this::viSwapCase);</span>
<span class="line-modified">3477         widgets.put(VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);</span>
<span class="line-modified">3478         widgets.put(VI_YANK, this::viYankTo);</span>
<span class="line-modified">3479         widgets.put(VI_YANK_WHOLE_LINE, this::viYankWholeLine);</span>
<span class="line-modified">3480         widgets.put(VISUAL_LINE_MODE, this::visualLineMode);</span>
<span class="line-modified">3481         widgets.put(VISUAL_MODE, this::visualMode);</span>
<span class="line-modified">3482         widgets.put(WHAT_CURSOR_POSITION, this::whatCursorPosition);</span>
<span class="line-modified">3483         widgets.put(YANK, this::yank);</span>
<span class="line-modified">3484         widgets.put(YANK_POP, this::yankPop);</span>
<span class="line-modified">3485         widgets.put(MOUSE, this::mouse);</span>
<span class="line-modified">3486         widgets.put(BEGIN_PASTE, this::beginPaste);</span>
<span class="line-modified">3487         widgets.put(FOCUS_IN, this::focusIn);</span>
<span class="line-modified">3488         widgets.put(FOCUS_OUT, this::focusOut);</span>



3489         return widgets;
3490     }
3491 
<a name="40" id="anc40"></a>
















3492     public boolean redisplay() {
3493         redisplay(true);
3494         return true;
3495     }
3496 
<a name="41" id="anc41"></a><span class="line-modified">3497     protected synchronized void redisplay(boolean flush) {</span>
<span class="line-modified">3498         if (skipRedisplay) {</span>
<span class="line-modified">3499             skipRedisplay = false;</span>
<span class="line-removed">3500             return;</span>
<span class="line-removed">3501         }</span>
3502 
<a name="42" id="anc42"></a><span class="line-modified">3503         Status status = Status.getStatus(terminal, false);</span>
<span class="line-modified">3504         if (status != null) {</span>
<span class="line-modified">3505             status.redraw();</span>
<span class="line-modified">3506         }</span>
3507 
<a name="43" id="anc43"></a><span class="line-modified">3508         if (size.getRows() &gt; 0 &amp;&amp; size.getRows() &lt; MIN_ROWS) {</span>
<span class="line-modified">3509             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>


3510 
<a name="44" id="anc44"></a><span class="line-modified">3511             sb.append(prompt);</span>
<span class="line-modified">3512             concat(getHighlightedBuffer(buf.toString()).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-removed">3513             AttributedString full = sb.toAttributedString();</span>
3514 
<a name="45" id="anc45"></a><span class="line-modified">3515             sb.setLength(0);</span>
<span class="line-modified">3516             sb.append(prompt);</span>
<span class="line-modified">3517             String line = buf.upToCursor();</span>
<span class="line-modified">3518             if(maskingCallback != null) {</span>
<span class="line-modified">3519                 line = maskingCallback.display(line);</span>



































3520             }
3521 
<a name="46" id="anc46"></a><span class="line-modified">3522             concat(new AttributedString(line).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-modified">3523             AttributedString toCursor = sb.toAttributedString();</span>
3524 
<a name="47" id="anc47"></a><span class="line-modified">3525             int w = WCWidth.wcwidth(&#39;\u2026&#39;);</span>
<span class="line-modified">3526             int width = size.getColumns();</span>
<span class="line-modified">3527             int cursor = toCursor.columnLength();</span>
<span class="line-modified">3528             int inc = width /2 + 1;</span>
<span class="line-modified">3529             while (cursor &lt;= smallTerminalOffset + w) {</span>
<span class="line-modified">3530                 smallTerminalOffset -= inc;</span>
3531             }
<a name="48" id="anc48"></a><span class="line-modified">3532             while (cursor &gt;= smallTerminalOffset + width - w) {</span>
<span class="line-modified">3533                 smallTerminalOffset += inc;</span>




3534             }
<a name="49" id="anc49"></a><span class="line-modified">3535             if (smallTerminalOffset &gt; 0) {</span>
<span class="line-modified">3536                 sb.setLength(0);</span>
<span class="line-removed">3537                 sb.append(&quot;\u2026&quot;);</span>
<span class="line-removed">3538                 sb.append(full.columnSubSequence(smallTerminalOffset + w, Integer.MAX_VALUE));</span>
<span class="line-removed">3539                 full = sb.toAttributedString();</span>
3540             }
<a name="50" id="anc50"></a><span class="line-modified">3541             int length = full.columnLength();</span>
<span class="line-modified">3542             if (length &gt;= smallTerminalOffset + width) {</span>
<span class="line-modified">3543                 sb.setLength(0);</span>
<span class="line-removed">3544                 sb.append(full.columnSubSequence(0, width - w));</span>
<span class="line-removed">3545                 sb.append(&quot;\u2026&quot;);</span>
<span class="line-removed">3546                 full = sb.toAttributedString();</span>
3547             }
3548 
<a name="51" id="anc51"></a><span class="line-modified">3549             display.update(Collections.singletonList(full), cursor - smallTerminalOffset, flush);</span>
<span class="line-modified">3550             return;</span>
<span class="line-modified">3551         }</span>
<span class="line-modified">3552 </span>
<span class="line-modified">3553         List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">3554         AttributedString full = getDisplayedBufferWithPrompts(secondaryPrompts);</span>
<span class="line-modified">3555 </span>
<span class="line-modified">3556         List&lt;AttributedString&gt; newLines;</span>
<span class="line-modified">3557         if (size.getColumns() &lt;= 0) {</span>
<span class="line-modified">3558             newLines = new ArrayList&lt;&gt;();</span>
<span class="line-modified">3559             newLines.add(full);</span>
<span class="line-modified">3560         } else {</span>
<span class="line-modified">3561             newLines = full.columnSplitLength(size.getColumns(), true, display.delayLineWrap());</span>
<span class="line-modified">3562         }</span>
<span class="line-modified">3563 </span>
<span class="line-modified">3564         List&lt;AttributedString&gt; rightPromptLines;</span>
<span class="line-modified">3565         if (rightPrompt.length() == 0 || size.getColumns() &lt;= 0) {</span>
<span class="line-removed">3566             rightPromptLines = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3567         } else {</span>
<span class="line-removed">3568             rightPromptLines = rightPrompt.columnSplitLength(size.getColumns());</span>
<span class="line-removed">3569         }</span>
<span class="line-removed">3570         while (newLines.size() &lt; rightPromptLines.size()) {</span>
<span class="line-removed">3571             newLines.add(new AttributedString(&quot;&quot;));</span>
<span class="line-removed">3572         }</span>
<span class="line-removed">3573         for (int i = 0; i &lt; rightPromptLines.size(); i++) {</span>
<span class="line-removed">3574             AttributedString line = rightPromptLines.get(i);</span>
<span class="line-removed">3575             newLines.set(i, addRightPrompt(line, newLines.get(i)));</span>
<span class="line-removed">3576         }</span>
<span class="line-removed">3577 </span>
<span class="line-removed">3578         int cursorPos = -1;</span>
<span class="line-removed">3579         if (size.getColumns() &gt; 0) {</span>
<span class="line-removed">3580             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>
<span class="line-removed">3581             sb.append(prompt);</span>
<span class="line-removed">3582             String buffer = buf.upToCursor();</span>
<span class="line-removed">3583             if (maskingCallback != null) {</span>
<span class="line-removed">3584                 buffer = maskingCallback.display(buffer);</span>
3585             }
<a name="52" id="anc52"></a><span class="line-modified">3586             sb.append(insertSecondaryPrompts(new AttributedString(buffer), secondaryPrompts, false));</span>
<span class="line-modified">3587             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());</span>
<span class="line-modified">3588             if (!promptLines.isEmpty()) {</span>
<span class="line-modified">3589                 cursorPos = size.cursorPos(promptLines.size() - 1,</span>
<span class="line-modified">3590                                            promptLines.get(promptLines.size() - 1).columnLength());</span>




























3591             }
<a name="53" id="anc53"></a>


3592         }
<a name="54" id="anc54"></a><span class="line-removed">3593 </span>
<span class="line-removed">3594         display.update(newLines, cursorPos, flush);</span>
3595     }
3596 
3597     private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
3598         if (lines.size() &gt; 1) {
3599             for (int i = 0; i &lt; lines.size() - 1; i++) {
3600                 sb.append(lines.get(i));
3601                 sb.style(sb.style().inverse());
3602                 sb.append(&quot;\\n&quot;);
3603                 sb.style(sb.style().inverseOff());
3604             }
3605         }
3606         sb.append(lines.get(lines.size() - 1));
3607     }
3608 
3609     /**
3610      * Compute the full string to be displayed with the left, right and secondary prompts
3611      * @param secondaryPrompts a list to store the secondary prompts
3612      * @return the displayed string including the buffer, left prompts and the help below
3613      */
3614     public AttributedString getDisplayedBufferWithPrompts(List&lt;AttributedString&gt; secondaryPrompts) {
3615         AttributedString attBuf = getHighlightedBuffer(buf.toString());
3616 
3617         AttributedString tNewBuf = insertSecondaryPrompts(attBuf, secondaryPrompts);
3618         AttributedStringBuilder full = new AttributedStringBuilder().tabs(TAB_WIDTH);
3619         full.append(prompt);
3620         full.append(tNewBuf);
3621         if (post != null) {
3622             full.append(&quot;\n&quot;);
3623             full.append(post.get());
3624         }
3625         return full.toAttributedString();
3626     }
3627 
3628     private AttributedString getHighlightedBuffer(String buffer) {
3629         if (maskingCallback != null) {
3630             buffer = maskingCallback.display(buffer);
3631         }
3632         if (highlighter != null &amp;&amp; !isSet(Option.DISABLE_HIGHLIGHTER)) {
3633             return highlighter.highlight(this, buffer);
3634         }
3635         return new AttributedString(buffer);
3636     }
3637 
3638     private AttributedString expandPromptPattern(String pattern, int padToWidth,
3639                                                  String message, int line) {
3640         ArrayList&lt;AttributedString&gt; parts = new ArrayList&lt;&gt;();
3641         boolean isHidden = false;
3642         int padPartIndex = -1;
3643         StringBuilder padPartString = null;
3644         StringBuilder sb = new StringBuilder();
3645         // Add &quot;%{&quot; to avoid special case for end of string.
3646         pattern = pattern + &quot;%{&quot;;
3647         int plen = pattern.length();
3648         int padChar = -1;
3649         int padPos = -1;
3650         int cols = 0;
3651         for (int i = 0; i &lt; plen; ) {
3652             char ch = pattern.charAt(i++);
3653             if (ch == &#39;%&#39; &amp;&amp; i &lt; plen) {
3654                 int count = 0;
3655                 boolean countSeen = false;
3656                 decode: while (true) {
3657                     ch = pattern.charAt(i++);
3658                     switch (ch) {
<a name="55" id="anc55"></a><span class="line-modified">3659                        case &#39;{&#39;:</span>
<span class="line-modified">3660                        case &#39;}&#39;:</span>
<span class="line-modified">3661                            String str = sb.toString();</span>
<span class="line-modified">3662                            AttributedString astr;</span>
<span class="line-modified">3663                            if (!isHidden) {</span>
<span class="line-modified">3664                                astr = AttributedString.fromAnsi(str);</span>
<span class="line-modified">3665                                cols += astr.columnLength();</span>
<span class="line-modified">3666                            } else {</span>
<span class="line-modified">3667                                astr = new AttributedString(str, AttributedStyle.HIDDEN);</span>
<span class="line-modified">3668                            }</span>
<span class="line-modified">3669                            if (padPartIndex == parts.size()) {</span>
<span class="line-modified">3670                                padPartString = sb;</span>
<span class="line-modified">3671                                if (i &lt; plen) {</span>
<span class="line-modified">3672                                    sb = new StringBuilder();</span>
<span class="line-modified">3673                                }</span>
<span class="line-modified">3674                            } else {</span>
<span class="line-modified">3675                                sb.setLength(0);</span>
<span class="line-modified">3676                            }</span>
<span class="line-modified">3677                            parts.add(astr);</span>
<span class="line-modified">3678                            isHidden = ch == &#39;{&#39;;</span>
3679                             break decode;
3680                         case &#39;%&#39;:
3681                             sb.append(ch);
3682                             break decode;
3683                         case &#39;N&#39;:
3684                             sb.append(getInt(LINE_OFFSET, 0) + line);
3685                             break decode;
3686                         case &#39;M&#39;:
3687                             if (message != null)
3688                                 sb.append(message);
3689                             break decode;
3690                         case &#39;P&#39;:
3691                             if (countSeen &amp;&amp; count &gt;= 0)
3692                                 padToWidth = count;
3693                             if (i &lt; plen) {
3694                                 padChar = pattern.charAt(i++);
3695                                 // FIXME check surrogate
3696                             }
3697                             padPos = sb.length();
3698                             padPartIndex = parts.size();
3699                             break decode;
3700                         case &#39;-&#39;:
3701                         case &#39;0&#39;:
3702                         case &#39;1&#39;:
3703                         case &#39;2&#39;:
3704                         case &#39;3&#39;:
3705                         case &#39;4&#39;:
3706                         case &#39;5&#39;:
3707                         case &#39;6&#39;:
3708                         case &#39;7&#39;:
3709                         case &#39;8&#39;:
3710                         case &#39;9&#39;:
3711                             boolean neg = false;
3712                             if (ch == &#39;-&#39;) {
3713                                 neg = true;
3714                                 ch = pattern.charAt(i++);
3715                             }
3716                             countSeen = true;
3717                             count = 0;
3718                             while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) {
3719                                 count = (count &lt; 0 ? 0 : 10 * count) + (ch - &#39;0&#39;);
3720                                 ch = pattern.charAt(i++);
3721                             }
3722                             if (neg) {
3723                                 count = -count;
3724                             }
3725                             i--;
3726                             break;
3727                         default:
3728                             break decode;
3729                     }
3730                 }
3731             } else
3732                 sb.append(ch);
3733         }
3734         if (padToWidth &gt; cols) {
3735             int padCharCols = WCWidth.wcwidth(padChar);
3736             int padCount = (padToWidth - cols) / padCharCols;
3737             sb = padPartString;
3738             while (--padCount &gt;= 0)
3739                 sb.insert(padPos, (char) padChar); // FIXME if wide
3740             parts.set(padPartIndex, AttributedString.fromAnsi(sb.toString()));
3741         }
3742         return AttributedString.join(null, parts);
3743     }
3744 
3745     private AttributedString insertSecondaryPrompts(AttributedString str, List&lt;AttributedString&gt; prompts) {
3746         return insertSecondaryPrompts(str, prompts, true);
3747     }
3748 
3749     private AttributedString insertSecondaryPrompts(AttributedString strAtt, List&lt;AttributedString&gt; prompts, boolean computePrompts) {
3750         Objects.requireNonNull(prompts);
3751         List&lt;AttributedString&gt; lines = strAtt.columnSplitLength(Integer.MAX_VALUE);
3752         AttributedStringBuilder sb = new AttributedStringBuilder();
3753         String secondaryPromptPattern = getString(SECONDARY_PROMPT_PATTERN, DEFAULT_SECONDARY_PROMPT_PATTERN);
3754         boolean needsMessage = secondaryPromptPattern.contains(&quot;%M&quot;);
3755         AttributedStringBuilder buf = new AttributedStringBuilder();
3756         int width = 0;
3757         List&lt;String&gt; missings = new ArrayList&lt;&gt;();
3758         if (computePrompts &amp;&amp; secondaryPromptPattern.contains(&quot;%P&quot;)) {
3759             width = prompt.columnLength();
3760             for (int line = 0; line &lt; lines.size() - 1; line++) {
3761                 AttributedString prompt;
3762                 buf.append(lines.get(line)).append(&quot;\n&quot;);
3763                 String missing = &quot;&quot;;
3764                 if (needsMessage) {
3765                     try {
3766                         parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
3767                     } catch (EOFError e) {
3768                         missing = e.getMissing();
3769                     } catch (SyntaxError e) {
3770                         // Ignore
3771                     }
3772                 }
3773                 missings.add(missing);
3774                 prompt = expandPromptPattern(secondaryPromptPattern, 0, missing, line + 1);
3775                 width = Math.max(width, prompt.columnLength());
3776             }
3777             buf.setLength(0);
3778         }
3779         int line = 0;
3780         while (line &lt; lines.size() - 1) {
3781             sb.append(lines.get(line)).append(&quot;\n&quot;);
3782             buf.append(lines.get(line)).append(&quot;\n&quot;);
3783             AttributedString prompt;
3784             if (computePrompts) {
3785                 String missing = &quot;&quot;;
3786                 if (needsMessage) {
3787                     if (missings.isEmpty()) {
3788                         try {
3789                             parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
3790                         } catch (EOFError e) {
3791                             missing = e.getMissing();
3792                         } catch (SyntaxError e) {
3793                             // Ignore
3794                         }
3795                     } else {
3796                         missing = missings.get(line);
3797                     }
3798                 }
3799                 prompt = expandPromptPattern(secondaryPromptPattern, width, missing, line + 1);
3800             } else {
3801                 prompt = prompts.get(line);
3802             }
3803             prompts.add(prompt);
3804             sb.append(prompt);
3805             line++;
3806         }
3807         sb.append(lines.get(line));
3808         buf.append(lines.get(line));
3809         return sb.toAttributedString();
3810     }
3811 
3812     private AttributedString addRightPrompt(AttributedString prompt, AttributedString line) {
3813         int width = prompt.columnLength();
3814         boolean endsWithNl = line.length() &gt; 0
3815             &amp;&amp; line.charAt(line.length() - 1) == &#39;\n&#39;;
3816         // columnLength counts -1 for the final newline; adjust for that
3817         int nb = size.getColumns() - width
3818             - (line.columnLength() + (endsWithNl ? 1 : 0));
3819         if (nb &gt;= 3) {
3820             AttributedStringBuilder sb = new AttributedStringBuilder(size.getColumns());
3821             sb.append(line, 0, endsWithNl ? line.length() - 1 : line.length());
3822             for (int j = 0; j &lt; nb; j++) {
3823                 sb.append(&#39; &#39;);
3824             }
3825             sb.append(prompt);
3826             if (endsWithNl) {
3827                 sb.append(&#39;\n&#39;);
3828             }
3829             line = sb.toAttributedString();
3830         }
3831         return line;
3832     }
3833 
3834     //
3835     // Completion
3836     //
3837 
3838     protected boolean insertTab() {
3839         return isSet(Option.INSERT_TAB)
3840                     &amp;&amp; getLastBinding().equals(&quot;\t&quot;)
3841                     &amp;&amp; buf.toString().matches(&quot;(^|[\\s\\S]*\n)[\r\n\t ]*&quot;);
3842     }
3843 
3844     protected boolean expandHistory() {
3845         String str = buf.toString();
3846         String exp = expander.expandHistory(history, str);
3847         if (!exp.equals(str)) {
3848             buf.clear();
3849             buf.write(exp);
3850             return true;
3851         } else {
3852             return false;
3853         }
3854     }
3855 
3856     protected enum CompletionType {
3857         Expand,
3858         ExpandComplete,
3859         Complete,
3860         List,
3861     }
3862 
3863     protected boolean expandWord() {
3864         if (insertTab()) {
3865             return selfInsert();
3866         } else {
3867             return doComplete(CompletionType.Expand, isSet(Option.MENU_COMPLETE), false);
3868         }
3869     }
3870 
3871     protected boolean expandOrComplete() {
3872         if (insertTab()) {
3873             return selfInsert();
3874         } else {
3875             return doComplete(CompletionType.ExpandComplete, isSet(Option.MENU_COMPLETE), false);
3876         }
3877     }
3878 
3879     protected boolean expandOrCompletePrefix() {
3880         if (insertTab()) {
3881             return selfInsert();
3882         } else {
3883             return doComplete(CompletionType.ExpandComplete, isSet(Option.MENU_COMPLETE), true);
3884         }
3885     }
3886 
3887     protected boolean completeWord() {
3888         if (insertTab()) {
3889             return selfInsert();
3890         } else {
3891             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), false);
3892         }
3893     }
3894 
3895     protected boolean menuComplete() {
3896         if (insertTab()) {
3897             return selfInsert();
3898         } else {
3899             return doComplete(CompletionType.Complete, true, false);
3900         }
3901     }
3902 
3903     protected boolean menuExpandOrComplete() {
3904         if (insertTab()) {
3905             return selfInsert();
3906         } else {
3907             return doComplete(CompletionType.ExpandComplete, true, false);
3908         }
3909     }
3910 
3911     protected boolean completePrefix() {
3912         if (insertTab()) {
3913             return selfInsert();
3914         } else {
3915             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), true);
3916         }
3917     }
3918 
3919     protected boolean listChoices() {
3920         return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);
3921     }
3922 
3923     protected boolean deleteCharOrList() {
3924         if (buf.cursor() != buf.length() || buf.length() == 0) {
3925             return deleteChar();
3926         } else {
3927             return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);
3928         }
3929     }
3930 
3931     protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {
3932         // If completion is disabled, just bail out
3933         if (getBoolean(DISABLE_COMPLETION, false)) {
3934             return true;
3935         }
3936         // Try to expand history first
3937         // If there is actually an expansion, bail out now
3938         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
3939             try {
3940                 if (expandHistory()) {
3941                     return true;
3942                 }
3943             } catch (Exception e) {
3944                 Log.info(&quot;Error while expanding history&quot;, e);
3945                 return false;
3946             }
3947         }
3948 
3949         // Parse the command line
3950         CompletingParsedLine line;
3951         try {
3952             line = wrap(parser.parse(buf.toString(), buf.cursor(), ParseContext.COMPLETE));
3953         } catch (Exception e) {
3954             Log.info(&quot;Error while parsing line&quot;, e);
3955             return false;
3956         }
3957 
3958         // Find completion candidates
3959         List&lt;Candidate&gt; candidates = new ArrayList&lt;&gt;();
3960         try {
3961             if (completer != null) {
3962                 completer.complete(this, line, candidates);
3963             }
3964         } catch (Exception e) {
3965             Log.info(&quot;Error while finding completion candidates&quot;, e);
3966             return false;
3967         }
3968 
3969         if (lst == CompletionType.ExpandComplete || lst == CompletionType.Expand) {
3970             String w = expander.expandVar(line.word());
3971             if (!line.word().equals(w)) {
3972                 if (prefix) {
3973                     buf.backspace(line.wordCursor());
3974                 } else {
3975                     buf.move(line.word().length() - line.wordCursor());
3976                     buf.backspace(line.word().length());
3977                 }
3978                 buf.write(w);
3979                 return true;
3980             }
3981             if (lst == CompletionType.Expand) {
3982                 return false;
3983             } else {
3984                 lst = CompletionType.Complete;
3985             }
3986         }
3987 
3988         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
3989         int errors = getInt(ERRORS, DEFAULT_ERRORS);
3990 
3991         // Build a list of sorted candidates
3992         Map&lt;String, List&lt;Candidate&gt;&gt; sortedCandidates = new HashMap&lt;&gt;();
3993         for (Candidate cand : candidates) {
3994             sortedCandidates
3995                     .computeIfAbsent(AttributedString.fromAnsi(cand.value()).toString(), s -&gt; new ArrayList&lt;&gt;())
3996                     .add(cand);
3997         }
3998 
3999         // Find matchers
4000         // TODO: glob completion
4001         List&lt;Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4002                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt;&gt; matchers;
4003         Predicate&lt;String&gt; exact;
4004         if (prefix) {
4005             String wd = line.word();
4006             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4007             String wp = wdi.substring(0, line.wordCursor());
4008             matchers = Arrays.asList(
4009                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wp)),
4010                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wp)),
4011                     typoMatcher(wp, errors, caseInsensitive)
4012             );
4013             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wp) : s.equals(wp);
4014         } else if (isSet(Option.COMPLETE_IN_WORD)) {
4015             String wd = line.word();
4016             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4017             String wp = wdi.substring(0, line.wordCursor());
4018             String ws = wdi.substring(line.wordCursor());
4019             Pattern p1 = Pattern.compile(Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4020             Pattern p2 = Pattern.compile(&quot;.*&quot; + Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4021             matchers = Arrays.asList(
4022                     simpleMatcher(s -&gt; p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4023                     simpleMatcher(s -&gt; p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4024                     typoMatcher(wdi, errors, caseInsensitive)
4025             );
4026             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4027         } else {
4028             String wd = line.word();
4029             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4030             matchers = Arrays.asList(
4031                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),
4032                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),
4033                     typoMatcher(wdi, errors, caseInsensitive)
4034             );
4035             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4036         }
4037         // Find matching candidates
4038         Map&lt;String, List&lt;Candidate&gt;&gt; matching = Collections.emptyMap();
4039         for (Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4040                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt; matcher : matchers) {
4041             matching = matcher.apply(sortedCandidates);
4042             if (!matching.isEmpty()) {
4043                 break;
4044             }
4045         }
4046 
4047         // If we have no matches, bail out
4048         if (matching.isEmpty()) {
4049             return false;
4050         }
<a name="56" id="anc56"></a>


























































4051 
<a name="57" id="anc57"></a><span class="line-removed">4052         // If we only need to display the list, do it now</span>
<span class="line-removed">4053         if (lst == CompletionType.List) {</span>
4054             List&lt;Candidate&gt; possible = matching.entrySet().stream()
4055                     .flatMap(e -&gt; e.getValue().stream())
4056                     .collect(Collectors.toList());
<a name="58" id="anc58"></a><span class="line-modified">4057             doList(possible, line.word(), false, line::escape);</span>
<span class="line-modified">4058             return !possible.isEmpty();</span>
<span class="line-modified">4059         }</span>
<span class="line-modified">4060 </span>
<span class="line-modified">4061         // Check if there&#39;s a single possible match</span>
<span class="line-modified">4062         Candidate completion = null;</span>
<span class="line-modified">4063         // If there&#39;s a single possible completion</span>
<span class="line-modified">4064         if (matching.size() == 1) {</span>
<span class="line-modified">4065             completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-modified">4066                     .findFirst().orElse(null);</span>
<span class="line-removed">4067         }</span>
<span class="line-removed">4068         // Or if RECOGNIZE_EXACT is set, try to find an exact match</span>
<span class="line-removed">4069         else if (isSet(Option.RECOGNIZE_EXACT)) {</span>
<span class="line-removed">4070             completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-removed">4071                     .filter(Candidate::complete)</span>
<span class="line-removed">4072                     .filter(c -&gt; exact.test(c.value()))</span>
<span class="line-removed">4073                     .findFirst().orElse(null);</span>
<span class="line-removed">4074         }</span>
<span class="line-removed">4075         // Complete and exit</span>
<span class="line-removed">4076         if (completion != null &amp;&amp; !completion.value().isEmpty()) {</span>
4077             if (prefix) {
<a name="59" id="anc59"></a><span class="line-modified">4078                 buf.backspace(line.rawWordCursor());</span>
4079             } else {
<a name="60" id="anc60"></a>
4080                 buf.move(line.rawWordLength() - line.rawWordCursor());
<a name="61" id="anc61"></a><span class="line-removed">4081                 buf.backspace(line.rawWordLength());</span>
4082             }
<a name="62" id="anc62"></a><span class="line-modified">4083             buf.write(line.escape(completion.value(), completion.complete()));</span>
<span class="line-modified">4084             if (completion.complete()) {</span>
<span class="line-modified">4085                 if (buf.currChar() != &#39; &#39;) {</span>
<span class="line-modified">4086                     buf.write(&quot; &quot;);</span>
<span class="line-modified">4087                 } else {</span>
<span class="line-removed">4088                     buf.move(1);</span>
<span class="line-removed">4089                 }</span>
4090             }
<a name="63" id="anc63"></a><span class="line-modified">4091             if (completion.suffix() != null) {</span>
<span class="line-modified">4092                 redisplay();</span>
<span class="line-modified">4093                 Binding op = readBinding(getKeys());</span>
<span class="line-modified">4094                 if (op != null) {</span>
<span class="line-modified">4095                     String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);</span>
<span class="line-modified">4096                     String ref = op instanceof Reference ? ((Reference) op).name() : null;</span>
<span class="line-modified">4097                     if (SELF_INSERT.equals(ref) &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0</span>
<span class="line-modified">4098                             || ACCEPT_LINE.equals(ref)) {</span>
<span class="line-modified">4099                         buf.backspace(completion.suffix().length());</span>
<span class="line-modified">4100                         if (getLastBinding().charAt(0) != &#39; &#39;) {</span>
<span class="line-removed">4101                             buf.write(&#39; &#39;);</span>
<span class="line-removed">4102                         }</span>
4103                     }
<a name="64" id="anc64"></a><span class="line-removed">4104                     pushBackBinding(true);</span>
4105                 }
4106             }
<a name="65" id="anc65"></a><span class="line-modified">4107             return true;</span>
<span class="line-modified">4108         }</span>
<span class="line-removed">4109 </span>
<span class="line-removed">4110         List&lt;Candidate&gt; possible = matching.entrySet().stream()</span>
<span class="line-removed">4111                 .flatMap(e -&gt; e.getValue().stream())</span>
<span class="line-removed">4112                 .collect(Collectors.toList());</span>
<span class="line-removed">4113 </span>
<span class="line-removed">4114         if (useMenu) {</span>
<span class="line-removed">4115             buf.move(line.word().length() - line.wordCursor());</span>
<span class="line-removed">4116             buf.backspace(line.word().length());</span>
<span class="line-removed">4117             doMenu(possible, line.word(), line::escape);</span>
<span class="line-removed">4118             return true;</span>
<span class="line-removed">4119         }</span>
<span class="line-removed">4120 </span>
<span class="line-removed">4121         // Find current word and move to end</span>
<span class="line-removed">4122         String current;</span>
<span class="line-removed">4123         if (prefix) {</span>
<span class="line-removed">4124             current = line.word().substring(0, line.wordCursor());</span>
<span class="line-removed">4125         } else {</span>
<span class="line-removed">4126             current = line.word();</span>
<span class="line-removed">4127             buf.move(line.rawWordLength() - line.rawWordCursor());</span>
<span class="line-removed">4128         }</span>
<span class="line-removed">4129         // Now, we need to find the unambiguous completion</span>
<span class="line-removed">4130         // TODO: need to find common suffix</span>
<span class="line-removed">4131         String commonPrefix = null;</span>
<span class="line-removed">4132         for (String key : matching.keySet()) {</span>
<span class="line-removed">4133             commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);</span>
<span class="line-removed">4134         }</span>
<span class="line-removed">4135         boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);</span>
<span class="line-removed">4136 </span>
<span class="line-removed">4137         if (hasUnambiguous) {</span>
<span class="line-removed">4138             buf.backspace(line.rawWordLength());</span>
<span class="line-removed">4139             buf.write(line.escape(commonPrefix, false));</span>
<span class="line-removed">4140             current = commonPrefix;</span>
<span class="line-removed">4141             if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))</span>
<span class="line-removed">4142                     || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {</span>
<span class="line-removed">4143                 if (!nextBindingIsComplete()) {</span>
4144                     return true;
4145                 }
4146             }
<a name="66" id="anc66"></a><span class="line-modified">4147         }</span>
<span class="line-modified">4148         if (isSet(Option.AUTO_LIST)) {</span>
<span class="line-modified">4149             if (!doList(possible, current, true, line::escape)) {</span>
<span class="line-removed">4150                 return true;</span>
4151             }
<a name="67" id="anc67"></a>


4152         }
<a name="68" id="anc68"></a><span class="line-removed">4153         if (isSet(Option.AUTO_MENU)) {</span>
<span class="line-removed">4154             buf.backspace(current.length());</span>
<span class="line-removed">4155             doMenu(possible, line.word(), line::escape);</span>
<span class="line-removed">4156         }</span>
<span class="line-removed">4157         return true;</span>
4158     }
4159 
4160     private CompletingParsedLine wrap(ParsedLine line) {
4161         if (line instanceof CompletingParsedLine) {
4162             return (CompletingParsedLine) line;
4163         } else {
4164             return new CompletingParsedLine() {
4165                 public String word() {
4166                     return line.word();
4167                 }
4168                 public int wordCursor() {
4169                     return line.wordCursor();
4170                 }
4171                 public int wordIndex() {
4172                     return line.wordIndex();
4173                 }
4174                 public List&lt;String&gt; words() {
4175                     return line.words();
4176                 }
4177                 public String line() {
4178                     return line.line();
4179                 }
4180                 public int cursor() {
4181                     return line.cursor();
4182                 }
4183                 public CharSequence escape(CharSequence candidate, boolean complete) {
4184                     return candidate;
4185                 }
4186                 public int rawWordCursor() {
4187                     return wordCursor();
4188                 }
4189                 public int rawWordLength() {
4190                     return word().length();
4191                 }
4192             };
4193         }
4194     }
4195 
4196     protected Comparator&lt;Candidate&gt; getCandidateComparator(boolean caseInsensitive, String word) {
4197         String wdi = caseInsensitive ? word.toLowerCase() : word;
4198         ToIntFunction&lt;String&gt; wordDistance = w -&gt; distance(wdi, caseInsensitive ? w.toLowerCase() : w);
4199         return Comparator
4200                 .comparing(Candidate::value, Comparator.comparingInt(wordDistance))
4201                 .thenComparing(Candidate::value, Comparator.comparingInt(String::length))
4202                 .thenComparing(Comparator.naturalOrder());
4203     }
4204 
4205     protected String getOthersGroupName() {
4206         return getString(OTHERS_GROUP_NAME, DEFAULT_OTHERS_GROUP_NAME);
4207     }
4208 
4209     protected String getOriginalGroupName() {
4210         return getString(ORIGINAL_GROUP_NAME, DEFAULT_ORIGINAL_GROUP_NAME);
4211     }
4212 
4213 
4214     protected Comparator&lt;String&gt; getGroupComparator() {
4215         return Comparator.&lt;String&gt;comparingInt(s -&gt; getOthersGroupName().equals(s) ? 1 : getOriginalGroupName().equals(s) ? -1 : 0)
4216                 .thenComparing(String::toLowerCase, Comparator.naturalOrder());
4217     }
4218 
4219     private void mergeCandidates(List&lt;Candidate&gt; possible) {
4220         // Merge candidates if the have the same key
4221         Map&lt;String, List&lt;Candidate&gt;&gt; keyedCandidates = new HashMap&lt;&gt;();
4222         for (Candidate candidate : possible) {
4223             if (candidate.key() != null) {
4224                 List&lt;Candidate&gt; cands = keyedCandidates.computeIfAbsent(candidate.key(), s -&gt; new ArrayList&lt;&gt;());
4225                 cands.add(candidate);
4226             }
4227         }
4228         if (!keyedCandidates.isEmpty()) {
4229             for (List&lt;Candidate&gt; candidates : keyedCandidates.values()) {
4230                 if (candidates.size() &gt;= 1) {
4231                     possible.removeAll(candidates);
4232                     // Candidates with the same key are supposed to have
4233                     // the same description
4234                     candidates.sort(Comparator.comparing(Candidate::value));
4235                     Candidate first = candidates.get(0);
4236                     String disp = candidates.stream()
4237                             .map(Candidate::displ)
4238                             .collect(Collectors.joining(&quot; &quot;));
4239                     possible.add(new Candidate(first.value(), disp, first.group(),
4240                             first.descr(), first.suffix(), null, first.complete()));
4241                 }
4242             }
4243         }
4244     }
4245 
4246     private Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4247                      Map&lt;String, List&lt;Candidate&gt;&gt;&gt; simpleMatcher(Predicate&lt;String&gt; pred) {
4248         return m -&gt; m.entrySet().stream()
4249                 .filter(e -&gt; pred.test(e.getKey()))
4250                 .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
4251     }
4252 
4253     private Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4254                      Map&lt;String, List&lt;Candidate&gt;&gt;&gt; typoMatcher(String word, int errors, boolean caseInsensitive) {
4255         return m -&gt; {
4256             Map&lt;String, List&lt;Candidate&gt;&gt; map = m.entrySet().stream()
4257                     .filter(e -&gt; distance(word, caseInsensitive ? e.getKey() : e.getKey().toLowerCase()) &lt; errors)
4258                     .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
4259             if (map.size() &gt; 1) {
4260                 map.computeIfAbsent(word, w -&gt; new ArrayList&lt;&gt;())
4261                         .add(new Candidate(word, word, getOriginalGroupName(), null, null, null, false));
4262             }
4263             return map;
4264         };
4265     }
4266 
4267     private int distance(String word, String cand) {
4268         if (word.length() &lt; cand.length()) {
4269             int d1 = Levenshtein.distance(word, cand.substring(0, Math.min(cand.length(), word.length())));
4270             int d2 = Levenshtein.distance(word, cand);
4271             return Math.min(d1, d2);
4272         } else {
4273             return Levenshtein.distance(word, cand);
4274         }
4275     }
4276 
4277     protected boolean nextBindingIsComplete() {
4278         redisplay();
4279         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4280         Binding operation = readBinding(getKeys(), keyMap);
4281         if (operation instanceof Reference &amp;&amp; MENU_COMPLETE.equals(((Reference) operation).name())) {
4282             return true;
4283         } else {
4284             pushBackBinding();
4285             return false;
4286         }
4287     }
4288 
4289     private class MenuSupport implements Supplier&lt;AttributedString&gt; {
4290         final List&lt;Candidate&gt; possible;
4291         final BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper;
4292         int selection;
4293         int topLine;
4294         String word;
4295         AttributedString computed;
4296         int lines;
4297         int columns;
4298         String completed;
4299 
4300         public MenuSupport(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4301             this.possible = new ArrayList&lt;&gt;();
4302             this.escaper = escaper;
4303             this.selection = -1;
4304             this.topLine = 0;
4305             this.word = &quot;&quot;;
4306             this.completed = completed;
4307             computePost(original, null, possible, completed);
4308             next();
4309         }
4310 
4311         public Candidate completion() {
4312             return possible.get(selection);
4313         }
4314 
4315         public void next() {
4316             selection = (selection + 1) % possible.size();
4317             update();
4318         }
4319 
4320         public void previous() {
4321             selection = (selection + possible.size() - 1) % possible.size();
4322             update();
4323         }
4324 
4325         /**
4326          * Move &#39;step&#39; options along the major axis of the menu.&lt;p&gt;
4327          * ie. if the menu is listing rows first, change row (up/down);
4328          * otherwise move column (left/right)
4329          *
4330          * @param step number of options to move by
4331          */
4332         private void major(int step) {
4333             int axis = isSet(Option.LIST_ROWS_FIRST) ? columns : lines;
4334             int sel = selection + step * axis;
4335             if (sel &lt; 0) {
4336                 int pos = (sel + axis) % axis; // needs +axis as (-1)%x == -1
4337                 int remainders = possible.size() % axis;
4338                 sel = possible.size() - remainders + pos;
4339                 if (sel &gt;= possible.size()) {
4340                     sel -= axis;
4341                 }
4342             } else if (sel &gt;= possible.size()) {
4343                 sel = sel % axis;
4344             }
4345             selection = sel;
4346             update();
4347         }
4348 
4349         /**
4350          * Move &#39;step&#39; options along the minor axis of the menu.&lt;p&gt;
4351          * ie. if the menu is listing rows first, move along the row (left/right);
4352          * otherwise move along the column (up/down)
4353          *
4354          * @param step number of options to move by
4355          */
4356         private void minor(int step) {
4357             int axis = isSet(Option.LIST_ROWS_FIRST) ? columns : lines;
4358             int row = selection % axis;
4359             int options = possible.size();
4360             if (selection - row + axis &gt; options) {
4361                 // selection is the last row/column
4362                 // so there are fewer options than other rows
4363                 axis = options%axis;
4364             }
4365             selection = selection - row + ((axis + row + step) % axis);
4366             update();
4367         }
4368 
4369         public void up() {
4370             if (isSet(Option.LIST_ROWS_FIRST)) {
4371                 major(-1);
4372             } else {
4373                 minor(-1);
4374             }
4375         }
4376 
4377         public void down() {
4378             if (isSet(Option.LIST_ROWS_FIRST)) {
4379                 major(1);
4380             } else {
4381                 minor(1);
4382             }
4383         }
4384 
4385         public void left() {
4386             if (isSet(Option.LIST_ROWS_FIRST)) {
4387                 minor(-1);
4388             } else {
4389                 major(-1);
4390             }
4391         }
4392 
4393         public void right() {
4394             if (isSet(Option.LIST_ROWS_FIRST)) {
4395                 minor(1);
4396             } else {
4397                 major(1);
4398             }
4399         }
4400 
4401         private void update() {
4402             buf.backspace(word.length());
4403             word = escaper.apply(completion().value(), true).toString();
4404             buf.write(word);
4405 
4406             // Compute displayed prompt
4407             PostResult pr = computePost(possible, completion(), null, completed);
4408             AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4409             int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4410             if (pr.lines &gt; size.getRows() - promptLines) {
4411                 int displayed = size.getRows() - promptLines - 1;
4412                 if (pr.selectedLine &gt;= 0) {
4413                     if (pr.selectedLine &lt; topLine) {
4414                         topLine = pr.selectedLine;
4415                     } else if (pr.selectedLine &gt;= topLine + displayed) {
4416                         topLine = pr.selectedLine - displayed + 1;
4417                     }
4418                 }
4419                 AttributedString post = pr.post;
4420                 if (post.length() &gt; 0 &amp;&amp; post.charAt(post.length() - 1) != &#39;\n&#39;) {
4421                     post = new AttributedStringBuilder(post.length() + 1)
4422                             .append(post).append(&quot;\n&quot;).toAttributedString();
4423                 }
4424                 List&lt;AttributedString&gt; lines = post.columnSplitLength(size.getColumns(), true, display.delayLineWrap());
4425                 List&lt;AttributedString&gt; sub = new ArrayList&lt;&gt;(lines.subList(topLine, topLine + displayed));
4426                 sub.add(new AttributedStringBuilder()
4427                         .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))
4428                         .append(&quot;rows &quot;)
4429                         .append(Integer.toString(topLine + 1))
4430                         .append(&quot; to &quot;)
4431                         .append(Integer.toString(topLine + displayed))
4432                         .append(&quot; of &quot;)
4433                         .append(Integer.toString(lines.size()))
4434                         .append(&quot;\n&quot;)
4435                         .style(AttributedStyle.DEFAULT).toAttributedString());
4436                 computed = AttributedString.join(AttributedString.EMPTY, sub);
4437             } else {
4438                 computed = pr.post;
4439             }
4440             lines = pr.lines;
4441             columns = (possible.size() + lines - 1) / lines;
4442         }
4443 
4444         @Override
4445         public AttributedString get() {
4446             return computed;
4447         }
4448 
4449     }
4450 
4451     protected boolean doMenu(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4452         // Reorder candidates according to display order
4453         final List&lt;Candidate&gt; possible = new ArrayList&lt;&gt;();
4454         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4455         original.sort(getCandidateComparator(caseInsensitive, completed));
4456         mergeCandidates(original);
4457         computePost(original, null, possible, completed);
4458 
4459         // Build menu support
4460         MenuSupport menuSupport = new MenuSupport(original, completed, escaper);
4461         post = menuSupport;
4462         redisplay();
4463 
4464         // Loop
4465         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4466         Binding operation;
4467         while ((operation = readBinding(getKeys(), keyMap)) != null) {
4468             String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
4469             switch (ref) {
4470                 case MENU_COMPLETE:
4471                     menuSupport.next();
4472                     break;
4473                 case REVERSE_MENU_COMPLETE:
4474                     menuSupport.previous();
4475                     break;
4476                 case UP_LINE_OR_HISTORY:
4477                 case UP_LINE_OR_SEARCH:
4478                     menuSupport.up();
4479                     break;
4480                 case DOWN_LINE_OR_HISTORY:
4481                 case DOWN_LINE_OR_SEARCH:
4482                     menuSupport.down();
4483                     break;
4484                 case FORWARD_CHAR:
4485                     menuSupport.right();
4486                     break;
4487                 case BACKWARD_CHAR:
4488                     menuSupport.left();
4489                     break;
4490                 case CLEAR_SCREEN:
4491                     clearScreen();
4492                     break;
4493                 default: {
4494                     Candidate completion = menuSupport.completion();
4495                     if (completion.suffix() != null) {
4496                         String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);
4497                         if (SELF_INSERT.equals(ref)
4498                                 &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0
4499                                 || BACKWARD_DELETE_CHAR.equals(ref)) {
4500                             buf.backspace(completion.suffix().length());
4501                         }
4502                     }
4503                     if (completion.complete()
4504                             &amp;&amp; getLastBinding().charAt(0) != &#39; &#39;
4505                             &amp;&amp; (SELF_INSERT.equals(ref) || getLastBinding().charAt(0) != &#39; &#39;)) {
4506                         buf.write(&#39; &#39;);
4507                     }
4508                     if (!ACCEPT_LINE.equals(ref)
4509                             &amp;&amp; !(SELF_INSERT.equals(ref)
4510                                 &amp;&amp; completion.suffix() != null
4511                                 &amp;&amp; completion.suffix().startsWith(getLastBinding()))) {
4512                         pushBackBinding(true);
4513                     }
4514                     post = null;
4515                     return true;
4516                 }
4517             }
4518             redisplay();
4519         }
4520         return false;
4521     }
4522 
4523     protected boolean doList(List&lt;Candidate&gt; possible, String completed, boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4524         // If we list only and if there&#39;s a big
4525         // number of items, we should ask the user
4526         // for confirmation, display the list
4527         // and redraw the line at the bottom
4528         mergeCandidates(possible);
4529         AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4530         int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4531         PostResult postResult = computePost(possible, null, null, completed);
4532         int lines = postResult.lines;
4533         int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
4534         if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
4535                 || lines &gt;= size.getRows() - promptLines) {
4536             // prompt
<a name="69" id="anc69"></a><span class="line-modified">4537             post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see to see all &quot; + possible.size()</span>
4538                     + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);
4539             redisplay(true);
4540             int c = readCharacter();
4541             if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {
4542                 post = null;
4543                 return false;
4544             }
4545         }
4546 
4547         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4548         StringBuilder sb = new StringBuilder();
4549         while (true) {
4550             String current = completed + sb.toString();
4551             List&lt;Candidate&gt; cands;
4552             if (sb.length() &gt; 0) {
4553                 cands = possible.stream()
4554                         .filter(c -&gt; caseInsensitive
4555                                     ? c.value().toLowerCase().startsWith(current.toLowerCase())
4556                                     : c.value().startsWith(current))
4557                         .sorted(getCandidateComparator(caseInsensitive, current))
4558                         .collect(Collectors.toList());
4559             } else {
4560                 cands = possible.stream()
4561                         .sorted(getCandidateComparator(caseInsensitive, current))
4562                         .collect(Collectors.toList());
4563             }
4564             post = () -&gt; {
4565                 AttributedString t = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4566                 int pl = t.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4567                 PostResult pr = computePost(cands, null, null, current);
4568                 if (pr.lines &gt;= size.getRows() - pl) {
4569                     post = null;
4570                     int oldCursor = buf.cursor();
4571                     buf.cursor(buf.length());
4572                     redisplay(false);
4573                     buf.cursor(oldCursor);
4574                     println();
4575                     List&lt;AttributedString&gt; ls = postResult.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
4576                     Display d = new Display(terminal, false);
4577                     d.resize(size.getRows(), size.getColumns());
4578                     d.update(ls, -1);
4579                     redrawLine();
4580                     return new AttributedString(&quot;&quot;);
4581                 }
4582                 return pr.post;
4583             };
4584             if (!runLoop) {
4585                 return false;
4586             }
4587             redisplay();
4588             // TODO: use a different keyMap ?
<a name="70" id="anc70"></a><span class="line-modified">4589             Binding b = bindingReader.readBinding(getKeys());</span>
4590             if (b instanceof Reference) {
4591                 String name = ((Reference) b).name();
4592                 if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
4593                     if (sb.length() == 0) {
4594                         pushBackBinding();
4595                         post = null;
4596                         return false;
4597                     } else {
4598                         sb.setLength(sb.length() - 1);
4599                         buf.backspace();
4600                     }
4601                 } else if (SELF_INSERT.equals(name)) {
4602                     sb.append(getLastBinding());
4603                     buf.write(getLastBinding());
4604                     if (cands.isEmpty()) {
4605                         post = null;
4606                         return false;
4607                     }
4608                 } else if (&quot;\t&quot;.equals(getLastBinding())) {
4609                     if (cands.size() == 1 || sb.length() &gt; 0) {
4610                         post = null;
4611                         pushBackBinding();
4612                     } else if (isSet(Option.AUTO_MENU)) {
4613                         buf.backspace(escaper.apply(current, false).length());
4614                         doMenu(cands, current, escaper);
4615                     }
4616                     return false;
4617                 } else {
4618                     pushBackBinding();
4619                     post = null;
4620                     return false;
4621                 }
4622             } else if (b == null) {
4623                 post = null;
4624                 return false;
4625             }
4626         }
4627     }
4628 
4629     protected static class PostResult {
4630         final AttributedString post;
4631         final int lines;
4632         final int selectedLine;
4633 
4634         public PostResult(AttributedString post, int lines, int selectedLine) {
4635             this.post = post;
4636             this.lines = lines;
4637             this.selectedLine = selectedLine;
4638         }
4639     }
4640 
4641     protected PostResult computePost(List&lt;Candidate&gt; possible, Candidate selection, List&lt;Candidate&gt; ordered, String completed) {
4642         return computePost(possible, selection, ordered, completed, display::wcwidth, size.getColumns(), isSet(Option.AUTO_GROUP), isSet(Option.GROUP), isSet(Option.LIST_ROWS_FIRST));
4643     }
4644 
4645     protected PostResult computePost(List&lt;Candidate&gt; possible, Candidate selection, List&lt;Candidate&gt; ordered, String completed, Function&lt;String, Integer&gt; wcwidth, int width, boolean autoGroup, boolean groupName, boolean rowsFirst) {
4646         List&lt;Object&gt; strings = new ArrayList&lt;&gt;();
4647         if (groupName) {
4648             Comparator&lt;String&gt; groupComparator = getGroupComparator();
4649             Map&lt;String, Map&lt;String, Candidate&gt;&gt; sorted;
4650             sorted = groupComparator != null
4651                         ? new TreeMap&lt;&gt;(groupComparator)
4652                         : new LinkedHashMap&lt;&gt;();
4653             for (Candidate cand : possible) {
4654                 String group = cand.group();
4655                 sorted.computeIfAbsent(group != null ? group : &quot;&quot;, s -&gt; new LinkedHashMap&lt;&gt;())
4656                         .put(cand.value(), cand);
4657             }
4658             for (Map.Entry&lt;String, Map&lt;String, Candidate&gt;&gt; entry : sorted.entrySet()) {
4659                 String group = entry.getKey();
4660                 if (group.isEmpty() &amp;&amp; sorted.size() &gt; 1) {
4661                     group = getOthersGroupName();
4662                 }
4663                 if (!group.isEmpty() &amp;&amp; autoGroup) {
4664                     strings.add(group);
4665                 }
4666                 strings.add(new ArrayList&lt;&gt;(entry.getValue().values()));
4667                 if (ordered != null) {
4668                     ordered.addAll(entry.getValue().values());
4669                 }
4670             }
4671         } else {
4672             Set&lt;String&gt; groups = new LinkedHashSet&lt;&gt;();
4673             TreeMap&lt;String, Candidate&gt; sorted = new TreeMap&lt;&gt;();
4674             for (Candidate cand : possible) {
4675                 String group = cand.group();
4676                 if (group != null) {
4677                     groups.add(group);
4678                 }
4679                 sorted.put(cand.value(), cand);
4680             }
4681             if (autoGroup) {
4682                 strings.addAll(groups);
4683             }
4684             strings.add(new ArrayList&lt;&gt;(sorted.values()));
4685             if (ordered != null) {
4686                 ordered.addAll(sorted.values());
4687             }
4688         }
4689         return toColumns(strings, selection, completed, wcwidth, width, rowsFirst);
4690     }
4691 
4692     private static final String DESC_PREFIX = &quot;(&quot;;
4693     private static final String DESC_SUFFIX = &quot;)&quot;;
4694     private static final int MARGIN_BETWEEN_DISPLAY_AND_DESC = 1;
4695     private static final int MARGIN_BETWEEN_COLUMNS = 3;
4696 
4697     @SuppressWarnings(&quot;unchecked&quot;)
4698     protected PostResult toColumns(List&lt;Object&gt; items, Candidate selection, String completed, Function&lt;String, Integer&gt; wcwidth, int width, boolean rowsFirst) {
4699         int[] out = new int[2];
4700         // TODO: support Option.LIST_PACKED
4701         // Compute column width
4702         int maxWidth = 0;
4703         for (Object item : items) {
4704             if (item instanceof String) {
4705                 int len = wcwidth.apply((String) item);
4706                 maxWidth = Math.max(maxWidth, len);
4707             }
4708             else if (item instanceof List) {
4709                 for (Candidate cand : (List&lt;Candidate&gt;) item) {
4710                     int len = wcwidth.apply(cand.displ());
4711                     if (cand.descr() != null) {
4712                         len += MARGIN_BETWEEN_DISPLAY_AND_DESC;
4713                         len += DESC_PREFIX.length();
4714                         len += wcwidth.apply(cand.descr());
4715                         len += DESC_SUFFIX.length();
4716                     }
4717                     maxWidth = Math.max(maxWidth, len);
4718                 }
4719             }
4720         }
4721         // Build columns
4722         AttributedStringBuilder sb = new AttributedStringBuilder();
4723         for (Object list : items) {
4724             toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, out);
4725         }
4726         if (sb.length() &gt; 0 &amp;&amp; sb.charAt(sb.length() - 1) == &#39;\n&#39;) {
4727             sb.setLength(sb.length() - 1);
4728         }
4729         return new PostResult(sb.toAttributedString(), out[0], out[1]);
4730     }
4731 
4732     @SuppressWarnings(&quot;unchecked&quot;)
4733     protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {
<a name="71" id="anc71"></a><span class="line-modified">4734         if (maxWidth &lt;= 0) {</span>
4735             return;
4736         }
4737         // This is a group
4738         if (items instanceof String) {
4739             sb.style(getCompletionStyleGroup())
4740                     .append((String) items)
4741                     .style(AttributedStyle.DEFAULT)
4742                     .append(&quot;\n&quot;);
4743             out[0]++;
4744         }
4745         // This is a Candidate list
4746         else if (items instanceof List) {
4747             List&lt;Candidate&gt; candidates = (List&lt;Candidate&gt;) items;
4748             maxWidth = Math.min(width, maxWidth);
4749             int c = width / maxWidth;
4750             while (c &gt; 1 &amp;&amp; c * maxWidth + (c - 1) * MARGIN_BETWEEN_COLUMNS &gt;= width) {
4751                 c--;
4752             }
4753             int lines = (candidates.size() + c - 1) / c;
4754             // Try to minimize the number of columns for the given number of rows
4755             // Prevents eg 9 candiates being split 6/3 instead of 5/4.
4756             final int columns = (candidates.size() + lines - 1) / lines;
4757             IntBinaryOperator index;
4758             if (rowsFirst) {
4759                 index = (i, j) -&gt; i * columns + j;
4760             } else {
4761                 index = (i, j) -&gt; j * lines + i;
4762             }
4763             for (int i = 0; i &lt; lines; i++) {
4764                 for (int j = 0; j &lt; columns; j++) {
4765                     int idx = index.applyAsInt(i, j);
4766                     if (idx &lt; candidates.size()) {
4767                         Candidate cand = candidates.get(idx);
4768                         boolean hasRightItem = j &lt; columns - 1 &amp;&amp; index.applyAsInt(i, j + 1) &lt; candidates.size();
4769                         AttributedString left = AttributedString.fromAnsi(cand.displ());
4770                         AttributedString right = AttributedString.fromAnsi(cand.descr());
4771                         int lw = left.columnLength();
4772                         int rw = 0;
4773                         if (right != null) {
4774                             int rem = maxWidth - (lw + MARGIN_BETWEEN_DISPLAY_AND_DESC
4775                                     + DESC_PREFIX.length() + DESC_SUFFIX.length());
4776                             rw = right.columnLength();
4777                             if (rw &gt; rem) {
4778                                 right = AttributedStringBuilder.append(
4779                                             right.columnSubSequence(0, rem - WCWidth.wcwidth(&#39;\u2026&#39;)),
4780                                             &quot;\u2026&quot;);
4781                                 rw = right.columnLength();
4782                             }
4783                             right = AttributedStringBuilder.append(DESC_PREFIX, right, DESC_SUFFIX);
4784                             rw += DESC_PREFIX.length() + DESC_SUFFIX.length();
4785                         }
4786                         if (cand == selection) {
4787                             out[1] = i;
4788                             sb.style(getCompletionStyleSelection());
4789                             if (left.toString().regionMatches(
4790                                     isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {
4791                                 sb.append(left.toString(), 0, completed.length());
4792                                 sb.append(left.toString(), completed.length(), left.length());
4793                             } else {
4794                                 sb.append(left.toString());
4795                             }
4796                             for (int k = 0; k &lt; maxWidth - lw - rw; k++) {
4797                                 sb.append(&#39; &#39;);
4798                             }
4799                             if (right != null) {
4800                                 sb.append(right);
4801                             }
4802                             sb.style(AttributedStyle.DEFAULT);
4803                         } else {
4804                             if (left.toString().regionMatches(
4805                                     isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {
4806                                 sb.style(getCompletionStyleStarting());
4807                                 sb.append(left, 0, completed.length());
4808                                 sb.style(AttributedStyle.DEFAULT);
4809                                 sb.append(left, completed.length(), left.length());
4810                             } else {
4811                                 sb.append(left);
4812                             }
4813                             if (right != null || hasRightItem) {
4814                                 for (int k = 0; k &lt; maxWidth - lw - rw; k++) {
4815                                     sb.append(&#39; &#39;);
4816                                 }
4817                             }
4818                             if (right != null) {
4819                                 sb.style(getCompletionStyleDescription());
4820                                 sb.append(right);
4821                                 sb.style(AttributedStyle.DEFAULT);
4822                             }
4823                         }
4824                         if (hasRightItem) {
4825                             for (int k = 0; k &lt; MARGIN_BETWEEN_COLUMNS; k++) {
4826                                 sb.append(&#39; &#39;);
4827                             }
4828                         }
4829                     }
4830                 }
4831                 sb.append(&#39;\n&#39;);
4832             }
4833             out[0] += lines;
4834         }
4835     }
4836 
4837     private AttributedStyle getCompletionStyleStarting() {
4838         return getCompletionStyle(COMPLETION_STYLE_STARTING, DEFAULT_COMPLETION_STYLE_STARTING);
4839     }
4840 
4841     protected AttributedStyle getCompletionStyleDescription() {
4842         return getCompletionStyle(COMPLETION_STYLE_DESCRIPTION, DEFAULT_COMPLETION_STYLE_DESCRIPTION);
4843     }
4844 
4845     protected AttributedStyle getCompletionStyleGroup() {
4846         return getCompletionStyle(COMPLETION_STYLE_GROUP, DEFAULT_COMPLETION_STYLE_GROUP);
4847     }
4848 
4849     protected AttributedStyle getCompletionStyleSelection() {
4850         return getCompletionStyle(COMPLETION_STYLE_SELECTION, DEFAULT_COMPLETION_STYLE_SELECTION);
4851     }
4852 
4853     protected AttributedStyle getCompletionStyle(String name, String value) {
4854         return buildStyle(getString(name, value));
4855     }
4856 
4857     protected AttributedStyle buildStyle(String str) {
4858         return AttributedString.fromAnsi(&quot;\u001b[&quot; + str + &quot;m &quot;).styleAt(0);
4859     }
4860 
4861     private String getCommonStart(String str1, String str2, boolean caseInsensitive) {
4862         int[] s1 = str1.codePoints().toArray();
4863         int[] s2 = str2.codePoints().toArray();
4864         int len = 0;
4865         while (len &lt; Math.min(s1.length, s2.length)) {
4866             int ch1 = s1[len];
4867             int ch2 = s2[len];
4868             if (ch1 != ch2 &amp;&amp; caseInsensitive) {
4869                 ch1 = Character.toUpperCase(ch1);
4870                 ch2 = Character.toUpperCase(ch2);
4871                 if (ch1 != ch2) {
4872                     ch1 = Character.toLowerCase(ch1);
4873                     ch2 = Character.toLowerCase(ch2);
4874                 }
4875             }
4876             if (ch1 != ch2) {
4877                 break;
4878             }
4879             len++;
4880         }
4881         return new String(s1, 0, len);
4882     }
4883 
4884     /**
4885      * Used in &quot;vi&quot; mode for argumented history move, to move a specific
4886      * number of history entries forward or back.
4887      *
4888      * @param next If true, move forward
4889      * @param count The number of entries to move
4890      * @return true if the move was successful
4891      */
4892     protected boolean moveHistory(final boolean next, int count) {
4893         boolean ok = true;
4894         for (int i = 0; i &lt; count &amp;&amp; (ok = moveHistory(next)); i++) {
4895             /* empty */
4896         }
4897         return ok;
4898     }
4899 
4900     /**
4901      * Move up or down the history tree.
4902      * @param next &lt;code&gt;true&lt;/code&gt; to go to the next, &lt;code&gt;false&lt;/code&gt; for the previous.
4903      * @return &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise
4904      */
4905     protected boolean moveHistory(final boolean next) {
4906         if (!buf.toString().equals(history.current())) {
4907             modifiedHistory.put(history.index(), buf.toString());
4908         }
4909         if (next &amp;&amp; !history.next()) {
4910             return false;
4911         }
4912         else if (!next &amp;&amp; !history.previous()) {
4913             return false;
4914         }
4915 
4916         setBuffer(modifiedHistory.containsKey(history.index())
4917                     ? modifiedHistory.get(history.index())
4918                     : history.current());
4919 
4920         return true;
4921     }
4922 
4923     //
4924     // Printing
4925     //
4926 
4927     /**
4928      * Raw output printing.
4929      * @param str the string to print to the terminal
4930      */
4931     void print(String str) {
4932         terminal.writer().write(str);
4933     }
4934 
4935     void println(String s) {
4936         print(s);
4937         println();
4938     }
4939 
4940     /**
4941      * Output a platform-dependant newline.
4942      */
4943     void println() {
4944         terminal.puts(Capability.carriage_return);
4945         print(&quot;\n&quot;);
4946         redrawLine();
4947     }
4948 
4949 
4950     //
4951     // Actions
4952     //
4953 
4954     protected boolean killBuffer() {
4955         killRing.add(buf.toString());
4956         buf.clear();
4957         return true;
4958     }
4959 
4960     protected boolean killWholeLine() {
4961         if (buf.length() == 0) {
4962             return false;
4963         }
4964         int start;
4965         int end;
4966         if (count &lt; 0) {
4967             end = buf.cursor();
4968             while (buf.atChar(end) != 0 &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
4969                 end++;
4970             }
4971             start = end;
4972             for (int count = -this.count; count &gt; 0; --count) {
4973                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
4974                     start--;
4975                 }
4976                 start--;
4977             }
4978         } else {
4979             start = buf.cursor();
4980             while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
4981                 start--;
4982             }
4983             end = start;
4984             while (count-- &gt; 0) {
4985                 while (end &lt; buf.length() &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
4986                     end++;
4987                 }
<a name="72" id="anc72"></a><span class="line-modified">4988                 end++;</span>


4989             }
4990         }
4991         String killed = buf.substring(start, end);
4992         buf.cursor(start);
4993         buf.delete(end - start);
4994         killRing.add(killed);
4995         return true;
4996     }
4997 
4998     /**
4999      * Kill the buffer ahead of the current cursor position.
5000      *
5001      * @return true if successful
5002      */
5003     public boolean killLine() {
5004         if (count &lt; 0) {
5005             return callNeg(this::backwardKillLine);
5006         }
5007         if (buf.cursor() == buf.length()) {
5008             return false;
5009         }
5010         int cp = buf.cursor();
5011         int len = cp;
5012         while (count-- &gt; 0) {
5013             if (buf.atChar(len) == &#39;\n&#39;) {
5014                 len++;
5015             } else {
5016                 while (buf.atChar(len) != 0 &amp;&amp; buf.atChar(len) != &#39;\n&#39;) {
5017                     len++;
5018                 }
5019             }
5020         }
5021         int num = len - cp;
5022         String killed = buf.substring(cp, cp + num);
5023         buf.delete(num);
5024         killRing.add(killed);
5025         return true;
5026     }
5027 
5028     public boolean backwardKillLine() {
5029         if (count &lt; 0) {
5030             return callNeg(this::killLine);
5031         }
5032         if (buf.cursor() == 0) {
5033             return false;
5034         }
5035         int cp = buf.cursor();
5036         int beg = cp;
5037         while (count-- &gt; 0) {
5038             if (beg == 0) {
5039                 break;
5040             }
5041             if (buf.atChar(beg - 1) == &#39;\n&#39;) {
5042                 beg--;
5043             } else {
5044                 while (beg &gt; 0 &amp;&amp; buf.atChar(beg - 1) != 0 &amp;&amp; buf.atChar(beg - 1) != &#39;\n&#39;) {
5045                     beg--;
5046                 }
5047             }
5048         }
5049         int num = cp - beg;
5050         String killed = buf.substring(cp - beg, cp);
5051         buf.cursor(beg);
5052         buf.delete(num);
5053         killRing.add(killed);
5054         return true;
5055     }
5056 
5057     public boolean killRegion() {
5058         return doCopyKillRegion(true);
5059     }
5060 
5061     public boolean copyRegionAsKill() {
5062         return doCopyKillRegion(false);
5063     }
5064 
5065     private boolean doCopyKillRegion(boolean kill) {
5066         if (regionMark &gt; buf.length()) {
5067             regionMark = buf.length();
5068         }
5069         if (regionActive == RegionType.LINE) {
5070             int start = regionMark;
5071             int end = buf.cursor();
5072             if (start &lt; end) {
5073                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5074                     start--;
5075                 }
5076                 while (end &lt; buf.length() - 1 &amp;&amp; buf.atChar(end + 1) != &#39;\n&#39;) {
5077                     end++;
5078                 }
5079                 if (isInViCmdMode()) {
5080                     end++;
5081                 }
5082                 killRing.add(buf.substring(start, end));
5083                 if (kill) {
5084                     buf.backspace(end - start);
5085                 }
5086             } else {
5087                 while (end &gt; 0 &amp;&amp; buf.atChar(end - 1) != &#39;\n&#39;) {
5088                     end--;
5089                 }
5090                 while (start &lt; buf.length() &amp;&amp; buf.atChar(start) != &#39;\n&#39;) {
5091                     start++;
5092                 }
5093                 if (isInViCmdMode()) {
5094                     start++;
5095                 }
5096                 killRing.addBackwards(buf.substring(end, start));
5097                 if (kill) {
5098                     buf.cursor(end);
5099                     buf.delete(start - end);
5100                 }
5101             }
5102         } else if (regionMark &gt; buf.cursor()) {
5103             if (isInViCmdMode()) {
5104                 regionMark++;
5105             }
5106             killRing.add(buf.substring(buf.cursor(), regionMark));
5107             if (kill) {
5108                 buf.delete(regionMark - buf.cursor());
5109             }
5110         } else {
5111             if (isInViCmdMode()) {
5112                 buf.move(1);
5113             }
5114             killRing.add(buf.substring(regionMark, buf.cursor()));
5115             if (kill) {
5116                 buf.backspace(buf.cursor() - regionMark);
5117             }
5118         }
5119         if (kill) {
5120             regionActive = RegionType.NONE;
5121         }
5122         return true;
5123     }
5124 
5125     public boolean yank() {
5126         String yanked = killRing.yank();
5127         if (yanked == null) {
5128             return false;
5129         } else {
5130             putString(yanked);
5131             return true;
5132         }
5133     }
5134 
5135     public boolean yankPop() {
5136         if (!killRing.lastYank()) {
5137             return false;
5138         }
5139         String current = killRing.yank();
5140         if (current == null) {
5141             // This shouldn&#39;t happen.
5142             return false;
5143         }
5144         buf.backspace(current.length());
5145         String yanked = killRing.yankPop();
5146         if (yanked == null) {
5147             // This shouldn&#39;t happen.
5148             return false;
5149         }
5150 
5151         putString(yanked);
5152         return true;
5153     }
5154 
5155     public boolean mouse() {
5156         MouseEvent event = readMouseEvent();
5157         if (event.getType() == MouseEvent.Type.Released
5158                 &amp;&amp; event.getButton() == MouseEvent.Button.Button1) {
5159             StringBuilder tsb = new StringBuilder();
5160             Cursor cursor = terminal.getCursorPosition(c -&gt; tsb.append((char) c));
5161             bindingReader.runMacro(tsb.toString());
5162 
5163             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();
5164             getDisplayedBufferWithPrompts(secondaryPrompts);
5165 
5166             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
5167             sb.append(prompt);
5168             sb.append(insertSecondaryPrompts(new AttributedString(buf.upToCursor()), secondaryPrompts, false));
5169             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
5170 
5171             int currentLine = promptLines.size() - 1;
5172             int wantedLine = Math.max(0, Math.min(currentLine + event.getY() - cursor.getY(), secondaryPrompts.size()));
5173             int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();
5174             int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();
5175             int adjust = pl1 - pl0;
5176             buf.moveXY(event.getX() - cursor.getX() - adjust, event.getY() - cursor.getY());
5177         }
5178         return true;
5179     }
5180 
5181     public boolean beginPaste() {
5182         final Object SELF_INSERT = new Object();
5183         final Object END_PASTE = new Object();
5184         KeyMap&lt;Object&gt; keyMap = new KeyMap&lt;&gt;();
5185         keyMap.setUnicode(SELF_INSERT);
5186         keyMap.setNomatch(SELF_INSERT);
5187         keyMap.setAmbiguousTimeout(0);
5188         keyMap.bind(END_PASTE, BRACKETED_PASTE_END);
5189         StringBuilder sb = new StringBuilder();
5190         while (true) {
<a name="73" id="anc73"></a><span class="line-modified">5191             Object b = bindingReader.readBinding(keyMap);</span>
5192             if (b == END_PASTE) {
5193                 break;
5194             }
5195             String s = getLastBinding();
5196             if (&quot;\r&quot;.equals(s)) {
5197                 s = &quot;\n&quot;;
5198             }
5199             sb.append(s);
5200         }
5201         regionActive = RegionType.PASTE;
5202         regionMark = getBuffer().cursor();
5203         getBuffer().write(sb);
5204         return true;
5205     }
5206 
5207     public boolean focusIn() {
5208         return false;
5209     }
5210 
5211     public boolean focusOut() {
5212         return false;
5213     }
5214 
5215     /**
5216      * Clean the used display
5217      * @return &lt;code&gt;true&lt;/code&gt;
5218      */
5219     public boolean clear() {
5220         display.update(Collections.emptyList(), 0);
5221         return true;
5222     }
5223 
5224     /**
5225      * Clear the screen by issuing the ANSI &quot;clear screen&quot; code.
5226      * @return &lt;code&gt;true&lt;/code&gt;
5227      */
5228     public boolean clearScreen() {
5229         if (terminal.puts(Capability.clear_screen)) {
<a name="74" id="anc74"></a>




5230             Status status = Status.getStatus(terminal, false);
5231             if (status != null) {
5232                 status.reset();
5233             }
5234             redrawLine();
5235         } else {
5236             println();
5237         }
5238         return true;
5239     }
5240 
5241     /**
5242      * Issue an audible keyboard bell.
5243      * @return &lt;code&gt;true&lt;/code&gt;
5244      */
5245     public boolean beep() {
5246         BellType bell_preference = BellType.AUDIBLE;
5247         switch (getString(BELL_STYLE, DEFAULT_BELL_STYLE).toLowerCase()) {
5248             case &quot;none&quot;:
5249             case &quot;off&quot;:
5250                 bell_preference = BellType.NONE;
5251                 break;
5252             case &quot;audible&quot;:
5253                 bell_preference = BellType.AUDIBLE;
5254                 break;
5255             case &quot;visible&quot;:
5256                 bell_preference = BellType.VISIBLE;
5257                 break;
5258             case &quot;on&quot;:
5259                 bell_preference = getBoolean(PREFER_VISIBLE_BELL, false)
5260                         ? BellType.VISIBLE : BellType.AUDIBLE;
5261                 break;
5262         }
5263         if (bell_preference == BellType.VISIBLE) {
5264             if (terminal.puts(Capability.flash_screen)
5265                     || terminal.puts(Capability.bell)) {
5266                 flush();
5267             }
5268         } else if (bell_preference == BellType.AUDIBLE) {
5269             if (terminal.puts(Capability.bell)) {
5270                 flush();
5271             }
5272         }
5273         return true;
5274     }
5275 
5276     //
5277     // Helpers
5278     //
5279 
5280     /**
5281      * Checks to see if the specified character is a delimiter. We consider a
5282      * character a delimiter if it is anything but a letter or digit.
5283      *
5284      * @param c     The character to test
5285      * @return      True if it is a delimiter
5286      */
5287     protected boolean isDelimiter(int c) {
5288         return !Character.isLetterOrDigit(c);
5289     }
5290 
5291     /**
5292      * Checks to see if a character is a whitespace character. Currently
5293      * this delegates to {@link Character#isWhitespace(char)}, however
5294      * eventually it should be hooked up so that the definition of whitespace
5295      * can be configured, as readline does.
5296      *
5297      * @param c The character to check
5298      * @return true if the character is a whitespace
5299      */
5300     protected boolean isWhitespace(int c) {
5301         return Character.isWhitespace(c);
5302     }
5303 
5304     protected boolean isViAlphaNum(int c) {
5305         return c == &#39;_&#39; || Character.isLetterOrDigit(c);
5306     }
5307 
5308     protected boolean isAlpha(int c) {
5309         return Character.isLetter(c);
5310     }
5311 
5312     protected boolean isWord(int c) {
5313         String wordchars = getString(WORDCHARS, DEFAULT_WORDCHARS);
5314         return Character.isLetterOrDigit(c)
5315                 || (c &lt; 128 &amp;&amp; wordchars.indexOf((char) c) &gt;= 0);
5316     }
5317 
5318     String getString(String name, String def) {
5319         return ReaderUtils.getString(this, name, def);
5320     }
5321 
5322     boolean getBoolean(String name, boolean def) {
5323         return ReaderUtils.getBoolean(this, name, def);
5324     }
5325 
5326     int getInt(String name, int def) {
5327         return ReaderUtils.getInt(this, name, def);
5328     }
5329 
5330     long getLong(String name, long def) {
5331         return ReaderUtils.getLong(this, name, def);
5332     }
5333 
5334     @Override
5335     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; defaultKeyMaps() {
5336         Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps = new HashMap&lt;&gt;();
5337         keyMaps.put(EMACS, emacs());
5338         keyMaps.put(VICMD, viCmd());
5339         keyMaps.put(VIINS, viInsertion());
5340         keyMaps.put(MENU, menu());
5341         keyMaps.put(VIOPP, viOpp());
5342         keyMaps.put(VISUAL, visual());
5343         keyMaps.put(SAFE, safe());
5344         if (getBoolean(BIND_TTY_SPECIAL_CHARS, true)) {
5345             Attributes attr = terminal.getAttributes();
5346             bindConsoleChars(keyMaps.get(EMACS), attr);
5347             bindConsoleChars(keyMaps.get(VIINS), attr);
5348         }
5349         // Put default
5350         for (KeyMap&lt;Binding&gt; keyMap : keyMaps.values()) {
5351             keyMap.setUnicode(new Reference(SELF_INSERT));
5352             keyMap.setAmbiguousTimeout(getLong(AMBIGUOUS_BINDING, DEFAULT_AMBIGUOUS_BINDING));
5353         }
5354         // By default, link main to emacs
5355         keyMaps.put(MAIN, keyMaps.get(EMACS));
5356         return keyMaps;
5357     }
5358 
5359     public KeyMap&lt;Binding&gt; emacs() {
5360         KeyMap&lt;Binding&gt; emacs = new KeyMap&lt;&gt;();
<a name="75" id="anc75"></a>
5361         bind(emacs, SET_MARK_COMMAND,                       ctrl(&#39;@&#39;));
5362         bind(emacs, BEGINNING_OF_LINE,                      ctrl(&#39;A&#39;));
5363         bind(emacs, BACKWARD_CHAR,                          ctrl(&#39;B&#39;));
5364         bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl(&#39;D&#39;));
5365         bind(emacs, END_OF_LINE,                            ctrl(&#39;E&#39;));
5366         bind(emacs, FORWARD_CHAR,                           ctrl(&#39;F&#39;));
5367         bind(emacs, SEND_BREAK,                             ctrl(&#39;G&#39;));
5368         bind(emacs, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5369         bind(emacs, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5370         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5371         bind(emacs, KILL_LINE,                              ctrl(&#39;K&#39;));
5372         bind(emacs, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5373         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5374         bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));
<a name="76" id="anc76"></a>
5375         bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
5376         bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5377         bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5378         bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5379         bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5380         bind(emacs, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5381         bind(emacs, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5382         bind(emacs, YANK,                                   ctrl(&#39;Y&#39;));
5383         bind(emacs, CHARACTER_SEARCH,                       ctrl(&#39;]&#39;));
5384         bind(emacs, UNDO,                                   ctrl(&#39;_&#39;));
5385         bind(emacs, SELF_INSERT,                            range(&quot; -~&quot;));
5386         bind(emacs, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5387         bind(emacs, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5388         bind(emacs, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5389         bind(emacs, BACKWARD_DELETE_CHAR,                   del());
5390         bind(emacs, VI_MATCH_BRACKET,                       translate(&quot;^X^B&quot;));
5391         bind(emacs, SEND_BREAK,                             translate(&quot;^X^G&quot;));
5392         bind(emacs, VI_FIND_NEXT_CHAR,                      translate(&quot;^X^F&quot;));
5393         bind(emacs, VI_JOIN,                                translate(&quot;^X^J&quot;));
5394         bind(emacs, KILL_BUFFER,                            translate(&quot;^X^K&quot;));
5395         bind(emacs, INFER_NEXT_HISTORY,                     translate(&quot;^X^N&quot;));
5396         bind(emacs, OVERWRITE_MODE,                         translate(&quot;^X^O&quot;));
5397         bind(emacs, REDO,                                   translate(&quot;^X^R&quot;));
5398         bind(emacs, UNDO,                                   translate(&quot;^X^U&quot;));
5399         bind(emacs, VI_CMD_MODE,                            translate(&quot;^X^V&quot;));
5400         bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(&quot;^X^X&quot;));
5401         bind(emacs, DO_LOWERCASE_VERSION,                   translate(&quot;^XA-^XZ&quot;));
5402         bind(emacs, WHAT_CURSOR_POSITION,                   translate(&quot;^X=&quot;));
5403         bind(emacs, KILL_LINE,                              translate(&quot;^X^?&quot;));
5404         bind(emacs, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5405         bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5406         bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5407         bind(emacs, COMPLETE_WORD,                          alt(esc()));
5408         bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5409         bind(emacs, COPY_PREV_WORD,                         alt(ctrl(&#39;_&#39;)));
5410         bind(emacs, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5411         bind(emacs, NEG_ARGUMENT,                           alt(&#39;-&#39;));
5412         bind(emacs, DIGIT_ARGUMENT,                         range(&quot;\\E0-\\E9&quot;));
5413         bind(emacs, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5414         bind(emacs, LIST_CHOICES,                           alt(&#39;=&#39;));
5415         bind(emacs, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5416         bind(emacs, LIST_CHOICES,                           alt(&#39;?&#39;));
5417         bind(emacs, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
<a name="77" id="anc77"></a>
5418         bind(emacs, BACKWARD_WORD,                          alt(&#39;b&#39;));
5419         bind(emacs, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5420         bind(emacs, KILL_WORD,                              alt(&#39;d&#39;));
5421         bind(emacs, KILL_WORD,                              translate(&quot;^[[3;5~&quot;)); // ctrl-delete
5422         bind(emacs, FORWARD_WORD,                           alt(&#39;f&#39;));
5423         bind(emacs, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5424         bind(emacs, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5425         bind(emacs, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5426         bind(emacs, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5427         bind(emacs, UP_CASE_WORD,                           alt(&#39;u&#39;));
5428         bind(emacs, YANK_POP,                               alt(&#39;y&#39;));
5429         bind(emacs, BACKWARD_KILL_WORD,                     alt(del()));
5430         bindArrowKeys(emacs);
5431         bind(emacs, FORWARD_WORD,                           translate(&quot;^[[1;5C&quot;)); // ctrl-left
5432         bind(emacs, BACKWARD_WORD,                          translate(&quot;^[[1;5D&quot;)); // ctrl-right
5433         bind(emacs, FORWARD_WORD,                           alt(key(Capability.key_right)));
5434         bind(emacs, BACKWARD_WORD,                          alt(key(Capability.key_left)));
5435         bind(emacs, FORWARD_WORD,                           alt(translate(&quot;^[[C&quot;)));
5436         bind(emacs, BACKWARD_WORD,                          alt(translate(&quot;^[[D&quot;)));
5437         return emacs;
5438     }
5439 
5440     public KeyMap&lt;Binding&gt; viInsertion() {
5441         KeyMap&lt;Binding&gt; viins = new KeyMap&lt;&gt;();
<a name="78" id="anc78"></a>
5442         bind(viins, SELF_INSERT,                            range(&quot;^@-^_&quot;));
5443         bind(viins, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5444         bind(viins, SEND_BREAK,                             ctrl(&#39;G&#39;));
5445         bind(viins, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5446         bind(viins, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5447         bind(viins, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5448         bind(viins, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5449         bind(viins, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5450         bind(viins, MENU_COMPLETE,                          ctrl(&#39;N&#39;));
5451         bind(viins, REVERSE_MENU_COMPLETE,                  ctrl(&#39;P&#39;));
5452         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5453         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5454         bind(viins, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5455         bind(viins, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5456         bind(viins, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5457         bind(viins, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5458         bind(viins, YANK,                                   ctrl(&#39;Y&#39;));
5459         bind(viins, VI_CMD_MODE,                            ctrl(&#39;[&#39;));
5460         bind(viins, UNDO,                                   ctrl(&#39;_&#39;));
5461         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
5462         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;X&#39;) + &quot;s&quot;);
5463         bind(viins, SELF_INSERT,                            range(&quot; -~&quot;));
5464         bind(viins, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5465         bind(viins, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5466         bind(viins, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5467         bind(viins, BACKWARD_DELETE_CHAR,                   del());
5468         bindArrowKeys(viins);
5469         return viins;
5470     }
5471 
5472     public KeyMap&lt;Binding&gt; viCmd() {
5473         KeyMap&lt;Binding&gt; vicmd = new KeyMap&lt;&gt;();
5474         bind(vicmd, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5475         bind(vicmd, EMACS_EDITING_MODE,                     ctrl(&#39;E&#39;));
5476         bind(vicmd, SEND_BREAK,                             ctrl(&#39;G&#39;));
5477         bind(vicmd, VI_BACKWARD_CHAR,                       ctrl(&#39;H&#39;));
5478         bind(vicmd, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5479         bind(vicmd, KILL_LINE,                              ctrl(&#39;K&#39;));
5480         bind(vicmd, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5481         bind(vicmd, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5482         bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                ctrl(&#39;N&#39;));
5483         bind(vicmd, VI_UP_LINE_OR_HISTORY,                  ctrl(&#39;P&#39;));
5484         bind(vicmd, QUOTED_INSERT,                          ctrl(&#39;Q&#39;));
5485         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5486         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5487         bind(vicmd, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5488         bind(vicmd, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5489         bind(vicmd, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5490         bind(vicmd, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5491         bind(vicmd, YANK,                                   ctrl(&#39;Y&#39;));
5492         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
5493         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;X&#39;) + &quot;s&quot;);
5494         bind(vicmd, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5495         bind(vicmd, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5496         bind(vicmd, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5497         bind(vicmd, COMPLETE_WORD,                          alt(esc()));
5498         bind(vicmd, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5499         bind(vicmd, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5500 //        bind(vicmd, INSERT_COMMENT,                         alt(&#39;#&#39;));
5501 //        bind(vicmd, INSERT_COMPLETIONS,                     alt(&#39;*&#39;));
5502         bind(vicmd, DIGIT_ARGUMENT,                         alt(&#39;-&#39;));
5503         bind(vicmd, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5504         bind(vicmd, LIST_CHOICES,                           alt(&#39;=&#39;));
5505         bind(vicmd, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5506         bind(vicmd, LIST_CHOICES,                           alt(&#39;?&#39;));
5507         bind(vicmd, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
5508         bind(vicmd, BACKWARD_WORD,                          alt(&#39;b&#39;));
5509         bind(vicmd, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5510         bind(vicmd, KILL_WORD,                              alt(&#39;d&#39;));
5511         bind(vicmd, FORWARD_WORD,                           alt(&#39;f&#39;));
5512         bind(vicmd, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5513         bind(vicmd, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5514         bind(vicmd, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5515         bind(vicmd, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5516         bind(vicmd, UP_CASE_WORD,                           alt(&#39;u&#39;));
5517         bind(vicmd, YANK_POP,                               alt(&#39;y&#39;));
5518         bind(vicmd, BACKWARD_KILL_WORD,                     alt(del()));
5519 
5520         bind(vicmd, FORWARD_CHAR,                           &quot; &quot;);
5521         bind(vicmd, VI_INSERT_COMMENT,                      &quot;#&quot;);
5522         bind(vicmd, END_OF_LINE,                            &quot;$&quot;);
5523         bind(vicmd, VI_MATCH_BRACKET,                       &quot;%&quot;);
5524         bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                &quot;+&quot;);
5525         bind(vicmd, VI_REV_REPEAT_FIND,                     &quot;,&quot;);
5526         bind(vicmd, VI_UP_LINE_OR_HISTORY,                  &quot;-&quot;);
5527         bind(vicmd, VI_REPEAT_CHANGE,                       &quot;.&quot;);
5528         bind(vicmd, VI_HISTORY_SEARCH_BACKWARD,             &quot;/&quot;);
5529         bind(vicmd, VI_DIGIT_OR_BEGINNING_OF_LINE,          &quot;0&quot;);
5530         bind(vicmd, DIGIT_ARGUMENT,                         range(&quot;1-9&quot;));
5531         bind(vicmd, VI_REPEAT_FIND,                         &quot;;&quot;);
5532         bind(vicmd, LIST_CHOICES,                           &quot;=&quot;);
5533         bind(vicmd, VI_HISTORY_SEARCH_FORWARD,              &quot;?&quot;);
5534         bind(vicmd, VI_ADD_EOL,                             &quot;A&quot;);
5535         bind(vicmd, VI_BACKWARD_BLANK_WORD,                 &quot;B&quot;);
5536         bind(vicmd, VI_CHANGE_EOL,                          &quot;C&quot;);
5537         bind(vicmd, VI_KILL_EOL,                            &quot;D&quot;);
5538         bind(vicmd, VI_FORWARD_BLANK_WORD_END,              &quot;E&quot;);
5539         bind(vicmd, VI_FIND_PREV_CHAR,                      &quot;F&quot;);
5540         bind(vicmd, VI_FETCH_HISTORY,                       &quot;G&quot;);
5541         bind(vicmd, VI_INSERT_BOL,                          &quot;I&quot;);
5542         bind(vicmd, VI_JOIN,                                &quot;J&quot;);
5543         bind(vicmd, VI_REV_REPEAT_SEARCH,                   &quot;N&quot;);
5544         bind(vicmd, VI_OPEN_LINE_ABOVE,                     &quot;O&quot;);
5545         bind(vicmd, VI_PUT_BEFORE,                          &quot;P&quot;);
5546         bind(vicmd, VI_REPLACE,                             &quot;R&quot;);
5547         bind(vicmd, VI_KILL_LINE,                           &quot;S&quot;);
5548         bind(vicmd, VI_FIND_PREV_CHAR_SKIP,                 &quot;T&quot;);
5549         bind(vicmd, REDO,                                   &quot;U&quot;);
5550         bind(vicmd, VISUAL_LINE_MODE,                       &quot;V&quot;);
5551         bind(vicmd, VI_FORWARD_BLANK_WORD,                  &quot;W&quot;);
5552         bind(vicmd, VI_BACKWARD_DELETE_CHAR,                &quot;X&quot;);
5553         bind(vicmd, VI_YANK_WHOLE_LINE,                     &quot;Y&quot;);
5554         bind(vicmd, VI_FIRST_NON_BLANK,                     &quot;^&quot;);
5555         bind(vicmd, VI_ADD_NEXT,                            &quot;a&quot;);
5556         bind(vicmd, VI_BACKWARD_WORD,                       &quot;b&quot;);
5557         bind(vicmd, VI_CHANGE,                              &quot;c&quot;);
5558         bind(vicmd, VI_DELETE,                              &quot;d&quot;);
5559         bind(vicmd, VI_FORWARD_WORD_END,                    &quot;e&quot;);
5560         bind(vicmd, VI_FIND_NEXT_CHAR,                      &quot;f&quot;);
5561         bind(vicmd, WHAT_CURSOR_POSITION,                   &quot;ga&quot;);
5562         bind(vicmd, VI_BACKWARD_BLANK_WORD_END,             &quot;gE&quot;);
5563         bind(vicmd, VI_BACKWARD_WORD_END,                   &quot;ge&quot;);
5564         bind(vicmd, VI_BACKWARD_CHAR,                       &quot;h&quot;);
5565         bind(vicmd, VI_INSERT,                              &quot;i&quot;);
5566         bind(vicmd, DOWN_LINE_OR_HISTORY,                   &quot;j&quot;);
5567         bind(vicmd, UP_LINE_OR_HISTORY,                     &quot;k&quot;);
5568         bind(vicmd, VI_FORWARD_CHAR,                        &quot;l&quot;);
5569         bind(vicmd, VI_REPEAT_SEARCH,                       &quot;n&quot;);
5570         bind(vicmd, VI_OPEN_LINE_BELOW,                     &quot;o&quot;);
5571         bind(vicmd, VI_PUT_AFTER,                           &quot;p&quot;);
5572         bind(vicmd, VI_REPLACE_CHARS,                       &quot;r&quot;);
5573         bind(vicmd, VI_SUBSTITUTE,                          &quot;s&quot;);
5574         bind(vicmd, VI_FIND_NEXT_CHAR_SKIP,                 &quot;t&quot;);
5575         bind(vicmd, UNDO,                                   &quot;u&quot;);
5576         bind(vicmd, VISUAL_MODE,                            &quot;v&quot;);
5577         bind(vicmd, VI_FORWARD_WORD,                        &quot;w&quot;);
5578         bind(vicmd, VI_DELETE_CHAR,                         &quot;x&quot;);
5579         bind(vicmd, VI_YANK,                                &quot;y&quot;);
5580         bind(vicmd, VI_GOTO_COLUMN,                         &quot;|&quot;);
5581         bind(vicmd, VI_SWAP_CASE,                           &quot;~&quot;);
5582         bind(vicmd, VI_BACKWARD_CHAR,                       del());
5583 
5584         bindArrowKeys(vicmd);
5585         return vicmd;
5586     }
5587 
5588     public KeyMap&lt;Binding&gt; menu() {
5589         KeyMap&lt;Binding&gt; menu = new KeyMap&lt;&gt;();
5590         bind(menu, MENU_COMPLETE,                     &quot;\t&quot;);
5591         bind(menu, REVERSE_MENU_COMPLETE,             key(Capability.back_tab));
5592         bind(menu, ACCEPT_LINE,                       &quot;\r&quot;, &quot;\n&quot;);
5593         bindArrowKeys(menu);
5594         return menu;
5595     }
5596 
5597     public KeyMap&lt;Binding&gt; safe() {
5598         KeyMap&lt;Binding&gt; safe = new KeyMap&lt;&gt;();
5599         bind(safe, SELF_INSERT,                 range(&quot;^@-^?&quot;));
5600         bind(safe, ACCEPT_LINE,                 &quot;\r&quot;, &quot;\n&quot;);
5601         bind(safe, SEND_BREAK,                  ctrl(&#39;G&#39;));
5602         return safe;
5603     }
5604 
5605     public KeyMap&lt;Binding&gt; visual() {
5606         KeyMap&lt;Binding&gt; visual = new KeyMap&lt;&gt;();
5607         bind(visual, UP_LINE,                   key(Capability.key_up),     &quot;k&quot;);
5608         bind(visual, DOWN_LINE,                 key(Capability.key_down),   &quot;j&quot;);
5609         bind(visual, this::deactivateRegion,    esc());
5610         bind(visual, EXCHANGE_POINT_AND_MARK,   &quot;o&quot;);
5611         bind(visual, PUT_REPLACE_SELECTION,     &quot;p&quot;);
5612         bind(visual, VI_DELETE,                 &quot;x&quot;);
5613         bind(visual, VI_OPER_SWAP_CASE,         &quot;~&quot;);
5614         return visual;
5615     }
5616 
5617     public KeyMap&lt;Binding&gt; viOpp() {
5618         KeyMap&lt;Binding&gt; viOpp = new KeyMap&lt;&gt;();
5619         bind(viOpp, UP_LINE,                    key(Capability.key_up),     &quot;k&quot;);
5620         bind(viOpp, DOWN_LINE,                  key(Capability.key_down),   &quot;j&quot;);
5621         bind(viOpp, VI_CMD_MODE,                esc());
5622         return viOpp;
5623     }
5624 
5625     private void bind(KeyMap&lt;Binding&gt; map, String widget, Iterable&lt;? extends CharSequence&gt; keySeqs) {
5626         map.bind(new Reference(widget), keySeqs);
5627     }
5628 
5629     private void bind(KeyMap&lt;Binding&gt; map, String widget, CharSequence... keySeqs) {
5630         map.bind(new Reference(widget), keySeqs);
5631     }
5632 
5633     private void bind(KeyMap&lt;Binding&gt; map, Widget widget, CharSequence... keySeqs) {
5634         map.bind(widget, keySeqs);
5635     }
5636 
5637     private String key(Capability capability) {
5638         return KeyMap.key(terminal, capability);
5639     }
5640 
<a name="79" id="anc79"></a>







5641     private void bindArrowKeys(KeyMap&lt;Binding&gt; map) {
5642         bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));
5643         bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));
5644         bind(map, BACKWARD_CHAR,        key(Capability.key_left));
5645         bind(map, FORWARD_CHAR,         key(Capability.key_right));
5646         bind(map, BEGINNING_OF_LINE,    key(Capability.key_home));
5647         bind(map, END_OF_LINE,          key(Capability.key_end));
5648         bind(map, DELETE_CHAR,          key(Capability.key_dc));
5649         bind(map, KILL_WHOLE_LINE,      key(Capability.key_dl));
5650         bind(map, OVERWRITE_MODE,       key(Capability.key_ic));
5651         bind(map, MOUSE,                key(Capability.key_mouse));
5652         bind(map, BEGIN_PASTE,          BRACKETED_PASTE_BEGIN);
5653         bind(map, FOCUS_IN,             FOCUS_IN_SEQ);
5654         bind(map, FOCUS_OUT,            FOCUS_OUT_SEQ);
5655     }
5656 
5657     /**
5658      * Bind special chars defined by the terminal instead of
5659      * the default bindings
5660      */
5661     private void bindConsoleChars(KeyMap&lt;Binding&gt; keyMap, Attributes attr) {
5662         if (attr != null) {
5663             rebind(keyMap, BACKWARD_DELETE_CHAR,
5664                     del(), (char) attr.getControlChar(ControlChar.VERASE));
5665             rebind(keyMap, BACKWARD_KILL_WORD,
5666                     ctrl(&#39;W&#39;),  (char) attr.getControlChar(ControlChar.VWERASE));
5667             rebind(keyMap, KILL_WHOLE_LINE,
5668                     ctrl(&#39;U&#39;), (char) attr.getControlChar(ControlChar.VKILL));
5669             rebind(keyMap, QUOTED_INSERT,
5670                     ctrl(&#39;V&#39;), (char) attr.getControlChar(ControlChar.VLNEXT));
5671         }
5672     }
5673 
5674     private void rebind(KeyMap&lt;Binding&gt; keyMap, String operation, String prevBinding, char newBinding) {
5675         if (newBinding &gt; 0 &amp;&amp; newBinding &lt; 128) {
5676             Reference ref = new Reference(operation);
5677             bind(keyMap, SELF_INSERT, prevBinding);
5678             keyMap.bind(ref, Character.toString(newBinding));
5679         }
5680     }
5681 
5682 
5683 }
<a name="80" id="anc80"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="80" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/NonBlockingInputStreamImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="1" id="anc1"></a><span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.io.IOException;
 12 import java.io.InputStream;
 13 import java.io.InterruptedIOException;
 14 
 15 /**
 16  * This class wraps a regular input stream and allows it to appear as if it
 17  * is non-blocking; that is, reads can be performed against it that timeout
 18  * if no data is seen for a period of time.  This effect is achieved by having
 19  * a separate thread perform all non-blocking read requests and then
 20  * waiting on the thread to complete.
 21  *
 22  * &lt;p&gt;VERY IMPORTANT NOTES
 23  * &lt;ul&gt;
 24  *   &lt;li&gt; This class is not thread safe. It expects at most one reader.
 25  *   &lt;li&gt; The {@link #shutdown()} method must be called in order to shut down
 26  *          the thread that handles blocking I/O.
 27  * &lt;/ul&gt;
 28  */
 29 public class NonBlockingInputStreamImpl
 30     extends NonBlockingInputStream
 31 {
 32     private InputStream in;                  // The actual input stream
 33     private int         b = READ_EXPIRED;    // Recently read byte
 34 
 35     private String      name;
 36     private boolean     threadIsReading      = false;
 37     private IOException exception            = null;
 38     private long        threadDelay          = 60 * 1000;
 39     private Thread      thread;
 40 
 41     /**
 42      * Creates a &lt;code&gt;NonBlockingReader&lt;/code&gt; out of a normal blocking
 43      * reader. Note that this call also spawn a separate thread to perform the
 44      * blocking I/O on behalf of the thread that is using this class. The
 45      * {@link #shutdown()} method must be called in order to shut this thread down.
 46      * @param name The stream name
 47      * @param in The reader to wrap
 48      */
 49     public NonBlockingInputStreamImpl(String name, InputStream in) {
 50         this.in = in;
 51         this.name = name;
 52     }
 53 
 54     private synchronized void startReadingThreadIfNeeded() {
 55         if (thread == null) {
 56             thread = new Thread(this::run);
 57             thread.setName(name + &quot; non blocking reader thread&quot;);
 58             thread.setDaemon(true);
 59             thread.start();
 60         }
 61     }
 62 
 63     /**
 64      * Shuts down the thread that is handling blocking I/O. Note that if the
 65      * thread is currently blocked waiting for I/O it will not actually
 66      * shut down until the I/O is received.
 67      */
 68     public synchronized void shutdown() {
 69         if (thread != null) {
 70             notify();
 71         }
 72     }
 73 
 74     @Override
 75     public void close() throws IOException {
 76         /*
 77          * The underlying input stream is closed first. This means that if the
 78          * I/O thread was blocked waiting on input, it will be woken for us.
 79          */
 80         in.close();
 81         shutdown();
 82     }
 83 
 84     /**
 85      * Attempts to read a byte from the input stream for a specific
 86      * period of time.
 87      * @param timeout The amount of time to wait for the character
 88      * @param isPeek &lt;code&gt;true&lt;/code&gt;if the byte read must not be consumed
 89      * @return The byte read, -1 if EOF is reached, or -2 if the
 90      *   read timed out.
 91      * @throws IOException if anything wrong happens
 92      */
 93     public synchronized int read(long timeout, boolean isPeek) throws IOException {
 94         /*
 95          * If the thread hit an IOException, we report it.
 96          */
 97         if (exception != null) {
 98             assert b == READ_EXPIRED;
 99             IOException toBeThrown = exception;
100             if (!isPeek)
101                 exception = null;
102             throw toBeThrown;
103         }
104 
105         /*
106          * If there was a pending character from the thread, then
107          * we send it. If the timeout is 0L or the thread was shut down
108          * then do a local read.
109          */
110         if (b &gt;= -1) {
111             assert exception == null;
112         }
113         else if (!isPeek &amp;&amp; timeout &lt;= 0L &amp;&amp; !threadIsReading) {
114             b = in.read();
115         }
116         else {
117             /*
118              * If the thread isn&#39;t reading already, then ask it to do so.
119              */
120             if (!threadIsReading) {
121                 threadIsReading = true;
122                 startReadingThreadIfNeeded();
123                 notifyAll();
124             }
125 
126             boolean isInfinite = (timeout &lt;= 0L);
127 
128             /*
129              * So the thread is currently doing the reading for us. So
130              * now we play the waiting game.
131              */
132             while (isInfinite || timeout &gt; 0L)  {
133                 long start = System.currentTimeMillis ();
134 
135                 try {
136                     if (Thread.interrupted()) {
137                         throw new InterruptedException();
138                     }
139                     wait(timeout);
140                 }
141                 catch (InterruptedException e) {
142                     exception = (IOException) new InterruptedIOException().initCause(e);
143                 }
144 
145                 if (exception != null) {
146                     assert b == READ_EXPIRED;
147 
148                     IOException toBeThrown = exception;
149                     if (!isPeek)
150                         exception = null;
151                     throw toBeThrown;
152                 }
153 
154                 if (b &gt;= -1) {
155                     assert exception == null;
156                     break;
157                 }
158 
159                 if (!isInfinite) {
160                     timeout -= System.currentTimeMillis() - start;
161                 }
162             }
163         }
164 
165         /*
166          * b is the character that was just read. Either we set it because
167          * a local read was performed or the read thread set it (or failed to
168          * change it).  We will return it&#39;s value, but if this was a peek
169          * operation, then we leave it in place.
170          */
171         int ret = b;
172         if (!isPeek) {
173             b = READ_EXPIRED;
174         }
175         return ret;
176     }
177 
178     private void run () {
179         Log.debug(&quot;NonBlockingInputStream start&quot;);
180         boolean needToRead;
181 
182         try {
183             while (true) {
184 
185                 /*
186                  * Synchronize to grab variables accessed by both this thread
187                  * and the accessing thread.
188                  */
189                 synchronized (this) {
190                     needToRead = this.threadIsReading;
191 
192                     try {
193                         /*
194                          * Nothing to do? Then wait.
195                          */
196                         if (!needToRead) {
197                             wait(threadDelay);
198                         }
199                     } catch (InterruptedException e) {
200                         /* IGNORED */
201                     }
202 
203                     needToRead = this.threadIsReading;
204                     if (!needToRead) {
205                         return;
206                     }
207                 }
208 
209                 /*
210                  * We&#39;re not shutting down, but we need to read. This cannot
211                  * happen while we are holding the lock (which we aren&#39;t now).
212                  */
213                 int byteRead = READ_EXPIRED;
214                 IOException failure = null;
215                 try {
216                     byteRead = in.read();
217                 } catch (IOException e) {
218                     failure = e;
219                 }
220 
221                 /*
222                  * Re-grab the lock to update the state.
223                  */
224                 synchronized (this) {
225                     exception = failure;
226                     b = byteRead;
227                     threadIsReading = false;
228                     notify();
229                 }
230 
231                 // If end of stream, exit the loop thread
232                 if (byteRead &lt; 0) {
233                     return;
234                 }
235             }
236         } catch (Throwable t) {
237             Log.warn(&quot;Error in NonBlockingInputStream thread&quot;, t);
238         } finally {
239             Log.debug(&quot;NonBlockingInputStream shutdown&quot;);
240             synchronized (this) {
241                 thread = null;
242                 threadIsReading = false;
243             }
244         }
245     }
246 
247 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/history/DefaultHistory.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2018, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.reader.impl.history;
 10 
 11 import java.io.*;
 12 import java.nio.file.*;
 13 import java.time.Instant;
 14 import java.util.*;
 15 
 16 import jdk.internal.org.jline.reader.History;
 17 import jdk.internal.org.jline.reader.LineReader;
 18 import jdk.internal.org.jline.utils.Log;
 19 
 20 import static jdk.internal.org.jline.reader.LineReader.HISTORY_IGNORE;
 21 import static jdk.internal.org.jline.reader.impl.ReaderUtils.*;
 22 
 23 /**
 24  * {@link History} using a file for persistent backing.
 25  * &lt;p&gt;
 26  * Implementers should install shutdown hook to call {@link DefaultHistory#save}
 27  * to save history to disk.
 28  * &lt;/p&gt;
 29  */
 30 public class DefaultHistory implements History {
 31 
 32     public static final int DEFAULT_HISTORY_SIZE = 500;
 33     public static final int DEFAULT_HISTORY_FILE_SIZE = 10000;
 34 
 35     private final LinkedList&lt;Entry&gt; items = new LinkedList&lt;&gt;();
 36 
 37     private LineReader reader;
 38 
 39     private int lastLoaded = 0;
 40     private int nbEntriesInFile = 0;
 41     private int offset = 0;
 42     private int index = 0;
 43 
 44     public DefaultHistory() {
 45     }
 46 
 47     public DefaultHistory(LineReader reader) {
 48         attach(reader);
 49     }
 50 
 51     private Path getPath() {
 52         Object obj = reader != null ? reader.getVariables().get(LineReader.HISTORY_FILE) : null;
 53         if (obj instanceof Path) {
 54             return (Path) obj;
 55         } else if (obj instanceof File) {
 56             return ((File) obj).toPath();
 57         } else if (obj != null) {
 58             return Paths.get(obj.toString());
 59         } else {
 60             return null;
 61         }
 62     }
 63 
 64     @Override
 65     public void attach(LineReader reader) {
 66         if (this.reader != reader) {
 67             this.reader = reader;
 68             try {
 69                 load();
 70             }
 71             catch (IOException e) {
 72                 Log.warn(&quot;Failed to load history&quot;, e);
 73             }
 74         }
 75     }
 76 
 77     @Override
 78     public void load() throws IOException {
 79         Path path = getPath();
 80         if (path != null) {
 81             try {
 82                 if (Files.exists(path)) {
 83                     Log.trace(&quot;Loading history from: &quot;, path);
 84                     try (BufferedReader reader = Files.newBufferedReader(path)) {
 85                         internalClear();
 86                         reader.lines().forEach(line -&gt; addHistoryLine(path, line));
 87                         lastLoaded = items.size();
 88                         nbEntriesInFile = lastLoaded;
 89                         maybeResize();
 90                     }
 91                 }
 92             } catch (IOException e) {
 93                 Log.debug(&quot;Failed to load history; clearing&quot;, e);
 94                 internalClear();
 95                 throw e;
 96             }
 97         }
 98     }
 99 
100     protected void addHistoryLine(Path path, String line) {
101         if (reader.isSet(LineReader.Option.HISTORY_TIMESTAMPED)) {
102             int idx = line.indexOf(&#39;:&#39;);
103             if (idx &lt; 0) {
104                 throw new IllegalArgumentException(&quot;Bad history file syntax! &quot; +
105                         &quot;The history file `&quot; + path + &quot;` may be an older history: &quot; +
106                         &quot;please remove it or use a different history file.&quot;);
107             }
108             Instant time = Instant.ofEpochMilli(Long.parseLong(line.substring(0, idx)));
109             String unescaped = unescape(line.substring(idx + 1));
110             internalAdd(time, unescaped);
111         }
112         else {
113             internalAdd(Instant.now(), unescape(line));
114         }
115     }
116 
117     @Override
118     public void purge() throws IOException {
119         internalClear();
120         Path path = getPath();
121         if (path != null) {
122             Log.trace(&quot;Purging history from: &quot;, path);
123             Files.deleteIfExists(path);
124         }
125     }
126 
127     @Override
128     public void save() throws IOException {
129         Path path = getPath();
130         if (path != null) {
131             Log.trace(&quot;Saving history to: &quot;, path);
132             Files.createDirectories(path.toAbsolutePath().getParent());
133             // Append new items to the history file
134             try (BufferedWriter writer = Files.newBufferedWriter(path.toAbsolutePath(),
135               StandardOpenOption.WRITE, StandardOpenOption.APPEND, StandardOpenOption.CREATE)) {
136                 for (Entry entry : items.subList(lastLoaded, items.size())) {
137                     if (isPersistable(entry)) {
138                         writer.append(format(entry));
139                     }
140                 }
141             }
142             nbEntriesInFile += items.size() - lastLoaded;
143             // If we are over 25% max size, trim history file
144             int max = getInt(reader, LineReader.HISTORY_FILE_SIZE, DEFAULT_HISTORY_FILE_SIZE);
145             if (nbEntriesInFile &gt; max + max / 4) {
146                 trimHistory(path, max);
147             }
148         }
149         lastLoaded = items.size();
150     }
151 
152     protected void trimHistory(Path path, int max) throws IOException {
153         Log.trace(&quot;Trimming history path: &quot;, path);
154         // Load all history entries
155         LinkedList&lt;Entry&gt; allItems = new LinkedList&lt;&gt;();
156         try (BufferedReader reader = Files.newBufferedReader(path)) {
157             reader.lines().forEach(l -&gt; {
158                 int idx = l.indexOf(&#39;:&#39;);
159                 Instant time = Instant.ofEpochMilli(Long.parseLong(l.substring(0, idx)));
160                 String line = unescape(l.substring(idx + 1));
161                 allItems.add(createEntry(allItems.size(), time, line));
162             });
163         }
164         // Remove duplicates
165         doTrimHistory(allItems, max);
166         // Write history
167         Path temp = Files.createTempFile(path.toAbsolutePath().getParent(), path.getFileName().toString(), &quot;.tmp&quot;);
168         try (BufferedWriter writer = Files.newBufferedWriter(temp, StandardOpenOption.WRITE)) {
169             for (Entry entry : allItems) {
170                 writer.append(format(entry));
171             }
172         }
173         Files.move(temp, path, StandardCopyOption.REPLACE_EXISTING);
174         // Keep items in memory
175         internalClear();
176         offset = allItems.get(0).index();
177         items.addAll(allItems);
178         lastLoaded = items.size();
179         nbEntriesInFile = items.size();
180         maybeResize();
181     }
182 
183     /**
184      * Create a history entry. Subclasses may override to use their own entry implementations.
185      * @param index index of history entry
186      * @param time entry creation time
187      * @param line the entry text
188      * @return entry object
189      */
190     protected EntryImpl createEntry(int index, Instant time, String line) {
191         return new EntryImpl(index, time, line);
192     }
193 
194     private void internalClear() {
195         offset = 0;
196         index = 0;
197         lastLoaded = 0;
198         nbEntriesInFile = 0;
199         items.clear();
200     }
201 
202     static void doTrimHistory(List&lt;Entry&gt; allItems, int max) {
203         int idx = 0;
204         while (idx &lt; allItems.size()) {
205             int ridx = allItems.size() - idx - 1;
206             String line = allItems.get(ridx).line().trim();
207             ListIterator&lt;Entry&gt; iterator = allItems.listIterator(ridx);
208             while (iterator.hasPrevious()) {
209                 String l = iterator.previous().line();
210                 if (line.equals(l.trim())) {
211                     iterator.remove();
212                 }
213             }
214             idx++;
215         }
216         while (allItems.size() &gt; max) {
217             allItems.remove(0);
218         }
219     }
220 
221     public int size() {
222         return items.size();
223     }
224 
225     public boolean isEmpty() {
226         return items.isEmpty();
227     }
228 
229     public int index() {
230         return offset + index;
231     }
232 
233     public int first() {
234         return offset;
235     }
236 
237     public int last() {
238         return offset + items.size() - 1;
239     }
240 
241     private String format(Entry entry) {
242         if (reader.isSet(LineReader.Option.HISTORY_TIMESTAMPED)) {
243             return Long.toString(entry.time().toEpochMilli()) + &quot;:&quot; + escape(entry.line()) + &quot;\n&quot;;
244         }
245         return escape(entry.line()) + &quot;\n&quot;;
246     }
247 
248     public String get(final int index) {
249         return items.get(index - offset).line();
250     }
251 
252     @Override
253     public void add(Instant time, String line) {
254         Objects.requireNonNull(time);
255         Objects.requireNonNull(line);
256 
257         if (getBoolean(reader, LineReader.DISABLE_HISTORY, false)) {
258             return;
259         }
260         if (isSet(reader, LineReader.Option.HISTORY_IGNORE_SPACE) &amp;&amp; line.startsWith(&quot; &quot;)) {
261             return;
262         }
263         if (isSet(reader, LineReader.Option.HISTORY_REDUCE_BLANKS)) {
264             line = line.trim();
265         }
266         if (isSet(reader, LineReader.Option.HISTORY_IGNORE_DUPS)) {
267             if (!items.isEmpty() &amp;&amp; line.equals(items.getLast().line())) {
268                 return;
269             }
270         }
271         if (matchPatterns(getString(reader, HISTORY_IGNORE, &quot;&quot;), line)) {
272             return;
273         }
274         internalAdd(time, line);
275         if (isSet(reader, LineReader.Option.HISTORY_INCREMENTAL)) {
276             try {
277                 save();
278             }
279             catch (IOException e) {
280                 Log.warn(&quot;Failed to save history&quot;, e);
281             }
282         }
283     }
284 
285     protected boolean matchPatterns(String patterns, String line) {
286         if (patterns == null || patterns.isEmpty()) {
287             return false;
288         }
289         StringBuilder sb = new StringBuilder();
290         for (int i = 0; i &lt; patterns.length(); i++) {
291             char ch = patterns.charAt(i);
292             if (ch == &#39;\\&#39;) {
293                 ch = patterns.charAt(++i);
294                 sb.append(ch);
295             } else if (ch == &#39;:&#39;) {
296                 sb.append(&#39;|&#39;);
297             } else if (ch == &#39;*&#39;) {
298                 sb.append(&#39;.&#39;).append(&#39;*&#39;);
299             }
300         }
301         return line.matches(sb.toString());
302     }
303 
304     protected void internalAdd(Instant time, String line) {
305         Entry entry = new EntryImpl(offset + items.size(), time, line);
306         items.add(entry);
307         maybeResize();
308     }
309 
310     private void maybeResize() {
311         while (size() &gt; getInt(reader, LineReader.HISTORY_SIZE, DEFAULT_HISTORY_SIZE)) {
312             items.removeFirst();
313             lastLoaded--;
314             offset++;
315         }
316         index = size();
317     }
318 
319     public ListIterator&lt;Entry&gt; iterator(int index) {
320         return items.listIterator(index - offset);
321     }
322 
323     @Override
324     public Spliterator&lt;Entry&gt; spliterator() {
325         return items.spliterator();
326     }
327 
328     protected static class EntryImpl implements Entry {
329 
330         private final int index;
331         private final Instant time;
332         private final String line;
333 
334         public EntryImpl(int index, Instant time, String line) {
335             this.index = index;
336             this.time = time;
337             this.line = line;
338         }
339 
340         public int index() {
341             return index;
342         }
343 
344         public Instant time() {
345             return time;
346         }
347 
348         public String line() {
349             return line;
350         }
351 
352         @Override
353         public String toString() {
354             return String.format(&quot;%d: %s&quot;, index, line);
355         }
356     }
357 
358     //
359     // Navigation
360     //
361 
362     /**
363      * This moves the history to the last entry. This entry is one position
364      * before the moveToEnd() position.
365      *
366      * @return Returns false if there were no history iterator or the history
367      * index was already at the last entry.
368      */
369     public boolean moveToLast() {
370         int lastEntry = size() - 1;
371         if (lastEntry &gt;= 0 &amp;&amp; lastEntry != index) {
372             index = size() - 1;
373             return true;
374         }
375 
376         return false;
377     }
378 
379     /**
380      * Move to the specified index in the history
381      */
382     public boolean moveTo(int index) {
383         index -= offset;
384         if (index &gt;= 0 &amp;&amp; index &lt; size()) {
385             this.index = index;
386             return true;
387         }
388         return false;
389     }
390 
391     /**
392      * Moves the history index to the first entry.
393      *
394      * @return Return false if there are no iterator in the history or if the
395      * history is already at the beginning.
396      */
397     public boolean moveToFirst() {
398         if (size() &gt; 0 &amp;&amp; index != 0) {
399             index = 0;
400             return true;
401         }
402         return false;
403     }
404 
405     /**
406      * Move to the end of the history buffer. This will be a blank entry, after
407      * all of the other iterator.
408      */
409     public void moveToEnd() {
410         index = size();
411     }
412 
413     /**
414      * Return the content of the current buffer.
415      */
416     public String current() {
417         if (index &gt;= size()) {
418             return &quot;&quot;;
419         }
420         return items.get(index).line();
421     }
422 
423     /**
424      * Move the pointer to the previous element in the buffer.
425      *
426      * @return true if we successfully went to the previous element
427      */
428     public boolean previous() {
429         if (index &lt;= 0) {
430             return false;
431         }
432         index--;
433         return true;
434     }
435 
436     /**
437      * Move the pointer to the next element in the buffer.
438      *
439      * @return true if we successfully went to the next element
440      */
441     public boolean next() {
442         if (index &gt;= size()) {
443             return false;
444         }
445         index++;
446         return true;
447     }
448 
449     @Override
450     public String toString() {
451         StringBuilder sb = new StringBuilder();
452         for (Entry e : this) {
453             sb.append(e.toString()).append(&quot;\n&quot;);
454         }
455         return sb.toString();
456     }
457 
458     private static String escape(String s) {
459         StringBuilder sb = new StringBuilder();
460         for (int i = 0; i &lt; s.length(); i++) {
461             char ch = s.charAt(i);
462             switch (ch) {
463                 case &#39;\n&#39;:
464                     sb.append(&#39;\\&#39;);
465                     sb.append(&#39;n&#39;);
466                     break;
467                 case &#39;\r&#39;:
468                     sb.append(&#39;\\&#39;);
469                     sb.append(&#39;r&#39;);
470                     break;
471                 case &#39;\\&#39;:
472                     sb.append(&#39;\\&#39;);
473                     sb.append(&#39;\\&#39;);
474                     break;
475                 default:
476                     sb.append(ch);
477                     break;
478             }
479         }
480         return sb.toString();
481     }
482 
483     static String unescape(String s) {
484         StringBuilder sb = new StringBuilder();
485         for (int i = 0; i &lt; s.length(); i++) {
486             char ch = s.charAt(i);
487             switch (ch) {
488                 case &#39;\\&#39;:
489                     ch = s.charAt(++i);
490                     if (ch == &#39;n&#39;) {
491                         sb.append(&#39;\n&#39;);
492                     } else if (ch == &#39;r&#39;) {
493                         sb.append(&#39;\r&#39;);
494                     } else {
495                         sb.append(ch);
496                     }
497                     break;
498                 default:
499                     sb.append(ch);
500                     break;
501             }
502         }
503         return sb.toString();
504     }
505 
506 }
507 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/BufferImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2017, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.reader.impl;
 10 
 11 import java.util.Objects;
 12 
 13 import jdk.internal.org.jline.reader.Buffer;
 14 
 15 /**
 16  * A holder for a {@link StringBuilder} that also contains the current cursor position.
 17  *
 18  * @author &lt;a href=&quot;mailto:mwp1@cornell.edu&quot;&gt;Marc Prud&#39;hommeaux&lt;/a&gt;
 19  * @author &lt;a href=&quot;mailto:jason@planet57.com&quot;&gt;Jason Dillon&lt;/a&gt;
 20  * @since 2.0
 21  */
 22 public class BufferImpl implements Buffer
 23 {
 24     private int cursor = 0;
 25     private int cursorCol = -1;
 26     private int[] buffer;
 27     private int g0;
 28     private int g1;
 29 
 30     public BufferImpl() {
 31         this(64);
 32     }
 33 
 34     public BufferImpl(int size) {
 35         buffer = new int[size];
 36         g0 = 0;
 37         g1 = buffer.length;
 38     }
 39 
 40     private BufferImpl(BufferImpl buffer) {
 41         this.cursor = buffer.cursor;
 42         this.cursorCol = buffer.cursorCol;
 43         this.buffer = buffer.buffer.clone();
 44         this.g0 = buffer.g0;
 45         this.g1 = buffer.g1;
 46     }
 47 
 48     public BufferImpl copy () {
 49         return new BufferImpl(this);
 50     }
 51 
 52     public int cursor() {
 53         return cursor;
 54     }
 55 
 56     public int length() {
 57         return buffer.length - (g1 - g0);
 58     }
 59 
 60     public boolean currChar(int ch) {
 61         if (cursor == length()) {
 62             return false;
 63         } else {
 64             buffer[adjust(cursor)] = ch;
 65             return true;
 66         }
 67     }
 68 
 69     public int currChar() {
 70         if (cursor == length()) {
 71             return 0;
 72         } else {
 73             return atChar(cursor);
 74         }
 75     }
 76 
 77     public int prevChar() {
 78         if (cursor &lt;= 0) {
 79             return 0;
 80         }
 81         return atChar(cursor - 1);
 82     }
 83 
 84     public int nextChar() {
 85         if (cursor &gt;= length() - 1) {
 86             return 0;
 87         }
 88         return atChar(cursor + 1);
 89     }
 90 
 91     public int atChar(int i) {
 92         if (i &lt; 0 || i &gt;= length()) {
 93             return 0;
 94         }
 95         return buffer[adjust(i)];
 96     }
 97 
 98     private int adjust(int i) {
 99         return (i &gt;= g0) ? i + g1 - g0 : i;
100     }
101 
102     /**
103      * Write the specific character into the buffer, setting the cursor position
104      * ahead one.
105      *
106      * @param c the character to insert
107      */
108     public void write(int c) {
109         write(new int[] { c });
110     }
111 
112     /**
113      * Write the specific character into the buffer, setting the cursor position
114      * ahead one. The text may overwrite or insert based on the current setting
115      * of {@code overTyping}.
116      *
117      * @param c the character to insert
118      */
119     public void write(int c, boolean overTyping) {
120         if (overTyping) {
121             delete(1);
122         }
123         write(new int[] { c });
124     }
125 
126     /**
127      * Insert the specified chars into the buffer, setting the cursor to the end of the insertion point.
128      */
129     public void write(CharSequence str) {
130         Objects.requireNonNull(str);
131         write(str.codePoints().toArray());
132     }
133 
134     public void write(CharSequence str, boolean overTyping) {
135         Objects.requireNonNull(str);
136         int[] ucps = str.codePoints().toArray();
137         if (overTyping) {
138             delete(ucps.length);
139         }
140         write(ucps);
141     }
142 
143     private void write(int[] ucps) {
144         moveGapToCursor();
145         int len = length() + ucps.length;
146         int sz = buffer.length;
147         if (sz &lt; len) {
148             while (sz &lt; len) {
149                 sz *= 2;
150             }
151             int[] nb = new int[sz];
152             System.arraycopy(buffer, 0, nb, 0, g0);
153             System.arraycopy(buffer, g1, nb, g1 + sz - buffer.length, buffer.length - g1);
154             g1 += sz - buffer.length;
155             buffer = nb;
156         }
157         System.arraycopy(ucps, 0, buffer, cursor, ucps.length);
158         g0 += ucps.length;
159         cursor += ucps.length;
160         cursorCol = -1;
161     }
162 
163     public boolean clear() {
164         if (length() == 0) {
165             return false;
166         }
167         g0 = 0;
168         g1 = buffer.length;
169         cursor = 0;
170         cursorCol = -1;
171         return true;
172     }
173 
174     public String substring(int start) {
175         return substring(start, length());
176     }
177 
178     public String substring(int start, int end) {
179         if (start &gt;= end || start &lt; 0 || end &gt; length()) {
180             return &quot;&quot;;
181         }
182         if (end &lt;= g0) {
183             return new String(buffer, start, end - start);
184         } else if (start &gt; g0) {
185             return new String(buffer, g1 - g0 + start, end - start);
186         } else {
187             int[] b = buffer.clone();
188             System.arraycopy(b, g1, b, g0, b.length - g1);
189             return new String(b, start, end - start);
190         }
191     }
192 
193     public String upToCursor() {
194         return substring(0, cursor);
195     }
196 
197     /**
198      * Move the cursor position to the specified absolute index.
199      */
200     public boolean cursor(int position) {
201         if (position == cursor) {
202             return true;
203         }
204         return move(position - cursor) != 0;
205     }
206 
207     /**
208      * Move the cursor &lt;i&gt;where&lt;/i&gt; characters.
209      *
210      * @param num   If less than 0, move abs(&lt;i&gt;where&lt;/i&gt;) to the left, otherwise move &lt;i&gt;where&lt;/i&gt; to the right.
211      * @return      The number of spaces we moved
212      */
213     public int move(final int num) {
214         int where = num;
215 
216         if ((cursor == 0) &amp;&amp; (where &lt;= 0)) {
217             return 0;
218         }
219 
220         if ((cursor == length()) &amp;&amp; (where &gt;= 0)) {
221             return 0;
222         }
223 
224         if ((cursor + where) &lt; 0) {
225             where = -cursor;
226         }
227         else if ((cursor + where) &gt; length()) {
228             where = length() - cursor;
229         }
230 
231         cursor += where;
232         cursorCol = -1;
233 
234         return where;
235     }
236 
237     public boolean up() {
238         int col = getCursorCol();
239         int pnl = cursor - 1;
240         while (pnl &gt;= 0 &amp;&amp; atChar(pnl) != &#39;\n&#39;) {
241             pnl--;
242         }
243         if (pnl &lt; 0) {
244             return false;
245         }
246         int ppnl = pnl - 1;
247         while (ppnl &gt;= 0 &amp;&amp; atChar(ppnl) != &#39;\n&#39;) {
248             ppnl--;
249         }
250         cursor = Math.min(ppnl + col + 1, pnl);
251         return true;
252     }
253 
254     public boolean down() {
255         int col = getCursorCol();
256         int nnl = cursor;
257         while (nnl &lt; length() &amp;&amp; atChar(nnl) != &#39;\n&#39;) {
258             nnl++;
259         }
260         if (nnl &gt;= length()) {
261             return false;
262         }
263         int nnnl = nnl + 1;
264         while (nnnl &lt; length() &amp;&amp; atChar(nnnl) != &#39;\n&#39;) {
265             nnnl++;
266         }
267         cursor = Math.min(nnl + col + 1, nnnl);
268         return true;
269     }
270 
271     public boolean moveXY(int dx, int dy) {
272         int col = 0;
273         while (prevChar() != &#39;\n&#39; &amp;&amp; move(-1) == -1) {
274             col++;
275         }
276         cursorCol = 0;
277         while (dy &lt; 0) {
278             up();
279             dy++;
280         }
281         while (dy &gt; 0) {
282             down();
283             dy--;
284         }
285         col = Math.max(col + dx, 0);
286         for (int i = 0; i &lt; col; i++) {
287             if (move(1) != 1 || currChar() == &#39;\n&#39;) {
288                 break;
289             }
290         }
291         cursorCol = col;
292         return true;
293     }
294 
295     private int getCursorCol() {
296         if (cursorCol &lt; 0) {
297             cursorCol = 0;
298             int pnl = cursor - 1;
299             while (pnl &gt;= 0 &amp;&amp; atChar(pnl) != &#39;\n&#39;) {
300                 pnl--;
301             }
302             cursorCol = cursor - pnl - 1;
303         }
304         return cursorCol;
305     }
306 
307     /**
308      * Issue &lt;em&gt;num&lt;/em&gt; backspaces.
309      *
310      * @return the number of characters backed up
311      */
312     public int backspace(final int num) {
313         int count = Math.max(Math.min(cursor, num), 0);
314         moveGapToCursor();
315         cursor -= count;
316         g0 -= count;
317         cursorCol = -1;
318         return count;
319     }
320 
321     /**
322      * Issue a backspace.
323      *
324      * @return true if successful
325      */
326     public boolean backspace() {
327         return backspace(1) == 1;
328     }
329 
330     public int delete(int num) {
331         int count = Math.max(Math.min(length() - cursor, num), 0);
332         moveGapToCursor();
333         g1 += count;
334         cursorCol = -1;
335         return count;
336     }
337 
338     public boolean delete() {
339         return delete(1) == 1;
340     }
341 
342     @Override
343     public String toString() {
344         return substring(0, length());
345     }
346 
347     public void copyFrom(Buffer buf) {
348         if (!(buf instanceof BufferImpl)) {
349             throw new IllegalStateException();
350         }
351         BufferImpl that = (BufferImpl) buf;
352         this.g0 = that.g0;
353         this.g1 = that.g1;
354         this.buffer = that.buffer.clone();
355         this.cursor = that.cursor;
356         this.cursorCol = that.cursorCol;
357     }
358 
359     private void moveGapToCursor() {
360         if (cursor &lt; g0) {
361             int l = g0 - cursor;
362             System.arraycopy(buffer, cursor, buffer, g1 - l, l);
363             g0 -= l;
364             g1 -= l;
365         } else if (cursor &gt; g0) {
366             int l = cursor - g0;
367             System.arraycopy(buffer, g1, buffer, g0, l);
368             g0 += l;
369             g1 += l;
370         }
371     }
372 }
    </pre>
  </body>
</html>
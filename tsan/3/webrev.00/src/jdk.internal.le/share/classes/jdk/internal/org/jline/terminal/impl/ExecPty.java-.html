<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/terminal/impl/ExecPty.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.terminal.impl;
 10 
 11 import java.io.FileInputStream;
 12 import java.io.FileOutputStream;
 13 import java.io.IOException;
 14 import java.io.InputStream;
 15 import java.io.FileDescriptor;
 16 import java.io.OutputStream;
 17 import java.util.ArrayList;
 18 import java.util.List;
 19 import java.util.regex.Matcher;
 20 import java.util.regex.Pattern;
 21 
 22 import jdk.internal.org.jline.terminal.Attributes;
 23 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
 24 import jdk.internal.org.jline.terminal.Attributes.ControlFlag;
 25 import jdk.internal.org.jline.terminal.Attributes.InputFlag;
 26 import jdk.internal.org.jline.terminal.Attributes.LocalFlag;
 27 import jdk.internal.org.jline.terminal.Attributes.OutputFlag;
 28 import jdk.internal.org.jline.terminal.Size;
 29 import jdk.internal.org.jline.terminal.spi.Pty;
 30 import jdk.internal.org.jline.utils.OSUtils;
 31 
 32 import static jdk.internal.org.jline.utils.ExecHelper.exec;
 33 
 34 public class ExecPty extends AbstractPty implements Pty {
 35 
 36     private final String name;
 37     private final boolean system;
 38 
 39     public static Pty current() throws IOException {
 40         try {
 41             String result = exec(true, OSUtils.TTY_COMMAND);
 42             return new ExecPty(result.trim(), true);
 43         } catch (IOException e) {
 44             throw new IOException(&quot;Not a tty&quot;, e);
 45         }
 46     }
 47 
 48     protected ExecPty(String name, boolean system) {
 49         this.name = name;
 50         this.system = system;
 51     }
 52 
 53     @Override
 54     public void close() throws IOException {
 55     }
 56 
 57     public String getName() {
 58         return name;
 59     }
 60 
 61     @Override
 62     public InputStream getMasterInput() {
 63         throw new UnsupportedOperationException();
 64     }
 65 
 66     @Override
 67     public OutputStream getMasterOutput() {
 68         throw new UnsupportedOperationException();
 69     }
 70 
 71     @Override
 72     protected InputStream doGetSlaveInput() throws IOException {
 73         return system
 74                 ? new FileInputStream(FileDescriptor.in)
 75                 : new FileInputStream(getName());
 76     }
 77 
 78     @Override
 79     public OutputStream getSlaveOutput() throws IOException {
 80         return system
 81                 ? new FileOutputStream(FileDescriptor.out)
 82                 : new FileOutputStream(getName());
 83     }
 84 
 85     @Override
 86     public Attributes getAttr() throws IOException {
 87         String cfg = doGetConfig();
 88         return doGetAttr(cfg);
 89     }
 90 
 91     @Override
 92     protected void doSetAttr(Attributes attr) throws IOException {
 93         List&lt;String&gt; commands = getFlagsToSet(attr, getAttr());
 94         if (!commands.isEmpty()) {
 95             commands.add(0, OSUtils.STTY_COMMAND);
 96             if (!system) {
 97                 commands.add(1, OSUtils.STTY_F_OPTION);
 98                 commands.add(2, getName());
 99             }
100             try {
101                 exec(system, commands.toArray(new String[commands.size()]));
102             } catch (IOException e) {
103                 // Handle partial failures with GNU stty, see #97
104                 if (e.toString().contains(&quot;unable to perform all requested operations&quot;)) {
105                     commands = getFlagsToSet(attr, getAttr());
106                     if (!commands.isEmpty()) {
107                         throw new IOException(&quot;Could not set the following flags: &quot; + String.join(&quot;, &quot;, commands), e);
108                     }
109                 } else {
110                     throw e;
111                 }
112             }
113         }
114     }
115 
116     protected List&lt;String&gt; getFlagsToSet(Attributes attr, Attributes current) {
117         List&lt;String&gt; commands = new ArrayList&lt;&gt;();
118         for (InputFlag flag : InputFlag.values()) {
119             if (attr.getInputFlag(flag) != current.getInputFlag(flag)) {
120                 commands.add((attr.getInputFlag(flag) ? flag.name() : &quot;-&quot; + flag.name()).toLowerCase());
121             }
122         }
123         for (OutputFlag flag : OutputFlag.values()) {
124             if (attr.getOutputFlag(flag) != current.getOutputFlag(flag)) {
125                 commands.add((attr.getOutputFlag(flag) ? flag.name() : &quot;-&quot; + flag.name()).toLowerCase());
126             }
127         }
128         for (ControlFlag flag : ControlFlag.values()) {
129             if (attr.getControlFlag(flag) != current.getControlFlag(flag)) {
130                 commands.add((attr.getControlFlag(flag) ? flag.name() : &quot;-&quot; + flag.name()).toLowerCase());
131             }
132         }
133         for (LocalFlag flag : LocalFlag.values()) {
134             if (attr.getLocalFlag(flag) != current.getLocalFlag(flag)) {
135                 commands.add((attr.getLocalFlag(flag) ? flag.name() : &quot;-&quot; + flag.name()).toLowerCase());
136             }
137         }
138         String undef = System.getProperty(&quot;os.name&quot;).toLowerCase().startsWith(&quot;hp&quot;) ? &quot;^-&quot; : &quot;undef&quot;;
139         for (ControlChar cchar : ControlChar.values()) {
140             if (attr.getControlChar(cchar) != current.getControlChar(cchar)) {
141                 String str = &quot;&quot;;
142                 int v = attr.getControlChar(cchar);
143                 commands.add(cchar.name().toLowerCase().substring(1));
144                 if (cchar == ControlChar.VMIN || cchar == ControlChar.VTIME) {
145                     commands.add(Integer.toBinaryString(v));
146                 }
147                 else if (v == 0) {
148                     commands.add(undef);
149                 }
150                 else {
151                     if (v &gt;= 128) {
152                         v -= 128;
153                         str += &quot;M-&quot;;
154                     }
155                     if (v &lt; 32 || v == 127) {
156                         v ^= 0x40;
157                         str += &quot;^&quot;;
158                     }
159                     str += (char) v;
160                     commands.add(str);
161                 }
162             }
163         }
164         return commands;
165     }
166 
167     @Override
168     public Size getSize() throws IOException {
169         String cfg = doGetConfig();
170         return doGetSize(cfg);
171     }
172 
173     protected String doGetConfig() throws IOException {
174         return system
175                 ? exec(true,  OSUtils.STTY_COMMAND, &quot;-a&quot;)
176                 : exec(false, OSUtils.STTY_COMMAND, OSUtils.STTY_F_OPTION, getName(), &quot;-a&quot;);
177     }
178 
179     static Attributes doGetAttr(String cfg) throws IOException {
180         Attributes attributes = new Attributes();
181         for (InputFlag flag : InputFlag.values()) {
182             Boolean value = doGetFlag(cfg, flag);
183             if (value != null) {
184                 attributes.setInputFlag(flag, value);
185             }
186         }
187         for (OutputFlag flag : OutputFlag.values()) {
188             Boolean value = doGetFlag(cfg, flag);
189             if (value != null) {
190                 attributes.setOutputFlag(flag, value);
191             }
192         }
193         for (ControlFlag flag : ControlFlag.values()) {
194             Boolean value = doGetFlag(cfg, flag);
195             if (value != null) {
196                 attributes.setControlFlag(flag, value);
197             }
198         }
199         for (LocalFlag flag : LocalFlag.values()) {
200             Boolean value = doGetFlag(cfg, flag);
201             if (value != null) {
202                 attributes.setLocalFlag(flag, value);
203             }
204         }
205         for (ControlChar cchar : ControlChar.values()) {
206             String name = cchar.name().toLowerCase().substring(1);
207             if (&quot;reprint&quot;.endsWith(name)) {
208                 name = &quot;(?:reprint|rprnt)&quot;;
209             }
210             Matcher matcher = Pattern.compile(&quot;[\\s;]&quot; + name + &quot;\\s*=\\s*(.+?)[\\s;]&quot;).matcher(cfg);
211             if (matcher.find()) {
212                 attributes.setControlChar(cchar, parseControlChar(matcher.group(1).toUpperCase()));
213             }
214         }
215         return attributes;
216     }
217 
218     private static Boolean doGetFlag(String cfg, Enum&lt;?&gt; flag) {
219         Matcher matcher = Pattern.compile(&quot;(?:^|[\\s;])(\\-?&quot; + flag.name().toLowerCase() + &quot;)(?:[\\s;]|$)&quot;).matcher(cfg);
220         return matcher.find() ? !matcher.group(1).startsWith(&quot;-&quot;) : null;
221     }
222 
223     static int parseControlChar(String str) {
224         // undef
225         if (&quot;&lt;UNDEF&gt;&quot;.equals(str)) {
226             return -1;
227         }
228         // del
229         if (&quot;DEL&quot;.equalsIgnoreCase(str)) {
230             return 127;
231         }
232         // octal
233         if (str.charAt(0) == &#39;0&#39;) {
234             return Integer.parseInt(str, 8);
235         }
236         // decimal
237         if (str.charAt(0) &gt;= &#39;1&#39; &amp;&amp; str.charAt(0) &lt;= &#39;9&#39;) {
238             return Integer.parseInt(str, 10);
239         }
240         // control char
241         if (str.charAt(0) == &#39;^&#39;) {
242             if (str.charAt(1) == &#39;?&#39;) {
243                 return 127;
244             } else {
245                 return str.charAt(1) - 64;
246             }
247         } else if (str.charAt(0) == &#39;M&#39; &amp;&amp; str.charAt(1) == &#39;-&#39;) {
248             if (str.charAt(2) == &#39;^&#39;) {
249                 if (str.charAt(3) == &#39;?&#39;) {
250                     return 127 + 128;
251                 } else {
252                     return str.charAt(3) - 64 + 128;
253                 }
254             } else {
255                 return str.charAt(2) + 128;
256             }
257         } else {
258             return str.charAt(0);
259         }
260     }
261 
262     static Size doGetSize(String cfg) throws IOException {
263         return new Size(doGetInt(&quot;columns&quot;, cfg), doGetInt(&quot;rows&quot;, cfg));
264     }
265 
266     static int doGetInt(String name, String cfg) throws IOException {
267         String[] patterns = new String[] {
268                 &quot;\\b([0-9]+)\\s+&quot; + name + &quot;\\b&quot;,
269                 &quot;\\b&quot; + name + &quot;\\s+([0-9]+)\\b&quot;,
270                 &quot;\\b&quot; + name + &quot;\\s*=\\s*([0-9]+)\\b&quot;
271         };
272         for (String pattern : patterns) {
273             Matcher matcher = Pattern.compile(pattern).matcher(cfg);
274             if (matcher.find()) {
275                 return Integer.parseInt(matcher.group(1));
276             }
277         }
278         throw new IOException(&quot;Unable to parse &quot; + name);
279     }
280 
281     @Override
282     public void setSize(Size size) throws IOException {
283         if (system) {
284             exec(true,
285                  OSUtils.STTY_COMMAND,
286                  &quot;columns&quot;, Integer.toString(size.getColumns()),
287                  &quot;rows&quot;, Integer.toString(size.getRows()));
288         } else {
289             exec(false,
290                  OSUtils.STTY_COMMAND,
291                  OSUtils.STTY_F_OPTION, getName(),
292                  &quot;columns&quot;, Integer.toString(size.getColumns()),
293                  &quot;rows&quot;, Integer.toString(size.getRows()));
294         }
295     }
296 
297     @Override
298     public String toString() {
299         return &quot;ExecPty[&quot; + getName() + (system ? &quot;, system]&quot; : &quot;]&quot;);
300     }
301 
302 }
    </pre>
  </body>
</html>
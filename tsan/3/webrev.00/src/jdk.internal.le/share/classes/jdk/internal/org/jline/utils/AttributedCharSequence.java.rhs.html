<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/AttributedCharSequence.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002-2019, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="2" id="anc2"></a><span class="line-modified">  7  * https://opensource.org/licenses/BSD-3-Clause</span>
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.ArrayList;
 12 import java.util.List;
 13 
 14 import jdk.internal.org.jline.terminal.Terminal;
 15 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
 16 import jdk.internal.org.jline.utils.InfoCmp.Capability;
 17 
 18 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR;
 19 import static jdk.internal.org.jline.utils.AttributedStyle.BG_COLOR_EXP;
 20 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR;
 21 import static jdk.internal.org.jline.utils.AttributedStyle.FG_COLOR_EXP;
 22 import static jdk.internal.org.jline.utils.AttributedStyle.F_BACKGROUND;
 23 import static jdk.internal.org.jline.utils.AttributedStyle.F_BLINK;
 24 import static jdk.internal.org.jline.utils.AttributedStyle.F_BOLD;
 25 import static jdk.internal.org.jline.utils.AttributedStyle.F_CONCEAL;
 26 import static jdk.internal.org.jline.utils.AttributedStyle.F_CROSSED_OUT;
 27 import static jdk.internal.org.jline.utils.AttributedStyle.F_FAINT;
 28 import static jdk.internal.org.jline.utils.AttributedStyle.F_FOREGROUND;
 29 import static jdk.internal.org.jline.utils.AttributedStyle.F_INVERSE;
 30 import static jdk.internal.org.jline.utils.AttributedStyle.F_ITALIC;
 31 import static jdk.internal.org.jline.utils.AttributedStyle.F_UNDERLINE;
 32 import static jdk.internal.org.jline.utils.AttributedStyle.F_HIDDEN;
 33 import static jdk.internal.org.jline.utils.AttributedStyle.MASK;
 34 import static jdk.internal.org.jline.terminal.TerminalBuilder.PROP_DISABLE_ALTERNATE_CHARSET;
 35 
 36 public abstract class AttributedCharSequence implements CharSequence {
 37 
 38     // cache the value here as we can&#39;t afford to get it each time
 39     static final boolean DISABLE_ALTERNATE_CHARSET = Boolean.getBoolean(PROP_DISABLE_ALTERNATE_CHARSET);
 40 
<a name="3" id="anc3"></a><span class="line-added"> 41     public void print(Terminal terminal) {</span>
<span class="line-added"> 42         terminal.writer().print(toAnsi(terminal));</span>
<span class="line-added"> 43     }</span>
<span class="line-added"> 44 </span>
<span class="line-added"> 45     public void println(Terminal terminal) {</span>
<span class="line-added"> 46         terminal.writer().println(toAnsi(terminal));</span>
<span class="line-added"> 47     }</span>
<span class="line-added"> 48 </span>
 49     public String toAnsi() {
 50         return toAnsi(null);
 51     }
 52 
 53     public String toAnsi(Terminal terminal) {
 54         if (terminal != null &amp;&amp; Terminal.TYPE_DUMB.equals(terminal.getType())) {
 55             return toString();
 56         }
 57         int colors = 256;
 58         boolean force256colors = false;
 59         String alternateIn = null, alternateOut = null;
 60         if (terminal != null) {
 61             Integer max_colors = terminal.getNumericCapability(Capability.max_colors);
 62             if (max_colors != null) {
 63                 colors = max_colors;
 64             }
<a name="4" id="anc4"></a><span class="line-modified"> 65             force256colors = AbstractWindowsTerminal.TYPE_WINDOWS_256_COLOR.equals(terminal.getType())</span>
<span class="line-added"> 66                 || AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType());</span>
 67             if (!DISABLE_ALTERNATE_CHARSET) {
 68                 alternateIn = Curses.tputs(terminal.getStringCapability(Capability.enter_alt_charset_mode));
 69                 alternateOut = Curses.tputs(terminal.getStringCapability(Capability.exit_alt_charset_mode));
 70             }
 71         }
 72         return toAnsi(colors, force256colors, alternateIn, alternateOut);
 73     }
 74 
 75     public String toAnsi(int colors, boolean force256colors) {
 76         return toAnsi(colors, force256colors, null, null);
 77     }
 78 
 79     public String toAnsi(int colors, boolean force256colors, String altIn, String altOut) {
 80         StringBuilder sb = new StringBuilder();
 81         int style = 0;
 82         int foreground = -1;
 83         int background = -1;
 84         boolean alt = false;
 85         for (int i = 0; i &lt; length(); i++) {
 86             char c = charAt(i);
 87             if (altIn != null &amp;&amp; altOut != null) {
 88                 char pc = c;
 89                 switch (c) {
 90                     case &#39;\u2518&#39;: c = &#39;j&#39;; break;
 91                     case &#39;\u2510&#39;: c = &#39;k&#39;; break;
 92                     case &#39;\u250C&#39;: c = &#39;l&#39;; break;
 93                     case &#39;\u2514&#39;: c = &#39;m&#39;; break;
 94                     case &#39;\u253C&#39;: c = &#39;n&#39;; break;
 95                     case &#39;\u2500&#39;: c = &#39;q&#39;; break;
 96                     case &#39;\u251C&#39;: c = &#39;t&#39;; break;
 97                     case &#39;\u2524&#39;: c = &#39;u&#39;; break;
 98                     case &#39;\u2534&#39;: c = &#39;v&#39;; break;
 99                     case &#39;\u252C&#39;: c = &#39;w&#39;; break;
100                     case &#39;\u2502&#39;: c = &#39;x&#39;; break;
101                 }
102                 boolean oldalt = alt;
103                 alt = c != pc;
104                 if (oldalt ^ alt) {
105                     sb.append(alt ? altIn : altOut);
106                 }
107             }
108             int  s = styleCodeAt(i) &amp; ~F_HIDDEN; // The hidden flag does not change the ansi styles
109             if (style != s) {
110                 int  d = (style ^ s) &amp; MASK;
111                 int fg = (s &amp; F_FOREGROUND) != 0 ? (s &amp; FG_COLOR) &gt;&gt;&gt; FG_COLOR_EXP : -1;
112                 int bg = (s &amp; F_BACKGROUND) != 0 ? (s &amp; BG_COLOR) &gt;&gt;&gt; BG_COLOR_EXP : -1;
113                 if (s == 0) {
114                     sb.append(&quot;\033[0m&quot;);
115                     foreground = background = -1;
116                 } else {
117                     sb.append(&quot;\033[&quot;);
118                     boolean first = true;
119                     if ((d &amp; F_ITALIC) != 0) {
120                         first = attr(sb, (s &amp; F_ITALIC) != 0 ? &quot;3&quot; : &quot;23&quot;, first);
121                     }
122                     if ((d &amp; F_UNDERLINE) != 0) {
123                         first = attr(sb, (s &amp; F_UNDERLINE) != 0 ? &quot;4&quot; : &quot;24&quot;, first);
124                     }
125                     if ((d &amp; F_BLINK) != 0) {
126                         first = attr(sb, (s &amp; F_BLINK) != 0 ? &quot;5&quot; : &quot;25&quot;, first);
127                     }
128                     if ((d &amp; F_INVERSE) != 0) {
129                         first = attr(sb, (s &amp; F_INVERSE) != 0 ? &quot;7&quot; : &quot;27&quot;, first);
130                     }
131                     if ((d &amp; F_CONCEAL) != 0) {
132                         first = attr(sb, (s &amp; F_CONCEAL) != 0 ? &quot;8&quot; : &quot;28&quot;, first);
133                     }
134                     if ((d &amp; F_CROSSED_OUT) != 0) {
135                         first = attr(sb, (s &amp; F_CROSSED_OUT) != 0 ? &quot;9&quot; : &quot;29&quot;, first);
136                     }
137                     if (foreground != fg) {
138                         if (fg &gt;= 0) {
139                             int rounded = Colors.roundColor(fg, colors);
140                             if (rounded &lt; 8 &amp;&amp; !force256colors) {
141                                 first = attr(sb, &quot;3&quot; + Integer.toString(rounded), first);
142                                 // small hack to force setting bold again after a foreground color change
143                                 d |= (s &amp; F_BOLD);
144                             } else if (rounded &lt; 16 &amp;&amp; !force256colors) {
145                                 first = attr(sb, &quot;9&quot; + Integer.toString(rounded - 8), first);
146                                 // small hack to force setting bold again after a foreground color change
147                                 d |= (s &amp; F_BOLD);
148                             } else {
149                                 first = attr(sb, &quot;38;5;&quot; + Integer.toString(rounded), first);
150                             }
151                         } else {
152                             first = attr(sb, &quot;39&quot;, first);
153                         }
154                         foreground = fg;
155                     }
156                     if (background != bg) {
157                         if (bg &gt;= 0) {
158                             int rounded = Colors.roundColor(bg, colors);
159                             if (rounded &lt; 8 &amp;&amp; !force256colors) {
160                                 first = attr(sb, &quot;4&quot; + Integer.toString(rounded), first);
161                             } else if (rounded &lt; 16 &amp;&amp; !force256colors) {
162                                 first = attr(sb, &quot;10&quot; + Integer.toString(rounded - 8), first);
163                             } else {
164                                 first = attr(sb, &quot;48;5;&quot; + Integer.toString(rounded), first);
165                             }
166                         } else {
167                             first = attr(sb, &quot;49&quot;, first);
168                         }
169                         background = bg;
170                     }
171                     if ((d &amp; (F_BOLD | F_FAINT)) != 0) {
172                         if (    (d &amp; F_BOLD)  != 0 &amp;&amp; (s &amp; F_BOLD)  == 0
173                                 || (d &amp; F_FAINT) != 0 &amp;&amp; (s &amp; F_FAINT) == 0) {
174                             first = attr(sb, &quot;22&quot;, first);
175                         }
176                         if ((d &amp; F_BOLD) != 0 &amp;&amp; (s &amp; F_BOLD) != 0) {
177                             first = attr(sb, &quot;1&quot;, first);
178                         }
179                         if ((d &amp; F_FAINT) != 0 &amp;&amp; (s &amp; F_FAINT) != 0) {
180                             first = attr(sb, &quot;2&quot;, first);
181                         }
182                     }
183                     sb.append(&quot;m&quot;);
184                 }
185                 style = s;
186             }
187             sb.append(c);
188         }
189         if (alt) {
190             sb.append(altOut);
191         }
192         if (style != 0) {
193             sb.append(&quot;\033[0m&quot;);
194         }
195         return sb.toString();
196     }
197 
198     @Deprecated
199     public static int rgbColor(int col) {
200         return Colors.rgbColor(col);
201     }
202 
203     @Deprecated
204     public static int roundColor(int col, int max) {
205         return Colors.roundColor(col, max);
206     }
207 
208     @Deprecated
209     public static int roundRgbColor(int r, int g, int b, int max) {
210         return Colors.roundRgbColor(r, g, b, max);
211     }
212 
213     private static boolean attr(StringBuilder sb, String s, boolean first) {
214         if (!first) {
215             sb.append(&quot;;&quot;);
216         }
217         sb.append(s);
218         return false;
219     }
220 
221     public abstract AttributedStyle styleAt(int index);
222 
223     int styleCodeAt(int index) {
224         return styleAt(index).getStyle();
225     }
226 
227     public boolean isHidden(int index) {
228         return (styleCodeAt(index) &amp; F_HIDDEN) != 0;
229     }
230 
231     public int runStart(int index) {
232         AttributedStyle style = styleAt(index);
233         while (index &gt; 0 &amp;&amp; styleAt(index - 1).equals(style)) {
234             index--;
235         }
236         return index;
237     }
238 
239     public int runLimit(int index) {
240         AttributedStyle style = styleAt(index);
241         while (index &lt; length() - 1 &amp;&amp; styleAt(index + 1).equals(style)) {
242             index++;
243         }
244         return index + 1;
245     }
246 
247     @Override
248     public abstract AttributedString subSequence(int start, int end);
249 
250     public AttributedString substring(int start, int end) {
251         return subSequence(start, end);
252     }
253 
254     protected abstract char[] buffer();
255 
256     protected abstract int offset();
257 
258     @Override
259     public char charAt(int index) {
260         return buffer()[offset() + index];
261     }
262 
263     public int codePointAt(int index) {
264         return Character.codePointAt(buffer(), index + offset());
265     }
266 
267     public boolean contains(char c) {
268         for (int i = 0; i &lt; length(); i++) {
269             if (charAt(i) == c) {
270                 return true;
271             }
272         }
273         return false;
274     }
275 
276     public int codePointBefore(int index) {
277         return Character.codePointBefore(buffer(), index + offset());
278     }
279 
280     public int codePointCount(int index, int length) {
281         return Character.codePointCount(buffer(), index + offset(), length);
282     }
283 
284     public int columnLength() {
285         int cols = 0;
286         int len = length();
287         for (int cur = 0; cur &lt; len; ) {
288             int cp = codePointAt(cur);
289             if (!isHidden(cur))
290                 cols += WCWidth.wcwidth(cp);
291             cur += Character.charCount(cp);
292         }
293         return cols;
294     }
295 
296     public AttributedString columnSubSequence(int start, int stop) {
297         int begin = 0;
298         int col = 0;
299         while (begin &lt; this.length()) {
300             int cp = codePointAt(begin);
301             int w = isHidden(begin) ? 0 : WCWidth.wcwidth(cp);
302             if (col + w &gt; start) {
303                 break;
304             }
<a name="5" id="anc5"></a><span class="line-modified">305             begin += Character.charCount(cp);</span>
306             col += w;
307         }
308         int end = begin;
309         while (end &lt; this.length()) {
310             int cp = codePointAt(end);
311             if (cp == &#39;\n&#39;)
312                 break;
313             int w = isHidden(end) ? 0 : WCWidth.wcwidth(cp);
314             if (col + w &gt; stop) {
315                 break;
316             }
<a name="6" id="anc6"></a><span class="line-modified">317             end += Character.charCount(cp);</span>
318             col += w;
319         }
320         return subSequence(begin, end);
321     }
322 
323     public List&lt;AttributedString&gt; columnSplitLength(int columns) {
324         return columnSplitLength(columns, false, true);
325     }
326 
327     public List&lt;AttributedString&gt; columnSplitLength(int columns, boolean includeNewlines, boolean delayLineWrap) {
328         List&lt;AttributedString&gt; strings = new ArrayList&lt;&gt;();
329         int cur = 0;
330         int beg = cur;
331         int col = 0;
332         while (cur &lt; length()) {
333             int cp = codePointAt(cur);
334             int w = isHidden(cur) ? 0 : WCWidth.wcwidth(cp);
335             if (cp == &#39;\n&#39;) {
336                 strings.add(subSequence(beg, includeNewlines ? cur+1 : cur));
337                 beg = cur + 1;
338                 col = 0;
339             } else if ((col += w) &gt; columns) {
340                 strings.add(subSequence(beg, cur));
341                 beg = cur;
342                 col = w;
343             }
344             cur += Character.charCount(cp);
345         }
346         strings.add(subSequence(beg, cur));
347         return strings;
348     }
349 
350     @Override
351     public String toString() {
352         return new String(buffer(), offset(), length());
353     }
354 
355     public AttributedString toAttributedString() {
356         return substring(0, length());
357     }
358 
359 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
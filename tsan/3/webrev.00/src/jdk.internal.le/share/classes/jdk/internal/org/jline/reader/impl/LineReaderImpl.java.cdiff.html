<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="KillRing.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ReaderUtils.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,12 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002-2018, the original author or authors.</span>
   *
   * This software is distributable under the BSD license. See the terms of the
   * BSD license in the documentation provided with this software.
   *
<span class="line-modified">!  * http://www.opensource.org/licenses/bsd-license.php</span>
   */
  package jdk.internal.org.jline.reader.impl;
  
  import java.io.Flushable;
  import java.io.IOError;
<span class="line-new-header">--- 1,12 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2002-2019, the original author or authors.</span>
   *
   * This software is distributable under the BSD license. See the terms of the
   * BSD license in the documentation provided with this software.
   *
<span class="line-modified">!  * https://opensource.org/licenses/BSD-3-Clause</span>
   */
  package jdk.internal.org.jline.reader.impl;
  
  import java.io.Flushable;
  import java.io.IOError;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 15,14 ***</span>
<span class="line-new-header">--- 15,17 ---</span>
  import java.io.InterruptedIOException;
  import java.time.Instant;
  import java.util.*;
  import java.util.Map.Entry;
  import java.util.concurrent.atomic.AtomicBoolean;
<span class="line-added">+ import java.util.concurrent.locks.Lock;</span>
<span class="line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  import java.util.function.*;
  import java.util.regex.Matcher;
  import java.util.regex.Pattern;
  import java.util.stream.Collectors;
<span class="line-added">+ import java.util.stream.Stream;</span>
  import java.util.stream.StreamSupport;
  
  import jdk.internal.org.jline.keymap.BindingReader;
  import jdk.internal.org.jline.keymap.KeyMap;
  import jdk.internal.org.jline.reader.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 33,11 ---</span>
  import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  import jdk.internal.org.jline.terminal.*;
  import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  import jdk.internal.org.jline.terminal.Terminal.Signal;
  import jdk.internal.org.jline.terminal.Terminal.SignalHandler;
<span class="line-added">+ import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;</span>
  import jdk.internal.org.jline.utils.AttributedString;
  import jdk.internal.org.jline.utils.AttributedStringBuilder;
  import jdk.internal.org.jline.utils.AttributedStyle;
  import jdk.internal.org.jline.utils.Curses;
  import jdk.internal.org.jline.utils.Display;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,12 ***</span>
  
      protected final Buffer buf = new BufferImpl();
  
      protected final Size size = new Size();
  
<span class="line-modified">!     protected AttributedString prompt;</span>
<span class="line-modified">!     protected AttributedString rightPrompt;</span>
  
      protected MaskingCallback maskingCallback;
  
      protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
      protected Buffer historyBuffer = null;
<span class="line-new-header">--- 161,12 ---</span>
  
      protected final Buffer buf = new BufferImpl();
  
      protected final Size size = new Size();
  
<span class="line-modified">!     protected AttributedString prompt = AttributedString.EMPTY;</span>
<span class="line-modified">!     protected AttributedString rightPrompt = AttributedString.EMPTY;</span>
  
      protected MaskingCallback maskingCallback;
  
      protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
      protected Buffer historyBuffer = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,10 ***</span>
<span class="line-new-header">--- 212,14 ---</span>
      protected KillRing killRing = new KillRing();
  
      protected UndoTree&lt;Buffer&gt; undo = new UndoTree&lt;&gt;(this::setBuffer);
      protected boolean isUndo;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * State lock</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected final ReentrantLock lock = new ReentrantLock();</span>
      /*
       * Current internal state of the line reader
       */
      protected State   state = State.DONE;
      protected final AtomicBoolean startedReading = new AtomicBoolean();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,10 ***</span>
<span class="line-new-header">--- 245,15 ---</span>
  
      protected String keyMap;
  
      protected int smallTerminalOffset = 0;
  
<span class="line-added">+     /*</span>
<span class="line-added">+      * accept-and-infer-next-history, accept-and-hold &amp; accept-line-and-down-history</span>
<span class="line-added">+      */</span>
<span class="line-added">+     protected boolean nextCommandFromHistory = false;</span>
<span class="line-added">+     protected int nextHistoryId = -1;</span>
  
  
      public LineReaderImpl(Terminal terminal) throws IOException {
          this(terminal, null, null);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,10 ***</span>
<span class="line-new-header">--- 277,11 ---</span>
          this.keyMaps = defaultKeyMaps();
  
          builtinWidgets = builtinWidgets();
          widgets = new HashMap&lt;&gt;(builtinWidgets);
          bindingReader = new BindingReader(terminal.reader());
<span class="line-added">+         doDisplay();</span>
      }
  
      public Terminal getTerminal() {
          return terminal;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 465,12 ***</span>
          Thread readLineThread = Thread.currentThread();
          SignalHandler previousIntrHandler = null;
          SignalHandler previousWinchHandler = null;
          SignalHandler previousContHandler = null;
          Attributes originalAttributes = null;
<span class="line-modified">!         boolean dumb = Terminal.TYPE_DUMB.equals(terminal.getType())</span>
<span class="line-removed">-                     || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());</span>
          try {
  
              this.maskingCallback = maskingCallback;
  
              /*
<span class="line-new-header">--- 479,11 ---</span>
          Thread readLineThread = Thread.currentThread();
          SignalHandler previousIntrHandler = null;
          SignalHandler previousWinchHandler = null;
          SignalHandler previousContHandler = null;
          Attributes originalAttributes = null;
<span class="line-modified">!         boolean dumb = isTerminalDumb();</span>
          try {
  
              this.maskingCallback = maskingCallback;
  
              /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 493,38 ***</span>
              setRightPrompt(rightPrompt);
              buf.clear();
              if (buffer != null) {
                  buf.write(buffer);
              }
              undo.clear();
              parsedLine = null;
              keyMap = MAIN;
  
              if (history != null) {
                  history.attach(this);
              }
  
<span class="line-modified">!             synchronized (this) {</span>
                  this.reading = true;
  
                  previousIntrHandler = terminal.handle(Signal.INT, signal -&gt; readLineThread.interrupt());
                  previousWinchHandler = terminal.handle(Signal.WINCH, this::handleSignal);
                  previousContHandler = terminal.handle(Signal.CONT, this::handleSignal);
                  originalAttributes = terminal.enterRawMode();
  
<span class="line-modified">!                 // Cache terminal size for the duration of the call to readLine()</span>
<span class="line-removed">-                 // It will eventually be updated with WINCH signals</span>
<span class="line-removed">-                 size.copy(terminal.getSize());</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 display = new Display(terminal, false);</span>
<span class="line-removed">-                 if (size.getRows() == 0 || size.getColumns() == 0) {</span>
<span class="line-removed">-                     display.resize(1, Integer.MAX_VALUE);</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     display.resize(size.getRows(), size.getColumns());</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (isSet(Option.DELAY_LINE_WRAP))</span>
<span class="line-removed">-                     display.setDelayLineWrap(true);</span>
  
                  // Move into application mode
                  if (!dumb) {
                      terminal.puts(Capability.keypad_xmit);
                      if (isSet(Option.AUTO_FRESH_LINE))
<span class="line-new-header">--- 506,40 ---</span>
              setRightPrompt(rightPrompt);
              buf.clear();
              if (buffer != null) {
                  buf.write(buffer);
              }
<span class="line-added">+             if (nextCommandFromHistory &amp;&amp; nextHistoryId &gt; 0) {</span>
<span class="line-added">+                 if (history.size() &gt; nextHistoryId) {</span>
<span class="line-added">+                     history.moveTo(nextHistoryId);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     history.moveTo(history.last());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 buf.write(history.current());</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 nextHistoryId = -1;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             nextCommandFromHistory = false;</span>
              undo.clear();
              parsedLine = null;
              keyMap = MAIN;
  
              if (history != null) {
                  history.attach(this);
              }
  
<span class="line-modified">!             try {</span>
<span class="line-added">+                 lock.lock();</span>
<span class="line-added">+ </span>
                  this.reading = true;
  
                  previousIntrHandler = terminal.handle(Signal.INT, signal -&gt; readLineThread.interrupt());
                  previousWinchHandler = terminal.handle(Signal.WINCH, this::handleSignal);
                  previousContHandler = terminal.handle(Signal.CONT, this::handleSignal);
                  originalAttributes = terminal.enterRawMode();
  
<span class="line-modified">!                 doDisplay();</span>
  
                  // Move into application mode
                  if (!dumb) {
                      terminal.puts(Capability.keypad_xmit);
                      if (isSet(Option.AUTO_FRESH_LINE))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,10 ***</span>
<span class="line-new-header">--- 560,12 ---</span>
                  undo.newState(buf.copy());
  
                  // Draw initial prompt
                  redrawLine();
                  redisplay();
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 lock.unlock();</span>
              }
  
              while (true) {
  
                  KeyMap&lt;Binding&gt; local = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,11 ***</span>
                  // Reset region after a paste
                  if (regionActive == RegionType.PASTE) {
                      regionActive = RegionType.NONE;
                  }
  
<span class="line-modified">!                 synchronized (this) {</span>
                      // Get executable widget
                      Buffer copy = buf.copy();
                      Widget w = getWidget(o);
                      if (!w.apply()) {
                          beep();
<span class="line-new-header">--- 593,12 ---</span>
                  // Reset region after a paste
                  if (regionActive == RegionType.PASTE) {
                      regionActive = RegionType.NONE;
                  }
  
<span class="line-modified">!                 try {</span>
<span class="line-added">+                     lock.lock();</span>
                      // Get executable widget
                      Buffer copy = buf.copy();
                      Widget w = getWidget(o);
                      if (!w.apply()) {
                          beep();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 608,21 ***</span>
                      }
  
                      if (!dumb) {
                          redisplay();
                      }
                  }
              }
          } catch (IOError e) {
              if (e.getCause() instanceof InterruptedIOException) {
                  throw new UserInterruptException(buf.toString());
              } else {
                  throw e;
              }
          }
          finally {
<span class="line-modified">!             synchronized (this) {</span>
                  this.reading = false;
  
                  cleanup();
                  if (originalAttributes != null) {
                      terminal.setAttributes(originalAttributes);
<span class="line-new-header">--- 626,25 ---</span>
                      }
  
                      if (!dumb) {
                          redisplay();
                      }
<span class="line-added">+                 } finally {</span>
<span class="line-added">+                     lock.unlock();</span>
                  }
              }
          } catch (IOError e) {
              if (e.getCause() instanceof InterruptedIOException) {
                  throw new UserInterruptException(buf.toString());
              } else {
                  throw e;
              }
          }
          finally {
<span class="line-modified">!             try {</span>
<span class="line-added">+                 lock.lock();</span>
<span class="line-added">+ </span>
                  this.reading = false;
  
                  cleanup();
                  if (originalAttributes != null) {
                      terminal.setAttributes(originalAttributes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 634,40 ***</span>
                      terminal.handle(Signal.WINCH, previousWinchHandler);
                  }
                  if (previousContHandler != null) {
                      terminal.handle(Signal.CONT, previousContHandler);
                  }
              }
              startedReading.set(false);
          }
      }
  
<span class="line-modified">!     @Override</span>
<span class="line-modified">!     public synchronized void printAbove(String str) {</span>
<span class="line-modified">!         boolean reading = this.reading;</span>
<span class="line-modified">!         if (reading) {</span>
<span class="line-modified">!             display.update(Collections.emptyList(), 0);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (str.endsWith(&quot;\n&quot;)) {</span>
<span class="line-modified">!             terminal.writer().print(str);</span>
          } else {
<span class="line-modified">!             terminal.writer().println(str);</span>
          }
<span class="line-modified">!         if (reading) {</span>
<span class="line-modified">!             redisplay(false);</span>
          }
<span class="line-removed">-         terminal.flush();</span>
      }
  
      @Override
      public void printAbove(AttributedString str) {
          printAbove(str.toAnsi(terminal));
      }
  
      @Override
<span class="line-modified">!     public synchronized boolean isReading() {</span>
<span class="line-modified">!         return reading;</span>
      }
  
      /* Make sure we position the cursor on column 0 */
      protected boolean freshLine() {
          boolean wrapAtEol = terminal.getBooleanCapability(Capability.auto_right_margin);
<span class="line-new-header">--- 656,73 ---</span>
                      terminal.handle(Signal.WINCH, previousWinchHandler);
                  }
                  if (previousContHandler != null) {
                      terminal.handle(Signal.CONT, previousContHandler);
                  }
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 lock.unlock();</span>
              }
              startedReading.set(false);
          }
      }
  
<span class="line-modified">!     private boolean isTerminalDumb(){</span>
<span class="line-modified">!         return Terminal.TYPE_DUMB.equals(terminal.getType())</span>
<span class="line-modified">!                 || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private void doDisplay(){</span>
<span class="line-modified">!         // Cache terminal size for the duration of the call to readLine()</span>
<span class="line-modified">!         // It will eventually be updated with WINCH signals</span>
<span class="line-added">+         size.copy(terminal.getBufferSize());</span>
<span class="line-added">+ </span>
<span class="line-added">+         display = new Display(terminal, false);</span>
<span class="line-added">+         if (size.getRows() == 0 || size.getColumns() == 0) {</span>
<span class="line-added">+             display.resize(1, Integer.MAX_VALUE);</span>
          } else {
<span class="line-modified">!             display.resize(size.getRows(), size.getColumns());</span>
          }
<span class="line-modified">!         if (isSet(Option.DELAY_LINE_WRAP))</span>
<span class="line-modified">!             display.setDelayLineWrap(true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void printAbove(String str) {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             lock.lock();</span>
<span class="line-added">+ </span>
<span class="line-added">+             boolean reading = this.reading;</span>
<span class="line-added">+             if (reading) {</span>
<span class="line-added">+                 display.update(Collections.emptyList(), 0);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (str.endsWith(&quot;\n&quot;) || str.endsWith(&quot;\n\033[m&quot;) || str.endsWith(&quot;\n\033[0m&quot;)) {</span>
<span class="line-added">+                 terminal.writer().print(str);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 terminal.writer().println(str);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (reading) {</span>
<span class="line-added">+                 redisplay(false);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             terminal.flush();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             lock.unlock();</span>
          }
      }
  
      @Override
      public void printAbove(AttributedString str) {
          printAbove(str.toAnsi(terminal));
      }
  
      @Override
<span class="line-modified">!     public boolean isReading() {</span>
<span class="line-modified">!         try {</span>
<span class="line-added">+             lock.lock();</span>
<span class="line-added">+             return reading;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             lock.unlock();</span>
<span class="line-added">+         }</span>
      }
  
      /* Make sure we position the cursor on column 0 */
      protected boolean freshLine() {
          boolean wrapAtEol = terminal.getBooleanCapability(Capability.auto_right_margin);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 698,31 ***</span>
              }
              sb.append(KeyMap.key(terminal, Capability.carriage_return));
              sb.append(&quot; &quot;);
              sb.append(KeyMap.key(terminal, Capability.carriage_return));
          }
<span class="line-modified">!         print(sb.toAnsi(terminal));</span>
          return true;
      }
  
      @Override
<span class="line-modified">!     public synchronized void callWidget(String name) {</span>
<span class="line-removed">-         if (!reading) {</span>
<span class="line-removed">-             throw new IllegalStateException(&quot;Widgets can only be called during a `readLine` call&quot;);</span>
<span class="line-removed">-         }</span>
          try {
<span class="line-modified">!             Widget w;</span>
<span class="line-modified">!             if (name.startsWith(&quot;.&quot;)) {</span>
<span class="line-modified">!                 w = builtinWidgets.get(name.substring(1));</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 w = widgets.get(name);</span>
              }
<span class="line-modified">!             if (w != null) {</span>
<span class="line-modified">!                 w.apply();</span>
              }
<span class="line-modified">!         } catch (Throwable t) {</span>
<span class="line-modified">!             Log.debug(&quot;Error executing widget &#39;&quot;, name, &quot;&#39;&quot;, t);</span>
          }
      }
  
      /**
       * Clear the line and redraw it.
<span class="line-new-header">--- 753,36 ---</span>
              }
              sb.append(KeyMap.key(terminal, Capability.carriage_return));
              sb.append(&quot; &quot;);
              sb.append(KeyMap.key(terminal, Capability.carriage_return));
          }
<span class="line-modified">!         sb.print(terminal);</span>
          return true;
      }
  
      @Override
<span class="line-modified">!     public void callWidget(String name) {</span>
          try {
<span class="line-modified">!             lock.lock();</span>
<span class="line-modified">!             if (!reading) {</span>
<span class="line-modified">!                 throw new IllegalStateException(&quot;Widgets can only be called during a `readLine` call&quot;);</span>
              }
<span class="line-modified">!             try {</span>
<span class="line-modified">!                 Widget w;</span>
<span class="line-added">+                 if (name.startsWith(&quot;.&quot;)) {</span>
<span class="line-added">+                     w = builtinWidgets.get(name.substring(1));</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     w = widgets.get(name);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (w != null) {</span>
<span class="line-added">+                     w.apply();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } catch (Throwable t) {</span>
<span class="line-added">+                 Log.debug(&quot;Error executing widget &#39;&quot;, name, &quot;&#39;&quot;, t);</span>
              }
<span class="line-modified">!         } finally {</span>
<span class="line-modified">!             lock.unlock();</span>
          }
      }
  
      /**
       * Clear the line and redraw it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 758,17 ***</span>
       * Read a character from the terminal.
       *
       * @return the character, or -1 if an EOF is received.
       */
      public int readCharacter() {
<span class="line-modified">!         return bindingReader.readCharacter();</span>
      }
  
      public int peekCharacter(long timeout) {
          return bindingReader.peekCharacter(timeout);
      }
  
      /**
       * Read from the input stream and decode an operation from the key map.
       *
       * The input stream will be read character by character until a matching
       * binding can be found.  Characters that can&#39;t possibly be matched to
<span class="line-new-header">--- 818,39 ---</span>
       * Read a character from the terminal.
       *
       * @return the character, or -1 if an EOF is received.
       */
      public int readCharacter() {
<span class="line-modified">!         if (lock.isHeldByCurrentThread()) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 lock.unlock();</span>
<span class="line-added">+                 return bindingReader.readCharacter();</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 lock.lock();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return bindingReader.readCharacter();</span>
<span class="line-added">+         }</span>
      }
  
      public int peekCharacter(long timeout) {
          return bindingReader.peekCharacter(timeout);
      }
  
<span class="line-added">+     protected &lt;T&gt; T doReadBinding(KeyMap&lt;T&gt; keys, KeyMap&lt;T&gt; local) {</span>
<span class="line-added">+         if (lock.isHeldByCurrentThread()) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 lock.unlock();</span>
<span class="line-added">+                 return bindingReader.readBinding(keys, local);</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 lock.lock();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return bindingReader.readBinding(keys, local);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Read from the input stream and decode an operation from the key map.
       *
       * The input stream will be read character by character until a matching
       * binding can be found.  Characters that can&#39;t possibly be matched to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 781,11 ***</span>
      public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
          return readBinding(keys, null);
      }
  
      public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
<span class="line-modified">!         Binding o = bindingReader.readBinding(keys, local);</span>
          /*
           * The kill ring keeps record of whether or not the
           * previous command was a yank or a kill. We reset
           * that state here if needed.
           */
<span class="line-new-header">--- 863,11 ---</span>
      public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
          return readBinding(keys, null);
      }
  
      public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
<span class="line-modified">!         Binding o = doReadBinding(keys, local);</span>
          /*
           * The kill ring keeps record of whether or not the
           * previous command was a yank or a kill. We reset
           * that state here if needed.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,11 ***</span>
                  if (escaped) {
                      escaped = false;
                      if (ch != &#39;\n&#39;) {
                          sb.append(ch);
                      }
<span class="line-modified">!                 } else if (ch == &#39;\\&#39;) {</span>
                      escaped = true;
                  } else {
                      sb.append(ch);
                  }
              }
<span class="line-new-header">--- 1006,11 ---</span>
                  if (escaped) {
                      escaped = false;
                      if (ch != &#39;\n&#39;) {
                          sb.append(ch);
                      }
<span class="line-modified">!                 } else if (parser.isEscapeChar(ch)) {</span>
                      escaped = true;
                  } else {
                      sb.append(ch);
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 946,17 ***</span>
          return str;
      }
  
      protected void handleSignal(Signal signal) {
          if (signal == Signal.WINCH) {
<span class="line-modified">!             size.copy(terminal.getSize());</span>
              display.resize(size.getRows(), size.getColumns());
              redisplay();
          }
          else if (signal == Signal.CONT) {
              terminal.enterRawMode();
<span class="line-modified">!             size.copy(terminal.getSize());</span>
              display.resize(size.getRows(), size.getColumns());
              terminal.puts(Capability.keypad_xmit);
              redrawLine();
              redisplay();
          }
<span class="line-new-header">--- 1028,22 ---</span>
          return str;
      }
  
      protected void handleSignal(Signal signal) {
          if (signal == Signal.WINCH) {
<span class="line-modified">!             Status status = Status.getStatus(terminal, false);</span>
<span class="line-added">+             if (status != null) {</span>
<span class="line-added">+                 status.hardReset();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             size.copy(terminal.getBufferSize());</span>
              display.resize(size.getRows(), size.getColumns());
<span class="line-added">+             redrawLine();</span>
              redisplay();
          }
          else if (signal == Signal.CONT) {
              terminal.enterRawMode();
<span class="line-modified">!             size.copy(terminal.getBufferSize());</span>
              display.resize(size.getRows(), size.getColumns());
              terminal.puts(Capability.keypad_xmit);
              redrawLine();
              redisplay();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1901,11 ***</span>
              keyMap = keyMaps.get(SAFE);
          }
          while (true) {
              post = () -&gt; new AttributedString(searchPrompt + searchBuffer.toString() + &quot;_&quot;);
              redisplay();
<span class="line-modified">!             Binding b = bindingReader.readBinding(keyMap);</span>
              if (b instanceof Reference) {
                  String func = ((Reference) b).name();
                  switch (func) {
                      case SEND_BREAK:
                          post = null;
<span class="line-new-header">--- 1988,11 ---</span>
              keyMap = keyMaps.get(SAFE);
          }
          while (true) {
              post = () -&gt; new AttributedString(searchPrompt + searchBuffer.toString() + &quot;_&quot;);
              redisplay();
<span class="line-modified">!             Binding b = doReadBinding(keyMap, null);</span>
              if (b instanceof Reference) {
                  String func = ((Reference) b).name();
                  switch (func) {
                      case SEND_BREAK:
                          post = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2298,11 ***</span>
              pos = mark;
              v
          } else {
              viMoveMode = mode;
              mark = -1;
<span class="line-modified">!             Binding b = bindingReader.readBinding(getKeys(), keyMaps.get(VIOPP));</span>
              if (b == null || new Reference(SEND_BREAK).equals(b)) {
                  viMoveMode = ViMoveMode.NORMAL;
                  mark = oldMark;
                  return -1;
              }
<span class="line-new-header">--- 2385,11 ---</span>
              pos = mark;
              v
          } else {
              viMoveMode = mode;
              mark = -1;
<span class="line-modified">!             Binding b = doReadBinding(getKeys(), keyMaps.get(VIOPP));</span>
              if (b == null || new Reference(SEND_BREAK).equals(b)) {
                  viMoveMode = ViMoveMode.NORMAL;
                  mark = oldMark;
                  return -1;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2708,10 ***</span>
<span class="line-new-header">--- 2795,46 ---</span>
      protected boolean quit() {
          getBuffer().clear();
          return acceptLine();
      }
  
<span class="line-added">+     protected boolean acceptAndHold() {</span>
<span class="line-added">+         nextCommandFromHistory = false;</span>
<span class="line-added">+         acceptLine();</span>
<span class="line-added">+         if (!buf.toString().isEmpty()) {</span>
<span class="line-added">+             nextHistoryId = Integer.MAX_VALUE;</span>
<span class="line-added">+             nextCommandFromHistory = true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return nextCommandFromHistory;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected boolean acceptLineAndDownHistory() {</span>
<span class="line-added">+         nextCommandFromHistory = false;</span>
<span class="line-added">+         acceptLine();</span>
<span class="line-added">+         if (nextHistoryId &lt; 0) {</span>
<span class="line-added">+             nextHistoryId = history.index();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (history.size() &gt; nextHistoryId + 1) {</span>
<span class="line-added">+             nextHistoryId++;</span>
<span class="line-added">+             nextCommandFromHistory = true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return nextCommandFromHistory;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     protected boolean acceptAndInferNextHistory() {</span>
<span class="line-added">+         nextCommandFromHistory = false;</span>
<span class="line-added">+         acceptLine();</span>
<span class="line-added">+         if (!buf.toString().isEmpty()) {</span>
<span class="line-added">+             nextHistoryId = searchBackwards(buf.toString(), history.last());</span>
<span class="line-added">+             if (nextHistoryId &gt;= 0 &amp;&amp; history.size() &gt; nextHistoryId + 1) {</span>
<span class="line-added">+                 nextHistoryId++;</span>
<span class="line-added">+                 nextCommandFromHistory = true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return nextCommandFromHistory;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      protected boolean acceptLine() {
          parsedLine = null;
          if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
              try {
                  String str = buf.toString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3341,259 ***</span>
          return true;
      }
  
      protected Map&lt;String, Widget&gt; builtinWidgets() {
          Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
<span class="line-modified">!         widgets.put(ACCEPT_LINE, this::acceptLine);</span>
<span class="line-modified">!         widgets.put(ARGUMENT_BASE, this::argumentBase);</span>
<span class="line-modified">!         widgets.put(BACKWARD_CHAR, this::backwardChar);</span>
<span class="line-modified">!         widgets.put(BACKWARD_DELETE_CHAR, this::backwardDeleteChar);</span>
<span class="line-modified">!         widgets.put(BACKWARD_DELETE_WORD, this::backwardDeleteWord);</span>
<span class="line-modified">!         widgets.put(BACKWARD_KILL_LINE, this::backwardKillLine);</span>
<span class="line-modified">!         widgets.put(BACKWARD_KILL_WORD, this::backwardKillWord);</span>
<span class="line-modified">!         widgets.put(BACKWARD_WORD, this::backwardWord);</span>
<span class="line-modified">!         widgets.put(BEEP, this::beep);</span>
<span class="line-modified">!         widgets.put(BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);</span>
<span class="line-modified">!         widgets.put(BEGINNING_OF_HISTORY, this::beginningOfHistory);</span>
<span class="line-modified">!         widgets.put(BEGINNING_OF_LINE, this::beginningOfLine);</span>
<span class="line-modified">!         widgets.put(BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);</span>
<span class="line-modified">!         widgets.put(CAPITALIZE_WORD, this::capitalizeWord);</span>
<span class="line-modified">!         widgets.put(CLEAR, this::clear);</span>
<span class="line-modified">!         widgets.put(CLEAR_SCREEN, this::clearScreen);</span>
<span class="line-modified">!         widgets.put(COMPLETE_PREFIX, this::completePrefix);</span>
<span class="line-modified">!         widgets.put(COMPLETE_WORD, this::completeWord);</span>
<span class="line-modified">!         widgets.put(COPY_PREV_WORD, this::copyPrevWord);</span>
<span class="line-modified">!         widgets.put(COPY_REGION_AS_KILL, this::copyRegionAsKill);</span>
<span class="line-modified">!         widgets.put(DELETE_CHAR, this::deleteChar);</span>
<span class="line-modified">!         widgets.put(DELETE_CHAR_OR_LIST, this::deleteCharOrList);</span>
<span class="line-modified">!         widgets.put(DELETE_WORD, this::deleteWord);</span>
<span class="line-modified">!         widgets.put(DIGIT_ARGUMENT, this::digitArgument);</span>
<span class="line-modified">!         widgets.put(DO_LOWERCASE_VERSION, this::doLowercaseVersion);</span>
<span class="line-modified">!         widgets.put(DOWN_CASE_WORD, this::downCaseWord);</span>
<span class="line-modified">!         widgets.put(DOWN_LINE, this::downLine);</span>
<span class="line-modified">!         widgets.put(DOWN_LINE_OR_HISTORY, this::downLineOrHistory);</span>
<span class="line-modified">!         widgets.put(DOWN_LINE_OR_SEARCH, this::downLineOrSearch);</span>
<span class="line-modified">!         widgets.put(DOWN_HISTORY, this::downHistory);</span>
<span class="line-modified">!         widgets.put(EMACS_EDITING_MODE, this::emacsEditingMode);</span>
<span class="line-modified">!         widgets.put(EMACS_BACKWARD_WORD, this::emacsBackwardWord);</span>
<span class="line-modified">!         widgets.put(EMACS_FORWARD_WORD, this::emacsForwardWord);</span>
<span class="line-modified">!         widgets.put(END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);</span>
<span class="line-modified">!         widgets.put(END_OF_HISTORY, this::endOfHistory);</span>
<span class="line-modified">!         widgets.put(END_OF_LINE, this::endOfLine);</span>
<span class="line-modified">!         widgets.put(END_OF_LINE_HIST, this::endOfLineHist);</span>
<span class="line-modified">!         widgets.put(EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);</span>
<span class="line-modified">!         widgets.put(EXPAND_HISTORY, this::expandHistory);</span>
<span class="line-modified">!         widgets.put(EXPAND_OR_COMPLETE, this::expandOrComplete);</span>
<span class="line-modified">!         widgets.put(EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);</span>
<span class="line-modified">!         widgets.put(EXPAND_WORD, this::expandWord);</span>
<span class="line-modified">!         widgets.put(FRESH_LINE, this::freshLine);</span>
<span class="line-modified">!         widgets.put(FORWARD_CHAR, this::forwardChar);</span>
<span class="line-modified">!         widgets.put(FORWARD_WORD, this::forwardWord);</span>
<span class="line-modified">!         widgets.put(HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);</span>
<span class="line-modified">!         widgets.put(HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);</span>
<span class="line-modified">!         widgets.put(HISTORY_SEARCH_BACKWARD, this::historySearchBackward);</span>
<span class="line-modified">!         widgets.put(HISTORY_SEARCH_FORWARD, this::historySearchForward);</span>
<span class="line-modified">!         widgets.put(INSERT_CLOSE_CURLY, this::insertCloseCurly);</span>
<span class="line-modified">!         widgets.put(INSERT_CLOSE_PAREN, this::insertCloseParen);</span>
<span class="line-modified">!         widgets.put(INSERT_CLOSE_SQUARE, this::insertCloseSquare);</span>
<span class="line-modified">!         widgets.put(INSERT_COMMENT, this::insertComment);</span>
<span class="line-modified">!         widgets.put(KILL_BUFFER, this::killBuffer);</span>
<span class="line-modified">!         widgets.put(KILL_LINE, this::killLine);</span>
<span class="line-modified">!         widgets.put(KILL_REGION, this::killRegion);</span>
<span class="line-modified">!         widgets.put(KILL_WHOLE_LINE, this::killWholeLine);</span>
<span class="line-modified">!         widgets.put(KILL_WORD, this::killWord);</span>
<span class="line-modified">!         widgets.put(LIST_CHOICES, this::listChoices);</span>
<span class="line-modified">!         widgets.put(MENU_COMPLETE, this::menuComplete);</span>
<span class="line-modified">!         widgets.put(MENU_EXPAND_OR_COMPLETE, this::menuExpandOrComplete);</span>
<span class="line-modified">!         widgets.put(NEG_ARGUMENT, this::negArgument);</span>
<span class="line-modified">!         widgets.put(OVERWRITE_MODE, this::overwriteMode);</span>
<span class="line-modified">! //        widgets.put(QUIT, this::quit);</span>
<span class="line-modified">!         widgets.put(QUOTED_INSERT, this::quotedInsert);</span>
<span class="line-modified">!         widgets.put(REDISPLAY, this::redisplay);</span>
<span class="line-modified">!         widgets.put(REDRAW_LINE, this::redrawLine);</span>
<span class="line-modified">!         widgets.put(REDO, this::redo);</span>
<span class="line-modified">!         widgets.put(SELF_INSERT, this::selfInsert);</span>
<span class="line-modified">!         widgets.put(SELF_INSERT_UNMETA, this::selfInsertUnmeta);</span>
<span class="line-modified">!         widgets.put(SEND_BREAK, this::sendBreak);</span>
<span class="line-modified">!         widgets.put(SET_MARK_COMMAND, this::setMarkCommand);</span>
<span class="line-modified">!         widgets.put(TRANSPOSE_CHARS, this::transposeChars);</span>
<span class="line-modified">!         widgets.put(TRANSPOSE_WORDS, this::transposeWords);</span>
<span class="line-modified">!         widgets.put(UNDEFINED_KEY, this::undefinedKey);</span>
<span class="line-modified">!         widgets.put(UNIVERSAL_ARGUMENT, this::universalArgument);</span>
<span class="line-modified">!         widgets.put(UNDO, this::undo);</span>
<span class="line-modified">!         widgets.put(UP_CASE_WORD, this::upCaseWord);</span>
<span class="line-modified">!         widgets.put(UP_HISTORY, this::upHistory);</span>
<span class="line-modified">!         widgets.put(UP_LINE, this::upLine);</span>
<span class="line-modified">!         widgets.put(UP_LINE_OR_HISTORY, this::upLineOrHistory);</span>
<span class="line-modified">!         widgets.put(UP_LINE_OR_SEARCH, this::upLineOrSearch);</span>
<span class="line-modified">!         widgets.put(VI_ADD_EOL, this::viAddEol);</span>
<span class="line-modified">!         widgets.put(VI_ADD_NEXT, this::viAddNext);</span>
<span class="line-modified">!         widgets.put(VI_BACKWARD_CHAR, this::viBackwardChar);</span>
<span class="line-modified">!         widgets.put(VI_BACKWARD_DELETE_CHAR, this::viBackwardDeleteChar);</span>
<span class="line-modified">!         widgets.put(VI_BACKWARD_BLANK_WORD, this::viBackwardBlankWord);</span>
<span class="line-modified">!         widgets.put(VI_BACKWARD_BLANK_WORD_END, this::viBackwardBlankWordEnd);</span>
<span class="line-modified">!         widgets.put(VI_BACKWARD_KILL_WORD, this::viBackwardKillWord);</span>
<span class="line-modified">!         widgets.put(VI_BACKWARD_WORD, this::viBackwardWord);</span>
<span class="line-modified">!         widgets.put(VI_BACKWARD_WORD_END, this::viBackwardWordEnd);</span>
<span class="line-modified">!         widgets.put(VI_BEGINNING_OF_LINE, this::viBeginningOfLine);</span>
<span class="line-modified">!         widgets.put(VI_CMD_MODE, this::viCmdMode);</span>
<span class="line-modified">!         widgets.put(VI_DIGIT_OR_BEGINNING_OF_LINE, this::viDigitOrBeginningOfLine);</span>
<span class="line-modified">!         widgets.put(VI_DOWN_LINE_OR_HISTORY, this::viDownLineOrHistory);</span>
<span class="line-modified">!         widgets.put(VI_CHANGE, this::viChange);</span>
<span class="line-modified">!         widgets.put(VI_CHANGE_EOL, this::viChangeEol);</span>
<span class="line-modified">!         widgets.put(VI_CHANGE_WHOLE_LINE, this::viChangeWholeLine);</span>
<span class="line-modified">!         widgets.put(VI_DELETE_CHAR, this::viDeleteChar);</span>
<span class="line-modified">!         widgets.put(VI_DELETE, this::viDelete);</span>
<span class="line-modified">!         widgets.put(VI_END_OF_LINE, this::viEndOfLine);</span>
<span class="line-modified">!         widgets.put(VI_KILL_EOL, this::viKillEol);</span>
<span class="line-modified">!         widgets.put(VI_FIRST_NON_BLANK, this::viFirstNonBlank);</span>
<span class="line-modified">!         widgets.put(VI_FIND_NEXT_CHAR, this::viFindNextChar);</span>
<span class="line-modified">!         widgets.put(VI_FIND_NEXT_CHAR_SKIP, this::viFindNextCharSkip);</span>
<span class="line-modified">!         widgets.put(VI_FIND_PREV_CHAR, this::viFindPrevChar);</span>
<span class="line-modified">!         widgets.put(VI_FIND_PREV_CHAR_SKIP, this::viFindPrevCharSkip);</span>
<span class="line-modified">!         widgets.put(VI_FORWARD_BLANK_WORD, this::viForwardBlankWord);</span>
<span class="line-modified">!         widgets.put(VI_FORWARD_BLANK_WORD_END, this::viForwardBlankWordEnd);</span>
<span class="line-modified">!         widgets.put(VI_FORWARD_CHAR, this::viForwardChar);</span>
<span class="line-modified">!         widgets.put(VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">!         widgets.put(VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">!         widgets.put(VI_FORWARD_WORD_END, this::viForwardWordEnd);</span>
<span class="line-modified">!         widgets.put(VI_HISTORY_SEARCH_BACKWARD, this::viHistorySearchBackward);</span>
<span class="line-modified">!         widgets.put(VI_HISTORY_SEARCH_FORWARD, this::viHistorySearchForward);</span>
<span class="line-modified">!         widgets.put(VI_INSERT, this::viInsert);</span>
<span class="line-modified">!         widgets.put(VI_INSERT_BOL, this::viInsertBol);</span>
<span class="line-modified">!         widgets.put(VI_INSERT_COMMENT, this::viInsertComment);</span>
<span class="line-modified">!         widgets.put(VI_JOIN, this::viJoin);</span>
<span class="line-modified">!         widgets.put(VI_KILL_LINE, this::viKillWholeLine);</span>
<span class="line-modified">!         widgets.put(VI_MATCH_BRACKET, this::viMatchBracket);</span>
<span class="line-modified">!         widgets.put(VI_OPEN_LINE_ABOVE, this::viOpenLineAbove);</span>
<span class="line-modified">!         widgets.put(VI_OPEN_LINE_BELOW, this::viOpenLineBelow);</span>
<span class="line-modified">!         widgets.put(VI_PUT_AFTER, this::viPutAfter);</span>
<span class="line-modified">!         widgets.put(VI_PUT_BEFORE, this::viPutBefore);</span>
<span class="line-modified">!         widgets.put(VI_REPEAT_FIND, this::viRepeatFind);</span>
<span class="line-modified">!         widgets.put(VI_REPEAT_SEARCH, this::viRepeatSearch);</span>
<span class="line-modified">!         widgets.put(VI_REPLACE_CHARS, this::viReplaceChars);</span>
<span class="line-modified">!         widgets.put(VI_REV_REPEAT_FIND, this::viRevRepeatFind);</span>
<span class="line-modified">!         widgets.put(VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);</span>
<span class="line-modified">!         widgets.put(VI_SWAP_CASE, this::viSwapCase);</span>
<span class="line-modified">!         widgets.put(VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);</span>
<span class="line-modified">!         widgets.put(VI_YANK, this::viYankTo);</span>
<span class="line-modified">!         widgets.put(VI_YANK_WHOLE_LINE, this::viYankWholeLine);</span>
<span class="line-modified">!         widgets.put(VISUAL_LINE_MODE, this::visualLineMode);</span>
<span class="line-modified">!         widgets.put(VISUAL_MODE, this::visualMode);</span>
<span class="line-modified">!         widgets.put(WHAT_CURSOR_POSITION, this::whatCursorPosition);</span>
<span class="line-modified">!         widgets.put(YANK, this::yank);</span>
<span class="line-modified">!         widgets.put(YANK_POP, this::yankPop);</span>
<span class="line-modified">!         widgets.put(MOUSE, this::mouse);</span>
<span class="line-modified">!         widgets.put(BEGIN_PASTE, this::beginPaste);</span>
<span class="line-modified">!         widgets.put(FOCUS_IN, this::focusIn);</span>
<span class="line-modified">!         widgets.put(FOCUS_OUT, this::focusOut);</span>
          return widgets;
      }
  
      public boolean redisplay() {
          redisplay(true);
          return true;
      }
  
<span class="line-modified">!     protected synchronized void redisplay(boolean flush) {</span>
<span class="line-modified">!         if (skipRedisplay) {</span>
<span class="line-modified">!             skipRedisplay = false;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!         Status status = Status.getStatus(terminal, false);</span>
<span class="line-modified">!         if (status != null) {</span>
<span class="line-modified">!             status.redraw();</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (size.getRows() &gt; 0 &amp;&amp; size.getRows() &lt; MIN_ROWS) {</span>
<span class="line-modified">!             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>
  
<span class="line-modified">!             sb.append(prompt);</span>
<span class="line-modified">!             concat(getHighlightedBuffer(buf.toString()).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-removed">-             AttributedString full = sb.toAttributedString();</span>
  
<span class="line-modified">!             sb.setLength(0);</span>
<span class="line-modified">!             sb.append(prompt);</span>
<span class="line-modified">!             String line = buf.upToCursor();</span>
<span class="line-modified">!             if(maskingCallback != null) {</span>
<span class="line-modified">!                 line = maskingCallback.display(line);</span>
              }
  
<span class="line-modified">!             concat(new AttributedString(line).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-modified">!             AttributedString toCursor = sb.toAttributedString();</span>
  
<span class="line-modified">!             int w = WCWidth.wcwidth(&#39;\u2026&#39;);</span>
<span class="line-modified">!             int width = size.getColumns();</span>
<span class="line-modified">!             int cursor = toCursor.columnLength();</span>
<span class="line-modified">!             int inc = width /2 + 1;</span>
<span class="line-modified">!             while (cursor &lt;= smallTerminalOffset + w) {</span>
<span class="line-modified">!                 smallTerminalOffset -= inc;</span>
              }
<span class="line-modified">!             while (cursor &gt;= smallTerminalOffset + width - w) {</span>
<span class="line-modified">!                 smallTerminalOffset += inc;</span>
              }
<span class="line-modified">!             if (smallTerminalOffset &gt; 0) {</span>
<span class="line-modified">!                 sb.setLength(0);</span>
<span class="line-removed">-                 sb.append(&quot;\u2026&quot;);</span>
<span class="line-removed">-                 sb.append(full.columnSubSequence(smallTerminalOffset + w, Integer.MAX_VALUE));</span>
<span class="line-removed">-                 full = sb.toAttributedString();</span>
              }
<span class="line-modified">!             int length = full.columnLength();</span>
<span class="line-modified">!             if (length &gt;= smallTerminalOffset + width) {</span>
<span class="line-modified">!                 sb.setLength(0);</span>
<span class="line-removed">-                 sb.append(full.columnSubSequence(0, width - w));</span>
<span class="line-removed">-                 sb.append(&quot;\u2026&quot;);</span>
<span class="line-removed">-                 full = sb.toAttributedString();</span>
              }
  
<span class="line-modified">!             display.update(Collections.singletonList(full), cursor - smallTerminalOffset, flush);</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!         AttributedString full = getDisplayedBufferWithPrompts(secondaryPrompts);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         List&lt;AttributedString&gt; newLines;</span>
<span class="line-modified">!         if (size.getColumns() &lt;= 0) {</span>
<span class="line-modified">!             newLines = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!             newLines.add(full);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             newLines = full.columnSplitLength(size.getColumns(), true, display.delayLineWrap());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         List&lt;AttributedString&gt; rightPromptLines;</span>
<span class="line-modified">!         if (rightPrompt.length() == 0 || size.getColumns() &lt;= 0) {</span>
<span class="line-removed">-             rightPromptLines = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             rightPromptLines = rightPrompt.columnSplitLength(size.getColumns());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         while (newLines.size() &lt; rightPromptLines.size()) {</span>
<span class="line-removed">-             newLines.add(new AttributedString(&quot;&quot;));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         for (int i = 0; i &lt; rightPromptLines.size(); i++) {</span>
<span class="line-removed">-             AttributedString line = rightPromptLines.get(i);</span>
<span class="line-removed">-             newLines.set(i, addRightPrompt(line, newLines.get(i)));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         int cursorPos = -1;</span>
<span class="line-removed">-         if (size.getColumns() &gt; 0) {</span>
<span class="line-removed">-             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>
<span class="line-removed">-             sb.append(prompt);</span>
<span class="line-removed">-             String buffer = buf.upToCursor();</span>
<span class="line-removed">-             if (maskingCallback != null) {</span>
<span class="line-removed">-                 buffer = maskingCallback.display(buffer);</span>
              }
<span class="line-modified">!             sb.append(insertSecondaryPrompts(new AttributedString(buffer), secondaryPrompts, false));</span>
<span class="line-modified">!             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());</span>
<span class="line-modified">!             if (!promptLines.isEmpty()) {</span>
<span class="line-modified">!                 cursorPos = size.cursorPos(promptLines.size() - 1,</span>
<span class="line-modified">!                                            promptLines.get(promptLines.size() - 1).columnLength());</span>
              }
          }
<span class="line-removed">- </span>
<span class="line-removed">-         display.update(newLines, cursorPos, flush);</span>
      }
  
      private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
          if (lines.size() &gt; 1) {
              for (int i = 0; i &lt; lines.size() - 1; i++) {
<span class="line-new-header">--- 3464,321 ---</span>
          return true;
      }
  
      protected Map&lt;String, Widget&gt; builtinWidgets() {
          Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
<span class="line-modified">!         addBuiltinWidget(widgets, ACCEPT_AND_INFER_NEXT_HISTORY, this::acceptAndInferNextHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, ACCEPT_AND_HOLD, this::acceptAndHold);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, ACCEPT_LINE, this::acceptLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, ACCEPT_LINE_AND_DOWN_HISTORY, this::acceptLineAndDownHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, ARGUMENT_BASE, this::argumentBase);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BACKWARD_CHAR, this::backwardChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BACKWARD_DELETE_CHAR, this::backwardDeleteChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BACKWARD_DELETE_WORD, this::backwardDeleteWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BACKWARD_KILL_LINE, this::backwardKillLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BACKWARD_KILL_WORD, this::backwardKillWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BACKWARD_WORD, this::backwardWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BEEP, this::beep);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BEGINNING_OF_HISTORY, this::beginningOfHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BEGINNING_OF_LINE, this::beginningOfLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, CAPITALIZE_WORD, this::capitalizeWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, CLEAR, this::clear);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, CLEAR_SCREEN, this::clearScreen);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, COMPLETE_PREFIX, this::completePrefix);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, COMPLETE_WORD, this::completeWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, COPY_PREV_WORD, this::copyPrevWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, COPY_REGION_AS_KILL, this::copyRegionAsKill);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DELETE_CHAR, this::deleteChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DELETE_CHAR_OR_LIST, this::deleteCharOrList);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DELETE_WORD, this::deleteWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DIGIT_ARGUMENT, this::digitArgument);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DO_LOWERCASE_VERSION, this::doLowercaseVersion);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DOWN_CASE_WORD, this::downCaseWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DOWN_LINE, this::downLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DOWN_LINE_OR_HISTORY, this::downLineOrHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DOWN_LINE_OR_SEARCH, this::downLineOrSearch);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, DOWN_HISTORY, this::downHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EMACS_EDITING_MODE, this::emacsEditingMode);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EMACS_BACKWARD_WORD, this::emacsBackwardWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EMACS_FORWARD_WORD, this::emacsForwardWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, END_OF_HISTORY, this::endOfHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, END_OF_LINE, this::endOfLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, END_OF_LINE_HIST, this::endOfLineHist);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EXPAND_HISTORY, this::expandHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE, this::expandOrComplete);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, EXPAND_WORD, this::expandWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, FRESH_LINE, this::freshLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, FORWARD_CHAR, this::forwardChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, FORWARD_WORD, this::forwardWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, HISTORY_SEARCH_BACKWARD, this::historySearchBackward);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, HISTORY_SEARCH_FORWARD, this::historySearchForward);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, INSERT_CLOSE_CURLY, this::insertCloseCurly);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, INSERT_CLOSE_PAREN, this::insertCloseParen);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, INSERT_CLOSE_SQUARE, this::insertCloseSquare);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, INSERT_COMMENT, this::insertComment);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, KILL_BUFFER, this::killBuffer);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, KILL_LINE, this::killLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, KILL_REGION, this::killRegion);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, KILL_WHOLE_LINE, this::killWholeLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, KILL_WORD, this::killWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, LIST_CHOICES, this::listChoices);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, MENU_COMPLETE, this::menuComplete);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, MENU_EXPAND_OR_COMPLETE, this::menuExpandOrComplete);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, NEG_ARGUMENT, this::negArgument);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, OVERWRITE_MODE, this::overwriteMode);</span>
<span class="line-modified">! //        addBuiltinWidget(widgets, QUIT, this::quit);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, QUOTED_INSERT, this::quotedInsert);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, REDISPLAY, this::redisplay);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, REDRAW_LINE, this::redrawLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, REDO, this::redo);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, SELF_INSERT, this::selfInsert);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, SELF_INSERT_UNMETA, this::selfInsertUnmeta);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, SEND_BREAK, this::sendBreak);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, SET_MARK_COMMAND, this::setMarkCommand);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, TRANSPOSE_CHARS, this::transposeChars);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, TRANSPOSE_WORDS, this::transposeWords);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UNDEFINED_KEY, this::undefinedKey);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UNIVERSAL_ARGUMENT, this::universalArgument);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UNDO, this::undo);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UP_CASE_WORD, this::upCaseWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UP_HISTORY, this::upHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UP_LINE, this::upLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UP_LINE_OR_HISTORY, this::upLineOrHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, UP_LINE_OR_SEARCH, this::upLineOrSearch);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_ADD_EOL, this::viAddEol);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_ADD_NEXT, this::viAddNext);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BACKWARD_CHAR, this::viBackwardChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BACKWARD_DELETE_CHAR, this::viBackwardDeleteChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD, this::viBackwardBlankWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD_END, this::viBackwardBlankWordEnd);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BACKWARD_KILL_WORD, this::viBackwardKillWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BACKWARD_WORD, this::viBackwardWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BACKWARD_WORD_END, this::viBackwardWordEnd);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_BEGINNING_OF_LINE, this::viBeginningOfLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_CMD_MODE, this::viCmdMode);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_DIGIT_OR_BEGINNING_OF_LINE, this::viDigitOrBeginningOfLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_DOWN_LINE_OR_HISTORY, this::viDownLineOrHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_CHANGE, this::viChange);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_CHANGE_EOL, this::viChangeEol);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_CHANGE_WHOLE_LINE, this::viChangeWholeLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_DELETE_CHAR, this::viDeleteChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_DELETE, this::viDelete);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_END_OF_LINE, this::viEndOfLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_KILL_EOL, this::viKillEol);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FIRST_NON_BLANK, this::viFirstNonBlank);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR, this::viFindNextChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR_SKIP, this::viFindNextCharSkip);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR, this::viFindPrevChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR_SKIP, this::viFindPrevCharSkip);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD, this::viForwardBlankWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD_END, this::viForwardBlankWordEnd);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FORWARD_CHAR, this::viForwardChar);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_FORWARD_WORD_END, this::viForwardWordEnd);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_BACKWARD, this::viHistorySearchBackward);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_FORWARD, this::viHistorySearchForward);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_INSERT, this::viInsert);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_INSERT_BOL, this::viInsertBol);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_INSERT_COMMENT, this::viInsertComment);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_JOIN, this::viJoin);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_KILL_LINE, this::viKillWholeLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_MATCH_BRACKET, this::viMatchBracket);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_OPEN_LINE_ABOVE, this::viOpenLineAbove);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_OPEN_LINE_BELOW, this::viOpenLineBelow);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_PUT_AFTER, this::viPutAfter);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_PUT_BEFORE, this::viPutBefore);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_REPEAT_FIND, this::viRepeatFind);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_REPEAT_SEARCH, this::viRepeatSearch);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_REPLACE_CHARS, this::viReplaceChars);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_REV_REPEAT_FIND, this::viRevRepeatFind);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_SWAP_CASE, this::viSwapCase);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_YANK, this::viYankTo);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VI_YANK_WHOLE_LINE, this::viYankWholeLine);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VISUAL_LINE_MODE, this::visualLineMode);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, VISUAL_MODE, this::visualMode);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, WHAT_CURSOR_POSITION, this::whatCursorPosition);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, YANK, this::yank);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, YANK_POP, this::yankPop);</span>
<span class="line-modified">!         addBuiltinWidget(widgets, MOUSE, this::mouse);</span>
<span class="line-added">+         addBuiltinWidget(widgets, BEGIN_PASTE, this::beginPaste);</span>
<span class="line-added">+         addBuiltinWidget(widgets, FOCUS_IN, this::focusIn);</span>
<span class="line-added">+         addBuiltinWidget(widgets, FOCUS_OUT, this::focusOut);</span>
          return widgets;
      }
  
<span class="line-added">+     private void addBuiltinWidget(Map&lt;String, Widget&gt; widgets, String name, Widget widget) {</span>
<span class="line-added">+         widgets.put(name, namedWidget(name, widget));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private Widget namedWidget(String name, Widget widget) {</span>
<span class="line-added">+         return new Widget() {</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public String toString() {</span>
<span class="line-added">+                 return name;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             @Override</span>
<span class="line-added">+             public boolean apply() {</span>
<span class="line-added">+                 return widget.apply();</span>
<span class="line-added">+             }</span>
<span class="line-added">+         };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public boolean redisplay() {
          redisplay(true);
          return true;
      }
  
<span class="line-modified">!     protected void redisplay(boolean flush) {</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             lock.lock();</span>
  
<span class="line-modified">!             if (skipRedisplay) {</span>
<span class="line-modified">!                 skipRedisplay = false;</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             Status status = Status.getStatus(terminal, false);</span>
<span class="line-modified">!             if (status != null) {</span>
<span class="line-added">+                 status.redraw();</span>
<span class="line-added">+             }</span>
  
<span class="line-modified">!             if (size.getRows() &gt; 0 &amp;&amp; size.getRows() &lt; MIN_ROWS) {</span>
<span class="line-modified">!                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>
  
<span class="line-modified">!                 sb.append(prompt);</span>
<span class="line-modified">!                 concat(getHighlightedBuffer(buf.toString()).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-modified">!                 AttributedString full = sb.toAttributedString();</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 sb.setLength(0);</span>
<span class="line-added">+                 sb.append(prompt);</span>
<span class="line-added">+                 String line = buf.upToCursor();</span>
<span class="line-added">+                 if (maskingCallback != null) {</span>
<span class="line-added">+                     line = maskingCallback.display(line);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 concat(new AttributedString(line).columnSplitLength(Integer.MAX_VALUE), sb);</span>
<span class="line-added">+                 AttributedString toCursor = sb.toAttributedString();</span>
<span class="line-added">+ </span>
<span class="line-added">+                 int w = WCWidth.wcwidth(&#39;\u2026&#39;);</span>
<span class="line-added">+                 int width = size.getColumns();</span>
<span class="line-added">+                 int cursor = toCursor.columnLength();</span>
<span class="line-added">+                 int inc = width / 2 + 1;</span>
<span class="line-added">+                 while (cursor &lt;= smallTerminalOffset + w) {</span>
<span class="line-added">+                     smallTerminalOffset -= inc;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 while (cursor &gt;= smallTerminalOffset + width - w) {</span>
<span class="line-added">+                     smallTerminalOffset += inc;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (smallTerminalOffset &gt; 0) {</span>
<span class="line-added">+                     sb.setLength(0);</span>
<span class="line-added">+                     sb.append(&quot;\u2026&quot;);</span>
<span class="line-added">+                     sb.append(full.columnSubSequence(smallTerminalOffset + w, Integer.MAX_VALUE));</span>
<span class="line-added">+                     full = sb.toAttributedString();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 int length = full.columnLength();</span>
<span class="line-added">+                 if (length &gt;= smallTerminalOffset + width) {</span>
<span class="line-added">+                     sb.setLength(0);</span>
<span class="line-added">+                     sb.append(full.columnSubSequence(0, width - w));</span>
<span class="line-added">+                     sb.append(&quot;\u2026&quot;);</span>
<span class="line-added">+                     full = sb.toAttributedString();</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 display.update(Collections.singletonList(full), cursor - smallTerminalOffset, flush);</span>
<span class="line-added">+                 return;</span>
              }
  
<span class="line-modified">!             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!             AttributedString full = getDisplayedBufferWithPrompts(secondaryPrompts);</span>
  
<span class="line-modified">!             List&lt;AttributedString&gt; newLines;</span>
<span class="line-modified">!             if (size.getColumns() &lt;= 0) {</span>
<span class="line-modified">!                 newLines = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!                 newLines.add(full);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 newLines = full.columnSplitLength(size.getColumns(), true, display.delayLineWrap());</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             List&lt;AttributedString&gt; rightPromptLines;</span>
<span class="line-added">+             if (rightPrompt.length() == 0 || size.getColumns() &lt;= 0) {</span>
<span class="line-added">+                 rightPromptLines = new ArrayList&lt;&gt;();</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 rightPromptLines = rightPrompt.columnSplitLength(size.getColumns());</span>
              }
<span class="line-modified">!             while (newLines.size() &lt; rightPromptLines.size()) {</span>
<span class="line-modified">!                 newLines.add(new AttributedString(&quot;&quot;));</span>
              }
<span class="line-modified">!             for (int i = 0; i &lt; rightPromptLines.size(); i++) {</span>
<span class="line-modified">!                 AttributedString line = rightPromptLines.get(i);</span>
<span class="line-modified">!                 newLines.set(i, addRightPrompt(line, newLines.get(i)));</span>
              }
  
<span class="line-modified">!             int cursorPos = -1;</span>
<span class="line-modified">!             int cursorNewLinesId = -1;</span>
<span class="line-modified">!             int cursorColPos = -1;</span>
<span class="line-modified">!             if (size.getColumns() &gt; 0) {</span>
<span class="line-modified">!                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);</span>
<span class="line-modified">!                 sb.append(prompt);</span>
<span class="line-modified">!                 String buffer = buf.upToCursor();</span>
<span class="line-modified">!                 if (maskingCallback != null) {</span>
<span class="line-modified">!                     buffer = maskingCallback.display(buffer);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 sb.append(insertSecondaryPrompts(new AttributedString(buffer), secondaryPrompts, false));</span>
<span class="line-modified">!                 List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());</span>
<span class="line-modified">!                 if (!promptLines.isEmpty()) {</span>
<span class="line-modified">!                     cursorNewLinesId = promptLines.size() - 1;</span>
<span class="line-modified">!                     cursorColPos = promptLines.get(promptLines.size() - 1).columnLength();</span>
<span class="line-modified">!                     cursorPos = size.cursorPos(cursorNewLinesId, cursorColPos);</span>
<span class="line-modified">!                 }</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             List&lt;AttributedString&gt; newLinesToDisplay = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!             int displaySize = size.getRows() - (status != null ? status.size() : 0);</span>
<span class="line-modified">!             if (newLines.size() &gt; displaySize &amp;&amp; !isTerminalDumb()) {</span>
<span class="line-modified">!                 StringBuilder sb = new StringBuilder(&quot;&gt;....&quot;);</span>
<span class="line-added">+                 // blanks are needed when displaying command completion candidate list</span>
<span class="line-added">+                 for (int i = sb.toString().length(); i &lt; size.getColumns(); i++) {</span>
<span class="line-added">+                     sb.append(&quot; &quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 AttributedString partialCommandInfo = new AttributedString(sb.toString());</span>
<span class="line-added">+                 int lineId = newLines.size() - displaySize + 1;</span>
<span class="line-added">+                 int endId = displaySize;</span>
<span class="line-added">+                 int startId = 1;</span>
<span class="line-added">+                 if (lineId  &gt; cursorNewLinesId) {</span>
<span class="line-added">+                     lineId = cursorNewLinesId;</span>
<span class="line-added">+                     endId = displaySize - 1;</span>
<span class="line-added">+                     startId = 0;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     newLinesToDisplay.add(partialCommandInfo);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 int cursorRowPos = 0;</span>
<span class="line-added">+                 for (int i = startId; i &lt; endId; i++) {</span>
<span class="line-added">+                     if (cursorNewLinesId == lineId) {</span>
<span class="line-added">+                         cursorRowPos = i;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     newLinesToDisplay.add(newLines.get(lineId++));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (startId == 0) {</span>
<span class="line-added">+                     newLinesToDisplay.add(partialCommandInfo);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 cursorPos = size.cursorPos(cursorRowPos, cursorColPos);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 newLinesToDisplay = newLines;</span>
              }
<span class="line-added">+             display.update(newLinesToDisplay, cursorPos, flush);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             lock.unlock();</span>
          }
      }
  
      private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
          if (lines.size() &gt; 1) {
              for (int i = 0; i &lt; lines.size() - 1; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3654,30 ***</span>
                  int count = 0;
                  boolean countSeen = false;
                  decode: while (true) {
                      ch = pattern.charAt(i++);
                      switch (ch) {
<span class="line-modified">!                        case &#39;{&#39;:</span>
<span class="line-modified">!                        case &#39;}&#39;:</span>
<span class="line-modified">!                            String str = sb.toString();</span>
<span class="line-modified">!                            AttributedString astr;</span>
<span class="line-modified">!                            if (!isHidden) {</span>
<span class="line-modified">!                                astr = AttributedString.fromAnsi(str);</span>
<span class="line-modified">!                                cols += astr.columnLength();</span>
<span class="line-modified">!                            } else {</span>
<span class="line-modified">!                                astr = new AttributedString(str, AttributedStyle.HIDDEN);</span>
<span class="line-modified">!                            }</span>
<span class="line-modified">!                            if (padPartIndex == parts.size()) {</span>
<span class="line-modified">!                                padPartString = sb;</span>
<span class="line-modified">!                                if (i &lt; plen) {</span>
<span class="line-modified">!                                    sb = new StringBuilder();</span>
<span class="line-modified">!                                }</span>
<span class="line-modified">!                            } else {</span>
<span class="line-modified">!                                sb.setLength(0);</span>
<span class="line-modified">!                            }</span>
<span class="line-modified">!                            parts.add(astr);</span>
<span class="line-modified">!                            isHidden = ch == &#39;{&#39;;</span>
                              break decode;
                          case &#39;%&#39;:
                              sb.append(ch);
                              break decode;
                          case &#39;N&#39;:
<span class="line-new-header">--- 3839,30 ---</span>
                  int count = 0;
                  boolean countSeen = false;
                  decode: while (true) {
                      ch = pattern.charAt(i++);
                      switch (ch) {
<span class="line-modified">!                         case &#39;{&#39;:</span>
<span class="line-modified">!                         case &#39;}&#39;:</span>
<span class="line-modified">!                             String str = sb.toString();</span>
<span class="line-modified">!                             AttributedString astr;</span>
<span class="line-modified">!                             if (!isHidden) {</span>
<span class="line-modified">!                                 astr = AttributedString.fromAnsi(str);</span>
<span class="line-modified">!                                 cols += astr.columnLength();</span>
<span class="line-modified">!                             } else {</span>
<span class="line-modified">!                                 astr = new AttributedString(str, AttributedStyle.HIDDEN);</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             if (padPartIndex == parts.size()) {</span>
<span class="line-modified">!                                 padPartString = sb;</span>
<span class="line-modified">!                                 if (i &lt; plen) {</span>
<span class="line-modified">!                                     sb = new StringBuilder();</span>
<span class="line-modified">!                                 }</span>
<span class="line-modified">!                             } else {</span>
<span class="line-modified">!                                 sb.setLength(0);</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                             parts.add(astr);</span>
<span class="line-modified">!                             isHidden = ch == &#39;{&#39;;</span>
                              break decode;
                          case &#39;%&#39;:
                              sb.append(ch);
                              break decode;
                          case &#39;N&#39;:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4046,117 ***</span>
  
          // If we have no matches, bail out
          if (matching.isEmpty()) {
              return false;
          }
  
<span class="line-removed">-         // If we only need to display the list, do it now</span>
<span class="line-removed">-         if (lst == CompletionType.List) {</span>
              List&lt;Candidate&gt; possible = matching.entrySet().stream()
                      .flatMap(e -&gt; e.getValue().stream())
                      .collect(Collectors.toList());
<span class="line-modified">!             doList(possible, line.word(), false, line::escape);</span>
<span class="line-modified">!             return !possible.isEmpty();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // Check if there&#39;s a single possible match</span>
<span class="line-modified">!         Candidate completion = null;</span>
<span class="line-modified">!         // If there&#39;s a single possible completion</span>
<span class="line-modified">!         if (matching.size() == 1) {</span>
<span class="line-modified">!             completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-modified">!                     .findFirst().orElse(null);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // Or if RECOGNIZE_EXACT is set, try to find an exact match</span>
<span class="line-removed">-         else if (isSet(Option.RECOGNIZE_EXACT)) {</span>
<span class="line-removed">-             completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-removed">-                     .filter(Candidate::complete)</span>
<span class="line-removed">-                     .filter(c -&gt; exact.test(c.value()))</span>
<span class="line-removed">-                     .findFirst().orElse(null);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // Complete and exit</span>
<span class="line-removed">-         if (completion != null &amp;&amp; !completion.value().isEmpty()) {</span>
              if (prefix) {
<span class="line-modified">!                 buf.backspace(line.rawWordCursor());</span>
              } else {
                  buf.move(line.rawWordLength() - line.rawWordCursor());
<span class="line-removed">-                 buf.backspace(line.rawWordLength());</span>
              }
<span class="line-modified">!             buf.write(line.escape(completion.value(), completion.complete()));</span>
<span class="line-modified">!             if (completion.complete()) {</span>
<span class="line-modified">!                 if (buf.currChar() != &#39; &#39;) {</span>
<span class="line-modified">!                     buf.write(&quot; &quot;);</span>
<span class="line-modified">!                 } else {</span>
<span class="line-removed">-                     buf.move(1);</span>
<span class="line-removed">-                 }</span>
              }
<span class="line-modified">!             if (completion.suffix() != null) {</span>
<span class="line-modified">!                 redisplay();</span>
<span class="line-modified">!                 Binding op = readBinding(getKeys());</span>
<span class="line-modified">!                 if (op != null) {</span>
<span class="line-modified">!                     String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);</span>
<span class="line-modified">!                     String ref = op instanceof Reference ? ((Reference) op).name() : null;</span>
<span class="line-modified">!                     if (SELF_INSERT.equals(ref) &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0</span>
<span class="line-modified">!                             || ACCEPT_LINE.equals(ref)) {</span>
<span class="line-modified">!                         buf.backspace(completion.suffix().length());</span>
<span class="line-modified">!                         if (getLastBinding().charAt(0) != &#39; &#39;) {</span>
<span class="line-removed">-                             buf.write(&#39; &#39;);</span>
<span class="line-removed">-                         }</span>
                      }
<span class="line-removed">-                     pushBackBinding(true);</span>
                  }
              }
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         List&lt;Candidate&gt; possible = matching.entrySet().stream()</span>
<span class="line-removed">-                 .flatMap(e -&gt; e.getValue().stream())</span>
<span class="line-removed">-                 .collect(Collectors.toList());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (useMenu) {</span>
<span class="line-removed">-             buf.move(line.word().length() - line.wordCursor());</span>
<span class="line-removed">-             buf.backspace(line.word().length());</span>
<span class="line-removed">-             doMenu(possible, line.word(), line::escape);</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // Find current word and move to end</span>
<span class="line-removed">-         String current;</span>
<span class="line-removed">-         if (prefix) {</span>
<span class="line-removed">-             current = line.word().substring(0, line.wordCursor());</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             current = line.word();</span>
<span class="line-removed">-             buf.move(line.rawWordLength() - line.rawWordCursor());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // Now, we need to find the unambiguous completion</span>
<span class="line-removed">-         // TODO: need to find common suffix</span>
<span class="line-removed">-         String commonPrefix = null;</span>
<span class="line-removed">-         for (String key : matching.keySet()) {</span>
<span class="line-removed">-             commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (hasUnambiguous) {</span>
<span class="line-removed">-             buf.backspace(line.rawWordLength());</span>
<span class="line-removed">-             buf.write(line.escape(commonPrefix, false));</span>
<span class="line-removed">-             current = commonPrefix;</span>
<span class="line-removed">-             if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))</span>
<span class="line-removed">-                     || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {</span>
<span class="line-removed">-                 if (!nextBindingIsComplete()) {</span>
                      return true;
                  }
              }
<span class="line-modified">!         }</span>
<span class="line-modified">!         if (isSet(Option.AUTO_LIST)) {</span>
<span class="line-modified">!             if (!doList(possible, current, true, line::escape)) {</span>
<span class="line-removed">-                 return true;</span>
              }
          }
<span class="line-removed">-         if (isSet(Option.AUTO_MENU)) {</span>
<span class="line-removed">-             buf.backspace(current.length());</span>
<span class="line-removed">-             doMenu(possible, line.word(), line::escape);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return true;</span>
      }
  
      private CompletingParsedLine wrap(ParsedLine line) {
          if (line instanceof CompletingParsedLine) {
              return (CompletingParsedLine) line;
<span class="line-new-header">--- 4231,121 ---</span>
  
          // If we have no matches, bail out
          if (matching.isEmpty()) {
              return false;
          }
<span class="line-added">+         size.copy(terminal.getSize());</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             // If we only need to display the list, do it now</span>
<span class="line-added">+             if (lst == CompletionType.List) {</span>
<span class="line-added">+                 List&lt;Candidate&gt; possible = matching.entrySet().stream()</span>
<span class="line-added">+                         .flatMap(e -&gt; e.getValue().stream())</span>
<span class="line-added">+                         .collect(Collectors.toList());</span>
<span class="line-added">+                 doList(possible, line.word(), false, line::escape);</span>
<span class="line-added">+                 return !possible.isEmpty();</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Check if there&#39;s a single possible match</span>
<span class="line-added">+             Candidate completion = null;</span>
<span class="line-added">+             // If there&#39;s a single possible completion</span>
<span class="line-added">+             if (matching.size() == 1) {</span>
<span class="line-added">+                 completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-added">+                         .findFirst().orElse(null);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Or if RECOGNIZE_EXACT is set, try to find an exact match</span>
<span class="line-added">+             else if (isSet(Option.RECOGNIZE_EXACT)) {</span>
<span class="line-added">+                 completion = matching.values().stream().flatMap(Collection::stream)</span>
<span class="line-added">+                         .filter(Candidate::complete)</span>
<span class="line-added">+                         .filter(c -&gt; exact.test(c.value()))</span>
<span class="line-added">+                         .findFirst().orElse(null);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Complete and exit</span>
<span class="line-added">+             if (completion != null &amp;&amp; !completion.value().isEmpty()) {</span>
<span class="line-added">+                 if (prefix) {</span>
<span class="line-added">+                     buf.backspace(line.rawWordCursor());</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     buf.move(line.rawWordLength() - line.rawWordCursor());</span>
<span class="line-added">+                     buf.backspace(line.rawWordLength());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 buf.write(line.escape(completion.value(), completion.complete()));</span>
<span class="line-added">+                 if (completion.complete()) {</span>
<span class="line-added">+                     if (buf.currChar() != &#39; &#39;) {</span>
<span class="line-added">+                         buf.write(&quot; &quot;);</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         buf.move(1);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (completion.suffix() != null) {</span>
<span class="line-added">+                     redisplay();</span>
<span class="line-added">+                     Binding op = readBinding(getKeys());</span>
<span class="line-added">+                     if (op != null) {</span>
<span class="line-added">+                         String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);</span>
<span class="line-added">+                         String ref = op instanceof Reference ? ((Reference) op).name() : null;</span>
<span class="line-added">+                         if (SELF_INSERT.equals(ref) &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0</span>
<span class="line-added">+                                 || ACCEPT_LINE.equals(ref)) {</span>
<span class="line-added">+                             buf.backspace(completion.suffix().length());</span>
<span class="line-added">+                             if (getLastBinding().charAt(0) != &#39; &#39;) {</span>
<span class="line-added">+                                 buf.write(&#39; &#39;);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         pushBackBinding(true);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
  
              List&lt;Candidate&gt; possible = matching.entrySet().stream()
                      .flatMap(e -&gt; e.getValue().stream())
                      .collect(Collectors.toList());
<span class="line-modified">! </span>
<span class="line-modified">!             if (useMenu) {</span>
<span class="line-modified">!                 buf.move(line.word().length() - line.wordCursor());</span>
<span class="line-modified">!                 buf.backspace(line.word().length());</span>
<span class="line-modified">!                 doMenu(possible, line.word(), line::escape);</span>
<span class="line-modified">!                 return true;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // Find current word and move to end</span>
<span class="line-modified">!             String current;</span>
              if (prefix) {
<span class="line-modified">!                 current = line.word().substring(0, line.wordCursor());</span>
              } else {
<span class="line-added">+                 current = line.word();</span>
                  buf.move(line.rawWordLength() - line.rawWordCursor());
              }
<span class="line-modified">!             // Now, we need to find the unambiguous completion</span>
<span class="line-modified">!             // TODO: need to find common suffix</span>
<span class="line-modified">!             String commonPrefix = null;</span>
<span class="line-modified">!             for (String key : matching.keySet()) {</span>
<span class="line-modified">!                 commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);</span>
              }
<span class="line-modified">!             boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             if (hasUnambiguous) {</span>
<span class="line-modified">!                 buf.backspace(line.rawWordLength());</span>
<span class="line-modified">!                 buf.write(line.escape(commonPrefix, false));</span>
<span class="line-modified">!                 current = commonPrefix;</span>
<span class="line-modified">!                 if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))</span>
<span class="line-modified">!                         || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {</span>
<span class="line-modified">!                     if (!nextBindingIsComplete()) {</span>
<span class="line-modified">!                         return true;</span>
                      }
                  }
              }
<span class="line-modified">!             if (isSet(Option.AUTO_LIST)) {</span>
<span class="line-modified">!                 if (!doList(possible, current, true, line::escape)) {</span>
                      return true;
                  }
              }
<span class="line-modified">!             if (isSet(Option.AUTO_MENU)) {</span>
<span class="line-modified">!                 buf.backspace(current.length());</span>
<span class="line-modified">!                 doMenu(possible, line.word(), line::escape);</span>
              }
<span class="line-added">+             return true;</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             size.copy(terminal.getBufferSize());</span>
          }
      }
  
      private CompletingParsedLine wrap(ParsedLine line) {
          if (line instanceof CompletingParsedLine) {
              return (CompletingParsedLine) line;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4532,11 ***</span>
          int lines = postResult.lines;
          int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
          if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
                  || lines &gt;= size.getRows() - promptLines) {
              // prompt
<span class="line-modified">!             post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see to see all &quot; + possible.size()</span>
                      + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);
              redisplay(true);
              int c = readCharacter();
              if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {
                  post = null;
<span class="line-new-header">--- 4721,11 ---</span>
          int lines = postResult.lines;
          int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
          if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
                  || lines &gt;= size.getRows() - promptLines) {
              // prompt
<span class="line-modified">!             post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see all &quot; + possible.size()</span>
                      + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);
              redisplay(true);
              int c = readCharacter();
              if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {
                  post = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4584,11 ***</span>
              if (!runLoop) {
                  return false;
              }
              redisplay();
              // TODO: use a different keyMap ?
<span class="line-modified">!             Binding b = bindingReader.readBinding(getKeys());</span>
              if (b instanceof Reference) {
                  String name = ((Reference) b).name();
                  if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
                      if (sb.length() == 0) {
                          pushBackBinding();
<span class="line-new-header">--- 4773,11 ---</span>
              if (!runLoop) {
                  return false;
              }
              redisplay();
              // TODO: use a different keyMap ?
<span class="line-modified">!             Binding b = doReadBinding(getKeys(), null);</span>
              if (b instanceof Reference) {
                  String name = ((Reference) b).name();
                  if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
                      if (sb.length() == 0) {
                          pushBackBinding();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4729,11 ***</span>
          return new PostResult(sb.toAttributedString(), out[0], out[1]);
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
      protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {
<span class="line-modified">!         if (maxWidth &lt;= 0) {</span>
              return;
          }
          // This is a group
          if (items instanceof String) {
              sb.style(getCompletionStyleGroup())
<span class="line-new-header">--- 4918,11 ---</span>
          return new PostResult(sb.toAttributedString(), out[0], out[1]);
      }
  
      @SuppressWarnings(&quot;unchecked&quot;)
      protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {
<span class="line-modified">!         if (maxWidth &lt;= 0 || width &lt;= 0) {</span>
              return;
          }
          // This is a group
          if (items instanceof String) {
              sb.style(getCompletionStyleGroup())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4983,11 ***</span>
              end = start;
              while (count-- &gt; 0) {
                  while (end &lt; buf.length() &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
                      end++;
                  }
<span class="line-modified">!                 end++;</span>
              }
          }
          String killed = buf.substring(start, end);
          buf.cursor(start);
          buf.delete(end - start);
<span class="line-new-header">--- 5172,13 ---</span>
              end = start;
              while (count-- &gt; 0) {
                  while (end &lt; buf.length() &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
                      end++;
                  }
<span class="line-modified">!                 if (end &lt; buf.length()) {</span>
<span class="line-added">+                     end++;</span>
<span class="line-added">+                 }</span>
              }
          }
          String killed = buf.substring(start, end);
          buf.cursor(start);
          buf.delete(end - start);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5186,11 ***</span>
          keyMap.setNomatch(SELF_INSERT);
          keyMap.setAmbiguousTimeout(0);
          keyMap.bind(END_PASTE, BRACKETED_PASTE_END);
          StringBuilder sb = new StringBuilder();
          while (true) {
<span class="line-modified">!             Object b = bindingReader.readBinding(keyMap);</span>
              if (b == END_PASTE) {
                  break;
              }
              String s = getLastBinding();
              if (&quot;\r&quot;.equals(s)) {
<span class="line-new-header">--- 5377,11 ---</span>
          keyMap.setNomatch(SELF_INSERT);
          keyMap.setAmbiguousTimeout(0);
          keyMap.bind(END_PASTE, BRACKETED_PASTE_END);
          StringBuilder sb = new StringBuilder();
          while (true) {
<span class="line-modified">!             Object b = doReadBinding(keyMap, null);</span>
              if (b == END_PASTE) {
                  break;
              }
              String s = getLastBinding();
              if (&quot;\r&quot;.equals(s)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5225,10 ***</span>
<span class="line-new-header">--- 5416,15 ---</span>
       * Clear the screen by issuing the ANSI &quot;clear screen&quot; code.
       * @return &lt;code&gt;true&lt;/code&gt;
       */
      public boolean clearScreen() {
          if (terminal.puts(Capability.clear_screen)) {
<span class="line-added">+             // ConEMU extended fonts support</span>
<span class="line-added">+             if (AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType())</span>
<span class="line-added">+                     &amp;&amp; !Boolean.getBoolean(&quot;org.jline.terminal.conemu.disable-activate&quot;)) {</span>
<span class="line-added">+                 terminal.writer().write(&quot;\u001b[9999E&quot;);</span>
<span class="line-added">+             }</span>
              Status status = Status.getStatus(terminal, false);
              if (status != null) {
                  status.reset();
              }
              redrawLine();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5356,10 ***</span>
<span class="line-new-header">--- 5552,11 ---</span>
          return keyMaps;
      }
  
      public KeyMap&lt;Binding&gt; emacs() {
          KeyMap&lt;Binding&gt; emacs = new KeyMap&lt;&gt;();
<span class="line-added">+         bindKeys(emacs);</span>
          bind(emacs, SET_MARK_COMMAND,                       ctrl(&#39;@&#39;));
          bind(emacs, BEGINNING_OF_LINE,                      ctrl(&#39;A&#39;));
          bind(emacs, BACKWARD_CHAR,                          ctrl(&#39;B&#39;));
          bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl(&#39;D&#39;));
          bind(emacs, END_OF_LINE,                            ctrl(&#39;E&#39;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5370,10 ***</span>
<span class="line-new-header">--- 5567,11 ---</span>
          bind(emacs, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
          bind(emacs, KILL_LINE,                              ctrl(&#39;K&#39;));
          bind(emacs, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
          bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
          bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));
<span class="line-added">+         bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl(&#39;O&#39;));</span>
          bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
          bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
          bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
          bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
          bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5413,10 ***</span>
<span class="line-new-header">--- 5611,11 ---</span>
          bind(emacs, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
          bind(emacs, LIST_CHOICES,                           alt(&#39;=&#39;));
          bind(emacs, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
          bind(emacs, LIST_CHOICES,                           alt(&#39;?&#39;));
          bind(emacs, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
<span class="line-added">+         bind(emacs, ACCEPT_AND_HOLD,                        alt(&#39;a&#39;));</span>
          bind(emacs, BACKWARD_WORD,                          alt(&#39;b&#39;));
          bind(emacs, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
          bind(emacs, KILL_WORD,                              alt(&#39;d&#39;));
          bind(emacs, KILL_WORD,                              translate(&quot;^[[3;5~&quot;)); // ctrl-delete
          bind(emacs, FORWARD_WORD,                           alt(&#39;f&#39;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5437,10 ***</span>
<span class="line-new-header">--- 5636,11 ---</span>
          return emacs;
      }
  
      public KeyMap&lt;Binding&gt; viInsertion() {
          KeyMap&lt;Binding&gt; viins = new KeyMap&lt;&gt;();
<span class="line-added">+         bindKeys(viins);</span>
          bind(viins, SELF_INSERT,                            range(&quot;^@-^_&quot;));
          bind(viins, LIST_CHOICES,                           ctrl(&#39;D&#39;));
          bind(viins, SEND_BREAK,                             ctrl(&#39;G&#39;));
          bind(viins, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
          bind(viins, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5636,10 ***</span>
<span class="line-new-header">--- 5836,18 ---</span>
  
      private String key(Capability capability) {
          return KeyMap.key(terminal, capability);
      }
  
<span class="line-added">+     private void bindKeys(KeyMap&lt;Binding&gt; emacs) {</span>
<span class="line-added">+         Widget beep = namedWidget(&quot;beep&quot;, this::beep);</span>
<span class="line-added">+         Stream.of(Capability.values())</span>
<span class="line-added">+                 .filter(c -&gt; c.name().startsWith(&quot;key_&quot;))</span>
<span class="line-added">+                 .map(this::key)</span>
<span class="line-added">+                 .forEach(k -&gt; bind(emacs, beep, k));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      private void bindArrowKeys(KeyMap&lt;Binding&gt; map) {
          bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));
          bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));
          bind(map, BACKWARD_CHAR,        key(Capability.key_left));
          bind(map, FORWARD_CHAR,         key(Capability.key_right));
</pre>
<center><a href="KillRing.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ReaderUtils.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
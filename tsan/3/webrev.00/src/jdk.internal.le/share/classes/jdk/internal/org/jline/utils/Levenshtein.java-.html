<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/Levenshtein.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.HashMap;
 12 import java.util.Map;
 13 
 14 /**
 15  * The Damerau-Levenshtein Algorithm is an extension to the Levenshtein
 16  * Algorithm which solves the edit distance problem between a source string and
 17  * a target string with the following operations:
 18  *
 19  * &lt;ul&gt;
 20  * &lt;li&gt;Character Insertion&lt;/li&gt;
 21  * &lt;li&gt;Character Deletion&lt;/li&gt;
 22  * &lt;li&gt;Character Replacement&lt;/li&gt;
 23  * &lt;li&gt;Adjacent Character Swap&lt;/li&gt;
 24  * &lt;/ul&gt;
 25  *
 26  * Note that the adjacent character swap operation is an edit that may be
 27  * applied when two adjacent characters in the source string match two adjacent
 28  * characters in the target string, but in reverse order, rather than a general
 29  * allowance for adjacent character swaps.
 30  * &lt;p&gt;
 31  *
 32  * This implementation allows the client to specify the costs of the various
 33  * edit operations with the restriction that the cost of two swap operations
 34  * must not be less than the cost of a delete operation followed by an insert
 35  * operation. This restriction is required to preclude two swaps involving the
 36  * same character being required for optimality which, in turn, enables a fast
 37  * dynamic programming solution.
 38  * &lt;p&gt;
 39  *
 40  * The running time of the Damerau-Levenshtein algorithm is O(n*m) where n is
 41  * the length of the source string and m is the length of the target string.
 42  * This implementation consumes O(n*m) space.
 43  *
 44  * @author Kevin L. Stern
 45  */
 46 public class Levenshtein {
 47 
 48     public static int distance(CharSequence lhs, CharSequence rhs) {
 49         return distance(lhs, rhs, 1, 1, 1, 1);
 50     }
 51 
 52     public static int distance(CharSequence source, CharSequence target,
 53                                int deleteCost, int insertCost,
 54                                int replaceCost, int swapCost) {
 55         /*
 56          * Required to facilitate the premise to the algorithm that two swaps of the
 57          * same character are never required for optimality.
 58          */
 59         if (2 * swapCost &lt; insertCost + deleteCost) {
 60             throw new IllegalArgumentException(&quot;Unsupported cost assignment&quot;);
 61         }
 62         if (source.length() == 0) {
 63             return target.length() * insertCost;
 64         }
 65         if (target.length() == 0) {
 66             return source.length() * deleteCost;
 67         }
 68         int[][] table = new int[source.length()][target.length()];
 69         Map&lt;Character, Integer&gt; sourceIndexByCharacter = new HashMap&lt;&gt;();
 70         if (source.charAt(0) != target.charAt(0)) {
 71             table[0][0] = Math.min(replaceCost, deleteCost + insertCost);
 72         }
 73         sourceIndexByCharacter.put(source.charAt(0), 0);
 74         for (int i = 1; i &lt; source.length(); i++) {
 75             int deleteDistance = table[i - 1][0] + deleteCost;
 76             int insertDistance = (i + 1) * deleteCost + insertCost;
 77             int matchDistance = i * deleteCost + (source.charAt(i) == target.charAt(0) ? 0 : replaceCost);
 78             table[i][0] = Math.min(Math.min(deleteDistance, insertDistance), matchDistance);
 79         }
 80         for (int j = 1; j &lt; target.length(); j++) {
 81             int deleteDistance = (j + 1) * insertCost + deleteCost;
 82             int insertDistance = table[0][j - 1] + insertCost;
 83             int matchDistance = j * insertCost + (source.charAt(0) == target.charAt(j) ? 0 : replaceCost);
 84             table[0][j] = Math.min(Math.min(deleteDistance, insertDistance), matchDistance);
 85         }
 86         for (int i = 1; i &lt; source.length(); i++) {
 87             int maxSourceLetterMatchIndex = source.charAt(i) == target.charAt(0) ? 0 : -1;
 88             for (int j = 1; j &lt; target.length(); j++) {
 89                 Integer candidateSwapIndex = sourceIndexByCharacter.get(target.charAt(j));
 90                 int jSwap = maxSourceLetterMatchIndex;
 91                 int deleteDistance = table[i - 1][j] + deleteCost;
 92                 int insertDistance = table[i][j - 1] + insertCost;
 93                 int matchDistance = table[i - 1][j - 1];
 94                 if (source.charAt(i) != target.charAt(j)) {
 95                     matchDistance += replaceCost;
 96                 } else {
 97                     maxSourceLetterMatchIndex = j;
 98                 }
 99                 int swapDistance;
100                 if (candidateSwapIndex != null &amp;&amp; jSwap != -1) {
101                     int iSwap = candidateSwapIndex;
102                     int preSwapCost;
103                     if (iSwap == 0 &amp;&amp; jSwap == 0) {
104                         preSwapCost = 0;
105                     } else {
106                         preSwapCost = table[Math.max(0, iSwap - 1)][Math.max(0, jSwap - 1)];
107                     }
108                     swapDistance = preSwapCost + (i - iSwap - 1) * deleteCost + (j - jSwap - 1) * insertCost + swapCost;
109                 } else {
110                     swapDistance = Integer.MAX_VALUE;
111                 }
112                 table[i][j] = Math.min(Math.min(Math.min(deleteDistance, insertDistance), matchDistance), swapDistance);
113             }
114             sourceIndexByCharacter.put(source.charAt(i), i);
115         }
116         return table[source.length() - 1][target.length() - 1];
117     }
118 
119 }
    </pre>
  </body>
</html>
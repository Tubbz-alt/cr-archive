<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/windows/classes/jdk/internal/org/jline/terminal/impl/jna/win/JnaWinSysTerminal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2002-2018, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<a name="2" id="anc2"></a><span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.terminal.impl.jna.win;
 10 
 11 import java.io.BufferedWriter;
 12 import java.io.IOException;
 13 import java.io.InputStream;
 14 import java.io.Writer;
 15 import java.nio.charset.Charset;
 16 import java.util.function.Function;
 17 import java.util.function.IntConsumer;
 18 
 19 //import com.sun.jna.LastErrorException;
 20 //import com.sun.jna.Pointer;
 21 //import com.sun.jna.ptr.IntByReference;
 22 
 23 import jdk.internal.org.jline.terminal.Cursor;
 24 import jdk.internal.org.jline.terminal.Size;
 25 import jdk.internal.org.jline.terminal.Terminal;
 26 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
 27 import jdk.internal.org.jline.utils.InfoCmp;
 28 import jdk.internal.org.jline.utils.OSUtils;
 29 
 30 public class JnaWinSysTerminal extends AbstractWindowsTerminal {
 31 
 32     private static final Pointer consoleIn = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_INPUT_HANDLE);
 33     private static final Pointer consoleOut = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);
 34 
 35     public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, boolean paused, Function&lt;InputStream, InputStream&gt; inputStreamWrapper) throws IOException {
 36         Writer writer;
 37         if (ansiPassThrough) {
 38             if (type == null) {
<a name="3" id="anc3"></a><span class="line-modified"> 39                 type = OSUtils.IS_CONEMU ? TYPE_WINDOWS_256_COLOR : TYPE_WINDOWS;</span>
 40             }
 41             writer = new JnaWinConsoleWriter(consoleOut);
 42         } else {
 43             IntByReference mode = new IntByReference();
 44             Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);
 45             try {
 46                 Kernel32.INSTANCE.SetConsoleMode(consoleOut, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);
 47                 if (type == null) {
 48                     type = TYPE_WINDOWS_VTP;
 49                 }
 50                 writer = new JnaWinConsoleWriter(consoleOut);
 51             } catch (LastErrorException e) {
 52                 if (OSUtils.IS_CONEMU) {
 53                     if (type == null) {
<a name="4" id="anc4"></a><span class="line-modified"> 54                         type = TYPE_WINDOWS_256_COLOR;</span>
 55                     }
 56                     writer = new JnaWinConsoleWriter(consoleOut);
 57                 } else {
 58                     if (type == null) {
 59                         type = TYPE_WINDOWS;
 60                     }
 61                     writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(consoleOut)), consoleOut);
 62                 }
 63             }
 64         }
 65         JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);
 66         // Start input pump thread
 67         if (!paused) {
 68             terminal.resume();
 69         }
 70         return terminal;
 71     }
 72 
 73     JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function&lt;InputStream, InputStream&gt; inputStreamWrapper) throws IOException {
 74         super(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);
 75         strings.put(InfoCmp.Capability.key_mouse, &quot;\\E[M&quot;);
 76     }
 77 
 78     @Override
 79     protected int getConsoleOutputCP() {
 80         return Kernel32.INSTANCE.GetConsoleOutputCP();
 81     }
 82 
 83     @Override
 84     protected int getConsoleMode() {
 85         IntByReference mode = new IntByReference();
 86         Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);
 87         return mode.getValue();
 88     }
 89 
 90     @Override
 91     protected void setConsoleMode(int mode) {
 92         Kernel32.INSTANCE.SetConsoleMode(consoleIn, mode);
 93     }
 94 
 95     public Size getSize() {
<a name="5" id="anc5"></a>





 96         Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();
 97         Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);
 98         return new Size(info.dwSize.X, info.dwSize.Y);
 99     }
100 
101     protected boolean processConsoleInput() throws IOException {
102         Kernel32.INPUT_RECORD event = readConsoleInput(100);
103         if (event == null) {
104             return false;
105         }
106 
107         switch (event.EventType) {
108             case Kernel32.INPUT_RECORD.KEY_EVENT:
109                 processKeyEvent(event.Event.KeyEvent);
110                 return true;
111             case Kernel32.INPUT_RECORD.WINDOW_BUFFER_SIZE_EVENT:
112                 raise(Signal.WINCH);
113                 return false;
114             case Kernel32.INPUT_RECORD.MOUSE_EVENT:
115                 processMouseEvent(event.Event.MouseEvent);
116                 return true;
117             case Kernel32.INPUT_RECORD.FOCUS_EVENT:
118                 processFocusEvent(event.Event.FocusEvent.bSetFocus);
119                 return true;
120             default:
121                 // Skip event
122                 return false;
123         }
124     }
125 
126     private void processKeyEvent(Kernel32.KEY_EVENT_RECORD keyEvent) throws IOException {
127         processKeyEvent(keyEvent.bKeyDown, keyEvent.wVirtualKeyCode, keyEvent.uChar.UnicodeChar, keyEvent.dwControlKeyState);
128     }
129 
130     private char[] focus = new char[] { &#39;\033&#39;, &#39;[&#39;, &#39; &#39; };
131 
132     private void processFocusEvent(boolean hasFocus) throws IOException {
133         if (focusTracking) {
134             focus[2] = hasFocus ? &#39;I&#39; : &#39;O&#39;;
135             slaveInputPipe.write(focus);
136         }
137     }
138 
139     private char[] mouse = new char[] { &#39;\033&#39;, &#39;[&#39;, &#39;M&#39;, &#39; &#39;, &#39; &#39;, &#39; &#39; };
140 
141     private void processMouseEvent(Kernel32.MOUSE_EVENT_RECORD mouseEvent) throws IOException {
142         int dwEventFlags = mouseEvent.dwEventFlags;
143         int dwButtonState = mouseEvent.dwButtonState;
144         if (tracking == MouseTracking.Off
145                 || tracking == MouseTracking.Normal &amp;&amp; dwEventFlags == Kernel32.MOUSE_MOVED
146                 || tracking == MouseTracking.Button &amp;&amp; dwEventFlags == Kernel32.MOUSE_MOVED &amp;&amp; dwButtonState == 0) {
147             return;
148         }
149         int cb = 0;
150         dwEventFlags &amp;= ~ Kernel32.DOUBLE_CLICK; // Treat double-clicks as normal
151         if (dwEventFlags == Kernel32.MOUSE_WHEELED) {
152             cb |= 64;
153             if ((dwButtonState &gt;&gt; 16) &lt; 0) {
154                 cb |= 1;
155             }
156         } else if (dwEventFlags == Kernel32.MOUSE_HWHEELED) {
157             return;
158         } else if ((dwButtonState &amp; Kernel32.FROM_LEFT_1ST_BUTTON_PRESSED) != 0) {
159             cb |= 0x00;
160         } else if ((dwButtonState &amp; Kernel32.RIGHTMOST_BUTTON_PRESSED) != 0) {
161             cb |= 0x01;
162         } else if ((dwButtonState &amp; Kernel32.FROM_LEFT_2ND_BUTTON_PRESSED) != 0) {
163             cb |= 0x02;
164         } else {
165             cb |= 0x03;
166         }
167         int cx = mouseEvent.dwMousePosition.X;
168         int cy = mouseEvent.dwMousePosition.Y;
169         mouse[3] = (char) (&#39; &#39; + cb);
170         mouse[4] = (char) (&#39; &#39; + cx + 1);
171         mouse[5] = (char) (&#39; &#39; + cy + 1);
172         slaveInputPipe.write(mouse);
173     }
174 
175     private final Kernel32.INPUT_RECORD[] inputEvents = new Kernel32.INPUT_RECORD[1];
176     private final IntByReference eventsRead = new IntByReference();
177 
178     private Kernel32.INPUT_RECORD readConsoleInput(int dwMilliseconds) throws IOException {
179         if (Kernel32.INSTANCE.WaitForSingleObject(consoleIn, dwMilliseconds) != 0) {
180             return null;
181         }
182         Kernel32.INSTANCE.ReadConsoleInput(consoleIn, inputEvents, 1, eventsRead);
183         if (eventsRead.getValue() == 1) {
184             return inputEvents[0];
185         } else {
186             return null;
187         }
188     }
189 
190     @Override
191     public Cursor getCursorPosition(IntConsumer discarded) {
192         Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();
193         Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);
194         return new Cursor(info.dwCursorPosition.X, info.dwCursorPosition.Y);
195     }
196 
197 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
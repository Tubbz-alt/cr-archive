<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/windows/classes/jdk/internal/org/jline/terminal/impl/jna/win/JnaWinSysTerminal.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JnaWinConsoleWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="Kernel32.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/windows/classes/jdk/internal/org/jline/terminal/impl/jna/win/JnaWinSysTerminal.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002-2018, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * http://www.opensource.org/licenses/bsd-license.php</span>
  8  */
  9 package jdk.internal.org.jline.terminal.impl.jna.win;
 10 
 11 import java.io.BufferedWriter;
 12 import java.io.IOException;
 13 import java.io.InputStream;
 14 import java.io.Writer;
 15 import java.nio.charset.Charset;
 16 import java.util.function.Function;
 17 import java.util.function.IntConsumer;
 18 
 19 //import com.sun.jna.LastErrorException;
 20 //import com.sun.jna.Pointer;
 21 //import com.sun.jna.ptr.IntByReference;
 22 
 23 import jdk.internal.org.jline.terminal.Cursor;
 24 import jdk.internal.org.jline.terminal.Size;
 25 import jdk.internal.org.jline.terminal.Terminal;
 26 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
 27 import jdk.internal.org.jline.utils.InfoCmp;
 28 import jdk.internal.org.jline.utils.OSUtils;
 29 
 30 public class JnaWinSysTerminal extends AbstractWindowsTerminal {
 31 
 32     private static final Pointer consoleIn = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_INPUT_HANDLE);
 33     private static final Pointer consoleOut = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);
 34 
 35     public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, boolean paused, Function&lt;InputStream, InputStream&gt; inputStreamWrapper) throws IOException {
 36         Writer writer;
 37         if (ansiPassThrough) {
 38             if (type == null) {
<span class="line-modified"> 39                 type = OSUtils.IS_CONEMU ? TYPE_WINDOWS_256_COLOR : TYPE_WINDOWS;</span>
 40             }
 41             writer = new JnaWinConsoleWriter(consoleOut);
 42         } else {
 43             IntByReference mode = new IntByReference();
 44             Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);
 45             try {
 46                 Kernel32.INSTANCE.SetConsoleMode(consoleOut, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);
 47                 if (type == null) {
 48                     type = TYPE_WINDOWS_VTP;
 49                 }
 50                 writer = new JnaWinConsoleWriter(consoleOut);
 51             } catch (LastErrorException e) {
 52                 if (OSUtils.IS_CONEMU) {
 53                     if (type == null) {
<span class="line-modified"> 54                         type = TYPE_WINDOWS_256_COLOR;</span>
 55                     }
 56                     writer = new JnaWinConsoleWriter(consoleOut);
 57                 } else {
 58                     if (type == null) {
 59                         type = TYPE_WINDOWS;
 60                     }
 61                     writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(consoleOut)), consoleOut);
 62                 }
 63             }
 64         }
 65         JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);
 66         // Start input pump thread
 67         if (!paused) {
 68             terminal.resume();
 69         }
 70         return terminal;
 71     }
 72 
 73     JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function&lt;InputStream, InputStream&gt; inputStreamWrapper) throws IOException {
 74         super(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);
</pre>
<hr />
<pre>
 76     }
 77 
 78     @Override
 79     protected int getConsoleOutputCP() {
 80         return Kernel32.INSTANCE.GetConsoleOutputCP();
 81     }
 82 
 83     @Override
 84     protected int getConsoleMode() {
 85         IntByReference mode = new IntByReference();
 86         Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);
 87         return mode.getValue();
 88     }
 89 
 90     @Override
 91     protected void setConsoleMode(int mode) {
 92         Kernel32.INSTANCE.SetConsoleMode(consoleIn, mode);
 93     }
 94 
 95     public Size getSize() {






 96         Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();
 97         Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);
 98         return new Size(info.dwSize.X, info.dwSize.Y);
 99     }
100 
101     protected boolean processConsoleInput() throws IOException {
102         Kernel32.INPUT_RECORD event = readConsoleInput(100);
103         if (event == null) {
104             return false;
105         }
106 
107         switch (event.EventType) {
108             case Kernel32.INPUT_RECORD.KEY_EVENT:
109                 processKeyEvent(event.Event.KeyEvent);
110                 return true;
111             case Kernel32.INPUT_RECORD.WINDOW_BUFFER_SIZE_EVENT:
112                 raise(Signal.WINCH);
113                 return false;
114             case Kernel32.INPUT_RECORD.MOUSE_EVENT:
115                 processMouseEvent(event.Event.MouseEvent);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002-2019, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
<span class="line-modified">  7  * https://opensource.org/licenses/BSD-3-Clause</span>
  8  */
  9 package jdk.internal.org.jline.terminal.impl.jna.win;
 10 
 11 import java.io.BufferedWriter;
 12 import java.io.IOException;
 13 import java.io.InputStream;
 14 import java.io.Writer;
 15 import java.nio.charset.Charset;
 16 import java.util.function.Function;
 17 import java.util.function.IntConsumer;
 18 
 19 //import com.sun.jna.LastErrorException;
 20 //import com.sun.jna.Pointer;
 21 //import com.sun.jna.ptr.IntByReference;
 22 
 23 import jdk.internal.org.jline.terminal.Cursor;
 24 import jdk.internal.org.jline.terminal.Size;
 25 import jdk.internal.org.jline.terminal.Terminal;
 26 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
 27 import jdk.internal.org.jline.utils.InfoCmp;
 28 import jdk.internal.org.jline.utils.OSUtils;
 29 
 30 public class JnaWinSysTerminal extends AbstractWindowsTerminal {
 31 
 32     private static final Pointer consoleIn = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_INPUT_HANDLE);
 33     private static final Pointer consoleOut = Kernel32.INSTANCE.GetStdHandle(Kernel32.STD_OUTPUT_HANDLE);
 34 
 35     public static JnaWinSysTerminal createTerminal(String name, String type, boolean ansiPassThrough, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, boolean paused, Function&lt;InputStream, InputStream&gt; inputStreamWrapper) throws IOException {
 36         Writer writer;
 37         if (ansiPassThrough) {
 38             if (type == null) {
<span class="line-modified"> 39                 type = OSUtils.IS_CONEMU ? TYPE_WINDOWS_CONEMU : TYPE_WINDOWS;</span>
 40             }
 41             writer = new JnaWinConsoleWriter(consoleOut);
 42         } else {
 43             IntByReference mode = new IntByReference();
 44             Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);
 45             try {
 46                 Kernel32.INSTANCE.SetConsoleMode(consoleOut, mode.getValue() | AbstractWindowsTerminal.ENABLE_VIRTUAL_TERMINAL_PROCESSING);
 47                 if (type == null) {
 48                     type = TYPE_WINDOWS_VTP;
 49                 }
 50                 writer = new JnaWinConsoleWriter(consoleOut);
 51             } catch (LastErrorException e) {
 52                 if (OSUtils.IS_CONEMU) {
 53                     if (type == null) {
<span class="line-modified"> 54                         type = TYPE_WINDOWS_CONEMU;</span>
 55                     }
 56                     writer = new JnaWinConsoleWriter(consoleOut);
 57                 } else {
 58                     if (type == null) {
 59                         type = TYPE_WINDOWS;
 60                     }
 61                     writer = new WindowsAnsiWriter(new BufferedWriter(new JnaWinConsoleWriter(consoleOut)), consoleOut);
 62                 }
 63             }
 64         }
 65         JnaWinSysTerminal terminal = new JnaWinSysTerminal(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);
 66         // Start input pump thread
 67         if (!paused) {
 68             terminal.resume();
 69         }
 70         return terminal;
 71     }
 72 
 73     JnaWinSysTerminal(Writer writer, String name, String type, Charset encoding, int codepage, boolean nativeSignals, SignalHandler signalHandler, Function&lt;InputStream, InputStream&gt; inputStreamWrapper) throws IOException {
 74         super(writer, name, type, encoding, codepage, nativeSignals, signalHandler, inputStreamWrapper);
</pre>
<hr />
<pre>
 76     }
 77 
 78     @Override
 79     protected int getConsoleOutputCP() {
 80         return Kernel32.INSTANCE.GetConsoleOutputCP();
 81     }
 82 
 83     @Override
 84     protected int getConsoleMode() {
 85         IntByReference mode = new IntByReference();
 86         Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);
 87         return mode.getValue();
 88     }
 89 
 90     @Override
 91     protected void setConsoleMode(int mode) {
 92         Kernel32.INSTANCE.SetConsoleMode(consoleIn, mode);
 93     }
 94 
 95     public Size getSize() {
<span class="line-added"> 96         Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();</span>
<span class="line-added"> 97         Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);</span>
<span class="line-added"> 98         return new Size(info.windowWidth(), info.windowHeight());</span>
<span class="line-added"> 99     }</span>
<span class="line-added">100 </span>
<span class="line-added">101     public Size getBufferSize() {</span>
102         Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();
103         Kernel32.INSTANCE.GetConsoleScreenBufferInfo(consoleOut, info);
104         return new Size(info.dwSize.X, info.dwSize.Y);
105     }
106 
107     protected boolean processConsoleInput() throws IOException {
108         Kernel32.INPUT_RECORD event = readConsoleInput(100);
109         if (event == null) {
110             return false;
111         }
112 
113         switch (event.EventType) {
114             case Kernel32.INPUT_RECORD.KEY_EVENT:
115                 processKeyEvent(event.Event.KeyEvent);
116                 return true;
117             case Kernel32.INPUT_RECORD.WINDOW_BUFFER_SIZE_EVENT:
118                 raise(Signal.WINCH);
119                 return false;
120             case Kernel32.INPUT_RECORD.MOUSE_EVENT:
121                 processMouseEvent(event.Event.MouseEvent);
</pre>
</td>
</tr>
</table>
<center><a href="JnaWinConsoleWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="Kernel32.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
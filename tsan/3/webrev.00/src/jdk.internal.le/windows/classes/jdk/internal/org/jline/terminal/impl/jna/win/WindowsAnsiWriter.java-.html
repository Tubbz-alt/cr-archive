<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/windows/classes/jdk/internal/org/jline/terminal/impl/jna/win/WindowsAnsiWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002-2016, the original author or authors.
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * http://www.opensource.org/licenses/bsd-license.php
  8  */
  9 package jdk.internal.org.jline.terminal.impl.jna.win;
 10 
 11 import java.io.IOException;
 12 import java.io.Writer;
 13 
 14 //import com.sun.jna.Pointer;
 15 //import com.sun.jna.ptr.IntByReference;
 16 import jdk.internal.org.jline.utils.AnsiWriter;
 17 import jdk.internal.org.jline.utils.Colors;
 18 
 19 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_BLUE;
 20 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_GREEN;
 21 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_INTENSITY;
 22 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.BACKGROUND_RED;
 23 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_BLUE;
 24 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_GREEN;
 25 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_INTENSITY;
 26 import static jdk.internal.org.jline.terminal.impl.jna.win.Kernel32.FOREGROUND_RED;
 27 
 28 
 29 /**
 30  * A Windows ANSI escape processor, uses JNA to access native platform
 31  * API&#39;s to change the console attributes.
 32  *
 33  * @since 1.0
 34  * @author &lt;a href=&quot;http://hiramchirino.com&quot;&gt;Hiram Chirino&lt;/a&gt;
 35  * @author Joris Kuipers
 36  */
 37 public final class WindowsAnsiWriter extends AnsiWriter {
 38 
 39     private static final short FOREGROUND_BLACK   = 0;
 40     private static final short FOREGROUND_YELLOW  = (short) (FOREGROUND_RED|FOREGROUND_GREEN);
 41     private static final short FOREGROUND_MAGENTA = (short) (FOREGROUND_BLUE|FOREGROUND_RED);
 42     private static final short FOREGROUND_CYAN    = (short) (FOREGROUND_BLUE|FOREGROUND_GREEN);
 43     private static final short FOREGROUND_WHITE   = (short) (FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);
 44 
 45     private static final short BACKGROUND_BLACK   = 0;
 46     private static final short BACKGROUND_YELLOW  = (short) (BACKGROUND_RED|BACKGROUND_GREEN);
 47     private static final short BACKGROUND_MAGENTA = (short) (BACKGROUND_BLUE|BACKGROUND_RED);
 48     private static final short BACKGROUND_CYAN    = (short) (BACKGROUND_BLUE|BACKGROUND_GREEN);
 49     private static final short BACKGROUND_WHITE   = (short) (BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE);
 50 
 51     private static final short ANSI_FOREGROUND_COLOR_MAP[] = {
 52             FOREGROUND_BLACK,
 53             FOREGROUND_RED,
 54             FOREGROUND_GREEN,
 55             FOREGROUND_YELLOW,
 56             FOREGROUND_BLUE,
 57             FOREGROUND_MAGENTA,
 58             FOREGROUND_CYAN,
 59             FOREGROUND_WHITE,
 60     };
 61 
 62     private static final short ANSI_BACKGROUND_COLOR_MAP[] = {
 63             BACKGROUND_BLACK,
 64             BACKGROUND_RED,
 65             BACKGROUND_GREEN,
 66             BACKGROUND_YELLOW,
 67             BACKGROUND_BLUE,
 68             BACKGROUND_MAGENTA,
 69             BACKGROUND_CYAN,
 70             BACKGROUND_WHITE,
 71     };
 72 
 73     private final static int MAX_ESCAPE_SEQUENCE_LENGTH = 100;
 74 
 75     private final Pointer console;
 76 
 77     private final Kernel32.CONSOLE_SCREEN_BUFFER_INFO info = new Kernel32.CONSOLE_SCREEN_BUFFER_INFO();
 78     private final short originalColors;
 79 
 80     private boolean negative;
 81     private boolean bold;
 82     private boolean underline;
 83     private short savedX = -1;
 84     private short savedY = -1;
 85 
 86     public WindowsAnsiWriter(Writer out, Pointer console) throws IOException {
 87         super(out);
 88         this.console = console;
 89         getConsoleInfo();
 90         originalColors = info.wAttributes;
 91     }
 92 
 93     private void getConsoleInfo() throws IOException {
 94         out.flush();
 95         Kernel32.INSTANCE.GetConsoleScreenBufferInfo(console, info);
 96         if( negative ) {
 97             info.wAttributes = invertAttributeColors(info.wAttributes);
 98         }
 99     }
100 
101     private void applyAttribute() throws IOException {
102         out.flush();
103         short attributes = info.wAttributes;
104         // bold is simulated by high foreground intensity
105         if (bold) {
106             attributes |= FOREGROUND_INTENSITY;
107         }
108         // underline is simulated by high foreground intensity
109         if (underline) {
110             attributes |= BACKGROUND_INTENSITY;
111         }
112         if( negative ) {
113             attributes = invertAttributeColors(attributes);
114         }
115         Kernel32.INSTANCE.SetConsoleTextAttribute(console, attributes);
116     }
117 
118     private short invertAttributeColors(short attributes) {
119         // Swap the the Foreground and Background bits.
120         int fg = 0x000F &amp; attributes;
121         fg &lt;&lt;= 4;
122         int bg = 0X00F0 &amp; attributes;
123         bg &gt;&gt;= 4;
124         attributes = (short) ((attributes &amp; 0xFF00) | fg | bg);
125         return attributes;
126     }
127 
128     private void applyCursorPosition() throws IOException {
129         info.dwCursorPosition.X = (short) Math.max(0, Math.min(info.dwSize.X - 1, info.dwCursorPosition.X));
130         info.dwCursorPosition.Y = (short) Math.max(0, Math.min(info.dwSize.Y - 1, info.dwCursorPosition.Y));
131         Kernel32.INSTANCE.SetConsoleCursorPosition(console, info.dwCursorPosition);
132     }
133 
134     protected void processEraseScreen(int eraseOption) throws IOException {
135         getConsoleInfo();
136         IntByReference written = new IntByReference();
137         switch(eraseOption) {
138             case ERASE_SCREEN:
139                 Kernel32.COORD topLeft = new Kernel32.COORD();
140                 topLeft.X = 0;
141                 topLeft.Y = info.srWindow.Top;
142                 int screenLength = info.srWindow.height() * info.dwSize.X;
143                 Kernel32.INSTANCE.FillConsoleOutputCharacter(console, &#39; &#39;, screenLength, topLeft, written);
144                 Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, screenLength, topLeft, written);
145                 break;
146             case ERASE_SCREEN_TO_BEGINING:
147                 Kernel32.COORD topLeft2 = new Kernel32.COORD();
148                 topLeft2.X = 0;
149                 topLeft2.Y = info.srWindow.Top;
150                 int lengthToCursor = (info.dwCursorPosition.Y - info.srWindow.Top) * info.dwSize.X + info.dwCursorPosition.X;
151                 Kernel32.INSTANCE.FillConsoleOutputCharacter(console, &#39; &#39;, lengthToCursor, topLeft2, written);
152                 Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToCursor, topLeft2, written);
153                 break;
154             case ERASE_SCREEN_TO_END:
155                 int lengthToEnd = (info.srWindow.Bottom - info.dwCursorPosition.Y) * info.dwSize.X +
156                         (info.dwSize.X - info.dwCursorPosition.X);
157                 Kernel32.INSTANCE.FillConsoleOutputCharacter(console, &#39; &#39;, lengthToEnd, info.dwCursorPosition, written);
158                 Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToEnd, info.dwCursorPosition, written);
159         }
160     }
161 
162     protected void processEraseLine(int eraseOption) throws IOException {
163         getConsoleInfo();
164         IntByReference written = new IntByReference();
165         switch(eraseOption) {
166             case ERASE_LINE:
167                 Kernel32.COORD leftColCurrRow = new Kernel32.COORD((short) 0, info.dwCursorPosition.Y);
168                 Kernel32.INSTANCE.FillConsoleOutputCharacter(console, &#39; &#39;, info.dwSize.X, leftColCurrRow, written);
169                 Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, info.dwSize.X, leftColCurrRow, written);
170                 break;
171             case ERASE_LINE_TO_BEGINING:
172                 Kernel32.COORD leftColCurrRow2 = new Kernel32.COORD((short) 0, info.dwCursorPosition.Y);
173                 Kernel32.INSTANCE.FillConsoleOutputCharacter(console, &#39; &#39;, info.dwCursorPosition.X, leftColCurrRow2, written);
174                 Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, info.dwCursorPosition.X, leftColCurrRow2, written);
175                 break;
176             case ERASE_LINE_TO_END:
177                 int lengthToLastCol = info.dwSize.X - info.dwCursorPosition.X;
178                 Kernel32.INSTANCE.FillConsoleOutputCharacter(console, &#39; &#39;, lengthToLastCol, info.dwCursorPosition, written);
179                 Kernel32.INSTANCE.FillConsoleOutputAttribute(console, info.wAttributes, lengthToLastCol, info.dwCursorPosition, written);
180         }
181     }
182 
183     protected void processCursorUpLine(int count) throws IOException {
184         getConsoleInfo();
185         info.dwCursorPosition.X = 0;
186         info.dwCursorPosition.Y -= count;
187         applyCursorPosition();
188     }
189 
190     protected void processCursorDownLine(int count) throws IOException {
191         getConsoleInfo();
192         info.dwCursorPosition.X = 0;
193         info.dwCursorPosition.Y += count;
194         applyCursorPosition();
195     }
196 
197     protected void processCursorLeft(int count) throws IOException {
198         getConsoleInfo();
199         info.dwCursorPosition.X -= count;
200         applyCursorPosition();
201     }
202 
203     protected void processCursorRight(int count) throws IOException {
204         getConsoleInfo();
205         info.dwCursorPosition.X += count;
206         applyCursorPosition();
207     }
208 
209     protected void processCursorDown(int count) throws IOException {
210         getConsoleInfo();
211         int nb = Math.max(0, info.dwCursorPosition.Y + count - info.dwSize.Y + 1);
212         if (nb != count) {
213             info.dwCursorPosition.Y += count;
214             applyCursorPosition();
215         }
216         if (nb &gt; 0) {
217             Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);
218             scroll.Top = 0;
219             Kernel32.COORD org = new Kernel32.COORD();
220             org.X = 0;
221             org.Y = (short)(- nb);
222             Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(&#39; &#39;, originalColors);
223             Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);
224         }
225     }
226 
227     protected void processCursorUp(int count) throws IOException {
228         getConsoleInfo();
229         info.dwCursorPosition.Y -= count;
230         applyCursorPosition();
231     }
232 
233     protected void processCursorTo(int row, int col) throws IOException {
234         getConsoleInfo();
235         info.dwCursorPosition.Y = (short) (info.srWindow.Top + row - 1);
236         info.dwCursorPosition.X = (short) (col - 1);
237         applyCursorPosition();
238     }
239 
240     protected void processCursorToColumn(int x) throws IOException {
241         getConsoleInfo();
242         info.dwCursorPosition.X = (short) (x - 1);
243         applyCursorPosition();
244     }
245 
246     @Override
247     protected void processSetForegroundColorExt(int paletteIndex) throws IOException {
248         int color = Colors.roundColor(paletteIndex, 16);
249         info.wAttributes = (short) ((info.wAttributes &amp; ~0x0007) | ANSI_FOREGROUND_COLOR_MAP[color &amp; 0x07]);
250         info.wAttributes = (short) ((info.wAttributes &amp; ~FOREGROUND_INTENSITY) | (color &gt;= 8 ? FOREGROUND_INTENSITY : 0));
251         applyAttribute();
252     }
253 
254     protected void processSetBackgroundColorExt(int paletteIndex) throws IOException {
255         int color = Colors.roundColor(paletteIndex, 16);
256         info.wAttributes = (short)((info.wAttributes &amp; ~0x0070 ) | ANSI_BACKGROUND_COLOR_MAP[color &amp; 0x07]);
257         info.wAttributes = (short) ((info.wAttributes &amp; ~BACKGROUND_INTENSITY) | (color &gt;= 8 ? BACKGROUND_INTENSITY : 0));
258         applyAttribute();
259     }
260 
261     protected void processDefaultTextColor() throws IOException {
262         info.wAttributes = (short)((info.wAttributes &amp; ~0x000F ) | (originalColors &amp; 0x000F));
263         applyAttribute();
264     }
265 
266     protected void processDefaultBackgroundColor() throws IOException {
267         info.wAttributes = (short)((info.wAttributes &amp; ~0x00F0 ) | (originalColors &amp; 0x00F0));
268         applyAttribute();
269     }
270 
271     protected void processAttributeRest() throws IOException {
272         info.wAttributes = (short)((info.wAttributes &amp; ~0x00FF ) | originalColors);
273         this.negative = false;
274         this.bold = false;
275         this.underline = false;
276         applyAttribute();
277     }
278 
279     protected void processSetAttribute(int attribute) throws IOException {
280         switch(attribute) {
281             case ATTRIBUTE_INTENSITY_BOLD:
282                 bold = true;
283                 applyAttribute();
284                 break;
285             case ATTRIBUTE_INTENSITY_NORMAL:
286                 bold = false;
287                 applyAttribute();
288                 break;
289 
290             case ATTRIBUTE_UNDERLINE:
291                 underline = true;
292                 applyAttribute();
293                 break;
294             case ATTRIBUTE_UNDERLINE_OFF:
295                 underline = false;
296                 applyAttribute();
297                 break;
298 
299             case ATTRIBUTE_NEGATIVE_ON:
300                 negative = true;
301                 applyAttribute();
302                 break;
303             case ATTRIBUTE_NEGATIVE_OFF:
304                 negative = false;
305                 applyAttribute();
306                 break;
307         }
308     }
309 
310     protected void processSaveCursorPosition() throws IOException {
311         getConsoleInfo();
312         savedX = info.dwCursorPosition.X;
313         savedY = info.dwCursorPosition.Y;
314     }
315 
316     protected void processRestoreCursorPosition() throws IOException {
317         // restore only if there was a save operation first
318         if (savedX != -1 &amp;&amp; savedY != -1) {
319             out.flush();
320             info.dwCursorPosition.X = savedX;
321             info.dwCursorPosition.Y = savedY;
322             applyCursorPosition();
323         }
324     }
325 
326     @Override
327     protected void processInsertLine(int optionInt) throws IOException {
328         getConsoleInfo();
329         Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);
330         scroll.Top = info.dwCursorPosition.Y;
331         Kernel32.COORD org = new Kernel32.COORD();
332         org.X = 0;
333         org.Y = (short)(info.dwCursorPosition.Y + optionInt);
334         Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(&#39; &#39;, originalColors);
335         Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);
336     }
337 
338     @Override
339     protected void processDeleteLine(int optionInt) throws IOException {
340         getConsoleInfo();
341         Kernel32.SMALL_RECT scroll = new Kernel32.SMALL_RECT(info.srWindow);
342         scroll.Top = info.dwCursorPosition.Y;
343         Kernel32.COORD org = new Kernel32.COORD();
344         org.X = 0;
345         org.Y = (short)(info.dwCursorPosition.Y - optionInt);
346         Kernel32.CHAR_INFO info = new Kernel32.CHAR_INFO(&#39; &#39;, originalColors);
347         Kernel32.INSTANCE.ScrollConsoleScreenBuffer(console, scroll, scroll, org, info);
348     }
349 
350     protected void processChangeWindowTitle(String label) {
351         Kernel32.INSTANCE.SetConsoleTitle(label);
352     }
353 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.management.jfr;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.StringReader;
<a name="1" id="anc1"></a><span class="line-added"> 31 import java.nio.file.Path;</span>
 32 import java.nio.file.Paths;
 33 import java.security.AccessControlContext;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 import java.text.ParseException;
 37 import java.time.Instant;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collections;
 41 import java.util.HashMap;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.Objects;
 45 import java.util.concurrent.ConcurrentHashMap;
 46 import java.util.concurrent.CopyOnWriteArrayList;
 47 import java.util.concurrent.atomic.AtomicLong;
 48 import java.util.function.Consumer;
 49 import java.util.function.Function;
 50 import java.util.function.Predicate;
 51 
 52 import javax.management.AttributeChangeNotification;
 53 import javax.management.AttributeNotFoundException;
 54 import javax.management.ListenerNotFoundException;
 55 import javax.management.MBeanException;
 56 import javax.management.MBeanNotificationInfo;
 57 import javax.management.Notification;
 58 import javax.management.NotificationBroadcasterSupport;
 59 import javax.management.NotificationEmitter;
 60 import javax.management.NotificationFilter;
 61 import javax.management.NotificationListener;
 62 import javax.management.ObjectName;
 63 import javax.management.ReflectionException;
 64 import javax.management.StandardEmitterMBean;
 65 
 66 import jdk.jfr.Configuration;
 67 import jdk.jfr.EventType;
 68 import jdk.jfr.FlightRecorder;
 69 import jdk.jfr.FlightRecorderListener;
 70 import jdk.jfr.FlightRecorderPermission;
 71 import jdk.jfr.Recording;
 72 import jdk.jfr.RecordingState;
 73 import jdk.jfr.internal.management.ManagementSupport;
 74 
 75 // Instantiated by service provider
 76 final class FlightRecorderMXBeanImpl extends StandardEmitterMBean implements FlightRecorderMXBean, NotificationEmitter {
 77 
 78     final class MXBeanListener implements FlightRecorderListener {
 79         private final NotificationListener listener;
 80         private final NotificationFilter filter;
 81         private final Object handback;
 82         private final AccessControlContext context;
 83 
 84         public MXBeanListener(NotificationListener listener, NotificationFilter filter, Object handback) {
 85             this.context = AccessController.getContext();
 86             this.listener = listener;
 87             this.filter = filter;
 88             this.handback = handback;
 89         }
 90 
 91         public void recordingStateChanged(Recording recording) {
 92             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 93                 @Override
 94                 public Void run() {
 95                     sendNotification(createNotication(recording));
 96                     return null;
 97                 }
 98             }, context);
 99         }
100     }
101 
102     private static final String ATTRIBUTE_RECORDINGS = &quot;Recordings&quot;;
103     private static final String OPTION_MAX_SIZE = &quot;maxSize&quot;;
104     private static final String OPTION_MAX_AGE = &quot;maxAge&quot;;
105     private static final String OPTION_NAME = &quot;name&quot;;
106     private static final String OPTION_DISK = &quot;disk&quot;;
107     private static final String OPTION_DUMP_ON_EXIT = &quot;dumpOnExit&quot;;
108     private static final String OPTION_DURATION = &quot;duration&quot;;
<a name="2" id="anc2"></a><span class="line-modified">109     private static final String OPTION_DESTINATION = &quot;destination&quot;;</span>
<span class="line-added">110     private static final List&lt;String&gt; OPTIONS = Arrays.asList(new String[] { OPTION_DUMP_ON_EXIT, OPTION_DURATION, OPTION_NAME, OPTION_MAX_AGE, OPTION_MAX_SIZE, OPTION_DISK, OPTION_DESTINATION, });</span>
111     private final StreamManager streamHandler = new StreamManager();
112     private final Map&lt;Long, Object&gt; changes = new ConcurrentHashMap&lt;&gt;();
113     private final AtomicLong sequenceNumber = new AtomicLong();
114     private final List&lt;MXBeanListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();
115     private FlightRecorder recorder;
116 
117     FlightRecorderMXBeanImpl() {
118         super(FlightRecorderMXBean.class, true, new NotificationBroadcasterSupport(createNotificationInfo()));
119     }
120 
121     @Override
122     public void startRecording(long id) {
123         MBeanUtils.checkControl();
124         getExistingRecording(id).start();
125     }
126 
127     @Override
128     public boolean stopRecording(long id) {
129         MBeanUtils.checkControl();
130         return getExistingRecording(id).stop();
131     }
132 
133     @Override
134     public void closeRecording(long id) {
135         MBeanUtils.checkControl();
136         getExistingRecording(id).close();
137     }
138 
139     @Override
140     public long openStream(long id, Map&lt;String, String&gt; options) throws IOException {
141         MBeanUtils.checkControl();
142         if (!FlightRecorder.isInitialized()) {
143             throw new IllegalArgumentException(&quot;No recording available with id &quot; + id);
144         }
145         // Make local copy to prevent concurrent modification
146         Map&lt;String, String&gt; s = options == null ? new HashMap&lt;&gt;() : new HashMap&lt;&gt;(options);
147         Instant starttime = MBeanUtils.parseTimestamp(s.get(&quot;startTime&quot;), Instant.MIN);
148         Instant endtime = MBeanUtils.parseTimestamp(s.get(&quot;endTime&quot;), Instant.MAX);
149         int blockSize = MBeanUtils.parseBlockSize(s.get(&quot;blockSize&quot;), StreamManager.DEFAULT_BLOCK_SIZE);
150         InputStream is = getExistingRecording(id).getStream(starttime, endtime);
151         if (is == null) {
152             throw new IOException(&quot;No recording data available&quot;);
153         }
154         return streamHandler.create(is, blockSize).getId();
155     }
156 
157     @Override
158     public void closeStream(long streamIdentifier) throws IOException {
159         MBeanUtils.checkControl();
160         streamHandler.getStream(streamIdentifier).close();
161     }
162 
163     @Override
164     public byte[] readStream(long streamIdentifier) throws IOException {
165         MBeanUtils.checkMonitor();
166         return streamHandler.getStream(streamIdentifier).read();
167     }
168 
169     @Override
170     public List&lt;RecordingInfo&gt; getRecordings() {
171         MBeanUtils.checkMonitor();
172         if (!FlightRecorder.isInitialized()) {
173             return Collections.emptyList();
174         }
175         return MBeanUtils.transformList(getRecorder().getRecordings(), RecordingInfo::new);
176     }
177 
178     @Override
179     public List&lt;ConfigurationInfo&gt; getConfigurations() {
180         MBeanUtils.checkMonitor();
181         return MBeanUtils.transformList(Configuration.getConfigurations(), ConfigurationInfo::new);
182     }
183 
184     @Override
185     public List&lt;EventTypeInfo&gt; getEventTypes() {
186         MBeanUtils.checkMonitor();
187         List&lt;EventType&gt; eventTypes = AccessController.doPrivileged(new PrivilegedAction&lt;List&lt;EventType&gt;&gt;() {
188             @Override
189             public List&lt;EventType&gt; run() {
190                 return ManagementSupport.getEventTypes();
191             }
192         }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;));
193 
194         return MBeanUtils.transformList(eventTypes, EventTypeInfo::new);
195     }
196 
197     @Override
198     public Map&lt;String, String&gt; getRecordingSettings(long recording) throws IllegalArgumentException {
199         MBeanUtils.checkMonitor();
200         return getExistingRecording(recording).getSettings();
201     }
202 
203     @Override
204     public void setRecordingSettings(long recording, Map&lt;String, String&gt; values) throws IllegalArgumentException {
205         Objects.requireNonNull(values);
206         MBeanUtils.checkControl();
207         getExistingRecording(recording).setSettings(values);
208     }
209 
210     @Override
211     public long newRecording() {
212         MBeanUtils.checkControl();
213         getRecorder(); // ensure notification listener is setup
214         return AccessController.doPrivileged(new PrivilegedAction&lt;Recording&gt;() {
215             @Override
216             public Recording run() {
217                 return new Recording();
218             }
219         }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;)).getId();
220     }
221 
222     @Override
223     public long takeSnapshot() {
224         MBeanUtils.checkControl();
225         return getRecorder().takeSnapshot().getId();
226     }
227 
228     @Override
229     public void setConfiguration(long recording, String configuration) throws IllegalArgumentException {
230         Objects.requireNonNull(configuration);
231         MBeanUtils.checkControl();
232         try {
233             Configuration c = Configuration.create(new StringReader(configuration));
234             getExistingRecording(recording).setSettings(c.getSettings());
235         } catch (IOException | ParseException e) {
236             throw new IllegalArgumentException(&quot;Could not parse configuration&quot;, e);
237         }
238     }
239 
240     @Override
241     public void setPredefinedConfiguration(long recording, String configurationName) throws IllegalArgumentException {
242         Objects.requireNonNull(configurationName);
243         MBeanUtils.checkControl();
244         Recording r = getExistingRecording(recording);
245         for (Configuration c : Configuration.getConfigurations()) {
246             if (c.getName().equals(configurationName)) {
247                 r.setSettings(c.getSettings());
248                 return;
249             }
250         }
251         throw new IllegalArgumentException(&quot;Could not find configuration with name &quot; + configurationName);
252     }
253 
254     @Override
255     public void copyTo(long recording, String path) throws IOException {
256         Objects.requireNonNull(path);
257         MBeanUtils.checkControl();
258         getExistingRecording(recording).dump(Paths.get(path));
259     }
260 
261     @Override
262     public void setRecordingOptions(long recording, Map&lt;String, String&gt; options) throws IllegalArgumentException {
263         Objects.requireNonNull(options);
264         MBeanUtils.checkControl();
265         // Make local copy to prevent concurrent modification
266         Map&lt;String, String&gt; ops = new HashMap&lt;String, String&gt;(options);
267         for (Map.Entry&lt;String, String&gt; entry : ops.entrySet()) {
268             Object key = entry.getKey();
269             Object value = entry.getValue();
270             if (!(key instanceof String)) {
271                 throw new IllegalArgumentException(&quot;Option key must not be null, or other type than &quot; + String.class);
272             }
273             if (!OPTIONS.contains(key)) {
274                 throw new IllegalArgumentException(&quot;Unknown recording option: &quot; + key + &quot;. Valid options are &quot; + OPTIONS + &quot;.&quot;);
275             }
276             if (value != null &amp;&amp; !(value instanceof String)) {
277                 throw new IllegalArgumentException(&quot;Incorrect value for option &quot; + key + &quot;. Values must be of type &quot; + String.class + &quot; .&quot;);
278             }
279         }
280 
281         Recording r = getExistingRecording(recording);
282         validateOption(ops, OPTION_DUMP_ON_EXIT, MBeanUtils::booleanValue);
283         validateOption(ops, OPTION_DISK, MBeanUtils::booleanValue);
284         validateOption(ops, OPTION_NAME, Function.identity());
285         validateOption(ops, OPTION_MAX_AGE, MBeanUtils::duration);
286         validateOption(ops, OPTION_MAX_SIZE, MBeanUtils::size);
287         validateOption(ops, OPTION_DURATION, MBeanUtils::duration);
<a name="3" id="anc3"></a><span class="line-added">288         validateOption(ops, OPTION_DESTINATION, x -&gt; MBeanUtils.destination(r, x));</span>
289 
290         // All OK, now set them.atomically
291         setOption(ops, OPTION_DUMP_ON_EXIT, &quot;false&quot;, MBeanUtils::booleanValue, x -&gt; r.setDumpOnExit(x));
292         setOption(ops, OPTION_DISK, &quot;true&quot;, MBeanUtils::booleanValue, x -&gt; r.setToDisk(x));
293         setOption(ops, OPTION_NAME, String.valueOf(r.getId()), Function.identity(), x -&gt; r.setName(x));
294         setOption(ops, OPTION_MAX_AGE, null, MBeanUtils::duration, x -&gt; r.setMaxAge(x));
295         setOption(ops, OPTION_MAX_SIZE, &quot;0&quot;, MBeanUtils::size, x -&gt; r.setMaxSize(x));
296         setOption(ops, OPTION_DURATION, null, MBeanUtils::duration, x -&gt; r.setDuration(x));
<a name="4" id="anc4"></a><span class="line-added">297         setOption(ops, OPTION_DESTINATION, null, x -&gt; MBeanUtils.destination(r, x), x -&gt; setOptionDestination(r, x));</span>
298     }
299 
300     @Override
301     public Map&lt;String, String&gt; getRecordingOptions(long recording) throws IllegalArgumentException {
302         MBeanUtils.checkMonitor();
303         Recording r = getExistingRecording(recording);
304         Map&lt;String, String&gt; options = new HashMap&lt;&gt;(10);
305         options.put(OPTION_DUMP_ON_EXIT, String.valueOf(r.getDumpOnExit()));
306         options.put(OPTION_DISK, String.valueOf(r.isToDisk()));
307         options.put(OPTION_NAME, String.valueOf(r.getName()));
308         options.put(OPTION_MAX_AGE, ManagementSupport.formatTimespan(r.getMaxAge(), &quot; &quot;));
309         Long maxSize = r.getMaxSize();
310         options.put(OPTION_MAX_SIZE, String.valueOf(maxSize == null ? &quot;0&quot; : maxSize.toString()));
311         options.put(OPTION_DURATION, ManagementSupport.formatTimespan(r.getDuration(), &quot; &quot;));
<a name="5" id="anc5"></a><span class="line-added">312         options.put(OPTION_DESTINATION, ManagementSupport.getDestinationOriginalText(r));</span>
313         return options;
314     }
315 
316     @Override
317     public long cloneRecording(long id, boolean stop) throws IllegalStateException, SecurityException {
318         MBeanUtils.checkControl();
319         return getRecording(id).copy(stop).getId();
320     }
321 
322     @Override
323     public ObjectName getObjectName() {
324         return MBeanUtils.createObjectName();
325     }
326 
327     private Recording getExistingRecording(long id) {
328         if (FlightRecorder.isInitialized()) {
329             Recording recording = getRecording(id);
330             if (recording != null) {
331                 return recording;
332             }
333         }
334         throw new IllegalArgumentException(&quot;No recording available with id &quot; + id);
335     }
336 
337     private Recording getRecording(long id) {
338         List&lt;Recording&gt; recs = getRecorder().getRecordings();
339         return recs.stream().filter(r -&gt; r.getId() == id).findFirst().orElse(null);
340     }
341 
342     private static &lt;T, U&gt; void setOption(Map&lt;String, String&gt; options, String name, String defaultValue, Function&lt;String, U&gt; converter, Consumer&lt;U&gt; setter) {
343         if (!options.containsKey(name)) {
344             return;
345         }
346         String v = options.get(name);
347         if (v == null) {
348             v = defaultValue;
349         }
350         try {
351             setter.accept(converter.apply(v));
352         } catch (IllegalArgumentException iae) {
353             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
354         }
355     }
356 
<a name="6" id="anc6"></a><span class="line-added">357     private static void setOptionDestination(Recording recording, String destination){</span>
<span class="line-added">358         try {</span>
<span class="line-added">359             Path pathDestination = null;</span>
<span class="line-added">360             if(destination != null){</span>
<span class="line-added">361                 pathDestination = Paths.get(destination);</span>
<span class="line-added">362             }</span>
<span class="line-added">363             recording.setDestination(pathDestination);</span>
<span class="line-added">364         } catch (IOException e) {</span>
<span class="line-added">365             IllegalArgumentException iae = new IllegalArgumentException(&quot;Not a valid destination &quot; + destination);</span>
<span class="line-added">366             iae.addSuppressed(e);</span>
<span class="line-added">367             throw iae;</span>
<span class="line-added">368         }</span>
<span class="line-added">369     }</span>
<span class="line-added">370 </span>
371     private static &lt;T, U&gt; void validateOption(Map&lt;String, String&gt; options, String name, Function&lt;String, U&gt; validator) {
372         try {
373             String v = options.get(name);
374             if (v == null) {
375                 return; // OK, will set default
376             }
377             validator.apply(v);
378         } catch (IllegalArgumentException iae) {
379             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
380         }
381     }
382 
383     private FlightRecorder getRecorder() throws SecurityException {
384         // Synchronize on some private object that is always available
385         synchronized (streamHandler) {
386             if (recorder == null) {
387                 recorder = AccessController.doPrivileged(new PrivilegedAction&lt;FlightRecorder&gt;() {
388                     @Override
389                     public FlightRecorder run() {
390                         return FlightRecorder.getFlightRecorder();
391                     }
392                 }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;));
393             }
394             return recorder;
395         }
396     }
397 
398     private static MBeanNotificationInfo[] createNotificationInfo() {
399         String[] types = new String[] { AttributeChangeNotification.ATTRIBUTE_CHANGE };
400         String name = AttributeChangeNotification.class.getName();
401         String description = &quot;Notifies if the RecordingState has changed for one of the recordings, for example if a recording starts or stops&quot;;
402         MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
403         return new MBeanNotificationInfo[] { info };
404     }
405 
406     @Override
407     public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) {
408         MXBeanListener mxbeanListener = new MXBeanListener(listener, filter, handback);
409         listeners.add(mxbeanListener);
410         AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
411             @Override
412             public Void run(){
413                 FlightRecorder.addListener(mxbeanListener);
414                 return null;
415             }
416         }, null, new FlightRecorderPermission(&quot;accessFlightRecorder&quot;));
417         super.addNotificationListener(listener, filter, handback);
418     }
419 
420     @Override
421     public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
422         removeListeners( x -&gt; listener == x.listener);
423         super.removeNotificationListener(listener);
424     }
425 
426     @Override
427     public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback) throws ListenerNotFoundException {
428         removeListeners( x -&gt; listener == x.listener &amp;&amp; filter == x.filter &amp;&amp; handback == x.handback);
429         super.removeNotificationListener(listener, filter, handback);
430     }
431 
432     private void removeListeners(Predicate&lt;MXBeanListener&gt; p) {
433         List&lt;MXBeanListener&gt; toBeRemoved = new ArrayList&lt;&gt;(listeners.size());
434         for (MXBeanListener l : listeners) {
435             if (p.test(l)) {
436                 toBeRemoved.add(l);
437                 FlightRecorder.removeListener(l);
438             }
439         }
440         listeners.removeAll(toBeRemoved);
441     }
442 
443     private Notification createNotication(Recording recording) {
444         try {
445             Long id = recording.getId();
446             Object oldValue = changes.get(recording.getId());
447             Object newValue = getAttribute(ATTRIBUTE_RECORDINGS);
448             if (recording.getState() != RecordingState.CLOSED) {
449                 changes.put(id, newValue);
450             } else {
451                 changes.remove(id);
452             }
453             return new AttributeChangeNotification(getObjectName(), sequenceNumber.incrementAndGet(), System.currentTimeMillis(), &quot;Recording &quot; + recording.getName() + &quot; is &quot;
454                     + recording.getState(), ATTRIBUTE_RECORDINGS, newValue.getClass().getName(), oldValue, newValue);
455         } catch (AttributeNotFoundException | MBeanException | ReflectionException e) {
456             throw new RuntimeException(&quot;Could not create notifcation for FlightRecorderMXBean. &quot; + e.getMessage(), e);
457         }
458     }
459 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
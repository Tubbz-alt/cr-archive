<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="FlightRecorderMXBean.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MBeanUtils.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.management.jfr/share/classes/jdk/management/jfr/FlightRecorderMXBeanImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.management.jfr;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.StringReader;

 31 import java.nio.file.Paths;
 32 import java.security.AccessControlContext;
 33 import java.security.AccessController;
 34 import java.security.PrivilegedAction;
 35 import java.text.ParseException;
 36 import java.time.Instant;
 37 import java.util.ArrayList;
 38 import java.util.Arrays;
 39 import java.util.Collections;
 40 import java.util.HashMap;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.Objects;
 44 import java.util.concurrent.ConcurrentHashMap;
 45 import java.util.concurrent.CopyOnWriteArrayList;
 46 import java.util.concurrent.atomic.AtomicLong;
 47 import java.util.function.Consumer;
 48 import java.util.function.Function;
 49 import java.util.function.Predicate;
 50 
</pre>
<hr />
<pre>
 88         }
 89 
 90         public void recordingStateChanged(Recording recording) {
 91             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 92                 @Override
 93                 public Void run() {
 94                     sendNotification(createNotication(recording));
 95                     return null;
 96                 }
 97             }, context);
 98         }
 99     }
100 
101     private static final String ATTRIBUTE_RECORDINGS = &quot;Recordings&quot;;
102     private static final String OPTION_MAX_SIZE = &quot;maxSize&quot;;
103     private static final String OPTION_MAX_AGE = &quot;maxAge&quot;;
104     private static final String OPTION_NAME = &quot;name&quot;;
105     private static final String OPTION_DISK = &quot;disk&quot;;
106     private static final String OPTION_DUMP_ON_EXIT = &quot;dumpOnExit&quot;;
107     private static final String OPTION_DURATION = &quot;duration&quot;;
<span class="line-modified">108     private static final List&lt;String&gt; OPTIONS = Arrays.asList(new String[] { OPTION_DUMP_ON_EXIT, OPTION_DURATION, OPTION_NAME, OPTION_MAX_AGE, OPTION_MAX_SIZE, OPTION_DISK, });</span>

109     private final StreamManager streamHandler = new StreamManager();
110     private final Map&lt;Long, Object&gt; changes = new ConcurrentHashMap&lt;&gt;();
111     private final AtomicLong sequenceNumber = new AtomicLong();
112     private final List&lt;MXBeanListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();
113     private FlightRecorder recorder;
114 
115     FlightRecorderMXBeanImpl() {
116         super(FlightRecorderMXBean.class, true, new NotificationBroadcasterSupport(createNotificationInfo()));
117     }
118 
119     @Override
120     public void startRecording(long id) {
121         MBeanUtils.checkControl();
122         getExistingRecording(id).start();
123     }
124 
125     @Override
126     public boolean stopRecording(long id) {
127         MBeanUtils.checkControl();
128         return getExistingRecording(id).stop();
</pre>
<hr />
<pre>
266             Object key = entry.getKey();
267             Object value = entry.getValue();
268             if (!(key instanceof String)) {
269                 throw new IllegalArgumentException(&quot;Option key must not be null, or other type than &quot; + String.class);
270             }
271             if (!OPTIONS.contains(key)) {
272                 throw new IllegalArgumentException(&quot;Unknown recording option: &quot; + key + &quot;. Valid options are &quot; + OPTIONS + &quot;.&quot;);
273             }
274             if (value != null &amp;&amp; !(value instanceof String)) {
275                 throw new IllegalArgumentException(&quot;Incorrect value for option &quot; + key + &quot;. Values must be of type &quot; + String.class + &quot; .&quot;);
276             }
277         }
278 
279         Recording r = getExistingRecording(recording);
280         validateOption(ops, OPTION_DUMP_ON_EXIT, MBeanUtils::booleanValue);
281         validateOption(ops, OPTION_DISK, MBeanUtils::booleanValue);
282         validateOption(ops, OPTION_NAME, Function.identity());
283         validateOption(ops, OPTION_MAX_AGE, MBeanUtils::duration);
284         validateOption(ops, OPTION_MAX_SIZE, MBeanUtils::size);
285         validateOption(ops, OPTION_DURATION, MBeanUtils::duration);

286 
287         // All OK, now set them.atomically
288         setOption(ops, OPTION_DUMP_ON_EXIT, &quot;false&quot;, MBeanUtils::booleanValue, x -&gt; r.setDumpOnExit(x));
289         setOption(ops, OPTION_DISK, &quot;true&quot;, MBeanUtils::booleanValue, x -&gt; r.setToDisk(x));
290         setOption(ops, OPTION_NAME, String.valueOf(r.getId()), Function.identity(), x -&gt; r.setName(x));
291         setOption(ops, OPTION_MAX_AGE, null, MBeanUtils::duration, x -&gt; r.setMaxAge(x));
292         setOption(ops, OPTION_MAX_SIZE, &quot;0&quot;, MBeanUtils::size, x -&gt; r.setMaxSize(x));
293         setOption(ops, OPTION_DURATION, null, MBeanUtils::duration, x -&gt; r.setDuration(x));

294     }
295 
296     @Override
297     public Map&lt;String, String&gt; getRecordingOptions(long recording) throws IllegalArgumentException {
298         MBeanUtils.checkMonitor();
299         Recording r = getExistingRecording(recording);
300         Map&lt;String, String&gt; options = new HashMap&lt;&gt;(10);
301         options.put(OPTION_DUMP_ON_EXIT, String.valueOf(r.getDumpOnExit()));
302         options.put(OPTION_DISK, String.valueOf(r.isToDisk()));
303         options.put(OPTION_NAME, String.valueOf(r.getName()));
304         options.put(OPTION_MAX_AGE, ManagementSupport.formatTimespan(r.getMaxAge(), &quot; &quot;));
305         Long maxSize = r.getMaxSize();
306         options.put(OPTION_MAX_SIZE, String.valueOf(maxSize == null ? &quot;0&quot; : maxSize.toString()));
307         options.put(OPTION_DURATION, ManagementSupport.formatTimespan(r.getDuration(), &quot; &quot;));

308         return options;
309     }
310 
311     @Override
312     public long cloneRecording(long id, boolean stop) throws IllegalStateException, SecurityException {
313         MBeanUtils.checkControl();
314         return getRecording(id).copy(stop).getId();
315     }
316 
317     @Override
318     public ObjectName getObjectName() {
319         return MBeanUtils.createObjectName();
320     }
321 
322     private Recording getExistingRecording(long id) {
323         if (FlightRecorder.isInitialized()) {
324             Recording recording = getRecording(id);
325             if (recording != null) {
326                 return recording;
327             }
</pre>
<hr />
<pre>
332     private Recording getRecording(long id) {
333         List&lt;Recording&gt; recs = getRecorder().getRecordings();
334         return recs.stream().filter(r -&gt; r.getId() == id).findFirst().orElse(null);
335     }
336 
337     private static &lt;T, U&gt; void setOption(Map&lt;String, String&gt; options, String name, String defaultValue, Function&lt;String, U&gt; converter, Consumer&lt;U&gt; setter) {
338         if (!options.containsKey(name)) {
339             return;
340         }
341         String v = options.get(name);
342         if (v == null) {
343             v = defaultValue;
344         }
345         try {
346             setter.accept(converter.apply(v));
347         } catch (IllegalArgumentException iae) {
348             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
349         }
350     }
351 














352     private static &lt;T, U&gt; void validateOption(Map&lt;String, String&gt; options, String name, Function&lt;String, U&gt; validator) {
353         try {
354             String v = options.get(name);
355             if (v == null) {
356                 return; // OK, will set default
357             }
358             validator.apply(v);
359         } catch (IllegalArgumentException iae) {
360             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
361         }
362     }
363 
364     private FlightRecorder getRecorder() throws SecurityException {
365         // Synchronize on some private object that is always available
366         synchronized (streamHandler) {
367             if (recorder == null) {
368                 recorder = AccessController.doPrivileged(new PrivilegedAction&lt;FlightRecorder&gt;() {
369                     @Override
370                     public FlightRecorder run() {
371                         return FlightRecorder.getFlightRecorder();
</pre>
</td>
<td>
<hr />
<pre>
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.management.jfr;
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.io.StringReader;
<span class="line-added"> 31 import java.nio.file.Path;</span>
 32 import java.nio.file.Paths;
 33 import java.security.AccessControlContext;
 34 import java.security.AccessController;
 35 import java.security.PrivilegedAction;
 36 import java.text.ParseException;
 37 import java.time.Instant;
 38 import java.util.ArrayList;
 39 import java.util.Arrays;
 40 import java.util.Collections;
 41 import java.util.HashMap;
 42 import java.util.List;
 43 import java.util.Map;
 44 import java.util.Objects;
 45 import java.util.concurrent.ConcurrentHashMap;
 46 import java.util.concurrent.CopyOnWriteArrayList;
 47 import java.util.concurrent.atomic.AtomicLong;
 48 import java.util.function.Consumer;
 49 import java.util.function.Function;
 50 import java.util.function.Predicate;
 51 
</pre>
<hr />
<pre>
 89         }
 90 
 91         public void recordingStateChanged(Recording recording) {
 92             AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {
 93                 @Override
 94                 public Void run() {
 95                     sendNotification(createNotication(recording));
 96                     return null;
 97                 }
 98             }, context);
 99         }
100     }
101 
102     private static final String ATTRIBUTE_RECORDINGS = &quot;Recordings&quot;;
103     private static final String OPTION_MAX_SIZE = &quot;maxSize&quot;;
104     private static final String OPTION_MAX_AGE = &quot;maxAge&quot;;
105     private static final String OPTION_NAME = &quot;name&quot;;
106     private static final String OPTION_DISK = &quot;disk&quot;;
107     private static final String OPTION_DUMP_ON_EXIT = &quot;dumpOnExit&quot;;
108     private static final String OPTION_DURATION = &quot;duration&quot;;
<span class="line-modified">109     private static final String OPTION_DESTINATION = &quot;destination&quot;;</span>
<span class="line-added">110     private static final List&lt;String&gt; OPTIONS = Arrays.asList(new String[] { OPTION_DUMP_ON_EXIT, OPTION_DURATION, OPTION_NAME, OPTION_MAX_AGE, OPTION_MAX_SIZE, OPTION_DISK, OPTION_DESTINATION, });</span>
111     private final StreamManager streamHandler = new StreamManager();
112     private final Map&lt;Long, Object&gt; changes = new ConcurrentHashMap&lt;&gt;();
113     private final AtomicLong sequenceNumber = new AtomicLong();
114     private final List&lt;MXBeanListener&gt; listeners = new CopyOnWriteArrayList&lt;&gt;();
115     private FlightRecorder recorder;
116 
117     FlightRecorderMXBeanImpl() {
118         super(FlightRecorderMXBean.class, true, new NotificationBroadcasterSupport(createNotificationInfo()));
119     }
120 
121     @Override
122     public void startRecording(long id) {
123         MBeanUtils.checkControl();
124         getExistingRecording(id).start();
125     }
126 
127     @Override
128     public boolean stopRecording(long id) {
129         MBeanUtils.checkControl();
130         return getExistingRecording(id).stop();
</pre>
<hr />
<pre>
268             Object key = entry.getKey();
269             Object value = entry.getValue();
270             if (!(key instanceof String)) {
271                 throw new IllegalArgumentException(&quot;Option key must not be null, or other type than &quot; + String.class);
272             }
273             if (!OPTIONS.contains(key)) {
274                 throw new IllegalArgumentException(&quot;Unknown recording option: &quot; + key + &quot;. Valid options are &quot; + OPTIONS + &quot;.&quot;);
275             }
276             if (value != null &amp;&amp; !(value instanceof String)) {
277                 throw new IllegalArgumentException(&quot;Incorrect value for option &quot; + key + &quot;. Values must be of type &quot; + String.class + &quot; .&quot;);
278             }
279         }
280 
281         Recording r = getExistingRecording(recording);
282         validateOption(ops, OPTION_DUMP_ON_EXIT, MBeanUtils::booleanValue);
283         validateOption(ops, OPTION_DISK, MBeanUtils::booleanValue);
284         validateOption(ops, OPTION_NAME, Function.identity());
285         validateOption(ops, OPTION_MAX_AGE, MBeanUtils::duration);
286         validateOption(ops, OPTION_MAX_SIZE, MBeanUtils::size);
287         validateOption(ops, OPTION_DURATION, MBeanUtils::duration);
<span class="line-added">288         validateOption(ops, OPTION_DESTINATION, x -&gt; MBeanUtils.destination(r, x));</span>
289 
290         // All OK, now set them.atomically
291         setOption(ops, OPTION_DUMP_ON_EXIT, &quot;false&quot;, MBeanUtils::booleanValue, x -&gt; r.setDumpOnExit(x));
292         setOption(ops, OPTION_DISK, &quot;true&quot;, MBeanUtils::booleanValue, x -&gt; r.setToDisk(x));
293         setOption(ops, OPTION_NAME, String.valueOf(r.getId()), Function.identity(), x -&gt; r.setName(x));
294         setOption(ops, OPTION_MAX_AGE, null, MBeanUtils::duration, x -&gt; r.setMaxAge(x));
295         setOption(ops, OPTION_MAX_SIZE, &quot;0&quot;, MBeanUtils::size, x -&gt; r.setMaxSize(x));
296         setOption(ops, OPTION_DURATION, null, MBeanUtils::duration, x -&gt; r.setDuration(x));
<span class="line-added">297         setOption(ops, OPTION_DESTINATION, null, x -&gt; MBeanUtils.destination(r, x), x -&gt; setOptionDestination(r, x));</span>
298     }
299 
300     @Override
301     public Map&lt;String, String&gt; getRecordingOptions(long recording) throws IllegalArgumentException {
302         MBeanUtils.checkMonitor();
303         Recording r = getExistingRecording(recording);
304         Map&lt;String, String&gt; options = new HashMap&lt;&gt;(10);
305         options.put(OPTION_DUMP_ON_EXIT, String.valueOf(r.getDumpOnExit()));
306         options.put(OPTION_DISK, String.valueOf(r.isToDisk()));
307         options.put(OPTION_NAME, String.valueOf(r.getName()));
308         options.put(OPTION_MAX_AGE, ManagementSupport.formatTimespan(r.getMaxAge(), &quot; &quot;));
309         Long maxSize = r.getMaxSize();
310         options.put(OPTION_MAX_SIZE, String.valueOf(maxSize == null ? &quot;0&quot; : maxSize.toString()));
311         options.put(OPTION_DURATION, ManagementSupport.formatTimespan(r.getDuration(), &quot; &quot;));
<span class="line-added">312         options.put(OPTION_DESTINATION, ManagementSupport.getDestinationOriginalText(r));</span>
313         return options;
314     }
315 
316     @Override
317     public long cloneRecording(long id, boolean stop) throws IllegalStateException, SecurityException {
318         MBeanUtils.checkControl();
319         return getRecording(id).copy(stop).getId();
320     }
321 
322     @Override
323     public ObjectName getObjectName() {
324         return MBeanUtils.createObjectName();
325     }
326 
327     private Recording getExistingRecording(long id) {
328         if (FlightRecorder.isInitialized()) {
329             Recording recording = getRecording(id);
330             if (recording != null) {
331                 return recording;
332             }
</pre>
<hr />
<pre>
337     private Recording getRecording(long id) {
338         List&lt;Recording&gt; recs = getRecorder().getRecordings();
339         return recs.stream().filter(r -&gt; r.getId() == id).findFirst().orElse(null);
340     }
341 
342     private static &lt;T, U&gt; void setOption(Map&lt;String, String&gt; options, String name, String defaultValue, Function&lt;String, U&gt; converter, Consumer&lt;U&gt; setter) {
343         if (!options.containsKey(name)) {
344             return;
345         }
346         String v = options.get(name);
347         if (v == null) {
348             v = defaultValue;
349         }
350         try {
351             setter.accept(converter.apply(v));
352         } catch (IllegalArgumentException iae) {
353             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
354         }
355     }
356 
<span class="line-added">357     private static void setOptionDestination(Recording recording, String destination){</span>
<span class="line-added">358         try {</span>
<span class="line-added">359             Path pathDestination = null;</span>
<span class="line-added">360             if(destination != null){</span>
<span class="line-added">361                 pathDestination = Paths.get(destination);</span>
<span class="line-added">362             }</span>
<span class="line-added">363             recording.setDestination(pathDestination);</span>
<span class="line-added">364         } catch (IOException e) {</span>
<span class="line-added">365             IllegalArgumentException iae = new IllegalArgumentException(&quot;Not a valid destination &quot; + destination);</span>
<span class="line-added">366             iae.addSuppressed(e);</span>
<span class="line-added">367             throw iae;</span>
<span class="line-added">368         }</span>
<span class="line-added">369     }</span>
<span class="line-added">370 </span>
371     private static &lt;T, U&gt; void validateOption(Map&lt;String, String&gt; options, String name, Function&lt;String, U&gt; validator) {
372         try {
373             String v = options.get(name);
374             if (v == null) {
375                 return; // OK, will set default
376             }
377             validator.apply(v);
378         } catch (IllegalArgumentException iae) {
379             throw new IllegalArgumentException(&quot;Not a valid value for option &#39;&quot; + name + &quot;&#39;. &quot; + iae.getMessage());
380         }
381     }
382 
383     private FlightRecorder getRecorder() throws SecurityException {
384         // Synchronize on some private object that is always available
385         synchronized (streamHandler) {
386             if (recorder == null) {
387                 recorder = AccessController.doPrivileged(new PrivilegedAction&lt;FlightRecorder&gt;() {
388                     @Override
389                     public FlightRecorder run() {
390                         return FlightRecorder.getFlightRecorder();
</pre>
</td>
</tr>
</table>
<center><a href="FlightRecorderMXBean.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MBeanUtils.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
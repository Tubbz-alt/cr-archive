<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.management.jfr/share/classes/jdk/management/jfr/RecordingInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.management.jfr;
 27 
 28 import java.nio.file.Path;
 29 import java.time.Duration;
 30 import java.time.Instant;
 31 import java.util.LinkedHashMap;
 32 import java.util.List;
 33 import java.util.Map;
 34 
 35 import javax.management.openmbean.CompositeData;
 36 import javax.management.openmbean.TabularData;
 37 
 38 import jdk.jfr.Recording;
 39 import jdk.jfr.RecordingState;
 40 
 41 /**
 42  * Management representation of a {@code Recording}.
 43  *
 44  * @see Recording
 45  *
 46  * @since 9
 47  */
 48 public final class RecordingInfo {
 49     private final long id;
 50     private final String name;
 51     private final String state;
 52     private final boolean dumpOnExit;
 53     private final long size;
 54     private final boolean disk;
 55     private final long maxAge;
 56     private final long maxSize;
 57     private final long startTime;
 58     private final long stopTime;
 59     private final String destination;
 60     private final long durationInSeconds;
 61     private final Map&lt;String, String&gt; settings;
 62 
 63     // package private
 64     RecordingInfo(Recording recording) {
 65         id = recording.getId();
 66         name = recording.getName();
 67         state = recording.getState().toString();
 68         dumpOnExit = recording.getDumpOnExit();
 69         size = recording.getSize();
 70         disk = recording.isToDisk();
 71 
 72         Duration d = recording.getMaxAge();
 73         if (d == null) {
 74             maxAge = 0;
 75         } else {
 76             maxAge = d.getSeconds();
 77         }
 78         maxSize = recording.getMaxSize();
 79         Instant s = recording.getStartTime();
 80         startTime = s == null ? 0L : s.toEpochMilli();
 81         Instant st = recording.getStopTime();
 82         stopTime = st == null ? 0L : st.toEpochMilli();
 83         Path p = recording.getDestination();
 84         destination = p == null ? null : p.toString();
 85         Duration duration = recording.getDuration();
 86         durationInSeconds = duration == null ? 0 : duration.getSeconds();
 87         settings = recording.getSettings();
 88     }
 89 
 90     private RecordingInfo(CompositeData cd) {
 91         id = (int) cd.get(&quot;id&quot;);
 92         name = (String) cd.get(&quot;name&quot;);
 93         state = (String) cd.get(&quot;state&quot;);
 94         dumpOnExit = (boolean) cd.get(&quot;dumpOnExit&quot;);
 95         size = (long) cd.get(&quot;size&quot;);
 96         disk = (boolean) cd.get(&quot;disk&quot;);
 97         maxAge = (Long) cd.get(&quot;maxAge&quot;);
 98         maxSize = (Long) cd.get(&quot;maxSize&quot;);
 99         startTime = (Long) cd.get(&quot;startTime&quot;);
100         stopTime = (Long) cd.get(&quot;stopTime&quot;);
101         destination = (String) cd.get(&quot;destination&quot;);
102         durationInSeconds = (long) cd.get(&quot;duration&quot;);
103         settings = new LinkedHashMap&lt;&gt;();
104         Object map = cd.get(&quot;settings&quot;);
105         if (map instanceof TabularData) {
106             TabularData td = (TabularData) map;
107             List&lt;String&gt; keyNames = td.getTabularType().getIndexNames();
108             int size = keyNames.size();
109             for (Object keys : td.keySet()) {
110                 Object[] keyValues = ((List&lt;?&gt;) keys).toArray();
111                 for (int i = 0; i &lt; size; i++) {
112                     String key = keyNames.get(i);
113                     Object value = keyValues[i];
114                     if (value instanceof String) {
115                         settings.put(key, (String) value);
116                     }
117                 }
118             }
119         }
120     }
121 
122     /**
123      * Returns the name of the recording associated with this
124      * {@code RecordingInfo}.
125      *
126      * @return the recording name, not {@code null}
127      *
128      * @see Recording#getName()
129      */
130     public String getName() {
131         return name;
132     }
133 
134     /**
135      * Returns the unique ID for the recording associated with this
136      * {@code RecordingInfo}.
137      *
138      * @return the recording ID
139      *
140      * @see Recording#getId()
141      */
142     public long getId() {
143         return id;
144     }
145 
146     /**
147      * Returns if the recording associated with this {@code RecordingInfo}
148      * should be dumped to file when the JVM exits.
149      *
150      * @return {@code true} if recording should be dumped on exit, {@code false}
151      *         otherwise
152      *
153      * @see Recording#getDumpOnExit()
154      */
155     public boolean getDumpOnExit() {
156         return dumpOnExit;
157     }
158 
159     /**
160      * Returns how many seconds data should be kept on disk, or {@code 0} if
161      * data is to be kept forever.
162      * &lt;p&gt;
163      * In-memory recordings are not affected by maximum age.
164      *
165      * @see Recording#getMaxAge()
166      * @see Recording#setToDisk(boolean)
167      * @return how long data should be kept on disk, measured in seconds
168      *
169      */
170     public long getMaxAge() {
171         return maxAge;
172     }
173 
174     /**
175      * Returns the amount of data, measured in bytes, the recording associated
176      * with this {@code RecordingInfo}, should be kept on disk, before it&#39;s
177      * rotated away, or {@code 0} if data is to be kept indefinitely.
178      * &lt;p&gt;
179      * In-memory recordings are not affected by maximum size.
180      *
181      * @return the amount of data should be kept on disk, in bytes
182      *
183      * @see Recording#setToDisk(boolean)
184      * @see Recording#getMaxSize()
185      */
186     public long getMaxSize() {
187         return maxSize;
188     }
189 
190     /**
191      * Returns a {@code String} representation of state of the recording
192      * associated with this {@code RecordingInfo}.
193      * &lt;p&gt;
194      * Valid return values are {@code &quot;NEW&quot;}, {@code &quot;DELAYED&quot;}, {@code &quot;STARTING&quot;},
195      * {@code &quot;RUNNING&quot;}, {@code &quot;STOPPING&quot;}, {@code &quot;STOPPED&quot;} and {@code &quot;CLOSED&quot;}.
196      *
197      * @return the recording state, not {@code null}
198      *
199      * @see RecordingState#toString()
200      * @see Recording#getState()
201      */
202     public String getState() {
203         return state;
204     }
205 
206     /**
207      * Returns start time of the recording associated with this
208      * {@code RecordingInfo}, measured as ms since epoch, or {@code null} if the
209      * recording hasn&#39;t started.
210      *
211      * @return the start time of the recording, or {@code null} if the recording
212      *         hasn&#39;t started
213      *
214      * @see Recording#getStartTime()
215      */
216     public long getStartTime() {
217         return startTime;
218     }
219 
220     /**
221      * Returns the actual or expected stop time of the recording associated with
222      * this {@code RecordingInfo}, measured as ms since epoch, or {@code null}
223      * if the expected or actual stop time is not known, which can only happen
224      * if the recording has not yet been stopped.
225      *
226      * @return the stop time of recording, or {@code null} if recording hasn&#39;t
227      *         been stopped.
228      *
229      * @see Recording#getStopTime()
230      */
231     public long getStopTime() {
232         return stopTime;
233     }
234 
235     /**
236      * Returns the settings for the recording associated with this
237      * {@code RecordingInfo}.
238      *
239      * @return the recording settings, not {@code null}
240      *
241      * @see Recording#getSettings()
242      */
243     public Map&lt;String, String&gt; getSettings() {
244         return settings;
245     }
246 
247     /**
248      * Returns destination path where data, for the recording associated with
249      * this {@link RecordingInfo}, should be written when the recording stops,
250      * or {@code null} if the recording should not be written.
251      *
252      * @return the destination, or {@code null} if not set
253      *
254      * @see Recording#getDestination()
255      */
256     public String getDestination() {
257         return destination;
258     }
259 
260     /**
261      * Returns a string description of the recording associated with this
262      * {@code RecordingInfo}
263      *
264      * @return description, not {@code null}
265      */
266     @Override
267     public String toString() {
268         Stringifier s = new Stringifier();
269         s.add(&quot;name&quot;, name);
270         s.add(&quot;id&quot;, id);
271         s.add(&quot;maxAge&quot;, maxAge);
272         s.add(&quot;maxSize&quot;, maxSize);
273         return s.toString();
274     }
275 
276     /**
277      * Returns the amount data recorded by recording. associated with this
278      * {@link RecordingInfo}.
279      *
280      * @return the amount of recorded data, measured in bytes
281      */
282     public long getSize() {
283         return size;
284     }
285 
286     /**
287      * Returns {@code true} if the recording associated with this
288      * {@code RecordingInfo} should be flushed to disk, when memory buffers are
289      * full, {@code false} otherwise.
290      *
291      * @return {@code true} if recording is to disk, {@code false} otherwise
292      */
293     public boolean isToDisk() {
294         return disk;
295     }
296 
297     /**
298      * Returns the desired duration, measured in seconds, of the recording
299      * associated with this {@link RecordingInfo}, or {code 0} if no duration
300      * has been set.
301      *
302      * @return the desired duration, or {code 0} if no duration has been set
303      *
304      * @see Recording#getDuration()
305      */
306     public long getDuration() {
307         return durationInSeconds;
308     }
309 
310     /**
311      * Returns a {@code RecordingInfo} represented by the specified
312      * {@code CompositeData} object.
313      * &lt;p&gt;
314      * The specified {@code CompositeData} must have the following item names and
315      * item types to be valid. &lt;blockquote&gt;
316      * &lt;table class=&quot;striped&quot;&gt;
317      * &lt;caption&gt;Supported names and types in a specified {@code CompositeData} object&lt;/caption&gt;
318      * &lt;thead&gt;
319      * &lt;tr&gt;
320      * &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Name&lt;/th&gt;
321      * &lt;th scope=&quot;col&quot; style=&quot;text-align:left&quot;&gt;Type&lt;/th&gt;
322      * &lt;/tr&gt;
323      * &lt;/thead&gt;
324      * &lt;tbody&gt;
325      * &lt;tr&gt;
326      * &lt;th scope=&quot;row&quot;&gt;id&lt;/th&gt;
327      * &lt;td&gt;{@code Long}&lt;/td&gt;
328      * &lt;/tr&gt;
329      * &lt;tr&gt;
330      * &lt;th scope=&quot;row&quot;&gt;name&lt;/th&gt;
331      * &lt;td&gt;{@code String}&lt;/td&gt;
332      * &lt;/tr&gt;
333      * &lt;tr&gt;
334      * &lt;th scope=&quot;row&quot;&gt;state&lt;/th&gt;
335      * &lt;td&gt;{@code String}&lt;/td&gt;
336      * &lt;/tr&gt;
337      * &lt;tr&gt;
338      * &lt;th scope=&quot;row&quot;&gt;dumpOnExit&lt;/th&gt;
339      * &lt;td&gt;{@code Boolean}&lt;/td&gt;
340      * &lt;/tr&gt;
341      * &lt;tr&gt;
342      * &lt;th scope=&quot;row&quot;&gt;size&lt;/th&gt;
343      * &lt;td&gt;{@code Long}&lt;/td&gt;
344      * &lt;/tr&gt;
345      * &lt;tr&gt;
346      * &lt;th scope=&quot;row&quot;&gt;disk&lt;/th&gt;
347      * &lt;td&gt;{@code Boolean}&lt;/td&gt;
348      * &lt;/tr&gt;
349      * &lt;tr&gt;
350      * &lt;th scope=&quot;row&quot;&gt;maxAge&lt;/th&gt;
351      * &lt;td&gt;{@code Long}&lt;/td&gt;
352      * &lt;/tr&gt;
353      * &lt;tr&gt;
354      * &lt;th scope=&quot;row&quot;&gt;maxSize&lt;/th&gt;
355      * &lt;td&gt;{@code Long}&lt;/td&gt;
356      * &lt;/tr&gt;
357      * &lt;tr&gt;
358      * &lt;th scope=&quot;row&quot;&gt;startTime&lt;/th&gt;
359      * &lt;td&gt;{@code Long}&lt;/td&gt;
360      * &lt;/tr&gt;
361      * &lt;tr&gt;
362      * &lt;th scope=&quot;row&quot;&gt;stopTime&lt;/th&gt;
363      * &lt;td&gt;{@code Long}&lt;/td&gt;
364      * &lt;/tr&gt;
365      * &lt;tr&gt;
366      * &lt;th scope=&quot;row&quot;&gt;destination&lt;/th&gt;
367      * &lt;td&gt;{@code String}&lt;/td&gt;
368      * &lt;/tr&gt;
369      * &lt;tr&gt;
370      * &lt;th scope=&quot;row&quot;&gt;duration&lt;/th&gt;
371      * &lt;td&gt;{@code Long}&lt;/td&gt;
372      * &lt;/tr&gt;
373      * &lt;tr&gt;
374      * &lt;th scope=&quot;row&quot;&gt;settings&lt;/th&gt;
375      * &lt;td&gt;{@code javax.management.openmbean.CompositeData[]} whose element type
376      * is the mapped type for {@link SettingDescriptorInfo} as specified in the
377      * {@link SettingDescriptorInfo#from} method.&lt;/td&gt;
378      * &lt;/tr&gt;
379      * &lt;/tbody&gt;
380      * &lt;/table&gt;
381      * &lt;/blockquote&gt;
382      *
383      * @param cd {@code CompositeData} representing the {@code RecordingInfo} to
384      *        return
385      *
386      * @throws IllegalArgumentException if {@code cd} does not represent a valid
387      *         {@code RecordingInfo}
388      *
389      * @return the {@code RecordingInfo} represented by {@code cd}, or
390      *         {@code null} if {@code cd} is {@code null}
391      */
392     public static RecordingInfo from(CompositeData cd) {
393         if (cd == null) {
394             return null;
395         }
396         return new RecordingInfo(cd);
397     }
398 }
    </pre>
  </body>
</html>
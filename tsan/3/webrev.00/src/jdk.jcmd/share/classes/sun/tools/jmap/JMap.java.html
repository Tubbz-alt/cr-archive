<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jcmd/share/classes/sun/tools/jmap/JMap.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.tools.jmap;
 27 
 28 import java.io.File;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.UnsupportedEncodingException;
 32 import java.util.Collection;
 33 
 34 import com.sun.tools.attach.VirtualMachine;
 35 import com.sun.tools.attach.VirtualMachineDescriptor;
 36 import com.sun.tools.attach.AttachNotSupportedException;
 37 import sun.tools.attach.HotSpotVirtualMachine;
 38 import sun.tools.common.ProcessArgumentMatcher;
 39 
 40 /*
 41  * This class is the main class for the JMap utility. It parses its arguments
 42  * and decides if the command should be satisfied using the VM attach mechanism
 43  * or an SA tool. At this time the only option that uses the VM attach mechanism
 44  * is the -dump option to get a heap dump of a running application. All other
 45  * options are mapped to SA tools.
 46  */
 47 public class JMap {
 48 
 49     public static void main(String[] args) throws Exception {
 50         if (args.length == 0) {
 51             usage(1); // no arguments
 52         }
 53 
 54         checkForUnsupportedOptions(args);
 55 
 56         // the chosen option
 57         String option = null;
 58 
 59         // First iterate over the options (arguments starting with -).  There should be
 60         // one.
 61         int optionCount = 0;
 62         while (optionCount &lt; args.length) {
 63             String arg = args[optionCount];
 64             if (!arg.startsWith(&quot;-&quot;)) {
 65                 break;
 66             }
 67             if (arg.equals(&quot;-?&quot;) ||
 68                 arg.equals(&quot;-h&quot;) ||
 69                 arg.equals(&quot;--help&quot;) ||
 70                 // -help: legacy. Undocumented.
 71                 arg.equals(&quot;-help&quot;)) {
 72                 usage(0);
 73             } else {
 74                 if (option != null) {
 75                     usage(1);  // option already specified
 76                 }
 77                 option = arg;
 78             }
 79             optionCount++;
 80         }
 81 
 82         // if no option provided then use default.
 83         if (option == null) {
 84             usage(0);
 85         }
 86 
 87         // Next we check the parameter count.
 88         int paramCount = args.length - optionCount;
 89         if (paramCount != 1) {
 90             usage(1);
 91         }
 92 
 93         String pidArg = args[1];
 94         // Here we handle the built-in options
 95         // As more options are added we should create an abstract tool class and
 96         // have a table to map the options
 97         ProcessArgumentMatcher ap = new ProcessArgumentMatcher(pidArg);
 98         Collection&lt;String&gt; pids = ap.getVirtualMachinePids(JMap.class);
 99 
100         if (pids.isEmpty()) {
101             System.err.println(&quot;Could not find any processes matching : &#39;&quot; + pidArg + &quot;&#39;&quot;);
102             System.exit(1);
103         }
104 
105         for (String pid : pids) {
106             if (pids.size() &gt; 1) {
107                 System.out.println(&quot;Pid:&quot; + pid);
108             }
109             if (option.equals(&quot;-histo&quot;)) {
110                 histo(pid, &quot;&quot;);
111             } else if (option.startsWith(&quot;-histo:&quot;)) {
112                 histo(pid, option.substring(&quot;-histo:&quot;.length()));
113             } else if (option.startsWith(&quot;-dump:&quot;)) {
114                 dump(pid, option.substring(&quot;-dump:&quot;.length()));
115             } else if (option.equals(&quot;-finalizerinfo&quot;)) {
116                 executeCommandForPid(pid, &quot;jcmd&quot;, &quot;GC.finalizer_info&quot;);
117             } else if (option.equals(&quot;-clstats&quot;)) {
118                 executeCommandForPid(pid, &quot;jcmd&quot;, &quot;VM.classloader_stats&quot;);
119             } else {
120               usage(1);
121             }
122         }
123     }
124 
125     private static void executeCommandForPid(String pid, String command, Object ... args)
126         throws AttachNotSupportedException, IOException,
127                UnsupportedEncodingException {
128         VirtualMachine vm = VirtualMachine.attach(pid);
129 
130         // Cast to HotSpotVirtualMachine as this is an
131         // implementation specific method.
132         HotSpotVirtualMachine hvm = (HotSpotVirtualMachine) vm;
133         try (InputStream in = hvm.executeCommand(command, args)) {
134           // read to EOF and just print output
135           byte b[] = new byte[256];
136           int n;
137           do {
138               n = in.read(b);
139               if (n &gt; 0) {
140                   String s = new String(b, 0, n, &quot;UTF-8&quot;);
141                   System.out.print(s);
142               }
143           } while (n &gt; 0);
144         }
145         vm.detach();
146     }
147 
148     private static String parseFileName(String opt) {
149         // opt starts with &quot;file=&quot;
150         if (opt.length() &gt; 5) {
151             //  pass whole &quot;file=&quot; string
152             String filename = opt.substring(5);
153             try {
154                 // Get the canonical path - important to avoid just
155                 // passing a &quot;heap.bin&quot; and having the dump created
156                 // in the target VM working directory rather than the
157                 // directory where jmap is executed.
158                 return new File(filename).getCanonicalPath();
159             } catch (IOException ioe) {
160               return null;
161             }
162         }
163         // no filename
164         return null;
165     }
166 
167     private static void histo(String pid, String options)
168         throws AttachNotSupportedException, IOException,
169                UnsupportedEncodingException {
170         String liveopt = &quot;-all&quot;;
171         String filename = null;
172         String subopts[] = options.split(&quot;,&quot;);
173 
174         for (int i = 0; i &lt; subopts.length; i++) {
175             String subopt = subopts[i];
176             if (subopt.equals(&quot;&quot;) || subopt.equals(&quot;all&quot;)) {
177                 // pass
178             } else if (subopt.equals(&quot;live&quot;)) {
179                 liveopt = &quot;-live&quot;;
180             } else if (subopt.startsWith(&quot;file=&quot;)) {
181                 filename = parseFileName(subopt);
182                 if (filename == null) {
183                     usage(1); // invalid options or no filename
184                 }
185             } else {
186                 usage(1);
187             }
188         }
189 
190         System.out.flush();
191 
192         // inspectHeap is not the same as jcmd GC.class_histogram
193         executeCommandForPid(pid, &quot;inspectheap&quot;, liveopt, filename);
194     }
195 
196     private static void dump(String pid, String options)
197         throws AttachNotSupportedException, IOException,
198                UnsupportedEncodingException {
199 
200         String subopts[] = options.split(&quot;,&quot;);
201         String filename = null;
202         String liveopt = &quot;-all&quot;;
203 
204         for (int i = 0; i &lt; subopts.length; i++) {
205             String subopt = subopts[i];
206             if (subopt.equals(&quot;live&quot;)) {
207                 liveopt = &quot;-live&quot;;
208             } else if (subopt.startsWith(&quot;file=&quot;)) {
209                 filename = parseFileName(subopt);
210             }
211         }
212 
213         if (filename == null) {
214             usage(1);  // invalid options or no filename
215         }
216 
217         // dumpHeap is not the same as jcmd GC.heap_dump
218         executeCommandForPid(pid, &quot;dumpheap&quot;, filename, liveopt);
219     }
220 
221     private static void checkForUnsupportedOptions(String[] args) {
222         // Check arguments for -F, -m, and non-numeric value
223         // and warn the user that SA is not supported anymore
224 
225         int paramCount = 0;
226 
227         for (String s : args) {
228             if (s.equals(&quot;-F&quot;)) {
229                 SAOptionError(&quot;-F option used&quot;);
230             }
231 
232             if (s.equals(&quot;-heap&quot;)) {
233                 SAOptionError(&quot;-heap option used&quot;);
234             }
235 
236             /* Reimplemented using jcmd, output format is different
237                from original one
238 
239             if (s.equals(&quot;-clstats&quot;)) {
240                 warnSA(&quot;-clstats option used&quot;);
241             }
242 
243             if (s.equals(&quot;-finalizerinfo&quot;)) {
244                 warnSA(&quot;-finalizerinfo option used&quot;);
245             }
246             */
247 
248             if (! s.startsWith(&quot;-&quot;)) {
249                 paramCount += 1;
250             }
251         }
252 
253         if (paramCount &gt; 1) {
254             SAOptionError(&quot;More than one non-option argument&quot;);
255         }
256     }
257 
258     private static void SAOptionError(String msg) {
259         System.err.println(&quot;Error: &quot; + msg);
260         System.err.println(&quot;Cannot connect to core dump or remote debug server. Use jhsdb jmap instead&quot;);
261         System.exit(1);
262     }
263 
264     // print usage message
265     private static void usage(int exit) {
266         System.err.println(&quot;Usage:&quot;);
267         System.err.println(&quot;    jmap -clstats &lt;pid&gt;&quot;);
268         System.err.println(&quot;        to connect to running process and print class loader statistics&quot;);
269         System.err.println(&quot;    jmap -finalizerinfo &lt;pid&gt;&quot;);
270         System.err.println(&quot;        to connect to running process and print information on objects awaiting finalization&quot;);
271         System.err.println(&quot;    jmap -histo[:[&lt;histo-options&gt;]] &lt;pid&gt;&quot;);
272         System.err.println(&quot;        to connect to running process and print histogram of java object heap&quot;);
273         System.err.println(&quot;    jmap -dump:&lt;dump-options&gt; &lt;pid&gt;&quot;);
274         System.err.println(&quot;        to connect to running process and dump java heap&quot;);
275         System.err.println(&quot;    jmap -? -h --help&quot;);
276         System.err.println(&quot;        to print this help message&quot;);
277         System.err.println(&quot;&quot;);
278         System.err.println(&quot;    dump-options:&quot;);
279         System.err.println(&quot;      live         dump only live objects&quot;);
280         System.err.println(&quot;      all          dump all objects in the heap (default if one of \&quot;live\&quot; or \&quot;all\&quot; is not specified&quot;);
281         System.err.println(&quot;      format=b     binary format&quot;);
282         System.err.println(&quot;      file=&lt;file&gt;  dump heap to &lt;file&gt;&quot;);
283         System.err.println(&quot;&quot;);
284         System.err.println(&quot;    Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;&quot;);
285         System.err.println(&quot;&quot;);
286         System.err.println(&quot;    histo-options:&quot;);
287         System.err.println(&quot;      live         count only live objects&quot;);
288         System.err.println(&quot;      all          count all objects in the heap (default if one of \&quot;live\&quot; or \&quot;all\&quot; is not specified)&quot;);
289         System.err.println(&quot;      file=&lt;file&gt;  dump data to &lt;file&gt;&quot;);
290         System.err.println(&quot;&quot;);
291         System.err.println(&quot;    Example: jmap -histo:live,file=/tmp/histo.data &lt;pid&gt;&quot;);
292         System.exit(exit);
293     }
294 }
    </pre>
  </body>
</html>
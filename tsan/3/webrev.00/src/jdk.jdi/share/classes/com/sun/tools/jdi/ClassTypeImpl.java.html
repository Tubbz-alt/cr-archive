<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdi/share/classes/com/sun/tools/jdi/ClassTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.jdi;
 27 
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import com.sun.jdi.ClassNotLoadedException;
 32 import com.sun.jdi.ClassType;
 33 import com.sun.jdi.Field;
 34 import com.sun.jdi.IncompatibleThreadStateException;
 35 import com.sun.jdi.InterfaceType;
 36 import com.sun.jdi.InvalidTypeException;
 37 import com.sun.jdi.InvocationException;
 38 import com.sun.jdi.Method;
 39 import com.sun.jdi.ObjectReference;
 40 import com.sun.jdi.ReferenceType;
 41 import com.sun.jdi.ThreadReference;
 42 import com.sun.jdi.Value;
 43 import com.sun.jdi.VirtualMachine;
 44 
 45 final public class ClassTypeImpl extends InvokableTypeImpl
 46                                  implements ClassType
 47 {
 48     private static class IResult implements InvocationResult {
 49         final private JDWP.ClassType.InvokeMethod rslt;
 50 
 51         public IResult(JDWP.ClassType.InvokeMethod rslt) {
 52             this.rslt = rslt;
 53         }
 54 
 55         @Override
 56         public ObjectReferenceImpl getException() {
 57             return rslt.exception;
 58         }
 59 
 60         @Override
 61         public ValueImpl getResult() {
 62             return rslt.returnValue;
 63         }
 64     }
 65 
 66     private boolean cachedSuperclass = false;
 67     private ClassType superclass = null;
 68     private List&lt;InterfaceType&gt; interfaces = null;
 69 
 70     protected ClassTypeImpl(VirtualMachine aVm, long aRef) {
 71         super(aVm, aRef);
 72     }
 73 
 74     public ClassType superclass() {
 75         if (!cachedSuperclass)  {
 76             ClassTypeImpl sup = null;
 77             try {
 78                 sup = JDWP.ClassType.Superclass.
 79                     process(vm, this).superclass;
 80             } catch (JDWPException exc) {
 81                 throw exc.toJDIException();
 82             }
 83 
 84             /*
 85              * If there is a superclass, cache its
 86              * ClassType here. Otherwise,
 87              * leave the cache reference null.
 88              */
 89             if (sup != null) {
 90                 superclass = sup;
 91             }
 92             cachedSuperclass = true;
 93         }
 94 
 95         return superclass;
 96     }
 97 
 98     @Override
 99     public List&lt;InterfaceType&gt; interfaces()  {
100         if (interfaces == null) {
101             interfaces = getInterfaces();
102         }
103         return interfaces;
104     }
105 
106     @Override
107     public List&lt;InterfaceType&gt; allInterfaces() {
108         return getAllInterfaces();
109     }
110 
111     public List&lt;ClassType&gt; subclasses() {
112         List&lt;ClassType&gt; subs = new ArrayList&lt;&gt;();
113         vm.forEachClass(refType -&gt; {
114             if (refType instanceof ClassType) {
115                 ClassType clazz = (ClassType)refType;
116                 ClassType superclass = clazz.superclass();
117                 if ((superclass != null) &amp;&amp; superclass.equals(this)) {
118                     subs.add(clazz);
119                 }
120             }
121         });
122         return subs;
123     }
124 
125     public boolean isEnum() {
126         ClassType superclass = superclass();
127         if (superclass != null &amp;&amp;
128             superclass.name().equals(&quot;java.lang.Enum&quot;)) {
129             return true;
130         }
131         return false;
132     }
133 
134     public void setValue(Field field, Value value)
135         throws InvalidTypeException, ClassNotLoadedException {
136 
137         validateMirror(field);
138         validateMirrorOrNull(value);
139         validateFieldSet(field);
140 
141         // More validation specific to setting from a ClassType
142         if(!field.isStatic()) {
143             throw new IllegalArgumentException(
144                             &quot;Must set non-static field through an instance&quot;);
145         }
146 
147         try {
148             JDWP.ClassType.SetValues.FieldValue[] values =
149                           new JDWP.ClassType.SetValues.FieldValue[1];
150             values[0] = new JDWP.ClassType.SetValues.FieldValue(
151                     ((FieldImpl)field).ref(),
152                     // validate and convert if necessary
153                     ValueImpl.prepareForAssignment(value, (FieldImpl)field));
154 
155             try {
156                 JDWP.ClassType.SetValues.process(vm, this, values);
157             } catch (JDWPException exc) {
158                 throw exc.toJDIException();
159             }
160         } catch (ClassNotLoadedException e) {
161             /*
162              * Since we got this exception,
163              * the field type must be a reference type. The value
164              * we&#39;re trying to set is null, but if the field&#39;s
165              * class has not yet been loaded through the enclosing
166              * class loader, then setting to null is essentially a
167              * no-op, and we should allow it without an exception.
168              */
169             if (value != null) {
170                 throw e;
171             }
172         }
173     }
174 
175     PacketStream sendNewInstanceCommand(final ThreadReferenceImpl thread,
176                                         final MethodImpl method,
177                                         final ValueImpl[] args,
178                                         final int options) {
179         CommandSender sender =
180             new CommandSender() {
181                 public PacketStream send() {
182                     return JDWP.ClassType.NewInstance.enqueueCommand(
183                                           vm, ClassTypeImpl.this, thread,
184                                           method.ref(), args, options);
185                 }
186         };
187 
188         PacketStream stream;
189         if ((options &amp; INVOKE_SINGLE_THREADED) != 0) {
190             stream = thread.sendResumingCommand(sender);
191         } else {
192             stream = vm.sendResumingCommand(sender);
193         }
194         return stream;
195     }
196 
197     public ObjectReference newInstance(ThreadReference threadIntf,
198                                        Method methodIntf,
199                                        List&lt;? extends Value&gt; origArguments,
200                                        int options)
201                                    throws InvalidTypeException,
202                                           ClassNotLoadedException,
203                                           IncompatibleThreadStateException,
204                                           InvocationException {
205         validateMirror(threadIntf);
206         validateMirror(methodIntf);
207         validateMirrorsOrNulls(origArguments);
208 
209         MethodImpl method = (MethodImpl)methodIntf;
210         ThreadReferenceImpl thread = (ThreadReferenceImpl)threadIntf;
211 
212         validateConstructorInvocation(method);
213 
214         List&lt;Value&gt; arguments = method.validateAndPrepareArgumentsForInvoke(
215                                                        origArguments);
216         ValueImpl[] args = arguments.toArray(new ValueImpl[0]);
217         JDWP.ClassType.NewInstance ret = null;
218         try {
219             PacketStream stream =
220                 sendNewInstanceCommand(thread, method, args, options);
221             ret = JDWP.ClassType.NewInstance.waitForReply(vm, stream);
222         } catch (JDWPException exc) {
223             if (exc.errorCode() == JDWP.Error.INVALID_THREAD) {
224                 throw new IncompatibleThreadStateException();
225             } else {
226                 throw exc.toJDIException();
227             }
228         }
229 
230         /*
231          * There is an implict VM-wide suspend at the conclusion
232          * of a normal (non-single-threaded) method invoke
233          */
234         if ((options &amp; INVOKE_SINGLE_THREADED) == 0) {
235             vm.notifySuspend();
236         }
237 
238         if (ret.exception != null) {
239             throw new InvocationException(ret.exception);
240         } else {
241             return ret.newObject;
242         }
243     }
244 
245     public Method concreteMethodByName(String name, String signature)  {
246         Method method = null;
247         for (Method candidate : visibleMethods()) {
248             if (candidate.name().equals(name) &amp;&amp;
249                 candidate.signature().equals(signature) &amp;&amp;
250                 !candidate.isAbstract()) {
251 
252                 method = candidate;
253                 break;
254             }
255         }
256         return method;
257     }
258 
259     void validateConstructorInvocation(Method method)
260                                    throws InvalidTypeException,
261                                           InvocationException {
262         /*
263          * Method must be in this class.
264          */
265         ReferenceTypeImpl declType = (ReferenceTypeImpl)method.declaringType();
266         if (!declType.equals(this)) {
267             throw new IllegalArgumentException(&quot;Invalid constructor&quot;);
268         }
269 
270         /*
271          * Method must be a constructor
272          */
273         if (!method.isConstructor()) {
274             throw new IllegalArgumentException(&quot;Cannot create instance with non-constructor&quot;);
275         }
276     }
277 
278     public String toString() {
279        return &quot;class &quot; + name() + &quot; (&quot; + loaderString() + &quot;)&quot;;
280     }
281 
282     @Override
283     CommandSender getInvokeMethodSender(ThreadReferenceImpl thread,
284                                         MethodImpl method,
285                                         ValueImpl[] args,
286                                         int options) {
287         return () -&gt;
288             JDWP.ClassType.InvokeMethod.enqueueCommand(vm,
289                                                        ClassTypeImpl.this,
290                                                        thread,
291                                                        method.ref(),
292                                                        args,
293                                                        options);
294     }
295 
296     @Override
297     InvocationResult waitForReply(PacketStream stream) throws JDWPException {
298         return new IResult(JDWP.ClassType.InvokeMethod.waitForReply(vm, stream));
299     }
300 
301     @Override
302     boolean canInvoke(Method method) {
303         // Method must be in this class or a superclass.
304         return ((ReferenceTypeImpl)method.declaringType()).isAssignableFrom(this);
305     }
306 }
    </pre>
  </body>
</html>
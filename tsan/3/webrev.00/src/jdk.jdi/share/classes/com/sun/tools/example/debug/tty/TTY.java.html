<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdi/share/classes/com/sun/tools/example/debug/tty/TTY.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This source code is provided to illustrate the usage of a given feature
  28  * or technique and has been deliberately simplified. Additional steps
  29  * required for a production-quality application, such as security checks,
  30  * input validation and proper error handling, might not be present in
  31  * this sample code.
  32  */
  33 
  34 
  35 package com.sun.tools.example.debug.tty;
  36 
  37 import com.sun.jdi.*;
  38 import com.sun.jdi.event.*;
  39 import com.sun.jdi.request.*;
  40 import com.sun.jdi.connect.*;
  41 
  42 import java.util.*;
  43 import java.util.concurrent.CopyOnWriteArrayList;
  44 import java.io.*;
  45 
  46 public class TTY implements EventNotifier {
  47     EventHandler handler = null;
  48 
  49     /**
  50      * List of Strings to execute at each stop.
  51      */
  52     private List&lt;String&gt; monitorCommands = new CopyOnWriteArrayList&lt;&gt;();
  53     private int monitorCount = 0;
  54 
  55     /**
  56      * The name of this tool.
  57      */
  58     private static final String progname = &quot;jdb&quot;;
  59 
  60     private volatile boolean shuttingDown = false;
  61 
  62     public void setShuttingDown(boolean s) {
  63        shuttingDown = s;
  64     }
  65 
  66     public boolean isShuttingDown() {
  67         return shuttingDown;
  68     }
  69 
  70     @Override
  71     public void vmStartEvent(VMStartEvent se)  {
  72         Thread.yield();  // fetch output
  73         MessageOutput.lnprint(&quot;VM Started:&quot;);
  74     }
  75 
  76     @Override
  77     public void vmDeathEvent(VMDeathEvent e)  {
  78     }
  79 
  80     @Override
  81     public void vmDisconnectEvent(VMDisconnectEvent e)  {
  82     }
  83 
  84     @Override
  85     public void threadStartEvent(ThreadStartEvent e)  {
  86     }
  87 
  88     @Override
  89     public void threadDeathEvent(ThreadDeathEvent e)  {
  90     }
  91 
  92     @Override
  93     public void classPrepareEvent(ClassPrepareEvent e)  {
  94     }
  95 
  96     @Override
  97     public void classUnloadEvent(ClassUnloadEvent e)  {
  98     }
  99 
 100     @Override
 101     public void breakpointEvent(BreakpointEvent be)  {
 102         Thread.yield();  // fetch output
 103         MessageOutput.lnprint(&quot;Breakpoint hit:&quot;);
 104         // Print breakpoint location and prompt if suspend policy is
 105         // SUSPEND_NONE or SUSPEND_EVENT_THREAD. In case of SUSPEND_ALL
 106         // policy this is handled by vmInterrupted() method.
 107         int suspendPolicy = be.request().suspendPolicy();
 108         switch (suspendPolicy) {
 109             case EventRequest.SUSPEND_EVENT_THREAD:
 110             case EventRequest.SUSPEND_NONE:
 111                 printBreakpointLocation(be);
 112                 MessageOutput.printPrompt();
 113                 break;
 114         }
 115     }
 116 
 117     @Override
 118     public void fieldWatchEvent(WatchpointEvent fwe)  {
 119         Field field = fwe.field();
 120         ObjectReference obj = fwe.object();
 121         Thread.yield();  // fetch output
 122 
 123         if (fwe instanceof ModificationWatchpointEvent) {
 124             MessageOutput.lnprint(&quot;Field access encountered before after&quot;,
 125                                   new Object [] {field,
 126                                                  fwe.valueCurrent(),
 127                                                  ((ModificationWatchpointEvent)fwe).valueToBe()});
 128         } else {
 129             MessageOutput.lnprint(&quot;Field access encountered&quot;, field.toString());
 130         }
 131     }
 132 
 133     @Override
 134     public void stepEvent(StepEvent se)  {
 135         Thread.yield();  // fetch output
 136         MessageOutput.lnprint(&quot;Step completed:&quot;);
 137     }
 138 
 139     @Override
 140     public void exceptionEvent(ExceptionEvent ee) {
 141         Thread.yield();  // fetch output
 142         Location catchLocation = ee.catchLocation();
 143         if (catchLocation == null) {
 144             MessageOutput.lnprint(&quot;Exception occurred uncaught&quot;,
 145                                   ee.exception().referenceType().name());
 146         } else {
 147             MessageOutput.lnprint(&quot;Exception occurred caught&quot;,
 148                                   new Object [] {ee.exception().referenceType().name(),
 149                                                  Commands.locationString(catchLocation)});
 150         }
 151     }
 152 
 153     @Override
 154     public void methodEntryEvent(MethodEntryEvent me) {
 155         Thread.yield();  // fetch output
 156         /*
 157          * These can be very numerous, so be as efficient as possible.
 158          * If we are stopping here, then we will see the normal location
 159          * info printed.
 160          */
 161         if (me.request().suspendPolicy() != EventRequest.SUSPEND_NONE) {
 162             // We are stopping; the name will be shown by the normal mechanism
 163             MessageOutput.lnprint(&quot;Method entered:&quot;);
 164         } else {
 165             // We aren&#39;t stopping, show the name
 166             MessageOutput.print(&quot;Method entered:&quot;);
 167             printLocationOfEvent(me);
 168         }
 169     }
 170 
 171     @Override
 172     public boolean methodExitEvent(MethodExitEvent me) {
 173         Thread.yield();  // fetch output
 174         /*
 175          * These can be very numerous, so be as efficient as possible.
 176          */
 177         Method mmm = Env.atExitMethod();
 178         Method meMethod = me.method();
 179 
 180         if (mmm == null || mmm.equals(meMethod)) {
 181             // Either we are not tracing a specific method, or we are
 182             // and we are exitting that method.
 183 
 184             if (me.request().suspendPolicy() != EventRequest.SUSPEND_NONE) {
 185                 // We will be stopping here, so do a newline
 186                 MessageOutput.println();
 187             }
 188             if (Env.vm().canGetMethodReturnValues()) {
 189                 MessageOutput.print(&quot;Method exitedValue:&quot;, me.returnValue() + &quot;&quot;);
 190             } else {
 191                 MessageOutput.print(&quot;Method exited:&quot;);
 192             }
 193 
 194             if (me.request().suspendPolicy() == EventRequest.SUSPEND_NONE) {
 195                 // We won&#39;t be stopping here, so show the method name
 196                 printLocationOfEvent(me);
 197 
 198             }
 199 
 200             // In case we want to have a one shot trace exit some day, this
 201             // code disables the request so we don&#39;t hit it again.
 202             if (false) {
 203                 // This is a one shot deal; we don&#39;t want to stop
 204                 // here the next time.
 205                 Env.setAtExitMethod(null);
 206                 EventRequestManager erm = Env.vm().eventRequestManager();
 207                 for (EventRequest eReq : erm.methodExitRequests()) {
 208                     if (eReq.equals(me.request())) {
 209                         eReq.disable();
 210                     }
 211                 }
 212             }
 213             return true;
 214         }
 215 
 216         // We are tracing a specific method, and this isn&#39;t it.  Keep going.
 217         return false;
 218     }
 219 
 220     @Override
 221     public void vmInterrupted() {
 222         Thread.yield();  // fetch output
 223         printCurrentLocation();
 224         for (String cmd : monitorCommands) {
 225             StringTokenizer t = new StringTokenizer(cmd);
 226             t.nextToken();  // get rid of monitor number
 227             executeCommand(t);
 228         }
 229         MessageOutput.printPrompt();
 230     }
 231 
 232     @Override
 233     public void receivedEvent(Event event) {
 234     }
 235 
 236     private void printBaseLocation(String threadName, Location loc) {
 237         MessageOutput.println(&quot;location&quot;,
 238                               new Object [] {threadName,
 239                                              Commands.locationString(loc)});
 240     }
 241 
 242     private void printBreakpointLocation(BreakpointEvent be) {
 243         printLocationWithSourceLine(be.thread().name(), be.location());
 244     }
 245 
 246     private void printCurrentLocation() {
 247         ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
 248         StackFrame frame;
 249         try {
 250             frame = threadInfo.getCurrentFrame();
 251         } catch (IncompatibleThreadStateException exc) {
 252             MessageOutput.println(&quot;&lt;location unavailable&gt;&quot;);
 253             return;
 254         }
 255         if (frame == null) {
 256             MessageOutput.println(&quot;No frames on the current call stack&quot;);
 257         } else {
 258             printLocationWithSourceLine(threadInfo.getThread().name(), frame.location());
 259         }
 260         MessageOutput.println();
 261     }
 262 
 263     private void printLocationWithSourceLine(String threadName, Location loc) {
 264         printBaseLocation(threadName, loc);
 265         // Output the current source line, if possible
 266         if (loc.lineNumber() != -1) {
 267             String line;
 268             try {
 269                 line = Env.sourceLine(loc, loc.lineNumber());
 270             } catch (java.io.IOException e) {
 271                 line = null;
 272             }
 273             if (line != null) {
 274                 MessageOutput.println(&quot;source line number and line&quot;,
 275                                            new Object [] {loc.lineNumber(),
 276                                                           line});
 277             }
 278         }
 279     }
 280 
 281     private void printLocationOfEvent(LocatableEvent theEvent) {
 282         printBaseLocation(theEvent.thread().name(), theEvent.location());
 283     }
 284 
 285     void help() {
 286         MessageOutput.println(&quot;zz help text&quot;);
 287     }
 288 
 289     private static final String[][] commandList = {
 290         /*
 291          * NOTE: this list must be kept sorted in ascending ASCII
 292          *       order by element [0].  Ref: isCommand() below.
 293          *
 294          *Command      OK when        OK when
 295          * name      disconnected?   readonly?
 296          *------------------------------------
 297          */
 298         {&quot;!!&quot;,           &quot;n&quot;,         &quot;y&quot;},
 299         {&quot;?&quot;,            &quot;y&quot;,         &quot;y&quot;},
 300         {&quot;bytecodes&quot;,    &quot;n&quot;,         &quot;y&quot;},
 301         {&quot;catch&quot;,        &quot;y&quot;,         &quot;n&quot;},
 302         {&quot;class&quot;,        &quot;n&quot;,         &quot;y&quot;},
 303         {&quot;classes&quot;,      &quot;n&quot;,         &quot;y&quot;},
 304         {&quot;classpath&quot;,    &quot;n&quot;,         &quot;y&quot;},
 305         {&quot;clear&quot;,        &quot;y&quot;,         &quot;n&quot;},
 306         {&quot;connectors&quot;,   &quot;y&quot;,         &quot;y&quot;},
 307         {&quot;cont&quot;,         &quot;n&quot;,         &quot;n&quot;},
 308         {&quot;dbgtrace&quot;,     &quot;y&quot;,         &quot;y&quot;},
 309         {&quot;disablegc&quot;,    &quot;n&quot;,         &quot;n&quot;},
 310         {&quot;down&quot;,         &quot;n&quot;,         &quot;y&quot;},
 311         {&quot;dump&quot;,         &quot;n&quot;,         &quot;y&quot;},
 312         {&quot;enablegc&quot;,     &quot;n&quot;,         &quot;n&quot;},
 313         {&quot;eval&quot;,         &quot;n&quot;,         &quot;y&quot;},
 314         {&quot;exclude&quot;,      &quot;y&quot;,         &quot;n&quot;},
 315         {&quot;exit&quot;,         &quot;y&quot;,         &quot;y&quot;},
 316         {&quot;extension&quot;,    &quot;n&quot;,         &quot;y&quot;},
 317         {&quot;fields&quot;,       &quot;n&quot;,         &quot;y&quot;},
 318         {&quot;gc&quot;,           &quot;n&quot;,         &quot;n&quot;},
 319         {&quot;help&quot;,         &quot;y&quot;,         &quot;y&quot;},
 320         {&quot;ignore&quot;,       &quot;y&quot;,         &quot;n&quot;},
 321         {&quot;interrupt&quot;,    &quot;n&quot;,         &quot;n&quot;},
 322         {&quot;kill&quot;,         &quot;n&quot;,         &quot;n&quot;},
 323         {&quot;lines&quot;,        &quot;n&quot;,         &quot;y&quot;},
 324         {&quot;list&quot;,         &quot;n&quot;,         &quot;y&quot;},
 325         {&quot;load&quot;,         &quot;n&quot;,         &quot;y&quot;},
 326         {&quot;locals&quot;,       &quot;n&quot;,         &quot;y&quot;},
 327         {&quot;lock&quot;,         &quot;n&quot;,         &quot;n&quot;},
 328         {&quot;memory&quot;,       &quot;n&quot;,         &quot;y&quot;},
 329         {&quot;methods&quot;,      &quot;n&quot;,         &quot;y&quot;},
 330         {&quot;monitor&quot;,      &quot;n&quot;,         &quot;n&quot;},
 331         {&quot;next&quot;,         &quot;n&quot;,         &quot;n&quot;},
 332         {&quot;pop&quot;,          &quot;n&quot;,         &quot;n&quot;},
 333         {&quot;print&quot;,        &quot;n&quot;,         &quot;y&quot;},
 334         {&quot;quit&quot;,         &quot;y&quot;,         &quot;y&quot;},
 335         {&quot;read&quot;,         &quot;y&quot;,         &quot;y&quot;},
 336         {&quot;redefine&quot;,     &quot;n&quot;,         &quot;n&quot;},
 337         {&quot;reenter&quot;,      &quot;n&quot;,         &quot;n&quot;},
 338         {&quot;resume&quot;,       &quot;n&quot;,         &quot;n&quot;},
 339         {&quot;run&quot;,          &quot;y&quot;,         &quot;n&quot;},
 340         {&quot;save&quot;,         &quot;n&quot;,         &quot;n&quot;},
 341         {&quot;set&quot;,          &quot;n&quot;,         &quot;n&quot;},
 342         {&quot;sourcepath&quot;,   &quot;y&quot;,         &quot;y&quot;},
 343         {&quot;step&quot;,         &quot;n&quot;,         &quot;n&quot;},
 344         {&quot;stepi&quot;,        &quot;n&quot;,         &quot;n&quot;},
 345         {&quot;stop&quot;,         &quot;y&quot;,         &quot;n&quot;},
 346         {&quot;suspend&quot;,      &quot;n&quot;,         &quot;n&quot;},
 347         {&quot;thread&quot;,       &quot;n&quot;,         &quot;y&quot;},
 348         {&quot;threadgroup&quot;,  &quot;n&quot;,         &quot;y&quot;},
 349         {&quot;threadgroups&quot;, &quot;n&quot;,         &quot;y&quot;},
 350         {&quot;threadlocks&quot;,  &quot;n&quot;,         &quot;y&quot;},
 351         {&quot;threads&quot;,      &quot;n&quot;,         &quot;y&quot;},
 352         {&quot;trace&quot;,        &quot;n&quot;,         &quot;n&quot;},
 353         {&quot;unmonitor&quot;,    &quot;n&quot;,         &quot;n&quot;},
 354         {&quot;untrace&quot;,      &quot;n&quot;,         &quot;n&quot;},
 355         {&quot;unwatch&quot;,      &quot;y&quot;,         &quot;n&quot;},
 356         {&quot;up&quot;,           &quot;n&quot;,         &quot;y&quot;},
 357         {&quot;use&quot;,          &quot;y&quot;,         &quot;y&quot;},
 358         {&quot;version&quot;,      &quot;y&quot;,         &quot;y&quot;},
 359         {&quot;watch&quot;,        &quot;y&quot;,         &quot;n&quot;},
 360         {&quot;where&quot;,        &quot;n&quot;,         &quot;y&quot;},
 361         {&quot;wherei&quot;,       &quot;n&quot;,         &quot;y&quot;},
 362     };
 363 
 364     /*
 365      * Look up the command string in commandList.
 366      * If found, return the index.
 367      * If not found, return index &lt; 0
 368      */
 369     private int isCommand(String key) {
 370         //Reference: binarySearch() in java/util/Arrays.java
 371         //           Adapted for use with String[][0].
 372         int low = 0;
 373         int high = commandList.length - 1;
 374         while (low &lt;= high) {
 375             int mid = (low + high) &gt;&gt;&gt; 1;
 376             String midVal = commandList[mid][0];
 377             int compare = midVal.compareTo(key);
 378             if (compare &lt; 0) {
 379                 low = mid + 1;
 380             } else if (compare &gt; 0) {
 381                 high = mid - 1;
 382             }
 383             else {
 384                 return mid; // key found
 385         }
 386         }
 387         return -(low + 1);  // key not found.
 388     };
 389 
 390     /*
 391      * Return true if the command is OK when disconnected.
 392      */
 393     private boolean isDisconnectCmd(int ii) {
 394         if (ii &lt; 0 || ii &gt;= commandList.length) {
 395             return false;
 396         }
 397         return (commandList[ii][1].equals(&quot;y&quot;));
 398     }
 399 
 400     /*
 401      * Return true if the command is OK when readonly.
 402      */
 403     private boolean isReadOnlyCmd(int ii) {
 404         if (ii &lt; 0 || ii &gt;= commandList.length) {
 405             return false;
 406         }
 407         return (commandList[ii][2].equals(&quot;y&quot;));
 408     };
 409 
 410 
 411     void executeCommand(StringTokenizer t) {
 412         String cmd = t.nextToken().toLowerCase();
 413         // Normally, prompt for the next command after this one is done
 414         boolean showPrompt = true;
 415 
 416 
 417         /*
 418          * Anything starting with # is discarded as a no-op or &#39;comment&#39;.
 419          */
 420         if (!cmd.startsWith(&quot;#&quot;)) {
 421             /*
 422              * Next check for an integer repetition prefix.  If found,
 423              * recursively execute cmd that number of times.
 424              */
 425             if (Character.isDigit(cmd.charAt(0)) &amp;&amp; t.hasMoreTokens()) {
 426                 try {
 427                     int repeat = Integer.parseInt(cmd);
 428                     String subcom = t.nextToken(&quot;&quot;);
 429                     while (repeat-- &gt; 0) {
 430                         executeCommand(new StringTokenizer(subcom));
 431                         showPrompt = false; // Bypass the printPrompt() below.
 432                     }
 433                 } catch (NumberFormatException exc) {
 434                     MessageOutput.println(&quot;Unrecognized command.  Try help...&quot;, cmd);
 435                 }
 436             } else {
 437                 int commandNumber = isCommand(cmd);
 438                 /*
 439                  * Check for an unknown command
 440                  */
 441                 if (commandNumber &lt; 0) {
 442                     MessageOutput.println(&quot;Unrecognized command.  Try help...&quot;, cmd);
 443                 } else if (!Env.connection().isOpen() &amp;&amp; !isDisconnectCmd(commandNumber)) {
 444                     MessageOutput.println(&quot;Command not valid until the VM is started with the run command&quot;,
 445                                           cmd);
 446                 } else if (Env.connection().isOpen() &amp;&amp; !Env.vm().canBeModified() &amp;&amp;
 447                            !isReadOnlyCmd(commandNumber)) {
 448                     MessageOutput.println(&quot;Command is not supported on a read-only VM connection&quot;,
 449                                           cmd);
 450                 } else {
 451 
 452                     Commands evaluator = new Commands();
 453                     try {
 454                         if (cmd.equals(&quot;print&quot;)) {
 455                             evaluator.commandPrint(t, false);
 456                             showPrompt = false;        // asynchronous command
 457                         } else if (cmd.equals(&quot;eval&quot;)) {
 458                             evaluator.commandPrint(t, false);
 459                             showPrompt = false;        // asynchronous command
 460                         } else if (cmd.equals(&quot;set&quot;)) {
 461                             evaluator.commandSet(t);
 462                             showPrompt = false;        // asynchronous command
 463                         } else if (cmd.equals(&quot;dump&quot;)) {
 464                             evaluator.commandPrint(t, true);
 465                             showPrompt = false;        // asynchronous command
 466                         } else if (cmd.equals(&quot;locals&quot;)) {
 467                             evaluator.commandLocals();
 468                         } else if (cmd.equals(&quot;classes&quot;)) {
 469                             evaluator.commandClasses();
 470                         } else if (cmd.equals(&quot;class&quot;)) {
 471                             evaluator.commandClass(t);
 472                         } else if (cmd.equals(&quot;connectors&quot;)) {
 473                             evaluator.commandConnectors(Bootstrap.virtualMachineManager());
 474                         } else if (cmd.equals(&quot;methods&quot;)) {
 475                             evaluator.commandMethods(t);
 476                         } else if (cmd.equals(&quot;fields&quot;)) {
 477                             evaluator.commandFields(t);
 478                         } else if (cmd.equals(&quot;threads&quot;)) {
 479                             evaluator.commandThreads(t);
 480                         } else if (cmd.equals(&quot;thread&quot;)) {
 481                             evaluator.commandThread(t);
 482                         } else if (cmd.equals(&quot;suspend&quot;)) {
 483                             evaluator.commandSuspend(t);
 484                         } else if (cmd.equals(&quot;resume&quot;)) {
 485                             evaluator.commandResume(t);
 486                         } else if (cmd.equals(&quot;cont&quot;)) {
 487                             MessageOutput.printPrompt(true);
 488                             showPrompt = false;
 489                             evaluator.commandCont();
 490                         } else if (cmd.equals(&quot;threadgroups&quot;)) {
 491                             evaluator.commandThreadGroups();
 492                         } else if (cmd.equals(&quot;threadgroup&quot;)) {
 493                             evaluator.commandThreadGroup(t);
 494                         } else if (cmd.equals(&quot;catch&quot;)) {
 495                             evaluator.commandCatchException(t);
 496                         } else if (cmd.equals(&quot;ignore&quot;)) {
 497                             evaluator.commandIgnoreException(t);
 498                         } else if (cmd.equals(&quot;step&quot;)) {
 499                             MessageOutput.printPrompt(true);
 500                             showPrompt = false;
 501                             evaluator.commandStep(t);
 502                         } else if (cmd.equals(&quot;stepi&quot;)) {
 503                             MessageOutput.printPrompt(true);
 504                             showPrompt = false;
 505                             evaluator.commandStepi();
 506                         } else if (cmd.equals(&quot;next&quot;)) {
 507                             MessageOutput.printPrompt(true);
 508                             showPrompt = false;
 509                             evaluator.commandNext();
 510                         } else if (cmd.equals(&quot;kill&quot;)) {
 511                             showPrompt = false;        // asynchronous command
 512                             evaluator.commandKill(t);
 513                         } else if (cmd.equals(&quot;interrupt&quot;)) {
 514                             evaluator.commandInterrupt(t);
 515                         } else if (cmd.equals(&quot;trace&quot;)) {
 516                             evaluator.commandTrace(t);
 517                         } else if (cmd.equals(&quot;untrace&quot;)) {
 518                             evaluator.commandUntrace(t);
 519                         } else if (cmd.equals(&quot;where&quot;)) {
 520                             evaluator.commandWhere(t, false);
 521                         } else if (cmd.equals(&quot;wherei&quot;)) {
 522                             evaluator.commandWhere(t, true);
 523                         } else if (cmd.equals(&quot;up&quot;)) {
 524                             evaluator.commandUp(t);
 525                         } else if (cmd.equals(&quot;down&quot;)) {
 526                             evaluator.commandDown(t);
 527                         } else if (cmd.equals(&quot;load&quot;)) {
 528                             evaluator.commandLoad(t);
 529                         } else if (cmd.equals(&quot;run&quot;)) {
 530                             evaluator.commandRun(t);
 531                             /*
 532                              * Fire up an event handler, if the connection was just
 533                              * opened. Since this was done from the run command
 534                              * we don&#39;t stop the VM on its VM start event (so
 535                              * arg 2 is false).
 536                              */
 537                             if ((handler == null) &amp;&amp; Env.connection().isOpen()) {
 538                                 handler = new EventHandler(this, false);
 539                             }
 540                         } else if (cmd.equals(&quot;memory&quot;)) {
 541                             evaluator.commandMemory();
 542                         } else if (cmd.equals(&quot;gc&quot;)) {
 543                             evaluator.commandGC();
 544                         } else if (cmd.equals(&quot;stop&quot;)) {
 545                             evaluator.commandStop(t);
 546                         } else if (cmd.equals(&quot;clear&quot;)) {
 547                             evaluator.commandClear(t);
 548                         } else if (cmd.equals(&quot;watch&quot;)) {
 549                             evaluator.commandWatch(t);
 550                         } else if (cmd.equals(&quot;unwatch&quot;)) {
 551                             evaluator.commandUnwatch(t);
 552                         } else if (cmd.equals(&quot;list&quot;)) {
 553                             evaluator.commandList(t);
 554                         } else if (cmd.equals(&quot;lines&quot;)) { // Undocumented command: useful for testing.
 555                             evaluator.commandLines(t);
 556                         } else if (cmd.equals(&quot;classpath&quot;)) {
 557                             evaluator.commandClasspath(t);
 558                         } else if (cmd.equals(&quot;use&quot;) || cmd.equals(&quot;sourcepath&quot;)) {
 559                             evaluator.commandUse(t);
 560                         } else if (cmd.equals(&quot;monitor&quot;)) {
 561                             monitorCommand(t);
 562                         } else if (cmd.equals(&quot;unmonitor&quot;)) {
 563                             unmonitorCommand(t);
 564                         } else if (cmd.equals(&quot;lock&quot;)) {
 565                             evaluator.commandLock(t);
 566                             showPrompt = false;        // asynchronous command
 567                         } else if (cmd.equals(&quot;threadlocks&quot;)) {
 568                             evaluator.commandThreadlocks(t);
 569                         } else if (cmd.equals(&quot;disablegc&quot;)) {
 570                             evaluator.commandDisableGC(t);
 571                             showPrompt = false;        // asynchronous command
 572                         } else if (cmd.equals(&quot;enablegc&quot;)) {
 573                             evaluator.commandEnableGC(t);
 574                             showPrompt = false;        // asynchronous command
 575                         } else if (cmd.equals(&quot;save&quot;)) { // Undocumented command: useful for testing.
 576                             evaluator.commandSave(t);
 577                             showPrompt = false;        // asynchronous command
 578                         } else if (cmd.equals(&quot;bytecodes&quot;)) { // Undocumented command: useful for testing.
 579                             evaluator.commandBytecodes(t);
 580                         } else if (cmd.equals(&quot;redefine&quot;)) {
 581                             evaluator.commandRedefine(t);
 582                         } else if (cmd.equals(&quot;pop&quot;)) {
 583                             evaluator.commandPopFrames(t, false);
 584                         } else if (cmd.equals(&quot;reenter&quot;)) {
 585                             evaluator.commandPopFrames(t, true);
 586                         } else if (cmd.equals(&quot;extension&quot;)) {
 587                             evaluator.commandExtension(t);
 588                         } else if (cmd.equals(&quot;exclude&quot;)) {
 589                             evaluator.commandExclude(t);
 590                         } else if (cmd.equals(&quot;read&quot;)) {
 591                             readCommand(t);
 592                         } else if (cmd.equals(&quot;dbgtrace&quot;)) {
 593                             evaluator.commandDbgTrace(t);
 594                         } else if (cmd.equals(&quot;help&quot;) || cmd.equals(&quot;?&quot;)) {
 595                             help();
 596                         } else if (cmd.equals(&quot;version&quot;)) {
 597                             evaluator.commandVersion(progname,
 598                                                      Bootstrap.virtualMachineManager());
 599                         } else if (cmd.equals(&quot;quit&quot;) || cmd.equals(&quot;exit&quot;)) {
 600                             if (handler != null) {
 601                                 handler.shutdown();
 602                             }
 603                             Env.shutdown();
 604                         } else {
 605                             MessageOutput.println(&quot;Unrecognized command.  Try help...&quot;, cmd);
 606                         }
 607                     } catch (VMCannotBeModifiedException rovm) {
 608                         MessageOutput.println(&quot;Command is not supported on a read-only VM connection&quot;, cmd);
 609                     } catch (UnsupportedOperationException uoe) {
 610                         MessageOutput.println(&quot;Command is not supported on the target VM&quot;, cmd);
 611                     } catch (VMNotConnectedException vmnse) {
 612                         MessageOutput.println(&quot;Command not valid until the VM is started with the run command&quot;,
 613                                               cmd);
 614                     } catch (Exception e) {
 615                         MessageOutput.printException(&quot;Internal exception:&quot;, e);
 616                     }
 617                 }
 618             }
 619         }
 620         if (showPrompt) {
 621             MessageOutput.printPrompt();
 622         }
 623     }
 624 
 625     /*
 626      * Maintain a list of commands to execute each time the VM is suspended.
 627      */
 628     void monitorCommand(StringTokenizer t) {
 629         if (t.hasMoreTokens()) {
 630             ++monitorCount;
 631             monitorCommands.add(monitorCount + &quot;: &quot; + t.nextToken(&quot;&quot;));
 632         } else {
 633             for (String cmd : monitorCommands) {
 634                 MessageOutput.printDirectln(cmd);// Special case: use printDirectln()
 635             }
 636         }
 637     }
 638 
 639     void unmonitorCommand(StringTokenizer t) {
 640         if (t.hasMoreTokens()) {
 641             String monTok = t.nextToken();
 642             int monNum;
 643             try {
 644                 monNum = Integer.parseInt(monTok);
 645             } catch (NumberFormatException exc) {
 646                 MessageOutput.println(&quot;Not a monitor number:&quot;, monTok);
 647                 return;
 648             }
 649             String monStr = monTok + &quot;:&quot;;
 650             for (String cmd : monitorCommands) {
 651                 StringTokenizer ct = new StringTokenizer(cmd);
 652                 if (ct.nextToken().equals(monStr)) {
 653                     monitorCommands.remove(cmd);
 654                     MessageOutput.println(&quot;Unmonitoring&quot;, cmd);
 655                     return;
 656                 }
 657             }
 658             MessageOutput.println(&quot;No monitor numbered:&quot;, monTok);
 659         } else {
 660             MessageOutput.println(&quot;Usage: unmonitor &lt;monitor#&gt;&quot;);
 661         }
 662     }
 663 
 664 
 665     void readCommand(StringTokenizer t) {
 666         if (t.hasMoreTokens()) {
 667             String cmdfname = t.nextToken();
 668             if (!readCommandFile(new File(cmdfname))) {
 669                 MessageOutput.println(&quot;Could not open:&quot;, cmdfname);
 670             }
 671         } else {
 672             MessageOutput.println(&quot;Usage: read &lt;command-filename&gt;&quot;);
 673         }
 674     }
 675 
 676     /**
 677      * Read and execute a command file.  Return true if the file was read
 678      * else false;
 679      */
 680     boolean readCommandFile(File f) {
 681         BufferedReader inFile = null;
 682         try {
 683             if (f.canRead()) {
 684                 // Process initial commands.
 685                 MessageOutput.println(&quot;*** Reading commands from&quot;, f.getPath());
 686                 inFile = new BufferedReader(new FileReader(f));
 687                 String ln;
 688                 while ((ln = inFile.readLine()) != null) {
 689                     StringTokenizer t = new StringTokenizer(ln);
 690                     if (t.hasMoreTokens()) {
 691                         executeCommand(t);
 692                     }
 693                 }
 694             }
 695         } catch (IOException e) {
 696         } finally {
 697             if (inFile != null) {
 698                 try {
 699                     inFile.close();
 700                 } catch (Exception exc) {
 701                 }
 702             }
 703         }
 704         return inFile != null;
 705     }
 706 
 707     /**
 708      * Try to read commands from dir/fname, unless
 709      * the canonical path passed in is the same as that
 710      * for dir/fname.
 711      * Return null if that file doesn&#39;t exist,
 712      * else return the canonical path of that file.
 713      */
 714     String readStartupCommandFile(String dir, String fname, String canonPath) {
 715         File dotInitFile = new File(dir, fname);
 716         if (!dotInitFile.exists()) {
 717             return null;
 718         }
 719 
 720         String myCanonFile;
 721         try {
 722             myCanonFile = dotInitFile.getCanonicalPath();
 723         } catch (IOException ee) {
 724             MessageOutput.println(&quot;Could not open:&quot;, dotInitFile.getPath());
 725             return null;
 726         }
 727         if (canonPath == null || !canonPath.equals(myCanonFile)) {
 728             if (!readCommandFile(dotInitFile)) {
 729                 MessageOutput.println(&quot;Could not open:&quot;, dotInitFile.getPath());
 730             }
 731         }
 732         return myCanonFile;
 733     }
 734 
 735 
 736     public TTY() throws Exception {
 737 
 738         MessageOutput.println(&quot;Initializing progname&quot;, progname);
 739 
 740         if (Env.connection().isOpen() &amp;&amp; Env.vm().canBeModified()) {
 741             /*
 742              * Connection opened on startup. Start event handler
 743              * immediately, telling it (through arg 2) to stop on the
 744              * VM start event.
 745              */
 746             this.handler = new EventHandler(this, true);
 747         }
 748         try {
 749             BufferedReader in =
 750                     new BufferedReader(new InputStreamReader(System.in));
 751 
 752             String lastLine = null;
 753 
 754             Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
 755 
 756             /*
 757              * Read start up files.  This mimics the behavior
 758              * of gdb which will read both ~/.gdbinit and then
 759              * ./.gdbinit if they exist.  We have the twist that
 760              * we allow two different names, so we do this:
 761              *  if ~/jdb.ini exists,
 762              *      read it
 763              *  else if ~/.jdbrc exists,
 764              *      read it
 765              *
 766              *  if ./jdb.ini exists,
 767              *      if it hasn&#39;t been read, read it
 768              *      It could have been read above because ~ == .
 769              *      or because of symlinks, ...
 770              *  else if ./jdbrx exists
 771              *      if it hasn&#39;t been read, read it
 772              */
 773             {
 774                 String userHome = System.getProperty(&quot;user.home&quot;);
 775                 String canonPath;
 776 
 777                 if ((canonPath = readStartupCommandFile(userHome, &quot;jdb.ini&quot;, null)) == null) {
 778                     // Doesn&#39;t exist, try alternate spelling
 779                     canonPath = readStartupCommandFile(userHome, &quot;.jdbrc&quot;, null);
 780                 }
 781 
 782                 String userDir = System.getProperty(&quot;user.dir&quot;);
 783                 if (readStartupCommandFile(userDir, &quot;jdb.ini&quot;, canonPath) == null) {
 784                     // Doesn&#39;t exist, try alternate spelling
 785                     readStartupCommandFile(userDir, &quot;.jdbrc&quot;, canonPath);
 786                 }
 787             }
 788 
 789             // Process interactive commands.
 790             MessageOutput.printPrompt();
 791             while (true) {
 792                 String ln = in.readLine();
 793                 if (ln == null) {
 794                     /*
 795                      *  Jdb is being shutdown because debuggee exited, ignore any &#39;null&#39;
 796                      *  returned by readLine() during shutdown. JDK-8154144.
 797                      */
 798                     if (!isShuttingDown()) {
 799                         MessageOutput.println(&quot;Input stream closed.&quot;);
 800                     }
 801                     ln = &quot;quit&quot;;
 802                 }
 803 
 804                 if (ln.startsWith(&quot;!!&quot;) &amp;&amp; lastLine != null) {
 805                     ln = lastLine + ln.substring(2);
 806                     MessageOutput.printDirectln(ln);// Special case: use printDirectln()
 807                 }
 808 
 809                 StringTokenizer t = new StringTokenizer(ln);
 810                 if (t.hasMoreTokens()) {
 811                     lastLine = ln;
 812                     executeCommand(t);
 813                 } else {
 814                     MessageOutput.printPrompt();
 815                 }
 816             }
 817         } catch (VMDisconnectedException e) {
 818             handler.handleDisconnectedException();
 819         }
 820     }
 821 
 822     private static void usage() {
 823         MessageOutput.println(&quot;zz usage text&quot;, new Object [] {progname,
 824                                                      File.pathSeparator});
 825         System.exit(0);
 826     }
 827 
 828     static void usageError(String messageKey) {
 829         MessageOutput.println(messageKey);
 830         MessageOutput.println();
 831         usage();
 832     }
 833 
 834     static void usageError(String messageKey, String argument) {
 835         MessageOutput.println(messageKey, argument);
 836         MessageOutput.println();
 837         usage();
 838     }
 839 
 840     private static boolean supportsSharedMemory() {
 841         for (Connector connector :
 842                  Bootstrap.virtualMachineManager().allConnectors()) {
 843             if (connector.transport() == null) {
 844                 continue;
 845             }
 846             if (&quot;dt_shmem&quot;.equals(connector.transport().name())) {
 847                 return true;
 848             }
 849         }
 850         return false;
 851     }
 852 
 853     private static String addressToSocketArgs(String address) {
 854         int index = address.indexOf(&#39;:&#39;);
 855         if (index != -1) {
 856             String hostString = address.substring(0, index);
 857             String portString = address.substring(index + 1);
 858             return &quot;hostname=&quot; + hostString + &quot;,port=&quot; + portString;
 859         } else {
 860             return &quot;port=&quot; + address;
 861         }
 862     }
 863 
 864     private static boolean hasWhitespace(String string) {
 865         int length = string.length();
 866         for (int i = 0; i &lt; length; i++) {
 867             if (Character.isWhitespace(string.charAt(i))) {
 868                 return true;
 869             }
 870         }
 871         return false;
 872     }
 873 
 874     private static String addArgument(String string, String argument) {
 875         if (hasWhitespace(argument) || argument.indexOf(&#39;,&#39;) != -1) {
 876             // Quotes were stripped out for this argument, add &#39;em back.
 877             StringBuilder sb = new StringBuilder(string);
 878             sb.append(&#39;&quot;&#39;);
 879             for (int i = 0; i &lt; argument.length(); i++) {
 880                 char c = argument.charAt(i);
 881                 if (c == &#39;&quot;&#39;) {
 882                     sb.append(&#39;\\&#39;);
 883                 }
 884                 sb.append(c);
 885             }
 886             sb.append(&quot;\&quot; &quot;);
 887             return sb.toString();
 888         } else {
 889             return string + argument + &#39; &#39;;
 890         }
 891     }
 892 
 893     public static void main(String argv[]) throws MissingResourceException {
 894         String cmdLine = &quot;&quot;;
 895         String javaArgs = &quot;&quot;;
 896         int traceFlags = VirtualMachine.TRACE_NONE;
 897         boolean launchImmediately = false;
 898         String connectSpec = null;
 899 
 900         MessageOutput.textResources = ResourceBundle.getBundle
 901             (&quot;com.sun.tools.example.debug.tty.TTYResources&quot;,
 902              Locale.getDefault());
 903 
 904         for (int i = 0; i &lt; argv.length; i++) {
 905             String token = argv[i];
 906             if (token.equals(&quot;-dbgtrace&quot;)) {
 907                 if ((i == argv.length - 1) ||
 908                     ! Character.isDigit(argv[i+1].charAt(0))) {
 909                     traceFlags = VirtualMachine.TRACE_ALL;
 910                 } else {
 911                     String flagStr = &quot;&quot;;
 912                     try {
 913                         flagStr = argv[++i];
 914                         traceFlags = Integer.decode(flagStr).intValue();
 915                     } catch (NumberFormatException nfe) {
 916                         usageError(&quot;dbgtrace flag value must be an integer:&quot;,
 917                                    flagStr);
 918                         return;
 919                     }
 920                 }
 921             } else if (token.equals(&quot;-X&quot;)) {
 922                 usageError(&quot;Use java minus X to see&quot;);
 923                 return;
 924             } else if (
 925                    // Standard VM options passed on
 926                    token.equals(&quot;-v&quot;) || token.startsWith(&quot;-v:&quot;) ||  // -v[:...]
 927                    token.startsWith(&quot;-verbose&quot;) ||                  // -verbose[:...]
 928                    token.startsWith(&quot;-D&quot;) ||
 929                    // -classpath handled below
 930                    // NonStandard options passed on
 931                    token.startsWith(&quot;-X&quot;) ||
 932                    // Old-style options (These should remain in place as long as
 933                    //  the standard VM accepts them)
 934                    token.equals(&quot;-noasyncgc&quot;) || token.equals(&quot;-prof&quot;) ||
 935                    token.equals(&quot;-verify&quot;) ||
 936                    token.equals(&quot;-verifyremote&quot;) ||
 937                    token.equals(&quot;-verbosegc&quot;) ||
 938                    token.startsWith(&quot;-ms&quot;) || token.startsWith(&quot;-mx&quot;) ||
 939                    token.startsWith(&quot;-ss&quot;) || token.startsWith(&quot;-oss&quot;) ) {
 940 
 941                 javaArgs = addArgument(javaArgs, token);
 942             } else if (token.equals(&quot;-tclassic&quot;)) {
 943                 usageError(&quot;Classic VM no longer supported.&quot;);
 944                 return;
 945             } else if (token.equals(&quot;-tclient&quot;)) {
 946                 // -client must be the first one
 947                 javaArgs = &quot;-client &quot; + javaArgs;
 948             } else if (token.equals(&quot;-tserver&quot;)) {
 949                 // -server must be the first one
 950                 javaArgs = &quot;-server &quot; + javaArgs;
 951             } else if (token.equals(&quot;-sourcepath&quot;)) {
 952                 if (i == (argv.length - 1)) {
 953                     usageError(&quot;No sourcepath specified.&quot;);
 954                     return;
 955                 }
 956                 Env.setSourcePath(argv[++i]);
 957             } else if (token.equals(&quot;-classpath&quot;)) {
 958                 if (i == (argv.length - 1)) {
 959                     usageError(&quot;No classpath specified.&quot;);
 960                     return;
 961                 }
 962                 javaArgs = addArgument(javaArgs, token);
 963                 javaArgs = addArgument(javaArgs, argv[++i]);
 964             } else if (token.equals(&quot;-attach&quot;)) {
 965                 if (connectSpec != null) {
 966                     usageError(&quot;cannot redefine existing connection&quot;, token);
 967                     return;
 968                 }
 969                 if (i == (argv.length - 1)) {
 970                     usageError(&quot;No attach address specified.&quot;);
 971                     return;
 972                 }
 973                 String address = argv[++i];
 974 
 975                 /*
 976                  * -attach is shorthand for one of the reference implementation&#39;s
 977                  * attaching connectors. Use the shared memory attach if it&#39;s
 978                  * available; otherwise, use sockets. Build a connect
 979                  * specification string based on this decision.
 980                  */
 981                 if (supportsSharedMemory()) {
 982                     connectSpec = &quot;com.sun.jdi.SharedMemoryAttach:name=&quot; +
 983                                    address;
 984                 } else {
 985                     String suboptions = addressToSocketArgs(address);
 986                     connectSpec = &quot;com.sun.jdi.SocketAttach:&quot; + suboptions;
 987                 }
 988             } else if (token.equals(&quot;-listen&quot;) || token.equals(&quot;-listenany&quot;)) {
 989                 if (connectSpec != null) {
 990                     usageError(&quot;cannot redefine existing connection&quot;, token);
 991                     return;
 992                 }
 993                 String address = null;
 994                 if (token.equals(&quot;-listen&quot;)) {
 995                     if (i == (argv.length - 1)) {
 996                         usageError(&quot;No attach address specified.&quot;);
 997                         return;
 998                     }
 999                     address = argv[++i];
1000                 }
1001 
1002                 /*
1003                  * -listen[any] is shorthand for one of the reference implementation&#39;s
1004                  * listening connectors. Use the shared memory listen if it&#39;s
1005                  * available; otherwise, use sockets. Build a connect
1006                  * specification string based on this decision.
1007                  */
1008                 if (supportsSharedMemory()) {
1009                     connectSpec = &quot;com.sun.jdi.SharedMemoryListen:&quot;;
1010                     if (address != null) {
1011                         connectSpec += (&quot;name=&quot; + address);
1012                     }
1013                 } else {
1014                     connectSpec = &quot;com.sun.jdi.SocketListen:&quot;;
1015                     if (address != null) {
1016                         connectSpec += addressToSocketArgs(address);
1017                     }
1018                 }
1019             } else if (token.equals(&quot;-launch&quot;)) {
1020                 launchImmediately = true;
1021             } else if (token.equals(&quot;-listconnectors&quot;)) {
1022                 Commands evaluator = new Commands();
1023                 evaluator.commandConnectors(Bootstrap.virtualMachineManager());
1024                 return;
1025             } else if (token.equals(&quot;-connect&quot;)) {
1026                 /*
1027                  * -connect allows the user to pick the connector
1028                  * used in bringing up the target VM. This allows
1029                  * use of connectors other than those in the reference
1030                  * implementation.
1031                  */
1032                 if (connectSpec != null) {
1033                     usageError(&quot;cannot redefine existing connection&quot;, token);
1034                     return;
1035                 }
1036                 if (i == (argv.length - 1)) {
1037                     usageError(&quot;No connect specification.&quot;);
1038                     return;
1039                 }
1040                 connectSpec = argv[++i];
1041             } else if (token.equals(&quot;-?&quot;) ||
1042                        token.equals(&quot;-h&quot;) ||
1043                        token.equals(&quot;--help&quot;) ||
1044                        // -help: legacy.
1045                        token.equals(&quot;-help&quot;)) {
1046                 usage();
1047             } else if (token.equals(&quot;-version&quot;)) {
1048                 Commands evaluator = new Commands();
1049                 evaluator.commandVersion(progname,
1050                                          Bootstrap.virtualMachineManager());
1051                 System.exit(0);
1052             } else if (token.startsWith(&quot;-&quot;)) {
1053                 usageError(&quot;invalid option&quot;, token);
1054                 return;
1055             } else {
1056                 // Everything from here is part of the command line
1057                 cmdLine = addArgument(&quot;&quot;, token);
1058                 for (i++; i &lt; argv.length; i++) {
1059                     cmdLine = addArgument(cmdLine, argv[i]);
1060                 }
1061                 break;
1062             }
1063         }
1064 
1065         /*
1066          * Unless otherwise specified, set the default connect spec.
1067          */
1068 
1069         /*
1070          * Here are examples of jdb command lines and how the options
1071          * are interpreted as arguments to the program being debugged.
1072          * arg1       arg2
1073          * ----       ----
1074          * jdb hello a b       a          b
1075          * jdb hello &quot;a b&quot;     a b
1076          * jdb hello a,b       a,b
1077          * jdb hello a, b      a,         b
1078          * jdb hello &quot;a, b&quot;    a, b
1079          * jdb -connect &quot;com.sun.jdi.CommandLineLaunch:main=hello  a,b&quot;   illegal
1080          * jdb -connect  com.sun.jdi.CommandLineLaunch:main=hello &quot;a,b&quot;   illegal
1081          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello &quot;a,b&quot;&#39;  arg1 = a,b
1082          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello &quot;a b&quot;&#39;  arg1 = a b
1083          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello  a b&#39;   arg1 = a  arg2 = b
1084          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello &quot;a,&quot; b&#39; arg1 = a, arg2 = b
1085          */
1086         if (connectSpec == null) {
1087             connectSpec = &quot;com.sun.jdi.CommandLineLaunch:&quot;;
1088         } else if (!connectSpec.endsWith(&quot;,&quot;) &amp;&amp; !connectSpec.endsWith(&quot;:&quot;)) {
1089             connectSpec += &quot;,&quot;; // (Bug ID 4285874)
1090         }
1091 
1092         cmdLine = cmdLine.trim();
1093         javaArgs = javaArgs.trim();
1094 
1095         if (cmdLine.length() &gt; 0) {
1096             if (!connectSpec.startsWith(&quot;com.sun.jdi.CommandLineLaunch:&quot;)) {
1097                 usageError(&quot;Cannot specify command line with connector:&quot;,
1098                            connectSpec);
1099                 return;
1100             }
1101             connectSpec += &quot;main=&quot; + cmdLine + &quot;,&quot;;
1102         }
1103 
1104         if (javaArgs.length() &gt; 0) {
1105             if (!connectSpec.startsWith(&quot;com.sun.jdi.CommandLineLaunch:&quot;)) {
1106                 usageError(&quot;Cannot specify target vm arguments with connector:&quot;,
1107                            connectSpec);
1108                 return;
1109             }
1110             connectSpec += &quot;options=&quot; + javaArgs + &quot;,&quot;;
1111         }
1112 
1113         try {
1114             if (! connectSpec.endsWith(&quot;,&quot;)) {
1115                 connectSpec += &quot;,&quot;; // (Bug ID 4285874)
1116             }
1117             Env.init(connectSpec, launchImmediately, traceFlags);
1118             new TTY();
1119         } catch(Exception e) {
1120             MessageOutput.printException(&quot;Internal exception:&quot;, e);
1121         }
1122     }
1123 }
    </pre>
  </body>
</html>
diff a/src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java b/src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java
--- a/src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java
+++ b/src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -31,14 +31,16 @@
 import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.TreeSet;
+import java.util.Set;
+import java.util.function.Consumer;
 
 import com.sun.jdi.BooleanType;
 import com.sun.jdi.BooleanValue;
 import com.sun.jdi.ByteType;
 import com.sun.jdi.ByteValue;
@@ -54,10 +56,11 @@
 import com.sun.jdi.IntegerValue;
 import com.sun.jdi.InternalException;
 import com.sun.jdi.LongType;
 import com.sun.jdi.LongValue;
 import com.sun.jdi.ModuleReference;
+import com.sun.jdi.ObjectCollectedException;
 import com.sun.jdi.PathSearchingVirtualMachine;
 import com.sun.jdi.PrimitiveType;
 import com.sun.jdi.ReferenceType;
 import com.sun.jdi.ShortType;
 import com.sun.jdi.ShortValue;
@@ -108,11 +111,11 @@
     // ReferenceType access - updated with class prepare and unload events
     // Protected by "synchronized(this)". "retrievedAllTypes" may be
     // tested unsynchronized (since once true, it stays true), but must
     // be set synchronously
     private Map<Long, ReferenceType> typesByID;
-    private TreeSet<ReferenceType> typesBySignature;
+    private Set<ReferenceType> typesBySignature;
     private boolean retrievedAllTypes = false;
 
     private Map<Long, ModuleReference> modulesByID;
 
     // For other languages support
@@ -335,10 +338,31 @@
             a = new ArrayList<>(typesBySignature);
         }
         return Collections.unmodifiableList(a);
     }
 
+    /**
+     * Performs an action for each loaded type.
+     */
+    public void forEachClass(Consumer<ReferenceType> action) {
+        for (ReferenceType type : allClasses()) {
+            try {
+                action.accept(type);
+            } catch (ObjectCollectedException ex) {
+                // Some classes might be unloaded and garbage collected since
+                // we retrieved the copy of all loaded classes and started
+                // iterating over them. In this case calling methods on such types
+                // might result in com.sun.jdi.ObjectCollectedException
+                // being thrown. We ignore such classes and keep iterating.
+                if ((vm.traceFlags & VirtualMachine.TRACE_OBJREFS) != 0) {
+                    vm.printTrace("ObjectCollectedException was thrown while " +
+                            "accessing unloaded class " + type.name());
+                }
+            }
+        }
+    }
+
     public void
         redefineClasses(Map<? extends ReferenceType, byte[]> classToBytes)
     {
         int cnt = classToBytes.size();
         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
@@ -841,18 +865,13 @@
                 break;
             default:
                 throw new InternalException("Invalid reference type tag");
         }
 
-        /*
-         * If a signature was specified, make sure to set it ASAP, to
-         * prevent any needless JDWP command to retrieve it. (for example,
-         * typesBySignature.add needs the signature, to maintain proper
-         * ordering.
-         */
-        if (signature != null) {
-            type.setSignature(signature);
+        if (signature == null && retrievedAllTypes) {
+            // do not cache if signature is not provided
+            return type;
         }
 
         typesByID.put(id, type);
         typesBySignature.add(type);
 
@@ -918,11 +937,11 @@
         return list;
     }
 
     private void initReferenceTypes() {
         typesByID = new HashMap<>(300);
-        typesBySignature = new TreeSet<>();
+        typesBySignature = new HashSet<>();
     }
 
     ReferenceTypeImpl referenceType(long ref, byte tag) {
         return referenceType(ref, tag, null);
     }
@@ -967,10 +986,13 @@
                     retType = (ReferenceTypeImpl)typesByID.get(id);
                 }
                 if (retType == null) {
                     retType = addReferenceType(id, tag, signature);
                 }
+                if (signature != null) {
+                    retType.setSignature(signature);
+                }
             }
             return retType;
         }
     }
 

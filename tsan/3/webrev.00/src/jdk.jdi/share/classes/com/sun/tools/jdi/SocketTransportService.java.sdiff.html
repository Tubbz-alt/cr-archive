<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdi/share/classes/com/sun/tools/jdi/SocketTransportService.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketListeningConnector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VirtualMachineImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdi/share/classes/com/sun/tools/jdi/SocketTransportService.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 62             return ss;
 63         }
 64 
 65         /*
 66          * Returns the string representation of the address that this
 67          * listen key represents.
 68          */
 69         public String address() {
 70             InetAddress address = ss.getInetAddress();
 71 
 72             /*
 73              * If bound to the wildcard address then use current local
 74              * hostname. In the event that we don&#39;t know our own hostname
 75              * then assume that host supports IPv4 and return something to
 76              * represent the loopback address.
 77              */
 78             if (address.isAnyLocalAddress()) {
 79                 try {
 80                     address = InetAddress.getLocalHost();
 81                 } catch (UnknownHostException uhe) {
<span class="line-modified"> 82                     byte[] loopback = {0x7f,0x00,0x00,0x01};</span>
<span class="line-removed"> 83                     try {</span>
<span class="line-removed"> 84                         address = InetAddress.getByAddress(&quot;127.0.0.1&quot;, loopback);</span>
<span class="line-removed"> 85                     } catch (UnknownHostException x) {</span>
<span class="line-removed"> 86                         throw new InternalError(&quot;unable to get local hostname&quot;);</span>
<span class="line-removed"> 87                     }</span>
 88                 }
 89             }
 90 
 91             /*
 92              * Now decide if we return a hostname or IP address. Where possible
 93              * return a hostname but in the case that we are bound to an
 94              * address that isn&#39;t registered in the name service then we
 95              * return an address.
 96              */
 97             String result;
 98             String hostname = address.getHostName();
 99             String hostaddr = address.getHostAddress();
100             if (hostname.equals(hostaddr)) {
101                 if (address instanceof Inet6Address) {
102                     result = &quot;[&quot; + hostaddr + &quot;]&quot;;
103                 } else {
104                     result = hostaddr;
105                 }
106             } else {
107                 result = hostname;
</pre>
<hr />
<pre>
184     public Capabilities capabilities() {
185         return new TransportService.Capabilities() {
186             public boolean supportsMultipleConnections() {
187                 return true;
188             }
189 
190             public boolean supportsAttachTimeout() {
191                 return true;
192             }
193 
194             public boolean supportsAcceptTimeout() {
195                 return true;
196             }
197 
198             public boolean supportsHandshakeTimeout() {
199                 return true;
200             }
201         };
202     }
203 






































204     /**
205      * Attach to the specified address with optional attach and handshake
206      * timeout.
207      */
208     public Connection attach(String address, long attachTimeout, long handshakeTimeout)
209         throws IOException {
210 
211         if (address == null) {
212             throw new NullPointerException(&quot;address is null&quot;);
213         }
214         if (attachTimeout &lt; 0 || handshakeTimeout &lt; 0) {
215             throw new IllegalArgumentException(&quot;timeout is negative&quot;);
216         }
217 
<span class="line-modified">218         int splitIndex = address.indexOf(&#39;:&#39;);</span>
<span class="line-removed">219         String host;</span>
<span class="line-removed">220         String portStr;</span>
<span class="line-removed">221         if (splitIndex &lt; 0) {</span>
<span class="line-removed">222             host = &quot;localhost&quot;;</span>
<span class="line-removed">223             portStr = address;</span>
<span class="line-removed">224         } else {</span>
<span class="line-removed">225             host = address.substring(0, splitIndex);</span>
<span class="line-removed">226             portStr = address.substring(splitIndex+1);</span>
<span class="line-removed">227         }</span>
<span class="line-removed">228 </span>
<span class="line-removed">229         if (host.equals(&quot;*&quot;)) {</span>
<span class="line-removed">230             host = InetAddress.getLocalHost().getHostName();</span>
<span class="line-removed">231         }</span>
<span class="line-removed">232 </span>
<span class="line-removed">233         int port;</span>
<span class="line-removed">234         try {</span>
<span class="line-removed">235             port = Integer.decode(portStr).intValue();</span>
<span class="line-removed">236         } catch (NumberFormatException e) {</span>
<span class="line-removed">237             throw new IllegalArgumentException(</span>
<span class="line-removed">238                 &quot;unable to parse port number in address&quot;);</span>
<span class="line-removed">239         }</span>
240 
241         // open TCP connection to VM
<span class="line-modified">242         InetSocketAddress sa = new InetSocketAddress(host, port);</span>




243         Socket s = new Socket();
244         try {
245             s.connect(sa, (int)attachTimeout);
246         } catch (SocketTimeoutException exc) {
247             try {
248                 s.close();
249             } catch (IOException x) { }
250             throw new TransportTimeoutException(&quot;timed out trying to establish connection&quot;);
251         }
252 
253         // handshake with the target VM
254         try {
255             handshake(s, handshakeTimeout);
256         } catch (IOException exc) {
257             try {
258                 s.close();
259             } catch (IOException x) { }
260             throw exc;
261         }
262 
</pre>
<hr />
<pre>
273             sa = new InetSocketAddress(port);
274         } else {
275             sa = new InetSocketAddress(localaddress, port);
276         }
277         ServerSocket ss = new ServerSocket();
278         if (port == 0) {
279             // Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
280             // start seeing EADDRINUSE due to collisions in free ports
281             // then we should retry the bind() a few times.
282             ss.setReuseAddress(false);
283         }
284         ss.bind(sa);
285         return new SocketListenKey(ss);
286     }
287 
288     /**
289      * Listen on the specified address
290      */
291     public ListenKey startListening(String address) throws IOException {
292         // use ephemeral port if address isn&#39;t specified.
<span class="line-modified">293         if (address == null || address.length() == 0) {</span>
<span class="line-modified">294             address = &quot;0&quot;;</span>
<span class="line-removed">295         }</span>
<span class="line-removed">296 </span>
<span class="line-removed">297         int splitIndex = address.indexOf(&#39;:&#39;);</span>
<span class="line-removed">298         String localaddr = null;</span>
<span class="line-removed">299         if (splitIndex &gt;= 0) {</span>
<span class="line-removed">300             localaddr = address.substring(0, splitIndex);</span>
<span class="line-removed">301             address = address.substring(splitIndex+1);</span>
<span class="line-removed">302         }</span>
<span class="line-removed">303 </span>
<span class="line-removed">304         int port;</span>
<span class="line-removed">305         try {</span>
<span class="line-removed">306             port = Integer.decode(address).intValue();</span>
<span class="line-removed">307         } catch (NumberFormatException e) {</span>
<span class="line-removed">308             throw new IllegalArgumentException(</span>
<span class="line-removed">309                     &quot;unable to parse port number in address&quot;);</span>
<span class="line-removed">310         }</span>
<span class="line-removed">311 </span>
<span class="line-removed">312         return startListening(localaddr, port);</span>
313     }
314 
315     /**
316      * Listen on the default address
317      */
318     public ListenKey startListening() throws IOException {
319         return startListening(null, 0);
320     }
321 
322     /**
323      * Stop the listener
324      */
325     public void stopListening(ListenKey listener) throws IOException {
326         if (!(listener instanceof SocketListenKey)) {
327             throw new IllegalArgumentException(&quot;Invalid listener&quot;);
328         }
329 
330         synchronized (listener) {
331             ServerSocket ss = ((SocketListenKey)listener).socket();
332 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 62             return ss;
 63         }
 64 
 65         /*
 66          * Returns the string representation of the address that this
 67          * listen key represents.
 68          */
 69         public String address() {
 70             InetAddress address = ss.getInetAddress();
 71 
 72             /*
 73              * If bound to the wildcard address then use current local
 74              * hostname. In the event that we don&#39;t know our own hostname
 75              * then assume that host supports IPv4 and return something to
 76              * represent the loopback address.
 77              */
 78             if (address.isAnyLocalAddress()) {
 79                 try {
 80                     address = InetAddress.getLocalHost();
 81                 } catch (UnknownHostException uhe) {
<span class="line-modified"> 82                     address = InetAddress.getLoopbackAddress();</span>





 83                 }
 84             }
 85 
 86             /*
 87              * Now decide if we return a hostname or IP address. Where possible
 88              * return a hostname but in the case that we are bound to an
 89              * address that isn&#39;t registered in the name service then we
 90              * return an address.
 91              */
 92             String result;
 93             String hostname = address.getHostName();
 94             String hostaddr = address.getHostAddress();
 95             if (hostname.equals(hostaddr)) {
 96                 if (address instanceof Inet6Address) {
 97                     result = &quot;[&quot; + hostaddr + &quot;]&quot;;
 98                 } else {
 99                     result = hostaddr;
100                 }
101             } else {
102                 result = hostname;
</pre>
<hr />
<pre>
179     public Capabilities capabilities() {
180         return new TransportService.Capabilities() {
181             public boolean supportsMultipleConnections() {
182                 return true;
183             }
184 
185             public boolean supportsAttachTimeout() {
186                 return true;
187             }
188 
189             public boolean supportsAcceptTimeout() {
190                 return true;
191             }
192 
193             public boolean supportsHandshakeTimeout() {
194                 return true;
195             }
196         };
197     }
198 
<span class="line-added">199     private static class HostPort {</span>
<span class="line-added">200         public final String host;</span>
<span class="line-added">201         public final int port;</span>
<span class="line-added">202         private HostPort(String host, int port) {</span>
<span class="line-added">203             this.host = host;</span>
<span class="line-added">204             this.port = port;</span>
<span class="line-added">205         }</span>
<span class="line-added">206 </span>
<span class="line-added">207         /**</span>
<span class="line-added">208          * Creates an instance for given URN, which can be either &lt;port&gt; or &lt;host&gt;:&lt;port&gt;.</span>
<span class="line-added">209          * If host is &#39;*&#39;, the returned HostPort instance has host set to null.</span>
<span class="line-added">210          * If &lt;code&gt;host&lt;/code&gt; is a literal IPv6 address, it may be in square brackets.</span>
<span class="line-added">211          */</span>
<span class="line-added">212         public static HostPort parse(String hostPort) {</span>
<span class="line-added">213             int splitIndex = hostPort.lastIndexOf(&#39;:&#39;);</span>
<span class="line-added">214 </span>
<span class="line-added">215             int port;</span>
<span class="line-added">216             try {</span>
<span class="line-added">217                 port = Integer.decode(hostPort.substring(splitIndex + 1));</span>
<span class="line-added">218             } catch (NumberFormatException e) {</span>
<span class="line-added">219                 throw new IllegalArgumentException(&quot;unable to parse port number in address&quot;);</span>
<span class="line-added">220             }</span>
<span class="line-added">221             if (port &lt; 0 || port &gt; 0xFFFF) {</span>
<span class="line-added">222                 throw new IllegalArgumentException(&quot;port out of range&quot;);</span>
<span class="line-added">223             }</span>
<span class="line-added">224 </span>
<span class="line-added">225             if (splitIndex &lt;= 0) {  // empty host means local connection</span>
<span class="line-added">226                 return new HostPort(InetAddress.getLoopbackAddress().getHostAddress(), port);</span>
<span class="line-added">227             } else if (splitIndex == 1 &amp;&amp; hostPort.charAt(0) == &#39;*&#39;) {</span>
<span class="line-added">228                 return new HostPort(null, port);</span>
<span class="line-added">229             } else if (hostPort.charAt(0) == &#39;[&#39; &amp;&amp; hostPort.charAt(splitIndex - 1) == &#39;]&#39;) {</span>
<span class="line-added">230                 return new HostPort(hostPort.substring(1, splitIndex - 1), port);</span>
<span class="line-added">231             } else {</span>
<span class="line-added">232                 return new HostPort(hostPort.substring(0, splitIndex), port);</span>
<span class="line-added">233             }</span>
<span class="line-added">234         }</span>
<span class="line-added">235     }</span>
<span class="line-added">236 </span>
237     /**
238      * Attach to the specified address with optional attach and handshake
239      * timeout.
240      */
241     public Connection attach(String address, long attachTimeout, long handshakeTimeout)
242         throws IOException {
243 
244         if (address == null) {
245             throw new NullPointerException(&quot;address is null&quot;);
246         }
247         if (attachTimeout &lt; 0 || handshakeTimeout &lt; 0) {
248             throw new IllegalArgumentException(&quot;timeout is negative&quot;);
249         }
250 
<span class="line-modified">251         HostPort hostPort = HostPort.parse(address);</span>





















252 
253         // open TCP connection to VM
<span class="line-modified">254         // formally &quot;*&quot; is not correct hostname to attach</span>
<span class="line-added">255         // but lets connect to localhost</span>
<span class="line-added">256         InetSocketAddress sa = new InetSocketAddress(hostPort.host == null</span>
<span class="line-added">257                                                      ? InetAddress.getLoopbackAddress().getHostAddress()</span>
<span class="line-added">258                                                      : hostPort.host, hostPort.port);</span>
259         Socket s = new Socket();
260         try {
261             s.connect(sa, (int)attachTimeout);
262         } catch (SocketTimeoutException exc) {
263             try {
264                 s.close();
265             } catch (IOException x) { }
266             throw new TransportTimeoutException(&quot;timed out trying to establish connection&quot;);
267         }
268 
269         // handshake with the target VM
270         try {
271             handshake(s, handshakeTimeout);
272         } catch (IOException exc) {
273             try {
274                 s.close();
275             } catch (IOException x) { }
276             throw exc;
277         }
278 
</pre>
<hr />
<pre>
289             sa = new InetSocketAddress(port);
290         } else {
291             sa = new InetSocketAddress(localaddress, port);
292         }
293         ServerSocket ss = new ServerSocket();
294         if (port == 0) {
295             // Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
296             // start seeing EADDRINUSE due to collisions in free ports
297             // then we should retry the bind() a few times.
298             ss.setReuseAddress(false);
299         }
300         ss.bind(sa);
301         return new SocketListenKey(ss);
302     }
303 
304     /**
305      * Listen on the specified address
306      */
307     public ListenKey startListening(String address) throws IOException {
308         // use ephemeral port if address isn&#39;t specified.
<span class="line-modified">309         HostPort hostPort = HostPort.parse((address == null || address.isEmpty()) ? &quot;0&quot; : address);</span>
<span class="line-modified">310         return startListening(hostPort.host, hostPort.port);</span>


















311     }
312 
313     /**
314      * Listen on the default address
315      */
316     public ListenKey startListening() throws IOException {
317         return startListening(null, 0);
318     }
319 
320     /**
321      * Stop the listener
322      */
323     public void stopListening(ListenKey listener) throws IOException {
324         if (!(listener instanceof SocketListenKey)) {
325             throw new IllegalArgumentException(&quot;Invalid listener&quot;);
326         }
327 
328         synchronized (listener) {
329             ServerSocket ss = ((SocketListenKey)listener).socket();
330 
</pre>
</td>
</tr>
</table>
<center><a href="SocketListeningConnector.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VirtualMachineImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
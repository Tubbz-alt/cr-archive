<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdi/share/classes/com/sun/tools/example/debug/tty/TTY.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * This source code is provided to illustrate the usage of a given feature
  28  * or technique and has been deliberately simplified. Additional steps
  29  * required for a production-quality application, such as security checks,
  30  * input validation and proper error handling, might not be present in
  31  * this sample code.
  32  */
  33 
  34 
  35 package com.sun.tools.example.debug.tty;
  36 
  37 import com.sun.jdi.*;
  38 import com.sun.jdi.event.*;
  39 import com.sun.jdi.request.*;
  40 import com.sun.jdi.connect.*;
  41 
  42 import java.util.*;
  43 import java.io.*;
  44 
  45 public class TTY implements EventNotifier {
  46     EventHandler handler = null;
  47 
  48     /**
  49      * List of Strings to execute at each stop.
  50      */
  51     private List&lt;String&gt; monitorCommands = new ArrayList&lt;String&gt;();
  52     private int monitorCount = 0;
  53 
  54     /**
  55      * The name of this tool.
  56      */
  57     private static final String progname = &quot;jdb&quot;;
  58 
  59     private volatile boolean shuttingDown = false;
  60 
  61     public void setShuttingDown(boolean s) {
  62        shuttingDown = s;
  63     }
  64 
  65     public boolean isShuttingDown() {
  66         return shuttingDown;
  67     }
  68 
  69     @Override
  70     public void vmStartEvent(VMStartEvent se)  {
  71         Thread.yield();  // fetch output
  72         MessageOutput.lnprint(&quot;VM Started:&quot;);
  73     }
  74 
  75     @Override
  76     public void vmDeathEvent(VMDeathEvent e)  {
  77     }
  78 
  79     @Override
  80     public void vmDisconnectEvent(VMDisconnectEvent e)  {
  81     }
  82 
  83     @Override
  84     public void threadStartEvent(ThreadStartEvent e)  {
  85     }
  86 
  87     @Override
  88     public void threadDeathEvent(ThreadDeathEvent e)  {
  89     }
  90 
  91     @Override
  92     public void classPrepareEvent(ClassPrepareEvent e)  {
  93     }
  94 
  95     @Override
  96     public void classUnloadEvent(ClassUnloadEvent e)  {
  97     }
  98 
  99     @Override
 100     public void breakpointEvent(BreakpointEvent be)  {
 101         Thread.yield();  // fetch output
 102         MessageOutput.lnprint(&quot;Breakpoint hit:&quot;);
 103         // Print breakpoint location and prompt if suspend policy is
 104         // SUSPEND_NONE or SUSPEND_EVENT_THREAD. In case of SUSPEND_ALL
 105         // policy this is handled by vmInterrupted() method.
 106         int suspendPolicy = be.request().suspendPolicy();
 107         switch (suspendPolicy) {
 108             case EventRequest.SUSPEND_EVENT_THREAD:
 109             case EventRequest.SUSPEND_NONE:
 110                 printBreakpointLocation(be);
 111                 MessageOutput.printPrompt();
 112                 break;
 113         }
 114     }
 115 
 116     @Override
 117     public void fieldWatchEvent(WatchpointEvent fwe)  {
 118         Field field = fwe.field();
 119         ObjectReference obj = fwe.object();
 120         Thread.yield();  // fetch output
 121 
 122         if (fwe instanceof ModificationWatchpointEvent) {
 123             MessageOutput.lnprint(&quot;Field access encountered before after&quot;,
 124                                   new Object [] {field,
 125                                                  fwe.valueCurrent(),
 126                                                  ((ModificationWatchpointEvent)fwe).valueToBe()});
 127         } else {
 128             MessageOutput.lnprint(&quot;Field access encountered&quot;, field.toString());
 129         }
 130     }
 131 
 132     @Override
 133     public void stepEvent(StepEvent se)  {
 134         Thread.yield();  // fetch output
 135         MessageOutput.lnprint(&quot;Step completed:&quot;);
 136     }
 137 
 138     @Override
 139     public void exceptionEvent(ExceptionEvent ee) {
 140         Thread.yield();  // fetch output
 141         Location catchLocation = ee.catchLocation();
 142         if (catchLocation == null) {
 143             MessageOutput.lnprint(&quot;Exception occurred uncaught&quot;,
 144                                   ee.exception().referenceType().name());
 145         } else {
 146             MessageOutput.lnprint(&quot;Exception occurred caught&quot;,
 147                                   new Object [] {ee.exception().referenceType().name(),
 148                                                  Commands.locationString(catchLocation)});
 149         }
 150     }
 151 
 152     @Override
 153     public void methodEntryEvent(MethodEntryEvent me) {
 154         Thread.yield();  // fetch output
 155         /*
 156          * These can be very numerous, so be as efficient as possible.
 157          * If we are stopping here, then we will see the normal location
 158          * info printed.
 159          */
 160         if (me.request().suspendPolicy() != EventRequest.SUSPEND_NONE) {
 161             // We are stopping; the name will be shown by the normal mechanism
 162             MessageOutput.lnprint(&quot;Method entered:&quot;);
 163         } else {
 164             // We aren&#39;t stopping, show the name
 165             MessageOutput.print(&quot;Method entered:&quot;);
 166             printLocationOfEvent(me);
 167         }
 168     }
 169 
 170     @Override
 171     public boolean methodExitEvent(MethodExitEvent me) {
 172         Thread.yield();  // fetch output
 173         /*
 174          * These can be very numerous, so be as efficient as possible.
 175          */
 176         Method mmm = Env.atExitMethod();
 177         Method meMethod = me.method();
 178 
 179         if (mmm == null || mmm.equals(meMethod)) {
 180             // Either we are not tracing a specific method, or we are
 181             // and we are exitting that method.
 182 
 183             if (me.request().suspendPolicy() != EventRequest.SUSPEND_NONE) {
 184                 // We will be stopping here, so do a newline
 185                 MessageOutput.println();
 186             }
 187             if (Env.vm().canGetMethodReturnValues()) {
 188                 MessageOutput.print(&quot;Method exitedValue:&quot;, me.returnValue() + &quot;&quot;);
 189             } else {
 190                 MessageOutput.print(&quot;Method exited:&quot;);
 191             }
 192 
 193             if (me.request().suspendPolicy() == EventRequest.SUSPEND_NONE) {
 194                 // We won&#39;t be stopping here, so show the method name
 195                 printLocationOfEvent(me);
 196 
 197             }
 198 
 199             // In case we want to have a one shot trace exit some day, this
 200             // code disables the request so we don&#39;t hit it again.
 201             if (false) {
 202                 // This is a one shot deal; we don&#39;t want to stop
 203                 // here the next time.
 204                 Env.setAtExitMethod(null);
 205                 EventRequestManager erm = Env.vm().eventRequestManager();
 206                 for (EventRequest eReq : erm.methodExitRequests()) {
 207                     if (eReq.equals(me.request())) {
 208                         eReq.disable();
 209                     }
 210                 }
 211             }
 212             return true;
 213         }
 214 
 215         // We are tracing a specific method, and this isn&#39;t it.  Keep going.
 216         return false;
 217     }
 218 
 219     @Override
 220     public void vmInterrupted() {
 221         Thread.yield();  // fetch output
 222         printCurrentLocation();
 223         for (String cmd : monitorCommands) {
 224             StringTokenizer t = new StringTokenizer(cmd);
 225             t.nextToken();  // get rid of monitor number
 226             executeCommand(t);
 227         }
 228         MessageOutput.printPrompt();
 229     }
 230 
 231     @Override
 232     public void receivedEvent(Event event) {
 233     }
 234 
 235     private void printBaseLocation(String threadName, Location loc) {
 236         MessageOutput.println(&quot;location&quot;,
 237                               new Object [] {threadName,
 238                                              Commands.locationString(loc)});
 239     }
 240 
 241     private void printBreakpointLocation(BreakpointEvent be) {
 242         printLocationWithSourceLine(be.thread().name(), be.location());
 243     }
 244 
 245     private void printCurrentLocation() {
 246         ThreadInfo threadInfo = ThreadInfo.getCurrentThreadInfo();
 247         StackFrame frame;
 248         try {
 249             frame = threadInfo.getCurrentFrame();
 250         } catch (IncompatibleThreadStateException exc) {
 251             MessageOutput.println(&quot;&lt;location unavailable&gt;&quot;);
 252             return;
 253         }
 254         if (frame == null) {
 255             MessageOutput.println(&quot;No frames on the current call stack&quot;);
 256         } else {
 257             printLocationWithSourceLine(threadInfo.getThread().name(), frame.location());
 258         }
 259         MessageOutput.println();
 260     }
 261 
 262     private void printLocationWithSourceLine(String threadName, Location loc) {
 263         printBaseLocation(threadName, loc);
 264         // Output the current source line, if possible
 265         if (loc.lineNumber() != -1) {
 266             String line;
 267             try {
 268                 line = Env.sourceLine(loc, loc.lineNumber());
 269             } catch (java.io.IOException e) {
 270                 line = null;
 271             }
 272             if (line != null) {
 273                 MessageOutput.println(&quot;source line number and line&quot;,
 274                                            new Object [] {loc.lineNumber(),
 275                                                           line});
 276             }
 277         }
 278     }
 279 
 280     private void printLocationOfEvent(LocatableEvent theEvent) {
 281         printBaseLocation(theEvent.thread().name(), theEvent.location());
 282     }
 283 
 284     void help() {
 285         MessageOutput.println(&quot;zz help text&quot;);
 286     }
 287 
 288     private static final String[][] commandList = {
 289         /*
 290          * NOTE: this list must be kept sorted in ascending ASCII
 291          *       order by element [0].  Ref: isCommand() below.
 292          *
 293          *Command      OK when        OK when
 294          * name      disconnected?   readonly?
 295          *------------------------------------
 296          */
 297         {&quot;!!&quot;,           &quot;n&quot;,         &quot;y&quot;},
 298         {&quot;?&quot;,            &quot;y&quot;,         &quot;y&quot;},
 299         {&quot;bytecodes&quot;,    &quot;n&quot;,         &quot;y&quot;},
 300         {&quot;catch&quot;,        &quot;y&quot;,         &quot;n&quot;},
 301         {&quot;class&quot;,        &quot;n&quot;,         &quot;y&quot;},
 302         {&quot;classes&quot;,      &quot;n&quot;,         &quot;y&quot;},
 303         {&quot;classpath&quot;,    &quot;n&quot;,         &quot;y&quot;},
 304         {&quot;clear&quot;,        &quot;y&quot;,         &quot;n&quot;},
 305         {&quot;connectors&quot;,   &quot;y&quot;,         &quot;y&quot;},
 306         {&quot;cont&quot;,         &quot;n&quot;,         &quot;n&quot;},
 307         {&quot;dbgtrace&quot;,     &quot;y&quot;,         &quot;y&quot;},
 308         {&quot;disablegc&quot;,    &quot;n&quot;,         &quot;n&quot;},
 309         {&quot;down&quot;,         &quot;n&quot;,         &quot;y&quot;},
 310         {&quot;dump&quot;,         &quot;n&quot;,         &quot;y&quot;},
 311         {&quot;enablegc&quot;,     &quot;n&quot;,         &quot;n&quot;},
 312         {&quot;eval&quot;,         &quot;n&quot;,         &quot;y&quot;},
 313         {&quot;exclude&quot;,      &quot;y&quot;,         &quot;n&quot;},
 314         {&quot;exit&quot;,         &quot;y&quot;,         &quot;y&quot;},
 315         {&quot;extension&quot;,    &quot;n&quot;,         &quot;y&quot;},
 316         {&quot;fields&quot;,       &quot;n&quot;,         &quot;y&quot;},
 317         {&quot;gc&quot;,           &quot;n&quot;,         &quot;n&quot;},
 318         {&quot;help&quot;,         &quot;y&quot;,         &quot;y&quot;},
 319         {&quot;ignore&quot;,       &quot;y&quot;,         &quot;n&quot;},
 320         {&quot;interrupt&quot;,    &quot;n&quot;,         &quot;n&quot;},
 321         {&quot;kill&quot;,         &quot;n&quot;,         &quot;n&quot;},
 322         {&quot;lines&quot;,        &quot;n&quot;,         &quot;y&quot;},
 323         {&quot;list&quot;,         &quot;n&quot;,         &quot;y&quot;},
 324         {&quot;load&quot;,         &quot;n&quot;,         &quot;y&quot;},
 325         {&quot;locals&quot;,       &quot;n&quot;,         &quot;y&quot;},
 326         {&quot;lock&quot;,         &quot;n&quot;,         &quot;n&quot;},
 327         {&quot;memory&quot;,       &quot;n&quot;,         &quot;y&quot;},
 328         {&quot;methods&quot;,      &quot;n&quot;,         &quot;y&quot;},
 329         {&quot;monitor&quot;,      &quot;n&quot;,         &quot;n&quot;},
 330         {&quot;next&quot;,         &quot;n&quot;,         &quot;n&quot;},
 331         {&quot;pop&quot;,          &quot;n&quot;,         &quot;n&quot;},
 332         {&quot;print&quot;,        &quot;n&quot;,         &quot;y&quot;},
 333         {&quot;quit&quot;,         &quot;y&quot;,         &quot;y&quot;},
 334         {&quot;read&quot;,         &quot;y&quot;,         &quot;y&quot;},
 335         {&quot;redefine&quot;,     &quot;n&quot;,         &quot;n&quot;},
 336         {&quot;reenter&quot;,      &quot;n&quot;,         &quot;n&quot;},
 337         {&quot;resume&quot;,       &quot;n&quot;,         &quot;n&quot;},
 338         {&quot;run&quot;,          &quot;y&quot;,         &quot;n&quot;},
 339         {&quot;save&quot;,         &quot;n&quot;,         &quot;n&quot;},
 340         {&quot;set&quot;,          &quot;n&quot;,         &quot;n&quot;},
 341         {&quot;sourcepath&quot;,   &quot;y&quot;,         &quot;y&quot;},
 342         {&quot;step&quot;,         &quot;n&quot;,         &quot;n&quot;},
 343         {&quot;stepi&quot;,        &quot;n&quot;,         &quot;n&quot;},
 344         {&quot;stop&quot;,         &quot;y&quot;,         &quot;n&quot;},
 345         {&quot;suspend&quot;,      &quot;n&quot;,         &quot;n&quot;},
 346         {&quot;thread&quot;,       &quot;n&quot;,         &quot;y&quot;},
 347         {&quot;threadgroup&quot;,  &quot;n&quot;,         &quot;y&quot;},
 348         {&quot;threadgroups&quot;, &quot;n&quot;,         &quot;y&quot;},
 349         {&quot;threadlocks&quot;,  &quot;n&quot;,         &quot;y&quot;},
 350         {&quot;threads&quot;,      &quot;n&quot;,         &quot;y&quot;},
 351         {&quot;trace&quot;,        &quot;n&quot;,         &quot;n&quot;},
 352         {&quot;unmonitor&quot;,    &quot;n&quot;,         &quot;n&quot;},
 353         {&quot;untrace&quot;,      &quot;n&quot;,         &quot;n&quot;},
 354         {&quot;unwatch&quot;,      &quot;y&quot;,         &quot;n&quot;},
 355         {&quot;up&quot;,           &quot;n&quot;,         &quot;y&quot;},
 356         {&quot;use&quot;,          &quot;y&quot;,         &quot;y&quot;},
 357         {&quot;version&quot;,      &quot;y&quot;,         &quot;y&quot;},
 358         {&quot;watch&quot;,        &quot;y&quot;,         &quot;n&quot;},
 359         {&quot;where&quot;,        &quot;n&quot;,         &quot;y&quot;},
 360         {&quot;wherei&quot;,       &quot;n&quot;,         &quot;y&quot;},
 361     };
 362 
 363     /*
 364      * Look up the command string in commandList.
 365      * If found, return the index.
 366      * If not found, return index &lt; 0
 367      */
 368     private int isCommand(String key) {
 369         //Reference: binarySearch() in java/util/Arrays.java
 370         //           Adapted for use with String[][0].
 371         int low = 0;
 372         int high = commandList.length - 1;
 373         while (low &lt;= high) {
 374             int mid = (low + high) &gt;&gt;&gt; 1;
 375             String midVal = commandList[mid][0];
 376             int compare = midVal.compareTo(key);
 377             if (compare &lt; 0) {
 378                 low = mid + 1;
 379             } else if (compare &gt; 0) {
 380                 high = mid - 1;
 381             }
 382             else {
 383                 return mid; // key found
 384         }
 385         }
 386         return -(low + 1);  // key not found.
 387     };
 388 
 389     /*
 390      * Return true if the command is OK when disconnected.
 391      */
 392     private boolean isDisconnectCmd(int ii) {
 393         if (ii &lt; 0 || ii &gt;= commandList.length) {
 394             return false;
 395         }
 396         return (commandList[ii][1].equals(&quot;y&quot;));
 397     }
 398 
 399     /*
 400      * Return true if the command is OK when readonly.
 401      */
 402     private boolean isReadOnlyCmd(int ii) {
 403         if (ii &lt; 0 || ii &gt;= commandList.length) {
 404             return false;
 405         }
 406         return (commandList[ii][2].equals(&quot;y&quot;));
 407     };
 408 
 409 
 410     void executeCommand(StringTokenizer t) {
 411         String cmd = t.nextToken().toLowerCase();
 412         // Normally, prompt for the next command after this one is done
 413         boolean showPrompt = true;
 414 
 415 
 416         /*
 417          * Anything starting with # is discarded as a no-op or &#39;comment&#39;.
 418          */
 419         if (!cmd.startsWith(&quot;#&quot;)) {
 420             /*
 421              * Next check for an integer repetition prefix.  If found,
 422              * recursively execute cmd that number of times.
 423              */
 424             if (Character.isDigit(cmd.charAt(0)) &amp;&amp; t.hasMoreTokens()) {
 425                 try {
 426                     int repeat = Integer.parseInt(cmd);
 427                     String subcom = t.nextToken(&quot;&quot;);
 428                     while (repeat-- &gt; 0) {
 429                         executeCommand(new StringTokenizer(subcom));
 430                         showPrompt = false; // Bypass the printPrompt() below.
 431                     }
 432                 } catch (NumberFormatException exc) {
 433                     MessageOutput.println(&quot;Unrecognized command.  Try help...&quot;, cmd);
 434                 }
 435             } else {
 436                 int commandNumber = isCommand(cmd);
 437                 /*
 438                  * Check for an unknown command
 439                  */
 440                 if (commandNumber &lt; 0) {
 441                     MessageOutput.println(&quot;Unrecognized command.  Try help...&quot;, cmd);
 442                 } else if (!Env.connection().isOpen() &amp;&amp; !isDisconnectCmd(commandNumber)) {
 443                     MessageOutput.println(&quot;Command not valid until the VM is started with the run command&quot;,
 444                                           cmd);
 445                 } else if (Env.connection().isOpen() &amp;&amp; !Env.vm().canBeModified() &amp;&amp;
 446                            !isReadOnlyCmd(commandNumber)) {
 447                     MessageOutput.println(&quot;Command is not supported on a read-only VM connection&quot;,
 448                                           cmd);
 449                 } else {
 450 
 451                     Commands evaluator = new Commands();
 452                     try {
 453                         if (cmd.equals(&quot;print&quot;)) {
 454                             evaluator.commandPrint(t, false);
 455                             showPrompt = false;        // asynchronous command
 456                         } else if (cmd.equals(&quot;eval&quot;)) {
 457                             evaluator.commandPrint(t, false);
 458                             showPrompt = false;        // asynchronous command
 459                         } else if (cmd.equals(&quot;set&quot;)) {
 460                             evaluator.commandSet(t);
 461                             showPrompt = false;        // asynchronous command
 462                         } else if (cmd.equals(&quot;dump&quot;)) {
 463                             evaluator.commandPrint(t, true);
 464                             showPrompt = false;        // asynchronous command
 465                         } else if (cmd.equals(&quot;locals&quot;)) {
 466                             evaluator.commandLocals();
 467                         } else if (cmd.equals(&quot;classes&quot;)) {
 468                             evaluator.commandClasses();
 469                         } else if (cmd.equals(&quot;class&quot;)) {
 470                             evaluator.commandClass(t);
 471                         } else if (cmd.equals(&quot;connectors&quot;)) {
 472                             evaluator.commandConnectors(Bootstrap.virtualMachineManager());
 473                         } else if (cmd.equals(&quot;methods&quot;)) {
 474                             evaluator.commandMethods(t);
 475                         } else if (cmd.equals(&quot;fields&quot;)) {
 476                             evaluator.commandFields(t);
 477                         } else if (cmd.equals(&quot;threads&quot;)) {
 478                             evaluator.commandThreads(t);
 479                         } else if (cmd.equals(&quot;thread&quot;)) {
 480                             evaluator.commandThread(t);
 481                         } else if (cmd.equals(&quot;suspend&quot;)) {
 482                             evaluator.commandSuspend(t);
 483                         } else if (cmd.equals(&quot;resume&quot;)) {
 484                             evaluator.commandResume(t);
 485                         } else if (cmd.equals(&quot;cont&quot;)) {
 486                             MessageOutput.printPrompt(true);
 487                             showPrompt = false;
 488                             evaluator.commandCont();
 489                         } else if (cmd.equals(&quot;threadgroups&quot;)) {
 490                             evaluator.commandThreadGroups();
 491                         } else if (cmd.equals(&quot;threadgroup&quot;)) {
 492                             evaluator.commandThreadGroup(t);
 493                         } else if (cmd.equals(&quot;catch&quot;)) {
 494                             evaluator.commandCatchException(t);
 495                         } else if (cmd.equals(&quot;ignore&quot;)) {
 496                             evaluator.commandIgnoreException(t);
 497                         } else if (cmd.equals(&quot;step&quot;)) {
 498                             MessageOutput.printPrompt(true);
 499                             showPrompt = false;
 500                             evaluator.commandStep(t);
 501                         } else if (cmd.equals(&quot;stepi&quot;)) {
 502                             MessageOutput.printPrompt(true);
 503                             showPrompt = false;
 504                             evaluator.commandStepi();
 505                         } else if (cmd.equals(&quot;next&quot;)) {
 506                             MessageOutput.printPrompt(true);
 507                             showPrompt = false;
 508                             evaluator.commandNext();
 509                         } else if (cmd.equals(&quot;kill&quot;)) {
 510                             showPrompt = false;        // asynchronous command
 511                             evaluator.commandKill(t);
 512                         } else if (cmd.equals(&quot;interrupt&quot;)) {
 513                             evaluator.commandInterrupt(t);
 514                         } else if (cmd.equals(&quot;trace&quot;)) {
 515                             evaluator.commandTrace(t);
 516                         } else if (cmd.equals(&quot;untrace&quot;)) {
 517                             evaluator.commandUntrace(t);
 518                         } else if (cmd.equals(&quot;where&quot;)) {
 519                             evaluator.commandWhere(t, false);
 520                         } else if (cmd.equals(&quot;wherei&quot;)) {
 521                             evaluator.commandWhere(t, true);
 522                         } else if (cmd.equals(&quot;up&quot;)) {
 523                             evaluator.commandUp(t);
 524                         } else if (cmd.equals(&quot;down&quot;)) {
 525                             evaluator.commandDown(t);
 526                         } else if (cmd.equals(&quot;load&quot;)) {
 527                             evaluator.commandLoad(t);
 528                         } else if (cmd.equals(&quot;run&quot;)) {
 529                             evaluator.commandRun(t);
 530                             /*
 531                              * Fire up an event handler, if the connection was just
 532                              * opened. Since this was done from the run command
 533                              * we don&#39;t stop the VM on its VM start event (so
 534                              * arg 2 is false).
 535                              */
 536                             if ((handler == null) &amp;&amp; Env.connection().isOpen()) {
 537                                 handler = new EventHandler(this, false);
 538                             }
 539                         } else if (cmd.equals(&quot;memory&quot;)) {
 540                             evaluator.commandMemory();
 541                         } else if (cmd.equals(&quot;gc&quot;)) {
 542                             evaluator.commandGC();
 543                         } else if (cmd.equals(&quot;stop&quot;)) {
 544                             evaluator.commandStop(t);
 545                         } else if (cmd.equals(&quot;clear&quot;)) {
 546                             evaluator.commandClear(t);
 547                         } else if (cmd.equals(&quot;watch&quot;)) {
 548                             evaluator.commandWatch(t);
 549                         } else if (cmd.equals(&quot;unwatch&quot;)) {
 550                             evaluator.commandUnwatch(t);
 551                         } else if (cmd.equals(&quot;list&quot;)) {
 552                             evaluator.commandList(t);
 553                         } else if (cmd.equals(&quot;lines&quot;)) { // Undocumented command: useful for testing.
 554                             evaluator.commandLines(t);
 555                         } else if (cmd.equals(&quot;classpath&quot;)) {
 556                             evaluator.commandClasspath(t);
 557                         } else if (cmd.equals(&quot;use&quot;) || cmd.equals(&quot;sourcepath&quot;)) {
 558                             evaluator.commandUse(t);
 559                         } else if (cmd.equals(&quot;monitor&quot;)) {
 560                             monitorCommand(t);
 561                         } else if (cmd.equals(&quot;unmonitor&quot;)) {
 562                             unmonitorCommand(t);
 563                         } else if (cmd.equals(&quot;lock&quot;)) {
 564                             evaluator.commandLock(t);
 565                             showPrompt = false;        // asynchronous command
 566                         } else if (cmd.equals(&quot;threadlocks&quot;)) {
 567                             evaluator.commandThreadlocks(t);
 568                         } else if (cmd.equals(&quot;disablegc&quot;)) {
 569                             evaluator.commandDisableGC(t);
 570                             showPrompt = false;        // asynchronous command
 571                         } else if (cmd.equals(&quot;enablegc&quot;)) {
 572                             evaluator.commandEnableGC(t);
 573                             showPrompt = false;        // asynchronous command
 574                         } else if (cmd.equals(&quot;save&quot;)) { // Undocumented command: useful for testing.
 575                             evaluator.commandSave(t);
 576                             showPrompt = false;        // asynchronous command
 577                         } else if (cmd.equals(&quot;bytecodes&quot;)) { // Undocumented command: useful for testing.
 578                             evaluator.commandBytecodes(t);
 579                         } else if (cmd.equals(&quot;redefine&quot;)) {
 580                             evaluator.commandRedefine(t);
 581                         } else if (cmd.equals(&quot;pop&quot;)) {
 582                             evaluator.commandPopFrames(t, false);
 583                         } else if (cmd.equals(&quot;reenter&quot;)) {
 584                             evaluator.commandPopFrames(t, true);
 585                         } else if (cmd.equals(&quot;extension&quot;)) {
 586                             evaluator.commandExtension(t);
 587                         } else if (cmd.equals(&quot;exclude&quot;)) {
 588                             evaluator.commandExclude(t);
 589                         } else if (cmd.equals(&quot;read&quot;)) {
 590                             readCommand(t);
 591                         } else if (cmd.equals(&quot;dbgtrace&quot;)) {
 592                             evaluator.commandDbgTrace(t);
 593                         } else if (cmd.equals(&quot;help&quot;) || cmd.equals(&quot;?&quot;)) {
 594                             help();
 595                         } else if (cmd.equals(&quot;version&quot;)) {
 596                             evaluator.commandVersion(progname,
 597                                                      Bootstrap.virtualMachineManager());
 598                         } else if (cmd.equals(&quot;quit&quot;) || cmd.equals(&quot;exit&quot;)) {
 599                             if (handler != null) {
 600                                 handler.shutdown();
 601                             }
 602                             Env.shutdown();
 603                         } else {
 604                             MessageOutput.println(&quot;Unrecognized command.  Try help...&quot;, cmd);
 605                         }
 606                     } catch (VMCannotBeModifiedException rovm) {
 607                         MessageOutput.println(&quot;Command is not supported on a read-only VM connection&quot;, cmd);
 608                     } catch (UnsupportedOperationException uoe) {
 609                         MessageOutput.println(&quot;Command is not supported on the target VM&quot;, cmd);
 610                     } catch (VMNotConnectedException vmnse) {
 611                         MessageOutput.println(&quot;Command not valid until the VM is started with the run command&quot;,
 612                                               cmd);
 613                     } catch (Exception e) {
 614                         MessageOutput.printException(&quot;Internal exception:&quot;, e);
 615                     }
 616                 }
 617             }
 618         }
 619         if (showPrompt) {
 620             MessageOutput.printPrompt();
 621         }
 622     }
 623 
 624     /*
 625      * Maintain a list of commands to execute each time the VM is suspended.
 626      */
 627     void monitorCommand(StringTokenizer t) {
 628         if (t.hasMoreTokens()) {
 629             ++monitorCount;
 630             monitorCommands.add(monitorCount + &quot;: &quot; + t.nextToken(&quot;&quot;));
 631         } else {
 632             for (String cmd : monitorCommands) {
 633                 MessageOutput.printDirectln(cmd);// Special case: use printDirectln()
 634             }
 635         }
 636     }
 637 
 638     void unmonitorCommand(StringTokenizer t) {
 639         if (t.hasMoreTokens()) {
 640             String monTok = t.nextToken();
 641             int monNum;
 642             try {
 643                 monNum = Integer.parseInt(monTok);
 644             } catch (NumberFormatException exc) {
 645                 MessageOutput.println(&quot;Not a monitor number:&quot;, monTok);
 646                 return;
 647             }
 648             String monStr = monTok + &quot;:&quot;;
 649             for (String cmd : monitorCommands) {
 650                 StringTokenizer ct = new StringTokenizer(cmd);
 651                 if (ct.nextToken().equals(monStr)) {
 652                     monitorCommands.remove(cmd);
 653                     MessageOutput.println(&quot;Unmonitoring&quot;, cmd);
 654                     return;
 655                 }
 656             }
 657             MessageOutput.println(&quot;No monitor numbered:&quot;, monTok);
 658         } else {
 659             MessageOutput.println(&quot;Usage: unmonitor &lt;monitor#&gt;&quot;);
 660         }
 661     }
 662 
 663 
 664     void readCommand(StringTokenizer t) {
 665         if (t.hasMoreTokens()) {
 666             String cmdfname = t.nextToken();
 667             if (!readCommandFile(new File(cmdfname))) {
 668                 MessageOutput.println(&quot;Could not open:&quot;, cmdfname);
 669             }
 670         } else {
 671             MessageOutput.println(&quot;Usage: read &lt;command-filename&gt;&quot;);
 672         }
 673     }
 674 
 675     /**
 676      * Read and execute a command file.  Return true if the file was read
 677      * else false;
 678      */
 679     boolean readCommandFile(File f) {
 680         BufferedReader inFile = null;
 681         try {
 682             if (f.canRead()) {
 683                 // Process initial commands.
 684                 MessageOutput.println(&quot;*** Reading commands from&quot;, f.getPath());
 685                 inFile = new BufferedReader(new FileReader(f));
 686                 String ln;
 687                 while ((ln = inFile.readLine()) != null) {
 688                     StringTokenizer t = new StringTokenizer(ln);
 689                     if (t.hasMoreTokens()) {
 690                         executeCommand(t);
 691                     }
 692                 }
 693             }
 694         } catch (IOException e) {
 695         } finally {
 696             if (inFile != null) {
 697                 try {
 698                     inFile.close();
 699                 } catch (Exception exc) {
 700                 }
 701             }
 702         }
 703         return inFile != null;
 704     }
 705 
 706     /**
 707      * Try to read commands from dir/fname, unless
 708      * the canonical path passed in is the same as that
 709      * for dir/fname.
 710      * Return null if that file doesn&#39;t exist,
 711      * else return the canonical path of that file.
 712      */
 713     String readStartupCommandFile(String dir, String fname, String canonPath) {
 714         File dotInitFile = new File(dir, fname);
 715         if (!dotInitFile.exists()) {
 716             return null;
 717         }
 718 
 719         String myCanonFile;
 720         try {
 721             myCanonFile = dotInitFile.getCanonicalPath();
 722         } catch (IOException ee) {
 723             MessageOutput.println(&quot;Could not open:&quot;, dotInitFile.getPath());
 724             return null;
 725         }
 726         if (canonPath == null || !canonPath.equals(myCanonFile)) {
 727             if (!readCommandFile(dotInitFile)) {
 728                 MessageOutput.println(&quot;Could not open:&quot;, dotInitFile.getPath());
 729             }
 730         }
 731         return myCanonFile;
 732     }
 733 
 734 
 735     public TTY() throws Exception {
 736 
 737         MessageOutput.println(&quot;Initializing progname&quot;, progname);
 738 
 739         if (Env.connection().isOpen() &amp;&amp; Env.vm().canBeModified()) {
 740             /*
 741              * Connection opened on startup. Start event handler
 742              * immediately, telling it (through arg 2) to stop on the
 743              * VM start event.
 744              */
 745             this.handler = new EventHandler(this, true);
 746         }
 747         try {
 748             BufferedReader in =
 749                     new BufferedReader(new InputStreamReader(System.in));
 750 
 751             String lastLine = null;
 752 
 753             Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
 754 
 755             /*
 756              * Read start up files.  This mimics the behavior
 757              * of gdb which will read both ~/.gdbinit and then
 758              * ./.gdbinit if they exist.  We have the twist that
 759              * we allow two different names, so we do this:
 760              *  if ~/jdb.ini exists,
 761              *      read it
 762              *  else if ~/.jdbrc exists,
 763              *      read it
 764              *
 765              *  if ./jdb.ini exists,
 766              *      if it hasn&#39;t been read, read it
 767              *      It could have been read above because ~ == .
 768              *      or because of symlinks, ...
 769              *  else if ./jdbrx exists
 770              *      if it hasn&#39;t been read, read it
 771              */
 772             {
 773                 String userHome = System.getProperty(&quot;user.home&quot;);
 774                 String canonPath;
 775 
 776                 if ((canonPath = readStartupCommandFile(userHome, &quot;jdb.ini&quot;, null)) == null) {
 777                     // Doesn&#39;t exist, try alternate spelling
 778                     canonPath = readStartupCommandFile(userHome, &quot;.jdbrc&quot;, null);
 779                 }
 780 
 781                 String userDir = System.getProperty(&quot;user.dir&quot;);
 782                 if (readStartupCommandFile(userDir, &quot;jdb.ini&quot;, canonPath) == null) {
 783                     // Doesn&#39;t exist, try alternate spelling
 784                     readStartupCommandFile(userDir, &quot;.jdbrc&quot;, canonPath);
 785                 }
 786             }
 787 
 788             // Process interactive commands.
 789             MessageOutput.printPrompt();
 790             while (true) {
 791                 String ln = in.readLine();
 792                 if (ln == null) {
 793                     /*
 794                      *  Jdb is being shutdown because debuggee exited, ignore any &#39;null&#39;
 795                      *  returned by readLine() during shutdown. JDK-8154144.
 796                      */
 797                     if (!isShuttingDown()) {
 798                         MessageOutput.println(&quot;Input stream closed.&quot;);
 799                     }
 800                     ln = &quot;quit&quot;;
 801                 }
 802 
 803                 if (ln.startsWith(&quot;!!&quot;) &amp;&amp; lastLine != null) {
 804                     ln = lastLine + ln.substring(2);
 805                     MessageOutput.printDirectln(ln);// Special case: use printDirectln()
 806                 }
 807 
 808                 StringTokenizer t = new StringTokenizer(ln);
 809                 if (t.hasMoreTokens()) {
 810                     lastLine = ln;
 811                     executeCommand(t);
 812                 } else {
 813                     MessageOutput.printPrompt();
 814                 }
 815             }
 816         } catch (VMDisconnectedException e) {
 817             handler.handleDisconnectedException();
 818         }
 819     }
 820 
 821     private static void usage() {
 822         MessageOutput.println(&quot;zz usage text&quot;, new Object [] {progname,
 823                                                      File.pathSeparator});
 824         System.exit(0);
 825     }
 826 
 827     static void usageError(String messageKey) {
 828         MessageOutput.println(messageKey);
 829         MessageOutput.println();
 830         usage();
 831     }
 832 
 833     static void usageError(String messageKey, String argument) {
 834         MessageOutput.println(messageKey, argument);
 835         MessageOutput.println();
 836         usage();
 837     }
 838 
 839     private static boolean supportsSharedMemory() {
 840         for (Connector connector :
 841                  Bootstrap.virtualMachineManager().allConnectors()) {
 842             if (connector.transport() == null) {
 843                 continue;
 844             }
 845             if (&quot;dt_shmem&quot;.equals(connector.transport().name())) {
 846                 return true;
 847             }
 848         }
 849         return false;
 850     }
 851 
 852     private static String addressToSocketArgs(String address) {
 853         int index = address.indexOf(&#39;:&#39;);
 854         if (index != -1) {
 855             String hostString = address.substring(0, index);
 856             String portString = address.substring(index + 1);
 857             return &quot;hostname=&quot; + hostString + &quot;,port=&quot; + portString;
 858         } else {
 859             return &quot;port=&quot; + address;
 860         }
 861     }
 862 
 863     private static boolean hasWhitespace(String string) {
 864         int length = string.length();
 865         for (int i = 0; i &lt; length; i++) {
 866             if (Character.isWhitespace(string.charAt(i))) {
 867                 return true;
 868             }
 869         }
 870         return false;
 871     }
 872 
 873     private static String addArgument(String string, String argument) {
 874         if (hasWhitespace(argument) || argument.indexOf(&#39;,&#39;) != -1) {
 875             // Quotes were stripped out for this argument, add &#39;em back.
 876             StringBuilder sb = new StringBuilder(string);
 877             sb.append(&#39;&quot;&#39;);
 878             for (int i = 0; i &lt; argument.length(); i++) {
 879                 char c = argument.charAt(i);
 880                 if (c == &#39;&quot;&#39;) {
 881                     sb.append(&#39;\\&#39;);
 882                 }
 883                 sb.append(c);
 884             }
 885             sb.append(&quot;\&quot; &quot;);
 886             return sb.toString();
 887         } else {
 888             return string + argument + &#39; &#39;;
 889         }
 890     }
 891 
 892     public static void main(String argv[]) throws MissingResourceException {
 893         String cmdLine = &quot;&quot;;
 894         String javaArgs = &quot;&quot;;
 895         int traceFlags = VirtualMachine.TRACE_NONE;
 896         boolean launchImmediately = false;
 897         String connectSpec = null;
 898 
 899         MessageOutput.textResources = ResourceBundle.getBundle
 900             (&quot;com.sun.tools.example.debug.tty.TTYResources&quot;,
 901              Locale.getDefault());
 902 
 903         for (int i = 0; i &lt; argv.length; i++) {
 904             String token = argv[i];
 905             if (token.equals(&quot;-dbgtrace&quot;)) {
 906                 if ((i == argv.length - 1) ||
 907                     ! Character.isDigit(argv[i+1].charAt(0))) {
 908                     traceFlags = VirtualMachine.TRACE_ALL;
 909                 } else {
 910                     String flagStr = &quot;&quot;;
 911                     try {
 912                         flagStr = argv[++i];
 913                         traceFlags = Integer.decode(flagStr).intValue();
 914                     } catch (NumberFormatException nfe) {
 915                         usageError(&quot;dbgtrace flag value must be an integer:&quot;,
 916                                    flagStr);
 917                         return;
 918                     }
 919                 }
 920             } else if (token.equals(&quot;-X&quot;)) {
 921                 usageError(&quot;Use java minus X to see&quot;);
 922                 return;
 923             } else if (
 924                    // Standard VM options passed on
 925                    token.equals(&quot;-v&quot;) || token.startsWith(&quot;-v:&quot;) ||  // -v[:...]
 926                    token.startsWith(&quot;-verbose&quot;) ||                  // -verbose[:...]
 927                    token.startsWith(&quot;-D&quot;) ||
 928                    // -classpath handled below
 929                    // NonStandard options passed on
 930                    token.startsWith(&quot;-X&quot;) ||
 931                    // Old-style options (These should remain in place as long as
 932                    //  the standard VM accepts them)
 933                    token.equals(&quot;-noasyncgc&quot;) || token.equals(&quot;-prof&quot;) ||
 934                    token.equals(&quot;-verify&quot;) ||
 935                    token.equals(&quot;-verifyremote&quot;) ||
 936                    token.equals(&quot;-verbosegc&quot;) ||
 937                    token.startsWith(&quot;-ms&quot;) || token.startsWith(&quot;-mx&quot;) ||
 938                    token.startsWith(&quot;-ss&quot;) || token.startsWith(&quot;-oss&quot;) ) {
 939 
 940                 javaArgs = addArgument(javaArgs, token);
 941             } else if (token.equals(&quot;-tclassic&quot;)) {
 942                 usageError(&quot;Classic VM no longer supported.&quot;);
 943                 return;
 944             } else if (token.equals(&quot;-tclient&quot;)) {
 945                 // -client must be the first one
 946                 javaArgs = &quot;-client &quot; + javaArgs;
 947             } else if (token.equals(&quot;-tserver&quot;)) {
 948                 // -server must be the first one
 949                 javaArgs = &quot;-server &quot; + javaArgs;
 950             } else if (token.equals(&quot;-sourcepath&quot;)) {
 951                 if (i == (argv.length - 1)) {
 952                     usageError(&quot;No sourcepath specified.&quot;);
 953                     return;
 954                 }
 955                 Env.setSourcePath(argv[++i]);
 956             } else if (token.equals(&quot;-classpath&quot;)) {
 957                 if (i == (argv.length - 1)) {
 958                     usageError(&quot;No classpath specified.&quot;);
 959                     return;
 960                 }
 961                 javaArgs = addArgument(javaArgs, token);
 962                 javaArgs = addArgument(javaArgs, argv[++i]);
 963             } else if (token.equals(&quot;-attach&quot;)) {
 964                 if (connectSpec != null) {
 965                     usageError(&quot;cannot redefine existing connection&quot;, token);
 966                     return;
 967                 }
 968                 if (i == (argv.length - 1)) {
 969                     usageError(&quot;No attach address specified.&quot;);
 970                     return;
 971                 }
 972                 String address = argv[++i];
 973 
 974                 /*
 975                  * -attach is shorthand for one of the reference implementation&#39;s
 976                  * attaching connectors. Use the shared memory attach if it&#39;s
 977                  * available; otherwise, use sockets. Build a connect
 978                  * specification string based on this decision.
 979                  */
 980                 if (supportsSharedMemory()) {
 981                     connectSpec = &quot;com.sun.jdi.SharedMemoryAttach:name=&quot; +
 982                                    address;
 983                 } else {
 984                     String suboptions = addressToSocketArgs(address);
 985                     connectSpec = &quot;com.sun.jdi.SocketAttach:&quot; + suboptions;
 986                 }
 987             } else if (token.equals(&quot;-listen&quot;) || token.equals(&quot;-listenany&quot;)) {
 988                 if (connectSpec != null) {
 989                     usageError(&quot;cannot redefine existing connection&quot;, token);
 990                     return;
 991                 }
 992                 String address = null;
 993                 if (token.equals(&quot;-listen&quot;)) {
 994                     if (i == (argv.length - 1)) {
 995                         usageError(&quot;No attach address specified.&quot;);
 996                         return;
 997                     }
 998                     address = argv[++i];
 999                 }
1000 
1001                 /*
1002                  * -listen[any] is shorthand for one of the reference implementation&#39;s
1003                  * listening connectors. Use the shared memory listen if it&#39;s
1004                  * available; otherwise, use sockets. Build a connect
1005                  * specification string based on this decision.
1006                  */
1007                 if (supportsSharedMemory()) {
1008                     connectSpec = &quot;com.sun.jdi.SharedMemoryListen:&quot;;
1009                     if (address != null) {
1010                         connectSpec += (&quot;name=&quot; + address);
1011                     }
1012                 } else {
1013                     connectSpec = &quot;com.sun.jdi.SocketListen:&quot;;
1014                     if (address != null) {
1015                         connectSpec += addressToSocketArgs(address);
1016                     }
1017                 }
1018             } else if (token.equals(&quot;-launch&quot;)) {
1019                 launchImmediately = true;
1020             } else if (token.equals(&quot;-listconnectors&quot;)) {
1021                 Commands evaluator = new Commands();
1022                 evaluator.commandConnectors(Bootstrap.virtualMachineManager());
1023                 return;
1024             } else if (token.equals(&quot;-connect&quot;)) {
1025                 /*
1026                  * -connect allows the user to pick the connector
1027                  * used in bringing up the target VM. This allows
1028                  * use of connectors other than those in the reference
1029                  * implementation.
1030                  */
1031                 if (connectSpec != null) {
1032                     usageError(&quot;cannot redefine existing connection&quot;, token);
1033                     return;
1034                 }
1035                 if (i == (argv.length - 1)) {
1036                     usageError(&quot;No connect specification.&quot;);
1037                     return;
1038                 }
1039                 connectSpec = argv[++i];
1040             } else if (token.equals(&quot;-?&quot;) ||
1041                        token.equals(&quot;-h&quot;) ||
1042                        token.equals(&quot;--help&quot;) ||
1043                        // -help: legacy.
1044                        token.equals(&quot;-help&quot;)) {
1045                 usage();
1046             } else if (token.equals(&quot;-version&quot;)) {
1047                 Commands evaluator = new Commands();
1048                 evaluator.commandVersion(progname,
1049                                          Bootstrap.virtualMachineManager());
1050                 System.exit(0);
1051             } else if (token.startsWith(&quot;-&quot;)) {
1052                 usageError(&quot;invalid option&quot;, token);
1053                 return;
1054             } else {
1055                 // Everything from here is part of the command line
1056                 cmdLine = addArgument(&quot;&quot;, token);
1057                 for (i++; i &lt; argv.length; i++) {
1058                     cmdLine = addArgument(cmdLine, argv[i]);
1059                 }
1060                 break;
1061             }
1062         }
1063 
1064         /*
1065          * Unless otherwise specified, set the default connect spec.
1066          */
1067 
1068         /*
1069          * Here are examples of jdb command lines and how the options
1070          * are interpreted as arguments to the program being debugged.
1071          * arg1       arg2
1072          * ----       ----
1073          * jdb hello a b       a          b
1074          * jdb hello &quot;a b&quot;     a b
1075          * jdb hello a,b       a,b
1076          * jdb hello a, b      a,         b
1077          * jdb hello &quot;a, b&quot;    a, b
1078          * jdb -connect &quot;com.sun.jdi.CommandLineLaunch:main=hello  a,b&quot;   illegal
1079          * jdb -connect  com.sun.jdi.CommandLineLaunch:main=hello &quot;a,b&quot;   illegal
1080          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello &quot;a,b&quot;&#39;  arg1 = a,b
1081          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello &quot;a b&quot;&#39;  arg1 = a b
1082          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello  a b&#39;   arg1 = a  arg2 = b
1083          * jdb -connect &#39;com.sun.jdi.CommandLineLaunch:main=hello &quot;a,&quot; b&#39; arg1 = a, arg2 = b
1084          */
1085         if (connectSpec == null) {
1086             connectSpec = &quot;com.sun.jdi.CommandLineLaunch:&quot;;
1087         } else if (!connectSpec.endsWith(&quot;,&quot;) &amp;&amp; !connectSpec.endsWith(&quot;:&quot;)) {
1088             connectSpec += &quot;,&quot;; // (Bug ID 4285874)
1089         }
1090 
1091         cmdLine = cmdLine.trim();
1092         javaArgs = javaArgs.trim();
1093 
1094         if (cmdLine.length() &gt; 0) {
1095             if (!connectSpec.startsWith(&quot;com.sun.jdi.CommandLineLaunch:&quot;)) {
1096                 usageError(&quot;Cannot specify command line with connector:&quot;,
1097                            connectSpec);
1098                 return;
1099             }
1100             connectSpec += &quot;main=&quot; + cmdLine + &quot;,&quot;;
1101         }
1102 
1103         if (javaArgs.length() &gt; 0) {
1104             if (!connectSpec.startsWith(&quot;com.sun.jdi.CommandLineLaunch:&quot;)) {
1105                 usageError(&quot;Cannot specify target vm arguments with connector:&quot;,
1106                            connectSpec);
1107                 return;
1108             }
1109             connectSpec += &quot;options=&quot; + javaArgs + &quot;,&quot;;
1110         }
1111 
1112         try {
1113             if (! connectSpec.endsWith(&quot;,&quot;)) {
1114                 connectSpec += &quot;,&quot;; // (Bug ID 4285874)
1115             }
1116             Env.init(connectSpec, launchImmediately, traceFlags);
1117             new TTY();
1118         } catch(Exception e) {
1119             MessageOutput.printException(&quot;Internal exception:&quot;, e);
1120         }
1121     }
1122 }
    </pre>
  </body>
</html>
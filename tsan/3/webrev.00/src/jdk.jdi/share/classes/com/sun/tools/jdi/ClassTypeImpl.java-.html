<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdi/share/classes/com/sun/tools/jdi/ClassTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.jdi;
 27 
 28 import java.util.ArrayList;
 29 import java.util.List;
 30 
 31 import com.sun.jdi.ClassNotLoadedException;
 32 import com.sun.jdi.ClassType;
 33 import com.sun.jdi.Field;
 34 import com.sun.jdi.IncompatibleThreadStateException;
 35 import com.sun.jdi.InterfaceType;
 36 import com.sun.jdi.InvalidTypeException;
 37 import com.sun.jdi.InvocationException;
 38 import com.sun.jdi.Method;
 39 import com.sun.jdi.ObjectReference;
 40 import com.sun.jdi.ReferenceType;
 41 import com.sun.jdi.ThreadReference;
 42 import com.sun.jdi.Value;
 43 import com.sun.jdi.VirtualMachine;
 44 
 45 final public class ClassTypeImpl extends InvokableTypeImpl
 46                                  implements ClassType
 47 {
 48     private static class IResult implements InvocationResult {
 49         final private JDWP.ClassType.InvokeMethod rslt;
 50 
 51         public IResult(JDWP.ClassType.InvokeMethod rslt) {
 52             this.rslt = rslt;
 53         }
 54 
 55         @Override
 56         public ObjectReferenceImpl getException() {
 57             return rslt.exception;
 58         }
 59 
 60         @Override
 61         public ValueImpl getResult() {
 62             return rslt.returnValue;
 63         }
 64     }
 65 
 66     private boolean cachedSuperclass = false;
 67     private ClassType superclass = null;
 68     private List&lt;InterfaceType&gt; interfaces = null;
 69 
 70     protected ClassTypeImpl(VirtualMachine aVm, long aRef) {
 71         super(aVm, aRef);
 72     }
 73 
 74     public ClassType superclass() {
 75         if (!cachedSuperclass)  {
 76             ClassTypeImpl sup = null;
 77             try {
 78                 sup = JDWP.ClassType.Superclass.
 79                     process(vm, this).superclass;
 80             } catch (JDWPException exc) {
 81                 throw exc.toJDIException();
 82             }
 83 
 84             /*
 85              * If there is a superclass, cache its
 86              * ClassType here. Otherwise,
 87              * leave the cache reference null.
 88              */
 89             if (sup != null) {
 90                 superclass = sup;
 91             }
 92             cachedSuperclass = true;
 93         }
 94 
 95         return superclass;
 96     }
 97 
 98     @Override
 99     public List&lt;InterfaceType&gt; interfaces()  {
100         if (interfaces == null) {
101             interfaces = getInterfaces();
102         }
103         return interfaces;
104     }
105 
106     @Override
107     public List&lt;InterfaceType&gt; allInterfaces() {
108         return getAllInterfaces();
109     }
110 
111     public List&lt;ClassType&gt; subclasses() {
112         List&lt;ClassType&gt; subs = new ArrayList&lt;&gt;();
113         for (ReferenceType refType : vm.allClasses()) {
114             if (refType instanceof ClassType) {
115                 ClassType clazz = (ClassType)refType;
116                 ClassType superclass = clazz.superclass();
117                 if ((superclass != null) &amp;&amp; superclass.equals(this)) {
118                     subs.add((ClassType)refType);
119                 }
120             }
121         }
122 
123         return subs;
124     }
125 
126     public boolean isEnum() {
127         ClassType superclass = superclass();
128         if (superclass != null &amp;&amp;
129             superclass.name().equals(&quot;java.lang.Enum&quot;)) {
130             return true;
131         }
132         return false;
133     }
134 
135     public void setValue(Field field, Value value)
136         throws InvalidTypeException, ClassNotLoadedException {
137 
138         validateMirror(field);
139         validateMirrorOrNull(value);
140         validateFieldSet(field);
141 
142         // More validation specific to setting from a ClassType
143         if(!field.isStatic()) {
144             throw new IllegalArgumentException(
145                             &quot;Must set non-static field through an instance&quot;);
146         }
147 
148         try {
149             JDWP.ClassType.SetValues.FieldValue[] values =
150                           new JDWP.ClassType.SetValues.FieldValue[1];
151             values[0] = new JDWP.ClassType.SetValues.FieldValue(
152                     ((FieldImpl)field).ref(),
153                     // validate and convert if necessary
154                     ValueImpl.prepareForAssignment(value, (FieldImpl)field));
155 
156             try {
157                 JDWP.ClassType.SetValues.process(vm, this, values);
158             } catch (JDWPException exc) {
159                 throw exc.toJDIException();
160             }
161         } catch (ClassNotLoadedException e) {
162             /*
163              * Since we got this exception,
164              * the field type must be a reference type. The value
165              * we&#39;re trying to set is null, but if the field&#39;s
166              * class has not yet been loaded through the enclosing
167              * class loader, then setting to null is essentially a
168              * no-op, and we should allow it without an exception.
169              */
170             if (value != null) {
171                 throw e;
172             }
173         }
174     }
175 
176     PacketStream sendNewInstanceCommand(final ThreadReferenceImpl thread,
177                                         final MethodImpl method,
178                                         final ValueImpl[] args,
179                                         final int options) {
180         CommandSender sender =
181             new CommandSender() {
182                 public PacketStream send() {
183                     return JDWP.ClassType.NewInstance.enqueueCommand(
184                                           vm, ClassTypeImpl.this, thread,
185                                           method.ref(), args, options);
186                 }
187         };
188 
189         PacketStream stream;
190         if ((options &amp; INVOKE_SINGLE_THREADED) != 0) {
191             stream = thread.sendResumingCommand(sender);
192         } else {
193             stream = vm.sendResumingCommand(sender);
194         }
195         return stream;
196     }
197 
198     public ObjectReference newInstance(ThreadReference threadIntf,
199                                        Method methodIntf,
200                                        List&lt;? extends Value&gt; origArguments,
201                                        int options)
202                                    throws InvalidTypeException,
203                                           ClassNotLoadedException,
204                                           IncompatibleThreadStateException,
205                                           InvocationException {
206         validateMirror(threadIntf);
207         validateMirror(methodIntf);
208         validateMirrorsOrNulls(origArguments);
209 
210         MethodImpl method = (MethodImpl)methodIntf;
211         ThreadReferenceImpl thread = (ThreadReferenceImpl)threadIntf;
212 
213         validateConstructorInvocation(method);
214 
215         List&lt;Value&gt; arguments = method.validateAndPrepareArgumentsForInvoke(
216                                                        origArguments);
217         ValueImpl[] args = arguments.toArray(new ValueImpl[0]);
218         JDWP.ClassType.NewInstance ret = null;
219         try {
220             PacketStream stream =
221                 sendNewInstanceCommand(thread, method, args, options);
222             ret = JDWP.ClassType.NewInstance.waitForReply(vm, stream);
223         } catch (JDWPException exc) {
224             if (exc.errorCode() == JDWP.Error.INVALID_THREAD) {
225                 throw new IncompatibleThreadStateException();
226             } else {
227                 throw exc.toJDIException();
228             }
229         }
230 
231         /*
232          * There is an implict VM-wide suspend at the conclusion
233          * of a normal (non-single-threaded) method invoke
234          */
235         if ((options &amp; INVOKE_SINGLE_THREADED) == 0) {
236             vm.notifySuspend();
237         }
238 
239         if (ret.exception != null) {
240             throw new InvocationException(ret.exception);
241         } else {
242             return ret.newObject;
243         }
244     }
245 
246     public Method concreteMethodByName(String name, String signature)  {
247         Method method = null;
248         for (Method candidate : visibleMethods()) {
249             if (candidate.name().equals(name) &amp;&amp;
250                 candidate.signature().equals(signature) &amp;&amp;
251                 !candidate.isAbstract()) {
252 
253                 method = candidate;
254                 break;
255             }
256         }
257         return method;
258     }
259 
260     void validateConstructorInvocation(Method method)
261                                    throws InvalidTypeException,
262                                           InvocationException {
263         /*
264          * Method must be in this class.
265          */
266         ReferenceTypeImpl declType = (ReferenceTypeImpl)method.declaringType();
267         if (!declType.equals(this)) {
268             throw new IllegalArgumentException(&quot;Invalid constructor&quot;);
269         }
270 
271         /*
272          * Method must be a constructor
273          */
274         if (!method.isConstructor()) {
275             throw new IllegalArgumentException(&quot;Cannot create instance with non-constructor&quot;);
276         }
277     }
278 
279     public String toString() {
280        return &quot;class &quot; + name() + &quot; (&quot; + loaderString() + &quot;)&quot;;
281     }
282 
283     @Override
284     CommandSender getInvokeMethodSender(ThreadReferenceImpl thread,
285                                         MethodImpl method,
286                                         ValueImpl[] args,
287                                         int options) {
288         return () -&gt;
289             JDWP.ClassType.InvokeMethod.enqueueCommand(vm,
290                                                        ClassTypeImpl.this,
291                                                        thread,
292                                                        method.ref(),
293                                                        args,
294                                                        options);
295     }
296 
297     @Override
298     InvocationResult waitForReply(PacketStream stream) throws JDWPException {
299         return new IResult(JDWP.ClassType.InvokeMethod.waitForReply(vm, stream));
300     }
301 
302     @Override
303     boolean canInvoke(Method method) {
304         // Method must be in this class or a superclass.
305         return ((ReferenceTypeImpl)method.declaringType()).isAssignableFrom(this);
306     }
307 }
    </pre>
  </body>
</html>
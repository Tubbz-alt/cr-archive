<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdi/share/classes/com/sun/tools/jdi/SocketTransportService.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.jdi;
 27 
 28 import java.io.IOException;
 29 import java.net.Inet6Address;
 30 import java.net.InetAddress;
 31 import java.net.InetSocketAddress;
 32 import java.net.ServerSocket;
 33 import java.net.Socket;
 34 import java.net.SocketTimeoutException;
 35 import java.net.UnknownHostException;
 36 import java.util.ResourceBundle;
 37 
 38 import com.sun.jdi.connect.TransportTimeoutException;
 39 import com.sun.jdi.connect.spi.Connection;
 40 import com.sun.jdi.connect.spi.TransportService;
 41 
 42 /*
 43  * A transport service based on a TCP connection between the
 44  * debugger and debugee.
 45  */
 46 
 47 public class SocketTransportService extends TransportService {
 48     private ResourceBundle messages = null;
 49 
 50     /**
 51      * The listener returned by startListening encapsulates
 52      * the ServerSocket.
 53      */
 54     static class SocketListenKey extends ListenKey {
 55         ServerSocket ss;
 56 
 57         SocketListenKey(ServerSocket ss) {
 58             this.ss = ss;
 59         }
 60 
 61         ServerSocket socket() {
 62             return ss;
 63         }
 64 
 65         /*
 66          * Returns the string representation of the address that this
 67          * listen key represents.
 68          */
 69         public String address() {
 70             InetAddress address = ss.getInetAddress();
 71 
 72             /*
 73              * If bound to the wildcard address then use current local
 74              * hostname. In the event that we don&#39;t know our own hostname
 75              * then assume that host supports IPv4 and return something to
 76              * represent the loopback address.
 77              */
 78             if (address.isAnyLocalAddress()) {
 79                 try {
 80                     address = InetAddress.getLocalHost();
 81                 } catch (UnknownHostException uhe) {
 82                     address = InetAddress.getLoopbackAddress();
 83                 }
 84             }
 85 
 86             /*
 87              * Now decide if we return a hostname or IP address. Where possible
 88              * return a hostname but in the case that we are bound to an
 89              * address that isn&#39;t registered in the name service then we
 90              * return an address.
 91              */
 92             String result;
 93             String hostname = address.getHostName();
 94             String hostaddr = address.getHostAddress();
 95             if (hostname.equals(hostaddr)) {
 96                 if (address instanceof Inet6Address) {
 97                     result = &quot;[&quot; + hostaddr + &quot;]&quot;;
 98                 } else {
 99                     result = hostaddr;
100                 }
101             } else {
102                 result = hostname;
103             }
104 
105             /*
106              * Finally return &quot;hostname:port&quot;, &quot;ipv4-address:port&quot; or
107              * &quot;[ipv6-address]:port&quot;.
108              */
109             return result + &quot;:&quot; + ss.getLocalPort();
110         }
111 
112         public String toString() {
113             return address();
114         }
115     }
116 
117     /**
118      * Handshake with the debuggee
119      */
120     void handshake(Socket s, long timeout) throws IOException {
121         s.setSoTimeout((int)timeout);
122 
123         byte[] hello = &quot;JDWP-Handshake&quot;.getBytes(&quot;UTF-8&quot;);
124         s.getOutputStream().write(hello);
125 
126         byte[] b = new byte[hello.length];
127         int received = 0;
128         while (received &lt; hello.length) {
129             int n;
130             try {
131                 n = s.getInputStream().read(b, received, hello.length-received);
132             } catch (SocketTimeoutException x) {
133                 throw new IOException(&quot;handshake timeout&quot;);
134             }
135             if (n &lt; 0) {
136                 s.close();
137                 throw new IOException(&quot;handshake failed - connection prematurally closed&quot;);
138             }
139             received += n;
140         }
141         for (int i=0; i&lt;hello.length; i++) {
142             if (b[i] != hello[i]) {
143                 throw new IOException(&quot;handshake failed - unrecognized message from target VM&quot;);
144             }
145         }
146 
147         // disable read timeout
148         s.setSoTimeout(0);
149     }
150 
151     /**
152      * No-arg constructor
153      */
154     public SocketTransportService() {
155     }
156 
157     /**
158      * The name of this transport service
159      */
160     public String name() {
161         return &quot;Socket&quot;;
162     }
163 
164     /**
165      * Return localized description of this transport service
166      */
167     public String description() {
168         synchronized (this) {
169             if (messages == null) {
170                 messages = ResourceBundle.getBundle(&quot;com.sun.tools.jdi.resources.jdi&quot;);
171             }
172         }
173         return messages.getString(&quot;socket_transportservice.description&quot;);
174     }
175 
176     /**
177      * Return the capabilities of this transport service
178      */
179     public Capabilities capabilities() {
180         return new TransportService.Capabilities() {
181             public boolean supportsMultipleConnections() {
182                 return true;
183             }
184 
185             public boolean supportsAttachTimeout() {
186                 return true;
187             }
188 
189             public boolean supportsAcceptTimeout() {
190                 return true;
191             }
192 
193             public boolean supportsHandshakeTimeout() {
194                 return true;
195             }
196         };
197     }
198 
199     private static class HostPort {
200         public final String host;
201         public final int port;
202         private HostPort(String host, int port) {
203             this.host = host;
204             this.port = port;
205         }
206 
207         /**
208          * Creates an instance for given URN, which can be either &lt;port&gt; or &lt;host&gt;:&lt;port&gt;.
209          * If host is &#39;*&#39;, the returned HostPort instance has host set to null.
210          * If &lt;code&gt;host&lt;/code&gt; is a literal IPv6 address, it may be in square brackets.
211          */
212         public static HostPort parse(String hostPort) {
213             int splitIndex = hostPort.lastIndexOf(&#39;:&#39;);
214 
215             int port;
216             try {
217                 port = Integer.decode(hostPort.substring(splitIndex + 1));
218             } catch (NumberFormatException e) {
219                 throw new IllegalArgumentException(&quot;unable to parse port number in address&quot;);
220             }
221             if (port &lt; 0 || port &gt; 0xFFFF) {
222                 throw new IllegalArgumentException(&quot;port out of range&quot;);
223             }
224 
225             if (splitIndex &lt;= 0) {  // empty host means local connection
226                 return new HostPort(InetAddress.getLoopbackAddress().getHostAddress(), port);
227             } else if (splitIndex == 1 &amp;&amp; hostPort.charAt(0) == &#39;*&#39;) {
228                 return new HostPort(null, port);
229             } else if (hostPort.charAt(0) == &#39;[&#39; &amp;&amp; hostPort.charAt(splitIndex - 1) == &#39;]&#39;) {
230                 return new HostPort(hostPort.substring(1, splitIndex - 1), port);
231             } else {
232                 return new HostPort(hostPort.substring(0, splitIndex), port);
233             }
234         }
235     }
236 
237     /**
238      * Attach to the specified address with optional attach and handshake
239      * timeout.
240      */
241     public Connection attach(String address, long attachTimeout, long handshakeTimeout)
242         throws IOException {
243 
244         if (address == null) {
245             throw new NullPointerException(&quot;address is null&quot;);
246         }
247         if (attachTimeout &lt; 0 || handshakeTimeout &lt; 0) {
248             throw new IllegalArgumentException(&quot;timeout is negative&quot;);
249         }
250 
251         HostPort hostPort = HostPort.parse(address);
252 
253         // open TCP connection to VM
254         // formally &quot;*&quot; is not correct hostname to attach
255         // but lets connect to localhost
256         InetSocketAddress sa = new InetSocketAddress(hostPort.host == null
257                                                      ? InetAddress.getLoopbackAddress().getHostAddress()
258                                                      : hostPort.host, hostPort.port);
259         Socket s = new Socket();
260         try {
261             s.connect(sa, (int)attachTimeout);
262         } catch (SocketTimeoutException exc) {
263             try {
264                 s.close();
265             } catch (IOException x) { }
266             throw new TransportTimeoutException(&quot;timed out trying to establish connection&quot;);
267         }
268 
269         // handshake with the target VM
270         try {
271             handshake(s, handshakeTimeout);
272         } catch (IOException exc) {
273             try {
274                 s.close();
275             } catch (IOException x) { }
276             throw exc;
277         }
278 
279         return new SocketConnection(s);
280     }
281 
282     /*
283      * Listen on the specified address and port. Return a listener
284      * that encapsulates the ServerSocket.
285      */
286     ListenKey startListening(String localaddress, int port) throws IOException {
287         InetSocketAddress sa;
288         if (localaddress == null) {
289             sa = new InetSocketAddress(port);
290         } else {
291             sa = new InetSocketAddress(localaddress, port);
292         }
293         ServerSocket ss = new ServerSocket();
294         if (port == 0) {
295             // Only need SO_REUSEADDR if we&#39;re using a fixed port. If we
296             // start seeing EADDRINUSE due to collisions in free ports
297             // then we should retry the bind() a few times.
298             ss.setReuseAddress(false);
299         }
300         ss.bind(sa);
301         return new SocketListenKey(ss);
302     }
303 
304     /**
305      * Listen on the specified address
306      */
307     public ListenKey startListening(String address) throws IOException {
308         // use ephemeral port if address isn&#39;t specified.
309         HostPort hostPort = HostPort.parse((address == null || address.isEmpty()) ? &quot;0&quot; : address);
310         return startListening(hostPort.host, hostPort.port);
311     }
312 
313     /**
314      * Listen on the default address
315      */
316     public ListenKey startListening() throws IOException {
317         return startListening(null, 0);
318     }
319 
320     /**
321      * Stop the listener
322      */
323     public void stopListening(ListenKey listener) throws IOException {
324         if (!(listener instanceof SocketListenKey)) {
325             throw new IllegalArgumentException(&quot;Invalid listener&quot;);
326         }
327 
328         synchronized (listener) {
329             ServerSocket ss = ((SocketListenKey)listener).socket();
330 
331             // if the ServerSocket has been closed it means
332             // the listener is invalid
333             if (ss.isClosed()) {
334                 throw new IllegalArgumentException(&quot;Invalid listener&quot;);
335             }
336             ss.close();
337         }
338     }
339 
340     /**
341      * Accept a connection from a debuggee and handshake with it.
342      */
343     public Connection accept(ListenKey listener, long acceptTimeout, long handshakeTimeout) throws IOException {
344         if (acceptTimeout &lt; 0 || handshakeTimeout &lt; 0) {
345             throw new IllegalArgumentException(&quot;timeout is negative&quot;);
346         }
347         if (!(listener instanceof SocketListenKey)) {
348             throw new IllegalArgumentException(&quot;Invalid listener&quot;);
349         }
350         ServerSocket ss;
351 
352         // obtain the ServerSocket from the listener - if the
353         // socket is closed it means the listener is invalid
354         synchronized (listener) {
355             ss = ((SocketListenKey)listener).socket();
356             if (ss.isClosed()) {
357                throw new IllegalArgumentException(&quot;Invalid listener&quot;);
358             }
359         }
360 
361         // from here onwards it&#39;s possible that the ServerSocket
362         // may be closed by a call to stopListening - that&#39;s okay
363         // because the ServerSocket methods will throw an
364         // IOException indicating the socket is closed.
365         //
366         // Additionally, it&#39;s possible that another thread calls accept
367         // with a different accept timeout - that creates a same race
368         // condition between setting the timeout and calling accept.
369         // As it is such an unlikely scenario (requires both threads
370         // to be using the same listener we&#39;ve chosen to ignore the issue).
371 
372         ss.setSoTimeout((int)acceptTimeout);
373         Socket s;
374         try {
375             s = ss.accept();
376         } catch (SocketTimeoutException x) {
377             throw new TransportTimeoutException(&quot;timeout waiting for connection&quot;);
378         }
379 
380         // handshake here
381         handshake(s, handshakeTimeout);
382 
383         return new SocketConnection(s);
384     }
385 
386     public String toString() {
387        return name();
388     }
389 }
    </pre>
  </body>
</html>
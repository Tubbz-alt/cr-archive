<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketTransportService.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VirtualMachineManagerImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,14 ***</span>
  import java.text.MessageFormat;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.HashMap;
  import java.util.Iterator;
  import java.util.List;
  import java.util.Map;
<span class="line-modified">! import java.util.TreeSet;</span>
  
  import com.sun.jdi.BooleanType;
  import com.sun.jdi.BooleanValue;
  import com.sun.jdi.ByteType;
  import com.sun.jdi.ByteValue;
<span class="line-new-header">--- 31,16 ---</span>
  import java.text.MessageFormat;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.Collections;
  import java.util.HashMap;
<span class="line-added">+ import java.util.HashSet;</span>
  import java.util.Iterator;
  import java.util.List;
  import java.util.Map;
<span class="line-modified">! import java.util.Set;</span>
<span class="line-added">+ import java.util.function.Consumer;</span>
  
  import com.sun.jdi.BooleanType;
  import com.sun.jdi.BooleanValue;
  import com.sun.jdi.ByteType;
  import com.sun.jdi.ByteValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,10 ***</span>
<span class="line-new-header">--- 56,11 ---</span>
  import com.sun.jdi.IntegerValue;
  import com.sun.jdi.InternalException;
  import com.sun.jdi.LongType;
  import com.sun.jdi.LongValue;
  import com.sun.jdi.ModuleReference;
<span class="line-added">+ import com.sun.jdi.ObjectCollectedException;</span>
  import com.sun.jdi.PathSearchingVirtualMachine;
  import com.sun.jdi.PrimitiveType;
  import com.sun.jdi.ReferenceType;
  import com.sun.jdi.ShortType;
  import com.sun.jdi.ShortValue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,11 ***</span>
      // ReferenceType access - updated with class prepare and unload events
      // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
      // tested unsynchronized (since once true, it stays true), but must
      // be set synchronously
      private Map&lt;Long, ReferenceType&gt; typesByID;
<span class="line-modified">!     private TreeSet&lt;ReferenceType&gt; typesBySignature;</span>
      private boolean retrievedAllTypes = false;
  
      private Map&lt;Long, ModuleReference&gt; modulesByID;
  
      // For other languages support
<span class="line-new-header">--- 111,11 ---</span>
      // ReferenceType access - updated with class prepare and unload events
      // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
      // tested unsynchronized (since once true, it stays true), but must
      // be set synchronously
      private Map&lt;Long, ReferenceType&gt; typesByID;
<span class="line-modified">!     private Set&lt;ReferenceType&gt; typesBySignature;</span>
      private boolean retrievedAllTypes = false;
  
      private Map&lt;Long, ModuleReference&gt; modulesByID;
  
      // For other languages support
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,10 ***</span>
<span class="line-new-header">--- 338,31 ---</span>
              a = new ArrayList&lt;&gt;(typesBySignature);
          }
          return Collections.unmodifiableList(a);
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Performs an action for each loaded type.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     public void forEachClass(Consumer&lt;ReferenceType&gt; action) {</span>
<span class="line-added">+         for (ReferenceType type : allClasses()) {</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 action.accept(type);</span>
<span class="line-added">+             } catch (ObjectCollectedException ex) {</span>
<span class="line-added">+                 // Some classes might be unloaded and garbage collected since</span>
<span class="line-added">+                 // we retrieved the copy of all loaded classes and started</span>
<span class="line-added">+                 // iterating over them. In this case calling methods on such types</span>
<span class="line-added">+                 // might result in com.sun.jdi.ObjectCollectedException</span>
<span class="line-added">+                 // being thrown. We ignore such classes and keep iterating.</span>
<span class="line-added">+                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {</span>
<span class="line-added">+                     vm.printTrace(&quot;ObjectCollectedException was thrown while &quot; +</span>
<span class="line-added">+                             &quot;accessing unloaded class &quot; + type.name());</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public void
          redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
      {
          int cnt = classToBytes.size();
          JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 841,18 ***</span>
                  break;
              default:
                  throw new InternalException(&quot;Invalid reference type tag&quot;);
          }
  
<span class="line-modified">!         /*</span>
<span class="line-modified">!          * If a signature was specified, make sure to set it ASAP, to</span>
<span class="line-modified">!          * prevent any needless JDWP command to retrieve it. (for example,</span>
<span class="line-removed">-          * typesBySignature.add needs the signature, to maintain proper</span>
<span class="line-removed">-          * ordering.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         if (signature != null) {</span>
<span class="line-removed">-             type.setSignature(signature);</span>
          }
  
          typesByID.put(id, type);
          typesBySignature.add(type);
  
<span class="line-new-header">--- 865,13 ---</span>
                  break;
              default:
                  throw new InternalException(&quot;Invalid reference type tag&quot;);
          }
  
<span class="line-modified">!         if (signature == null &amp;&amp; retrievedAllTypes) {</span>
<span class="line-modified">!             // do not cache if signature is not provided</span>
<span class="line-modified">!             return type;</span>
          }
  
          typesByID.put(id, type);
          typesBySignature.add(type);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,11 ***</span>
          return list;
      }
  
      private void initReferenceTypes() {
          typesByID = new HashMap&lt;&gt;(300);
<span class="line-modified">!         typesBySignature = new TreeSet&lt;&gt;();</span>
      }
  
      ReferenceTypeImpl referenceType(long ref, byte tag) {
          return referenceType(ref, tag, null);
      }
<span class="line-new-header">--- 937,11 ---</span>
          return list;
      }
  
      private void initReferenceTypes() {
          typesByID = new HashMap&lt;&gt;(300);
<span class="line-modified">!         typesBySignature = new HashSet&lt;&gt;();</span>
      }
  
      ReferenceTypeImpl referenceType(long ref, byte tag) {
          return referenceType(ref, tag, null);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 967,10 ***</span>
<span class="line-new-header">--- 986,13 ---</span>
                      retType = (ReferenceTypeImpl)typesByID.get(id);
                  }
                  if (retType == null) {
                      retType = addReferenceType(id, tag, signature);
                  }
<span class="line-added">+                 if (signature != null) {</span>
<span class="line-added">+                     retType.setSignature(signature);</span>
<span class="line-added">+                 }</span>
              }
              return retType;
          }
      }
  
</pre>
<center><a href="SocketTransportService.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VirtualMachineManagerImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
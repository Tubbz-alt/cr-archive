<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SocketTransportService.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VirtualMachineManagerImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.text.MessageFormat;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.HashMap;

  36 import java.util.Iterator;
  37 import java.util.List;
  38 import java.util.Map;
<span class="line-modified">  39 import java.util.TreeSet;</span>

  40 
  41 import com.sun.jdi.BooleanType;
  42 import com.sun.jdi.BooleanValue;
  43 import com.sun.jdi.ByteType;
  44 import com.sun.jdi.ByteValue;
  45 import com.sun.jdi.CharType;
  46 import com.sun.jdi.CharValue;
  47 import com.sun.jdi.ClassLoaderReference;
  48 import com.sun.jdi.ClassNotLoadedException;
  49 import com.sun.jdi.DoubleType;
  50 import com.sun.jdi.DoubleValue;
  51 import com.sun.jdi.FloatType;
  52 import com.sun.jdi.FloatValue;
  53 import com.sun.jdi.IntegerType;
  54 import com.sun.jdi.IntegerValue;
  55 import com.sun.jdi.InternalException;
  56 import com.sun.jdi.LongType;
  57 import com.sun.jdi.LongValue;
  58 import com.sun.jdi.ModuleReference;

  59 import com.sun.jdi.PathSearchingVirtualMachine;
  60 import com.sun.jdi.PrimitiveType;
  61 import com.sun.jdi.ReferenceType;
  62 import com.sun.jdi.ShortType;
  63 import com.sun.jdi.ShortValue;
  64 import com.sun.jdi.StringReference;
  65 import com.sun.jdi.ThreadGroupReference;
  66 import com.sun.jdi.ThreadReference;
  67 import com.sun.jdi.Type;
  68 import com.sun.jdi.VMDisconnectedException;
  69 import com.sun.jdi.VirtualMachine;
  70 import com.sun.jdi.VirtualMachineManager;
  71 import com.sun.jdi.VoidType;
  72 import com.sun.jdi.VoidValue;
  73 import com.sun.jdi.connect.spi.Connection;
  74 import com.sun.jdi.event.EventQueue;
  75 import com.sun.jdi.request.BreakpointRequest;
  76 import com.sun.jdi.request.EventRequest;
  77 import com.sun.jdi.request.EventRequestManager;
  78 
</pre>
<hr />
<pre>
  93     private final EventQueueImpl eventQueue;
  94     private final EventRequestManagerImpl internalEventRequestManager;
  95     private final EventRequestManagerImpl eventRequestManager;
  96     final VirtualMachineManagerImpl vmManager;
  97     private final ThreadGroup threadGroupForJDI;
  98 
  99     // Allow direct access to this field so that that tracing code slows down
 100     // JDI as little as possible when not enabled.
 101     int traceFlags = TRACE_NONE;
 102 
 103     static int TRACE_RAW_SENDS     = 0x01000000;
 104     static int TRACE_RAW_RECEIVES  = 0x02000000;
 105 
 106     boolean traceReceives = false;   // pre-compute because of frequency
 107 
 108     // ReferenceType access - updated with class prepare and unload events
 109     // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
 110     // tested unsynchronized (since once true, it stays true), but must
 111     // be set synchronously
 112     private Map&lt;Long, ReferenceType&gt; typesByID;
<span class="line-modified"> 113     private TreeSet&lt;ReferenceType&gt; typesBySignature;</span>
 114     private boolean retrievedAllTypes = false;
 115 
 116     private Map&lt;Long, ModuleReference&gt; modulesByID;
 117 
 118     // For other languages support
 119     private String defaultStratum = null;
 120 
 121     // ObjectReference cache
 122     // &quot;objectsByID&quot; protected by &quot;synchronized(this)&quot;.
 123     private final Map&lt;Long, SoftObjectReference&gt; objectsByID = new HashMap&lt;&gt;();
 124     private final ReferenceQueue&lt;ObjectReferenceImpl&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 125     static private final int DISPOSE_THRESHOLD = 50;
 126     private final List&lt;SoftObjectReference&gt; batchedDisposeRequests =
 127             Collections.synchronizedList(new ArrayList&lt;&gt;(DISPOSE_THRESHOLD + 10));
 128 
 129     // These are cached once for the life of the VM
 130     private JDWP.VirtualMachine.Version versionInfo;
 131     private JDWP.VirtualMachine.ClassPaths pathInfo;
 132     private JDWP.VirtualMachine.Capabilities capabilities = null;
 133     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew = null;
</pre>
<hr />
<pre>
 320            list = findReferenceTypes(signature);
 321         } else {
 322            list = retrieveClassesBySignature(signature);
 323         }
 324         return Collections.unmodifiableList(list);
 325     }
 326 
 327     public List&lt;ReferenceType&gt; allClasses() {
 328         validateVM();
 329 
 330         if (!retrievedAllTypes) {
 331             retrieveAllClasses();
 332         }
 333         ArrayList&lt;ReferenceType&gt; a;
 334         synchronized (this) {
 335             a = new ArrayList&lt;&gt;(typesBySignature);
 336         }
 337         return Collections.unmodifiableList(a);
 338     }
 339 





















 340     public void
 341         redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
 342     {
 343         int cnt = classToBytes.size();
 344         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
 345             new JDWP.VirtualMachine.RedefineClasses.ClassDef[cnt];
 346         validateVM();
 347         if (!canRedefineClasses()) {
 348             throw new UnsupportedOperationException();
 349         }
 350         Iterator&lt;?&gt; it = classToBytes.entrySet().iterator();
 351         for (int i = 0; it.hasNext(); i++) {
 352             @SuppressWarnings(&quot;rawtypes&quot;)
 353             Map.Entry&lt;?, ?&gt; entry = (Map.Entry)it.next();
 354             ReferenceTypeImpl refType = (ReferenceTypeImpl)entry.getKey();
 355             validateMirror(refType);
 356             defs[i] = new JDWP.VirtualMachine.RedefineClasses
 357                        .ClassDef(refType, (byte[])entry.getValue());
 358         }
 359 
</pre>
<hr />
<pre>
 826                                                             int tag,
 827                                                             String signature) {
 828         if (typesByID == null) {
 829             initReferenceTypes();
 830         }
 831         ReferenceTypeImpl type = null;
 832         switch(tag) {
 833             case JDWP.TypeTag.CLASS:
 834                 type = new ClassTypeImpl(vm, id);
 835                 break;
 836             case JDWP.TypeTag.INTERFACE:
 837                 type = new InterfaceTypeImpl(vm, id);
 838                 break;
 839             case JDWP.TypeTag.ARRAY:
 840                 type = new ArrayTypeImpl(vm, id);
 841                 break;
 842             default:
 843                 throw new InternalException(&quot;Invalid reference type tag&quot;);
 844         }
 845 
<span class="line-modified"> 846         /*</span>
<span class="line-modified"> 847          * If a signature was specified, make sure to set it ASAP, to</span>
<span class="line-modified"> 848          * prevent any needless JDWP command to retrieve it. (for example,</span>
<span class="line-removed"> 849          * typesBySignature.add needs the signature, to maintain proper</span>
<span class="line-removed"> 850          * ordering.</span>
<span class="line-removed"> 851          */</span>
<span class="line-removed"> 852         if (signature != null) {</span>
<span class="line-removed"> 853             type.setSignature(signature);</span>
 854         }
 855 
 856         typesByID.put(id, type);
 857         typesBySignature.add(type);
 858 
 859         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 860            vm.printTrace(&quot;Caching new ReferenceType, sig=&quot; + signature +
 861                          &quot;, id=&quot; + id);
 862         }
 863 
 864         return type;
 865     }
 866 
 867     synchronized void removeReferenceType(String signature) {
 868         if (typesByID == null) {
 869             return;
 870         }
 871         /*
 872          * There can be multiple classes with the same name. Since
 873          * we can&#39;t differentiate here, we first remove all
</pre>
<hr />
<pre>
 903     private synchronized List&lt;ReferenceType&gt; findReferenceTypes(String signature) {
 904         if (typesByID == null) {
 905             return new ArrayList&lt;&gt;(0);
 906         }
 907         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 908         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;();
 909         while (iter.hasNext()) {
 910             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 911             int comp = signature.compareTo(type.signature());
 912             if (comp == 0) {
 913                 list.add(type);
 914                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 915                 // in the order we think
 916             }
 917         }
 918         return list;
 919     }
 920 
 921     private void initReferenceTypes() {
 922         typesByID = new HashMap&lt;&gt;(300);
<span class="line-modified"> 923         typesBySignature = new TreeSet&lt;&gt;();</span>
 924     }
 925 
 926     ReferenceTypeImpl referenceType(long ref, byte tag) {
 927         return referenceType(ref, tag, null);
 928     }
 929 
 930     ClassTypeImpl classType(long ref) {
 931         return (ClassTypeImpl)referenceType(ref, JDWP.TypeTag.CLASS, null);
 932     }
 933 
 934     InterfaceTypeImpl interfaceType(long ref) {
 935         return (InterfaceTypeImpl)referenceType(ref, JDWP.TypeTag.INTERFACE, null);
 936     }
 937 
 938     ArrayTypeImpl arrayType(long ref) {
 939         return (ArrayTypeImpl)referenceType(ref, JDWP.TypeTag.ARRAY, null);
 940     }
 941 
 942     ReferenceTypeImpl referenceType(long id, int tag, String signature) {
 943         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
</pre>
<hr />
<pre>
 952             } else {
 953                 sb.append(&quot;UNKNOWN TAG: &quot;).append(tag);
 954             }
 955             if (signature != null) {
 956                 sb.append(&quot;, signature=&#39;&quot;).append(signature).append(&#39;\&#39;&#39;);
 957             }
 958             sb.append(&quot;, id=&quot;).append(id);
 959             vm.printTrace(sb.toString());
 960         }
 961         if (id == 0) {
 962             return null;
 963         } else {
 964             ReferenceTypeImpl retType = null;
 965             synchronized (this) {
 966                 if (typesByID != null) {
 967                     retType = (ReferenceTypeImpl)typesByID.get(id);
 968                 }
 969                 if (retType == null) {
 970                     retType = addReferenceType(id, tag, signature);
 971                 }



 972             }
 973             return retType;
 974         }
 975     }
 976 
 977     private JDWP.VirtualMachine.Capabilities capabilities() {
 978         if (capabilities == null) {
 979             try {
 980                 capabilities = JDWP.VirtualMachine
 981                                  .Capabilities.process(vm);
 982             } catch (JDWPException exc) {
 983                 throw exc.toJDIException();
 984             }
 985         }
 986         return capabilities;
 987     }
 988 
 989     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew() {
 990         if (capabilitiesNew == null) {
 991             try {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.text.MessageFormat;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.HashMap;
<span class="line-added">  36 import java.util.HashSet;</span>
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
<span class="line-modified">  40 import java.util.Set;</span>
<span class="line-added">  41 import java.util.function.Consumer;</span>
  42 
  43 import com.sun.jdi.BooleanType;
  44 import com.sun.jdi.BooleanValue;
  45 import com.sun.jdi.ByteType;
  46 import com.sun.jdi.ByteValue;
  47 import com.sun.jdi.CharType;
  48 import com.sun.jdi.CharValue;
  49 import com.sun.jdi.ClassLoaderReference;
  50 import com.sun.jdi.ClassNotLoadedException;
  51 import com.sun.jdi.DoubleType;
  52 import com.sun.jdi.DoubleValue;
  53 import com.sun.jdi.FloatType;
  54 import com.sun.jdi.FloatValue;
  55 import com.sun.jdi.IntegerType;
  56 import com.sun.jdi.IntegerValue;
  57 import com.sun.jdi.InternalException;
  58 import com.sun.jdi.LongType;
  59 import com.sun.jdi.LongValue;
  60 import com.sun.jdi.ModuleReference;
<span class="line-added">  61 import com.sun.jdi.ObjectCollectedException;</span>
  62 import com.sun.jdi.PathSearchingVirtualMachine;
  63 import com.sun.jdi.PrimitiveType;
  64 import com.sun.jdi.ReferenceType;
  65 import com.sun.jdi.ShortType;
  66 import com.sun.jdi.ShortValue;
  67 import com.sun.jdi.StringReference;
  68 import com.sun.jdi.ThreadGroupReference;
  69 import com.sun.jdi.ThreadReference;
  70 import com.sun.jdi.Type;
  71 import com.sun.jdi.VMDisconnectedException;
  72 import com.sun.jdi.VirtualMachine;
  73 import com.sun.jdi.VirtualMachineManager;
  74 import com.sun.jdi.VoidType;
  75 import com.sun.jdi.VoidValue;
  76 import com.sun.jdi.connect.spi.Connection;
  77 import com.sun.jdi.event.EventQueue;
  78 import com.sun.jdi.request.BreakpointRequest;
  79 import com.sun.jdi.request.EventRequest;
  80 import com.sun.jdi.request.EventRequestManager;
  81 
</pre>
<hr />
<pre>
  96     private final EventQueueImpl eventQueue;
  97     private final EventRequestManagerImpl internalEventRequestManager;
  98     private final EventRequestManagerImpl eventRequestManager;
  99     final VirtualMachineManagerImpl vmManager;
 100     private final ThreadGroup threadGroupForJDI;
 101 
 102     // Allow direct access to this field so that that tracing code slows down
 103     // JDI as little as possible when not enabled.
 104     int traceFlags = TRACE_NONE;
 105 
 106     static int TRACE_RAW_SENDS     = 0x01000000;
 107     static int TRACE_RAW_RECEIVES  = 0x02000000;
 108 
 109     boolean traceReceives = false;   // pre-compute because of frequency
 110 
 111     // ReferenceType access - updated with class prepare and unload events
 112     // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
 113     // tested unsynchronized (since once true, it stays true), but must
 114     // be set synchronously
 115     private Map&lt;Long, ReferenceType&gt; typesByID;
<span class="line-modified"> 116     private Set&lt;ReferenceType&gt; typesBySignature;</span>
 117     private boolean retrievedAllTypes = false;
 118 
 119     private Map&lt;Long, ModuleReference&gt; modulesByID;
 120 
 121     // For other languages support
 122     private String defaultStratum = null;
 123 
 124     // ObjectReference cache
 125     // &quot;objectsByID&quot; protected by &quot;synchronized(this)&quot;.
 126     private final Map&lt;Long, SoftObjectReference&gt; objectsByID = new HashMap&lt;&gt;();
 127     private final ReferenceQueue&lt;ObjectReferenceImpl&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 128     static private final int DISPOSE_THRESHOLD = 50;
 129     private final List&lt;SoftObjectReference&gt; batchedDisposeRequests =
 130             Collections.synchronizedList(new ArrayList&lt;&gt;(DISPOSE_THRESHOLD + 10));
 131 
 132     // These are cached once for the life of the VM
 133     private JDWP.VirtualMachine.Version versionInfo;
 134     private JDWP.VirtualMachine.ClassPaths pathInfo;
 135     private JDWP.VirtualMachine.Capabilities capabilities = null;
 136     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew = null;
</pre>
<hr />
<pre>
 323            list = findReferenceTypes(signature);
 324         } else {
 325            list = retrieveClassesBySignature(signature);
 326         }
 327         return Collections.unmodifiableList(list);
 328     }
 329 
 330     public List&lt;ReferenceType&gt; allClasses() {
 331         validateVM();
 332 
 333         if (!retrievedAllTypes) {
 334             retrieveAllClasses();
 335         }
 336         ArrayList&lt;ReferenceType&gt; a;
 337         synchronized (this) {
 338             a = new ArrayList&lt;&gt;(typesBySignature);
 339         }
 340         return Collections.unmodifiableList(a);
 341     }
 342 
<span class="line-added"> 343     /**</span>
<span class="line-added"> 344      * Performs an action for each loaded type.</span>
<span class="line-added"> 345      */</span>
<span class="line-added"> 346     public void forEachClass(Consumer&lt;ReferenceType&gt; action) {</span>
<span class="line-added"> 347         for (ReferenceType type : allClasses()) {</span>
<span class="line-added"> 348             try {</span>
<span class="line-added"> 349                 action.accept(type);</span>
<span class="line-added"> 350             } catch (ObjectCollectedException ex) {</span>
<span class="line-added"> 351                 // Some classes might be unloaded and garbage collected since</span>
<span class="line-added"> 352                 // we retrieved the copy of all loaded classes and started</span>
<span class="line-added"> 353                 // iterating over them. In this case calling methods on such types</span>
<span class="line-added"> 354                 // might result in com.sun.jdi.ObjectCollectedException</span>
<span class="line-added"> 355                 // being thrown. We ignore such classes and keep iterating.</span>
<span class="line-added"> 356                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {</span>
<span class="line-added"> 357                     vm.printTrace(&quot;ObjectCollectedException was thrown while &quot; +</span>
<span class="line-added"> 358                             &quot;accessing unloaded class &quot; + type.name());</span>
<span class="line-added"> 359                 }</span>
<span class="line-added"> 360             }</span>
<span class="line-added"> 361         }</span>
<span class="line-added"> 362     }</span>
<span class="line-added"> 363 </span>
 364     public void
 365         redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
 366     {
 367         int cnt = classToBytes.size();
 368         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
 369             new JDWP.VirtualMachine.RedefineClasses.ClassDef[cnt];
 370         validateVM();
 371         if (!canRedefineClasses()) {
 372             throw new UnsupportedOperationException();
 373         }
 374         Iterator&lt;?&gt; it = classToBytes.entrySet().iterator();
 375         for (int i = 0; it.hasNext(); i++) {
 376             @SuppressWarnings(&quot;rawtypes&quot;)
 377             Map.Entry&lt;?, ?&gt; entry = (Map.Entry)it.next();
 378             ReferenceTypeImpl refType = (ReferenceTypeImpl)entry.getKey();
 379             validateMirror(refType);
 380             defs[i] = new JDWP.VirtualMachine.RedefineClasses
 381                        .ClassDef(refType, (byte[])entry.getValue());
 382         }
 383 
</pre>
<hr />
<pre>
 850                                                             int tag,
 851                                                             String signature) {
 852         if (typesByID == null) {
 853             initReferenceTypes();
 854         }
 855         ReferenceTypeImpl type = null;
 856         switch(tag) {
 857             case JDWP.TypeTag.CLASS:
 858                 type = new ClassTypeImpl(vm, id);
 859                 break;
 860             case JDWP.TypeTag.INTERFACE:
 861                 type = new InterfaceTypeImpl(vm, id);
 862                 break;
 863             case JDWP.TypeTag.ARRAY:
 864                 type = new ArrayTypeImpl(vm, id);
 865                 break;
 866             default:
 867                 throw new InternalException(&quot;Invalid reference type tag&quot;);
 868         }
 869 
<span class="line-modified"> 870         if (signature == null &amp;&amp; retrievedAllTypes) {</span>
<span class="line-modified"> 871             // do not cache if signature is not provided</span>
<span class="line-modified"> 872             return type;</span>





 873         }
 874 
 875         typesByID.put(id, type);
 876         typesBySignature.add(type);
 877 
 878         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 879            vm.printTrace(&quot;Caching new ReferenceType, sig=&quot; + signature +
 880                          &quot;, id=&quot; + id);
 881         }
 882 
 883         return type;
 884     }
 885 
 886     synchronized void removeReferenceType(String signature) {
 887         if (typesByID == null) {
 888             return;
 889         }
 890         /*
 891          * There can be multiple classes with the same name. Since
 892          * we can&#39;t differentiate here, we first remove all
</pre>
<hr />
<pre>
 922     private synchronized List&lt;ReferenceType&gt; findReferenceTypes(String signature) {
 923         if (typesByID == null) {
 924             return new ArrayList&lt;&gt;(0);
 925         }
 926         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 927         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;();
 928         while (iter.hasNext()) {
 929             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 930             int comp = signature.compareTo(type.signature());
 931             if (comp == 0) {
 932                 list.add(type);
 933                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 934                 // in the order we think
 935             }
 936         }
 937         return list;
 938     }
 939 
 940     private void initReferenceTypes() {
 941         typesByID = new HashMap&lt;&gt;(300);
<span class="line-modified"> 942         typesBySignature = new HashSet&lt;&gt;();</span>
 943     }
 944 
 945     ReferenceTypeImpl referenceType(long ref, byte tag) {
 946         return referenceType(ref, tag, null);
 947     }
 948 
 949     ClassTypeImpl classType(long ref) {
 950         return (ClassTypeImpl)referenceType(ref, JDWP.TypeTag.CLASS, null);
 951     }
 952 
 953     InterfaceTypeImpl interfaceType(long ref) {
 954         return (InterfaceTypeImpl)referenceType(ref, JDWP.TypeTag.INTERFACE, null);
 955     }
 956 
 957     ArrayTypeImpl arrayType(long ref) {
 958         return (ArrayTypeImpl)referenceType(ref, JDWP.TypeTag.ARRAY, null);
 959     }
 960 
 961     ReferenceTypeImpl referenceType(long id, int tag, String signature) {
 962         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
</pre>
<hr />
<pre>
 971             } else {
 972                 sb.append(&quot;UNKNOWN TAG: &quot;).append(tag);
 973             }
 974             if (signature != null) {
 975                 sb.append(&quot;, signature=&#39;&quot;).append(signature).append(&#39;\&#39;&#39;);
 976             }
 977             sb.append(&quot;, id=&quot;).append(id);
 978             vm.printTrace(sb.toString());
 979         }
 980         if (id == 0) {
 981             return null;
 982         } else {
 983             ReferenceTypeImpl retType = null;
 984             synchronized (this) {
 985                 if (typesByID != null) {
 986                     retType = (ReferenceTypeImpl)typesByID.get(id);
 987                 }
 988                 if (retType == null) {
 989                     retType = addReferenceType(id, tag, signature);
 990                 }
<span class="line-added"> 991                 if (signature != null) {</span>
<span class="line-added"> 992                     retType.setSignature(signature);</span>
<span class="line-added"> 993                 }</span>
 994             }
 995             return retType;
 996         }
 997     }
 998 
 999     private JDWP.VirtualMachine.Capabilities capabilities() {
1000         if (capabilities == null) {
1001             try {
1002                 capabilities = JDWP.VirtualMachine
1003                                  .Capabilities.process(vm);
1004             } catch (JDWPException exc) {
1005                 throw exc.toJDIException();
1006             }
1007         }
1008         return capabilities;
1009     }
1010 
1011     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew() {
1012         if (capabilitiesNew == null) {
1013             try {
</pre>
</td>
</tr>
</table>
<center><a href="SocketTransportService.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VirtualMachineManagerImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
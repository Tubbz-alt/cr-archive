<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdi/share/classes/com/sun/tools/jdi/ReferenceTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.SoftReference;
  29 import java.util.ArrayList;
  30 import java.util.Arrays;
  31 import java.util.Collections;
  32 import java.util.HashMap;
  33 import java.util.HashSet;
  34 import java.util.Iterator;
  35 import java.util.List;
  36 import java.util.Map;
  37 import java.util.Set;
  38 
  39 import com.sun.jdi.AbsentInformationException;
  40 import com.sun.jdi.ClassLoaderReference;
  41 import com.sun.jdi.ClassNotLoadedException;
  42 import com.sun.jdi.ClassObjectReference;
  43 import com.sun.jdi.Field;
  44 import com.sun.jdi.InterfaceType;
  45 import com.sun.jdi.InternalException;
  46 import com.sun.jdi.Location;
  47 import com.sun.jdi.Method;
  48 import com.sun.jdi.ModuleReference;
  49 import com.sun.jdi.ObjectReference;
  50 import com.sun.jdi.ReferenceType;
  51 import com.sun.jdi.Type;
  52 import com.sun.jdi.Value;
  53 import com.sun.jdi.VirtualMachine;
  54 
  55 public abstract class ReferenceTypeImpl extends TypeImpl implements ReferenceType {
  56     protected long ref;
  57     private String signature = null;
  58     private String genericSignature = null;
  59     private boolean genericSignatureGotten = false;
  60     private String baseSourceName = null;
  61     private String baseSourceDir = null;
  62     private String baseSourcePath = null;
  63     protected int modifiers = -1;
  64     private SoftReference&lt;List&lt;Field&gt;&gt; fieldsRef = null;
  65     private SoftReference&lt;List&lt;Method&gt;&gt; methodsRef = null;
  66     private SoftReference&lt;SDE&gt; sdeRef = null;
  67 
  68     private boolean isClassLoaderCached = false;
  69     private ClassLoaderReference classLoader = null;
  70     private ClassObjectReference classObject = null;
  71     private ModuleReference module = null;
  72 
  73     private int status = 0;
  74     private boolean isPrepared = false;
  75 
  76     private boolean versionNumberGotten = false;
  77     private int majorVersion;
  78     private int minorVersion;
  79 
  80     private boolean constantPoolInfoGotten = false;
  81     private int constanPoolCount;
  82     private SoftReference&lt;byte[]&gt; constantPoolBytesRef = null;
  83 
  84     /* to mark a SourceFile request that returned a genuine JDWP.Error.ABSENT_INFORMATION */
  85     private static final String ABSENT_BASE_SOURCE_NAME = &quot;**ABSENT_BASE_SOURCE_NAME**&quot;;
  86 
  87     /* to mark when no info available */
  88     static final SDE NO_SDE_INFO_MARK = new SDE();
  89 
  90     // bits set when initialization was attempted (succeeded or failed)
  91     private static final int INITIALIZED_OR_FAILED =
  92         JDWP.ClassStatus.INITIALIZED | JDWP.ClassStatus.ERROR;
  93 
  94     protected ReferenceTypeImpl(VirtualMachine aVm, long aRef) {
  95         super(aVm);
  96         ref = aRef;
  97         genericSignatureGotten = false;
  98     }
  99 
 100     void noticeRedefineClass() {
 101         //Invalidate information previously fetched and cached.
 102         //These will be refreshed later on demand.
 103         baseSourceName = null;
 104         baseSourcePath = null;
 105         modifiers = -1;
 106         fieldsRef = null;
 107         methodsRef = null;
 108         sdeRef = null;
 109         versionNumberGotten = false;
 110         constantPoolInfoGotten = false;
 111     }
 112 
 113     Method getMethodMirror(long ref) {
 114         if (ref == 0) {
 115             // obsolete method
 116             return new ObsoleteMethodImpl(vm, this);
 117         }
 118         // Fetch all methods for the class, check performance impact
 119         // Needs no synchronization now, since methods() returns
 120         // unmodifiable local data
 121         Iterator&lt;Method&gt; it = methods().iterator();
 122         while (it.hasNext()) {
 123             MethodImpl method = (MethodImpl)it.next();
 124             if (method.ref() == ref) {
 125                 return method;
 126             }
 127         }
 128         throw new IllegalArgumentException(&quot;Invalid method id: &quot; + ref);
 129     }
 130 
 131     Field getFieldMirror(long ref) {
 132         // Fetch all fields for the class, check performance impact
 133         // Needs no synchronization now, since fields() returns
 134         // unmodifiable local data
 135         Iterator&lt;Field&gt;it = fields().iterator();
 136         while (it.hasNext()) {
 137             FieldImpl field = (FieldImpl)it.next();
 138             if (field.ref() == ref) {
 139                 return field;
 140             }
 141         }
 142         throw new IllegalArgumentException(&quot;Invalid field id: &quot; + ref);
 143     }
 144 
 145     public boolean equals(Object obj) {
 146         if ((obj != null) &amp;&amp; (obj instanceof ReferenceTypeImpl)) {
 147             ReferenceTypeImpl other = (ReferenceTypeImpl)obj;
 148             return (ref() == other.ref()) &amp;&amp;
 149                 (vm.equals(other.virtualMachine()));
 150         } else {
 151             return false;
 152         }
 153     }
 154 
 155     public int hashCode() {
 156         return(int)ref();
 157     }
 158 
 159     public int compareTo(ReferenceType object) {
 160         /*
 161          * Note that it is critical that compareTo() == 0
 162          * implies that equals() == true. Otherwise, TreeSet
 163          * will collapse classes.
 164          *
 165          * (Classes of the same name loaded by different class loaders
 166          * or in different VMs must not return 0).
 167          */
 168         ReferenceTypeImpl other = (ReferenceTypeImpl)object;
 169         int comp = name().compareTo(other.name());
 170         if (comp == 0) {
 171             long rf1 = ref();
 172             long rf2 = other.ref();
 173             // optimize for typical case: refs equal and VMs equal
 174             if (rf1 == rf2) {
 175                 // sequenceNumbers are always positive
 176                 comp = vm.sequenceNumber -
 177                  ((VirtualMachineImpl)(other.virtualMachine())).sequenceNumber;
 178             } else {
 179                 comp = (rf1 &lt; rf2)? -1 : 1;
 180             }
 181         }
 182         return comp;
 183     }
 184 
 185     public String signature() {
 186         if (signature == null) {
 187             // Does not need synchronization, since worst-case
 188             // static info is fetched twice
 189             if (vm.canGet1_5LanguageFeatures()) {
 190                 /*
 191                  * we might as well get both the signature and the
 192                  * generic signature.
 193                  */
 194                 genericSignature();
 195             } else {
 196                 try {
 197                     signature = JDWP.ReferenceType.Signature.
 198                         process(vm, this).signature;
 199                 } catch (JDWPException exc) {
 200                     throw exc.toJDIException();
 201                 }
 202             }
 203         }
 204         return signature;
 205     }
 206 
 207     public String genericSignature() {
 208         // This gets both the signature and the generic signature
 209         if (vm.canGet1_5LanguageFeatures() &amp;&amp; !genericSignatureGotten) {
 210             // Does not need synchronization, since worst-case
 211             // static info is fetched twice
 212             JDWP.ReferenceType.SignatureWithGeneric result;
 213             try {
 214                 result = JDWP.ReferenceType.SignatureWithGeneric.
 215                     process(vm, this);
 216             } catch (JDWPException exc) {
 217                 throw exc.toJDIException();
 218             }
 219             signature = result.signature;
 220             setGenericSignature(result.genericSignature);
 221         }
 222         return genericSignature;
 223     }
 224 
 225     public ClassLoaderReference classLoader() {
 226         if (!isClassLoaderCached) {
 227             // Does not need synchronization, since worst-case
 228             // static info is fetched twice
 229             try {
 230                 classLoader = JDWP.ReferenceType.ClassLoader.
 231                     process(vm, this).classLoader;
 232                 isClassLoaderCached = true;
 233             } catch (JDWPException exc) {
 234                 throw exc.toJDIException();
 235             }
 236         }
 237         return classLoader;
 238     }
 239 
 240     public ModuleReference module() {
 241         if (module != null) {
 242             return module;
 243         }
 244         // Does not need synchronization, since worst-case
 245         // static info is fetched twice
 246         try {
 247             ModuleReferenceImpl m = JDWP.ReferenceType.Module.
 248                 process(vm, this).module;
 249             module = vm.getModule(m.ref());
 250         } catch (JDWPException exc) {
 251             throw exc.toJDIException();
 252         }
 253         return module;
 254     }
 255 
 256     public boolean isPublic() {
 257         if (modifiers == -1)
 258             getModifiers();
 259 
 260         return((modifiers &amp; VMModifiers.PUBLIC) &gt; 0);
 261     }
 262 
 263     public boolean isProtected() {
 264         if (modifiers == -1)
 265             getModifiers();
 266 
 267         return((modifiers &amp; VMModifiers.PROTECTED) &gt; 0);
 268     }
 269 
 270     public boolean isPrivate() {
 271         if (modifiers == -1)
 272             getModifiers();
 273 
 274         return((modifiers &amp; VMModifiers.PRIVATE) &gt; 0);
 275     }
 276 
 277     public boolean isPackagePrivate() {
 278         return !isPublic() &amp;&amp; !isPrivate() &amp;&amp; !isProtected();
 279     }
 280 
 281     public boolean isAbstract() {
 282         if (modifiers == -1)
 283             getModifiers();
 284 
 285         return((modifiers &amp; VMModifiers.ABSTRACT) &gt; 0);
 286     }
 287 
 288     public boolean isFinal() {
 289         if (modifiers == -1)
 290             getModifiers();
 291 
 292         return((modifiers &amp; VMModifiers.FINAL) &gt; 0);
 293     }
 294 
 295     public boolean isStatic() {
 296         if (modifiers == -1)
 297             getModifiers();
 298 
 299         return((modifiers &amp; VMModifiers.STATIC) &gt; 0);
 300     }
 301 
 302     public boolean isPrepared() {
 303         // This ref type may have been prepared before we were getting
 304         // events, so get it once.  After that,
 305         // this status flag is updated through the ClassPrepareEvent,
 306         // there is no need for the expense of a JDWP query.
 307         if (status == 0) {
 308             updateStatus();
 309         }
 310         return isPrepared;
 311     }
 312 
 313     public boolean isVerified() {
 314         // Once true, it never resets, so we don&#39;t need to update
 315         if ((status &amp; JDWP.ClassStatus.VERIFIED) == 0) {
 316             updateStatus();
 317         }
 318         return (status &amp; JDWP.ClassStatus.VERIFIED) != 0;
 319     }
 320 
 321     public boolean isInitialized() {
 322         // Once initialization succeeds or fails, it never resets,
 323         // so we don&#39;t need to update
 324         if ((status &amp; INITIALIZED_OR_FAILED) == 0) {
 325             updateStatus();
 326         }
 327         return (status &amp; JDWP.ClassStatus.INITIALIZED) != 0;
 328     }
 329 
 330     public boolean failedToInitialize() {
 331         // Once initialization succeeds or fails, it never resets,
 332         // so we don&#39;t need to update
 333         if ((status &amp; INITIALIZED_OR_FAILED) == 0) {
 334             updateStatus();
 335         }
 336         return (status &amp; JDWP.ClassStatus.ERROR) != 0;
 337     }
 338 
 339     public List&lt;Field&gt; fields() {
 340         List&lt;Field&gt; fields = (fieldsRef == null) ? null : fieldsRef.get();
 341         if (fields == null) {
 342             if (vm.canGet1_5LanguageFeatures()) {
 343                 JDWP.ReferenceType.FieldsWithGeneric.FieldInfo[] jdwpFields;
 344                 try {
 345                     jdwpFields = JDWP.ReferenceType.FieldsWithGeneric.
 346                         process(vm, this).declared;
 347                 } catch (JDWPException exc) {
 348                     throw exc.toJDIException();
 349                 }
 350                 fields = new ArrayList&lt;&gt;(jdwpFields.length);
 351                 for (int i=0; i&lt;jdwpFields.length; i++) {
 352                     JDWP.ReferenceType.FieldsWithGeneric.FieldInfo fi
 353                         = jdwpFields[i];
 354 
 355                     Field field = new FieldImpl(vm, this, fi.fieldID,
 356                                                 fi.name, fi.signature,
 357                                                 fi.genericSignature,
 358                                                 fi.modBits);
 359                     fields.add(field);
 360                 }
 361             } else {
 362                 JDWP.ReferenceType.Fields.FieldInfo[] jdwpFields;
 363                 try {
 364                     jdwpFields = JDWP.ReferenceType.Fields.
 365                         process(vm, this).declared;
 366                 } catch (JDWPException exc) {
 367                     throw exc.toJDIException();
 368                 }
 369                 fields = new ArrayList&lt;&gt;(jdwpFields.length);
 370                 for (int i=0; i&lt;jdwpFields.length; i++) {
 371                     JDWP.ReferenceType.Fields.FieldInfo fi = jdwpFields[i];
 372 
 373                     Field field = new FieldImpl(vm, this, fi.fieldID,
 374                                             fi.name, fi.signature,
 375                                             null,
 376                                             fi.modBits);
 377                     fields.add(field);
 378                 }
 379             }
 380 
 381             fields = Collections.unmodifiableList(fields);
 382             fieldsRef = new SoftReference&lt;List&lt;Field&gt;&gt;(fields);
 383         }
 384         return fields;
 385     }
 386 
 387     abstract List&lt;? extends ReferenceType&gt; inheritedTypes();
 388 
 389     void addVisibleFields(List&lt;Field&gt; visibleList, Map&lt;String, Field&gt; visibleTable, List&lt;String&gt; ambiguousNames) {
 390         for (Field field : visibleFields()) {
 391             String name = field.name();
 392             if (!ambiguousNames.contains(name)) {
 393                 Field duplicate = visibleTable.get(name);
 394                 if (duplicate == null) {
 395                     visibleList.add(field);
 396                     visibleTable.put(name, field);
 397                 } else if (!field.equals(duplicate)) {
 398                     ambiguousNames.add(name);
 399                     visibleTable.remove(name);
 400                     visibleList.remove(duplicate);
 401                 } else {
 402                     // identical field from two branches; do nothing
 403                 }
 404             }
 405         }
 406     }
 407 
 408     public List&lt;Field&gt; visibleFields() {
 409         /*
 410          * Maintain two different collections of visible fields. The
 411          * list maintains a reasonable order for return. The
 412          * hash map provides an efficient way to lookup visible fields
 413          * by name, important for finding hidden or ambiguous fields.
 414          */
 415         List&lt;Field&gt; visibleList = new ArrayList&lt;&gt;();
 416         Map&lt;String, Field&gt;  visibleTable = new HashMap&lt;String, Field&gt;();
 417 
 418         /* Track fields removed from above collection due to ambiguity */
 419         List&lt;String&gt; ambiguousNames = new ArrayList&lt;String&gt;();
 420 
 421         /* Add inherited, visible fields */
 422         List&lt;? extends ReferenceType&gt; types = inheritedTypes();
 423         Iterator&lt;? extends ReferenceType&gt; iter = types.iterator();
 424         while (iter.hasNext()) {
 425             /*
 426              * TO DO: Be defensive and check for cyclic interface inheritance
 427              */
 428             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 429             type.addVisibleFields(visibleList, visibleTable, ambiguousNames);
 430         }
 431 
 432         /*
 433          * Insert fields from this type, removing any inherited fields they
 434          * hide.
 435          */
 436         List&lt;Field&gt; retList = new ArrayList&lt;&gt;(fields());
 437         for (Field field : retList) {
 438             Field hidden = visibleTable.get(field.name());
 439             if (hidden != null) {
 440                 visibleList.remove(hidden);
 441             }
 442         }
 443         retList.addAll(visibleList);
 444         return retList;
 445     }
 446 
 447     void addAllFields(List&lt;Field&gt; fieldList, Set&lt;ReferenceType&gt; typeSet) {
 448         /* Continue the recursion only if this type is new */
 449         if (!typeSet.contains(this)) {
 450             typeSet.add(this);
 451 
 452             /* Add local fields */
 453             fieldList.addAll(fields());
 454 
 455             /* Add inherited fields */
 456             List&lt;? extends ReferenceType&gt; types = inheritedTypes();
 457             Iterator&lt;? extends ReferenceType&gt; iter = types.iterator();
 458             while (iter.hasNext()) {
 459                 ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 460                 type.addAllFields(fieldList, typeSet);
 461             }
 462         }
 463     }
 464     public List&lt;Field&gt; allFields() {
 465         List&lt;Field&gt; fieldList = new ArrayList&lt;&gt;();
 466         Set&lt;ReferenceType&gt; typeSet = new HashSet&lt;ReferenceType&gt;();
 467         addAllFields(fieldList, typeSet);
 468         return fieldList;
 469     }
 470 
 471     public Field fieldByName(String fieldName) {
 472         List&lt;Field&gt; searchList = visibleFields();
 473 
 474         for (int i = 0; i &lt; searchList.size(); i++) {
 475             Field f = searchList.get(i);
 476 
 477             if (f.name().equals(fieldName)) {
 478                 return f;
 479             }
 480         }
 481         //throw new NoSuchFieldException(&quot;Field &#39;&quot; + fieldName + &quot;&#39; not found in &quot; + name());
 482         return null;
 483     }
 484 
 485     public List&lt;Method&gt; methods() {
 486         List&lt;Method&gt; methods = (methodsRef == null) ? null : methodsRef.get();
 487         if (methods == null) {
 488             if (!vm.canGet1_5LanguageFeatures()) {
 489                 methods = methods1_4();
 490             } else {
 491                 JDWP.ReferenceType.MethodsWithGeneric.MethodInfo[] declared;
 492                 try {
 493                     declared = JDWP.ReferenceType.MethodsWithGeneric.
 494                         process(vm, this).declared;
 495                 } catch (JDWPException exc) {
 496                     throw exc.toJDIException();
 497                 }
 498                 methods = new ArrayList&lt;&gt;(declared.length);
 499                 for (int i = 0; i &lt; declared.length; i++) {
 500                     JDWP.ReferenceType.MethodsWithGeneric.MethodInfo
 501                         mi = declared[i];
 502 
 503                     Method method = MethodImpl.createMethodImpl(vm, this,
 504                                                          mi.methodID,
 505                                                          mi.name, mi.signature,
 506                                                          mi.genericSignature,
 507                                                          mi.modBits);
 508                     methods.add(method);
 509                 }
 510             }
 511             methods = Collections.unmodifiableList(methods);
 512             methodsRef = new SoftReference&lt;List&lt;Method&gt;&gt;(methods);
 513         }
 514         return methods;
 515     }
 516 
 517     private List&lt;Method&gt; methods1_4() {
 518         List&lt;Method&gt; methods;
 519         JDWP.ReferenceType.Methods.MethodInfo[] declared;
 520         try {
 521             declared = JDWP.ReferenceType.Methods.
 522                 process(vm, this).declared;
 523         } catch (JDWPException exc) {
 524             throw exc.toJDIException();
 525         }
 526         methods = new ArrayList&lt;Method&gt;(declared.length);
 527         for (int i=0; i&lt;declared.length; i++) {
 528             JDWP.ReferenceType.Methods.MethodInfo mi = declared[i];
 529 
 530             Method method = MethodImpl.createMethodImpl(vm, this,
 531                                                         mi.methodID,
 532                                                         mi.name, mi.signature,
 533                                                         null,
 534                                                         mi.modBits);
 535             methods.add(method);
 536         }
 537         return methods;
 538     }
 539 
 540     /*
 541      * Utility method used by subclasses to build lists of visible
 542      * methods.
 543      */
 544     void addToMethodMap(Map&lt;String, Method&gt; methodMap, List&lt;Method&gt; methodList) {
 545         for (Method method : methodList)
 546             methodMap.put(method.name().concat(method.signature()), method);
 547         }
 548 
 549     abstract void addVisibleMethods(Map&lt;String, Method&gt; methodMap, Set&lt;InterfaceType&gt; seenInterfaces);
 550 
 551     public List&lt;Method&gt; visibleMethods() {
 552         /*
 553          * Build a collection of all visible methods. The hash
 554          * map allows us to do this efficiently by keying on the
 555          * concatenation of name and signature.
 556          */
 557         Map&lt;String, Method&gt; map = new HashMap&lt;String, Method&gt;();
 558         addVisibleMethods(map, new HashSet&lt;InterfaceType&gt;());
 559 
 560         /*
 561          * ... but the hash map destroys order. Methods should be
 562          * returned in a sensible order, as they are in allMethods().
 563          * So, start over with allMethods() and use the hash map
 564          * to filter that ordered collection.
 565          */
 566         List&lt;Method&gt; list = allMethods();
 567         list.retainAll(new HashSet&lt;Method&gt;(map.values()));
 568         return list;
 569     }
 570 
 571     abstract public List&lt;Method&gt; allMethods();
 572 
 573     public List&lt;Method&gt; methodsByName(String name) {
 574         List&lt;Method&gt; methods = visibleMethods();
 575         ArrayList&lt;Method&gt; retList = new ArrayList&lt;Method&gt;(methods.size());
 576         for (Method candidate : methods) {
 577             if (candidate.name().equals(name)) {
 578                 retList.add(candidate);
 579             }
 580         }
 581         retList.trimToSize();
 582         return retList;
 583     }
 584 
 585     public List&lt;Method&gt; methodsByName(String name, String signature) {
 586         List&lt;Method&gt; methods = visibleMethods();
 587         ArrayList&lt;Method&gt; retList = new ArrayList&lt;Method&gt;(methods.size());
 588         for (Method candidate : methods) {
 589             if (candidate.name().equals(name) &amp;&amp;
 590                 candidate.signature().equals(signature)) {
 591                 retList.add(candidate);
 592             }
 593         }
 594         retList.trimToSize();
 595         return retList;
 596     }
 597 
 598     List&lt;InterfaceType&gt; getInterfaces() {
 599         InterfaceTypeImpl[] intfs;
 600         try {
 601             intfs = JDWP.ReferenceType.Interfaces.
 602                                          process(vm, this).interfaces;
 603         } catch (JDWPException exc) {
 604             throw exc.toJDIException();
 605         }
 606         return Arrays.asList((InterfaceType[])intfs);
 607     }
 608 
 609     public List&lt;ReferenceType&gt; nestedTypes() {
 610         List&lt;ReferenceType&gt; all = vm.allClasses();
 611         List&lt;ReferenceType&gt; nested = new ArrayList&lt;ReferenceType&gt;();
 612         String outername = name();
 613         int outerlen = outername.length();
 614         Iterator&lt;ReferenceType&gt; iter = all.iterator();
 615         while (iter.hasNext()) {
 616             ReferenceType refType = iter.next();
 617             String name = refType.name();
 618             int len = name.length();
 619             /* The separator is historically &#39;$&#39; but could also be &#39;#&#39; */
 620             if ( len &gt; outerlen &amp;&amp; name.startsWith(outername) ) {
 621                 char c = name.charAt(outerlen);
 622                 if ( c ==&#39;$&#39; || c== &#39;#&#39; ) {
 623                     nested.add(refType);
 624                 }
 625             }
 626         }
 627         return nested;
 628     }
 629 
 630     public Value getValue(Field sig) {
 631         List&lt;Field&gt; list = new ArrayList&lt;Field&gt;(1);
 632         list.add(sig);
 633         Map&lt;Field, Value&gt; map = getValues(list);
 634         return map.get(sig);
 635     }
 636 
 637 
 638     void validateFieldAccess(Field field) {
 639         /*
 640          * Field must be in this object&#39;s class, a superclass, or
 641          * implemented interface
 642          */
 643         ReferenceTypeImpl declType = (ReferenceTypeImpl)field.declaringType();
 644         if (!declType.isAssignableFrom(this)) {
 645             throw new IllegalArgumentException(&quot;Invalid field&quot;);
 646         }
 647     }
 648 
 649     void validateFieldSet(Field field) {
 650         validateFieldAccess(field);
 651         if (field.isFinal()) {
 652             throw new IllegalArgumentException(&quot;Cannot set value of final field&quot;);
 653         }
 654     }
 655 
 656     /**
 657      * Returns a map of field values
 658      */
 659     public Map&lt;Field,Value&gt; getValues(List&lt;? extends Field&gt; theFields) {
 660         validateMirrors(theFields);
 661 
 662         int size = theFields.size();
 663         JDWP.ReferenceType.GetValues.Field[] queryFields =
 664                          new JDWP.ReferenceType.GetValues.Field[size];
 665 
 666         for (int i=0; i&lt;size; i++) {
 667             FieldImpl field = (FieldImpl)theFields.get(i);
 668 
 669             validateFieldAccess(field);
 670 
 671             // Do more validation specific to ReferenceType field getting
 672             if (!field.isStatic()) {
 673                 throw new IllegalArgumentException(
 674                      &quot;Attempt to use non-static field with ReferenceType&quot;);
 675             }
 676             queryFields[i] = new JDWP.ReferenceType.GetValues.Field(
 677                                          field.ref());
 678         }
 679 
 680         Map&lt;Field, Value&gt; map = new HashMap&lt;Field, Value&gt;(size);
 681 
 682         ValueImpl[] values;
 683         try {
 684             values = JDWP.ReferenceType.GetValues.
 685                                      process(vm, this, queryFields).values;
 686         } catch (JDWPException exc) {
 687             throw exc.toJDIException();
 688         }
 689 
 690         if (size != values.length) {
 691             throw new InternalException(
 692                          &quot;Wrong number of values returned from target VM&quot;);
 693         }
 694         for (int i=0; i&lt;size; i++) {
 695             FieldImpl field = (FieldImpl)theFields.get(i);
 696             map.put(field, values[i]);
 697         }
 698 
 699         return map;
 700     }
 701 
 702     public ClassObjectReference classObject() {
 703         if (classObject == null) {
 704             // Are classObjects unique for an Object, or
 705             // created each time? Is this spec&#39;ed?
 706             synchronized(this) {
 707                 if (classObject == null) {
 708                     try {
 709                         classObject = JDWP.ReferenceType.ClassObject.
 710                             process(vm, this).classObject;
 711                     } catch (JDWPException exc) {
 712                         throw exc.toJDIException();
 713                     }
 714                 }
 715             }
 716         }
 717         return classObject;
 718     }
 719 
 720     SDE.Stratum stratum(String stratumID) {
 721         SDE sde = sourceDebugExtensionInfo();
 722         if (!sde.isValid()) {
 723             sde = NO_SDE_INFO_MARK;
 724         }
 725         return sde.stratum(stratumID);
 726     }
 727 
 728     public String sourceName() throws AbsentInformationException {
 729         return sourceNames(vm.getDefaultStratum()).get(0);
 730     }
 731 
 732     public List&lt;String&gt; sourceNames(String stratumID)
 733                                 throws AbsentInformationException {
 734         SDE.Stratum stratum = stratum(stratumID);
 735         if (stratum.isJava()) {
 736             List&lt;String&gt; result = new ArrayList&lt;String&gt;(1);
 737             result.add(baseSourceName());
 738             return result;
 739         }
 740         return stratum.sourceNames(this);
 741     }
 742 
 743     public List&lt;String&gt; sourcePaths(String stratumID)
 744                                 throws AbsentInformationException {
 745         SDE.Stratum stratum = stratum(stratumID);
 746         if (stratum.isJava()) {
 747             List&lt;String&gt; result = new ArrayList&lt;String&gt;(1);
 748             result.add(baseSourceDir() + baseSourceName());
 749             return result;
 750         }
 751         return stratum.sourcePaths(this);
 752     }
 753 
 754     String baseSourceName() throws AbsentInformationException {
 755         String bsn = baseSourceName;
 756         if (bsn == null) {
 757             // Does not need synchronization, since worst-case
 758             // static info is fetched twice
 759             try {
 760                 bsn = JDWP.ReferenceType.SourceFile.
 761                     process(vm, this).sourceFile;
 762             } catch (JDWPException exc) {
 763                 if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {
 764                     bsn = ABSENT_BASE_SOURCE_NAME;
 765                 } else {
 766                     throw exc.toJDIException();
 767                 }
 768             }
 769             baseSourceName = bsn;
 770         }
 771         if (bsn == ABSENT_BASE_SOURCE_NAME) {
 772             throw new AbsentInformationException();
 773         }
 774         return bsn;
 775     }
 776 
 777     String baseSourcePath() throws AbsentInformationException {
 778         String bsp = baseSourcePath;
 779         if (bsp == null) {
 780             bsp = baseSourceDir() + baseSourceName();
 781             baseSourcePath = bsp;
 782         }
 783         return bsp;
 784     }
 785 
 786     String baseSourceDir() {
 787         if (baseSourceDir == null) {
 788             String typeName = name();
 789             StringBuilder sb = new StringBuilder(typeName.length() + 10);
 790             int index = 0;
 791             int nextIndex;
 792 
 793             while ((nextIndex = typeName.indexOf(&#39;.&#39;, index)) &gt; 0) {
 794                 sb.append(typeName.substring(index, nextIndex));
 795                 sb.append(java.io.File.separatorChar);
 796                 index = nextIndex + 1;
 797             }
 798             baseSourceDir = sb.toString();
 799         }
 800         return baseSourceDir;
 801     }
 802 
 803     public String sourceDebugExtension()
 804                            throws AbsentInformationException {
 805         if (!vm.canGetSourceDebugExtension()) {
 806             throw new UnsupportedOperationException();
 807         }
 808         SDE sde = sourceDebugExtensionInfo();
 809         if (sde == NO_SDE_INFO_MARK) {
 810             throw new AbsentInformationException();
 811         }
 812         return sde.sourceDebugExtension;
 813     }
 814 
 815     private SDE sourceDebugExtensionInfo() {
 816         if (!vm.canGetSourceDebugExtension()) {
 817             return NO_SDE_INFO_MARK;
 818         }
 819         SDE sde = (sdeRef == null) ?  null : sdeRef.get();
 820         if (sde == null) {
 821             String extension = null;
 822             try {
 823                 extension = JDWP.ReferenceType.SourceDebugExtension.
 824                     process(vm, this).extension;
 825             } catch (JDWPException exc) {
 826                 if (exc.errorCode() != JDWP.Error.ABSENT_INFORMATION) {
 827                     sdeRef = new SoftReference&lt;SDE&gt;(NO_SDE_INFO_MARK);
 828                     throw exc.toJDIException();
 829                 }
 830             }
 831             if (extension == null) {
 832                 sde = NO_SDE_INFO_MARK;
 833             } else {
 834                 sde = new SDE(extension);
 835             }
 836             sdeRef = new SoftReference&lt;SDE&gt;(sde);
 837         }
 838         return sde;
 839     }
 840 
 841     public List&lt;String&gt; availableStrata() {
 842         SDE sde = sourceDebugExtensionInfo();
 843         if (sde.isValid()) {
 844             return sde.availableStrata();
 845         } else {
 846             List&lt;String&gt; strata = new ArrayList&lt;String&gt;();
 847             strata.add(SDE.BASE_STRATUM_NAME);
 848             return strata;
 849         }
 850     }
 851 
 852     /**
 853      * Always returns non-null stratumID
 854      */
 855     public String defaultStratum() {
 856         SDE sdei = sourceDebugExtensionInfo();
 857         if (sdei.isValid()) {
 858             return sdei.defaultStratumId;
 859         } else {
 860             return SDE.BASE_STRATUM_NAME;
 861         }
 862     }
 863 
 864     public int modifiers() {
 865         if (modifiers == -1)
 866             getModifiers();
 867 
 868         return modifiers;
 869     }
 870 
 871     public List&lt;Location&gt; allLineLocations()
 872                             throws AbsentInformationException {
 873         return allLineLocations(vm.getDefaultStratum(), null);
 874     }
 875 
 876     public List&lt;Location&gt; allLineLocations(String stratumID, String sourceName)
 877                             throws AbsentInformationException {
 878         boolean someAbsent = false; // A method that should have info, didn&#39;t
 879         SDE.Stratum stratum = stratum(stratumID);
 880         List&lt;Location&gt; list = new ArrayList&lt;Location&gt;();  // location list
 881 
 882         for (Iterator&lt;Method&gt; iter = methods().iterator(); iter.hasNext(); ) {
 883             MethodImpl method = (MethodImpl)iter.next();
 884             try {
 885                 list.addAll(
 886                    method.allLineLocations(stratum, sourceName));
 887             } catch(AbsentInformationException exc) {
 888                 someAbsent = true;
 889             }
 890         }
 891 
 892         // If we retrieved no line info, and at least one of the methods
 893         // should have had some (as determined by an
 894         // AbsentInformationException being thrown) then we rethrow
 895         // the AbsentInformationException.
 896         if (someAbsent &amp;&amp; list.size() == 0) {
 897             throw new AbsentInformationException();
 898         }
 899         return list;
 900     }
 901 
 902     public List&lt;Location&gt; locationsOfLine(int lineNumber)
 903                            throws AbsentInformationException {
 904         return locationsOfLine(vm.getDefaultStratum(),
 905                                null,
 906                                lineNumber);
 907     }
 908 
 909     public List&lt;Location&gt; locationsOfLine(String stratumID,
 910                                 String sourceName,
 911                                 int lineNumber)
 912                            throws AbsentInformationException {
 913         // A method that should have info, didn&#39;t
 914         boolean someAbsent = false;
 915         // A method that should have info, did
 916         boolean somePresent = false;
 917         List&lt;Method&gt; methods = methods();
 918         SDE.Stratum stratum = stratum(stratumID);
 919 
 920         List&lt;Location&gt; list = new ArrayList&lt;Location&gt;();
 921 
 922         Iterator&lt;Method&gt; iter = methods.iterator();
 923         while(iter.hasNext()) {
 924             MethodImpl method = (MethodImpl)iter.next();
 925             // eliminate native and abstract to eliminate
 926             // false positives
 927             if (!method.isAbstract() &amp;&amp;
 928                 !method.isNative()) {
 929                 try {
 930                     list.addAll(
 931                        method.locationsOfLine(stratum,
 932                                               sourceName,
 933                                               lineNumber));
 934                     somePresent = true;
 935                 } catch(AbsentInformationException exc) {
 936                     someAbsent = true;
 937                 }
 938             }
 939         }
 940         if (someAbsent &amp;&amp; !somePresent) {
 941             throw new AbsentInformationException();
 942         }
 943         return list;
 944     }
 945 
 946     public List&lt;ObjectReference&gt; instances(long maxInstances) {
 947         if (!vm.canGetInstanceInfo()) {
 948             throw new UnsupportedOperationException(
 949                 &quot;target does not support getting instances&quot;);
 950         }
 951 
 952         if (maxInstances &lt; 0) {
 953             throw new IllegalArgumentException(&quot;maxInstances is less than zero: &quot;
 954                                               + maxInstances);
 955         }
 956         int intMax = (maxInstances &gt; Integer.MAX_VALUE)?
 957             Integer.MAX_VALUE: (int)maxInstances;
 958         // JDWP can&#39;t currently handle more than this (in mustang)
 959 
 960         try {
 961             return Arrays.asList(
 962                 (ObjectReference[])JDWP.ReferenceType.Instances.
 963                         process(vm, this, intMax).instances);
 964         } catch (JDWPException exc) {
 965             throw exc.toJDIException();
 966         }
 967     }
 968 
 969     private void getClassFileVersion() {
 970         if (!vm.canGetClassFileVersion()) {
 971             throw new UnsupportedOperationException();
 972         }
 973         JDWP.ReferenceType.ClassFileVersion classFileVersion;
 974         if (versionNumberGotten) {
 975             return;
 976         } else {
 977             try {
 978                 classFileVersion = JDWP.ReferenceType.ClassFileVersion.process(vm, this);
 979             } catch (JDWPException exc) {
 980                 if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {
 981                     majorVersion = 0;
 982                     minorVersion = 0;
 983                     versionNumberGotten = true;
 984                     return;
 985                 } else {
 986                     throw exc.toJDIException();
 987                 }
 988             }
 989             majorVersion = classFileVersion.majorVersion;
 990             minorVersion = classFileVersion.minorVersion;
 991             versionNumberGotten = true;
 992         }
 993     }
 994 
 995     public int majorVersion() {
 996         try {
 997             getClassFileVersion();
 998         } catch (RuntimeException exc) {
 999             throw exc;
1000         }
1001         return majorVersion;
1002     }
1003 
1004     public int minorVersion() {
1005         try {
1006             getClassFileVersion();
1007         } catch (RuntimeException exc) {
1008             throw exc;
1009         }
1010         return minorVersion;
1011     }
1012 
1013     private byte[] getConstantPoolInfo() {
1014         JDWP.ReferenceType.ConstantPool jdwpCPool;
1015         if (!vm.canGetConstantPool()) {
1016             throw new UnsupportedOperationException();
1017         }
1018         if (constantPoolInfoGotten) {
1019             if (constantPoolBytesRef == null) {
1020                 return null;
1021             }
1022             byte[] cpbytes = constantPoolBytesRef.get();
1023             if (cpbytes != null) {
1024                 return cpbytes;
1025             }
1026         }
1027 
1028         try {
1029             jdwpCPool = JDWP.ReferenceType.ConstantPool.process(vm, this);
1030         } catch (JDWPException exc) {
1031             if (exc.errorCode() == JDWP.Error.ABSENT_INFORMATION) {
1032                 constanPoolCount = 0;
1033                 constantPoolBytesRef = null;
1034                 constantPoolInfoGotten = true;
1035                 return null;
1036             } else {
1037                 throw exc.toJDIException();
1038             }
1039         }
1040         byte[] cpbytes;
1041         constanPoolCount = jdwpCPool.count;
1042         cpbytes = jdwpCPool.bytes;
1043         constantPoolBytesRef = new SoftReference&lt;byte[]&gt;(cpbytes);
1044         constantPoolInfoGotten = true;
1045         return cpbytes;
1046     }
1047 
1048     public int constantPoolCount() {
1049         try {
1050             getConstantPoolInfo();
1051         } catch (RuntimeException exc) {
1052             throw exc;
1053         }
1054         return constanPoolCount;
1055     }
1056 
1057     public byte[] constantPool() {
1058         byte[] cpbytes;
1059         try {
1060             cpbytes = getConstantPoolInfo();
1061         } catch (RuntimeException exc) {
1062             throw exc;
1063         }
1064         if (cpbytes != null) {
1065             /*
1066              * Arrays are always modifiable, so it is a little unsafe
1067              * to return the cached bytecodes directly; instead, we
1068              * make a clone at the cost of using more memory.
1069              */
1070             return cpbytes.clone();
1071         } else {
1072             return null;
1073         }
1074     }
1075 
1076     // Does not need synchronization, since worst-case
1077     // static info is fetched twice
1078     void getModifiers() {
1079         if (modifiers != -1) {
1080             return;
1081         }
1082         try {
1083             modifiers = JDWP.ReferenceType.Modifiers.
1084                                   process(vm, this).modBits;
1085         } catch (JDWPException exc) {
1086             throw exc.toJDIException();
1087         }
1088     }
1089 
1090     void decodeStatus(int status) {
1091         this.status = status;
1092         if ((status &amp; JDWP.ClassStatus.PREPARED) != 0) {
1093             isPrepared = true;
1094         }
1095     }
1096 
1097     void updateStatus() {
1098         try {
1099             decodeStatus(JDWP.ReferenceType.Status.process(vm, this).status);
1100         } catch (JDWPException exc) {
1101             throw exc.toJDIException();
1102         }
1103     }
1104 
1105     void markPrepared() {
1106         isPrepared = true;
1107     }
1108 
1109     long ref() {
1110         return ref;
1111     }
1112 
1113     int indexOf(Method method) {
1114         // Make sure they&#39;re all here - the obsolete method
1115         // won&#39;t be found and so will have index -1
1116         return methods().indexOf(method);
1117     }
1118 
1119     int indexOf(Field field) {
1120         // Make sure they&#39;re all here
1121         return fields().indexOf(field);
1122     }
1123 
1124     /*
1125      * Return true if an instance of this type
1126      * can be assigned to a variable of the given type
1127      */
1128     abstract boolean isAssignableTo(ReferenceType type);
1129 
1130     boolean isAssignableFrom(ReferenceType type) {
1131         return ((ReferenceTypeImpl)type).isAssignableTo(this);
1132     }
1133 
1134     boolean isAssignableFrom(ObjectReference object) {
1135         return object == null ||
1136                isAssignableFrom(object.referenceType());
1137     }
1138 
1139     void setStatus(int status) {
1140         decodeStatus(status);
1141     }
1142 
1143     void setSignature(String signature) {
1144         this.signature = signature;
1145     }
1146 
1147     void setGenericSignature(String signature) {
1148         if (signature != null &amp;&amp; signature.length() == 0) {
1149             this.genericSignature = null;
1150         } else{
1151             this.genericSignature = signature;
1152         }
1153         this.genericSignatureGotten = true;
1154     }
1155 
1156     private static boolean isOneDimensionalPrimitiveArray(String signature) {
1157         int i = signature.lastIndexOf(&#39;[&#39;);
1158         /*
1159          * TO DO: Centralize JNI signature knowledge.
1160          *
1161          * Ref:
1162          *  jdk1.4/doc/guide/jpda/jdi/com/sun/jdi/doc-files/signature.html
1163          */
1164         boolean isPA;
1165         if (i &lt; 0 || signature.startsWith(&quot;[[&quot;)) {
1166             isPA = false;
1167         } else {
1168             char c = signature.charAt(i + 1);
1169             isPA = (c != &#39;L&#39;);
1170         }
1171         return isPA;
1172     }
1173 
1174     Type findType(String signature) throws ClassNotLoadedException {
1175         Type type;
1176         if (signature.length() == 1) {
1177             /* OTI FIX: Must be a primitive type or the void type */
1178             char sig = signature.charAt(0);
1179             if (sig == &#39;V&#39;) {
1180                 type = vm.theVoidType();
1181             } else {
1182                 type = vm.primitiveTypeMirror((byte)sig);
1183             }
1184         } else {
1185             // Must be a reference type.
1186             ClassLoaderReferenceImpl loader =
1187                        (ClassLoaderReferenceImpl)classLoader();
1188             if ((loader == null) ||
1189                 (isOneDimensionalPrimitiveArray(signature)) //Work around 4450091
1190                 ) {
1191                 // Caller wants type of boot class field
1192                 type = vm.findBootType(signature);
1193             } else {
1194                 // Caller wants type of non-boot class field
1195                 type = loader.findType(signature);
1196             }
1197         }
1198         return type;
1199     }
1200 
1201     String loaderString() {
1202         if (classLoader() != null) {
1203             return &quot;loaded by &quot; + classLoader().toString();
1204         } else {
1205             return &quot;no class loader&quot;;
1206         }
1207     }
1208 
1209 }
    </pre>
  </body>
</html>
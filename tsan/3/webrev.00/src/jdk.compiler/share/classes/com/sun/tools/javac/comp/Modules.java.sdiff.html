<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemberEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Operators.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 338                 modules.add(sym);
 339             } else {
 340                 log.error(toplevel.pos(), Errors.TooManyModules);
 341             }
 342 
 343             Env&lt;AttrContext&gt; provisionalEnv = new Env&lt;&gt;(decl, null);
 344 
 345             provisionalEnv.toplevel = toplevel;
 346             typeEnvs.put(sym, provisionalEnv);
 347         } else if (isModuleInfo) {
 348             if (multiModuleMode) {
 349                 JCTree tree = toplevel.defs.isEmpty() ? toplevel : toplevel.defs.head;
 350                 log.error(tree.pos(), Errors.ExpectedModule);
 351             }
 352         }
 353     }
 354 
 355     private void setCompilationUnitModules(List&lt;JCCompilationUnit&gt; trees, Set&lt;ModuleSymbol&gt; rootModules, ClassSymbol c) {
 356         // update the module for each compilation unit
 357         if (multiModuleMode) {
<span class="line-modified"> 358             checkNoAllModulePath();</span>
 359             for (JCCompilationUnit tree: trees) {
 360                 if (tree.defs.isEmpty()) {
 361                     tree.modle = syms.unnamedModule;
 362                     continue;
 363                 }
 364 
 365                 JavaFileObject prev = log.useSource(tree.sourcefile);
 366                 try {
 367                     Location msplocn = getModuleLocation(tree);
 368                     Location plocn = fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH) ?
 369                             fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH,
 370                                                              tree.sourcefile) :
 371                             null;
 372 
 373                     if (plocn != null) {
 374                         Name name = names.fromString(fileManager.inferModuleName(plocn));
 375                         ModuleSymbol msym = moduleFinder.findModule(name);
 376                         tree.modle = msym;
 377                         rootModules.add(msym);

 378 
 379                         if (msplocn != null) {
 380                             Name mspname = names.fromString(fileManager.inferModuleName(msplocn));
 381                             if (name != mspname) {
 382                                 log.error(tree.pos(), Errors.FilePatchedAndMsp(name, mspname));
 383                             }
 384                         }
 385                     } else if (msplocn != null) {
 386                         if (tree.getModuleDecl() != null) {
 387                             JavaFileObject canonical =
 388                                     fileManager.getJavaFileForInput(msplocn, &quot;module-info&quot;, Kind.SOURCE);
 389                             if (canonical == null || !fileManager.isSameFile(canonical, tree.sourcefile)) {
 390                                 log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 391                             }
 392                         }
 393                         Name name = names.fromString(fileManager.inferModuleName(msplocn));
 394                         ModuleSymbol msym;
 395                         JCModuleDecl decl = tree.getModuleDecl();
 396                         if (decl != null) {
 397                             msym = decl.sym;
</pre>
<hr />
<pre>
 421                             }
 422                         }
 423                         tree.modle = msym;
 424                         rootModules.add(msym);
 425                     } else if (c != null &amp;&amp; c.packge().modle == syms.unnamedModule) {
 426                         tree.modle = syms.unnamedModule;
 427                     } else {
 428                         if (tree.getModuleDecl() != null) {
 429                             log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 430                         } else {
 431                             log.error(tree.pos(), Errors.NotInModuleOnModuleSourcePath);
 432                         }
 433                         tree.modle = syms.errModule;
 434                     }
 435                 } catch (IOException e) {
 436                     throw new Error(e); // FIXME
 437                 } finally {
 438                     log.useSource(prev);
 439                 }
 440             }



 441             if (syms.unnamedModule.sourceLocation == null) {
 442                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 443                 syms.unnamedModule.sourceLocation = StandardLocation.SOURCE_PATH;
 444                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 445             }
 446             defaultModule = syms.unnamedModule;
 447         } else {
 448             ModuleSymbol module = null;
 449             if (defaultModule == null) {
 450                 String moduleOverride = singleModuleOverride(trees);
 451                 switch (rootModules.size()) {
 452                     case 0:
 453                         try {
 454                             defaultModule = moduleFinder.findSingleModule();
 455                         } catch (CompletionFailure cf) {
 456                             chk.completionError(null, cf);
 457                             defaultModule = syms.unnamedModule;
 458                         }
 459                         if (defaultModule == syms.unnamedModule) {
 460                             if (moduleOverride != null) {
<span class="line-removed"> 461                                 checkNoAllModulePath();</span>
 462                                 defaultModule = moduleFinder.findModule(names.fromString(moduleOverride));
 463                                 defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;



 464                             } else {
 465                                 // Question: why not do findAllModules and initVisiblePackages here?
 466                                 // i.e. body of unnamedModuleCompleter
 467                                 defaultModule.completer = getUnnamedModuleCompleter();
 468                                 defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 469                                 defaultModule.classLocation = StandardLocation.CLASS_PATH;
 470                             }
 471                         } else {
 472                             checkNoAllModulePath();
 473                             defaultModule.complete();
 474                             // Question: why not do completeModule here?
 475                             defaultModule.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 476                             defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 477                         }
 478                         rootModules.add(defaultModule);
 479                         break;
 480                     case 1:
 481                         checkNoAllModulePath();
 482                         defaultModule = rootModules.iterator().next();
 483                         defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
</pre>
<hr />
<pre>
1137                 ClassSymbol service = (ClassSymbol) st.tsym;
1138                 if (allUses.add(service)) {
1139                     Directive.UsesDirective d = new Directive.UsesDirective(service);
1140                     msym.uses = msym.uses.prepend(d);
1141                     msym.directives = msym.directives.prepend(d);
1142                 } else {
1143                     log.error(tree.pos(), Errors.DuplicateUses(service));
1144                 }
1145             }
1146         }
1147 
1148         private void checkForCorrectness() {
1149             for (Directive.ProvidesDirective provides : msym.provides) {
1150                 JCProvides tree = directiveToTreeMap.get(provides);
1151                 for (ClassSymbol impl : provides.impls) {
1152                     /* The implementation must be defined in the same module as the provides directive
1153                      * (else, error)
1154                      */
1155                     PackageSymbol implementationDefiningPackage = impl.packge();
1156                     if (implementationDefiningPackage.modle != msym) {
<span class="line-modified">1157                         // TODO: should use tree for the implentation name, not the entire provides tree</span>
1158                         // TODO: should improve error message to identify the implementation type
1159                         log.error(tree.pos(), Errors.ServiceImplementationNotInRightModule(implementationDefiningPackage.modle));
1160                     }
1161 
1162                     /* There is no inherent requirement that module that provides a service should actually
1163                      * use it itself. However, it is a pointless declaration if the service package is not
1164                      * exported and there is no uses for the service.
1165                      */
1166                     PackageSymbol interfaceDeclaringPackage = provides.service.packge();
1167                     boolean isInterfaceDeclaredInCurrentModule = interfaceDeclaringPackage.modle == msym;
1168                     boolean isInterfaceExportedFromAReadableModule =
1169                             msym.visiblePackages.get(interfaceDeclaringPackage.fullname) == interfaceDeclaringPackage;
1170                     if (isInterfaceDeclaredInCurrentModule &amp;&amp; !isInterfaceExportedFromAReadableModule) {
1171                         // ok the interface is declared in this module. Let&#39;s check if it&#39;s exported
1172                         boolean warn = true;
1173                         for (ExportsDirective export : msym.exports) {
1174                             if (interfaceDeclaringPackage == export.packge) {
1175                                 warn = false;
1176                                 break;
1177                             }
</pre>
</td>
<td>
<hr />
<pre>
 338                 modules.add(sym);
 339             } else {
 340                 log.error(toplevel.pos(), Errors.TooManyModules);
 341             }
 342 
 343             Env&lt;AttrContext&gt; provisionalEnv = new Env&lt;&gt;(decl, null);
 344 
 345             provisionalEnv.toplevel = toplevel;
 346             typeEnvs.put(sym, provisionalEnv);
 347         } else if (isModuleInfo) {
 348             if (multiModuleMode) {
 349                 JCTree tree = toplevel.defs.isEmpty() ? toplevel : toplevel.defs.head;
 350                 log.error(tree.pos(), Errors.ExpectedModule);
 351             }
 352         }
 353     }
 354 
 355     private void setCompilationUnitModules(List&lt;JCCompilationUnit&gt; trees, Set&lt;ModuleSymbol&gt; rootModules, ClassSymbol c) {
 356         // update the module for each compilation unit
 357         if (multiModuleMode) {
<span class="line-modified"> 358             boolean patchesAutomaticModules = false;</span>
 359             for (JCCompilationUnit tree: trees) {
 360                 if (tree.defs.isEmpty()) {
 361                     tree.modle = syms.unnamedModule;
 362                     continue;
 363                 }
 364 
 365                 JavaFileObject prev = log.useSource(tree.sourcefile);
 366                 try {
 367                     Location msplocn = getModuleLocation(tree);
 368                     Location plocn = fileManager.hasLocation(StandardLocation.PATCH_MODULE_PATH) ?
 369                             fileManager.getLocationForModule(StandardLocation.PATCH_MODULE_PATH,
 370                                                              tree.sourcefile) :
 371                             null;
 372 
 373                     if (plocn != null) {
 374                         Name name = names.fromString(fileManager.inferModuleName(plocn));
 375                         ModuleSymbol msym = moduleFinder.findModule(name);
 376                         tree.modle = msym;
 377                         rootModules.add(msym);
<span class="line-added"> 378                         patchesAutomaticModules |= (msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0;</span>
 379 
 380                         if (msplocn != null) {
 381                             Name mspname = names.fromString(fileManager.inferModuleName(msplocn));
 382                             if (name != mspname) {
 383                                 log.error(tree.pos(), Errors.FilePatchedAndMsp(name, mspname));
 384                             }
 385                         }
 386                     } else if (msplocn != null) {
 387                         if (tree.getModuleDecl() != null) {
 388                             JavaFileObject canonical =
 389                                     fileManager.getJavaFileForInput(msplocn, &quot;module-info&quot;, Kind.SOURCE);
 390                             if (canonical == null || !fileManager.isSameFile(canonical, tree.sourcefile)) {
 391                                 log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 392                             }
 393                         }
 394                         Name name = names.fromString(fileManager.inferModuleName(msplocn));
 395                         ModuleSymbol msym;
 396                         JCModuleDecl decl = tree.getModuleDecl();
 397                         if (decl != null) {
 398                             msym = decl.sym;
</pre>
<hr />
<pre>
 422                             }
 423                         }
 424                         tree.modle = msym;
 425                         rootModules.add(msym);
 426                     } else if (c != null &amp;&amp; c.packge().modle == syms.unnamedModule) {
 427                         tree.modle = syms.unnamedModule;
 428                     } else {
 429                         if (tree.getModuleDecl() != null) {
 430                             log.error(tree.pos(), Errors.ModuleNotFoundOnModuleSourcePath);
 431                         } else {
 432                             log.error(tree.pos(), Errors.NotInModuleOnModuleSourcePath);
 433                         }
 434                         tree.modle = syms.errModule;
 435                     }
 436                 } catch (IOException e) {
 437                     throw new Error(e); // FIXME
 438                 } finally {
 439                     log.useSource(prev);
 440                 }
 441             }
<span class="line-added"> 442             if (!patchesAutomaticModules) {</span>
<span class="line-added"> 443                 checkNoAllModulePath();</span>
<span class="line-added"> 444             }</span>
 445             if (syms.unnamedModule.sourceLocation == null) {
 446                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
 447                 syms.unnamedModule.sourceLocation = StandardLocation.SOURCE_PATH;
 448                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
 449             }
 450             defaultModule = syms.unnamedModule;
 451         } else {
 452             ModuleSymbol module = null;
 453             if (defaultModule == null) {
 454                 String moduleOverride = singleModuleOverride(trees);
 455                 switch (rootModules.size()) {
 456                     case 0:
 457                         try {
 458                             defaultModule = moduleFinder.findSingleModule();
 459                         } catch (CompletionFailure cf) {
 460                             chk.completionError(null, cf);
 461                             defaultModule = syms.unnamedModule;
 462                         }
 463                         if (defaultModule == syms.unnamedModule) {
 464                             if (moduleOverride != null) {

 465                                 defaultModule = moduleFinder.findModule(names.fromString(moduleOverride));
 466                                 defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
<span class="line-added"> 467                                 if ((defaultModule.flags_field &amp; Flags.AUTOMATIC_MODULE) == 0) {</span>
<span class="line-added"> 468                                     checkNoAllModulePath();</span>
<span class="line-added"> 469                                 }</span>
 470                             } else {
 471                                 // Question: why not do findAllModules and initVisiblePackages here?
 472                                 // i.e. body of unnamedModuleCompleter
 473                                 defaultModule.completer = getUnnamedModuleCompleter();
 474                                 defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 475                                 defaultModule.classLocation = StandardLocation.CLASS_PATH;
 476                             }
 477                         } else {
 478                             checkNoAllModulePath();
 479                             defaultModule.complete();
 480                             // Question: why not do completeModule here?
 481                             defaultModule.completer = sym -&gt; completeModule((ModuleSymbol) sym);
 482                             defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
 483                         }
 484                         rootModules.add(defaultModule);
 485                         break;
 486                     case 1:
 487                         checkNoAllModulePath();
 488                         defaultModule = rootModules.iterator().next();
 489                         defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
</pre>
<hr />
<pre>
1143                 ClassSymbol service = (ClassSymbol) st.tsym;
1144                 if (allUses.add(service)) {
1145                     Directive.UsesDirective d = new Directive.UsesDirective(service);
1146                     msym.uses = msym.uses.prepend(d);
1147                     msym.directives = msym.directives.prepend(d);
1148                 } else {
1149                     log.error(tree.pos(), Errors.DuplicateUses(service));
1150                 }
1151             }
1152         }
1153 
1154         private void checkForCorrectness() {
1155             for (Directive.ProvidesDirective provides : msym.provides) {
1156                 JCProvides tree = directiveToTreeMap.get(provides);
1157                 for (ClassSymbol impl : provides.impls) {
1158                     /* The implementation must be defined in the same module as the provides directive
1159                      * (else, error)
1160                      */
1161                     PackageSymbol implementationDefiningPackage = impl.packge();
1162                     if (implementationDefiningPackage.modle != msym) {
<span class="line-modified">1163                         // TODO: should use tree for the implementation name, not the entire provides tree</span>
1164                         // TODO: should improve error message to identify the implementation type
1165                         log.error(tree.pos(), Errors.ServiceImplementationNotInRightModule(implementationDefiningPackage.modle));
1166                     }
1167 
1168                     /* There is no inherent requirement that module that provides a service should actually
1169                      * use it itself. However, it is a pointless declaration if the service package is not
1170                      * exported and there is no uses for the service.
1171                      */
1172                     PackageSymbol interfaceDeclaringPackage = provides.service.packge();
1173                     boolean isInterfaceDeclaredInCurrentModule = interfaceDeclaringPackage.modle == msym;
1174                     boolean isInterfaceExportedFromAReadableModule =
1175                             msym.visiblePackages.get(interfaceDeclaringPackage.fullname) == interfaceDeclaringPackage;
1176                     if (isInterfaceDeclaredInCurrentModule &amp;&amp; !isInterfaceExportedFromAReadableModule) {
1177                         // ok the interface is declared in this module. Let&#39;s check if it&#39;s exported
1178                         boolean warn = true;
1179                         for (ExportsDirective export : msym.exports) {
1180                             if (interfaceDeclaringPackage == export.packge) {
1181                                 warn = false;
1182                                 break;
1183                             }
</pre>
</td>
</tr>
</table>
<center><a href="MemberEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Operators.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.util.ArrayDeque;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.Map;
  33 
  34 import javax.lang.model.type.*;
  35 
  36 import com.sun.tools.javac.code.Symbol.*;
  37 import com.sun.tools.javac.code.TypeMetadata.Entry;
  38 import com.sun.tools.javac.code.Types.TypeMapping;
<a name="1" id="anc1"></a>
  39 import com.sun.tools.javac.comp.Infer.IncorporationAction;
<a name="2" id="anc2"></a>

  40 import com.sun.tools.javac.util.*;
  41 import com.sun.tools.javac.util.DefinedBy.Api;
  42 
  43 import static com.sun.tools.javac.code.BoundKind.*;
  44 import static com.sun.tools.javac.code.Flags.*;
  45 import static com.sun.tools.javac.code.Kinds.Kind.*;
  46 import static com.sun.tools.javac.code.TypeTag.*;
  47 
  48 /** This class represents Java types. The class itself defines the behavior of
  49  *  the following types:
  50  *  &lt;pre&gt;
  51  *  base types (tags: BYTE, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, BOOLEAN),
  52  *  type `void&#39; (tag: VOID),
  53  *  the bottom type (tag: BOT),
  54  *  the missing type (tag: NONE).
  55  *  &lt;/pre&gt;
  56  *  &lt;p&gt;The behavior of the following types is defined in subclasses, which are
  57  *  all static inner classes of this class:
  58  *  &lt;pre&gt;
  59  *  class types (tag: CLASS, class: ClassType),
  60  *  array types (tag: ARRAY, class: ArrayType),
  61  *  method types (tag: METHOD, class: MethodType),
  62  *  package types (tag: PACKAGE, class: PackageType),
  63  *  type variables (tag: TYPEVAR, class: TypeVar),
  64  *  type arguments (tag: WILDCARD, class: WildcardType),
  65  *  generic method types (tag: FORALL, class: ForAll),
  66  *  the error type (tag: ERROR, class: ErrorType).
  67  *  &lt;/pre&gt;
  68  *
  69  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  70  *  If you write code that depends on this, you do so at your own risk.
  71  *  This code and its internal interfaces are subject to change or
  72  *  deletion without notice.&lt;/b&gt;
  73  *
  74  *  @see TypeTag
  75  */
<a name="3" id="anc3"></a><span class="line-modified">  76 public abstract class Type extends AnnoConstruct implements TypeMirror {</span>
  77 
  78     /**
  79      * Type metadata,  Should be {@code null} for the default value.
  80      *
  81      * Note: it is an invariant that for any {@code TypeMetadata}
  82      * class, a given {@code Type} may have at most one metadata array
  83      * entry of that class.
  84      */
  85     protected final TypeMetadata metadata;
  86 
  87     public TypeMetadata getMetadata() {
  88         return metadata;
  89     }
  90 
  91     public Entry getMetadataOfKind(final Entry.Kind kind) {
  92         return metadata != null ? metadata.get(kind) : null;
  93     }
  94 
  95     /** Constant type: no type at all. */
  96     public static final JCNoType noType = new JCNoType() {
  97         @Override @DefinedBy(Api.LANGUAGE_MODEL)
  98         public String toString() {
  99             return &quot;none&quot;;
 100         }
 101     };
 102 
 103     /** Constant type: special type to be used during recovery of deferred expressions. */
 104     public static final JCNoType recoveryType = new JCNoType(){
 105         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 106         public String toString() {
 107             return &quot;recovery&quot;;
 108         }
 109     };
 110 
 111     /** Constant type: special type to be used for marking stuck trees. */
 112     public static final JCNoType stuckType = new JCNoType() {
 113         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 114         public String toString() {
 115             return &quot;stuck&quot;;
 116         }
 117     };
 118 
 119     /** If this switch is turned on, the names of type variables
 120      *  and anonymous classes are printed with hashcodes appended.
 121      */
 122     public static boolean moreInfo = false;
 123 
 124     /** The defining class / interface / package / type variable.
 125      */
 126     public TypeSymbol tsym;
 127 
<a name="4" id="anc4"></a>









 128     /**
 129      * Checks if the current type tag is equal to the given tag.
 130      * @return true if tag is equal to the current type tag.
 131      */
 132     public boolean hasTag(TypeTag tag) {
 133         return tag == getTag();
 134     }
 135 
 136     /**
 137      * Returns the current type tag.
 138      * @return the value of the current type tag.
 139      */
 140     public abstract TypeTag getTag();
 141 
 142     public boolean isNumeric() {
 143         return false;
 144     }
 145 
 146     public boolean isIntegral() {
 147         return false;
 148     }
 149 
 150     public boolean isPrimitive() {
 151         return false;
 152     }
 153 
 154     public boolean isPrimitiveOrVoid() {
 155         return false;
 156     }
 157 
 158     public boolean isReference() {
 159         return false;
 160     }
 161 
 162     public boolean isNullOrReference() {
 163         return false;
 164     }
 165 
 166     public boolean isPartial() {
 167         return false;
 168     }
 169 
 170     /**
 171      * The constant value of this type, null if this type does not
 172      * have a constant value attribute. Only primitive types and
 173      * strings (ClassType) can have a constant value attribute.
 174      * @return the constant value attribute of this type
 175      */
 176     public Object constValue() {
 177         return null;
 178     }
 179 
 180     /** Is this a constant type whose value is false?
 181      */
 182     public boolean isFalse() {
 183         return false;
 184     }
 185 
 186     /** Is this a constant type whose value is true?
 187      */
 188     public boolean isTrue() {
 189         return false;
 190     }
 191 
 192     /**
 193      * Get the representation of this type used for modelling purposes.
 194      * By default, this is itself. For ErrorType, a different value
 195      * may be provided.
 196      */
 197     public Type getModelType() {
 198         return this;
 199     }
 200 
 201     public static List&lt;Type&gt; getModelTypes(List&lt;Type&gt; ts) {
 202         ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 203         for (Type t: ts)
 204             lb.append(t.getModelType());
 205         return lb.toList();
 206     }
 207 
 208     /**For ErrorType, returns the original type, otherwise returns the type itself.
 209      */
 210     public Type getOriginalType() {
 211         return this;
 212     }
 213 
 214     public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) { return v.visitType(this, s); }
 215 
 216     /** Define a type given its tag, type symbol, and type annotations
 217      */
 218 
 219     public Type(TypeSymbol tsym, TypeMetadata metadata) {
 220         Assert.checkNonNull(metadata);
 221         this.tsym = tsym;
 222         this.metadata = metadata;
 223     }
 224 
 225     /**
 226      * A subclass of {@link Types.TypeMapping} which applies a mapping recursively to the subterms
 227      * of a given type expression. This mapping returns the original type is no changes occurred
 228      * when recursively mapping the original type&#39;s subterms.
 229      */
 230     public static abstract class StructuralTypeMapping&lt;S&gt; extends Types.TypeMapping&lt;S&gt; {
 231 
 232         @Override
 233         public Type visitClassType(ClassType t, S s) {
 234             Type outer = t.getEnclosingType();
 235             Type outer1 = visit(outer, s);
 236             List&lt;Type&gt; typarams = t.getTypeArguments();
 237             List&lt;Type&gt; typarams1 = visit(typarams, s);
 238             if (outer1 == outer &amp;&amp; typarams1 == typarams) return t;
 239             else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {
 240                 @Override
 241                 protected boolean needsStripping() {
 242                     return true;
 243                 }
 244             };
 245         }
 246 
 247         @Override
 248         public Type visitWildcardType(WildcardType wt, S s) {
 249             Type t = wt.type;
 250             if (t != null)
 251                 t = visit(t, s);
 252             if (t == wt.type)
 253                 return wt;
 254             else
 255                 return new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.metadata) {
 256                     @Override
 257                     protected boolean needsStripping() {
 258                         return true;
 259                     }
 260                 };
 261         }
 262 
 263         @Override
 264         public Type visitArrayType(ArrayType t, S s) {
 265             Type elemtype = t.elemtype;
 266             Type elemtype1 = visit(elemtype, s);
 267             if (elemtype1 == elemtype) return t;
 268             else return new ArrayType(elemtype1, t.tsym, t.metadata) {
 269                 @Override
 270                 protected boolean needsStripping() {
 271                     return true;
 272                 }
 273             };
 274         }
 275 
 276         @Override
 277         public Type visitMethodType(MethodType t, S s) {
 278             List&lt;Type&gt; argtypes = t.argtypes;
 279             Type restype = t.restype;
 280             List&lt;Type&gt; thrown = t.thrown;
 281             List&lt;Type&gt; argtypes1 = visit(argtypes, s);
 282             Type restype1 = visit(restype, s);
 283             List&lt;Type&gt; thrown1 = visit(thrown, s);
 284             if (argtypes1 == argtypes &amp;&amp;
 285                 restype1 == restype &amp;&amp;
 286                 thrown1 == thrown) return t;
 287             else return new MethodType(argtypes1, restype1, thrown1, t.tsym) {
 288                 @Override
 289                 protected boolean needsStripping() {
 290                     return true;
 291                 }
 292             };
 293         }
 294 
 295         @Override
 296         public Type visitForAll(ForAll t, S s) {
 297             return visit(t.qtype, s);
 298         }
 299     }
 300 
 301     /** map a type function over all immediate descendants of this type
 302      */
 303     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping, Z arg) {
 304         return mapping.visit(this, arg);
 305     }
 306 
 307     /** map a type function over all immediate descendants of this type (no arg version)
 308      */
 309     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping) {
 310         return mapping.visit(this, null);
 311     }
 312 
 313     /** Define a constant type, of the same kind as this type
 314      *  and with given constant value
 315      */
 316     public Type constType(Object constValue) {
 317         throw new AssertionError();
 318     }
 319 
 320     /**
 321      * If this is a constant type, return its underlying type.
 322      * Otherwise, return the type itself.
 323      */
 324     public Type baseType() {
 325         return this;
 326     }
 327 
 328     /**
 329      * Returns the original version of this type, before metadata were added. This routine is meant
 330      * for internal use only (i.e. {@link Type#equalsIgnoreMetadata(Type)}, {@link Type#stripMetadata});
 331      * it should not be used outside this class.
 332      */
 333     protected Type typeNoMetadata() {
 334         return metadata == TypeMetadata.EMPTY ? this : baseType();
 335     }
 336 
 337     /**
 338      * Create a new copy of this type but with the specified TypeMetadata.
 339      */
 340     public abstract Type cloneWithMetadata(TypeMetadata metadata);
 341 
 342     /**
 343      * Does this type require annotation stripping for API clients?
 344      */
 345     protected boolean needsStripping() {
 346         return false;
 347     }
 348 
 349     /**
 350      * Strip all metadata associated with this type - this could return a new clone of the type.
 351      * This routine is only used to present the correct annotated types back to the users when types
 352      * are accessed through compiler APIs; it should not be used anywhere in the compiler internals
 353      * as doing so might result in performance penalties.
 354      */
 355     public Type stripMetadataIfNeeded() {
 356         return needsStripping() ?
 357                 accept(stripMetadata, null) :
 358                 this;
 359     }
 360 
 361     public Type stripMetadata() {
 362         return accept(stripMetadata, null);
 363     }
 364     //where
 365         private final static TypeMapping&lt;Void&gt; stripMetadata = new StructuralTypeMapping&lt;Void&gt;() {
 366             @Override
 367             public Type visitClassType(ClassType t, Void aVoid) {
 368                 return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);
 369             }
 370 
 371             @Override
 372             public Type visitArrayType(ArrayType t, Void aVoid) {
 373                 return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);
 374             }
 375 
 376             @Override
 377             public Type visitTypeVar(TypeVar t, Void aVoid) {
 378                 return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);
 379             }
 380 
 381             @Override
 382             public Type visitWildcardType(WildcardType wt, Void aVoid) {
 383                 return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);
 384             }
 385         };
 386 
 387     public Type annotatedType(final List&lt;Attribute.TypeCompound&gt; annos) {
 388         final Entry annoMetadata = new TypeMetadata.Annotations(annos);
 389         return cloneWithMetadata(metadata.combine(annoMetadata));
 390     }
 391 
 392     public boolean isAnnotated() {
 393         final TypeMetadata.Annotations metadata =
 394             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 395 
 396         return null != metadata &amp;&amp; !metadata.getAnnotations().isEmpty();
 397     }
 398 
 399     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 400     public List&lt;Attribute.TypeCompound&gt; getAnnotationMirrors() {
 401         final TypeMetadata.Annotations metadata =
 402             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 403 
 404         return metadata == null ? List.nil() : metadata.getAnnotations();
 405     }
 406 
 407 
 408     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 409     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) {
 410         return null;
 411     }
 412 
 413 
 414     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 415     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationType) {
 416         @SuppressWarnings(&quot;unchecked&quot;)
 417         A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);
 418         return tmp;
 419     }
 420 
 421     /** Return the base types of a list of types.
 422      */
 423     public static List&lt;Type&gt; baseTypes(List&lt;Type&gt; ts) {
 424         if (ts.nonEmpty()) {
 425             Type t = ts.head.baseType();
 426             List&lt;Type&gt; baseTypes = baseTypes(ts.tail);
 427             if (t != ts.head || baseTypes != ts.tail)
 428                 return baseTypes.prepend(t);
 429         }
 430         return ts;
 431     }
 432 
 433     protected void appendAnnotationsString(StringBuilder sb,
 434                                          boolean prefix) {
 435         if (isAnnotated()) {
 436             if (prefix) {
 437                 sb.append(&quot; &quot;);
 438             }
 439             sb.append(getAnnotationMirrors());
 440             sb.append(&quot; &quot;);
 441         }
 442     }
 443 
 444     protected void appendAnnotationsString(StringBuilder sb) {
 445         appendAnnotationsString(sb, false);
 446     }
 447 
 448     /** The Java source which this type represents.
 449      */
 450     @DefinedBy(Api.LANGUAGE_MODEL)
 451     public String toString() {
 452         StringBuilder sb = new StringBuilder();
 453         appendAnnotationsString(sb);
 454         if (tsym == null || tsym.name == null) {
 455             sb.append(&quot;&lt;none&gt;&quot;);
 456         } else {
 457             sb.append(tsym.name);
 458         }
 459         if (moreInfo &amp;&amp; hasTag(TYPEVAR)) {
 460             sb.append(hashCode());
 461         }
 462         return sb.toString();
 463     }
 464 
 465     /**
 466      * The Java source which this type list represents.  A List is
<a name="5" id="anc5"></a><span class="line-modified"> 467      * represented as a comma-spearated listing of the elements in</span>
 468      * that list.
 469      */
 470     public static String toString(List&lt;Type&gt; ts) {
 471         if (ts.isEmpty()) {
 472             return &quot;&quot;;
 473         } else {
 474             StringBuilder buf = new StringBuilder();
 475             buf.append(ts.head.toString());
 476             for (List&lt;Type&gt; l = ts.tail; l.nonEmpty(); l = l.tail)
 477                 buf.append(&quot;,&quot;).append(l.head.toString());
 478             return buf.toString();
 479         }
 480     }
 481 
 482     /**
 483      * The constant value of this type, converted to String
 484      */
 485     public String stringValue() {
 486         Object cv = Assert.checkNonNull(constValue());
 487         return cv.toString();
 488     }
 489 
 490     /**
 491      * Override this method with care. For most Type instances this should behave as ==.
 492      */
 493     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 494     public boolean equals(Object t) {
 495         return this == t;
 496     }
 497 
 498     public boolean equalsIgnoreMetadata(Type t) {
 499         return typeNoMetadata().equals(t.typeNoMetadata());
 500     }
 501 
 502     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 503     public int hashCode() {
 504         return super.hashCode();
 505     }
 506 
 507     public String argtypes(boolean varargs) {
 508         List&lt;Type&gt; args = getParameterTypes();
 509         if (!varargs) return args.toString();
 510         StringBuilder buf = new StringBuilder();
 511         while (args.tail.nonEmpty()) {
 512             buf.append(args.head);
 513             args = args.tail;
 514             buf.append(&#39;,&#39;);
 515         }
 516         if (args.head.hasTag(ARRAY)) {
 517             buf.append(((ArrayType)args.head).elemtype);
 518             if (args.head.getAnnotationMirrors().nonEmpty()) {
 519                 buf.append(args.head.getAnnotationMirrors());
 520             }
 521             buf.append(&quot;...&quot;);
 522         } else {
 523             buf.append(args.head);
 524         }
 525         return buf.toString();
 526     }
 527 
 528     /** Access methods.
 529      */
 530     public List&lt;Type&gt;        getTypeArguments()  { return List.nil(); }
 531     public Type              getEnclosingType()  { return null; }
 532     public List&lt;Type&gt;        getParameterTypes() { return List.nil(); }
 533     public Type              getReturnType()     { return null; }
 534     public Type              getReceiverType()   { return null; }
 535     public List&lt;Type&gt;        getThrownTypes()    { return List.nil(); }
 536     public Type              getUpperBound()     { return null; }
 537     public Type              getLowerBound()     { return null; }
 538 
 539     /** Navigation methods, these will work for classes, type variables,
 540      *  foralls, but will return null for arrays and methods.
 541      */
 542 
 543    /** Return all parameters of this type and all its outer types in order
 544     *  outer (first) to inner (last).
 545     */
 546     public List&lt;Type&gt; allparams() { return List.nil(); }
 547 
 548     /** Does this type contain &quot;error&quot; elements?
 549      */
 550     public boolean isErroneous() {
 551         return false;
 552     }
 553 
 554     public static boolean isErroneous(List&lt;Type&gt; ts) {
 555         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 556             if (l.head.isErroneous()) return true;
 557         return false;
 558     }
 559 
 560     /** Is this type parameterized?
 561      *  A class type is parameterized if it has some parameters.
 562      *  An array type is parameterized if its element type is parameterized.
 563      *  All other types are not parameterized.
 564      */
 565     public boolean isParameterized() {
 566         return false;
 567     }
 568 
 569     /** Is this type a raw type?
 570      *  A class type is a raw type if it misses some of its parameters.
 571      *  An array type is a raw type if its element type is raw.
 572      *  All other types are not raw.
 573      *  Type validation will ensure that the only raw types
 574      *  in a program are types that miss all their type variables.
 575      */
 576     public boolean isRaw() {
 577         return false;
 578     }
 579 
 580     /**
 581      * A compound type is a special class type whose supertypes are used to store a list
 582      * of component types. There are two kinds of compound types: (i) intersection types
 583      * {@see IntersectionClassType} and (ii) union types {@see UnionClassType}.
 584      */
 585     public boolean isCompound() {
 586         return false;
 587     }
 588 
 589     public boolean isIntersection() {
 590         return false;
 591     }
 592 
 593     public boolean isUnion() {
 594         return false;
 595     }
 596 
 597     public boolean isInterface() {
 598         return (tsym.flags() &amp; INTERFACE) != 0;
 599     }
 600 
 601     public boolean isFinal() {
 602         return (tsym.flags() &amp; FINAL) != 0;
 603     }
 604 
 605     /**
 606      * Does this type contain occurrences of type t?
 607      */
 608     public boolean contains(Type t) {
 609         return t.equalsIgnoreMetadata(this);
 610     }
 611 
 612     public static boolean contains(List&lt;Type&gt; ts, Type t) {
 613         for (List&lt;Type&gt; l = ts;
 614              l.tail != null /*inlined: l.nonEmpty()*/;
 615              l = l.tail)
 616             if (l.head.contains(t)) return true;
 617         return false;
 618     }
 619 
 620     /** Does this type contain an occurrence of some type in &#39;ts&#39;?
 621      */
 622     public boolean containsAny(List&lt;Type&gt; ts) {
 623         for (Type t : ts)
 624             if (this.contains(t)) return true;
 625         return false;
 626     }
 627 
 628     public static boolean containsAny(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
 629         for (Type t : ts1)
 630             if (t.containsAny(ts2)) return true;
 631         return false;
 632     }
 633 
 634     public static List&lt;Type&gt; filter(List&lt;Type&gt; ts, Filter&lt;Type&gt; tf) {
 635         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 636         for (Type t : ts) {
 637             if (tf.accepts(t)) {
 638                 buf.append(t);
 639             }
 640         }
 641         return buf.toList();
 642     }
 643 
 644     public boolean isSuperBound() { return false; }
 645     public boolean isExtendsBound() { return false; }
 646     public boolean isUnbound() { return false; }
 647     public Type withTypeVar(Type t) { return this; }
 648 
 649     /** The underlying method type of this type.
 650      */
 651     public MethodType asMethodType() { throw new AssertionError(); }
 652 
 653     /** Complete loading all classes in this type.
 654      */
 655     public void complete() {}
 656 
 657     public TypeSymbol asElement() {
 658         return tsym;
 659     }
 660 
 661     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 662     public TypeKind getKind() {
 663         return TypeKind.OTHER;
 664     }
 665 
 666     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 667     public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 668         throw new AssertionError();
 669     }
 670 
 671     public static class JCPrimitiveType extends Type
 672             implements javax.lang.model.type.PrimitiveType {
 673 
 674         TypeTag tag;
 675 
 676         public JCPrimitiveType(TypeTag tag, TypeSymbol tsym) {
 677             this(tag, tsym, TypeMetadata.EMPTY);
 678         }
 679 
 680         private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {
 681             super(tsym, metadata);
 682             this.tag = tag;
 683             Assert.check(tag.isPrimitive);
 684         }
 685 
 686         @Override
 687         public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {
 688             return new JCPrimitiveType(tag, tsym, md) {
 689                 @Override
 690                 public Type baseType() { return JCPrimitiveType.this.baseType(); }
 691             };
 692         }
 693 
 694         @Override
 695         public boolean isNumeric() {
 696             return tag != BOOLEAN;
 697         }
 698 
 699         @Override
 700         public boolean isIntegral() {
 701             switch (tag) {
 702                 case CHAR:
 703                 case BYTE:
 704                 case SHORT:
 705                 case INT:
 706                 case LONG:
 707                     return true;
 708                 default:
 709                     return false;
 710             }
 711         }
 712 
 713         @Override
 714         public boolean isPrimitive() {
 715             return true;
 716         }
 717 
 718         @Override
 719         public TypeTag getTag() {
 720             return tag;
 721         }
 722 
 723         @Override
 724         public boolean isPrimitiveOrVoid() {
 725             return true;
 726         }
 727 
 728         /** Define a constant type, of the same kind as this type
 729          *  and with given constant value
 730          */
 731         @Override
 732         public Type constType(Object constValue) {
 733             final Object value = constValue;
 734             return new JCPrimitiveType(tag, tsym, metadata) {
 735                     @Override
 736                     public Object constValue() {
 737                         return value;
 738                     }
 739                     @Override
 740                     public Type baseType() {
 741                         return tsym.type;
 742                     }
 743                 };
 744         }
 745 
 746         /**
 747          * The constant value of this type, converted to String
 748          */
 749         @Override
 750         public String stringValue() {
 751             Object cv = Assert.checkNonNull(constValue());
 752             if (tag == BOOLEAN) {
 753                 return ((Integer) cv).intValue() == 0 ? &quot;false&quot; : &quot;true&quot;;
 754             }
 755             else if (tag == CHAR) {
 756                 return String.valueOf((char) ((Integer) cv).intValue());
 757             }
 758             else {
 759                 return cv.toString();
 760             }
 761         }
 762 
 763         /** Is this a constant type whose value is false?
 764          */
 765         @Override
 766         public boolean isFalse() {
 767             return
 768                 tag == BOOLEAN &amp;&amp;
 769                 constValue() != null &amp;&amp;
 770                 ((Integer)constValue()).intValue() == 0;
 771         }
 772 
 773         /** Is this a constant type whose value is true?
 774          */
 775         @Override
 776         public boolean isTrue() {
 777             return
 778                 tag == BOOLEAN &amp;&amp;
 779                 constValue() != null &amp;&amp;
 780                 ((Integer)constValue()).intValue() != 0;
 781         }
 782 
 783         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 784         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 785             return v.visitPrimitive(this, p);
 786         }
 787 
 788         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 789         public TypeKind getKind() {
 790             switch (tag) {
 791                 case BYTE:      return TypeKind.BYTE;
 792                 case CHAR:      return TypeKind.CHAR;
 793                 case SHORT:     return TypeKind.SHORT;
 794                 case INT:       return TypeKind.INT;
 795                 case LONG:      return TypeKind.LONG;
 796                 case FLOAT:     return TypeKind.FLOAT;
 797                 case DOUBLE:    return TypeKind.DOUBLE;
 798                 case BOOLEAN:   return TypeKind.BOOLEAN;
 799             }
 800             throw new AssertionError();
 801         }
 802 
 803     }
 804 
 805     public static class WildcardType extends Type
 806             implements javax.lang.model.type.WildcardType {
 807 
 808         public Type type;
 809         public BoundKind kind;
 810         public TypeVar bound;
 811 
 812         @Override
 813         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
 814             return v.visitWildcardType(this, s);
 815         }
 816 
 817         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym) {
 818             this(type, kind, tsym, null, TypeMetadata.EMPTY);
 819         }
 820 
 821         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 822                             TypeMetadata metadata) {
 823             this(type, kind, tsym, null, metadata);
 824         }
 825 
 826         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 827                             TypeVar bound) {
 828             this(type, kind, tsym, bound, TypeMetadata.EMPTY);
 829         }
 830 
 831         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 832                             TypeVar bound, TypeMetadata metadata) {
 833             super(tsym, metadata);
 834             this.type = Assert.checkNonNull(type);
 835             this.kind = kind;
 836             this.bound = bound;
 837         }
 838 
 839         @Override
 840         public WildcardType cloneWithMetadata(TypeMetadata md) {
 841             return new WildcardType(type, kind, tsym, bound, md) {
 842                 @Override
 843                 public Type baseType() { return WildcardType.this.baseType(); }
 844             };
 845         }
 846 
 847         @Override
 848         public TypeTag getTag() {
 849             return WILDCARD;
 850         }
 851 
 852         @Override
 853         public boolean contains(Type t) {
 854             return kind != UNBOUND &amp;&amp; type.contains(t);
 855         }
 856 
 857         public boolean isSuperBound() {
 858             return kind == SUPER ||
 859                 kind == UNBOUND;
 860         }
 861         public boolean isExtendsBound() {
 862             return kind == EXTENDS ||
 863                 kind == UNBOUND;
 864         }
 865         public boolean isUnbound() {
 866             return kind == UNBOUND;
 867         }
 868 
 869         @Override
 870         public boolean isReference() {
 871             return true;
 872         }
 873 
 874         @Override
 875         public boolean isNullOrReference() {
 876             return true;
 877         }
 878 
 879         @Override
 880         public Type withTypeVar(Type t) {
 881             //-System.err.println(this+&quot;.withTypeVar(&quot;+t+&quot;);&quot;);//DEBUG
 882             if (bound == t)
 883                 return this;
 884             bound = (TypeVar)t;
 885             return this;
 886         }
 887 
 888         boolean isPrintingBound = false;
 889         @DefinedBy(Api.LANGUAGE_MODEL)
 890         public String toString() {
 891             StringBuilder s = new StringBuilder();
 892             appendAnnotationsString(s);
 893             s.append(kind.toString());
 894             if (kind != UNBOUND)
 895                 s.append(type);
 896             if (moreInfo &amp;&amp; bound != null &amp;&amp; !isPrintingBound)
 897                 try {
 898                     isPrintingBound = true;
 899                     s.append(&quot;{:&quot;).append(bound.getUpperBound()).append(&quot;:}&quot;);
 900                 } finally {
 901                     isPrintingBound = false;
 902                 }
 903             return s.toString();
 904         }
 905 
 906         @DefinedBy(Api.LANGUAGE_MODEL)
 907         public Type getExtendsBound() {
 908             if (kind == EXTENDS)
 909                 return type;
 910             else
 911                 return null;
 912         }
 913 
 914         @DefinedBy(Api.LANGUAGE_MODEL)
 915         public Type getSuperBound() {
 916             if (kind == SUPER)
 917                 return type;
 918             else
 919                 return null;
 920         }
 921 
 922         @DefinedBy(Api.LANGUAGE_MODEL)
 923         public TypeKind getKind() {
 924             return TypeKind.WILDCARD;
 925         }
 926 
 927         @DefinedBy(Api.LANGUAGE_MODEL)
 928         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 929             return v.visitWildcard(this, p);
 930         }
 931     }
 932 
<a name="6" id="anc6"></a><span class="line-modified"> 933     public static class ClassType extends Type implements DeclaredType,</span>
 934                                                           javax.lang.model.type.ErrorType {
 935 
 936         /** The enclosing type of this type. If this is the type of an inner
 937          *  class, outer_field refers to the type of its enclosing
 938          *  instance class, in all other cases it refers to noType.
 939          */
 940         private Type outer_field;
 941 
 942         /** The type parameters of this type (to be set once class is loaded).
 943          */
 944         public List&lt;Type&gt; typarams_field;
 945 
 946         /** A cache variable for the type parameters of this type,
 947          *  appended to all parameters of its enclosing class.
 948          *  @see #allparams
 949          */
 950         public List&lt;Type&gt; allparams_field;
 951 
 952         /** The supertype of this class (to be set once class is loaded).
 953          */
 954         public Type supertype_field;
 955 
 956         /** The interfaces of this class (to be set once class is loaded).
 957          */
 958         public List&lt;Type&gt; interfaces_field;
 959 
 960         /** All the interfaces of this class, including missing ones.
 961          */
 962         public List&lt;Type&gt; all_interfaces_field;
 963 
 964         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym) {
 965             this(outer, typarams, tsym, TypeMetadata.EMPTY);
 966         }
 967 
 968         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym,
 969                          TypeMetadata metadata) {
 970             super(tsym, metadata);
 971             this.outer_field = outer;
 972             this.typarams_field = typarams;
 973             this.allparams_field = null;
 974             this.supertype_field = null;
 975             this.interfaces_field = null;
 976         }
 977 
<a name="7" id="anc7"></a>



 978         @Override
 979         public ClassType cloneWithMetadata(TypeMetadata md) {
 980             return new ClassType(outer_field, typarams_field, tsym, md) {
 981                 @Override
 982                 public Type baseType() { return ClassType.this.baseType(); }
 983             };
 984         }
 985 
 986         @Override
 987         public TypeTag getTag() {
 988             return CLASS;
 989         }
 990 
 991         @Override
 992         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
 993             return v.visitClassType(this, s);
 994         }
 995 
 996         public Type constType(Object constValue) {
 997             final Object value = constValue;
 998             return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {
 999                     @Override
1000                     public Object constValue() {
1001                         return value;
1002                     }
1003                     @Override
1004                     public Type baseType() {
1005                         return tsym.type;
1006                     }
1007                 };
1008         }
1009 
1010         /** The Java source which this type represents.
1011          */
1012         @DefinedBy(Api.LANGUAGE_MODEL)
1013         public String toString() {
1014             StringBuilder buf = new StringBuilder();
1015             if (getEnclosingType().hasTag(CLASS) &amp;&amp; tsym.owner.kind == TYP) {
1016                 buf.append(getEnclosingType().toString());
1017                 buf.append(&quot;.&quot;);
1018                 appendAnnotationsString(buf);
1019                 buf.append(className(tsym, false));
1020             } else {
1021                 appendAnnotationsString(buf);
1022                 buf.append(className(tsym, true));
1023             }
1024 
1025             if (getTypeArguments().nonEmpty()) {
1026                 buf.append(&#39;&lt;&#39;);
1027                 buf.append(getTypeArguments().toString());
1028                 buf.append(&quot;&gt;&quot;);
1029             }
1030             return buf.toString();
1031         }
1032 //where
1033             private String className(Symbol sym, boolean longform) {
1034                 if (sym.name.isEmpty() &amp;&amp; (sym.flags() &amp; COMPOUND) != 0) {
1035                     StringBuilder s = new StringBuilder(supertype_field.toString());
1036                     for (List&lt;Type&gt; is=interfaces_field; is.nonEmpty(); is = is.tail) {
1037                         s.append(&quot;&amp;&quot;);
1038                         s.append(is.head.toString());
1039                     }
1040                     return s.toString();
1041                 } else if (sym.name.isEmpty()) {
1042                     String s;
1043                     ClassType norm = (ClassType) tsym.type;
1044                     if (norm == null) {
1045                         s = Log.getLocalizedString(&quot;anonymous.class&quot;, (Object)null);
1046                     } else if (norm.interfaces_field != null &amp;&amp; norm.interfaces_field.nonEmpty()) {
1047                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1048                                                    norm.interfaces_field.head);
1049                     } else {
1050                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1051                                                    norm.supertype_field);
1052                     }
1053                     if (moreInfo)
1054                         s += String.valueOf(sym.hashCode());
1055                     return s;
1056                 } else if (longform) {
1057                     return sym.getQualifiedName().toString();
1058                 } else {
1059                     return sym.name.toString();
1060                 }
1061             }
1062 
1063         @DefinedBy(Api.LANGUAGE_MODEL)
1064         public List&lt;Type&gt; getTypeArguments() {
1065             if (typarams_field == null) {
1066                 complete();
1067                 if (typarams_field == null)
1068                     typarams_field = List.nil();
1069             }
1070             return typarams_field;
1071         }
1072 
1073         public boolean hasErasedSupertypes() {
1074             return isRaw();
1075         }
1076 
1077         @DefinedBy(Api.LANGUAGE_MODEL)
1078         public Type getEnclosingType() {
1079             return outer_field;
1080         }
1081 
1082         public void setEnclosingType(Type outer) {
1083             outer_field = outer;
1084         }
1085 
1086         public List&lt;Type&gt; allparams() {
1087             if (allparams_field == null) {
1088                 allparams_field = getTypeArguments().prependList(getEnclosingType().allparams());
1089             }
1090             return allparams_field;
1091         }
1092 
1093         public boolean isErroneous() {
1094             return
1095                 getEnclosingType().isErroneous() ||
1096                 isErroneous(getTypeArguments()) ||
1097                 this != tsym.type &amp;&amp; tsym.type.isErroneous();
1098         }
1099 
1100         public boolean isParameterized() {
1101             return allparams().tail != null;
1102             // optimization, was: allparams().nonEmpty();
1103         }
1104 
1105         @Override
1106         public boolean isReference() {
1107             return true;
1108         }
1109 
1110         @Override
1111         public boolean isNullOrReference() {
1112             return true;
1113         }
1114 
1115         /** A cache for the rank. */
1116         int rank_field = -1;
1117 
1118         /** A class type is raw if it misses some
1119          *  of its type parameter sections.
1120          *  After validation, this is equivalent to:
1121          *  {@code allparams.isEmpty() &amp;&amp; tsym.type.allparams.nonEmpty(); }
1122          */
1123         public boolean isRaw() {
1124             return
1125                 this != tsym.type &amp;&amp; // necessary, but not sufficient condition
1126                 tsym.type.allparams().nonEmpty() &amp;&amp;
1127                 allparams().isEmpty();
1128         }
1129 
1130         public boolean contains(Type elem) {
1131             return
1132                 elem.equalsIgnoreMetadata(this)
1133                 || (isParameterized()
1134                     &amp;&amp; (getEnclosingType().contains(elem) || contains(getTypeArguments(), elem)))
1135                 || (isCompound()
1136                     &amp;&amp; (supertype_field.contains(elem) || contains(interfaces_field, elem)));
1137         }
1138 
1139         public void complete() {
1140             tsym.complete();
1141         }
1142 
1143         @DefinedBy(Api.LANGUAGE_MODEL)
1144         public TypeKind getKind() {
1145             tsym.apiComplete();
1146             return tsym.kind == TYP ? TypeKind.DECLARED : TypeKind.ERROR;
1147         }
1148 
1149         @DefinedBy(Api.LANGUAGE_MODEL)
1150         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1151             return v.visitDeclared(this, p);
1152         }
1153     }
1154 
1155     public static class ErasedClassType extends ClassType {
1156         public ErasedClassType(Type outer, TypeSymbol tsym,
1157                                TypeMetadata metadata) {
1158             super(outer, List.nil(), tsym, metadata);
1159         }
1160 
1161         @Override
1162         public boolean hasErasedSupertypes() {
1163             return true;
1164         }
1165     }
1166 
1167     // a clone of a ClassType that knows about the alternatives of a union type.
1168     public static class UnionClassType extends ClassType implements UnionType {
1169         final List&lt;? extends Type&gt; alternatives_field;
1170 
1171         public UnionClassType(ClassType ct, List&lt;? extends Type&gt; alternatives) {
1172             // Presently no way to refer to this type directly, so we
1173             // cannot put annotations directly on it.
1174             super(ct.outer_field, ct.typarams_field, ct.tsym);
1175             allparams_field = ct.allparams_field;
1176             supertype_field = ct.supertype_field;
1177             interfaces_field = ct.interfaces_field;
1178             all_interfaces_field = ct.interfaces_field;
1179             alternatives_field = alternatives;
1180         }
1181 
1182         @Override
1183         public UnionClassType cloneWithMetadata(TypeMetadata md) {
1184             throw new AssertionError(&quot;Cannot add metadata to a union type&quot;);
1185         }
1186 
1187         public Type getLub() {
1188             return tsym.type;
1189         }
1190 
1191         @DefinedBy(Api.LANGUAGE_MODEL)
1192         public java.util.List&lt;? extends TypeMirror&gt; getAlternatives() {
1193             return Collections.unmodifiableList(alternatives_field);
1194         }
1195 
1196         @Override
1197         public boolean isUnion() {
1198             return true;
1199         }
1200 
1201         @Override
1202         public boolean isCompound() {
1203             return getLub().isCompound();
1204         }
1205 
1206         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1207         public TypeKind getKind() {
1208             return TypeKind.UNION;
1209         }
1210 
1211         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1212         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1213             return v.visitUnion(this, p);
1214         }
1215 
1216         public Iterable&lt;? extends Type&gt; getAlternativeTypes() {
1217             return alternatives_field;
1218         }
1219     }
1220 
1221     // a clone of a ClassType that knows about the bounds of an intersection type.
1222     public static class IntersectionClassType extends ClassType implements IntersectionType {
1223 
1224         public boolean allInterfaces;
1225 
1226         public IntersectionClassType(List&lt;Type&gt; bounds, ClassSymbol csym, boolean allInterfaces) {
1227             // Presently no way to refer to this type directly, so we
1228             // cannot put annotations directly on it.
1229             super(Type.noType, List.nil(), csym);
1230             this.allInterfaces = allInterfaces;
1231             Assert.check((csym.flags() &amp; COMPOUND) != 0);
1232             supertype_field = bounds.head;
1233             interfaces_field = bounds.tail;
1234             Assert.check(!supertype_field.tsym.isCompleted() ||
1235                     !supertype_field.isInterface(), supertype_field);
1236         }
1237 
1238         @Override
1239         public IntersectionClassType cloneWithMetadata(TypeMetadata md) {
1240             throw new AssertionError(&quot;Cannot add metadata to an intersection type&quot;);
1241         }
1242 
1243         @DefinedBy(Api.LANGUAGE_MODEL)
1244         public java.util.List&lt;? extends TypeMirror&gt; getBounds() {
1245             return Collections.unmodifiableList(getExplicitComponents());
1246         }
1247 
1248         @Override
1249         public boolean isCompound() {
1250             return true;
1251         }
1252 
1253         public List&lt;Type&gt; getComponents() {
1254             return interfaces_field.prepend(supertype_field);
1255         }
1256 
1257         @Override
1258         public boolean isIntersection() {
1259             return true;
1260         }
1261 
1262         public List&lt;Type&gt; getExplicitComponents() {
1263             return allInterfaces ?
1264                     interfaces_field :
1265                     getComponents();
1266         }
1267 
1268         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1269         public TypeKind getKind() {
1270             return TypeKind.INTERSECTION;
1271         }
1272 
1273         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1274         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1275             return v.visitIntersection(this, p);
1276         }
1277     }
1278 
1279     public static class ArrayType extends Type
<a name="8" id="anc8"></a><span class="line-modified">1280             implements javax.lang.model.type.ArrayType {</span>
1281 
1282         public Type elemtype;
1283 
1284         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
1285             this(elemtype, arrayClass, TypeMetadata.EMPTY);
1286         }
1287 
1288         public ArrayType(Type elemtype, TypeSymbol arrayClass,
1289                          TypeMetadata metadata) {
1290             super(arrayClass, metadata);
1291             this.elemtype = elemtype;
1292         }
1293 
1294         public ArrayType(ArrayType that) {
1295             //note: type metadata is deliberately shared here, as we want side-effects from annotation
1296             //processing to flow from original array to the cloned array.
1297             this(that.elemtype, that.tsym, that.getMetadata());
1298         }
1299 
<a name="9" id="anc9"></a>



1300         @Override
1301         public ArrayType cloneWithMetadata(TypeMetadata md) {
1302             return new ArrayType(elemtype, tsym, md) {
1303                 @Override
1304                 public Type baseType() { return ArrayType.this.baseType(); }
1305             };
1306         }
1307 
1308         @Override
1309         public TypeTag getTag() {
1310             return ARRAY;
1311         }
1312 
1313         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1314             return v.visitArrayType(this, s);
1315         }
1316 
1317         @DefinedBy(Api.LANGUAGE_MODEL)
1318         public String toString() {
1319             StringBuilder sb = new StringBuilder();
1320 
1321             // First append root component type
1322             Type t = elemtype;
1323             while (t.getKind() == TypeKind.ARRAY)
1324                 t = ((ArrayType) t).getComponentType();
1325             sb.append(t);
1326 
1327             // then append @Anno[] @Anno[] ... @Anno[]
1328             t = this;
1329             do {
1330                 t.appendAnnotationsString(sb, true);
1331                 sb.append(&quot;[]&quot;);
1332                 t = ((ArrayType) t).getComponentType();
1333             } while (t.getKind() == TypeKind.ARRAY);
1334 
1335             return sb.toString();
1336         }
1337 
1338         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1339         public boolean equals(Object obj) {
1340             if (obj instanceof ArrayType) {
1341                 ArrayType that = (ArrayType)obj;
1342                 return this == that ||
1343                         elemtype.equals(that.elemtype);
1344             }
1345 
1346             return false;
1347         }
1348 
1349         @DefinedBy(Api.LANGUAGE_MODEL)
1350         public int hashCode() {
1351             return (ARRAY.ordinal() &lt;&lt; 5) + elemtype.hashCode();
1352         }
1353 
1354         public boolean isVarargs() {
1355             return false;
1356         }
1357 
1358         public List&lt;Type&gt; allparams() { return elemtype.allparams(); }
1359 
1360         public boolean isErroneous() {
1361             return elemtype.isErroneous();
1362         }
1363 
1364         public boolean isParameterized() {
1365             return elemtype.isParameterized();
1366         }
1367 
1368         @Override
1369         public boolean isReference() {
1370             return true;
1371         }
1372 
1373         @Override
1374         public boolean isNullOrReference() {
1375             return true;
1376         }
1377 
1378         public boolean isRaw() {
1379             return elemtype.isRaw();
1380         }
1381 
1382         public ArrayType makeVarargs() {
1383             return new ArrayType(elemtype, tsym, metadata) {
1384                 @Override
1385                 public boolean isVarargs() {
1386                     return true;
1387                 }
1388             };
1389         }
1390 
1391         public boolean contains(Type elem) {
1392             return elem.equalsIgnoreMetadata(this) || elemtype.contains(elem);
1393         }
1394 
1395         public void complete() {
1396             elemtype.complete();
1397         }
1398 
1399         @DefinedBy(Api.LANGUAGE_MODEL)
1400         public Type getComponentType() {
1401             return elemtype;
1402         }
1403 
1404         @DefinedBy(Api.LANGUAGE_MODEL)
1405         public TypeKind getKind() {
1406             return TypeKind.ARRAY;
1407         }
1408 
1409         @DefinedBy(Api.LANGUAGE_MODEL)
1410         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1411             return v.visitArray(this, p);
1412         }
1413     }
1414 
<a name="10" id="anc10"></a><span class="line-modified">1415     public static class MethodType extends Type implements ExecutableType {</span>
1416 
1417         public List&lt;Type&gt; argtypes;
1418         public Type restype;
1419         public List&lt;Type&gt; thrown;
1420 
1421         /** The type annotations on the method receiver.
1422          */
1423         public Type recvtype;
1424 
1425         public MethodType(List&lt;Type&gt; argtypes,
1426                           Type restype,
1427                           List&lt;Type&gt; thrown,
1428                           TypeSymbol methodClass) {
1429             // Presently no way to refer to a method type directly, so
1430             // we cannot put type annotations on it.
1431             super(methodClass, TypeMetadata.EMPTY);
1432             this.argtypes = argtypes;
1433             this.restype = restype;
1434             this.thrown = thrown;
1435         }
1436 
1437         @Override
1438         public MethodType cloneWithMetadata(TypeMetadata md) {
1439             throw new AssertionError(&quot;Cannot add metadata to a method type&quot;);
1440         }
1441 
1442         @Override
1443         public TypeTag getTag() {
1444             return METHOD;
1445         }
1446 
1447         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1448             return v.visitMethodType(this, s);
1449         }
1450 
1451         /** The Java source which this type represents.
1452          *
1453          *  XXX 06/09/99 iris This isn&#39;t correct Java syntax, but it probably
1454          *  should be.
1455          */
1456         @DefinedBy(Api.LANGUAGE_MODEL)
1457         public String toString() {
1458             StringBuilder sb = new StringBuilder();
1459             appendAnnotationsString(sb);
1460             sb.append(&#39;(&#39;);
1461             sb.append(argtypes);
1462             sb.append(&#39;)&#39;);
1463             sb.append(restype);
1464             return sb.toString();
1465         }
1466 
1467         @DefinedBy(Api.LANGUAGE_MODEL)
1468         public List&lt;Type&gt;        getParameterTypes() { return argtypes; }
1469         @DefinedBy(Api.LANGUAGE_MODEL)
1470         public Type              getReturnType()     { return restype; }
1471         @DefinedBy(Api.LANGUAGE_MODEL)
1472         public Type              getReceiverType()   { return recvtype; }
1473         @DefinedBy(Api.LANGUAGE_MODEL)
1474         public List&lt;Type&gt;        getThrownTypes()    { return thrown; }
1475 
1476         public boolean isErroneous() {
1477             return
1478                 isErroneous(argtypes) ||
1479                 restype != null &amp;&amp; restype.isErroneous();
1480         }
1481 
<a name="11" id="anc11"></a>




1482         public boolean contains(Type elem) {
1483             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
1484         }
1485 
1486         public MethodType asMethodType() { return this; }
1487 
1488         public void complete() {
1489             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1490                 l.head.complete();
1491             restype.complete();
1492             recvtype.complete();
1493             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1494                 l.head.complete();
1495         }
1496 
1497         @DefinedBy(Api.LANGUAGE_MODEL)
1498         public List&lt;TypeVar&gt; getTypeVariables() {
1499             return List.nil();
1500         }
1501 
1502         public TypeSymbol asElement() {
1503             return null;
1504         }
1505 
1506         @DefinedBy(Api.LANGUAGE_MODEL)
1507         public TypeKind getKind() {
1508             return TypeKind.EXECUTABLE;
1509         }
1510 
1511         @DefinedBy(Api.LANGUAGE_MODEL)
1512         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1513             return v.visitExecutable(this, p);
1514         }
1515     }
1516 
1517     public static class PackageType extends Type implements NoType {
1518 
1519         PackageType(PackageSymbol tsym) {
1520             // Package types cannot be annotated
1521             super(tsym, TypeMetadata.EMPTY);
1522         }
1523 
1524         @Override
1525         public PackageType cloneWithMetadata(TypeMetadata md) {
1526             throw new AssertionError(&quot;Cannot add metadata to a package type&quot;);
1527         }
1528 
1529         @Override
1530         public TypeTag getTag() {
1531             return PACKAGE;
1532         }
1533 
1534         @Override
1535         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1536             return v.visitPackageType(this, s);
1537         }
1538 
1539         @DefinedBy(Api.LANGUAGE_MODEL)
1540         public String toString() {
1541             return tsym.getQualifiedName().toString();
1542         }
1543 
1544         @DefinedBy(Api.LANGUAGE_MODEL)
1545         public TypeKind getKind() {
1546             return TypeKind.PACKAGE;
1547         }
1548 
1549         @DefinedBy(Api.LANGUAGE_MODEL)
1550         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1551             return v.visitNoType(this, p);
1552         }
1553     }
1554 
1555     public static class ModuleType extends Type implements NoType {
1556 
1557         ModuleType(ModuleSymbol tsym) {
1558             // Module types cannot be annotated
1559             super(tsym, TypeMetadata.EMPTY);
1560         }
1561 
1562         @Override
1563         public ModuleType cloneWithMetadata(TypeMetadata md) {
1564             throw new AssertionError(&quot;Cannot add metadata to a module type&quot;);
1565         }
1566 
1567         @Override
1568         public ModuleType annotatedType(List&lt;Attribute.TypeCompound&gt; annos) {
1569             throw new AssertionError(&quot;Cannot annotate a module type&quot;);
1570         }
1571 
1572         @Override
1573         public TypeTag getTag() {
1574             return TypeTag.MODULE;
1575         }
1576 
1577         @Override
1578         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1579             return v.visitModuleType(this, s);
1580         }
1581 
1582         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1583         public String toString() {
1584             return tsym.getQualifiedName().toString();
1585         }
1586 
1587         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1588         public TypeKind getKind() {
1589             return TypeKind.MODULE;
1590         }
1591 
1592         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1593         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1594             return v.visitNoType(this, p);
1595         }
1596     }
1597 
1598     public static class TypeVar extends Type implements TypeVariable {
1599 
1600         /** The upper bound of this type variable; set from outside.
1601          *  Must be nonempty once it is set.
1602          *  For a bound, `bound&#39; is the bound type itself.
1603          *  Multiple bounds are expressed as a single class type which has the
1604          *  individual bounds as superclass, respectively interfaces.
1605          *  The class type then has as `tsym&#39; a compiler generated class `c&#39;,
1606          *  which has a flag COMPOUND and whose owner is the type variable
1607          *  itself. Furthermore, the erasure_field of the class
1608          *  points to the first class or interface bound.
1609          */
1610         private Type _bound = null;
1611 
1612         /** The lower bound of this type variable.
1613          *  TypeVars don&#39;t normally have a lower bound, so it is normally set
1614          *  to syms.botType.
1615          *  Subtypes, such as CapturedType, may provide a different value.
1616          */
1617         public Type lower;
1618 
1619         public TypeVar(Name name, Symbol owner, Type lower) {
1620             super(null, TypeMetadata.EMPTY);
1621             Assert.checkNonNull(lower);
1622             tsym = new TypeVariableSymbol(0, name, this, owner);
1623             this.setUpperBound(null);
1624             this.lower = lower;
1625         }
1626 
1627         public TypeVar(TypeSymbol tsym, Type bound, Type lower) {
1628             this(tsym, bound, lower, TypeMetadata.EMPTY);
1629         }
1630 
1631         public TypeVar(TypeSymbol tsym, Type bound, Type lower,
1632                        TypeMetadata metadata) {
1633             super(tsym, metadata);
1634             Assert.checkNonNull(lower);
1635             this.setUpperBound(bound);
1636             this.lower = lower;
1637         }
1638 
1639         @Override
1640         public TypeVar cloneWithMetadata(TypeMetadata md) {
1641             return new TypeVar(tsym, getUpperBound(), lower, md) {
1642                 @Override
1643                 public Type baseType() { return TypeVar.this.baseType(); }
1644 
1645                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1646                 public Type getUpperBound() { return TypeVar.this.getUpperBound(); }
1647 
1648                 public void setUpperBound(Type bound) { TypeVar.this.setUpperBound(bound); }
1649             };
1650         }
1651 
1652         @Override
1653         public TypeTag getTag() {
1654             return TYPEVAR;
1655         }
1656 
1657         @Override
1658         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1659             return v.visitTypeVar(this, s);
1660         }
1661 
1662         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1663         public Type getUpperBound() { return _bound; }
1664 
1665         public void setUpperBound(Type bound) { this._bound = bound; }
1666 
1667         int rank_field = -1;
1668 
1669         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1670         public Type getLowerBound() {
1671             return lower;
1672         }
1673 
1674         @DefinedBy(Api.LANGUAGE_MODEL)
1675         public TypeKind getKind() {
1676             return TypeKind.TYPEVAR;
1677         }
1678 
1679         public boolean isCaptured() {
1680             return false;
1681         }
1682 
1683         @Override
1684         public boolean isReference() {
1685             return true;
1686         }
1687 
1688         @Override
1689         public boolean isNullOrReference() {
1690             return true;
1691         }
1692 
1693         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1694         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1695             return v.visitTypeVariable(this, p);
1696         }
1697     }
1698 
1699     /** A captured type variable comes from wildcards which can have
1700      *  both upper and lower bound.  CapturedType extends TypeVar with
1701      *  a lower bound.
1702      */
1703     public static class CapturedType extends TypeVar {
1704 
1705         public WildcardType wildcard;
1706 
1707         public CapturedType(Name name,
1708                             Symbol owner,
1709                             Type upper,
1710                             Type lower,
1711                             WildcardType wildcard) {
1712             super(name, owner, lower);
1713             this.lower = Assert.checkNonNull(lower);
1714             this.setUpperBound(upper);
1715             this.wildcard = wildcard;
1716         }
1717 
1718         public CapturedType(TypeSymbol tsym,
1719                             Type bound,
1720                             Type upper,
1721                             Type lower,
1722                             WildcardType wildcard,
1723                             TypeMetadata metadata) {
1724             super(tsym, bound, lower, metadata);
1725             this.wildcard = wildcard;
1726         }
1727 
1728         @Override
1729         public CapturedType cloneWithMetadata(TypeMetadata md) {
1730             return new CapturedType(tsym, getUpperBound(), getUpperBound(), lower, wildcard, md) {
1731                 @Override
1732                 public Type baseType() { return CapturedType.this.baseType(); }
1733 
1734                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1735                 public Type getUpperBound() { return CapturedType.this.getUpperBound(); }
1736 
1737                 public void setUpperBound(Type bound) { CapturedType.this.setUpperBound(bound); }
1738             };
1739         }
1740 
1741         @Override
1742         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1743             return v.visitCapturedType(this, s);
1744         }
1745 
1746         @Override
1747         public boolean isCaptured() {
1748             return true;
1749         }
1750 
1751         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1752         public String toString() {
1753             StringBuilder sb = new StringBuilder();
1754             appendAnnotationsString(sb);
1755             sb.append(&quot;capture#&quot;);
1756             sb.append((hashCode() &amp; 0xFFFFFFFFL) % Printer.PRIME);
1757             sb.append(&quot; of &quot;);
1758             sb.append(wildcard);
1759             return sb.toString();
1760         }
1761     }
1762 
1763     public static abstract class DelegatedType extends Type {
1764         public Type qtype;
1765         public TypeTag tag;
1766 
1767         public DelegatedType(TypeTag tag, Type qtype) {
1768             this(tag, qtype, TypeMetadata.EMPTY);
1769         }
1770 
1771         public DelegatedType(TypeTag tag, Type qtype,
1772                              TypeMetadata metadata) {
1773             super(qtype.tsym, metadata);
1774             this.tag = tag;
1775             this.qtype = qtype;
1776         }
1777 
1778         public TypeTag getTag() { return tag; }
1779         @DefinedBy(Api.LANGUAGE_MODEL)
1780         public String toString() { return qtype.toString(); }
1781         public List&lt;Type&gt; getTypeArguments() { return qtype.getTypeArguments(); }
1782         public Type getEnclosingType() { return qtype.getEnclosingType(); }
1783         public List&lt;Type&gt; getParameterTypes() { return qtype.getParameterTypes(); }
1784         public Type getReturnType() { return qtype.getReturnType(); }
1785         public Type getReceiverType() { return qtype.getReceiverType(); }
1786         public List&lt;Type&gt; getThrownTypes() { return qtype.getThrownTypes(); }
1787         public List&lt;Type&gt; allparams() { return qtype.allparams(); }
1788         public Type getUpperBound() { return qtype.getUpperBound(); }
1789         public boolean isErroneous() { return qtype.isErroneous(); }
1790     }
1791 
1792     /**
1793      * The type of a generic method type. It consists of a method type and
1794      * a list of method type-parameters that are used within the method
1795      * type.
1796      */
1797     public static class ForAll extends DelegatedType implements ExecutableType {
1798         public List&lt;Type&gt; tvars;
1799 
1800         public ForAll(List&lt;Type&gt; tvars, Type qtype) {
1801             super(FORALL, (MethodType)qtype);
1802             this.tvars = tvars;
1803         }
1804 
1805         @Override
1806         public ForAll cloneWithMetadata(TypeMetadata md) {
1807             throw new AssertionError(&quot;Cannot add metadata to a forall type&quot;);
1808         }
1809 
1810         @Override
1811         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1812             return v.visitForAll(this, s);
1813         }
1814 
1815         @DefinedBy(Api.LANGUAGE_MODEL)
1816         public String toString() {
1817             StringBuilder sb = new StringBuilder();
1818             appendAnnotationsString(sb);
1819             sb.append(&#39;&lt;&#39;);
1820             sb.append(tvars);
1821             sb.append(&#39;&gt;&#39;);
1822             sb.append(qtype);
1823             return sb.toString();
1824         }
1825 
1826         public List&lt;Type&gt; getTypeArguments()   { return tvars; }
1827 
1828         public boolean isErroneous()  {
1829             return qtype.isErroneous();
1830         }
1831 
1832         public boolean contains(Type elem) {
1833             return qtype.contains(elem);
1834         }
1835 
1836         public MethodType asMethodType() {
1837             return (MethodType)qtype;
1838         }
1839 
1840         public void complete() {
1841             for (List&lt;Type&gt; l = tvars; l.nonEmpty(); l = l.tail) {
1842                 ((TypeVar)l.head).getUpperBound().complete();
1843             }
1844             qtype.complete();
1845         }
1846 
1847         @DefinedBy(Api.LANGUAGE_MODEL)
1848         public List&lt;TypeVar&gt; getTypeVariables() {
1849             return List.convert(TypeVar.class, getTypeArguments());
1850         }
1851 
1852         @DefinedBy(Api.LANGUAGE_MODEL)
1853         public TypeKind getKind() {
1854             return TypeKind.EXECUTABLE;
1855         }
1856 
1857         @DefinedBy(Api.LANGUAGE_MODEL)
1858         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1859             return v.visitExecutable(this, p);
1860         }
1861     }
1862 
1863     /** A class for inference variables, for use during method/diamond type
1864      *  inference. An inference variable has upper/lower bounds and a set
1865      *  of equality constraints. Such bounds are set during subtyping, type-containment,
1866      *  type-equality checks, when the types being tested contain inference variables.
1867      *  A change listener can be attached to an inference variable, to receive notifications
1868      *  whenever the bounds of an inference variable change.
1869      */
1870     public static class UndetVar extends DelegatedType {
1871 
1872         enum Kind {
1873             NORMAL,
1874             CAPTURED,
1875             THROWS;
1876         }
1877 
1878         /** Inference variable change listener. The listener method is called
1879          *  whenever a change to the inference variable&#39;s bounds occurs
1880          */
1881         public interface UndetVarListener {
1882             /** called when some inference variable bounds (of given kinds ibs) change */
1883             void varBoundChanged(UndetVar uv, InferenceBound ib, Type bound, boolean update);
1884             /** called when the inferred type is set on some inference variable */
1885             default void varInstantiated(UndetVar uv) { Assert.error(); }
1886         }
1887 
1888         /**
1889          * Inference variable bound kinds
1890          */
1891         public enum InferenceBound {
1892             /** lower bounds */
1893             LOWER {
1894                 public InferenceBound complement() { return UPPER; }
1895             },
1896             /** equality constraints */
1897             EQ {
1898                 public InferenceBound complement() { return EQ; }
1899             },
1900             /** upper bounds */
1901             UPPER {
1902                 public InferenceBound complement() { return LOWER; }
1903             };
1904 
1905             public abstract InferenceBound complement();
1906 
1907             public boolean lessThan(InferenceBound that) {
1908                 if (that == this) {
1909                     return false;
1910                 } else {
1911                     switch (that) {
1912                         case UPPER: return true;
1913                         case LOWER: return false;
1914                         case EQ: return (this != UPPER);
1915                         default:
1916                             Assert.error(&quot;Cannot get here!&quot;);
1917                             return false;
1918                     }
1919                 }
1920             }
1921         }
1922 
1923         /** list of incorporation actions (used by the incorporation engine). */
1924         public ArrayDeque&lt;IncorporationAction&gt; incorporationActions = new ArrayDeque&lt;&gt;();
1925 
1926         /** inference variable bounds */
1927         protected Map&lt;InferenceBound, List&lt;Type&gt;&gt; bounds;
1928 
1929         /** inference variable&#39;s inferred type (set from Infer.java) */
1930         private Type inst = null;
1931 
1932         /** number of declared (upper) bounds */
1933         public int declaredCount;
1934 
1935         /** inference variable&#39;s change listener */
1936         public UndetVarListener listener = null;
1937 
1938         Kind kind;
1939 
1940         @Override
1941         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1942             return v.visitUndetVar(this, s);
1943         }
1944 
1945         public UndetVar(TypeVar origin, UndetVarListener listener, Types types) {
1946             // This is a synthesized internal type, so we cannot annotate it.
1947             super(UNDETVAR, origin);
1948             this.kind = origin.isCaptured() ?
1949                     Kind.CAPTURED :
1950                     Kind.NORMAL;
1951             this.listener = listener;
1952             bounds = new EnumMap&lt;&gt;(InferenceBound.class);
1953             List&lt;Type&gt; declaredBounds = types.getBounds(origin);
1954             declaredCount = declaredBounds.length();
1955             bounds.put(InferenceBound.UPPER, List.nil());
1956             bounds.put(InferenceBound.LOWER, List.nil());
1957             bounds.put(InferenceBound.EQ, List.nil());
1958             for (Type t : declaredBounds.reverse()) {
1959                 //add bound works in reverse order
1960                 addBound(InferenceBound.UPPER, t, types, true);
1961             }
1962             if (origin.isCaptured() &amp;&amp; !origin.lower.hasTag(BOT)) {
1963                 //add lower bound if needed
1964                 addBound(InferenceBound.LOWER, origin.lower, types, true);
1965             }
1966         }
1967 
1968         @DefinedBy(Api.LANGUAGE_MODEL)
1969         public String toString() {
1970             StringBuilder sb = new StringBuilder();
1971             appendAnnotationsString(sb);
1972             if (inst == null) {
1973                 sb.append(qtype);
1974                 sb.append(&#39;?&#39;);
1975             } else {
1976                 sb.append(inst);
1977             }
1978             return sb.toString();
1979         }
1980 
1981         public String debugString() {
1982             String result = &quot;inference var = &quot; + qtype + &quot;\n&quot;;
1983             if (inst != null) {
1984                 result += &quot;inst = &quot; + inst + &#39;\n&#39;;
1985             }
1986             for (InferenceBound bound: InferenceBound.values()) {
1987                 List&lt;Type&gt; aboundList = bounds.get(bound);
1988                 if (aboundList != null &amp;&amp; aboundList.size() &gt; 0) {
1989                     result += bound + &quot; = &quot; + aboundList + &#39;\n&#39;;
1990                 }
1991             }
1992             return result;
1993         }
1994 
1995         public void setThrow() {
1996             if (this.kind == Kind.CAPTURED) {
1997                 //invalid state transition
1998                 throw new IllegalStateException();
1999             }
2000             this.kind = Kind.THROWS;
2001         }
2002 
2003         /**
2004          * Returns a new copy of this undet var.
2005          */
2006         public UndetVar dup(Types types) {
2007             UndetVar uv2 = new UndetVar((TypeVar)qtype, listener, types);
2008             dupTo(uv2, types);
2009             return uv2;
2010         }
2011 
2012         /**
2013          * Dumps the contents of this undet var on another undet var.
2014          */
2015         public void dupTo(UndetVar uv2, Types types) {
2016             uv2.listener = null;
2017             uv2.bounds.clear();
2018             for (InferenceBound ib : InferenceBound.values()) {
2019                 uv2.bounds.put(ib, List.nil());
2020                 for (Type t : getBounds(ib)) {
2021                     uv2.addBound(ib, t, types, true);
2022                 }
2023             }
2024             uv2.inst = inst;
2025             uv2.listener = listener;
2026             uv2.incorporationActions = new ArrayDeque&lt;&gt;();
2027             for (IncorporationAction action : incorporationActions) {
2028                 uv2.incorporationActions.add(action.dup(uv2));
2029             }
2030             uv2.kind = kind;
2031         }
2032 
2033         @Override
2034         public UndetVar cloneWithMetadata(TypeMetadata md) {
2035             throw new AssertionError(&quot;Cannot add metadata to an UndetVar type&quot;);
2036         }
2037 
2038         @Override
2039         public boolean isPartial() {
2040             return true;
2041         }
2042 
2043         @Override
2044         public Type baseType() {
2045             return (inst == null) ? this : inst.baseType();
2046         }
2047 
2048         public Type getInst() {
2049             return inst;
2050         }
2051 
2052         public void setInst(Type inst) {
2053             this.inst = inst;
2054             if (listener != null) {
2055                 listener.varInstantiated(this);
2056             }
2057         }
2058 
2059         /** get all bounds of a given kind */
2060         public List&lt;Type&gt; getBounds(InferenceBound... ibs) {
2061             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2062             for (InferenceBound ib : ibs) {
2063                 buf.appendList(bounds.get(ib));
2064             }
2065             return buf.toList();
2066         }
2067 
2068         /** get the list of declared (upper) bounds */
2069         public List&lt;Type&gt; getDeclaredBounds() {
2070             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2071             int count = 0;
2072             for (Type b : getBounds(InferenceBound.UPPER)) {
2073                 if (count++ == declaredCount) break;
2074                 buf.append(b);
2075             }
2076             return buf.toList();
2077         }
2078 
2079         /** internal method used to override an undetvar bounds */
2080         public void setBounds(InferenceBound ib, List&lt;Type&gt; newBounds) {
2081             bounds.put(ib, newBounds);
2082         }
2083 
2084         /** add a bound of a given kind - this might trigger listener notification */
2085         public final void addBound(InferenceBound ib, Type bound, Types types) {
2086             // Per JDK-8075793: in pre-8 sources, follow legacy javac behavior
2087             // when capture variables are inferred as bounds: for lower bounds,
2088             // map to the capture variable&#39;s upper bound; for upper bounds,
2089             // if the capture variable has a lower bound, map to that type
2090             if (types.mapCapturesToBounds) {
2091                 switch (ib) {
2092                     case LOWER:
2093                         bound = types.cvarUpperBound(bound);
2094                         break;
2095                     case UPPER:
2096                         Type altBound = types.cvarLowerBound(bound);
2097                         if (!altBound.hasTag(TypeTag.BOT)) bound = altBound;
2098                         break;
2099                 }
2100             }
2101             addBound(ib, bound, types, false);
2102         }
2103 
2104         @SuppressWarnings(&quot;fallthrough&quot;)
2105         private void addBound(InferenceBound ib, Type bound, Types types, boolean update) {
2106             if (kind == Kind.CAPTURED &amp;&amp; !update) {
2107                 //Captured inference variables bounds must not be updated during incorporation,
2108                 //except when some inference variable (beta) has been instantiated in the
2109                 //right-hand-side of a &#39;C&lt;alpha&gt; = capture(C&lt;? extends/super beta&gt;) constraint.
2110                 if (bound.hasTag(UNDETVAR) &amp;&amp; !((UndetVar)bound).isCaptured()) {
2111                     //If the new incoming bound is itself a (regular) inference variable,
2112                     //then we are allowed to propagate this inference variable bounds to it.
2113                     ((UndetVar)bound).addBound(ib.complement(), this, types, false);
2114                 }
2115             } else {
2116                 Type bound2 = bound.map(toTypeVarMap).baseType();
2117                 List&lt;Type&gt; prevBounds = bounds.get(ib);
2118                 if (bound == qtype) return;
2119                 for (Type b : prevBounds) {
2120                     //check for redundancy - do not add same bound twice
2121                     if (types.isSameType(b, bound2)) return;
2122                 }
2123                 bounds.put(ib, prevBounds.prepend(bound2));
2124                 notifyBoundChange(ib, bound2, false);
2125             }
2126         }
2127         //where
2128             TypeMapping&lt;Void&gt; toTypeVarMap = new StructuralTypeMapping&lt;Void&gt;() {
2129                 @Override
2130                 public Type visitUndetVar(UndetVar uv, Void _unused) {
2131                     return uv.inst != null ? uv.inst : uv.qtype;
2132                 }
2133             };
2134 
2135         /** replace types in all bounds - this might trigger listener notification */
2136         public void substBounds(List&lt;Type&gt; from, List&lt;Type&gt; to, Types types) {
2137             final ListBuffer&lt;Pair&lt;InferenceBound, Type&gt;&gt;  boundsChanged = new ListBuffer&lt;&gt;();
2138             UndetVarListener prevListener = listener;
2139             try {
2140                 //setup new listener for keeping track of changed bounds
2141                 listener = (uv, ib, t, _ignored) -&gt; {
2142                     Assert.check(uv == UndetVar.this);
2143                     boundsChanged.add(new Pair&lt;&gt;(ib, t));
2144                 };
2145                 for (Map.Entry&lt;InferenceBound, List&lt;Type&gt;&gt; _entry : bounds.entrySet()) {
2146                     InferenceBound ib = _entry.getKey();
2147                     List&lt;Type&gt; prevBounds = _entry.getValue();
2148                     ListBuffer&lt;Type&gt; newBounds = new ListBuffer&lt;&gt;();
2149                     ListBuffer&lt;Type&gt; deps = new ListBuffer&lt;&gt;();
2150                     //step 1 - re-add bounds that are not dependent on ivars
2151                     for (Type t : prevBounds) {
2152                         if (!t.containsAny(from)) {
2153                             newBounds.append(t);
2154                         } else {
2155                             deps.append(t);
2156                         }
2157                     }
2158                     //step 2 - replace bounds
2159                     bounds.put(ib, newBounds.toList());
2160                     //step 3 - for each dependency, add new replaced bound
2161                     for (Type dep : deps) {
2162                         addBound(ib, types.subst(dep, from, to), types, true);
2163                     }
2164                 }
2165             } finally {
2166                 listener = prevListener;
2167                 for (Pair&lt;InferenceBound, Type&gt; boundUpdate : boundsChanged) {
2168                     notifyBoundChange(boundUpdate.fst, boundUpdate.snd, true);
2169                 }
2170             }
2171         }
2172 
2173         private void notifyBoundChange(InferenceBound ib, Type bound, boolean update) {
2174             if (listener != null) {
2175                 listener.varBoundChanged(this, ib, bound, update);
2176             }
2177         }
2178 
2179         public final boolean isCaptured() {
2180             return kind == Kind.CAPTURED;
2181         }
2182 
2183         public final boolean isThrows() {
2184             return kind == Kind.THROWS;
2185         }
2186     }
2187 
2188     /** Represents NONE.
2189      */
2190     public static class JCNoType extends Type implements NoType {
2191         public JCNoType() {
2192             // Need to use List.nil(), because JCNoType constructor
2193             // gets called in static initializers in Type, where
2194             // noAnnotations is also defined.
2195             super(null, TypeMetadata.EMPTY);
2196         }
2197 
2198         @Override
2199         public JCNoType cloneWithMetadata(TypeMetadata md) {
2200             throw new AssertionError(&quot;Cannot add metadata to a JCNoType&quot;);
2201         }
2202 
2203         @Override
2204         public TypeTag getTag() {
2205             return NONE;
2206         }
2207 
2208         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2209         public TypeKind getKind() {
2210             return TypeKind.NONE;
2211         }
2212 
2213         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2214         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2215             return v.visitNoType(this, p);
2216         }
2217 
2218         @Override
2219         public boolean isCompound() { return false; }
2220     }
2221 
2222     /** Represents VOID.
2223      */
2224     public static class JCVoidType extends Type implements NoType {
2225 
2226         public JCVoidType() {
2227             // Void cannot be annotated
2228             super(null, TypeMetadata.EMPTY);
2229         }
2230 
2231         @Override
2232         public JCVoidType cloneWithMetadata(TypeMetadata md) {
2233             throw new AssertionError(&quot;Cannot add metadata to a void type&quot;);
2234         }
2235 
2236         @Override
2237         public TypeTag getTag() {
2238             return VOID;
2239         }
2240 
2241         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2242         public TypeKind getKind() {
2243             return TypeKind.VOID;
2244         }
2245 
2246         @Override
2247         public boolean isCompound() { return false; }
2248 
2249         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2250         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2251             return v.visitNoType(this, p);
2252         }
2253 
2254         @Override
2255         public boolean isPrimitiveOrVoid() {
2256             return true;
2257         }
2258     }
2259 
2260     static class BottomType extends Type implements NullType {
2261         public BottomType() {
2262             // Bottom is a synthesized internal type, so it cannot be annotated
2263             super(null, TypeMetadata.EMPTY);
2264         }
2265 
2266         @Override
2267         public BottomType cloneWithMetadata(TypeMetadata md) {
2268             throw new AssertionError(&quot;Cannot add metadata to a bottom type&quot;);
2269         }
2270 
2271         @Override
2272         public TypeTag getTag() {
2273             return BOT;
2274         }
2275 
2276         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2277         public TypeKind getKind() {
2278             return TypeKind.NULL;
2279         }
2280 
2281         @Override
2282         public boolean isCompound() { return false; }
2283 
2284         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2285         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2286             return v.visitNull(this, p);
2287         }
2288 
2289         @Override
2290         public Type constType(Object value) {
2291             return this;
2292         }
2293 
2294         @Override
2295         public String stringValue() {
2296             return &quot;null&quot;;
2297         }
2298 
2299         @Override
2300         public boolean isNullOrReference() {
2301             return true;
2302         }
2303 
2304     }
2305 
2306     public static class ErrorType extends ClassType
2307             implements javax.lang.model.type.ErrorType {
2308 
2309         private Type originalType = null;
2310 
2311         public ErrorType(ClassSymbol c, Type originalType) {
2312             this(originalType, c);
2313             c.type = this;
2314             c.kind = ERR;
2315             c.members_field = new Scope.ErrorScope(c);
2316         }
2317 
2318         public ErrorType(Type originalType, TypeSymbol tsym) {
2319             super(noType, List.nil(), null);
2320             this.tsym = tsym;
2321             this.originalType = (originalType == null ? noType : originalType);
2322         }
2323 
2324         private ErrorType(Type originalType, TypeSymbol tsym,
2325                           TypeMetadata metadata) {
2326             super(noType, List.nil(), null, metadata);
2327             this.tsym = tsym;
2328             this.originalType = (originalType == null ? noType : originalType);
2329         }
2330 
2331         @Override
2332         public ErrorType cloneWithMetadata(TypeMetadata md) {
2333             return new ErrorType(originalType, tsym, md) {
2334                 @Override
2335                 public Type baseType() { return ErrorType.this.baseType(); }
2336             };
2337         }
2338 
2339         @Override
2340         public TypeTag getTag() {
2341             return ERROR;
2342         }
2343 
2344         @Override
2345         public boolean isPartial() {
2346             return true;
2347         }
2348 
2349         @Override
2350         public boolean isReference() {
2351             return true;
2352         }
2353 
2354         @Override
2355         public boolean isNullOrReference() {
2356             return true;
2357         }
2358 
2359         public ErrorType(Name name, TypeSymbol container, Type originalType) {
2360             this(new ClassSymbol(PUBLIC|STATIC|ACYCLIC, name, null, container), originalType);
2361         }
2362 
2363         @Override
2364         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2365             return v.visitErrorType(this, s);
2366         }
2367 
2368         public Type constType(Object constValue) { return this; }
2369         @DefinedBy(Api.LANGUAGE_MODEL)
2370         public Type getEnclosingType()           { return Type.noType; }
2371         public Type getReturnType()              { return this; }
2372         public Type asSub(Symbol sym)            { return this; }
2373 
2374         public boolean isGenType(Type t)         { return true; }
2375         public boolean isErroneous()             { return true; }
2376         public boolean isCompound()              { return false; }
2377         public boolean isInterface()             { return false; }
2378 
2379         public List&lt;Type&gt; allparams()            { return List.nil(); }
2380         @DefinedBy(Api.LANGUAGE_MODEL)
2381         public List&lt;Type&gt; getTypeArguments()     { return List.nil(); }
2382 
2383         @DefinedBy(Api.LANGUAGE_MODEL)
2384         public TypeKind getKind() {
2385             return TypeKind.ERROR;
2386         }
2387 
2388         public Type getOriginalType() {
2389             return originalType;
2390         }
2391 
2392         @DefinedBy(Api.LANGUAGE_MODEL)
2393         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2394             return v.visitError(this, p);
2395         }
2396     }
2397 
2398     public static class UnknownType extends Type {
2399 
2400         public UnknownType() {
2401             // Unknown is a synthesized internal type, so it cannot be
2402             // annotated.
2403             super(null, TypeMetadata.EMPTY);
2404         }
2405 
2406         @Override
2407         public UnknownType cloneWithMetadata(TypeMetadata md) {
2408             throw new AssertionError(&quot;Cannot add metadata to an unknown type&quot;);
2409         }
2410 
2411         @Override
2412         public TypeTag getTag() {
2413             return UNKNOWN;
2414         }
2415 
2416         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2417         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2418             return v.visitUnknown(this, p);
2419         }
2420 
2421         @Override
2422         public boolean isPartial() {
2423             return true;
2424         }
2425     }
2426 
2427     /**
2428      * A visitor for types.  A visitor is used to implement operations
2429      * (or relations) on types.  Most common operations on types are
2430      * binary relations and this interface is designed for binary
2431      * relations, that is, operations of the form
2432      * Type&amp;nbsp;&amp;times;&amp;nbsp;S&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2433      * &lt;!-- In plain text: Type x S -&gt; R --&gt;
2434      *
2435      * @param &lt;R&gt; the return type of the operation implemented by this
2436      * visitor; use Void if no return type is needed.
2437      * @param &lt;S&gt; the type of the second argument (the first being the
2438      * type itself) of the operation implemented by this visitor; use
2439      * Void if a second argument is not needed.
2440      */
2441     public interface Visitor&lt;R,S&gt; {
2442         R visitClassType(ClassType t, S s);
2443         R visitWildcardType(WildcardType t, S s);
2444         R visitArrayType(ArrayType t, S s);
2445         R visitMethodType(MethodType t, S s);
2446         R visitPackageType(PackageType t, S s);
2447         R visitModuleType(ModuleType t, S s);
2448         R visitTypeVar(TypeVar t, S s);
2449         R visitCapturedType(CapturedType t, S s);
2450         R visitForAll(ForAll t, S s);
2451         R visitUndetVar(UndetVar t, S s);
2452         R visitErrorType(ErrorType t, S s);
2453         R visitType(Type t, S s);
2454     }
2455 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
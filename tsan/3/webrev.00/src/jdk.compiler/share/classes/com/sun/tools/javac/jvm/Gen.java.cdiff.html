<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Code.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Items.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   * questions.
   */
  
  package com.sun.tools.javac.jvm;
  
<span class="line-added">+ import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
  import com.sun.tools.javac.tree.TreeInfo.PosKind;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  import com.sun.tools.javac.util.List;
  import com.sun.tools.javac.code.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,13 ***</span>
          if (instance == null)
              instance = new Gen(context);
          return instance;
      }
  
<span class="line-modified">!     /** Constant pool, reset by genClass.</span>
       */
<span class="line-modified">!     private final Pool pool;</span>
  
      protected Gen(Context context) {
          context.put(genKey, this);
  
          names = Names.instance(context);
<span class="line-new-header">--- 87,13 ---</span>
          if (instance == null)
              instance = new Gen(context);
          return instance;
      }
  
<span class="line-modified">!     /** Constant pool writer, set by genClass.</span>
       */
<span class="line-modified">!     final PoolWriter poolWriter;</span>
  
      protected Gen(Context context) {
          context.put(genKey, this);
  
          names = Names.instance(context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,11 ***</span>
              ? options.isSet(G)
              : options.isSet(G_CUSTOM, &quot;vars&quot;);
          genCrt = options.isSet(XJCOV);
          debugCode = options.isSet(&quot;debug.code&quot;);
          disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
<span class="line-modified">!         pool = new Pool(types);</span>
  
          // ignore cldc because we cannot have both stackmap formats
          this.stackMap = StackMapFormat.JSR202;
          annotate = Annotate.instance(context);
      }
<span class="line-new-header">--- 120,11 ---</span>
              ? options.isSet(G)
              : options.isSet(G_CUSTOM, &quot;vars&quot;);
          genCrt = options.isSet(XJCOV);
          debugCode = options.isSet(&quot;debug.code&quot;);
          disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
<span class="line-modified">!         poolWriter = new PoolWriter(types, names);</span>
  
          // ignore cldc because we cannot have both stackmap formats
          this.stackMap = StackMapFormat.JSR202;
          annotate = Annotate.instance(context);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,10 ***</span>
<span class="line-new-header">--- 164,11 ---</span>
  
      boolean inCondSwitchExpression;
      Chain switchExpressionTrueChain;
      Chain switchExpressionFalseChain;
      List&lt;LocalItem&gt; stackBeforeSwitchExpression;
<span class="line-added">+     LocalItem switchResult;</span>
  
      /** Generate code to load an integer constant.
       *  @param n     The integer to be loaded.
       */
      void loadIntConst(int n) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,21 ***</span>
       *  checking for an array with too many dimensions;
       *  return the reference&#39;s index.
       *  @param type   The type for which a reference is inserted.
       */
      int makeRef(DiagnosticPosition pos, Type type) {
<span class="line-modified">!         checkDimension(pos, type);</span>
<span class="line-removed">-         if (type.isAnnotated()) {</span>
<span class="line-removed">-             return pool.put((Object)type);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             return pool.put(type.hasTag(CLASS) ? (Object)type.tsym : (Object)type);</span>
<span class="line-removed">-         }</span>
      }
  
      /** Check if the given type is an array with too many dimensions.
       */
<span class="line-modified">!     private void checkDimension(DiagnosticPosition pos, Type t) {</span>
          switch (t.getTag()) {
          case METHOD:
              checkDimension(pos, t.getReturnType());
              for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
                  checkDimension(pos, args.head);
<span class="line-new-header">--- 252,21 ---</span>
       *  checking for an array with too many dimensions;
       *  return the reference&#39;s index.
       *  @param type   The type for which a reference is inserted.
       */
      int makeRef(DiagnosticPosition pos, Type type) {
<span class="line-modified">!         return poolWriter.putClass(checkDimension(pos, type));</span>
      }
  
      /** Check if the given type is an array with too many dimensions.
       */
<span class="line-modified">!     private Type checkDimension(DiagnosticPosition pos, Type t) {</span>
<span class="line-added">+         checkDimensionInternal(pos, t);</span>
<span class="line-added">+         return t;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void checkDimensionInternal(DiagnosticPosition pos, Type t) {</span>
          switch (t.getTag()) {
          case METHOD:
              checkDimension(pos, t.getReturnType());
              for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
                  checkDimension(pos, args.head);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,11 ***</span>
          default:
              break;
          }
      }
  
<span class="line-modified">!     /** Create a tempory variable.</span>
       *  @param type   The variable&#39;s type.
       */
      LocalItem makeTemp(Type type) {
          VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
                                      names.empty,
<span class="line-new-header">--- 280,11 ---</span>
          default:
              break;
          }
      }
  
<span class="line-modified">!     /** Create a temporary variable.</span>
       *  @param type   The variable&#39;s type.
       */
      LocalItem makeTemp(Type type) {
          VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
                                      names.empty,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,11 ***</span>
       */
      private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
          if (nerrs != 0 || // only complain about a long string once
              constValue == null ||
              !(constValue instanceof String) ||
<span class="line-modified">!             ((String)constValue).length() &lt; Pool.MAX_STRING_LENGTH)</span>
              return;
          log.error(pos, Errors.LimitString);
          nerrs++;
      }
  
<span class="line-new-header">--- 516,11 ---</span>
       */
      private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
          if (nerrs != 0 || // only complain about a long string once
              constValue == null ||
              !(constValue instanceof String) ||
<span class="line-modified">!             ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH)</span>
              return;
          log.error(pos, Errors.LimitString);
          nerrs++;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 723,10 ***</span>
<span class="line-new-header">--- 725,12 ---</span>
                                        Code.mergeChains(trueJumps, second.trueJumps),
                                        Code.mergeChains(falseJumps, second.falseJumps));
              if (markBranches) result.tree = tree.falsepart;
              return result;
          } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
<span class="line-added">+             code.resolvePending();</span>
<span class="line-added">+ </span>
              boolean prevInCondSwitchExpression = inCondSwitchExpression;
              Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
              Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
              try {
                  inCondSwitchExpression = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 747,10 ***</span>
<span class="line-new-header">--- 751,12 ---</span>
                  inCondSwitchExpression = prevInCondSwitchExpression;
                  switchExpressionTrueChain = prevSwitchExpressionTrueChain;
                  switchExpressionFalseChain = prevSwitchExpressionFalseChain;
              }
          } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {
<span class="line-added">+             code.resolvePending();</span>
<span class="line-added">+ </span>
              LetExpr tree = (LetExpr) inner_tree;
              int limit = code.nextreg;
              int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
              try {
                  genStats(tree.defs, env);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 804,11 ***</span>
          }
  
          @Override
          public void visitIdent(JCIdent tree) {
              if (tree.sym.owner instanceof ClassSymbol) {
<span class="line-modified">!                 pool.put(tree.sym.owner);</span>
              }
          }
  
          @Override
          public void visitConditional(JCConditional tree) {
<span class="line-new-header">--- 810,11 ---</span>
          }
  
          @Override
          public void visitIdent(JCIdent tree) {
              if (tree.sym.owner instanceof ClassSymbol) {
<span class="line-modified">!                 poolWriter.putClass((ClassSymbol)tree.sym.owner);</span>
              }
          }
  
          @Override
          public void visitConditional(JCConditional tree) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 845,11 ***</span>
          try {
              if (tree.type.constValue() != null) {
                  // Short circuit any expressions which are constants
                  tree.accept(classReferenceVisitor);
                  checkStringConstant(tree.pos(), tree.type.constValue());
<span class="line-modified">!                 result = items.makeImmediateItem(tree.type, tree.type.constValue());</span>
              } else {
                  this.pt = pt;
                  tree.accept(this);
              }
              return result.coerce(pt);
<span class="line-new-header">--- 851,16 ---</span>
          try {
              if (tree.type.constValue() != null) {
                  // Short circuit any expressions which are constants
                  tree.accept(classReferenceVisitor);
                  checkStringConstant(tree.pos(), tree.type.constValue());
<span class="line-modified">!                 Symbol sym = TreeInfo.symbol(tree);</span>
<span class="line-added">+                 if (sym != null &amp;&amp; isConstantDynamic(sym)) {</span>
<span class="line-added">+                     result = items.makeDynamicItem(sym);</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     result = items.makeImmediateItem(tree.type, tree.type.constValue());</span>
<span class="line-added">+                 }</span>
              } else {
                  this.pt = pt;
                  tree.accept(this);
              }
              return result.coerce(pt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 860,10 ***</span>
<span class="line-new-header">--- 871,16 ---</span>
          } finally {
              this.pt = prevPt;
          }
      }
  
<span class="line-added">+     public boolean isConstantDynamic(Symbol sym) {</span>
<span class="line-added">+         return sym.kind == VAR &amp;&amp;</span>
<span class="line-added">+                 sym instanceof DynamicVarSymbol &amp;&amp;</span>
<span class="line-added">+                 ((DynamicVarSymbol)sym).isDynamic();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /** Derived visitor method: generate code for a list of method arguments.
       *  @param trees    The argument expressions to be visited.
       *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
       *                  types of the invoked method).
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1005,12 ***</span>
                                          debugCode,
                                          genCrt ? new CRTable(tree, env.toplevel.endPositions)
                                                 : null,
                                          syms,
                                          types,
<span class="line-modified">!                                         pool);</span>
<span class="line-modified">!             items = new Items(pool, code, syms, types);</span>
              if (code.debugCode) {
                  System.err.println(meth + &quot; for body &quot; + tree);
              }
  
              // If method is not static, create a new local variable address
<span class="line-new-header">--- 1022,12 ---</span>
                                          debugCode,
                                          genCrt ? new CRTable(tree, env.toplevel.endPositions)
                                                 : null,
                                          syms,
                                          types,
<span class="line-modified">!                                         poolWriter);</span>
<span class="line-modified">!             items = new Items(poolWriter, code, syms, types);</span>
              if (code.debugCode) {
                  System.err.println(meth + &quot; for body &quot; + tree);
              }
  
              // If method is not static, create a new local variable address
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1089,11 ***</span>
      }
      //where
          /** Generate code for a loop.
           *  @param loop       The tree representing the loop.
           *  @param body       The loop&#39;s body.
<span class="line-modified">!          *  @param cond       The loop&#39;s controling condition.</span>
           *  @param step       &quot;Step&quot; statements to be inserted at end of
           *                    each iteration.
           *  @param testFirst  True if the loop test belongs before the body.
           */
          private void genLoop(JCStatement loop,
<span class="line-new-header">--- 1106,11 ---</span>
      }
      //where
          /** Generate code for a loop.
           *  @param loop       The tree representing the loop.
           *  @param body       The loop&#39;s body.
<span class="line-modified">!          *  @param cond       The loop&#39;s controlling condition.</span>
           *  @param step       &quot;Step&quot; statements to be inserted at end of
           *                    each iteration.
           *  @param testFirst  True if the loop test belongs before the body.
           */
          private void genLoop(JCStatement loop,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1176,13 ***</span>
<span class="line-new-header">--- 1193,15 ---</span>
          result = items.makeStackItem(pt);
      }
  
      private void doHandleSwitchExpression(JCSwitchExpression tree) {
          List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
<span class="line-added">+         LocalItem prevSwitchResult = switchResult;</span>
          int limit = code.nextreg;
          try {
              stackBeforeSwitchExpression = List.nil();
<span class="line-added">+             switchResult = null;</span>
              if (hasTry(tree)) {
                  //if the switch expression contains try-catch, the catch handlers need to have
                  //an empty stack. So stash whole stack to local variables, and restore it before
                  //breaks:
                  while (code.state.stacksize &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1197,19 ***</span>
<span class="line-new-header">--- 1216,21 ---</span>
                                                    this.env.enclMethod.sym);
                      LocalItem item = items.new LocalItem(type, code.newLocal(var));
                      stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
                      item.store();
                  }
<span class="line-added">+                 switchResult = makeTemp(tree.type);</span>
              }
              int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
              try {
                  handleSwitch(tree, tree.selector, tree.cases);
              } finally {
                  code.setLetExprStackPos(prevLetExprStart);
              }
          } finally {
              stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
<span class="line-added">+             switchResult = prevSwitchResult;</span>
              code.endScopes(limit);
          }
      }
      //where:
          private boolean hasTry(JCSwitchExpression tree) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1499,11 ***</span>
                                                   code.branch(goto_));
                  }
                  endFinalizerGap(env);
              }
              if (hasFinalizer) {
<span class="line-modified">!                 // Create a new register segement to avoid allocating</span>
                  // the same variables in finalizers and other statements.
                  code.newRegSegment();
  
                  // Add a catch-all clause.
  
<span class="line-new-header">--- 1520,11 ---</span>
                                                   code.branch(goto_));
                  }
                  endFinalizerGap(env);
              }
              if (hasFinalizer) {
<span class="line-modified">!                 // Create a new register segment to avoid allocating</span>
                  // the same variables in finalizers and other statements.
                  code.newRegSegment();
  
                  // Add a catch-all clause.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1702,55 ***</span>
          genExpr(tree.expr, tree.expr.type).drop();
          Assert.check(code.isStatementStart());
      }
  
      public void visitBreak(JCBreak tree) {
          Assert.check(code.isStatementStart());
          final Env&lt;GenContext&gt; targetEnv;
<span class="line-modified">!         if (tree.isValueBreak()) {</span>
<span class="line-modified">!             //restore stack as it was before the switch expression:</span>
<span class="line-modified">!             for (LocalItem li : stackBeforeSwitchExpression) {</span>
<span class="line-modified">!                 li.load();</span>
              }
<span class="line-modified">!             if (inCondSwitchExpression) {</span>
<span class="line-modified">!                 CondItem value = genCond(tree.value, CRT_FLOW_TARGET);</span>
<span class="line-removed">-                 Chain falseJumps = value.jumpFalse();</span>
<span class="line-removed">-                 targetEnv = unwindBreak(tree);</span>
<span class="line-removed">-                 code.resolve(value.trueJumps);</span>
<span class="line-removed">-                 Chain trueJumps = code.branch(goto_);</span>
<span class="line-removed">-                 if (switchExpressionTrueChain == null) {</span>
<span class="line-removed">-                     switchExpressionTrueChain = trueJumps;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     switchExpressionTrueChain =</span>
<span class="line-removed">-                             Code.mergeChains(switchExpressionTrueChain, trueJumps);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (switchExpressionFalseChain == null) {</span>
<span class="line-removed">-                     switchExpressionFalseChain = falseJumps;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     switchExpressionFalseChain =</span>
<span class="line-removed">-                             Code.mergeChains(switchExpressionFalseChain, falseJumps);</span>
<span class="line-removed">-                 }</span>
              } else {
<span class="line-modified">!                 genExpr(tree.value, pt).load();</span>
                  code.state.forceStackTop(tree.target.type);
<span class="line-removed">-                 targetEnv = unwindBreak(tree);</span>
                  targetEnv.info.addExit(code.branch(goto_));
              }
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             targetEnv = unwindBreak(tree);</span>
<span class="line-removed">-             targetEnv.info.addExit(code.branch(goto_));</span>
          }
          endFinalizerGaps(env, targetEnv);
      }
      //where:
<span class="line-modified">!         private Env&lt;GenContext&gt; unwindBreak(JCBreak tree) {</span>
              int tmpPos = code.pendingStatPos;
<span class="line-modified">!             Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);</span>
              code.pendingStatPos = tmpPos;
              return targetEnv;
          }
  
      public void visitContinue(JCContinue tree) {
          int tmpPos = code.pendingStatPos;
          Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
          code.pendingStatPos = tmpPos;
          Assert.check(code.isStatementStart());
<span class="line-new-header">--- 1723,81 ---</span>
          genExpr(tree.expr, tree.expr.type).drop();
          Assert.check(code.isStatementStart());
      }
  
      public void visitBreak(JCBreak tree) {
<span class="line-added">+         Assert.check(code.isStatementStart());</span>
<span class="line-added">+         final Env&lt;GenContext&gt; targetEnv = unwindBreak(tree.target);</span>
<span class="line-added">+         targetEnv.info.addExit(code.branch(goto_));</span>
<span class="line-added">+         endFinalizerGaps(env, targetEnv);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public void visitYield(JCYield tree) {</span>
          Assert.check(code.isStatementStart());
          final Env&lt;GenContext&gt; targetEnv;
<span class="line-modified">!         if (inCondSwitchExpression) {</span>
<span class="line-modified">!             CondItem value = genCond(tree.value, CRT_FLOW_TARGET);</span>
<span class="line-modified">!             Chain falseJumps = value.jumpFalse();</span>
<span class="line-modified">! </span>
<span class="line-added">+             code.resolve(value.trueJumps);</span>
<span class="line-added">+             Env&lt;GenContext&gt; localEnv = unwindBreak(tree.target);</span>
<span class="line-added">+             reloadStackBeforeSwitchExpr();</span>
<span class="line-added">+             Chain trueJumps = code.branch(goto_);</span>
<span class="line-added">+ </span>
<span class="line-added">+             endFinalizerGaps(env, localEnv);</span>
<span class="line-added">+ </span>
<span class="line-added">+             code.resolve(falseJumps);</span>
<span class="line-added">+             targetEnv = unwindBreak(tree.target);</span>
<span class="line-added">+             reloadStackBeforeSwitchExpr();</span>
<span class="line-added">+             falseJumps = code.branch(goto_);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (switchExpressionTrueChain == null) {</span>
<span class="line-added">+                 switchExpressionTrueChain = trueJumps;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 switchExpressionTrueChain =</span>
<span class="line-added">+                         Code.mergeChains(switchExpressionTrueChain, trueJumps);</span>
              }
<span class="line-modified">!             if (switchExpressionFalseChain == null) {</span>
<span class="line-modified">!                 switchExpressionFalseChain = falseJumps;</span>
              } else {
<span class="line-modified">!                 switchExpressionFalseChain =</span>
<span class="line-added">+                         Code.mergeChains(switchExpressionFalseChain, falseJumps);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             genExpr(tree.value, pt).load();</span>
<span class="line-added">+             if (switchResult != null)</span>
<span class="line-added">+                 switchResult.store();</span>
<span class="line-added">+ </span>
<span class="line-added">+             targetEnv = unwindBreak(tree.target);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (code.isAlive()) {</span>
<span class="line-added">+                 reloadStackBeforeSwitchExpr();</span>
<span class="line-added">+                 if (switchResult != null)</span>
<span class="line-added">+                     switchResult.load();</span>
<span class="line-added">+ </span>
                  code.state.forceStackTop(tree.target.type);
                  targetEnv.info.addExit(code.branch(goto_));
<span class="line-added">+                 code.markDead();</span>
              }
          }
          endFinalizerGaps(env, targetEnv);
      }
      //where:
<span class="line-modified">!         /** As side-effect, might mark code as dead disabling any further emission.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private Env&lt;GenContext&gt; unwindBreak(JCTree target) {</span>
              int tmpPos = code.pendingStatPos;
<span class="line-modified">!             Env&lt;GenContext&gt; targetEnv = unwind(target, env);</span>
              code.pendingStatPos = tmpPos;
              return targetEnv;
          }
  
<span class="line-added">+         private void reloadStackBeforeSwitchExpr() {</span>
<span class="line-added">+             for (LocalItem li : stackBeforeSwitchExpression)</span>
<span class="line-added">+                 li.load();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      public void visitContinue(JCContinue tree) {
          int tmpPos = code.pendingStatPos;
          Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
          code.pendingStatPos = tmpPos;
          Assert.check(code.isStatementStart());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1884,11 ***</span>
          // Enclosing instances or anonymous classes should have been eliminated
          // by now.
          Assert.check(tree.encl == null &amp;&amp; tree.def == null);
          setTypeAnnotationPositions(tree.pos);
  
<span class="line-modified">!         code.emitop2(new_, makeRef(tree.pos(), tree.type));</span>
          code.emitop0(dup);
  
          // Generate code for all arguments, where the expected types are
          // the parameters of the constructor&#39;s external type (that is,
          // any implicit outer instance appears as first parameter).
<span class="line-new-header">--- 1931,11 ---</span>
          // Enclosing instances or anonymous classes should have been eliminated
          // by now.
          Assert.check(tree.encl == null &amp;&amp; tree.def == null);
          setTypeAnnotationPositions(tree.pos);
  
<span class="line-modified">!         code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);</span>
          code.emitop0(dup);
  
          // Generate code for all arguments, where the expected types are
          // the parameters of the constructor&#39;s external type (that is,
          // any implicit outer instance appears as first parameter).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2160,22 ***</span>
          // For basic types, the coerce(...) in genExpr(...) will do
          // the conversion.
          if (!tree.clazz.type.isPrimitive() &amp;&amp;
             !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
             types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
<span class="line-modified">!             code.emitop2(checkcast, makeRef(tree.pos(), tree.clazz.type));</span>
          }
      }
  
      public void visitWildcard(JCWildcard tree) {
          throw new AssertionError(this.getClass().getName());
      }
  
      public void visitTypeTest(JCInstanceOf tree) {
          genExpr(tree.expr, tree.expr.type).load();
          setTypeAnnotationPositions(tree.pos);
<span class="line-modified">!         code.emitop2(instanceof_, makeRef(tree.pos(), tree.clazz.type));</span>
          result = items.makeStackItem(syms.booleanType);
      }
  
      public void visitIndexed(JCArrayAccess tree) {
          genExpr(tree.indexed, tree.indexed.type).load();
<span class="line-new-header">--- 2207,22 ---</span>
          // For basic types, the coerce(...) in genExpr(...) will do
          // the conversion.
          if (!tree.clazz.type.isPrimitive() &amp;&amp;
             !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
             types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
<span class="line-modified">!             code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);</span>
          }
      }
  
      public void visitWildcard(JCWildcard tree) {
          throw new AssertionError(this.getClass().getName());
      }
  
      public void visitTypeTest(JCInstanceOf tree) {
          genExpr(tree.expr, tree.expr.type).load();
          setTypeAnnotationPositions(tree.pos);
<span class="line-modified">!         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));</span>
          result = items.makeStackItem(syms.booleanType);
      }
  
      public void visitIndexed(JCArrayAccess tree) {
          genExpr(tree.indexed, tree.indexed.type).load();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2193,14 ***</span>
                  // Generate code to address the constructor.
                  res.load();
                  res = items.makeMemberItem(sym, true);
              }
              result = res;
          } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
              result = items.makeLocalItem((VarSymbol)sym);
<span class="line-removed">-         } else if (isInvokeDynamic(sym)) {</span>
<span class="line-removed">-             result = items.makeDynamicItem(sym);</span>
          } else if ((sym.flags() &amp; STATIC) != 0) {
              if (!isAccessSuper(env.enclMethod))
                  sym = binaryQualifier(sym, env.enclClass.type);
              result = items.makeStaticItem(sym);
          } else {
<span class="line-new-header">--- 2240,17 ---</span>
                  // Generate code to address the constructor.
                  res.load();
                  res = items.makeMemberItem(sym, true);
              }
              result = res;
<span class="line-added">+        } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {</span>
<span class="line-added">+             if (isConstantDynamic(sym)) {</span>
<span class="line-added">+                 setTypeAnnotationPositions(tree.pos);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             result = items.makeDynamicItem(sym);</span>
          } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
              result = items.makeLocalItem((VarSymbol)sym);
          } else if ((sym.flags() &amp; STATIC) != 0) {
              if (!isAccessSuper(env.enclMethod))
                  sym = binaryQualifier(sym, env.enclClass.type);
              result = items.makeStaticItem(sym);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2219,11 ***</span>
  
      public void visitSelect(JCFieldAccess tree) {
          Symbol sym = tree.sym;
  
          if (tree.name == names._class) {
<span class="line-modified">!             code.emitLdc(makeRef(tree.pos(), tree.selected.type));</span>
              result = items.makeStackItem(pt);
              return;
         }
  
          Symbol ssym = TreeInfo.symbol(tree.selected);
<span class="line-new-header">--- 2269,11 ---</span>
  
      public void visitSelect(JCFieldAccess tree) {
          Symbol sym = tree.sym;
  
          if (tree.name == names._class) {
<span class="line-modified">!             code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));</span>
              result = items.makeStackItem(pt);
              return;
         }
  
          Symbol ssym = TreeInfo.symbol(tree.selected);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2292,10 ***</span>
<span class="line-new-header">--- 2342,12 ---</span>
          else
              result = items.makeImmediateItem(tree.type, tree.value);
      }
  
      public void visitLetExpr(LetExpr tree) {
<span class="line-added">+         code.resolvePending();</span>
<span class="line-added">+ </span>
          int limit = code.nextreg;
          int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
          try {
              genStats(tree.defs, env);
          } finally {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2303,11 ***</span>
          }
          result = genExpr(tree.expr, tree.expr.type).load();
          code.endScopes(limit);
      }
  
<span class="line-modified">!     private void generateReferencesToPrunedTree(ClassSymbol classSymbol, Pool pool) {</span>
          List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
          if (prunedInfo != null) {
              for (JCTree prunedTree: prunedInfo) {
                  prunedTree.accept(classReferenceVisitor);
              }
<span class="line-new-header">--- 2355,11 ---</span>
          }
          result = genExpr(tree.expr, tree.expr.type).load();
          code.endScopes(limit);
      }
  
<span class="line-modified">!     private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {</span>
          List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
          if (prunedInfo != null) {
              for (JCTree prunedTree: prunedInfo) {
                  prunedTree.accept(classReferenceVisitor);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2329,24 ***</span>
          try {
              attrEnv = env;
              ClassSymbol c = cdef.sym;
              this.toplevel = env.toplevel;
              this.endPosTable = toplevel.endPositions;
<span class="line-removed">-             c.pool = pool;</span>
<span class="line-removed">-             pool.reset();</span>
              /* method normalizeDefs() can add references to external classes into the constant pool
               */
              cdef.defs = normalizeDefs(cdef.defs, c);
<span class="line-modified">!             generateReferencesToPrunedTree(c, pool);</span>
              Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
              localEnv.toplevel = env.toplevel;
              localEnv.enclClass = cdef;
  
              for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
                  genDef(l.head, localEnv);
              }
<span class="line-modified">!             if (pool.numEntries() &gt; Pool.MAX_ENTRIES) {</span>
                  log.error(cdef.pos(), Errors.LimitPool);
                  nerrs++;
              }
              if (nerrs != 0) {
                  // if errors, discard code
<span class="line-new-header">--- 2381,22 ---</span>
          try {
              attrEnv = env;
              ClassSymbol c = cdef.sym;
              this.toplevel = env.toplevel;
              this.endPosTable = toplevel.endPositions;
              /* method normalizeDefs() can add references to external classes into the constant pool
               */
              cdef.defs = normalizeDefs(cdef.defs, c);
<span class="line-modified">!             generateReferencesToPrunedTree(c);</span>
              Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
              localEnv.toplevel = env.toplevel;
              localEnv.enclClass = cdef;
  
              for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
                  genDef(l.head, localEnv);
              }
<span class="line-modified">!             if (poolWriter.size() &gt; PoolWriter.MAX_ENTRIES) {</span>
                  log.error(cdef.pos(), Errors.LimitPool);
                  nerrs++;
              }
              if (nerrs != 0) {
                  // if errors, discard code
</pre>
<center><a href="Code.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Items.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
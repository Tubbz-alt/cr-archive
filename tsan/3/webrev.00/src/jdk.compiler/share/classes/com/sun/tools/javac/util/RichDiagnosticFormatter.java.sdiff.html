<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Position.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../sjavac/CompileJavaPackages.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/util/RichDiagnosticFormatter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 34 import java.util.Map;
 35 
 36 import com.sun.tools.javac.code.Printer;
 37 import com.sun.tools.javac.code.Symbol;
 38 import com.sun.tools.javac.code.Symbol.*;
 39 import com.sun.tools.javac.code.Symtab;
 40 import com.sun.tools.javac.code.Type;
 41 import com.sun.tools.javac.code.Type.*;
 42 import com.sun.tools.javac.code.Types;
 43 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
 44 
 45 import static com.sun.tools.javac.code.Flags.*;
 46 import static com.sun.tools.javac.code.TypeTag.*;
 47 import static com.sun.tools.javac.code.Kinds.*;
 48 import static com.sun.tools.javac.code.Kinds.Kind.*;
 49 import static com.sun.tools.javac.util.LayoutCharacters.*;
 50 import static com.sun.tools.javac.util.RichDiagnosticFormatter.RichConfiguration.*;
 51 
 52 /**
 53  * A rich diagnostic formatter is a formatter that provides better integration
<span class="line-modified"> 54  * with javac&#39;s type system. A diagostic is first preprocessed in order to keep</span>
<span class="line-modified"> 55  * track of each types/symbols in it; after these informations are collected,</span>
 56  * the diagnostic is rendered using a standard formatter, whose type/symbol printer
 57  * has been replaced by a more refined version provided by this rich formatter.
 58  * The rich formatter currently enables three different features: (i) simple class
 59  * names - that is class names are displayed used a non qualified name (thus
 60  * omitting package info) whenever possible - (ii) where clause list - a list of
 61  * additional subdiagnostics that provide specific info about type-variables,
 62  * captured types, intersection types that occur in the diagnostic that is to be
 63  * formatted and (iii) type-variable disambiguation - when the diagnostic refers
 64  * to two different type-variables with the same name, their representation is
 65  * disambiguated by appending an index to the type variable name.
 66  *
 67  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 68  * If you write code that depends on this, you do so at your own risk.
 69  * This code and its internal interfaces are subject to change or
 70  * deletion without notice.&lt;/b&gt;
 71  */
 72 public class RichDiagnosticFormatter extends
 73         ForwardingDiagnosticFormatter&lt;JCDiagnostic, AbstractDiagnosticFormatter&gt; {
 74 
 75     final Symtab syms;
</pre>
<hr />
<pre>
233             }
234         }
235         return -1;
236     }
237 
238     private boolean unique(TypeVar typevar) {
239         typevar = (TypeVar) typevar.stripMetadata();
240 
241         int found = 0;
242         for (Type t : whereClauses.get(WhereClauseKind.TYPEVAR).keySet()) {
243             if (t.stripMetadata().toString().equals(typevar.toString())) {
244                 found++;
245             }
246         }
247         if (found &lt; 1)
248             throw new AssertionError(&quot;Missing type variable in where clause: &quot; + typevar);
249         return found == 1;
250     }
251     //where
252     /**
<span class="line-modified">253      * This enum defines all posssible kinds of where clauses that can be</span>
254      * attached by a rich diagnostic formatter to a given diagnostic
255      */
256     enum WhereClauseKind {
257 
258         /** where clause regarding a type variable */
259         TYPEVAR(&quot;where.description.typevar&quot;),
260         /** where clause regarding a captured type */
261         CAPTURED(&quot;where.description.captured&quot;),
262         /** where clause regarding an intersection type */
263         INTERSECTION(&quot;where.description.intersection&quot;);
264 
265         /** resource key for this where clause kind */
266         private final String key;
267 
268         WhereClauseKind(String key) {
269             this.key = key;
270         }
271 
272         String key() {
273             return key;
</pre>
</td>
<td>
<hr />
<pre>
 34 import java.util.Map;
 35 
 36 import com.sun.tools.javac.code.Printer;
 37 import com.sun.tools.javac.code.Symbol;
 38 import com.sun.tools.javac.code.Symbol.*;
 39 import com.sun.tools.javac.code.Symtab;
 40 import com.sun.tools.javac.code.Type;
 41 import com.sun.tools.javac.code.Type.*;
 42 import com.sun.tools.javac.code.Types;
 43 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
 44 
 45 import static com.sun.tools.javac.code.Flags.*;
 46 import static com.sun.tools.javac.code.TypeTag.*;
 47 import static com.sun.tools.javac.code.Kinds.*;
 48 import static com.sun.tools.javac.code.Kinds.Kind.*;
 49 import static com.sun.tools.javac.util.LayoutCharacters.*;
 50 import static com.sun.tools.javac.util.RichDiagnosticFormatter.RichConfiguration.*;
 51 
 52 /**
 53  * A rich diagnostic formatter is a formatter that provides better integration
<span class="line-modified"> 54  * with javac&#39;s type system. A diagnostic is first preprocessed in order to keep</span>
<span class="line-modified"> 55  * track of each types/symbols in it; after this information is collected,</span>
 56  * the diagnostic is rendered using a standard formatter, whose type/symbol printer
 57  * has been replaced by a more refined version provided by this rich formatter.
 58  * The rich formatter currently enables three different features: (i) simple class
 59  * names - that is class names are displayed used a non qualified name (thus
 60  * omitting package info) whenever possible - (ii) where clause list - a list of
 61  * additional subdiagnostics that provide specific info about type-variables,
 62  * captured types, intersection types that occur in the diagnostic that is to be
 63  * formatted and (iii) type-variable disambiguation - when the diagnostic refers
 64  * to two different type-variables with the same name, their representation is
 65  * disambiguated by appending an index to the type variable name.
 66  *
 67  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 68  * If you write code that depends on this, you do so at your own risk.
 69  * This code and its internal interfaces are subject to change or
 70  * deletion without notice.&lt;/b&gt;
 71  */
 72 public class RichDiagnosticFormatter extends
 73         ForwardingDiagnosticFormatter&lt;JCDiagnostic, AbstractDiagnosticFormatter&gt; {
 74 
 75     final Symtab syms;
</pre>
<hr />
<pre>
233             }
234         }
235         return -1;
236     }
237 
238     private boolean unique(TypeVar typevar) {
239         typevar = (TypeVar) typevar.stripMetadata();
240 
241         int found = 0;
242         for (Type t : whereClauses.get(WhereClauseKind.TYPEVAR).keySet()) {
243             if (t.stripMetadata().toString().equals(typevar.toString())) {
244                 found++;
245             }
246         }
247         if (found &lt; 1)
248             throw new AssertionError(&quot;Missing type variable in where clause: &quot; + typevar);
249         return found == 1;
250     }
251     //where
252     /**
<span class="line-modified">253      * This enum defines all possible kinds of where clauses that can be</span>
254      * attached by a rich diagnostic formatter to a given diagnostic
255      */
256     enum WhereClauseKind {
257 
258         /** where clause regarding a type variable */
259         TYPEVAR(&quot;where.description.typevar&quot;),
260         /** where clause regarding a captured type */
261         CAPTURED(&quot;where.description.captured&quot;),
262         /** where clause regarding an intersection type */
263         INTERSECTION(&quot;where.description.intersection&quot;);
264 
265         /** resource key for this where clause kind */
266         private final String key;
267 
268         WhereClauseKind(String key) {
269             this.key = key;
270         }
271 
272         String key() {
273             return key;
</pre>
</td>
</tr>
</table>
<center><a href="Position.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../sjavac/CompileJavaPackages.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/MatchBindingsComputer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Symbol;
 29 import com.sun.tools.javac.code.Symbol.BindingSymbol;
 30 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 31 import com.sun.tools.javac.tree.JCTree;
 32 import com.sun.tools.javac.tree.JCTree.Tag;
 33 import com.sun.tools.javac.tree.TreeScanner;
 34 import com.sun.tools.javac.util.Context;
 35 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 36 import com.sun.tools.javac.util.List;
 37 import com.sun.tools.javac.util.Log;
 38 
 39 import static com.sun.tools.javac.code.Flags.CLASH;
 40 
 41 
 42 public class MatchBindingsComputer extends TreeScanner {
 43     public static final MatchBindings EMPTY = new MatchBindings(List.nil(), List.nil());
 44 
 45     protected static final Context.Key&lt;MatchBindingsComputer&gt; matchBindingsComputerKey = new Context.Key&lt;&gt;();
 46 
 47     private final Log log;
 48 
 49     public static MatchBindingsComputer instance(Context context) {
 50         MatchBindingsComputer instance = context.get(matchBindingsComputerKey);
 51         if (instance == null)
 52             instance = new MatchBindingsComputer(context);
 53         return instance;
 54     }
 55 
 56     protected MatchBindingsComputer(Context context) {
 57         this.log = Log.instance(context);
 58     }
 59 
 60     public MatchBindings conditional(JCTree tree, MatchBindings condBindings, MatchBindings trueBindings, MatchBindings falseBindings) {
 61         if (condBindings == EMPTY &amp;&amp;
 62             trueBindings == EMPTY &amp;&amp;
 63             falseBindings == EMPTY) {
 64             return EMPTY;
 65         }
 66 
 67         DiagnosticPosition pos = tree.pos();
 68          //A pattern variable is introduced both by a when true, and by c when true:
 69         List&lt;BindingSymbol&gt; xTzT = intersection(pos, condBindings.bindingsWhenTrue, falseBindings.bindingsWhenTrue);
 70          //A pattern variable is introduced both by a when false, and by b when true:
 71         List&lt;BindingSymbol&gt; xFyT = intersection(pos, condBindings.bindingsWhenFalse, trueBindings.bindingsWhenTrue);
 72          //A pattern variable is introduced both by b when true, and by c when true:
 73         List&lt;BindingSymbol&gt; yTzT = intersection(pos, trueBindings.bindingsWhenTrue, falseBindings.bindingsWhenTrue);
 74          //A pattern variable is introduced both by a when true, and by c when false:
 75         List&lt;BindingSymbol&gt; xTzF = intersection(pos, condBindings.bindingsWhenTrue, falseBindings.bindingsWhenFalse);
 76          //A pattern variable is introduced both by a when false, and by b when false:
 77         List&lt;BindingSymbol&gt; xFyF = intersection(pos, condBindings.bindingsWhenFalse, trueBindings.bindingsWhenFalse);
 78          //A pattern variable is introduced both by b when false, and by c when false:
 79         List&lt;BindingSymbol&gt; yFzF = intersection(pos, trueBindings.bindingsWhenFalse, falseBindings.bindingsWhenFalse);
 80 
 81         //error recovery:
 82         /* if e = &quot;x ? y : z&quot;, then:
 83                e.T = union(intersect(y.T, z.T), intersect(x.T, z.T), intersect(x.F, y.T))
 84                e.F = union(intersect(y.F, z.F), intersect(x.T, z.F), intersect(x.F, y.F))
 85         */
 86         List&lt;BindingSymbol&gt; bindingsWhenTrue = union(pos, yTzT, xTzT, xFyT);
 87         List&lt;BindingSymbol&gt; bindingsWhenFalse = union(pos, yFzF, xTzF, xFyF);
 88         return new MatchBindings(bindingsWhenTrue, bindingsWhenFalse);
 89     }
 90 
 91     public MatchBindings unary(JCTree tree, MatchBindings bindings) {
 92         if (bindings == EMPTY || !tree.hasTag(Tag.NOT)) return bindings;
 93         return new MatchBindings(bindings.bindingsWhenFalse, bindings.bindingsWhenTrue);
 94     }
 95 
 96     public MatchBindings binary(JCTree tree, MatchBindings lhsBindings, MatchBindings rhsBindings) {
 97         switch (tree.getTag()) {
 98             case AND: {
 99                 // e.T = union(x.T, y.T)
100                 // e.F = intersection(x.F, y.F) (error recovery)
101                 List&lt;BindingSymbol&gt; bindingsWhenTrue =
102                         union(tree.pos(), lhsBindings.bindingsWhenTrue, rhsBindings.bindingsWhenTrue);
103                 List&lt;BindingSymbol&gt; bindingsWhenFalse = //error recovery
104                         intersection(tree.pos(), lhsBindings.bindingsWhenFalse, rhsBindings.bindingsWhenFalse);
105                 return new MatchBindings(bindingsWhenTrue, bindingsWhenFalse);
106             }
107             case OR: {
108                 // e.T = intersection(x.T, y.T) (error recovery)
109                 // e.F = union(x.F, y.F)
110                 List&lt;BindingSymbol&gt; bindingsWhenTrue = //error recovery
111                         intersection(tree.pos(), lhsBindings.bindingsWhenTrue, rhsBindings.bindingsWhenTrue);
112                 List&lt;Symbol.BindingSymbol&gt; bindingsWhenFalse =
113                         union(tree.pos(), lhsBindings.bindingsWhenFalse, rhsBindings.bindingsWhenFalse);
114                 return new MatchBindings(bindingsWhenTrue, bindingsWhenFalse);
115             }
116         }
117         return EMPTY;
118     }
119 
120     public MatchBindings finishBindings(JCTree tree, MatchBindings matchBindings) {
121         switch (tree.getTag()) {
122             case NOT: case AND: case OR: case BINDINGPATTERN:
123             case PARENS: case TYPETEST:
124             case CONDEXPR: //error recovery:
125                 return matchBindings;
126             default:
127                 return MatchBindingsComputer.EMPTY;
128         }
129     }
130 
131     public static class MatchBindings {
132 
133         public final List&lt;BindingSymbol&gt; bindingsWhenTrue;
134         public final List&lt;BindingSymbol&gt; bindingsWhenFalse;
135 
136         public MatchBindings(List&lt;BindingSymbol&gt; bindingsWhenTrue, List&lt;BindingSymbol&gt; bindingsWhenFalse) {
137             this.bindingsWhenTrue = bindingsWhenTrue;
138             this.bindingsWhenFalse = bindingsWhenFalse;
139         }
140 
141     }
142     private List&lt;BindingSymbol&gt; intersection(DiagnosticPosition pos, List&lt;BindingSymbol&gt; lhsBindings, List&lt;BindingSymbol&gt; rhsBindings) {
143         // It is an error if, for intersection(a,b), if a and b contain the same variable name (may be eventually relaxed to merge variables of same type)
144         List&lt;BindingSymbol&gt; list = List.nil();
145         for (BindingSymbol v1 : lhsBindings) {
146             for (BindingSymbol v2 : rhsBindings) {
147                 if (v1.name == v2.name &amp;&amp;
148                     (v1.flags() &amp; CLASH) == 0 &amp;&amp;
149                     (v2.flags() &amp; CLASH) == 0) {
150                     log.error(pos, Errors.MatchBindingExists);
151                     list = list.append(v2);
152                 }
153             }
154         }
155         return list;
156     }
157 
158     @SafeVarargs
159     private final List&lt;BindingSymbol&gt; union(DiagnosticPosition pos, List&lt;BindingSymbol&gt; lhsBindings, List&lt;BindingSymbol&gt; ... rhsBindings_s) {
160         // It is an error if for union(a,b), a and b contain the same name (disjoint union).
161         List&lt;BindingSymbol&gt; list = lhsBindings;
162         for (List&lt;BindingSymbol&gt; rhsBindings : rhsBindings_s) {
163             for (BindingSymbol v : rhsBindings) {
164                 for (BindingSymbol ov : list) {
165                     if (ov.name == v.name &amp;&amp;
166                         (ov.flags() &amp; CLASH) == 0 &amp;&amp;
167                         (v.flags() &amp; CLASH) == 0) {
168                         log.error(pos, Errors.MatchBindingExists);
169                     }
170                 }
171                 list = list.append(v);
172             }
173         }
174         return list;
175     }
176 }
    </pre>
  </body>
</html>
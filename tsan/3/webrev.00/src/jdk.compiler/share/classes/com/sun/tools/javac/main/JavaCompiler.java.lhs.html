<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/main/JavaCompiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.main;
  27 
  28 import java.io.*;
  29 import java.util.Collection;
  30 import java.util.Collections;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.LinkedHashMap;
  34 import java.util.LinkedHashSet;
  35 import java.util.Map;
  36 import java.util.MissingResourceException;
  37 import java.util.Queue;
  38 import java.util.ResourceBundle;
  39 import java.util.Set;
  40 import java.util.function.Function;
  41 
  42 import javax.annotation.processing.Processor;
  43 import javax.lang.model.SourceVersion;
  44 import javax.lang.model.element.ElementVisitor;
  45 import javax.tools.DiagnosticListener;
  46 import javax.tools.JavaFileManager;
  47 import javax.tools.JavaFileObject;
  48 import javax.tools.JavaFileObject.Kind;
  49 import javax.tools.StandardLocation;
  50 
  51 import com.sun.source.util.TaskEvent;
  52 import com.sun.tools.javac.api.MultiTaskListener;
  53 import com.sun.tools.javac.code.*;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Source.Feature;
  56 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  57 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  58 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  59 import com.sun.tools.javac.comp.*;
  60 import com.sun.tools.javac.comp.CompileStates.CompileState;
  61 import com.sun.tools.javac.file.JavacFileManager;
  62 import com.sun.tools.javac.jvm.*;
  63 import com.sun.tools.javac.parser.*;
  64 import com.sun.tools.javac.platform.PlatformDescription;
  65 import com.sun.tools.javac.processing.*;
  66 import com.sun.tools.javac.tree.*;
  67 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
  68 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  69 import com.sun.tools.javac.tree.JCTree.JCExpression;
  70 import com.sun.tools.javac.tree.JCTree.JCLambda;
  71 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
  72 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
  73 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  74 import com.sun.tools.javac.util.*;
  75 import com.sun.tools.javac.util.DefinedBy.Api;
  76 import com.sun.tools.javac.util.JCDiagnostic.Factory;
  77 import com.sun.tools.javac.util.Log.DiagnosticHandler;
  78 import com.sun.tools.javac.util.Log.DiscardDiagnosticHandler;
  79 import com.sun.tools.javac.util.Log.WriterKind;
  80 
  81 import static com.sun.tools.javac.code.Kinds.Kind.*;
  82 
  83 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  84 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  85 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  86 import com.sun.tools.javac.resources.CompilerProperties.Notes;
  87 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  88 
  89 import static com.sun.tools.javac.code.TypeTag.CLASS;
  90 import static com.sun.tools.javac.main.Option.*;
  91 import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;
  92 
  93 import static javax.tools.StandardLocation.CLASS_OUTPUT;
  94 
  95 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  96 
  97 /** This class could be the main entry point for GJC when GJC is used as a
  98  *  component in a larger software system. It provides operations to
  99  *  construct a new compiler, and to run a new compiler on a set of source
 100  *  files.
 101  *
 102  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 103  *  If you write code that depends on this, you do so at your own risk.
 104  *  This code and its internal interfaces are subject to change or
 105  *  deletion without notice.&lt;/b&gt;
 106  */
 107 public class JavaCompiler {
 108     /** The context key for the compiler. */
 109     public static final Context.Key&lt;JavaCompiler&gt; compilerKey = new Context.Key&lt;&gt;();
 110 
 111     /** Get the JavaCompiler instance for this context. */
 112     public static JavaCompiler instance(Context context) {
 113         JavaCompiler instance = context.get(compilerKey);
 114         if (instance == null)
 115             instance = new JavaCompiler(context);
 116         return instance;
 117     }
 118 
 119     /** The current version number as a string.
 120      */
 121     public static String version() {
 122         return version(&quot;release&quot;);  // mm.nn.oo[-milestone]
 123     }
 124 
 125     /** The current full version number as a string.
 126      */
 127     public static String fullVersion() {
 128         return version(&quot;full&quot;); // mm.mm.oo[-milestone]-build
 129     }
 130 
 131     private static final String versionRBName = &quot;com.sun.tools.javac.resources.version&quot;;
 132     private static ResourceBundle versionRB;
 133 
 134     private static String version(String key) {
 135         if (versionRB == null) {
 136             try {
 137                 versionRB = ResourceBundle.getBundle(versionRBName);
 138             } catch (MissingResourceException e) {
 139                 return Log.getLocalizedString(&quot;version.not.available&quot;);
 140             }
 141         }
 142         try {
 143             return versionRB.getString(key);
 144         }
 145         catch (MissingResourceException e) {
 146             return Log.getLocalizedString(&quot;version.not.available&quot;);
 147         }
 148     }
 149 
 150     /**
 151      * Control how the compiler&#39;s latter phases (attr, flow, desugar, generate)
 152      * are connected. Each individual file is processed by each phase in turn,
 153      * but with different compile policies, you can control the order in which
 154      * each class is processed through its next phase.
 155      *
 156      * &lt;p&gt;Generally speaking, the compiler will &quot;fail fast&quot; in the face of
 157      * errors, although not aggressively so. flow, desugar, etc become no-ops
 158      * once any errors have occurred. No attempt is currently made to determine
 159      * if it might be safe to process a class through its next phase because
 160      * it does not depend on any unrelated errors that might have occurred.
 161      */
 162     protected static enum CompilePolicy {
 163         /**
 164          * Just attribute the parse trees.
 165          */
 166         ATTR_ONLY,
 167 
 168         /**
 169          * Just attribute and do flow analysis on the parse trees.
 170          * This should catch most user errors.
 171          */
 172         CHECK_ONLY,
 173 
 174         /**
 175          * Attribute everything, then do flow analysis for everything,
 176          * then desugar everything, and only then generate output.
 177          * This means no output will be generated if there are any
 178          * errors in any classes.
 179          */
 180         SIMPLE,
 181 
 182         /**
 183          * Groups the classes for each source file together, then process
 184          * each group in a manner equivalent to the {@code SIMPLE} policy.
 185          * This means no output will be generated if there are any
 186          * errors in any of the classes in a source file.
 187          */
 188         BY_FILE,
 189 
 190         /**
 191          * Completely process each entry on the todo list in turn.
 192          * -- this is the same for 1.5.
 193          * Means output might be generated for some classes in a compilation unit
 194          * and not others.
 195          */
 196         BY_TODO;
 197 
 198         static CompilePolicy decode(String option) {
 199             if (option == null)
 200                 return DEFAULT_COMPILE_POLICY;
 201             else if (option.equals(&quot;attr&quot;))
 202                 return ATTR_ONLY;
 203             else if (option.equals(&quot;check&quot;))
 204                 return CHECK_ONLY;
 205             else if (option.equals(&quot;simple&quot;))
 206                 return SIMPLE;
 207             else if (option.equals(&quot;byfile&quot;))
 208                 return BY_FILE;
 209             else if (option.equals(&quot;bytodo&quot;))
 210                 return BY_TODO;
 211             else
 212                 return DEFAULT_COMPILE_POLICY;
 213         }
 214     }
 215 
 216     private static final CompilePolicy DEFAULT_COMPILE_POLICY = CompilePolicy.BY_TODO;
 217 
 218     protected static enum ImplicitSourcePolicy {
 219         /** Don&#39;t generate or process implicitly read source files. */
 220         NONE,
 221         /** Generate classes for implicitly read source files. */
 222         CLASS,
 223         /** Like CLASS, but generate warnings if annotation processing occurs */
 224         UNSET;
 225 
 226         static ImplicitSourcePolicy decode(String option) {
 227             if (option == null)
 228                 return UNSET;
 229             else if (option.equals(&quot;none&quot;))
 230                 return NONE;
 231             else if (option.equals(&quot;class&quot;))
 232                 return CLASS;
 233             else
 234                 return UNSET;
 235         }
 236     }
 237 
 238     /** The log to be used for error reporting.
 239      */
 240     public Log log;
 241 
 242     /** Factory for creating diagnostic objects
 243      */
 244     JCDiagnostic.Factory diagFactory;
 245 
 246     /** The tree factory module.
 247      */
 248     protected TreeMaker make;
 249 
 250     /** The class finder.
 251      */
 252     protected ClassFinder finder;
 253 
 254     /** The class reader.
 255      */
 256     protected ClassReader reader;
 257 
 258     /** The class writer.
 259      */
 260     protected ClassWriter writer;
 261 
 262     /** The native header writer.
 263      */
 264     protected JNIWriter jniWriter;
 265 
 266     /** The module for the symbol table entry phases.
 267      */
 268     protected Enter enter;
 269 
 270     /** The symbol table.
 271      */
 272     protected Symtab syms;
 273 
 274     /** The language version.
 275      */
 276     protected Source source;
 277 
 278     /** The preview language version.
 279      */
 280     protected Preview preview;
 281 
 282     /** The module for code generation.
 283      */
 284     protected Gen gen;
 285 
 286     /** The name table.
 287      */
 288     protected Names names;
 289 
 290     /** The attributor.
 291      */
 292     protected Attr attr;
 293 
 294     /** The analyzer
 295      */
 296     protected Analyzer analyzer;
 297 
 298     /** The attributor.
 299      */
 300     protected Check chk;
 301 
 302     /** The flow analyzer.
 303      */
 304     protected Flow flow;
 305 
 306     /** The modules visitor
 307      */
 308     protected Modules modules;
 309 
 310     /** The module finder
 311      */
 312     protected ModuleFinder moduleFinder;
 313 
 314     /** The diagnostics factory
 315      */
 316     protected JCDiagnostic.Factory diags;
 317 
 318     protected DeferredCompletionFailureHandler dcfh;
 319 
 320     /** The type eraser.
 321      */
 322     protected TransTypes transTypes;
 323 
 324     /** The syntactic sugar desweetener.
 325      */
 326     protected Lower lower;
 327 
 328     /** The annotation annotator.
 329      */
 330     protected Annotate annotate;
 331 
 332     /** Force a completion failure on this name
 333      */
 334     protected final Name completionFailureName;
 335 
 336     /** Type utilities.
 337      */
 338     protected Types types;
 339 
 340     /** Access to file objects.
 341      */
 342     protected JavaFileManager fileManager;
 343 
 344     /** Factory for parsers.
 345      */
 346     protected ParserFactory parserFactory;
 347 
 348     /** Broadcasting listener for progress events
 349      */
 350     protected MultiTaskListener taskListener;
 351 
 352     /**
 353      * SourceCompleter that delegates to the readSourceFile method of this class.
 354      */
 355     protected final Symbol.Completer sourceCompleter =
 356             sym -&gt; readSourceFile((ClassSymbol) sym);
 357 
 358     /**
 359      * Command line options.
 360      */
 361     protected Options options;
 362 
 363     protected Context context;
 364 
 365     /**
 366      * Flag set if any annotation processing occurred.
 367      **/
 368     protected boolean annotationProcessingOccurred;
 369 
 370     /**
 371      * Flag set if any implicit source files read.
 372      **/
 373     protected boolean implicitSourceFilesRead;
 374 
 375     private boolean enterDone;
 376 
 377     protected CompileStates compileStates;
 378 
 379     /** Construct a new compiler using a shared context.
 380      */
 381     public JavaCompiler(Context context) {
 382         this.context = context;
 383         context.put(compilerKey, this);
 384 
 385         // if fileManager not already set, register the JavacFileManager to be used
 386         if (context.get(JavaFileManager.class) == null)
 387             JavacFileManager.preRegister(context);
 388 
 389         names = Names.instance(context);
 390         log = Log.instance(context);
 391         diagFactory = JCDiagnostic.Factory.instance(context);
 392         finder = ClassFinder.instance(context);
 393         reader = ClassReader.instance(context);
 394         make = TreeMaker.instance(context);
 395         writer = ClassWriter.instance(context);
 396         jniWriter = JNIWriter.instance(context);
 397         enter = Enter.instance(context);
 398         todo = Todo.instance(context);
 399 
 400         fileManager = context.get(JavaFileManager.class);
 401         parserFactory = ParserFactory.instance(context);
 402         compileStates = CompileStates.instance(context);
 403 
 404         try {
 405             // catch completion problems with predefineds
 406             syms = Symtab.instance(context);
 407         } catch (CompletionFailure ex) {
 408             // inlined Check.completionError as it is not initialized yet
 409             log.error(Errors.CantAccess(ex.sym, ex.getDetailValue()));
 410         }
 411         source = Source.instance(context);
 412         preview = Preview.instance(context);
 413         attr = Attr.instance(context);
 414         analyzer = Analyzer.instance(context);
 415         chk = Check.instance(context);
 416         gen = Gen.instance(context);
 417         flow = Flow.instance(context);
 418         transTypes = TransTypes.instance(context);
 419         lower = Lower.instance(context);
 420         annotate = Annotate.instance(context);
 421         types = Types.instance(context);
 422         taskListener = MultiTaskListener.instance(context);
 423         modules = Modules.instance(context);
 424         moduleFinder = ModuleFinder.instance(context);
 425         diags = Factory.instance(context);
 426         dcfh = DeferredCompletionFailureHandler.instance(context);
 427 
 428         finder.sourceCompleter = sourceCompleter;
 429         modules.findPackageInFile = this::findPackageInFile;
 430         moduleFinder.moduleNameFromSourceReader = this::readModuleName;
 431 
 432         options = Options.instance(context);
 433 
 434         verbose       = options.isSet(VERBOSE);
 435         sourceOutput  = options.isSet(PRINTSOURCE); // used to be -s
 436         lineDebugInfo = options.isUnset(G_CUSTOM) ||
 437                         options.isSet(G_CUSTOM, &quot;lines&quot;);
 438         genEndPos     = options.isSet(XJCOV) ||
 439                         context.get(DiagnosticListener.class) != null;
 440         devVerbose    = options.isSet(&quot;dev&quot;);
 441         processPcks   = options.isSet(&quot;process.packages&quot;);
 442         werror        = options.isSet(WERROR);
 443 
 444         verboseCompilePolicy = options.isSet(&quot;verboseCompilePolicy&quot;);
 445 
 446         if (options.isSet(&quot;should-stop.at&quot;) &amp;&amp;
 447             CompileState.valueOf(options.get(&quot;should-stop.at&quot;)) == CompileState.ATTR)
 448             compilePolicy = CompilePolicy.ATTR_ONLY;
 449         else
 450             compilePolicy = CompilePolicy.decode(options.get(&quot;compilePolicy&quot;));
 451 
 452         implicitSourcePolicy = ImplicitSourcePolicy.decode(options.get(&quot;-implicit&quot;));
 453 
 454         completionFailureName =
 455             options.isSet(&quot;failcomplete&quot;)
 456             ? names.fromString(options.get(&quot;failcomplete&quot;))
 457             : null;
 458 
 459         shouldStopPolicyIfError =
 460             options.isSet(&quot;should-stop.at&quot;) // backwards compatible
 461             ? CompileState.valueOf(options.get(&quot;should-stop.at&quot;))
 462             : options.isSet(&quot;should-stop.ifError&quot;)
 463             ? CompileState.valueOf(options.get(&quot;should-stop.ifError&quot;))
 464             : CompileState.INIT;
 465         shouldStopPolicyIfNoError =
 466             options.isSet(&quot;should-stop.ifNoError&quot;)
 467             ? CompileState.valueOf(options.get(&quot;should-stop.ifNoError&quot;))
 468             : CompileState.GENERATE;
 469 
 470         if (options.isUnset(&quot;diags.legacy&quot;))
 471             log.setDiagnosticFormatter(RichDiagnosticFormatter.instance(context));
 472 
 473         PlatformDescription platformProvider = context.get(PlatformDescription.class);
 474 
 475         if (platformProvider != null)
 476             closeables = closeables.prepend(platformProvider);
 477 
 478         silentFail = new Symbol(ABSENT_TYP, 0, names.empty, Type.noType, syms.rootPackage) {
 479             @DefinedBy(Api.LANGUAGE_MODEL)
 480             public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 481                 return v.visitUnknown(this, p);
 482             }
 483             @Override
 484             public boolean exists() {
 485                 return false;
 486             }
 487         };
 488 
 489     }
 490 
 491     /* Switches:
 492      */
 493 
 494     /** Verbose output.
 495      */
 496     public boolean verbose;
 497 
 498     /** Emit plain Java source files rather than class files.
 499      */
 500     public boolean sourceOutput;
 501 
 502 
 503     /** Generate code with the LineNumberTable attribute for debugging
 504      */
 505     public boolean lineDebugInfo;
 506 
 507     /** Switch: should we store the ending positions?
 508      */
 509     public boolean genEndPos;
 510 
 511     /** Switch: should we debug ignored exceptions
 512      */
 513     protected boolean devVerbose;
 514 
 515     /** Switch: should we (annotation) process packages as well
 516      */
 517     protected boolean processPcks;
 518 
 519     /** Switch: treat warnings as errors
 520      */
 521     protected boolean werror;
 522 
 523     /** Switch: is annotation processing requested explicitly via
 524      * CompilationTask.setProcessors?
 525      */
 526     protected boolean explicitAnnotationProcessingRequested = false;
 527 
 528     /**
 529      * The policy for the order in which to perform the compilation
 530      */
 531     protected CompilePolicy compilePolicy;
 532 
 533     /**
 534      * The policy for what to do with implicitly read source files
 535      */
 536     protected ImplicitSourcePolicy implicitSourcePolicy;
 537 
 538     /**
 539      * Report activity related to compilePolicy
 540      */
 541     public boolean verboseCompilePolicy;
 542 
 543     /**
 544      * Policy of how far to continue compilation after errors have occurred.
 545      * Set this to minimum CompileState (INIT) to stop as soon as possible
 546      * after errors.
 547      */
 548     public CompileState shouldStopPolicyIfError;
 549 
 550     /**
 551      * Policy of how far to continue compilation when no errors have occurred.
 552      * Set this to maximum CompileState (GENERATE) to perform full compilation.
 553      * Set this lower to perform partial compilation, such as -proc:only.
 554      */
 555     public CompileState shouldStopPolicyIfNoError;
 556 
 557     /** A queue of all as yet unattributed classes.
 558      */
 559     public Todo todo;
 560 
 561     /** A list of items to be closed when the compilation is complete.
 562      */
 563     public List&lt;Closeable&gt; closeables = List.nil();
 564 
 565     /** The set of currently compiled inputfiles, needed to ensure
 566      *  we don&#39;t accidentally overwrite an input file when -s is set.
 567      *  initialized by `compile&#39;.
 568      */
 569     protected Set&lt;JavaFileObject&gt; inputFiles = new HashSet&lt;&gt;();
 570 
 571     /** Used by the resolveBinaryNameOrIdent to say that the given type cannot be found, and that
 572      *  an error has already been produced about that.
 573      */
 574     private final Symbol silentFail;
 575 
 576     protected boolean shouldStop(CompileState cs) {
 577         CompileState shouldStopPolicy = (errorCount() &gt; 0 || unrecoverableError())
 578             ? shouldStopPolicyIfError
 579             : shouldStopPolicyIfNoError;
 580         return cs.isAfter(shouldStopPolicy);
 581     }
 582 
 583     /** The number of errors reported so far.
 584      */
 585     public int errorCount() {
 586         if (werror &amp;&amp; log.nerrors == 0 &amp;&amp; log.nwarnings &gt; 0) {
 587             log.error(Errors.WarningsAndWerror);
 588         }
 589         return log.nerrors;
 590     }
 591 
 592     protected final &lt;T&gt; Queue&lt;T&gt; stopIfError(CompileState cs, Queue&lt;T&gt; queue) {
 593         return shouldStop(cs) ? new ListBuffer&lt;T&gt;() : queue;
 594     }
 595 
 596     protected final &lt;T&gt; List&lt;T&gt; stopIfError(CompileState cs, List&lt;T&gt; list) {
 597         return shouldStop(cs) ? List.nil() : list;
 598     }
 599 
 600     /** The number of warnings reported so far.
 601      */
 602     public int warningCount() {
 603         return log.nwarnings;
 604     }
 605 
 606     /** Try to open input stream with given name.
 607      *  Report an error if this fails.
 608      *  @param filename   The file name of the input stream to be opened.
 609      */
 610     public CharSequence readSource(JavaFileObject filename) {
 611         try {
 612             inputFiles.add(filename);
 613             return filename.getCharContent(false);
 614         } catch (IOException e) {
 615             log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 616             return null;
 617         }
 618     }
 619 
 620     /** Parse contents of input stream.
 621      *  @param filename     The name of the file from which input stream comes.
 622      *  @param content      The characters to be parsed.
 623      */
 624     protected JCCompilationUnit parse(JavaFileObject filename, CharSequence content) {
 625         long msec = now();
 626         JCCompilationUnit tree = make.TopLevel(List.nil());
 627         if (content != null) {
 628             if (verbose) {
 629                 log.printVerbose(&quot;parsing.started&quot;, filename);
 630             }
 631             if (!taskListener.isEmpty()) {
 632                 TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, filename);
 633                 taskListener.started(e);
 634                 keepComments = true;
 635                 genEndPos = true;
 636             }
 637             Parser parser = parserFactory.newParser(content, keepComments(), genEndPos,
 638                                 lineDebugInfo, filename.isNameCompatible(&quot;module-info&quot;, Kind.SOURCE));
 639             tree = parser.parseCompilationUnit();
 640             if (verbose) {
 641                 log.printVerbose(&quot;parsing.done&quot;, Long.toString(elapsed(msec)));
 642             }
 643         }
 644 
 645         tree.sourcefile = filename;
 646 
 647         if (content != null &amp;&amp; !taskListener.isEmpty()) {
 648             TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, tree);
 649             taskListener.finished(e);
 650         }
 651 
 652         return tree;
 653     }
 654     // where
 655         public boolean keepComments = false;
 656         protected boolean keepComments() {
 657             return keepComments || sourceOutput;
 658         }
 659 
 660 
 661     /** Parse contents of file.
 662      *  @param filename     The name of the file to be parsed.
 663      */
 664     @Deprecated
 665     public JCTree.JCCompilationUnit parse(String filename) {
 666         JavacFileManager fm = (JavacFileManager)fileManager;
 667         return parse(fm.getJavaFileObjectsFromStrings(List.of(filename)).iterator().next());
 668     }
 669 
 670     /** Parse contents of file.
 671      *  @param filename     The name of the file to be parsed.
 672      */
 673     public JCTree.JCCompilationUnit parse(JavaFileObject filename) {
 674         JavaFileObject prev = log.useSource(filename);
 675         try {
 676             JCTree.JCCompilationUnit t = parse(filename, readSource(filename));
 677             if (t.endPositions != null)
 678                 log.setEndPosTable(filename, t.endPositions);
 679             return t;
 680         } finally {
 681             log.useSource(prev);
 682         }
 683     }
 684 
 685     /** Resolve an identifier which may be the binary name of a class or
 686      * the Java name of a class or package.
 687      * @param name      The name to resolve
 688      */
 689     public Symbol resolveBinaryNameOrIdent(String name) {
 690         ModuleSymbol msym;
 691         String typeName;
 692         int sep = name.indexOf(&#39;/&#39;);
 693         if (sep == -1) {
 694             msym = modules.getDefaultModule();
 695             typeName = name;
 696         } else if (Feature.MODULES.allowedInSource(source)) {
 697             Name modName = names.fromString(name.substring(0, sep));
 698 
 699             msym = moduleFinder.findModule(modName);
 700             typeName = name.substring(sep + 1);
 701         } else {
 702             log.error(Errors.InvalidModuleSpecifier(name));
 703             return silentFail;
 704         }
 705 
 706         return resolveBinaryNameOrIdent(msym, typeName);
 707     }
 708 
 709     /** Resolve an identifier which may be the binary name of a class or
 710      * the Java name of a class or package.
 711      * @param msym      The module in which the search should be performed
 712      * @param name      The name to resolve
 713      */
 714     public Symbol resolveBinaryNameOrIdent(ModuleSymbol msym, String name) {
 715         try {
 716             Name flatname = names.fromString(name.replace(&quot;/&quot;, &quot;.&quot;));
 717             return finder.loadClass(msym, flatname);
 718         } catch (CompletionFailure ignore) {
 719             return resolveIdent(msym, name);
 720         }
 721     }
 722 
 723     /** Resolve an identifier.
 724      * @param msym      The module in which the search should be performed
 725      * @param name      The identifier to resolve
 726      */
 727     public Symbol resolveIdent(ModuleSymbol msym, String name) {
 728         if (name.equals(&quot;&quot;))
 729             return syms.errSymbol;
 730         JavaFileObject prev = log.useSource(null);
 731         try {
 732             JCExpression tree = null;
 733             for (String s : name.split(&quot;\\.&quot;, -1)) {
 734                 if (!SourceVersion.isIdentifier(s)) // TODO: check for keywords
 735                     return syms.errSymbol;
 736                 tree = (tree == null) ? make.Ident(names.fromString(s))
 737                                       : make.Select(tree, names.fromString(s));
 738             }
 739             JCCompilationUnit toplevel =
 740                 make.TopLevel(List.nil());
 741             toplevel.modle = msym;
 742             toplevel.packge = msym.unnamedPackage;
 743             return attr.attribIdent(tree, toplevel);
 744         } finally {
 745             log.useSource(prev);
 746         }
 747     }
 748 
 749     /** Generate code and emit a class file for a given class
 750      *  @param env    The attribution environment of the outermost class
 751      *                containing this class.
 752      *  @param cdef   The class definition from which code is generated.
 753      */
 754     JavaFileObject genCode(Env&lt;AttrContext&gt; env, JCClassDecl cdef) throws IOException {
 755         try {
 756             if (gen.genClass(env, cdef) &amp;&amp; (errorCount() == 0))
 757                 return writer.writeClass(cdef.sym);
 758         } catch (ClassWriter.PoolOverflow ex) {
 759             log.error(cdef.pos(), Errors.LimitPool);
 760         } catch (ClassWriter.StringOverflow ex) {
 761             log.error(cdef.pos(),
 762                       Errors.LimitStringOverflow(ex.value.substring(0, 20)));
 763         } catch (CompletionFailure ex) {
 764             chk.completionError(cdef.pos(), ex);
 765         }
 766         return null;
 767     }
 768 
 769     /** Emit plain Java source for a class.
 770      *  @param env    The attribution environment of the outermost class
 771      *                containing this class.
 772      *  @param cdef   The class definition to be printed.
 773      */
 774     JavaFileObject printSource(Env&lt;AttrContext&gt; env, JCClassDecl cdef) throws IOException {
 775         JavaFileObject outFile
 776            = fileManager.getJavaFileForOutput(CLASS_OUTPUT,
 777                                                cdef.sym.flatname.toString(),
 778                                                JavaFileObject.Kind.SOURCE,
 779                                                null);
 780         if (inputFiles.contains(outFile)) {
 781             log.error(cdef.pos(), Errors.SourceCantOverwriteInputFile(outFile));
 782             return null;
 783         } else {
 784             try (BufferedWriter out = new BufferedWriter(outFile.openWriter())) {
 785                 new Pretty(out, true).printUnit(env.toplevel, cdef);
 786                 if (verbose)
 787                     log.printVerbose(&quot;wrote.file&quot;, outFile.getName());
 788             }
 789             return outFile;
 790         }
 791     }
 792 
 793     /** Compile a source file that has been accessed by the class finder.
 794      *  @param c          The class the source file of which needs to be compiled.
 795      */
 796     private void readSourceFile(ClassSymbol c) throws CompletionFailure {
 797         readSourceFile(null, c);
 798     }
 799 
 800     /** Compile a ClassSymbol from source, optionally using the given compilation unit as
 801      *  the source tree.
 802      *  @param tree the compilation unit in which the given ClassSymbol resides,
 803      *              or null if should be parsed from source
 804      *  @param c    the ClassSymbol to complete
 805      */
 806     public void readSourceFile(JCCompilationUnit tree, ClassSymbol c) throws CompletionFailure {
 807         if (completionFailureName == c.fullname) {
<a name="2" id="anc2"></a><span class="line-modified"> 808             JCDiagnostic msg =</span>
<span class="line-modified"> 809                     diagFactory.fragment(Fragments.UserSelectedCompletionFailure);</span>
<span class="line-removed"> 810             throw new CompletionFailure(c, msg, dcfh);</span>
 811         }
 812         JavaFileObject filename = c.classfile;
 813         JavaFileObject prev = log.useSource(filename);
 814 
 815         if (tree == null) {
 816             try {
 817                 tree = parse(filename, filename.getCharContent(false));
 818             } catch (IOException e) {
 819                 log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 820                 tree = make.TopLevel(List.&lt;JCTree&gt;nil());
 821             } finally {
 822                 log.useSource(prev);
 823             }
 824         }
 825 
 826         if (!taskListener.isEmpty()) {
 827             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 828             taskListener.started(e);
 829         }
 830 
 831         // Process module declarations.
 832         // If module resolution fails, ignore trees, and if trying to
 833         // complete a specific symbol, throw CompletionFailure.
 834         // Note that if module resolution failed, we may not even
 835         // have enough modules available to access java.lang, and
 836         // so risk getting FatalError(&quot;no.java.lang&quot;) from MemberEnter.
 837         if (!modules.enter(List.of(tree), c)) {
<a name="3" id="anc3"></a><span class="line-modified"> 838             throw new CompletionFailure(c, diags.fragment(Fragments.CantResolveModules), dcfh);</span>
 839         }
 840 
 841         enter.complete(List.of(tree), c);
 842 
 843         if (!taskListener.isEmpty()) {
 844             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 845             taskListener.finished(e);
 846         }
 847 
 848         if (enter.getEnv(c) == null) {
 849             boolean isPkgInfo =
 850                 tree.sourcefile.isNameCompatible(&quot;package-info&quot;,
 851                                                  JavaFileObject.Kind.SOURCE);
 852             boolean isModuleInfo =
 853                 tree.sourcefile.isNameCompatible(&quot;module-info&quot;,
 854                                                  JavaFileObject.Kind.SOURCE);
 855             if (isModuleInfo) {
 856                 if (enter.getEnv(tree.modle) == null) {
 857                     JCDiagnostic diag =
 858                         diagFactory.fragment(Fragments.FileDoesNotContainModule);
 859                     throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 860                 }
 861             } else if (isPkgInfo) {
 862                 if (enter.getEnv(tree.packge) == null) {
 863                     JCDiagnostic diag =
 864                         diagFactory.fragment(Fragments.FileDoesNotContainPackage(c.location()));
 865                     throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 866                 }
 867             } else {
 868                 JCDiagnostic diag =
 869                         diagFactory.fragment(Fragments.FileDoesntContainClass(c.getQualifiedName()));
 870                 throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 871             }
 872         }
 873 
 874         implicitSourceFilesRead = true;
 875     }
 876 
 877     /** Track when the JavaCompiler has been used to compile something. */
 878     private boolean hasBeenUsed = false;
 879     private long start_msec = 0;
 880     public long elapsed_msec = 0;
 881 
 882     public void compile(List&lt;JavaFileObject&gt; sourceFileObject)
 883         throws Throwable {
 884         compile(sourceFileObject, List.nil(), null, List.nil());
 885     }
 886 
 887     /**
 888      * Main method: compile a list of files, return all compiled classes
 889      *
 890      * @param sourceFileObjects file objects to be compiled
 891      * @param classnames class names to process for annotations
 892      * @param processors user provided annotation processors to bypass
 893      * discovery, {@code null} means that no processors were provided
 894      * @param addModules additional root modules to be used during
 895      * module resolution.
 896      */
 897     public void compile(Collection&lt;JavaFileObject&gt; sourceFileObjects,
 898                         Collection&lt;String&gt; classnames,
 899                         Iterable&lt;? extends Processor&gt; processors,
 900                         Collection&lt;String&gt; addModules)
 901     {
 902         if (!taskListener.isEmpty()) {
 903             taskListener.started(new TaskEvent(TaskEvent.Kind.COMPILATION));
 904         }
 905 
 906         if (processors != null &amp;&amp; processors.iterator().hasNext())
 907             explicitAnnotationProcessingRequested = true;
 908         // as a JavaCompiler can only be used once, throw an exception if
 909         // it has been used before.
 910         if (hasBeenUsed)
 911             checkReusable();
 912         hasBeenUsed = true;
 913 
 914         // forcibly set the equivalent of -Xlint:-options, so that no further
 915         // warnings about command line options are generated from this point on
 916         options.put(XLINT_CUSTOM.primaryName + &quot;-&quot; + LintCategory.OPTIONS.option, &quot;true&quot;);
 917         options.remove(XLINT_CUSTOM.primaryName + LintCategory.OPTIONS.option);
 918 
 919         start_msec = now();
 920 
 921         try {
 922             initProcessAnnotations(processors, sourceFileObjects, classnames);
 923 
 924             for (String className : classnames) {
 925                 int sep = className.indexOf(&#39;/&#39;);
 926                 if (sep != -1) {
 927                     modules.addExtraAddModules(className.substring(0, sep));
 928                 }
 929             }
 930 
 931             for (String moduleName : addModules) {
 932                 modules.addExtraAddModules(moduleName);
 933             }
 934 
 935             // These method calls must be chained to avoid memory leaks
 936             processAnnotations(
 937                 enterTrees(
 938                         stopIfError(CompileState.PARSE,
 939                                 initModules(stopIfError(CompileState.PARSE, parseFiles(sourceFileObjects))))
 940                 ),
 941                 classnames
 942             );
 943 
 944             // If it&#39;s safe to do so, skip attr / flow / gen for implicit classes
 945             if (taskListener.isEmpty() &amp;&amp;
 946                     implicitSourcePolicy == ImplicitSourcePolicy.NONE) {
 947                 todo.retainFiles(inputFiles);
 948             }
 949 
 950             switch (compilePolicy) {
 951             case ATTR_ONLY:
 952                 attribute(todo);
 953                 break;
 954 
 955             case CHECK_ONLY:
 956                 flow(attribute(todo));
 957                 break;
 958 
 959             case SIMPLE:
 960                 generate(desugar(flow(attribute(todo))));
 961                 break;
 962 
 963             case BY_FILE: {
 964                     Queue&lt;Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; q = todo.groupByFile();
 965                     while (!q.isEmpty() &amp;&amp; !shouldStop(CompileState.ATTR)) {
 966                         generate(desugar(flow(attribute(q.remove()))));
 967                     }
 968                 }
 969                 break;
 970 
 971             case BY_TODO:
 972                 while (!todo.isEmpty())
 973                     generate(desugar(flow(attribute(todo.remove()))));
 974                 break;
 975 
 976             default:
 977                 Assert.error(&quot;unknown compile policy&quot;);
 978             }
 979         } catch (Abort ex) {
 980             if (devVerbose)
 981                 ex.printStackTrace(System.err);
 982         } finally {
 983             if (verbose) {
 984                 elapsed_msec = elapsed(start_msec);
 985                 log.printVerbose(&quot;total&quot;, Long.toString(elapsed_msec));
 986             }
 987 
 988             reportDeferredDiagnostics();
 989 
 990             if (!log.hasDiagnosticListener()) {
 991                 printCount(&quot;error&quot;, errorCount());
 992                 printCount(&quot;warn&quot;, warningCount());
<a name="4" id="anc4"></a>

 993             }
 994             if (!taskListener.isEmpty()) {
 995                 taskListener.finished(new TaskEvent(TaskEvent.Kind.COMPILATION));
 996             }
 997             close();
 998             if (procEnvImpl != null)
 999                 procEnvImpl.close();
1000         }
1001     }
1002 
1003     protected void checkReusable() {
1004         throw new AssertionError(&quot;attempt to reuse JavaCompiler&quot;);
1005     }
1006 
1007     /**
1008      * The list of classes explicitly supplied on the command line for compilation.
1009      * Not always populated.
1010      */
1011     private List&lt;JCClassDecl&gt; rootClasses;
1012 
1013     /**
1014      * Parses a list of files.
1015      */
1016    public List&lt;JCCompilationUnit&gt; parseFiles(Iterable&lt;JavaFileObject&gt; fileObjects) {
1017        return parseFiles(fileObjects, false);
1018    }
1019 
1020    public List&lt;JCCompilationUnit&gt; parseFiles(Iterable&lt;JavaFileObject&gt; fileObjects, boolean force) {
1021        if (!force &amp;&amp; shouldStop(CompileState.PARSE))
1022            return List.nil();
1023 
1024         //parse all files
1025         ListBuffer&lt;JCCompilationUnit&gt; trees = new ListBuffer&lt;&gt;();
1026         Set&lt;JavaFileObject&gt; filesSoFar = new HashSet&lt;&gt;();
1027         for (JavaFileObject fileObject : fileObjects) {
1028             if (!filesSoFar.contains(fileObject)) {
1029                 filesSoFar.add(fileObject);
1030                 trees.append(parse(fileObject));
1031             }
1032         }
1033         return trees.toList();
1034     }
1035 
1036     /**
1037      * Enter the symbols found in a list of parse trees if the compilation
1038      * is expected to proceed beyond anno processing into attr.
1039      * As a side-effect, this puts elements on the &quot;todo&quot; list.
1040      * Also stores a list of all top level classes in rootClasses.
1041      */
1042     public List&lt;JCCompilationUnit&gt; enterTreesIfNeeded(List&lt;JCCompilationUnit&gt; roots) {
1043        if (shouldStop(CompileState.ATTR))
1044            return List.nil();
1045         return enterTrees(initModules(roots));
1046     }
1047 
1048     public List&lt;JCCompilationUnit&gt; initModules(List&lt;JCCompilationUnit&gt; roots) {
1049         modules.initModules(roots);
1050         if (roots.isEmpty()) {
1051             enterDone();
1052         }
1053         return roots;
1054     }
1055 
1056     /**
1057      * Enter the symbols found in a list of parse trees.
1058      * As a side-effect, this puts elements on the &quot;todo&quot; list.
1059      * Also stores a list of all top level classes in rootClasses.
1060      */
1061     public List&lt;JCCompilationUnit&gt; enterTrees(List&lt;JCCompilationUnit&gt; roots) {
1062         //enter symbols for all files
1063         if (!taskListener.isEmpty()) {
1064             for (JCCompilationUnit unit: roots) {
1065                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
1066                 taskListener.started(e);
1067             }
1068         }
1069 
1070         enter.main(roots);
1071 
1072         enterDone();
1073 
1074         if (!taskListener.isEmpty()) {
1075             for (JCCompilationUnit unit: roots) {
1076                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
1077                 taskListener.finished(e);
1078             }
1079         }
1080 
1081         // If generating source, or if tracking public apis,
1082         // then remember the classes declared in
1083         // the original compilation units listed on the command line.
1084         if (sourceOutput) {
1085             ListBuffer&lt;JCClassDecl&gt; cdefs = new ListBuffer&lt;&gt;();
1086             for (JCCompilationUnit unit : roots) {
1087                 for (List&lt;JCTree&gt; defs = unit.defs;
1088                      defs.nonEmpty();
1089                      defs = defs.tail) {
1090                     if (defs.head instanceof JCClassDecl)
1091                         cdefs.append((JCClassDecl)defs.head);
1092                 }
1093             }
1094             rootClasses = cdefs.toList();
1095         }
1096 
1097         // Ensure the input files have been recorded. Although this is normally
1098         // done by readSource, it may not have been done if the trees were read
1099         // in a prior round of annotation processing, and the trees have been
1100         // cleaned and are being reused.
1101         for (JCCompilationUnit unit : roots) {
1102             inputFiles.add(unit.sourcefile);
1103         }
1104 
1105         return roots;
1106     }
1107 
1108     /**
1109      * Set to true to enable skeleton annotation processing code.
1110      * Currently, we assume this variable will be replaced more
1111      * advanced logic to figure out if annotation processing is
1112      * needed.
1113      */
1114     boolean processAnnotations = false;
1115 
1116     Log.DeferredDiagnosticHandler deferredDiagnosticHandler;
1117 
1118     /**
1119      * Object to handle annotation processing.
1120      */
1121     private JavacProcessingEnvironment procEnvImpl = null;
1122 
1123     /**
1124      * Check if we should process annotations.
1125      * If so, and if no scanner is yet registered, then set up the DocCommentScanner
1126      * to catch doc comments, and set keepComments so the parser records them in
1127      * the compilation unit.
1128      *
1129      * @param processors user provided annotation processors to bypass
1130      * discovery, {@code null} means that no processors were provided
1131      */
1132     public void initProcessAnnotations(Iterable&lt;? extends Processor&gt; processors,
1133                                        Collection&lt;? extends JavaFileObject&gt; initialFiles,
1134                                        Collection&lt;String&gt; initialClassNames) {
1135         // Process annotations if processing is not disabled and there
1136         // is at least one Processor available.
1137         if (options.isSet(PROC, &quot;none&quot;)) {
1138             processAnnotations = false;
1139         } else if (procEnvImpl == null) {
1140             procEnvImpl = JavacProcessingEnvironment.instance(context);
1141             procEnvImpl.setProcessors(processors);
1142             processAnnotations = procEnvImpl.atLeastOneProcessor();
1143 
1144             if (processAnnotations) {
1145                 options.put(&quot;parameters&quot;, &quot;parameters&quot;);
1146                 reader.saveParameterNames = true;
1147                 keepComments = true;
1148                 genEndPos = true;
1149                 if (!taskListener.isEmpty())
1150                     taskListener.started(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING));
1151                 deferredDiagnosticHandler = new Log.DeferredDiagnosticHandler(log);
1152                 procEnvImpl.getFiler().setInitialState(initialFiles, initialClassNames);
1153             } else { // free resources
1154                 procEnvImpl.close();
1155             }
1156         }
1157     }
1158 
1159     // TODO: called by JavacTaskImpl
1160     public void processAnnotations(List&lt;JCCompilationUnit&gt; roots) {
1161         processAnnotations(roots, List.nil());
1162     }
1163 
1164     /**
1165      * Process any annotations found in the specified compilation units.
1166      * @param roots a list of compilation units
1167      */
1168     // Implementation note: when this method is called, log.deferredDiagnostics
1169     // will have been set true by initProcessAnnotations, meaning that any diagnostics
1170     // that are reported will go into the log.deferredDiagnostics queue.
1171     // By the time this method exits, log.deferDiagnostics must be set back to false,
1172     // and all deferredDiagnostics must have been handled: i.e. either reported
1173     // or determined to be transient, and therefore suppressed.
1174     public void processAnnotations(List&lt;JCCompilationUnit&gt; roots,
1175                                    Collection&lt;String&gt; classnames) {
1176         if (shouldStop(CompileState.PROCESS)) {
1177             // Errors were encountered.
1178             // Unless all the errors are resolve errors, the errors were parse errors
1179             // or other errors during enter which cannot be fixed by running
1180             // any annotation processors.
1181             if (unrecoverableError()) {
1182                 deferredDiagnosticHandler.reportDeferredDiagnostics();
1183                 log.popDiagnosticHandler(deferredDiagnosticHandler);
1184                 return ;
1185             }
1186         }
1187 
1188         // ASSERT: processAnnotations and procEnvImpl should have been set up by
1189         // by initProcessAnnotations
1190 
1191         // NOTE: The !classnames.isEmpty() checks should be refactored to Main.
1192 
1193         if (!processAnnotations) {
1194             // If there are no annotation processors present, and
1195             // annotation processing is to occur with compilation,
1196             // emit a warning.
1197             if (options.isSet(PROC, &quot;only&quot;)) {
1198                 log.warning(Warnings.ProcProcOnlyRequestedNoProcs);
1199                 todo.clear();
1200             }
1201             // If not processing annotations, classnames must be empty
1202             if (!classnames.isEmpty()) {
1203                 log.error(Errors.ProcNoExplicitAnnotationProcessingRequested(classnames));
1204             }
1205             Assert.checkNull(deferredDiagnosticHandler);
1206             return ; // continue regular compilation
1207         }
1208 
1209         Assert.checkNonNull(deferredDiagnosticHandler);
1210 
1211         try {
1212             List&lt;ClassSymbol&gt; classSymbols = List.nil();
1213             List&lt;PackageSymbol&gt; pckSymbols = List.nil();
1214             if (!classnames.isEmpty()) {
1215                  // Check for explicit request for annotation
1216                  // processing
1217                 if (!explicitAnnotationProcessingRequested()) {
1218                     log.error(Errors.ProcNoExplicitAnnotationProcessingRequested(classnames));
1219                     deferredDiagnosticHandler.reportDeferredDiagnostics();
1220                     log.popDiagnosticHandler(deferredDiagnosticHandler);
1221                     return ; // TODO: Will this halt compilation?
1222                 } else {
1223                     boolean errors = false;
1224                     for (String nameStr : classnames) {
1225                         Symbol sym = resolveBinaryNameOrIdent(nameStr);
1226                         if (sym == null ||
1227                             (sym.kind == PCK &amp;&amp; !processPcks) ||
1228                             sym.kind == ABSENT_TYP) {
1229                             if (sym != silentFail)
1230                                 log.error(Errors.ProcCantFindClass(nameStr));
1231                             errors = true;
1232                             continue;
1233                         }
1234                         try {
1235                             if (sym.kind == PCK)
1236                                 sym.complete();
1237                             if (sym.exists()) {
1238                                 if (sym.kind == PCK)
1239                                     pckSymbols = pckSymbols.prepend((PackageSymbol)sym);
1240                                 else
1241                                     classSymbols = classSymbols.prepend((ClassSymbol)sym);
1242                                 continue;
1243                             }
1244                             Assert.check(sym.kind == PCK);
1245                             log.warning(Warnings.ProcPackageDoesNotExist(nameStr));
1246                             pckSymbols = pckSymbols.prepend((PackageSymbol)sym);
1247                         } catch (CompletionFailure e) {
1248                             log.error(Errors.ProcCantFindClass(nameStr));
1249                             errors = true;
1250                             continue;
1251                         }
1252                     }
1253                     if (errors) {
1254                         deferredDiagnosticHandler.reportDeferredDiagnostics();
1255                         log.popDiagnosticHandler(deferredDiagnosticHandler);
1256                         return ;
1257                     }
1258                 }
1259             }
1260             try {
1261                 annotationProcessingOccurred =
1262                         procEnvImpl.doProcessing(roots,
1263                                                  classSymbols,
1264                                                  pckSymbols,
1265                                                  deferredDiagnosticHandler);
1266                 // doProcessing will have handled deferred diagnostics
1267             } finally {
1268                 procEnvImpl.close();
1269             }
1270         } catch (CompletionFailure ex) {
1271             log.error(Errors.CantAccess(ex.sym, ex.getDetailValue()));
1272             if (deferredDiagnosticHandler != null) {
1273                 deferredDiagnosticHandler.reportDeferredDiagnostics();
1274                 log.popDiagnosticHandler(deferredDiagnosticHandler);
1275             }
1276         }
1277     }
1278 
1279     private boolean unrecoverableError() {
1280         if (deferredDiagnosticHandler != null) {
1281             for (JCDiagnostic d: deferredDiagnosticHandler.getDiagnostics()) {
1282                 if (d.getKind() == JCDiagnostic.Kind.ERROR &amp;&amp; !d.isFlagSet(RECOVERABLE))
1283                     return true;
1284             }
1285         }
1286         return false;
1287     }
1288 
1289     boolean explicitAnnotationProcessingRequested() {
1290         return
1291             explicitAnnotationProcessingRequested ||
1292             explicitAnnotationProcessingRequested(options);
1293     }
1294 
1295     static boolean explicitAnnotationProcessingRequested(Options options) {
1296         return
1297             options.isSet(PROCESSOR) ||
1298             options.isSet(PROCESSOR_PATH) ||
1299             options.isSet(PROCESSOR_MODULE_PATH) ||
1300             options.isSet(PROC, &quot;only&quot;) ||
1301             options.isSet(XPRINT);
1302     }
1303 
1304     public void setDeferredDiagnosticHandler(Log.DeferredDiagnosticHandler deferredDiagnosticHandler) {
1305         this.deferredDiagnosticHandler = deferredDiagnosticHandler;
1306     }
1307 
1308     /**
1309      * Attribute a list of parse trees, such as found on the &quot;todo&quot; list.
1310      * Note that attributing classes may cause additional files to be
1311      * parsed and entered via the SourceCompleter.
1312      * Attribution of the entries in the list does not stop if any errors occur.
1313      * @return a list of environments for attribute classes.
1314      */
1315     public Queue&lt;Env&lt;AttrContext&gt;&gt; attribute(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1316         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1317         while (!envs.isEmpty())
1318             results.append(attribute(envs.remove()));
1319         return stopIfError(CompileState.ATTR, results);
1320     }
1321 
1322     /**
1323      * Attribute a parse tree.
1324      * @return the attributed parse tree
1325      */
1326     public Env&lt;AttrContext&gt; attribute(Env&lt;AttrContext&gt; env) {
1327         if (compileStates.isDone(env, CompileState.ATTR))
1328             return env;
1329 
1330         if (verboseCompilePolicy)
1331             printNote(&quot;[attribute &quot; + env.enclClass.sym + &quot;]&quot;);
1332         if (verbose)
1333             log.printVerbose(&quot;checking.attribution&quot;, env.enclClass.sym);
1334 
1335         if (!taskListener.isEmpty()) {
1336             TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
1337             taskListener.started(e);
1338         }
1339 
1340         JavaFileObject prev = log.useSource(
1341                                   env.enclClass.sym.sourcefile != null ?
1342                                   env.enclClass.sym.sourcefile :
1343                                   env.toplevel.sourcefile);
1344         try {
1345             attr.attrib(env);
1346             if (errorCount() &gt; 0 &amp;&amp; !shouldStop(CompileState.ATTR)) {
1347                 //if in fail-over mode, ensure that AST expression nodes
1348                 //are correctly initialized (e.g. they have a type/symbol)
1349                 attr.postAttr(env.tree);
1350             }
1351             compileStates.put(env, CompileState.ATTR);
1352         }
1353         finally {
1354             log.useSource(prev);
1355         }
1356 
1357         return env;
1358     }
1359 
1360     /**
1361      * Perform dataflow checks on attributed parse trees.
1362      * These include checks for definite assignment and unreachable statements.
1363      * If any errors occur, an empty list will be returned.
1364      * @return the list of attributed parse trees
1365      */
1366     public Queue&lt;Env&lt;AttrContext&gt;&gt; flow(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1367         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1368         for (Env&lt;AttrContext&gt; env: envs) {
1369             flow(env, results);
1370         }
1371         return stopIfError(CompileState.FLOW, results);
1372     }
1373 
1374     /**
1375      * Perform dataflow checks on an attributed parse tree.
1376      */
1377     public Queue&lt;Env&lt;AttrContext&gt;&gt; flow(Env&lt;AttrContext&gt; env) {
1378         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1379         flow(env, results);
1380         return stopIfError(CompileState.FLOW, results);
1381     }
1382 
1383     /**
1384      * Perform dataflow checks on an attributed parse tree.
1385      */
1386     protected void flow(Env&lt;AttrContext&gt; env, Queue&lt;Env&lt;AttrContext&gt;&gt; results) {
1387         if (compileStates.isDone(env, CompileState.FLOW)) {
1388             results.add(env);
1389             return;
1390         }
1391 
1392         try {
1393             if (shouldStop(CompileState.FLOW))
1394                 return;
1395 
1396             if (verboseCompilePolicy)
1397                 printNote(&quot;[flow &quot; + env.enclClass.sym + &quot;]&quot;);
1398             JavaFileObject prev = log.useSource(
1399                                                 env.enclClass.sym.sourcefile != null ?
1400                                                 env.enclClass.sym.sourcefile :
1401                                                 env.toplevel.sourcefile);
1402             try {
1403                 make.at(Position.FIRSTPOS);
1404                 TreeMaker localMake = make.forToplevel(env.toplevel);
1405                 flow.analyzeTree(env, localMake);
1406                 compileStates.put(env, CompileState.FLOW);
1407 
1408                 if (shouldStop(CompileState.FLOW))
1409                     return;
1410 
1411                 analyzer.flush(env);
1412 
1413                 results.add(env);
1414             }
1415             finally {
1416                 log.useSource(prev);
1417             }
1418         }
1419         finally {
1420             if (!taskListener.isEmpty()) {
1421                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
1422                 taskListener.finished(e);
1423             }
1424         }
1425     }
1426 
1427     /**
1428      * Prepare attributed parse trees, in conjunction with their attribution contexts,
1429      * for source or code generation.
1430      * If any errors occur, an empty list will be returned.
1431      * @return a list containing the classes to be generated
1432      */
1433     public Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; desugar(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1434         ListBuffer&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; results = new ListBuffer&lt;&gt;();
1435         for (Env&lt;AttrContext&gt; env: envs)
1436             desugar(env, results);
1437         return stopIfError(CompileState.FLOW, results);
1438     }
1439 
1440     HashMap&lt;Env&lt;AttrContext&gt;, Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt;&gt; desugaredEnvs = new HashMap&lt;&gt;();
1441 
1442     /**
1443      * Prepare attributed parse trees, in conjunction with their attribution contexts,
1444      * for source or code generation. If the file was not listed on the command line,
1445      * the current implicitSourcePolicy is taken into account.
1446      * The preparation stops as soon as an error is found.
1447      */
1448     protected void desugar(final Env&lt;AttrContext&gt; env, Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; results) {
1449         if (shouldStop(CompileState.TRANSTYPES))
1450             return;
1451 
1452         if (implicitSourcePolicy == ImplicitSourcePolicy.NONE
1453                 &amp;&amp; !inputFiles.contains(env.toplevel.sourcefile)) {
1454             return;
1455         }
1456 
1457         if (!modules.multiModuleMode &amp;&amp; env.toplevel.modle != modules.getDefaultModule()) {
1458             //can only generate classfiles for a single module:
1459             return;
1460         }
1461 
1462         if (compileStates.isDone(env, CompileState.LOWER)) {
1463             results.addAll(desugaredEnvs.get(env));
1464             return;
1465         }
1466 
1467         /**
1468          * Ensure that superclasses of C are desugared before C itself. This is
1469          * required for two reasons: (i) as erasure (TransTypes) destroys
1470          * information needed in flow analysis and (ii) as some checks carried
1471          * out during lowering require that all synthetic fields/methods have
1472          * already been added to C and its superclasses.
1473          */
1474         class ScanNested extends TreeScanner {
1475             Set&lt;Env&lt;AttrContext&gt;&gt; dependencies = new LinkedHashSet&lt;&gt;();
1476             protected boolean hasLambdas;
1477             @Override
1478             public void visitClassDef(JCClassDecl node) {
1479                 Type st = types.supertype(node.sym.type);
1480                 boolean envForSuperTypeFound = false;
1481                 while (!envForSuperTypeFound &amp;&amp; st.hasTag(CLASS)) {
1482                     ClassSymbol c = st.tsym.outermostClass();
1483                     Env&lt;AttrContext&gt; stEnv = enter.getEnv(c);
1484                     if (stEnv != null &amp;&amp; env != stEnv) {
1485                         if (dependencies.add(stEnv)) {
1486                             boolean prevHasLambdas = hasLambdas;
1487                             try {
1488                                 scan(stEnv.tree);
1489                             } finally {
1490                                 /*
1491                                  * ignore any updates to hasLambdas made during
<a name="5" id="anc5"></a><span class="line-modified">1492                                  * the nested scan, this ensures an initalized</span>
1493                                  * LambdaToMethod is available only to those
1494                                  * classes that contain lambdas
1495                                  */
1496                                 hasLambdas = prevHasLambdas;
1497                             }
1498                         }
1499                         envForSuperTypeFound = true;
1500                     }
1501                     st = types.supertype(st);
1502                 }
1503                 super.visitClassDef(node);
1504             }
1505             @Override
1506             public void visitLambda(JCLambda tree) {
1507                 hasLambdas = true;
1508                 super.visitLambda(tree);
1509             }
1510             @Override
1511             public void visitReference(JCMemberReference tree) {
1512                 hasLambdas = true;
1513                 super.visitReference(tree);
1514             }
1515         }
1516         ScanNested scanner = new ScanNested();
1517         scanner.scan(env.tree);
1518         for (Env&lt;AttrContext&gt; dep: scanner.dependencies) {
1519         if (!compileStates.isDone(dep, CompileState.FLOW))
1520             desugaredEnvs.put(dep, desugar(flow(attribute(dep))));
1521         }
1522 
1523         //We need to check for error another time as more classes might
1524         //have been attributed and analyzed at this stage
1525         if (shouldStop(CompileState.TRANSTYPES))
1526             return;
1527 
1528         if (verboseCompilePolicy)
1529             printNote(&quot;[desugar &quot; + env.enclClass.sym + &quot;]&quot;);
1530 
1531         JavaFileObject prev = log.useSource(env.enclClass.sym.sourcefile != null ?
1532                                   env.enclClass.sym.sourcefile :
1533                                   env.toplevel.sourcefile);
1534         try {
1535             //save tree prior to rewriting
1536             JCTree untranslated = env.tree;
1537 
1538             make.at(Position.FIRSTPOS);
1539             TreeMaker localMake = make.forToplevel(env.toplevel);
1540 
1541             if (env.tree.hasTag(JCTree.Tag.PACKAGEDEF) || env.tree.hasTag(JCTree.Tag.MODULEDEF)) {
1542                 if (!(sourceOutput)) {
1543                     if (shouldStop(CompileState.LOWER))
1544                         return;
1545                     List&lt;JCTree&gt; def = lower.translateTopLevelClass(env, env.tree, localMake);
1546                     if (def.head != null) {
1547                         Assert.check(def.tail.isEmpty());
1548                         results.add(new Pair&lt;&gt;(env, (JCClassDecl)def.head));
1549                     }
1550                 }
1551                 return;
1552             }
1553 
1554             if (shouldStop(CompileState.TRANSTYPES))
1555                 return;
1556 
1557             env.tree = transTypes.translateTopLevelClass(env.tree, localMake);
1558             compileStates.put(env, CompileState.TRANSTYPES);
1559 
<a name="6" id="anc6"></a>





1560             if (Feature.LAMBDA.allowedInSource(source) &amp;&amp; scanner.hasLambdas) {
1561                 if (shouldStop(CompileState.UNLAMBDA))
1562                     return;
1563 
1564                 env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);
1565                 compileStates.put(env, CompileState.UNLAMBDA);
1566             }
1567 
1568             if (shouldStop(CompileState.LOWER))
1569                 return;
1570 
1571             if (sourceOutput) {
1572                 //emit standard Java source file, only for compilation
1573                 //units enumerated explicitly on the command line
1574                 JCClassDecl cdef = (JCClassDecl)env.tree;
1575                 if (untranslated instanceof JCClassDecl &amp;&amp;
1576                     rootClasses.contains((JCClassDecl)untranslated)) {
1577                     results.add(new Pair&lt;&gt;(env, cdef));
1578                 }
1579                 return;
1580             }
1581 
1582             //translate out inner classes
1583             List&lt;JCTree&gt; cdefs = lower.translateTopLevelClass(env, env.tree, localMake);
1584             compileStates.put(env, CompileState.LOWER);
1585 
1586             if (shouldStop(CompileState.LOWER))
1587                 return;
1588 
1589             //generate code for each class
1590             for (List&lt;JCTree&gt; l = cdefs; l.nonEmpty(); l = l.tail) {
1591                 JCClassDecl cdef = (JCClassDecl)l.head;
1592                 results.add(new Pair&lt;&gt;(env, cdef));
1593             }
1594         }
1595         finally {
1596             log.useSource(prev);
1597         }
1598 
1599     }
1600 
1601     /** Generates the source or class file for a list of classes.
1602      * The decision to generate a source file or a class file is
1603      * based upon the compiler&#39;s options.
1604      * Generation stops if an error occurs while writing files.
1605      */
1606     public void generate(Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; queue) {
1607         generate(queue, null);
1608     }
1609 
1610     public void generate(Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; queue, Queue&lt;JavaFileObject&gt; results) {
1611         if (shouldStop(CompileState.GENERATE))
1612             return;
1613 
1614         for (Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt; x: queue) {
1615             Env&lt;AttrContext&gt; env = x.fst;
1616             JCClassDecl cdef = x.snd;
1617 
1618             if (verboseCompilePolicy) {
1619                 printNote(&quot;[generate &quot; + (sourceOutput ? &quot; source&quot; : &quot;code&quot;) + &quot; &quot; + cdef.sym + &quot;]&quot;);
1620             }
1621 
1622             if (!taskListener.isEmpty()) {
1623                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
1624                 taskListener.started(e);
1625             }
1626 
1627             JavaFileObject prev = log.useSource(env.enclClass.sym.sourcefile != null ?
1628                                       env.enclClass.sym.sourcefile :
1629                                       env.toplevel.sourcefile);
1630             try {
1631                 JavaFileObject file;
1632                 if (sourceOutput) {
1633                     file = printSource(env, cdef);
1634                 } else {
1635                     if (fileManager.hasLocation(StandardLocation.NATIVE_HEADER_OUTPUT)
1636                             &amp;&amp; jniWriter.needsHeader(cdef.sym)) {
1637                         jniWriter.write(cdef.sym);
1638                     }
1639                     file = genCode(env, cdef);
1640                 }
1641                 if (results != null &amp;&amp; file != null)
1642                     results.add(file);
1643             } catch (IOException ex) {
1644                 log.error(cdef.pos(),
1645                           Errors.ClassCantWrite(cdef.sym, ex.getMessage()));
1646                 return;
1647             } finally {
1648                 log.useSource(prev);
1649             }
1650 
1651             if (!taskListener.isEmpty()) {
1652                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
1653                 taskListener.finished(e);
1654             }
1655         }
1656     }
1657 
1658         // where
1659         Map&lt;JCCompilationUnit, Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; groupByFile(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1660             // use a LinkedHashMap to preserve the order of the original list as much as possible
1661             Map&lt;JCCompilationUnit, Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; map = new LinkedHashMap&lt;&gt;();
1662             for (Env&lt;AttrContext&gt; env: envs) {
1663                 Queue&lt;Env&lt;AttrContext&gt;&gt; sublist = map.get(env.toplevel);
1664                 if (sublist == null) {
1665                     sublist = new ListBuffer&lt;&gt;();
1666                     map.put(env.toplevel, sublist);
1667                 }
1668                 sublist.add(env);
1669             }
1670             return map;
1671         }
1672 
1673         JCClassDecl removeMethodBodies(JCClassDecl cdef) {
1674             final boolean isInterface = (cdef.mods.flags &amp; Flags.INTERFACE) != 0;
1675             class MethodBodyRemover extends TreeTranslator {
1676                 @Override
1677                 public void visitMethodDef(JCMethodDecl tree) {
1678                     tree.mods.flags &amp;= ~Flags.SYNCHRONIZED;
1679                     for (JCVariableDecl vd : tree.params)
1680                         vd.mods.flags &amp;= ~Flags.FINAL;
1681                     tree.body = null;
1682                     super.visitMethodDef(tree);
1683                 }
1684                 @Override
1685                 public void visitVarDef(JCVariableDecl tree) {
1686                     if (tree.init != null &amp;&amp; tree.init.type.constValue() == null)
1687                         tree.init = null;
1688                     super.visitVarDef(tree);
1689                 }
1690                 @Override
1691                 public void visitClassDef(JCClassDecl tree) {
1692                     ListBuffer&lt;JCTree&gt; newdefs = new ListBuffer&lt;&gt;();
1693                     for (List&lt;JCTree&gt; it = tree.defs; it.tail != null; it = it.tail) {
1694                         JCTree t = it.head;
1695                         switch (t.getTag()) {
1696                         case CLASSDEF:
1697                             if (isInterface ||
1698                                 (((JCClassDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1699                                 (((JCClassDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCClassDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1700                                 newdefs.append(t);
1701                             break;
1702                         case METHODDEF:
1703                             if (isInterface ||
1704                                 (((JCMethodDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1705                                 ((JCMethodDecl) t).sym.name == names.init ||
1706                                 (((JCMethodDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCMethodDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1707                                 newdefs.append(t);
1708                             break;
1709                         case VARDEF:
1710                             if (isInterface || (((JCVariableDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1711                                 (((JCVariableDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCVariableDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1712                                 newdefs.append(t);
1713                             break;
1714                         default:
1715                             break;
1716                         }
1717                     }
1718                     tree.defs = newdefs.toList();
1719                     super.visitClassDef(tree);
1720                 }
1721             }
1722             MethodBodyRemover r = new MethodBodyRemover();
1723             return r.translate(cdef);
1724         }
1725 
1726     public void reportDeferredDiagnostics() {
1727         if (errorCount() == 0
1728                 &amp;&amp; annotationProcessingOccurred
1729                 &amp;&amp; implicitSourceFilesRead
1730                 &amp;&amp; implicitSourcePolicy == ImplicitSourcePolicy.UNSET) {
1731             if (explicitAnnotationProcessingRequested())
1732                 log.warning(Warnings.ProcUseImplicit);
1733             else
1734                 log.warning(Warnings.ProcUseProcOrImplicit);
1735         }
1736         chk.reportDeferredDiagnostics();
1737         preview.reportDeferredDiagnostics();
1738         if (log.compressedOutput) {
1739             log.mandatoryNote(null, Notes.CompressedDiags);
1740         }
1741     }
1742 
1743     public void enterDone() {
1744         enterDone = true;
1745         annotate.enterDone();
1746     }
1747 
1748     public boolean isEnterDone() {
1749         return enterDone;
1750     }
1751 
1752     private Name readModuleName(JavaFileObject fo) {
1753         return parseAndGetName(fo, t -&gt; {
1754             JCModuleDecl md = t.getModuleDecl();
1755 
1756             return md != null ? TreeInfo.fullName(md.getName()) : null;
1757         });
1758     }
1759 
1760     private Name findPackageInFile(JavaFileObject fo) {
1761         return parseAndGetName(fo, t -&gt; t.getPackage() != null ?
1762                                         TreeInfo.fullName(t.getPackage().getPackageName()) : null);
1763     }
1764 
1765     private Name parseAndGetName(JavaFileObject fo,
1766                                  Function&lt;JCTree.JCCompilationUnit, Name&gt; tree2Name) {
1767         DiagnosticHandler dh = new DiscardDiagnosticHandler(log);
1768         JavaFileObject prevSource = log.useSource(fo);
1769         try {
1770             JCTree.JCCompilationUnit t = parse(fo, fo.getCharContent(false));
1771             return tree2Name.apply(t);
1772         } catch (IOException e) {
1773             return null;
1774         } finally {
1775             log.popDiagnosticHandler(dh);
1776             log.useSource(prevSource);
1777         }
1778     }
1779 
1780     /** Close the compiler, flushing the logs
1781      */
1782     public void close() {
1783         rootClasses = null;
1784         finder = null;
1785         reader = null;
1786         make = null;
1787         writer = null;
1788         enter = null;
1789         if (todo != null)
1790             todo.clear();
1791         todo = null;
1792         parserFactory = null;
1793         syms = null;
1794         source = null;
1795         attr = null;
1796         chk = null;
1797         gen = null;
1798         flow = null;
1799         transTypes = null;
1800         lower = null;
1801         annotate = null;
1802         types = null;
1803 
1804         log.flush();
1805         try {
1806             fileManager.flush();
1807         } catch (IOException e) {
1808             throw new Abort(e);
1809         } finally {
1810             if (names != null)
1811                 names.dispose();
1812             names = null;
1813 
1814             for (Closeable c: closeables) {
1815                 try {
1816                     c.close();
1817                 } catch (IOException e) {
1818                     // When javac uses JDK 7 as a baseline, this code would be
1819                     // better written to set any/all exceptions from all the
1820                     // Closeables as suppressed exceptions on the FatalError
1821                     // that is thrown.
1822                     JCDiagnostic msg = diagFactory.fragment(Fragments.FatalErrCantClose);
1823                     throw new FatalError(msg, e);
1824                 }
1825             }
1826             closeables = List.nil();
1827         }
1828     }
1829 
1830     protected void printNote(String lines) {
1831         log.printRawLines(Log.WriterKind.NOTICE, lines);
1832     }
1833 
1834     /** Print numbers of errors and warnings.
1835      */
1836     public void printCount(String kind, int count) {
1837         if (count != 0) {
1838             String key;
1839             if (count == 1)
1840                 key = &quot;count.&quot; + kind;
1841             else
1842                 key = &quot;count.&quot; + kind + &quot;.plural&quot;;
1843             log.printLines(WriterKind.ERROR, key, String.valueOf(count));
1844             log.flush(Log.WriterKind.ERROR);
1845         }
1846     }
1847 
<a name="7" id="anc7"></a>








1848     private static long now() {
1849         return System.currentTimeMillis();
1850     }
1851 
1852     private static long elapsed(long then) {
1853         return now() - then;
1854     }
1855 
1856     public void newRound() {
1857         inputFiles.clear();
1858         todo.clear();
1859     }
1860 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
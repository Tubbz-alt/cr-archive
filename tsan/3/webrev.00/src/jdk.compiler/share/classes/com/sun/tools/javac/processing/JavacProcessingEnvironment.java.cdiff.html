<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacProcessingEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacMessager.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacRoundEnvironment.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacProcessingEnvironment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,10 ***</span>
<span class="line-new-header">--- 186,15 ---</span>
      private final Completer initialCompleter;
      private final Check chk;
  
      private final Context context;
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Support for preview language features.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final Preview preview;</span>
<span class="line-added">+ </span>
      /** Get the JavacProcessingEnvironment instance for this context. */
      public static JavacProcessingEnvironment instance(Context context) {
          JavacProcessingEnvironment instance = context.get(JavacProcessingEnvironment.class);
          if (instance == null)
              instance = new JavacProcessingEnvironment(context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,10 ***</span>
<span class="line-new-header">--- 239,11 ---</span>
          dcfh = DeferredCompletionFailureHandler.instance(context);
          names = Names.instance(context);
          enter = Enter.instance(context);
          initialCompleter = ClassFinder.instance(context).getCompleter();
          chk = Check.instance(context);
<span class="line-added">+         preview = Preview.instance(context);</span>
          initProcessorLoader();
      }
  
      public void setProcessors(Iterable&lt;? extends Processor&gt; processors) {
          Assert.checkNull(discoveredProcs);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,11 ***</span>
                        module_prefix + &quot;java.lang.annotation.Documented&quot;,
                        module_prefix + &quot;java.lang.annotation.Inherited&quot;,
                        module_prefix + &quot;java.lang.annotation.Native&quot;,
                        module_prefix + &quot;java.lang.annotation.Repeatable&quot;,
                        module_prefix + &quot;java.lang.annotation.Retention&quot;,
<span class="line-modified">!                       module_prefix + &quot;java.lang.annotation.Target&quot;);</span>
      }
  
      private void initProcessorLoader() {
          try {
              if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {
<span class="line-new-header">--- 262,13 ---</span>
                        module_prefix + &quot;java.lang.annotation.Documented&quot;,
                        module_prefix + &quot;java.lang.annotation.Inherited&quot;,
                        module_prefix + &quot;java.lang.annotation.Native&quot;,
                        module_prefix + &quot;java.lang.annotation.Repeatable&quot;,
                        module_prefix + &quot;java.lang.annotation.Retention&quot;,
<span class="line-modified">!                       module_prefix + &quot;java.lang.annotation.Target&quot;,</span>
<span class="line-added">+ </span>
<span class="line-added">+                       module_prefix + &quot;java.io.Serial&quot;);</span>
      }
  
      private void initProcessorLoader() {
          try {
              if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,11 ***</span>
<span class="line-new-header">--- 444,18 ---</span>
              try {
                  return internalHasNext();
              } catch(ServiceConfigurationError sce) {
                  log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
                  throw new Abort(sce);
<span class="line-added">+             } catch (UnsupportedClassVersionError ucve) {</span>
<span class="line-added">+                 log.error(Errors.ProcCantLoadClass(ucve.getLocalizedMessage()));</span>
<span class="line-added">+                 throw new Abort(ucve);</span>
<span class="line-added">+             } catch (ClassFormatError cfe) {</span>
<span class="line-added">+                 log.error(Errors.ProcCantLoadClass(cfe.getLocalizedMessage()));</span>
<span class="line-added">+                 throw new Abort(cfe);</span>
              } catch (Throwable t) {
<span class="line-added">+                 log.error(Errors.ProcBadConfigFile(t.getLocalizedMessage()));</span>
                  throw new Abort(t);
              }
          }
  
          boolean internalHasNext() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,10 ***</span>
<span class="line-new-header">--- 468,11 ---</span>
                  return internalNext();
              } catch (ServiceConfigurationError sce) {
                  log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
                  throw new Abort(sce);
              } catch (Throwable t) {
<span class="line-added">+                 log.error(Errors.ProcBadConfigFile(t.getLocalizedMessage()));</span>
                  throw new Abort(t);
              }
          }
  
          Processor internalNext() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 670,36 ***</span>
       * only) getSupportedAnnotationTypes call to the processor.
       */
      static class ProcessorState {
          public Processor processor;
          public boolean   contributed;
<span class="line-modified">!         private ArrayList&lt;Pattern&gt; supportedAnnotationPatterns;</span>
<span class="line-modified">!         private ArrayList&lt;String&gt;  supportedOptionNames;</span>
  
          ProcessorState(Processor p, Log log, Source source, DeferredCompletionFailureHandler dcfh,
<span class="line-modified">!                        boolean allowModules, ProcessingEnvironment env) {</span>
              processor = p;
              contributed = false;
  
              Handler prevDeferredHandler = dcfh.setHandler(dcfh.userCodeHandler);
              try {
                  processor.init(env);
  
                  checkSourceVersionCompatibility(source, log);
  
<span class="line-modified">!                 supportedAnnotationPatterns = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!                 for (String importString : processor.getSupportedAnnotationTypes()) {</span>
<span class="line-modified">!                     supportedAnnotationPatterns.add(importStringToPattern(allowModules,</span>
<span class="line-modified">!                                                                           importString,</span>
<span class="line-modified">!                                                                           processor,</span>
<span class="line-modified">!                                                                           log));</span>
                  }
  
<span class="line-modified">!                 supportedOptionNames = new ArrayList&lt;&gt;();</span>
                  for (String optionName : processor.getSupportedOptions() ) {
<span class="line-modified">!                     if (checkOptionName(optionName, log))</span>
<span class="line-modified">!                         supportedOptionNames.add(optionName);</span>
                  }
  
              } catch (ClientCodeException e) {
                  throw e;
              } catch (Throwable t) {
<span class="line-new-header">--- 686,65 ---</span>
       * only) getSupportedAnnotationTypes call to the processor.
       */
      static class ProcessorState {
          public Processor processor;
          public boolean   contributed;
<span class="line-modified">!         private Set&lt;String&gt; supportedAnnotationStrings; // Used for warning generation</span>
<span class="line-modified">!         private Set&lt;Pattern&gt; supportedAnnotationPatterns;</span>
<span class="line-added">+         private Set&lt;String&gt; supportedOptionNames;</span>
  
          ProcessorState(Processor p, Log log, Source source, DeferredCompletionFailureHandler dcfh,
<span class="line-modified">!                        boolean allowModules, ProcessingEnvironment env, boolean lint) {</span>
              processor = p;
              contributed = false;
  
              Handler prevDeferredHandler = dcfh.setHandler(dcfh.userCodeHandler);
              try {
                  processor.init(env);
  
                  checkSourceVersionCompatibility(source, log);
  
<span class="line-modified">! </span>
<span class="line-modified">!                 // Check for direct duplicates in the strings of</span>
<span class="line-modified">!                 // supported annotation types. Do not check for</span>
<span class="line-modified">!                 // duplicates that would result after stripping of</span>
<span class="line-modified">!                 // module prefixes.</span>
<span class="line-modified">!                 supportedAnnotationStrings = new LinkedHashSet&lt;&gt;();</span>
<span class="line-added">+                 supportedAnnotationPatterns = new LinkedHashSet&lt;&gt;();</span>
<span class="line-added">+                 for (String annotationPattern : processor.getSupportedAnnotationTypes()) {</span>
<span class="line-added">+                     boolean patternAdded = supportedAnnotationStrings.add(annotationPattern);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     supportedAnnotationPatterns.</span>
<span class="line-added">+                         add(importStringToPattern(allowModules, annotationPattern,</span>
<span class="line-added">+                                                   processor, log, lint));</span>
<span class="line-added">+                     if (lint &amp;&amp; !patternAdded) {</span>
<span class="line-added">+                         log.warning(Warnings.ProcDuplicateSupportedAnnotation(annotationPattern,</span>
<span class="line-added">+                                                                               p.getClass().getName()));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // If a processor supports &quot;*&quot;, that matches</span>
<span class="line-added">+                 // everything and other entries are redundant. With</span>
<span class="line-added">+                 // more work, it could be checked that the supported</span>
<span class="line-added">+                 // annotation types were otherwise non-overlapping</span>
<span class="line-added">+                 // with each other in other cases, for example &quot;foo.*&quot;</span>
<span class="line-added">+                 // and &quot;foo.bar.*&quot;.</span>
<span class="line-added">+                 if (lint &amp;&amp;</span>
<span class="line-added">+                     supportedAnnotationPatterns.contains(MatchingUtils.validImportStringToPattern(&quot;*&quot;)) &amp;&amp;</span>
<span class="line-added">+                     supportedAnnotationPatterns.size() &gt; 1) {</span>
<span class="line-added">+                     log.warning(Warnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));</span>
                  }
  
<span class="line-modified">!                 supportedOptionNames = new LinkedHashSet&lt;&gt;();</span>
                  for (String optionName : processor.getSupportedOptions() ) {
<span class="line-modified">!                     if (checkOptionName(optionName, log)) {</span>
<span class="line-modified">!                         boolean optionAdded = supportedOptionNames.add(optionName);</span>
<span class="line-added">+                         if (lint &amp;&amp; !optionAdded) {</span>
<span class="line-added">+                             log.warning(Warnings.ProcDuplicateOptionName(optionName,</span>
<span class="line-added">+                                                                          p.getClass().getName()));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
                  }
  
              } catch (ClientCodeException e) {
                  throw e;
              } catch (Throwable t) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 715,11 ***</span>
           * processor&#39;s source version needs to be greater than or
           * equal to the source version of the compile.
           */
          private void checkSourceVersionCompatibility(Source source, Log log) {
              SourceVersion procSourceVersion = processor.getSupportedSourceVersion();
<span class="line-removed">- </span>
              if (procSourceVersion.compareTo(Source.toSourceVersion(source)) &lt; 0 )  {
                  log.warning(Warnings.ProcProcessorIncompatibleSourceVersion(procSourceVersion,
                                                                              processor.getClass().getName(),
                                                                              source.name));
              }
<span class="line-new-header">--- 760,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 761,39 ***</span>
      class DiscoveredProcessors implements Iterable&lt;ProcessorState&gt; {
  
          class ProcessorStateIterator implements Iterator&lt;ProcessorState&gt; {
              DiscoveredProcessors psi;
              Iterator&lt;ProcessorState&gt; innerIter;
<span class="line-modified">!             boolean onProcInterator;</span>
  
              ProcessorStateIterator(DiscoveredProcessors psi) {
                  this.psi = psi;
                  this.innerIter = psi.procStateList.iterator();
<span class="line-modified">!                 this.onProcInterator = false;</span>
              }
  
              public ProcessorState next() {
<span class="line-modified">!                 if (!onProcInterator) {</span>
                      if (innerIter.hasNext())
                          return innerIter.next();
                      else
<span class="line-modified">!                         onProcInterator = true;</span>
                  }
  
                  if (psi.processorIterator.hasNext()) {
                      ProcessorState ps = new ProcessorState(psi.processorIterator.next(),
                                                             log, source, dcfh,
                                                             Feature.MODULES.allowedInSource(source),
<span class="line-modified">!                                                            JavacProcessingEnvironment.this);</span>
                      psi.procStateList.add(ps);
                      return ps;
                  } else
                      throw new NoSuchElementException();
              }
  
              public boolean hasNext() {
<span class="line-modified">!                 if (onProcInterator)</span>
                      return  psi.processorIterator.hasNext();
                  else
                      return innerIter.hasNext() || psi.processorIterator.hasNext();
              }
  
<span class="line-new-header">--- 805,40 ---</span>
      class DiscoveredProcessors implements Iterable&lt;ProcessorState&gt; {
  
          class ProcessorStateIterator implements Iterator&lt;ProcessorState&gt; {
              DiscoveredProcessors psi;
              Iterator&lt;ProcessorState&gt; innerIter;
<span class="line-modified">!             boolean onProcIterator;</span>
  
              ProcessorStateIterator(DiscoveredProcessors psi) {
                  this.psi = psi;
                  this.innerIter = psi.procStateList.iterator();
<span class="line-modified">!                 this.onProcIterator = false;</span>
              }
  
              public ProcessorState next() {
<span class="line-modified">!                 if (!onProcIterator) {</span>
                      if (innerIter.hasNext())
                          return innerIter.next();
                      else
<span class="line-modified">!                         onProcIterator = true;</span>
                  }
  
                  if (psi.processorIterator.hasNext()) {
                      ProcessorState ps = new ProcessorState(psi.processorIterator.next(),
                                                             log, source, dcfh,
                                                             Feature.MODULES.allowedInSource(source),
<span class="line-modified">!                                                            JavacProcessingEnvironment.this,</span>
<span class="line-added">+                                                            lint);</span>
                      psi.procStateList.add(ps);
                      return ps;
                  } else
                      throw new NoSuchElementException();
              }
  
              public boolean hasNext() {
<span class="line-modified">!                 if (onProcIterator)</span>
                      return  psi.processorIterator.hasNext();
                  else
                      return innerIter.hasNext() || psi.processorIterator.hasNext();
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
               * Run all remaining processors on the procStateList that
               * have not already run this round with an empty set of
               * annotations.
               */
              public void runContributingProcs(RoundEnvironment re) {
<span class="line-modified">!                 if (!onProcInterator) {</span>
                      Set&lt;TypeElement&gt; emptyTypeElements = Collections.emptySet();
                      while(innerIter.hasNext()) {
                          ProcessorState ps = innerIter.next();
                          if (ps.contributed)
                              callProcessor(ps.processor, emptyTypeElements, re);
<span class="line-new-header">--- 850,11 ---</span>
               * Run all remaining processors on the procStateList that
               * have not already run this round with an empty set of
               * annotations.
               */
              public void runContributingProcs(RoundEnvironment re) {
<span class="line-modified">!                 if (!onProcIterator) {</span>
                      Set&lt;TypeElement&gt; emptyTypeElements = Collections.emptySet();
                      while(innerIter.hasNext()) {
                          ProcessorState ps = innerIter.next();
                          if (ps.contributed)
                              callProcessor(ps.processor, emptyTypeElements, re);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,12 ***</span>
  
      /**
       * Computes the set of annotations on the symbol in question.
       * Leave class public for external testing purposes.
       */
      public static class ComputeAnnotationSet extends
<span class="line-modified">!         ElementScanner9&lt;Set&lt;TypeElement&gt;, Set&lt;TypeElement&gt;&gt; {</span>
          final Elements elements;
  
          public ComputeAnnotationSet(Elements elements) {
              super();
              this.elements = elements;
<span class="line-new-header">--- 970,13 ---</span>
  
      /**
       * Computes the set of annotations on the symbol in question.
       * Leave class public for external testing purposes.
       */
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public static class ComputeAnnotationSet extends
<span class="line-modified">!         ElementScanner14&lt;Set&lt;TypeElement&gt;, Set&lt;TypeElement&gt;&gt; {</span>
          final Elements elements;
  
          public ComputeAnnotationSet(Elements elements) {
              super();
              this.elements = elements;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1113,11 ***</span>
          void finalCompiler() {
              newRound();
          }
  
          /** Return the number of errors found so far in this round.
<span class="line-modified">!          * This may include uncoverable errors, such as parse errors,</span>
           * and transient errors, such as missing symbols. */
          int errorCount() {
              return compiler.errorCount();
          }
  
<span class="line-new-header">--- 1159,11 ---</span>
          void finalCompiler() {
              newRound();
          }
  
          /** Return the number of errors found so far in this round.
<span class="line-modified">!          * This may include unrecoverable errors, such as parse errors,</span>
           * and transient errors, such as missing symbols. */
          int errorCount() {
              return compiler.errorCount();
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1466,14 ***</span>
      }
  
      private List&lt;ModuleSymbol&gt; getModuleInfoFiles(List&lt;? extends JCCompilationUnit&gt; units) {
          List&lt;ModuleSymbol&gt; modules = List.nil();
          for (JCCompilationUnit unit : units) {
<span class="line-modified">!             if (isModuleInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE) &amp;&amp;</span>
<span class="line-modified">!                 unit.defs.nonEmpty() &amp;&amp;</span>
<span class="line-modified">!                 unit.defs.head.hasTag(Tag.MODULEDEF)) {</span>
<span class="line-modified">!                 modules = modules.prepend(unit.modle);</span>
              }
          }
          return modules.reverse();
      }
  
<span class="line-new-header">--- 1512,23 ---</span>
      }
  
      private List&lt;ModuleSymbol&gt; getModuleInfoFiles(List&lt;? extends JCCompilationUnit&gt; units) {
          List&lt;ModuleSymbol&gt; modules = List.nil();
          for (JCCompilationUnit unit : units) {
<span class="line-modified">!             if (isModuleInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE) &amp;&amp; unit.defs.nonEmpty()) {</span>
<span class="line-modified">!                 for (JCTree tree : unit.defs) {</span>
<span class="line-modified">!                     if (tree.hasTag(Tag.IMPORT)) {</span>
<span class="line-modified">!                         continue;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     else if (tree.hasTag(Tag.MODULEDEF)) {</span>
<span class="line-added">+                         modules = modules.prepend(unit.modle);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     else {</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
              }
          }
          return modules.reverse();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1673,10 ***</span>
<span class="line-new-header">--- 1728,15 ---</span>
      @DefinedBy(Api.ANNOTATION_PROCESSING)
      public Locale getLocale() {
          return messages.getCurrentLocale();
      }
  
<span class="line-added">+     @DefinedBy(Api.ANNOTATION_PROCESSING)</span>
<span class="line-added">+     public boolean isPreviewEnabled() {</span>
<span class="line-added">+         return preview.isEnabled();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public Set&lt;Symbol.PackageSymbol&gt; getSpecifiedPackages() {
          return specifiedPackages;
      }
  
      public static final Pattern noMatches  = Pattern.compile(&quot;(\\P{all})+&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1684,30 ***</span>
      /**
       * Convert import-style string for supported annotations into a
       * regex matching that string.  If the string is not a valid
       * import-style string, return a regex that won&#39;t match anything.
       */
<span class="line-modified">!     private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {</span>
          String module;
          String pkg;
          int slash = s.indexOf(&#39;/&#39;);
          if (slash == (-1)) {
              if (s.equals(&quot;*&quot;)) {
                  return MatchingUtils.validImportStringToPattern(s);
              }
              module = allowModules ? &quot;.*/&quot; : &quot;&quot;;
              pkg = s;
          } else {
<span class="line-modified">!             module = Pattern.quote(s.substring(0, slash + 1));</span>
              pkg = s.substring(slash + 1);
          }
          if (MatchingUtils.isValidImportString(pkg)) {
              return Pattern.compile(module + MatchingUtils.validImportStringToPatternString(pkg));
          } else {
              log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));
<span class="line-removed">-             return noMatches; // won&#39;t match any valid identifier</span>
          }
      }
  
      /**
       * For internal use only.  This method may be removed without warning.
       */
<span class="line-new-header">--- 1744,41 ---</span>
      /**
       * Convert import-style string for supported annotations into a
       * regex matching that string.  If the string is not a valid
       * import-style string, return a regex that won&#39;t match anything.
       */
<span class="line-modified">!     private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, boolean lint) {</span>
          String module;
          String pkg;
          int slash = s.indexOf(&#39;/&#39;);
          if (slash == (-1)) {
              if (s.equals(&quot;*&quot;)) {
                  return MatchingUtils.validImportStringToPattern(s);
              }
              module = allowModules ? &quot;.*/&quot; : &quot;&quot;;
              pkg = s;
          } else {
<span class="line-modified">!             String moduleName = s.substring(0, slash);</span>
<span class="line-added">+             if (!SourceVersion.isName(moduleName)) {</span>
<span class="line-added">+                 return warnAndNoMatches(s, p, log, lint);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             module = Pattern.quote(moduleName + &quot;/&quot;);</span>
<span class="line-added">+             // And warn if module is specified if modules aren&#39;t supported, conditional on -Xlint:proc?</span>
              pkg = s.substring(slash + 1);
          }
          if (MatchingUtils.isValidImportString(pkg)) {
              return Pattern.compile(module + MatchingUtils.validImportStringToPatternString(pkg));
          } else {
<span class="line-added">+             return warnAndNoMatches(s, p, log, lint);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static Pattern warnAndNoMatches(String s, Processor p, Log log, boolean lint) {</span>
<span class="line-added">+         if (lint) {</span>
              log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));
          }
<span class="line-added">+         return noMatches; // won&#39;t match any valid identifier</span>
      }
  
      /**
       * For internal use only.  This method may be removed without warning.
       */
</pre>
<center><a href="JavacMessager.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacRoundEnvironment.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
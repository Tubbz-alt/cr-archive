<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/sjavac/pubapi/PubApi.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.sjavac.pubapi;
 27 
 28 
 29 import static com.sun.tools.sjavac.Util.union;
 30 
 31 import java.io.Serializable;
 32 import java.util.ArrayList;
 33 import java.util.Collection;
 34 import java.util.Collections;
 35 import java.util.Comparator;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Optional;
 41 import java.util.Set;
 42 import java.util.regex.Matcher;
 43 import java.util.regex.Pattern;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 import javax.lang.model.element.Modifier;
 48 
 49 import com.sun.tools.javac.util.Assert;
 50 import com.sun.tools.javac.util.StringUtils;
 51 
 52 public class PubApi implements Serializable {
 53 
 54     private static final long serialVersionUID = 5926627347801986850L;
 55 
 56     // Used to have Set here. Problem is that the objects are mutated during
 57     // javac_state loading, causing them to change hash codes. We could probably
 58     // change back to Set once javac_state loading is cleaned up.
 59     public final Map&lt;String, PubType&gt; types = new HashMap&lt;&gt;();
 60     public final Map&lt;String, PubVar&gt; variables = new HashMap&lt;&gt;();
 61     public final Map&lt;String, PubMethod&gt; methods = new HashMap&lt;&gt;();
<a name="2" id="anc2"></a><span class="line-added"> 62     public final Map&lt;String, PubVar&gt; recordComponents = new HashMap&lt;&gt;();</span>
 63 
 64     public PubApi() {
 65     }
 66 
 67     public PubApi(Collection&lt;PubType&gt; types,
 68                   Collection&lt;PubVar&gt; variables,
 69                   Collection&lt;PubMethod&gt; methods) {
 70         types.forEach(this::addPubType);
 71         variables.forEach(this::addPubVar);
 72         methods.forEach(this::addPubMethod);
 73     }
 74 
 75     // Currently this is implemented as equality. This is far from optimal. It
 76     // should preferably make sure that all previous methods are still available
 77     // and no abstract methods are added. It should also be aware of inheritance
 78     // of course.
 79     public boolean isBackwardCompatibleWith(PubApi older) {
 80         return equals(older);
 81     }
 82 
 83     private static String typeLine(PubType type) {
 84         if (type.fqName.isEmpty())
 85             throw new RuntimeException(&quot;empty class name &quot; + type);
 86         return String.format(&quot;TYPE %s%s&quot;, asString(type.modifiers), type.fqName);
 87     }
 88 
 89     private static String varLine(PubVar var) {
 90         return String.format(&quot;VAR %s%s %s%s&quot;,
 91                              asString(var.modifiers),
 92                              TypeDesc.encodeAsString(var.type),
 93                              var.identifier,
 94                              var.getConstValue().map(v -&gt; &quot; = &quot; + v).orElse(&quot;&quot;));
 95     }
 96 
 97     private static String methodLine(PubMethod method) {
 98         return String.format(&quot;METHOD %s%s%s %s(%s)%s&quot;,
 99                              asString(method.modifiers),
100                              method.typeParams.isEmpty() ? &quot;&quot; : (&quot;&lt;&quot; + method.typeParams.stream().map(PubApiTypeParam::asString).collect(Collectors.joining(&quot;,&quot;)) + &quot;&gt; &quot;),
101                              TypeDesc.encodeAsString(method.returnType),
102                              method.identifier,
103                              commaSeparated(method.paramTypes),
104                              method.throwDecls.isEmpty()
105                                  ? &quot;&quot;
106                                  : &quot; throws &quot; + commaSeparated(method.throwDecls));
107     }
108 
109     public List&lt;String&gt; asListOfStrings() {
110         List&lt;String&gt; lines = new ArrayList&lt;&gt;();
111 
112         // Types
113         types.values()
114              .stream()
115              .sorted(Comparator.comparing(PubApi::typeLine))
116              .forEach(type -&gt; {
117                  lines.add(typeLine(type));
118                  for (String subline : type.pubApi.asListOfStrings())
119                      lines.add(&quot;  &quot; + subline);
120              });
121 
122         // Variables
123         variables.values()
124                  .stream()
125                  .map(PubApi::varLine)
126                  .sorted()
127                  .forEach(lines::add);
128 
129         // Methods
130         methods.values()
131                .stream()
132                .map(PubApi::methodLine)
133                .sorted()
134                .forEach(lines::add);
135 
136         return lines;
137     }
138 
139     @Override
140     public boolean equals(Object obj) {
141         if (getClass() != obj.getClass())
142             return false;
143         PubApi other = (PubApi) obj;
144         return types.equals(other.types)
145             &amp;&amp; variables.equals(other.variables)
146             &amp;&amp; methods.equals(other.methods);
147     }
148 
149     @Override
150     public int hashCode() {
151         return types.keySet().hashCode()
152              ^ variables.keySet().hashCode()
153              ^ methods.keySet().hashCode();
154     }
155 
156     private static String commaSeparated(List&lt;TypeDesc&gt; typeDescs) {
157         return typeDescs.stream()
158                         .map(TypeDesc::encodeAsString)
159                         .collect(Collectors.joining(&quot;,&quot;));
160     }
161 
162     // Create space separated list of modifiers (with a trailing space)
163     private static String asString(Set&lt;Modifier&gt; modifiers) {
164         return modifiers.stream()
165                         .map(mod -&gt; mod + &quot; &quot;)
166                         .sorted()
167                         .collect(Collectors.joining());
168     }
169 
170     // Used to combine class PubApis to package level PubApis
171     public static PubApi mergeTypes(PubApi api1, PubApi api2) {
172         Assert.check(api1.methods.isEmpty(), &quot;Can only merge types.&quot;);
173         Assert.check(api2.methods.isEmpty(), &quot;Can only merge types.&quot;);
174         Assert.check(api1.variables.isEmpty(), &quot;Can only merge types.&quot;);
175         Assert.check(api2.variables.isEmpty(), &quot;Can only merge types.&quot;);
176         PubApi merged = new PubApi();
177         merged.types.putAll(api1.types);
178         merged.types.putAll(api2.types);
179         return merged;
180     }
181 
182 
183     // Used for line-by-line parsing
184     private PubType lastInsertedType = null;
185 
186     private final static String MODIFIERS = Stream.of(Modifier.values())
187                                                   .map(Modifier::name)
188                                                   .map(StringUtils::toLowerCase)
189                                                   .collect(Collectors.joining(&quot;|&quot;, &quot;(&quot;, &quot;)&quot;));
190 
191     private final static Pattern MOD_PATTERN = Pattern.compile(&quot;(&quot; + MODIFIERS + &quot; )*&quot;);
192     private final static Pattern METHOD_PATTERN = Pattern.compile(&quot;(?&lt;ret&gt;.+?) (?&lt;name&gt;\\S+)\\((?&lt;params&gt;.*)\\)( throws (?&lt;throws&gt;.*))?&quot;);
193     private final static Pattern VAR_PATTERN = Pattern.compile(&quot;VAR (?&lt;modifiers&gt;(&quot;+MODIFIERS+&quot; )*)(?&lt;type&gt;.+?) (?&lt;id&gt;\\S+)( = (?&lt;val&gt;.*))?&quot;);
194     private final static Pattern TYPE_PATTERN = Pattern.compile(&quot;TYPE (?&lt;modifiers&gt;(&quot;+MODIFIERS+&quot; )*)(?&lt;fullyQualified&gt;\\S+)&quot;);
195 
196     public void appendItem(String l) {
197         try {
198             if (l.startsWith(&quot;  &quot;)) {
199                 lastInsertedType.pubApi.appendItem(l.substring(2));
200                 return;
201             }
202 
203             if (l.startsWith(&quot;METHOD&quot;)) {
204                 l = l.substring(&quot;METHOD &quot;.length());
205                 Set&lt;Modifier&gt; modifiers = new HashSet&lt;&gt;();
206                 Matcher modMatcher = MOD_PATTERN.matcher(l);
207                 if (modMatcher.find()) {
208                     String modifiersStr = modMatcher.group();
209                     modifiers.addAll(parseModifiers(modifiersStr));
210                     l = l.substring(modifiersStr.length());
211                 }
212                 List&lt;PubApiTypeParam&gt; typeParams = new ArrayList&lt;&gt;();
213                 if (l.startsWith(&quot;&lt;&quot;)) {
214                     int closingPos = findClosingTag(l, 0);
215                     String str = l.substring(1, closingPos);
216                     l = l.substring(closingPos+1);
217                     typeParams.addAll(parseTypeParams(splitOnTopLevelCommas(str)));
218                 }
219                 Matcher mm = METHOD_PATTERN.matcher(l);
220                 if (!mm.matches())
221                     throw new AssertionError(&quot;Could not parse return type, identifier, parameter types or throws declaration of method: &quot; + l);
222 
223                 List&lt;String&gt; params = splitOnTopLevelCommas(mm.group(&quot;params&quot;));
224                 String th = Optional.ofNullable(mm.group(&quot;throws&quot;)).orElse(&quot;&quot;);
225                 List&lt;String&gt; throwz = splitOnTopLevelCommas(th);
226                 PubMethod m = new PubMethod(modifiers,
227                                             typeParams,
228                                             TypeDesc.decodeString(mm.group(&quot;ret&quot;)),
229                                             mm.group(&quot;name&quot;),
230                                             parseTypeDescs(params),
231                                             parseTypeDescs(throwz));
232                 addPubMethod(m);
233                 return;
234             }
235 
236             Matcher vm = VAR_PATTERN.matcher(l);
237             if (vm.matches()) {
238                 addPubVar(new PubVar(parseModifiers(vm.group(&quot;modifiers&quot;)),
239                                      TypeDesc.decodeString(vm.group(&quot;type&quot;)),
240                                      vm.group(&quot;id&quot;),
241                                      vm.group(&quot;val&quot;)));
242                 return;
243             }
244 
245             Matcher tm = TYPE_PATTERN.matcher(l);
246             if (tm.matches()) {
247                 addPubType(new PubType(parseModifiers(tm.group(&quot;modifiers&quot;)),
248                                        tm.group(&quot;fullyQualified&quot;),
249                                        new PubApi()));
250                 return;
251             }
252 
253             throw new AssertionError(&quot;No matching line pattern.&quot;);
254         } catch (Throwable e) {
255             throw new AssertionError(&quot;Could not parse API line: &quot; + l, e);
256         }
257     }
258 
259     public void addPubType(PubType t) {
260         types.put(t.fqName, t);
261         lastInsertedType = t;
262     }
263 
264     public void addPubVar(PubVar v) {
265         variables.put(v.identifier, v);
266     }
267 
268     public void addPubMethod(PubMethod m) {
269         methods.put(m.asSignatureString(), m);
270     }
271 
272     private static List&lt;TypeDesc&gt; parseTypeDescs(List&lt;String&gt; strs) {
273         return strs.stream()
274                    .map(TypeDesc::decodeString)
275                    .collect(Collectors.toList());
276     }
277 
278     private static List&lt;PubApiTypeParam&gt; parseTypeParams(List&lt;String&gt; strs) {
279         return strs.stream().map(PubApi::parseTypeParam).collect(Collectors.toList());
280     }
281 
282     // Parse a type parameter string. Example input:
283     //     identifier
284     //     identifier extends Type (&amp; Type)*
285     private static PubApiTypeParam parseTypeParam(String typeParamString) {
286         int extPos = typeParamString.indexOf(&quot; extends &quot;);
287         if (extPos == -1)
288             return new PubApiTypeParam(typeParamString, Collections.emptyList());
289         String identifier = typeParamString.substring(0, extPos);
290         String rest = typeParamString.substring(extPos + &quot; extends &quot;.length());
291         List&lt;TypeDesc&gt; bounds = parseTypeDescs(splitOnTopLevelChars(rest, &#39;&amp;&#39;));
292         return new PubApiTypeParam(identifier, bounds);
293     }
294 
295     public Set&lt;Modifier&gt; parseModifiers(String modifiers) {
296         if (modifiers == null)
297             return Collections.emptySet();
298         return Stream.of(modifiers.split(&quot; &quot;))
299                      .map(String::trim)
300                      .map(StringUtils::toUpperCase)
301                      .filter(s -&gt; !s.isEmpty())
302                      .map(Modifier::valueOf)
303                      .collect(Collectors.toSet());
304     }
305 
306     // Find closing tag of the opening tag at the given &#39;pos&#39;.
307     private static int findClosingTag(String l, int pos) {
308         while (true) {
309             pos = pos + 1;
310             if (l.charAt(pos) == &#39;&gt;&#39;)
311                 return pos;
312             if (l.charAt(pos) == &#39;&lt;&#39;)
313                 pos = findClosingTag(l, pos);
314         }
315     }
316 
317     public List&lt;String&gt; splitOnTopLevelCommas(String s) {
318         return splitOnTopLevelChars(s, &#39;,&#39;);
319     }
320 
321     public static List&lt;String&gt; splitOnTopLevelChars(String s, char split) {
322         if (s.isEmpty())
323             return Collections.emptyList();
324         List&lt;String&gt; result = new ArrayList&lt;&gt;();
325         StringBuilder buf = new StringBuilder();
326         int depth = 0;
327         for (char c : s.toCharArray()) {
328             if (c == split &amp;&amp; depth == 0) {
329                 result.add(buf.toString().trim());
330                 buf = new StringBuilder();
331             } else {
332                 if (c == &#39;&lt;&#39;) depth++;
333                 if (c == &#39;&gt;&#39;) depth--;
334                 buf.append(c);
335             }
336         }
337         result.add(buf.toString().trim());
338         return result;
339     }
340 
341     public boolean isEmpty() {
342         return types.isEmpty() &amp;&amp; variables.isEmpty() &amp;&amp; methods.isEmpty();
343     }
344 
345     // Used for descriptive debug messages when figuring out what triggers
346     // recompilation.
347     public List&lt;String&gt; diff(PubApi prevApi) {
348         return diff(&quot;&quot;, prevApi);
349     }
350     private List&lt;String&gt; diff(String scopePrefix, PubApi prevApi) {
351 
352         List&lt;String&gt; diffs = new ArrayList&lt;&gt;();
353 
354         for (String typeKey : union(types.keySet(), prevApi.types.keySet())) {
355             PubType type = types.get(typeKey);
356             PubType prevType = prevApi.types.get(typeKey);
357             if (prevType == null) {
358                 diffs.add(&quot;Type &quot; + scopePrefix + typeKey + &quot; was added&quot;);
359             } else if (type == null) {
360                 diffs.add(&quot;Type &quot; + scopePrefix + typeKey + &quot; was removed&quot;);
361             } else {
362                 // Check modifiers
363                 if (!type.modifiers.equals(prevType.modifiers)) {
364                     diffs.add(&quot;Modifiers for type &quot; + scopePrefix + typeKey
365                             + &quot; changed from &quot; + prevType.modifiers + &quot; to &quot;
366                             + type.modifiers);
367                 }
368 
369                 // Recursively check types pub API
370                 diffs.addAll(type.pubApi.diff(prevType.pubApi));
371             }
372         }
373 
374         for (String varKey : union(variables.keySet(), prevApi.variables.keySet())) {
375             PubVar var = variables.get(varKey);
376             PubVar prevVar = prevApi.variables.get(varKey);
377             if (prevVar == null) {
378                 diffs.add(&quot;Variable &quot; + scopePrefix + varKey + &quot; was added&quot;);
379             } else if (var == null) {
380                 diffs.add(&quot;Variable &quot; + scopePrefix + varKey + &quot; was removed&quot;);
381             } else {
382                 if (!var.modifiers.equals(prevVar.modifiers)) {
383                     diffs.add(&quot;Modifiers for var &quot; + scopePrefix + varKey
384                             + &quot; changed from &quot; + prevVar.modifiers + &quot; to &quot;
385                             + var.modifiers);
386                 }
387                 if (!var.type.equals(prevVar.type)) {
388                     diffs.add(&quot;Type of &quot; + scopePrefix + varKey
389                             + &quot; changed from &quot; + prevVar.type + &quot; to &quot;
390                             + var.type);
391                 }
392                 if (!var.getConstValue().equals(prevVar.getConstValue())) {
393                     diffs.add(&quot;Const value of &quot; + scopePrefix + varKey
394                             + &quot; changed from &quot; + prevVar.getConstValue().orElse(&quot;&lt;none&gt;&quot;)
395                             + &quot; to &quot; + var.getConstValue().orElse(&quot;&lt;none&gt;&quot;));
396                 }
397             }
398         }
399 
400         for (String methodKey : union(methods.keySet(), prevApi.methods.keySet())) {
401             PubMethod method = methods.get(methodKey);
402             PubMethod prevMethod = prevApi.methods.get(methodKey);
403             if (prevMethod == null) {
404                 diffs.add(&quot;Method &quot; + scopePrefix + methodKey + &quot; was added&quot;);
405             } else if (method == null) {
406                 diffs.add(&quot;Method &quot; + scopePrefix + methodKey + &quot; was removed&quot;);
407             } else {
408                 if (!method.modifiers.equals(prevMethod.modifiers)) {
409                     diffs.add(&quot;Modifiers for method &quot; + scopePrefix + methodKey
410                             + &quot; changed from &quot; + prevMethod.modifiers + &quot; to &quot;
411                             + method.modifiers);
412                 }
413                 if (!method.typeParams.equals(prevMethod.typeParams)) {
414                     diffs.add(&quot;Type parameters for method &quot; + scopePrefix
415                             + methodKey + &quot; changed from &quot; + prevMethod.typeParams
416                             + &quot; to &quot; + method.typeParams);
417                 }
418                 if (!method.throwDecls.equals(prevMethod.throwDecls)) {
419                     diffs.add(&quot;Throw decl for method &quot; + scopePrefix + methodKey
420                             + &quot; changed from &quot; + prevMethod.throwDecls + &quot; to &quot;
421                             + &quot; to &quot; + method.throwDecls);
422                 }
423             }
424         }
425 
426         return diffs;
427     }
428 
429     public String toString() {
430         return String.format(&quot;%s[types: %s, variables: %s, methods: %s]&quot;,
431                              getClass().getSimpleName(),
432                              types.values(),
433                              variables.values(),
434                              methods.values());
435     }
436 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
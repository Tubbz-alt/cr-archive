diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Analyzer.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Analyzer.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Analyzer.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Analyzer.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -24,15 +24,16 @@
  */
 
 package com.sun.tools.javac.comp;
 
 import java.util.ArrayDeque;
+import java.util.Arrays;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Queue;
-import java.util.function.Predicate;
+import java.util.stream.Collectors;
 
 import com.sun.source.tree.LambdaExpressionTree;
 import com.sun.source.tree.NewClassTree;
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.code.Kinds.Kind;
@@ -40,10 +41,11 @@
 import com.sun.tools.javac.code.Source.Feature;
 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.code.Types;
 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
+import com.sun.tools.javac.comp.DeferredAttr.AttributionMode;
 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.JCTree.JCBlock;
 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
@@ -444,11 +446,11 @@
     /**
      * Create a copy of Env if needed.
      */
     Env<AttrContext> copyEnvIfNeeded(JCTree tree, Env<AttrContext> env) {
         if (!analyzerModes.isEmpty() &&
-                !env.info.isSpeculative &&
+                !env.info.attributionMode.isSpeculative &&
                 TreeInfo.isStatement(tree) &&
                 !tree.hasTag(LABELLED)) {
             Env<AttrContext> analyzeEnv =
                     env.dup(env.tree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));
             analyzeEnv.info.returnResult = analyzeEnv.info.returnResult != null ?
@@ -560,14 +562,18 @@
                                     .Block(Flags.SYNTHETIC, List.of((JCStatement)rewriting.originalTree));
             }
 
             //TODO: to further refine the analysis, try all rewriting combinations
             deferredAttr.attribSpeculative(treeToAnalyze, rewriting.env, attr.statInfo, new TreeRewriter(rewriting),
-                    t -> rewriting.diagHandler(), argumentAttr.withLocalCacheContext());
+                    () -> rewriting.diagHandler(), AttributionMode.ANALYZER, argumentAttr.withLocalCacheContext());
             rewriting.analyzer.process(rewriting.oldTree, rewriting.replacement, rewriting.erroneous);
         } catch (Throwable ex) {
-            Assert.error("Analyzer error when processing: " + rewriting.originalTree);
+            Assert.error("Analyzer error when processing: " +
+                         rewriting.originalTree + ":" + ex.toString() + "\n" +
+                         Arrays.stream(ex.getStackTrace())
+                               .map(se -> se.toString())
+                               .collect(Collectors.joining("\n")));
         } finally {
             log.useSource(prevSource.getFile());
             localCacheContext.leave();
         }
     }
@@ -625,10 +631,15 @@
 
         @Override
         public void visitBlock(JCBlock tree) {
             //do nothing (prevents seeing same stuff twice)
         }
+
+        @Override
+        public void visitLambda(JCLambda tree) {
+            //do nothing (prevents seeing same stuff in lambda expression twice)
+        }
 
         @Override
         public void visitSwitch(JCSwitch tree) {
             scan(tree.getExpression());
         }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Operators.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Modules.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Resolve.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Operators.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
212     private OperatorSymbol reportErrorIfNeeded(DiagnosticPosition pos, Tag tag, Type... args) {
213         if (Stream.of(args).noneMatch(t -&gt; t.isErroneous() || t.hasTag(TypeTag.NONE))) {
214             Name opName = operatorName(tag);
215             JCDiagnostic.Error opError = (args.length) == 1 ?
216                     Errors.OperatorCantBeApplied(opName, args[0]) :
217                     Errors.OperatorCantBeApplied1(opName, args[0], args[1]);
218             log.error(pos, opError);
219         }
220         return noOpSymbol;
221     }
222 
223     /**
224      * Return name of operator with given tree tag.
225      */
226     public Name operatorName(JCTree.Tag tag) {
227         return opname[tag.operatorIndex()];
228     }
229 
230     /**
231      * The constants in this enum represent the types upon which all the operator helpers
<span class="line-modified">232      * operate upon. This allows lazy and consise mapping between a type name and a type instance.</span>
233      */
234     enum OperatorType {
235         BYTE(syms -&gt; syms.byteType),
236         SHORT(syms -&gt; syms.shortType),
237         INT(syms -&gt; syms.intType),
238         LONG(syms -&gt; syms.longType),
239         FLOAT(syms -&gt; syms.floatType),
240         DOUBLE(syms -&gt; syms.doubleType),
241         CHAR(syms -&gt; syms.charType),
242         BOOLEAN(syms -&gt; syms.booleanType),
243         OBJECT(syms -&gt; syms.objectType),
244         STRING(syms -&gt; syms.stringType),
245         BOT(syms -&gt; syms.botType);
246 
247         final Function&lt;Symtab, Type&gt; asTypeFunc;
248 
249         OperatorType(Function&lt;Symtab, Type&gt; asTypeFunc) {
250             this.asTypeFunc = asTypeFunc;
251         }
252 
</pre>
<hr />
<pre>
263      * initialization circularities between this class and {@code Symtab}.
264      */
265     abstract class OperatorHelper {
266 
267         /** The operator name. */
268         final Name name;
269 
270         /** The list of symbols associated with this operator (lazily populated). */
271         Optional&lt;OperatorSymbol[]&gt; alternatives = Optional.empty();
272 
273         /** An array of operator symbol suppliers (used to lazily populate the symbol list). */
274         List&lt;Supplier&lt;OperatorSymbol&gt;&gt; operatorSuppliers = List.nil();
275 
276         @SuppressWarnings(&quot;varargs&quot;)
277         OperatorHelper(Tag tag) {
278             this.name = operatorName(tag);
279         }
280 
281         /**
282          * This routine implements the main operator lookup process. Each operator is tested
<span class="line-modified">283          * using an applicability predicate; if the test suceeds that same operator is returned,</span>
284          * otherwise a dummy symbol is returned.
285          */
286         final OperatorSymbol doLookup(Predicate&lt;OperatorSymbol&gt; applicabilityTest) {
287             return Stream.of(alternatives.orElseGet(this::initOperators))
288                     .filter(applicabilityTest)
289                     .findFirst()
290                     .orElse(noOpSymbol);
291         }
292 
293         /**
294          * This routine performs lazy instantiation of the operator symbols supported by this helper.
295          * After initialization is done, the suppliers are cleared, to free up memory.
296          */
297         private OperatorSymbol[] initOperators() {
298             OperatorSymbol[] operators = operatorSuppliers.stream()
299                     .map(Supplier::get)
300                     .toArray(OperatorSymbol[]::new);
301             alternatives = Optional.of(operators);
302             operatorSuppliers = null; //let GC do its work
303             return operators;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
212     private OperatorSymbol reportErrorIfNeeded(DiagnosticPosition pos, Tag tag, Type... args) {
213         if (Stream.of(args).noneMatch(t -&gt; t.isErroneous() || t.hasTag(TypeTag.NONE))) {
214             Name opName = operatorName(tag);
215             JCDiagnostic.Error opError = (args.length) == 1 ?
216                     Errors.OperatorCantBeApplied(opName, args[0]) :
217                     Errors.OperatorCantBeApplied1(opName, args[0], args[1]);
218             log.error(pos, opError);
219         }
220         return noOpSymbol;
221     }
222 
223     /**
224      * Return name of operator with given tree tag.
225      */
226     public Name operatorName(JCTree.Tag tag) {
227         return opname[tag.operatorIndex()];
228     }
229 
230     /**
231      * The constants in this enum represent the types upon which all the operator helpers
<span class="line-modified">232      * operate upon. This allows lazy and concise mapping between a type name and a type instance.</span>
233      */
234     enum OperatorType {
235         BYTE(syms -&gt; syms.byteType),
236         SHORT(syms -&gt; syms.shortType),
237         INT(syms -&gt; syms.intType),
238         LONG(syms -&gt; syms.longType),
239         FLOAT(syms -&gt; syms.floatType),
240         DOUBLE(syms -&gt; syms.doubleType),
241         CHAR(syms -&gt; syms.charType),
242         BOOLEAN(syms -&gt; syms.booleanType),
243         OBJECT(syms -&gt; syms.objectType),
244         STRING(syms -&gt; syms.stringType),
245         BOT(syms -&gt; syms.botType);
246 
247         final Function&lt;Symtab, Type&gt; asTypeFunc;
248 
249         OperatorType(Function&lt;Symtab, Type&gt; asTypeFunc) {
250             this.asTypeFunc = asTypeFunc;
251         }
252 
</pre>
<hr />
<pre>
263      * initialization circularities between this class and {@code Symtab}.
264      */
265     abstract class OperatorHelper {
266 
267         /** The operator name. */
268         final Name name;
269 
270         /** The list of symbols associated with this operator (lazily populated). */
271         Optional&lt;OperatorSymbol[]&gt; alternatives = Optional.empty();
272 
273         /** An array of operator symbol suppliers (used to lazily populate the symbol list). */
274         List&lt;Supplier&lt;OperatorSymbol&gt;&gt; operatorSuppliers = List.nil();
275 
276         @SuppressWarnings(&quot;varargs&quot;)
277         OperatorHelper(Tag tag) {
278             this.name = operatorName(tag);
279         }
280 
281         /**
282          * This routine implements the main operator lookup process. Each operator is tested
<span class="line-modified">283          * using an applicability predicate; if the test succeeds that same operator is returned,</span>
284          * otherwise a dummy symbol is returned.
285          */
286         final OperatorSymbol doLookup(Predicate&lt;OperatorSymbol&gt; applicabilityTest) {
287             return Stream.of(alternatives.orElseGet(this::initOperators))
288                     .filter(applicabilityTest)
289                     .findFirst()
290                     .orElse(noOpSymbol);
291         }
292 
293         /**
294          * This routine performs lazy instantiation of the operator symbols supported by this helper.
295          * After initialization is done, the suppliers are cleared, to free up memory.
296          */
297         private OperatorSymbol[] initOperators() {
298             OperatorSymbol[] operators = operatorSuppliers.stream()
299                     .map(Supplier::get)
300                     .toArray(OperatorSymbol[]::new);
301             alternatives = Optional.of(operators);
302             operatorSuppliers = null; //let GC do its work
303             return operators;
</pre>
</td>
</tr>
</table>
<center><a href="Modules.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Resolve.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
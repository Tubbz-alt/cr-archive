<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FSInfo.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Locations.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,10 +25,11 @@</span>
  
  package com.sun.tools.javac.file;
  
  import java.io.File;
  import java.io.IOException;
<span class="udiff-line-added">+ import java.io.UncheckedIOException;</span>
  import java.lang.module.Configuration;
  import java.lang.module.ModuleFinder;
  import java.net.MalformedURLException;
  import java.net.URI;
  import java.net.URISyntaxException;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,10 +70,11 @@</span>
  import javax.tools.JavaFileObject;
  import javax.tools.StandardJavaFileManager;
  
  import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
  import com.sun.tools.javac.file.RelativePath.RelativeFile;
<span class="udiff-line-added">+ import com.sun.tools.javac.main.Option;</span>
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.util.Assert;
  import com.sun.tools.javac.util.Context;
  import com.sun.tools.javac.util.Context.Factory;
  import com.sun.tools.javac.util.DefinedBy;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126,10 +128,23 @@</span>
          }
      }
  
      protected SortFiles sortFiles;
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * We use a two-layered map instead of a map with a complex key because we don&#39;t want to reindex</span>
<span class="udiff-line-added">+      * the values for every Location+RelativeDirectory pair. Once the PathsAndContainers are needed</span>
<span class="udiff-line-added">+      * for a single Location, we should know all valid RelativeDirectory mappings. Because the</span>
<span class="udiff-line-added">+      * indexing is costly for very large classpaths, this can result in a significant savings.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private Map&lt;Location, Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt;&gt;</span>
<span class="udiff-line-added">+         pathsAndContainersByLocationAndRelativeDirectory = new HashMap&lt;&gt;();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Containers that have no indexing by {@link RelativeDirectory}, keyed by {@link Location}. */</span>
<span class="udiff-line-added">+     private Map&lt;Location, java.util.List&lt;PathAndContainer&gt;&gt; nonIndexingContainersByLocation =</span>
<span class="udiff-line-added">+         new HashMap&lt;&gt;();</span>
<span class="udiff-line-added">+ </span>
      /**
       * Register a Context.Factory to create a JavacFileManager.
       */
      public static void preRegister(Context context) {
          context.put(JavaFileManager.class,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,10 +351,17 @@</span>
                                    Set&lt;JavaFileObject.Kind&gt; fileKinds,
                                    boolean recurse,
                                    ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException;
          public abstract JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException;
          public abstract void close() throws IOException;
<span class="udiff-line-added">+         public abstract boolean maintainsDirectoryIndex();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * The directories this container indexes if {@link #maintainsDirectoryIndex()}, otherwise</span>
<span class="udiff-line-added">+          * an empty iterable.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public abstract Iterable&lt;RelativeDirectory&gt; indexedDirectories();</span>
      }
  
      private static final Container MISSING_CONTAINER =  new Container() {
          @Override
          public void list(Path userPath,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,10 +374,18 @@</span>
          public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
              return null;
          }
          @Override
          public void close() throws IOException {}
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean maintainsDirectoryIndex() {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="udiff-line-added">+             return List.nil();</span>
<span class="udiff-line-added">+         }</span>
      };
  
      private final class JRTImageContainer implements Container {
  
          /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,10 +435,20 @@</span>
          }
  
          @Override
          public void close() throws IOException {
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean maintainsDirectoryIndex() {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="udiff-line-added">+             return List.nil();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      private synchronized JRTIndex getJRTIndex() {
          if (jrtIndex == null)
              jrtIndex = JRTIndex.getSharedInstance();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -496,29 +536,39 @@</span>
          }
  
          @Override
          public void close() throws IOException {
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean maintainsDirectoryIndex() {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="udiff-line-added">+             return List.nil();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      private static final Set&lt;FileVisitOption&gt; NO_FILE_VISIT_OPTIONS = Set.of();
      private static final Set&lt;FileVisitOption&gt; FOLLOW_LINKS_OPTIONS = Set.of(FOLLOW_LINKS);
  
      private final class ArchiveContainer implements Container {
          private final Path archivePath;
          private final FileSystem fileSystem;
<span class="udiff-line-modified-removed">-         private final Map&lt;RelativePath, Path&gt; packages;</span>
<span class="udiff-line-modified-added">+         private final Map&lt;RelativeDirectory, Path&gt; packages;</span>
  
          public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {
              this.archivePath = archivePath;
              if (multiReleaseValue != null &amp;&amp; archivePath.toString().endsWith(&quot;.jar&quot;)) {
                  Map&lt;String,String&gt; env = Collections.singletonMap(&quot;multi-release&quot;, multiReleaseValue);
                  FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();
                  Assert.checkNonNull(jarFSProvider, &quot;should have been caught before!&quot;);
                  this.fileSystem = jarFSProvider.newFileSystem(archivePath, env);
              } else {
<span class="udiff-line-modified-removed">-                 this.fileSystem = FileSystems.newFileSystem(archivePath, null);</span>
<span class="udiff-line-modified-added">+                 this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);</span>
              }
              packages = new HashMap&lt;&gt;();
              for (Path root : fileSystem.getRootDirectories()) {
                  Files.walkFileTree(root, NO_FILE_VISIT_OPTIONS, Integer.MAX_VALUE,
                          new SimpleFileVisitor&lt;Path&gt;() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -602,10 +652,20 @@</span>
  
          @Override
          public void close() throws IOException {
              fileSystem.close();
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean maintainsDirectoryIndex() {</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="udiff-line-added">+             return packages.keySet();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /**
       * container is a directory, a zip file, or a non-existent path.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -652,10 +712,12 @@</span>
      /** Flush any output resources.
       */
      @Override @DefinedBy(Api.COMPILER)
      public void flush() {
          contentCache.clear();
<span class="udiff-line-added">+         pathsAndContainersByLocationAndRelativeDirectory.clear();</span>
<span class="udiff-line-added">+         nonIndexingContainersByLocation.clear();</span>
      }
  
      /**
       * Close the JavaFileManager, releasing resources.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,10 +731,12 @@</span>
          locations.close();
          for (Container container: containers.values()) {
              container.close();
          }
          containers.clear();
<span class="udiff-line-added">+         pathsAndContainersByLocationAndRelativeDirectory.clear();</span>
<span class="udiff-line-added">+         nonIndexingContainersByLocation.clear();</span>
          contentCache.clear();
      }
  
      @Override @DefinedBy(Api.COMPILER)
      public ClassLoader getClassLoader(Location location) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -702,19 +766,16 @@</span>
          checkNotModuleOrientedLocation(location);
          // validatePackageName(packageName);
          nullCheck(packageName);
          nullCheck(kinds);
  
<span class="udiff-line-removed">-         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);</span>
<span class="udiff-line-removed">-         if (path == null)</span>
<span class="udiff-line-removed">-             return List.nil();</span>
          RelativeDirectory subdirectory = RelativeDirectory.forPackage(packageName);
          ListBuffer&lt;JavaFileObject&gt; results = new ListBuffer&lt;&gt;();
  
<span class="udiff-line-modified-removed">-         for (Path directory : path) {</span>
<span class="udiff-line-modified-removed">-             Container container = getContainer(directory);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+         for (PathAndContainer pathAndContainer : pathsAndContainers(location, subdirectory)) {</span>
<span class="udiff-line-modified-added">+             Path directory = pathAndContainer.path;</span>
<span class="udiff-line-modified-added">+             Container container = pathAndContainer.container;</span>
              container.list(directory, subdirectory, kinds, recurse, results);
          }
  
          return results.toList();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -895,11 +956,11 @@</span>
          return result;
      }
  
      @Override @DefinedBy(Api.COMPILER)
      public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(
<span class="udiff-line-modified-removed">-         Iterable&lt;? extends Path&gt; paths)</span>
<span class="udiff-line-modified-added">+         Collection&lt;? extends Path&gt; paths)</span>
      {
          ArrayList&lt;PathFileObject&gt; result;
          if (paths instanceof Collection&lt;?&gt;)
              result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)paths).size());
          else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -925,33 +986,137 @@</span>
                              Iterable&lt;? extends File&gt; searchpath)
          throws IOException
      {
          nullCheck(location);
          locations.setLocation(location, asPaths(searchpath));
<span class="udiff-line-added">+         clearCachesForLocation(location);</span>
      }
  
      @Override @DefinedBy(Api.COMPILER)
      public void setLocationFromPaths(Location location,
                              Collection&lt;? extends Path&gt; searchpath)
          throws IOException
      {
          nullCheck(location);
          locations.setLocation(location, nullCheck(searchpath));
<span class="udiff-line-added">+         clearCachesForLocation(location);</span>
      }
  
      @Override @DefinedBy(Api.COMPILER)
      public Iterable&lt;? extends File&gt; getLocation(Location location) {
          nullCheck(location);
          return asFiles(locations.getLocation(location));
      }
  
      @Override @DefinedBy(Api.COMPILER)
<span class="udiff-line-modified-removed">-     public Iterable&lt;? extends Path&gt; getLocationAsPaths(Location location) {</span>
<span class="udiff-line-modified-added">+     public Collection&lt;? extends Path&gt; getLocationAsPaths(Location location) {</span>
          nullCheck(location);
          return locations.getLocation(location);
      }
  
<span class="udiff-line-added">+     private java.util.List&lt;PathAndContainer&gt; pathsAndContainers(</span>
<span class="udiff-line-added">+             Location location, RelativeDirectory relativeDirectory) throws IOException {</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return pathsAndContainersByLocationAndRelativeDirectory.computeIfAbsent(</span>
<span class="udiff-line-added">+                     location, this::indexPathsAndContainersByRelativeDirectory)</span>
<span class="udiff-line-added">+                 .computeIfAbsent(</span>
<span class="udiff-line-added">+                     relativeDirectory, d -&gt; nonIndexingContainersByLocation.get(location));</span>
<span class="udiff-line-added">+         } catch (UncheckedIOException e) {</span>
<span class="udiff-line-added">+             throw e.getCause();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt; indexPathsAndContainersByRelativeDirectory(</span>
<span class="udiff-line-added">+             Location location) {</span>
<span class="udiff-line-added">+         Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt; result = new HashMap&lt;&gt;();</span>
<span class="udiff-line-added">+         java.util.List&lt;PathAndContainer&gt; allPathsAndContainers = pathsAndContainers(location);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // First collect all of the containers that don&#39;t maintain their own index on</span>
<span class="udiff-line-added">+         // RelativeDirectory. These need to always be included for all mappings</span>
<span class="udiff-line-added">+         java.util.List&lt;PathAndContainer&gt; nonIndexingContainers = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+         for (PathAndContainer pathAndContainer : allPathsAndContainers) {</span>
<span class="udiff-line-added">+             if (!pathAndContainer.container.maintainsDirectoryIndex()) {</span>
<span class="udiff-line-added">+                 nonIndexingContainers.add(pathAndContainer);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Next, use the container that do maintain their own RelativeDirectory index to create a</span>
<span class="udiff-line-added">+         // single master index.</span>
<span class="udiff-line-added">+         for (PathAndContainer pathAndContainer : allPathsAndContainers) {</span>
<span class="udiff-line-added">+             Container container = pathAndContainer.container;</span>
<span class="udiff-line-added">+             if (container.maintainsDirectoryIndex()) {</span>
<span class="udiff-line-added">+                 for (RelativeDirectory directory : container.indexedDirectories()) {</span>
<span class="udiff-line-added">+                     result.computeIfAbsent(directory, d -&gt; new ArrayList&lt;&gt;(nonIndexingContainers))</span>
<span class="udiff-line-added">+                           .add(pathAndContainer);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         nonIndexingContainersByLocation.put(location, nonIndexingContainers);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Sorting preserves the search order used in the uncached Location path, which has</span>
<span class="udiff-line-added">+         // maintains consistency with the classpath order</span>
<span class="udiff-line-added">+         result.values().forEach(pathAndContainerList -&gt; Collections.sort(pathAndContainerList));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return result;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * For each {@linkplain #getLocationAsPaths(Location) path of the location}, compute the</span>
<span class="udiff-line-added">+      * corresponding {@link Container}.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private java.util.List&lt;PathAndContainer&gt; pathsAndContainers(Location location) {</span>
<span class="udiff-line-added">+         Collection&lt;? extends Path&gt; paths = getLocationAsPaths(location);</span>
<span class="udiff-line-added">+         if (paths == null) {</span>
<span class="udiff-line-added">+             return List.nil();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         java.util.List&lt;PathAndContainer&gt; pathsAndContainers =</span>
<span class="udiff-line-added">+             new ArrayList&lt;&gt;(paths.size());</span>
<span class="udiff-line-added">+         for (Path path : paths) {</span>
<span class="udiff-line-added">+             Container container;</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 container = getContainer(path);</span>
<span class="udiff-line-added">+             } catch (IOException e) {</span>
<span class="udiff-line-added">+                 throw new UncheckedIOException(e);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             pathsAndContainers.add(new PathAndContainer(path, container, pathsAndContainers.size()));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return pathsAndContainers;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static class PathAndContainer implements Comparable&lt;PathAndContainer&gt; {</span>
<span class="udiff-line-added">+         private final Path path;</span>
<span class="udiff-line-added">+         private final Container container;</span>
<span class="udiff-line-added">+         private final int index;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         PathAndContainer(Path path, Container container, int index) {</span>
<span class="udiff-line-added">+             this.path = path;</span>
<span class="udiff-line-added">+             this.container = container;</span>
<span class="udiff-line-added">+             this.index = index;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int compareTo(PathAndContainer other) {</span>
<span class="udiff-line-added">+             return index - other.index;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean equals(Object o) {</span>
<span class="udiff-line-added">+           if (o == null || !(o instanceof PathAndContainer)) {</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           PathAndContainer that = (PathAndContainer) o;</span>
<span class="udiff-line-added">+           return path.equals(that.path)</span>
<span class="udiff-line-added">+               &amp;&amp; container.equals(that.container)</span>
<span class="udiff-line-added">+               &amp;&amp; index == this.index;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int hashCode() {</span>
<span class="udiff-line-added">+           return Objects.hash(path, container, index);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      @Override @DefinedBy(Api.COMPILER)
      public boolean contains(Location location, FileObject fo) throws IOException {
          nullCheck(location);
          nullCheck(fo);
          Path p = asPath(fo);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1006,10 +1171,11 @@</span>
      public void setLocationForModule(Location location, String moduleName, Collection&lt;? extends Path&gt; paths)
              throws IOException {
          nullCheck(location);
          checkModuleOrientedOrOutputLocation(location);
          locations.setLocationForModule(location, nullCheck(moduleName), nullCheck(paths));
<span class="udiff-line-added">+         clearCachesForLocation(location);</span>
      }
  
      @Override @DefinedBy(Api.COMPILER)
      public String inferModuleName(Location location) {
          checkNotModuleOrientedLocation(location);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1081,11 +1247,11 @@</span>
  
      /**
       * Get a detail message from an IOException.
       * Most, but not all, instances of IOException provide a non-null result
       * for getLocalizedMessage().  But some instances return null: in these
<span class="udiff-line-modified-removed">-      * cases, fallover to getMessage(), and if even that is null, return the</span>
<span class="udiff-line-modified-added">+      * cases, fall back to getMessage(), and if even that is null, return the</span>
       * name of the exception itself.
       * @param e an IOException
       * @return a string to include in a compiler diagnostic
       */
      public static String getMessage(IOException e) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1161,6 +1327,21 @@</span>
                      throw new IllegalStateException(e);
                  }
              }
          };
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public boolean handleOption(Option option, String value) {</span>
<span class="udiff-line-added">+         if (javacFileManagerOptions.contains(option)) {</span>
<span class="udiff-line-added">+             pathsAndContainersByLocationAndRelativeDirectory.clear();</span>
<span class="udiff-line-added">+             nonIndexingContainersByLocation.clear();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return super.handleOption(option, value);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private void clearCachesForLocation(Location location) {</span>
<span class="udiff-line-added">+         nullCheck(location);</span>
<span class="udiff-line-added">+         pathsAndContainersByLocationAndRelativeDirectory.remove(location);</span>
<span class="udiff-line-added">+         nonIndexingContainersByLocation.remove(location);</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="FSInfo.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Locations.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
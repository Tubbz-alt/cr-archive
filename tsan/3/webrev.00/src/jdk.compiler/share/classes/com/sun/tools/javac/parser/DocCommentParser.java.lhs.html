<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/DocCommentParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.text.BreakIterator;
  29 import java.util.HashMap;
  30 import java.util.Map;
  31 
  32 import com.sun.source.doctree.AttributeTree.ValueKind;
  33 import com.sun.tools.javac.parser.DocCommentParser.TagParser.Kind;
  34 import com.sun.tools.javac.parser.Tokens.Comment;
  35 import com.sun.tools.javac.parser.Tokens.TokenKind;
  36 import com.sun.tools.javac.tree.DCTree;
  37 import com.sun.tools.javac.tree.DCTree.DCAttribute;
  38 import com.sun.tools.javac.tree.DCTree.DCDocComment;
  39 import com.sun.tools.javac.tree.DCTree.DCEndElement;
  40 import com.sun.tools.javac.tree.DCTree.DCEndPosTree;
  41 import com.sun.tools.javac.tree.DCTree.DCErroneous;
  42 import com.sun.tools.javac.tree.DCTree.DCIdentifier;
  43 import com.sun.tools.javac.tree.DCTree.DCReference;
  44 import com.sun.tools.javac.tree.DCTree.DCStartElement;
  45 import com.sun.tools.javac.tree.DCTree.DCText;
  46 import com.sun.tools.javac.tree.DocTreeMaker;
  47 import com.sun.tools.javac.tree.JCTree;
  48 import com.sun.tools.javac.util.DiagnosticSource;
  49 import com.sun.tools.javac.util.List;
  50 import com.sun.tools.javac.util.ListBuffer;
  51 import com.sun.tools.javac.util.Log;
  52 import com.sun.tools.javac.util.Name;
  53 import com.sun.tools.javac.util.Names;
  54 import com.sun.tools.javac.util.Position;
  55 import com.sun.tools.javac.util.StringUtils;
  56 
  57 import static com.sun.tools.javac.util.LayoutCharacters.*;
  58 
  59 /**
  60  *
  61  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  62  *  If you write code that depends on this, you do so at your own risk.
  63  *  This code and its internal interfaces are subject to change or
  64  *  deletion without notice.&lt;/b&gt;
  65  */
  66 public class DocCommentParser {
  67     static class ParseException extends Exception {
  68         private static final long serialVersionUID = 0;
  69         ParseException(String key) {
  70             super(key);
  71         }
  72     }
  73 
  74     private enum Phase {PREAMBLE, BODY, POSTAMBLE};
  75 
  76     final ParserFactory fac;
  77     final DiagnosticSource diagSource;
  78     final Comment comment;
  79     final DocTreeMaker m;
  80     final Names names;
  81     final boolean isFileContent;
  82 
  83     BreakIterator sentenceBreaker;
  84 
  85     /** The input buffer, index of most recent character read,
  86      *  index of one past last character in buffer.
  87      */
  88     protected char[] buf;
  89     protected int bp;
  90     protected int buflen;
  91 
  92     /** The current character.
  93      */
  94     protected char ch;
  95 
  96     int textStart = -1;
  97     int lastNonWhite = -1;
  98     boolean newline = true;
  99 
 100     Map&lt;Name, TagParser&gt; tagParsers;
 101 
 102     public DocCommentParser(ParserFactory fac, DiagnosticSource diagSource,
 103                             Comment comment, boolean isFileContent) {
 104         this.fac = fac;
 105         this.diagSource = diagSource;
 106         this.comment = comment;
 107         names = fac.names;
 108         this.isFileContent = isFileContent;
 109         m = fac.docTreeMaker;
 110         initTagParsers();
 111     }
 112 
 113     public DocCommentParser(ParserFactory fac, DiagnosticSource diagSource, Comment comment) {
 114         this(fac, diagSource, comment, false);
 115     }
 116 
 117     public DocCommentParser(ParserFactory fac) {
 118         this(fac, null, null, false);
 119     }
 120 
 121     public DCDocComment parse() {
 122         String c = comment.getText();
 123         buf = new char[c.length() + 1];
 124         c.getChars(0, c.length(), buf, 0);
 125         buf[buf.length - 1] = EOI;
 126         buflen = buf.length - 1;
 127         bp = -1;
 128         nextChar();
 129 
 130         List&lt;DCTree&gt; preamble = isFileContent ? blockContent(Phase.PREAMBLE) : List.nil();
 131         List&lt;DCTree&gt; body = blockContent(Phase.BODY);
 132         List&lt;DCTree&gt; tags = blockTags();
 133         List&lt;DCTree&gt; postamble = isFileContent ? blockContent(Phase.POSTAMBLE) : List.nil();
 134 
 135         int pos = Position.NOPOS;
 136         if (!preamble.isEmpty())
 137             pos = preamble.head.pos;
 138         else if (!body.isEmpty())
 139             pos = body.head.pos;
 140         else if (!tags.isEmpty())
 141             pos = tags.head.pos;
 142         else if (!postamble.isEmpty())
 143             pos = postamble.head.pos;
 144 
 145         DCDocComment dc = m.at(pos).newDocCommentTree(comment, body, tags, preamble, postamble);
 146         return dc;
 147     }
 148 
 149     void nextChar() {
 150         ch = buf[bp &lt; buflen ? ++bp : buflen];
 151         switch (ch) {
 152             case &#39;\f&#39;: case &#39;\n&#39;: case &#39;\r&#39;:
 153                 newline = true;
 154         }
 155     }
 156 
 157     protected List&lt;DCTree&gt; blockContent() {
 158         return blockContent(Phase.BODY);
 159     }
 160 
 161     /**
 162      * Read block content, consisting of text, html and inline tags.
 163      * Terminated by the end of input, or the beginning of the next block tag:
 164      * i.e. @ as the first non-whitespace character on a line.
 165      */
 166     @SuppressWarnings(&quot;fallthrough&quot;)
 167     protected List&lt;DCTree&gt; blockContent(Phase phase) {
 168         ListBuffer&lt;DCTree&gt; trees = new ListBuffer&lt;&gt;();
 169         textStart = -1;
 170 
 171         loop:
 172         while (bp &lt; buflen) {
 173             switch (ch) {
 174                 case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\f&#39;:
 175                     newline = true;
 176                     // fallthrough
 177 
 178                 case &#39; &#39;: case &#39;\t&#39;:
 179                     nextChar();
 180                     break;
 181 
 182                 case &#39;&amp;&#39;:
 183                     entity(trees);
 184                     break;
 185 
 186                 case &#39;&lt;&#39;:
 187                     newline = false;
 188                     if (isFileContent) {
 189                         switch (phase) {
 190                             case PREAMBLE:
<a name="2" id="anc2"></a><span class="line-modified"> 191                                 if (peek(&quot;body&quot;)) {</span>
 192                                     trees.add(html());
 193                                     if (textStart == -1) {
 194                                         textStart = bp;
 195                                         lastNonWhite = -1;
 196                                     }
 197                                     // mark this as the start, for processing purposes
 198                                     newline = true;
 199                                     break loop;
 200                                 }
 201                                 break;
 202                             case BODY:
<a name="3" id="anc3"></a><span class="line-modified"> 203                                 if (peek(&quot;/body&quot;)) {</span>
 204                                     addPendingText(trees, lastNonWhite);
 205                                     break loop;
 206                                 }
 207                                 break;
 208                             default:
 209                                 // fallthrough
 210                         }
 211                     }
 212                     addPendingText(trees, bp - 1);
 213                     trees.add(html());
 214 
 215                     if (phase == Phase.PREAMBLE || phase == Phase.POSTAMBLE) {
 216                         break; // Ignore newlines after html tags, in the meta content
 217                     }
 218                     if (textStart == -1) {
 219                         textStart = bp;
 220                         lastNonWhite = -1;
 221                     }
 222                     break;
 223 
 224                 case &#39;&gt;&#39;:
 225                     newline = false;
 226                     addPendingText(trees, bp - 1);
 227                     trees.add(m.at(bp).newErroneousTree(newString(bp, bp + 1), diagSource, &quot;dc.bad.gt&quot;));
 228                     nextChar();
 229                     if (textStart == -1) {
 230                         textStart = bp;
 231                         lastNonWhite = -1;
 232                     }
 233                     break;
 234 
 235                 case &#39;{&#39;:
 236                     inlineTag(trees);
 237                     break;
 238 
 239                 case &#39;@&#39;:
 240                     if (newline) {
 241                         addPendingText(trees, lastNonWhite);
 242                         break loop;
 243                     }
 244                     // fallthrough
 245 
 246                 default:
 247                     newline = false;
 248                     if (textStart == -1)
 249                         textStart = bp;
 250                     lastNonWhite = bp;
 251                     nextChar();
 252             }
 253         }
 254 
 255         if (lastNonWhite != -1)
 256             addPendingText(trees, lastNonWhite);
 257 
 258         return trees.toList();
 259     }
 260 
 261     /**
 262      * Read a series of block tags, including their content.
 263      * Standard tags parse their content appropriately.
 264      * Non-standard tags are represented by {@link UnknownBlockTag}.
 265      */
 266     protected List&lt;DCTree&gt; blockTags() {
 267         ListBuffer&lt;DCTree&gt; tags = new ListBuffer&lt;&gt;();
 268         while (ch == &#39;@&#39;)
 269             tags.add(blockTag());
 270         return tags.toList();
 271     }
 272 
 273     /**
 274      * Read a single block tag, including its content.
 275      * Standard tags parse their content appropriately.
 276      * Non-standard tags are represented by {@link UnknownBlockTag}.
 277      */
 278     protected DCTree blockTag() {
 279         int p = bp;
 280         try {
 281             nextChar();
 282             if (isIdentifierStart(ch)) {
 283                 Name name = readTagName();
 284                 TagParser tp = tagParsers.get(name);
 285                 if (tp == null) {
 286                     List&lt;DCTree&gt; content = blockContent();
 287                     return m.at(p).newUnknownBlockTagTree(name, content);
 288                 } else {
 289                     switch (tp.getKind()) {
 290                         case BLOCK:
 291                             return tp.parse(p);
 292                         case INLINE:
 293                             return erroneous(&quot;dc.bad.inline.tag&quot;, p);
 294                     }
 295                 }
 296             }
 297             blockContent();
 298 
 299             return erroneous(&quot;dc.no.tag.name&quot;, p);
 300         } catch (ParseException e) {
 301             blockContent();
 302             return erroneous(e.getMessage(), p);
 303         }
 304     }
 305 
 306     protected void inlineTag(ListBuffer&lt;DCTree&gt; list) {
 307         newline = false;
 308         nextChar();
 309         if (ch == &#39;@&#39;) {
 310             addPendingText(list, bp - 2);
 311             list.add(inlineTag());
 312             textStart = bp;
 313             lastNonWhite = -1;
 314         } else {
 315             if (textStart == -1)
 316                 textStart = bp - 1;
 317             lastNonWhite = bp;
 318         }
 319     }
 320 
 321     /**
 322      * Read a single inline tag, including its content.
 323      * Standard tags parse their content appropriately.
 324      * Non-standard tags are represented by {@link UnknownBlockTag}.
 325      * Malformed tags may be returned as {@link Erroneous}.
 326      */
 327     protected DCTree inlineTag() {
 328         int p = bp - 1;
 329         try {
 330             nextChar();
 331             if (isIdentifierStart(ch)) {
 332                 Name name = readTagName();
 333                 TagParser tp = tagParsers.get(name);
 334 
 335                 if (tp == null) {
 336                     skipWhitespace();
 337                     DCTree text = inlineText(WhitespaceRetentionPolicy.REMOVE_ALL);
 338                     if (text != null) {
 339                         nextChar();
 340                         return m.at(p).newUnknownInlineTagTree(name, List.of(text)).setEndPos(bp);
 341                     }
 342                 } else {
 343                     if (!tp.retainWhiteSpace) {
 344                         skipWhitespace();
 345                     }
 346                     if (tp.getKind() == TagParser.Kind.INLINE) {
 347                         DCEndPosTree&lt;?&gt; tree = (DCEndPosTree&lt;?&gt;) tp.parse(p);
 348                         if (tree != null) {
 349                             return tree.setEndPos(bp);
 350                         }
 351                     } else { // handle block tags (ex: @see) in inline content
 352                         inlineText(WhitespaceRetentionPolicy.REMOVE_ALL); // skip content
 353                         nextChar();
 354                     }
 355                 }
 356             }
 357             return erroneous(&quot;dc.no.tag.name&quot;, p);
 358         } catch (ParseException e) {
 359             return erroneous(e.getMessage(), p);
 360         }
 361     }
 362 
 363     private static enum WhitespaceRetentionPolicy {
 364         RETAIN_ALL,
 365         REMOVE_FIRST_SPACE,
 366         REMOVE_ALL
 367     }
 368 
 369     /**
 370      * Read plain text content of an inline tag.
 371      * Matching pairs of { } are skipped; the text is terminated by the first
 372      * unmatched }. It is an error if the beginning of the next tag is detected.
 373      */
 374     private DCTree inlineText(WhitespaceRetentionPolicy whitespacePolicy) throws ParseException {
 375         switch (whitespacePolicy) {
 376             case REMOVE_ALL:
 377                 skipWhitespace();
 378                 break;
 379             case REMOVE_FIRST_SPACE:
 380                 if (ch == &#39; &#39;)
 381                     nextChar();
 382                 break;
 383             case RETAIN_ALL:
 384             default:
 385                 // do nothing
 386                 break;
 387 
 388         }
 389         int pos = bp;
 390         int depth = 1;
 391 
 392         loop:
 393         while (bp &lt; buflen) {
 394             switch (ch) {
 395                 case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\f&#39;:
 396                     newline = true;
 397                     break;
 398 
 399                 case &#39; &#39;: case &#39;\t&#39;:
 400                     break;
 401 
 402                 case &#39;{&#39;:
 403                     newline = false;
 404                     lastNonWhite = bp;
 405                     depth++;
 406                     break;
 407 
 408                 case &#39;}&#39;:
 409                     if (--depth == 0) {
 410                         return m.at(pos).newTextTree(newString(pos, bp));
 411                     }
 412                     newline = false;
 413                     lastNonWhite = bp;
 414                     break;
 415 
 416                 case &#39;@&#39;:
 417                     if (newline)
 418                         break loop;
 419                     newline = false;
 420                     lastNonWhite = bp;
 421                     break;
 422 
 423                 default:
 424                     newline = false;
 425                     lastNonWhite = bp;
 426                     break;
 427             }
 428             nextChar();
 429         }
 430         throw new ParseException(&quot;dc.unterminated.inline.tag&quot;);
 431     }
 432 
 433     /**
 434      * Read Java class name, possibly followed by member
 435      * Matching pairs of {@literal &lt; &gt;} are skipped. The text is terminated by the first
 436      * unmatched }. It is an error if the beginning of the next tag is detected.
 437      */
 438     // TODO: boolean allowMember should be enum FORBID, ALLOW, REQUIRE
 439     // TODO: improve quality of parse to forbid bad constructions.
 440     // TODO: update to use ReferenceParser
 441     @SuppressWarnings(&quot;fallthrough&quot;)
 442     protected DCReference reference(boolean allowMember) throws ParseException {
 443         int pos = bp;
 444         int depth = 0;
 445 
 446         // scan to find the end of the signature, by looking for the first
 447         // whitespace not enclosed in () or &lt;&gt;, or the end of the tag
 448         loop:
 449         while (bp &lt; buflen) {
 450             switch (ch) {
 451                 case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\f&#39;:
 452                     newline = true;
 453                     // fallthrough
 454 
 455                 case &#39; &#39;: case &#39;\t&#39;:
 456                     if (depth == 0)
 457                         break loop;
 458                     break;
 459 
 460                 case &#39;(&#39;:
 461                 case &#39;&lt;&#39;:
 462                     newline = false;
 463                     depth++;
 464                     break;
 465 
 466                 case &#39;)&#39;:
 467                 case &#39;&gt;&#39;:
 468                     newline = false;
 469                     --depth;
 470                     break;
 471 
 472                 case &#39;}&#39;:
 473                     if (bp == pos)
 474                         return null;
 475                     newline = false;
 476                     break loop;
 477 
 478                 case &#39;@&#39;:
 479                     if (newline)
 480                         break loop;
 481                     // fallthrough
 482 
 483                 default:
 484                     newline = false;
 485 
 486             }
 487             nextChar();
 488         }
 489 
 490         if (depth != 0)
 491             throw new ParseException(&quot;dc.unterminated.signature&quot;);
 492 
 493         String sig = newString(pos, bp);
 494 
 495         // Break sig apart into qualifiedExpr member paramTypes.
 496         JCTree qualExpr;
 497         Name member;
 498         List&lt;JCTree&gt; paramTypes;
 499 
 500         Log.DeferredDiagnosticHandler deferredDiagnosticHandler
 501                 = new Log.DeferredDiagnosticHandler(fac.log);
 502 
 503         try {
 504             int hash = sig.indexOf(&quot;#&quot;);
 505             int lparen = sig.indexOf(&quot;(&quot;, hash + 1);
 506             if (hash == -1) {
 507                 if (lparen == -1) {
 508                     qualExpr = parseType(sig);
 509                     member = null;
 510                 } else {
 511                     qualExpr = null;
 512                     member = parseMember(sig.substring(0, lparen));
 513                 }
 514             } else {
 515                 qualExpr = (hash == 0) ? null : parseType(sig.substring(0, hash));
 516                 if (lparen == -1)
 517                     member = parseMember(sig.substring(hash + 1));
 518                 else
 519                     member = parseMember(sig.substring(hash + 1, lparen));
 520             }
 521 
 522             if (lparen &lt; 0) {
 523                 paramTypes = null;
 524             } else {
 525                 int rparen = sig.indexOf(&quot;)&quot;, lparen);
 526                 if (rparen != sig.length() - 1)
 527                     throw new ParseException(&quot;dc.ref.bad.parens&quot;);
 528                 paramTypes = parseParams(sig.substring(lparen + 1, rparen));
 529             }
 530 
 531             if (!deferredDiagnosticHandler.getDiagnostics().isEmpty())
 532                 throw new ParseException(&quot;dc.ref.syntax.error&quot;);
 533 
 534         } finally {
 535             fac.log.popDiagnosticHandler(deferredDiagnosticHandler);
 536         }
 537 
 538         return m.at(pos).newReferenceTree(sig, qualExpr, member, paramTypes).setEndPos(bp);
 539     }
 540 
 541     JCTree parseType(String s) throws ParseException {
 542         JavacParser p = fac.newParser(s, false, false, false);
 543         JCTree tree = p.parseType();
 544         if (p.token().kind != TokenKind.EOF)
 545             throw new ParseException(&quot;dc.ref.unexpected.input&quot;);
 546         return tree;
 547     }
 548 
 549     Name parseMember(String s) throws ParseException {
 550         JavacParser p = fac.newParser(s, false, false, false);
 551         Name name = p.ident();
 552         if (p.token().kind != TokenKind.EOF)
 553             throw new ParseException(&quot;dc.ref.unexpected.input&quot;);
 554         return name;
 555     }
 556 
 557     List&lt;JCTree&gt; parseParams(String s) throws ParseException {
 558         if (s.trim().isEmpty())
 559             return List.nil();
 560 
 561         JavacParser p = fac.newParser(s.replace(&quot;...&quot;, &quot;[]&quot;), false, false, false);
 562         ListBuffer&lt;JCTree&gt; paramTypes = new ListBuffer&lt;&gt;();
 563         paramTypes.add(p.parseType());
 564 
 565         if (p.token().kind == TokenKind.IDENTIFIER)
 566             p.nextToken();
 567 
 568         while (p.token().kind == TokenKind.COMMA) {
 569             p.nextToken();
 570             paramTypes.add(p.parseType());
 571 
 572             if (p.token().kind == TokenKind.IDENTIFIER)
 573                 p.nextToken();
 574         }
 575 
 576         if (p.token().kind != TokenKind.EOF)
 577             throw new ParseException(&quot;dc.ref.unexpected.input&quot;);
 578 
 579         return paramTypes.toList();
 580     }
 581 
 582     /**
 583      * Read Java identifier
 584      * Matching pairs of { } are skipped; the text is terminated by the first
 585      * unmatched }. It is an error if the beginning of the next tag is detected.
 586      */
 587     @SuppressWarnings(&quot;fallthrough&quot;)
 588     protected DCIdentifier identifier() throws ParseException {
 589         skipWhitespace();
 590         int pos = bp;
 591 
 592         if (isJavaIdentifierStart(ch)) {
 593             Name name = readJavaIdentifier();
 594             return m.at(pos).newIdentifierTree(name);
 595         }
 596 
 597         throw new ParseException(&quot;dc.identifier.expected&quot;);
 598     }
 599 
 600     /**
 601      * Read a quoted string.
 602      * It is an error if the beginning of the next tag is detected.
 603      */
 604     @SuppressWarnings(&quot;fallthrough&quot;)
 605     protected DCText quotedString() {
 606         int pos = bp;
 607         nextChar();
 608 
 609         loop:
 610         while (bp &lt; buflen) {
 611             switch (ch) {
 612                 case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\f&#39;:
 613                     newline = true;
 614                     break;
 615 
 616                 case &#39; &#39;: case &#39;\t&#39;:
 617                     break;
 618 
 619                 case &#39;&quot;&#39;:
 620                     nextChar();
 621                     // trim trailing white-space?
 622                     return m.at(pos).newTextTree(newString(pos, bp));
 623 
 624                 case &#39;@&#39;:
 625                     if (newline)
 626                         break loop;
 627 
 628             }
 629             nextChar();
 630         }
 631         return null;
 632     }
 633 
 634     /**
 635      * Read a term ie. one word.
 636      * It is an error if the beginning of the next tag is detected.
 637      */
 638     @SuppressWarnings(&quot;fallthrough&quot;)
 639     protected DCText inlineWord() {
 640         int pos = bp;
 641         int depth = 0;
 642         loop:
 643         while (bp &lt; buflen) {
 644             switch (ch) {
 645                 case &#39;\n&#39;:
 646                     newline = true;
 647                     // fallthrough
 648 
 649                 case &#39;\r&#39;: case &#39;\f&#39;: case &#39; &#39;: case &#39;\t&#39;:
 650                     return m.at(pos).newTextTree(newString(pos, bp));
 651 
 652                 case &#39;@&#39;:
 653                     if (newline)
 654                         break loop;
 655 
 656                 case &#39;{&#39;:
 657                     depth++;
 658                     break;
 659 
 660                 case &#39;}&#39;:
 661                     if (depth == 0 || --depth == 0)
 662                         return m.at(pos).newTextTree(newString(pos, bp));
 663                     break;
 664             }
 665             newline = false;
 666             nextChar();
 667         }
 668         return null;
 669     }
 670 
 671     /**
 672      * Read general text content of an inline tag, including HTML entities and elements.
 673      * Matching pairs of { } are skipped; the text is terminated by the first
 674      * unmatched }. It is an error if the beginning of the next tag is detected.
 675      */
 676     @SuppressWarnings(&quot;fallthrough&quot;)
 677     private List&lt;DCTree&gt; inlineContent() {
 678         ListBuffer&lt;DCTree&gt; trees = new ListBuffer&lt;&gt;();
 679 
 680         skipWhitespace();
 681         int pos = bp;
 682         int depth = 1;
 683         textStart = -1;
 684 
 685         loop:
 686         while (bp &lt; buflen) {
 687 
 688             switch (ch) {
 689                 case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\f&#39;:
 690                     newline = true;
 691                     // fall through
 692 
 693                 case &#39; &#39;: case &#39;\t&#39;:
 694                     nextChar();
 695                     break;
 696 
 697                 case &#39;&amp;&#39;:
 698                     entity(trees);
 699                     break;
 700 
 701                 case &#39;&lt;&#39;:
 702                     newline = false;
 703                     addPendingText(trees, bp - 1);
 704                     trees.add(html());
 705                     break;
 706 
 707                 case &#39;{&#39;:
 708                     if (textStart == -1)
 709                         textStart = bp;
 710                     newline = false;
 711                     depth++;
 712                     nextChar();
 713                     break;
 714 
 715                 case &#39;}&#39;:
 716                     newline = false;
 717                     if (--depth == 0) {
 718                         addPendingText(trees, bp - 1);
 719                         nextChar();
 720                         return trees.toList();
 721                     }
 722                     nextChar();
 723                     break;
 724 
 725                 case &#39;@&#39;:
 726                     if (newline)
 727                         break loop;
 728                     // fallthrough
 729 
 730                 default:
 731                     if (textStart == -1)
 732                         textStart = bp;
 733                     nextChar();
 734                     break;
 735             }
 736         }
 737 
 738         return List.of(erroneous(&quot;dc.unterminated.inline.tag&quot;, pos));
 739     }
 740 
 741     protected void entity(ListBuffer&lt;DCTree&gt; list) {
 742         newline = false;
 743         addPendingText(list, bp - 1);
 744         list.add(entity());
 745         if (textStart == -1) {
 746             textStart = bp;
 747             lastNonWhite = -1;
 748         }
 749     }
 750 
 751     /**
 752      * Read an HTML entity.
 753      * {@literal &amp;identifier; } or {@literal &amp;#digits; } or {@literal &amp;#xhex-digits; }
 754      */
 755     protected DCTree entity() {
 756         int p = bp;
 757         nextChar();
 758         Name name = null;
 759         if (ch == &#39;#&#39;) {
 760             int namep = bp;
 761             nextChar();
 762             if (isDecimalDigit(ch)) {
 763                 nextChar();
 764                 while (isDecimalDigit(ch))
 765                     nextChar();
 766                 name = names.fromChars(buf, namep, bp - namep);
 767             } else if (ch == &#39;x&#39; || ch == &#39;X&#39;) {
 768                 nextChar();
 769                 if (isHexDigit(ch)) {
 770                     nextChar();
 771                     while (isHexDigit(ch))
 772                         nextChar();
 773                     name = names.fromChars(buf, namep, bp - namep);
 774                 }
 775             }
 776         } else if (isIdentifierStart(ch)) {
 777             name = readIdentifier();
 778         }
 779 
 780         if (name == null)
 781             return erroneous(&quot;dc.bad.entity&quot;, p);
 782         else {
 783             if (ch != &#39;;&#39;)
 784                 return erroneous(&quot;dc.missing.semicolon&quot;, p);
 785             nextChar();
 786             return m.at(p).newEntityTree(name);
 787         }
 788     }
 789 
<a name="4" id="anc4"></a>























































































 790     boolean peek(String s) {
 791         final int savedpos = bp;
 792         try {
 793             if (ch == &#39;&lt;&#39;)
 794                 nextChar();
 795 
 796             if (ch == &#39;/&#39;) {
 797                 if (s.charAt(0) != ch) {
 798                     return false;
 799                 } else {
 800                     s = s.substring(1, s.length());
 801                     nextChar();
 802                 }
 803             }
 804 
 805             if (isIdentifierStart(ch)) {
 806                 Name name = readIdentifier();
 807                 return StringUtils.toLowerCase(name.toString()).equals(s);
 808             }
 809             return false;
 810         } finally {
 811             bp = savedpos;
 812             ch = buf[bp];
 813         }
 814     }
 815 
 816     /**
 817      * Read the start or end of an HTML tag, or an HTML comment
 818      * {@literal &lt;identifier attrs&gt; } or {@literal &lt;/identifier&gt; }
 819      */
 820     private DCTree html() {
 821         int p = bp;
 822         nextChar();
 823         if (isIdentifierStart(ch)) {
 824             Name name = readIdentifier();
 825             List&lt;DCTree&gt; attrs = htmlAttrs();
 826             if (attrs != null) {
 827                 boolean selfClosing = false;
 828                 if (ch == &#39;/&#39;) {
 829                     nextChar();
 830                     selfClosing = true;
 831                 }
 832                 if (ch == &#39;&gt;&#39;) {
 833                     nextChar();
 834                     DCTree dctree = m.at(p).newStartElementTree(name, attrs, selfClosing).setEndPos(bp);
 835                     return dctree;
 836                 }
 837             }
 838         } else if (ch == &#39;/&#39;) {
 839             nextChar();
 840             if (isIdentifierStart(ch)) {
 841                 Name name = readIdentifier();
 842                 skipWhitespace();
 843                 if (ch == &#39;&gt;&#39;) {
 844                     nextChar();
<a name="5" id="anc5"></a><span class="line-modified"> 845                     return m.at(p).newEndElementTree(name);</span>
 846                 }
 847             }
 848         } else if (ch == &#39;!&#39;) {
 849             nextChar();
 850             if (ch == &#39;-&#39;) {
 851                 nextChar();
 852                 if (ch == &#39;-&#39;) {
 853                     nextChar();
 854                     while (bp &lt; buflen) {
 855                         int dash = 0;
 856                         while (ch == &#39;-&#39;) {
 857                             dash++;
 858                             nextChar();
 859                         }
 860                         // Strictly speaking, a comment should not contain &quot;--&quot;
 861                         // so dash &gt; 2 is an error, dash == 2 implies ch == &#39;&gt;&#39;
 862                         // See http://www.w3.org/TR/html-markup/syntax.html#syntax-comments
 863                         // for more details.
 864                         if (dash &gt;= 2 &amp;&amp; ch == &#39;&gt;&#39;) {
 865                             nextChar();
 866                             return m.at(p).newCommentTree(newString(p, bp));
 867                         }
 868 
 869                         nextChar();
 870                     }
 871                 }
 872             } else if (isIdentifierStart(ch) &amp;&amp; peek(&quot;doctype&quot;)) {
 873                 readIdentifier();
 874                 nextChar();
 875                 skipWhitespace();
 876                 int d = bp;
 877                 while (bp &lt; buflen) {
 878                     if (ch == &#39;&gt;&#39;) {
 879                         int mark = bp;
 880                         nextChar();
 881                         return m.at(d).newDocTypeTree(newString(d, mark));
 882                     }
 883                     nextChar();
 884                 }
 885             }
 886         }
 887 
 888         bp = p + 1;
 889         ch = buf[bp];
 890         return erroneous(&quot;dc.malformed.html&quot;, p);
 891     }
 892 
 893     /**
 894      * Read a series of HTML attributes, terminated by {@literal &gt; }.
 895      * Each attribute is of the form {@literal identifier[=value] }.
 896      * &quot;value&quot; may be unquoted, single-quoted, or double-quoted.
 897      */
 898     protected List&lt;DCTree&gt; htmlAttrs() {
 899         ListBuffer&lt;DCTree&gt; attrs = new ListBuffer&lt;&gt;();
 900         skipWhitespace();
 901 
 902         loop:
 903         while (isIdentifierStart(ch)) {
 904             int namePos = bp;
 905             Name name = readAttributeName();
 906             skipWhitespace();
 907             List&lt;DCTree&gt; value = null;
 908             ValueKind vkind = ValueKind.EMPTY;
 909             if (ch == &#39;=&#39;) {
 910                 ListBuffer&lt;DCTree&gt; v = new ListBuffer&lt;&gt;();
 911                 nextChar();
 912                 skipWhitespace();
 913                 if (ch == &#39;\&#39;&#39; || ch == &#39;&quot;&#39;) {
 914                     vkind = (ch == &#39;\&#39;&#39;) ? ValueKind.SINGLE : ValueKind.DOUBLE;
 915                     char quote = ch;
 916                     nextChar();
 917                     textStart = bp;
 918                     while (bp &lt; buflen &amp;&amp; ch != quote) {
 919                         if (newline &amp;&amp; ch == &#39;@&#39;) {
 920                             attrs.add(erroneous(&quot;dc.unterminated.string&quot;, namePos));
 921                             // No point trying to read more.
 922                             // In fact, all attrs get discarded by the caller
 923                             // and superseded by a malformed.html node because
 924                             // the html tag itself is not terminated correctly.
 925                             break loop;
 926                         }
 927                         attrValueChar(v);
 928                     }
 929                     addPendingText(v, bp - 1);
 930                     nextChar();
 931                 } else {
 932                     vkind = ValueKind.UNQUOTED;
 933                     textStart = bp;
 934                     while (bp &lt; buflen &amp;&amp; !isUnquotedAttrValueTerminator(ch)) {
 935                         attrValueChar(v);
 936                     }
 937                     addPendingText(v, bp - 1);
 938                 }
 939                 skipWhitespace();
 940                 value = v.toList();
 941             }
 942             DCAttribute attr = m.at(namePos).newAttributeTree(name, vkind, value);
 943             attrs.add(attr);
 944         }
 945 
 946         return attrs.toList();
 947     }
 948 
 949     protected void attrValueChar(ListBuffer&lt;DCTree&gt; list) {
 950         switch (ch) {
 951             case &#39;&amp;&#39;:
 952                 entity(list);
 953                 break;
 954 
 955             case &#39;{&#39;:
 956                 inlineTag(list);
 957                 break;
 958 
 959             default:
 960                 nextChar();
 961         }
 962     }
 963 
 964     protected void addPendingText(ListBuffer&lt;DCTree&gt; list, int textEnd) {
 965         if (textStart != -1) {
 966             if (textStart &lt;= textEnd) {
 967                 list.add(m.at(textStart).newTextTree(newString(textStart, textEnd + 1)));
 968             }
 969             textStart = -1;
 970         }
 971     }
 972 
 973     protected DCErroneous erroneous(String code, int pos) {
 974         int i = bp - 1;
 975         loop:
 976         while (i &gt; pos) {
 977             switch (buf[i]) {
 978                 case &#39;\f&#39;: case &#39;\n&#39;: case &#39;\r&#39;:
 979                     newline = true;
 980                     break;
 981                 case &#39;\t&#39;: case &#39; &#39;:
 982                     break;
 983                 default:
 984                     break loop;
 985             }
 986             i--;
 987         }
 988         textStart = -1;
 989         return m.at(pos).newErroneousTree(newString(pos, i + 1), diagSource, code);
 990     }
 991 
 992     protected boolean isIdentifierStart(char ch) {
 993         return Character.isUnicodeIdentifierStart(ch);
 994     }
 995 
 996     protected Name readIdentifier() {
 997         int start = bp;
 998         nextChar();
 999         while (bp &lt; buflen &amp;&amp; Character.isUnicodeIdentifierPart(ch))
1000             nextChar();
1001         return names.fromChars(buf, start, bp - start);
1002     }
1003 
1004     protected Name readAttributeName() {
1005         int start = bp;
1006         nextChar();
1007         while (bp &lt; buflen &amp;&amp; (Character.isUnicodeIdentifierPart(ch) || ch == &#39;-&#39;))
1008             nextChar();
1009         return names.fromChars(buf, start, bp - start);
1010     }
1011 
1012     protected Name readTagName() {
1013         int start = bp;
1014         nextChar();
1015         while (bp &lt; buflen
1016                 &amp;&amp; (Character.isUnicodeIdentifierPart(ch) || ch == &#39;.&#39;
1017                 || ch == &#39;-&#39; || ch == &#39;:&#39;)) {
1018             nextChar();
1019         }
1020         return names.fromChars(buf, start, bp - start);
1021     }
1022 
1023     protected boolean isJavaIdentifierStart(char ch) {
1024         return Character.isJavaIdentifierStart(ch);
1025     }
1026 
1027     protected Name readJavaIdentifier() {
1028         int start = bp;
1029         nextChar();
1030         while (bp &lt; buflen &amp;&amp; Character.isJavaIdentifierPart(ch))
1031             nextChar();
1032         return names.fromChars(buf, start, bp - start);
1033     }
1034 
1035     protected Name readSystemPropertyName() {
1036         int pos = bp;
1037         nextChar();
1038         while (bp &lt; buflen &amp;&amp; Character.isUnicodeIdentifierPart(ch) || ch == &#39;.&#39;)
1039             nextChar();
1040         return names.fromChars(buf, pos, bp - pos);
1041     }
1042 
1043     protected boolean isDecimalDigit(char ch) {
1044         return (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;);
1045     }
1046 
1047     protected boolean isHexDigit(char ch) {
1048         return (&#39;0&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;9&#39;)
1049                 || (&#39;a&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;f&#39;)
1050                 || (&#39;A&#39; &lt;= ch &amp;&amp; ch &lt;= &#39;F&#39;);
1051     }
1052 
1053     protected boolean isUnquotedAttrValueTerminator(char ch) {
1054         switch (ch) {
1055             case &#39;\f&#39;: case &#39;\n&#39;: case &#39;\r&#39;: case &#39;\t&#39;:
1056             case &#39; &#39;:
1057             case &#39;&quot;&#39;: case &#39;\&#39;&#39;: case &#39;`&#39;:
1058             case &#39;=&#39;: case &#39;&lt;&#39;: case &#39;&gt;&#39;:
1059                 return true;
1060             default:
1061                 return false;
1062         }
1063     }
1064 
1065     protected boolean isWhitespace(char ch) {
1066         return Character.isWhitespace(ch);
1067     }
1068 
1069     protected void skipWhitespace() {
1070         while (isWhitespace(ch)) {
1071             nextChar();
1072         }
1073     }
1074 
1075     /**
1076      * @param start position of first character of string
1077      * @param end position of character beyond last character to be included
1078      */
1079     String newString(int start, int end) {
1080         return new String(buf, start, end - start);
1081     }
1082 
1083     static abstract class TagParser {
1084         enum Kind { INLINE, BLOCK }
1085 
1086         final Kind kind;
1087         final DCTree.Kind treeKind;
1088         final boolean retainWhiteSpace;
1089 
1090 
1091         TagParser(Kind k, DCTree.Kind tk) {
1092             kind = k;
1093             treeKind = tk;
1094             retainWhiteSpace = false;
1095         }
1096 
1097         TagParser(Kind k, DCTree.Kind tk, boolean retainWhiteSpace) {
1098             kind = k;
1099             treeKind = tk;
1100             this.retainWhiteSpace = retainWhiteSpace;
1101         }
1102 
1103         Kind getKind() {
1104             return kind;
1105         }
1106 
1107         DCTree.Kind getTreeKind() {
1108             return treeKind;
1109         }
1110 
1111         abstract DCTree parse(int pos) throws ParseException;
1112     }
1113 
1114     /**
1115      * @see &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/technotes/tools/unix/javadoc.html#CHDJGIJB&quot;&gt;Javadoc Tags&lt;/a&gt;
1116      */
1117     private void initTagParsers() {
1118         TagParser[] parsers = {
1119             // @author name-text
1120             new TagParser(Kind.BLOCK, DCTree.Kind.AUTHOR) {
1121                 public DCTree parse(int pos) {
1122                     List&lt;DCTree&gt; name = blockContent();
1123                     return m.at(pos).newAuthorTree(name);
1124                 }
1125             },
1126 
1127             // {@code text}
1128             new TagParser(Kind.INLINE, DCTree.Kind.CODE, true) {
1129                 public DCTree parse(int pos) throws ParseException {
1130                     DCTree text = inlineText(WhitespaceRetentionPolicy.REMOVE_FIRST_SPACE);
1131                     nextChar();
1132                     return m.at(pos).newCodeTree((DCText) text);
1133                 }
1134             },
1135 
1136             // @deprecated deprecated-text
1137             new TagParser(Kind.BLOCK, DCTree.Kind.DEPRECATED) {
1138                 public DCTree parse(int pos) {
1139                     List&lt;DCTree&gt; reason = blockContent();
1140                     return m.at(pos).newDeprecatedTree(reason);
1141                 }
1142             },
1143 
1144             // {@docRoot}
1145             new TagParser(Kind.INLINE, DCTree.Kind.DOC_ROOT) {
1146                 public DCTree parse(int pos) throws ParseException {
1147                     if (ch == &#39;}&#39;) {
1148                         nextChar();
1149                         return m.at(pos).newDocRootTree();
1150                     }
1151                     inlineText(WhitespaceRetentionPolicy.REMOVE_ALL); // skip unexpected content
1152                     nextChar();
1153                     throw new ParseException(&quot;dc.unexpected.content&quot;);
1154                 }
1155             },
1156 
1157             // @exception class-name description
1158             new TagParser(Kind.BLOCK, DCTree.Kind.EXCEPTION) {
1159                 public DCTree parse(int pos) throws ParseException {
1160                     skipWhitespace();
1161                     DCReference ref = reference(false);
1162                     List&lt;DCTree&gt; description = blockContent();
1163                     return m.at(pos).newExceptionTree(ref, description);
1164                 }
1165             },
1166 
1167             // @hidden hidden-text
1168             new TagParser(Kind.BLOCK, DCTree.Kind.HIDDEN) {
1169                 public DCTree parse(int pos) {
1170                     List&lt;DCTree&gt; reason = blockContent();
1171                     return m.at(pos).newHiddenTree(reason);
1172                 }
1173             },
1174 
1175             // @index search-term options-description
1176             new TagParser(Kind.INLINE, DCTree.Kind.INDEX) {
1177                 public DCTree parse(int pos) throws ParseException {
1178                     skipWhitespace();
1179                     if (ch == &#39;}&#39;) {
1180                         throw new ParseException(&quot;dc.no.content&quot;);
1181                     }
1182                     DCTree term = ch == &#39;&quot;&#39; ? quotedString() : inlineWord();
1183                     if (term == null) {
1184                         throw new ParseException(&quot;dc.no.content&quot;);
1185                     }
1186                     skipWhitespace();
1187                     List&lt;DCTree&gt; description = List.nil();
1188                     if (ch != &#39;}&#39;) {
1189                         description = inlineContent();
1190                     } else {
1191                         nextChar();
1192                     }
1193                     return m.at(pos).newIndexTree(term, description);
1194                 }
1195             },
1196 
1197             // {@inheritDoc}
1198             new TagParser(Kind.INLINE, DCTree.Kind.INHERIT_DOC) {
1199                 public DCTree parse(int pos) throws ParseException {
1200                     if (ch == &#39;}&#39;) {
1201                         nextChar();
1202                         return m.at(pos).newInheritDocTree();
1203                     }
1204                     inlineText(WhitespaceRetentionPolicy.REMOVE_ALL); // skip unexpected content
1205                     nextChar();
1206                     throw new ParseException(&quot;dc.unexpected.content&quot;);
1207                 }
1208             },
1209 
1210             // {@link package.class#member label}
1211             new TagParser(Kind.INLINE, DCTree.Kind.LINK) {
1212                 public DCTree parse(int pos) throws ParseException {
1213                     DCReference ref = reference(true);
1214                     List&lt;DCTree&gt; label = inlineContent();
1215                     return m.at(pos).newLinkTree(ref, label);
1216                 }
1217             },
1218 
1219             // {@linkplain package.class#member label}
1220             new TagParser(Kind.INLINE, DCTree.Kind.LINK_PLAIN) {
1221                 public DCTree parse(int pos) throws ParseException {
1222                     DCReference ref = reference(true);
1223                     List&lt;DCTree&gt; label = inlineContent();
1224                     return m.at(pos).newLinkPlainTree(ref, label);
1225                 }
1226             },
1227 
1228             // {@literal text}
1229             new TagParser(Kind.INLINE, DCTree.Kind.LITERAL, true) {
1230                 public DCTree parse(int pos) throws ParseException {
1231                     DCTree text = inlineText(WhitespaceRetentionPolicy.REMOVE_FIRST_SPACE);
1232                     nextChar();
1233                     return m.at(pos).newLiteralTree((DCText) text);
1234                 }
1235             },
1236 
1237             // @param parameter-name description
1238             new TagParser(Kind.BLOCK, DCTree.Kind.PARAM) {
1239                 public DCTree parse(int pos) throws ParseException {
1240                     skipWhitespace();
1241 
1242                     boolean typaram = false;
1243                     if (ch == &#39;&lt;&#39;) {
1244                         typaram = true;
1245                         nextChar();
1246                     }
1247 
1248                     DCIdentifier id = identifier();
1249 
1250                     if (typaram) {
1251                         if (ch != &#39;&gt;&#39;)
1252                             throw new ParseException(&quot;dc.gt.expected&quot;);
1253                         nextChar();
1254                     }
1255 
1256                     skipWhitespace();
1257                     List&lt;DCTree&gt; desc = blockContent();
1258                     return m.at(pos).newParamTree(typaram, id, desc);
1259                 }
1260             },
1261 
1262             // @provides service-name description
1263             new TagParser(Kind.BLOCK, DCTree.Kind.PROVIDES) {
1264                 public DCTree parse(int pos) throws ParseException {
1265                     skipWhitespace();
1266                     DCReference ref = reference(true);
1267                     List&lt;DCTree&gt; description = blockContent();
1268                     return m.at(pos).newProvidesTree(ref, description);
1269                 }
1270             },
1271 
1272             // @return description
1273             new TagParser(Kind.BLOCK, DCTree.Kind.RETURN) {
1274                 public DCTree parse(int pos) {
1275                     List&lt;DCTree&gt; description = blockContent();
1276                     return m.at(pos).newReturnTree(description);
1277                 }
1278             },
1279 
1280             // @see reference | quoted-string | HTML
1281             new TagParser(Kind.BLOCK, DCTree.Kind.SEE) {
1282                 public DCTree parse(int pos) throws ParseException {
1283                     skipWhitespace();
1284                     switch (ch) {
1285                         case &#39;&quot;&#39;:
1286                             DCText string = quotedString();
1287                             if (string != null) {
1288                                 skipWhitespace();
1289                                 if (ch == &#39;@&#39;
1290                                         || ch == EOI &amp;&amp; bp == buf.length - 1) {
1291                                     return m.at(pos).newSeeTree(List.&lt;DCTree&gt;of(string));
1292                                 }
1293                             }
1294                             break;
1295 
1296                         case &#39;&lt;&#39;:
1297                             List&lt;DCTree&gt; html = blockContent();
1298                             if (html != null)
1299                                 return m.at(pos).newSeeTree(html);
1300                             break;
1301 
1302                         case &#39;@&#39;:
1303                             if (newline)
1304                                 throw new ParseException(&quot;dc.no.content&quot;);
1305                             break;
1306 
1307                         case EOI:
1308                             if (bp == buf.length - 1)
1309                                 throw new ParseException(&quot;dc.no.content&quot;);
1310                             break;
1311 
1312                         default:
1313                             if (isJavaIdentifierStart(ch) || ch == &#39;#&#39;) {
1314                                 DCReference ref = reference(true);
1315                                 List&lt;DCTree&gt; description = blockContent();
1316                                 return m.at(pos).newSeeTree(description.prepend(ref));
1317                             }
1318                     }
1319                     throw new ParseException(&quot;dc.unexpected.content&quot;);
1320                 }
1321             },
1322 
1323             // @serialData data-description
1324             new TagParser(Kind.BLOCK, DCTree.Kind.SERIAL_DATA) {
1325                 public DCTree parse(int pos) {
1326                     List&lt;DCTree&gt; description = blockContent();
1327                     return m.at(pos).newSerialDataTree(description);
1328                 }
1329             },
1330 
1331             // @serialField field-name field-type description
1332             new TagParser(Kind.BLOCK, DCTree.Kind.SERIAL_FIELD) {
1333                 public DCTree parse(int pos) throws ParseException {
1334                     skipWhitespace();
1335                     DCIdentifier name = identifier();
1336                     skipWhitespace();
1337                     DCReference type = reference(false);
1338                     List&lt;DCTree&gt; description = null;
1339                     if (isWhitespace(ch)) {
1340                         skipWhitespace();
1341                         description = blockContent();
1342                     }
1343                     return m.at(pos).newSerialFieldTree(name, type, description);
1344                 }
1345             },
1346 
1347             // @serial field-description | include | exclude
1348             new TagParser(Kind.BLOCK, DCTree.Kind.SERIAL) {
1349                 public DCTree parse(int pos) {
1350                     List&lt;DCTree&gt; description = blockContent();
1351                     return m.at(pos).newSerialTree(description);
1352                 }
1353             },
1354 
1355             // @since since-text
1356             new TagParser(Kind.BLOCK, DCTree.Kind.SINCE) {
1357                 public DCTree parse(int pos) {
1358                     List&lt;DCTree&gt; description = blockContent();
1359                     return m.at(pos).newSinceTree(description);
1360                 }
1361             },
1362 
1363             // @summary summary-text
1364             new TagParser(Kind.INLINE, DCTree.Kind.SUMMARY) {
1365                 public DCTree parse(int pos) throws ParseException {
1366                     List&lt;DCTree&gt; summary = inlineContent();
1367                     return m.at(pos).newSummaryTree(summary);
1368                 }
1369             },
1370 
1371             // @systemProperty property-name
1372             new TagParser(Kind.INLINE, DCTree.Kind.SYSTEM_PROPERTY) {
1373                 public DCTree parse(int pos) throws ParseException {
1374                     skipWhitespace();
1375                     if (ch == &#39;}&#39;) {
1376                         throw new ParseException(&quot;dc.no.content&quot;);
1377                     }
1378                     Name propertyName = readSystemPropertyName();
1379                     if (propertyName == null) {
1380                         throw new ParseException(&quot;dc.no.content&quot;);
1381                     }
1382                     skipWhitespace();
1383                     if (ch != &#39;}&#39;) {
1384                         nextChar();
1385                         throw new ParseException(&quot;dc.unexpected.content&quot;);
1386                     } else {
1387                         nextChar();
1388                         return m.at(pos).newSystemPropertyTree(propertyName);
1389                     }
1390                 }
1391             },
1392 
1393             // @throws class-name description
1394             new TagParser(Kind.BLOCK, DCTree.Kind.THROWS) {
1395                 public DCTree parse(int pos) throws ParseException {
1396                     skipWhitespace();
1397                     DCReference ref = reference(false);
1398                     List&lt;DCTree&gt; description = blockContent();
1399                     return m.at(pos).newThrowsTree(ref, description);
1400                 }
1401             },
1402 
1403             // @uses service-name description
1404             new TagParser(Kind.BLOCK, DCTree.Kind.USES) {
1405                 public DCTree parse(int pos) throws ParseException {
1406                     skipWhitespace();
1407                     DCReference ref = reference(true);
1408                     List&lt;DCTree&gt; description = blockContent();
1409                     return m.at(pos).newUsesTree(ref, description);
1410                 }
1411             },
1412 
1413             // {@value package.class#field}
1414             new TagParser(Kind.INLINE, DCTree.Kind.VALUE) {
1415                 public DCTree parse(int pos) throws ParseException {
1416                     DCReference ref = reference(true);
1417                     skipWhitespace();
1418                     if (ch == &#39;}&#39;) {
1419                         nextChar();
1420                         return m.at(pos).newValueTree(ref);
1421                     }
1422                     nextChar();
1423                     throw new ParseException(&quot;dc.unexpected.content&quot;);
1424                 }
1425             },
1426 
1427             // @version version-text
1428             new TagParser(Kind.BLOCK, DCTree.Kind.VERSION) {
1429                 public DCTree parse(int pos) {
1430                     List&lt;DCTree&gt; description = blockContent();
1431                     return m.at(pos).newVersionTree(description);
1432                 }
1433             },
1434         };
1435 
1436         tagParsers = new HashMap&lt;&gt;();
1437         for (TagParser p: parsers)
1438             tagParsers.put(names.fromString(p.getTreeKind().tagName), p);
1439 
1440     }
1441 
1442 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
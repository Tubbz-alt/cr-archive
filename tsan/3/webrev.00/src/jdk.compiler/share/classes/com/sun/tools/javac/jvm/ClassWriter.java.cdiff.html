<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Code.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 27,13 ***</span>
  
  import java.io.*;
  import java.util.LinkedHashMap;
  import java.util.Map;
  import java.util.Set;
<span class="line-removed">- import java.util.HashSet;</span>
  import java.util.LinkedHashSet;
<span class="line-modified">! import java.util.stream.Collectors;</span>
  
  import javax.tools.JavaFileManager;
  import javax.tools.FileObject;
  import javax.tools.JavaFileManager.Location;
  import javax.tools.JavaFileObject;
<span class="line-new-header">--- 27,12 ---</span>
  
  import java.io.*;
  import java.util.LinkedHashMap;
  import java.util.Map;
  import java.util.Set;
  import java.util.LinkedHashSet;
<span class="line-modified">! import java.util.function.ToIntFunction;</span>
  
  import javax.tools.JavaFileManager;
  import javax.tools.FileObject;
  import javax.tools.JavaFileManager.Location;
  import javax.tools.JavaFileObject;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,20 ***</span>
  import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  import com.sun.tools.javac.code.Directive.*;
  import com.sun.tools.javac.code.Symbol.*;
  import com.sun.tools.javac.code.Type.*;
  import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
<span class="line-removed">- import com.sun.tools.javac.code.Types.UniqueType;</span>
  import com.sun.tools.javac.comp.Check;
  import com.sun.tools.javac.file.PathFileObject;
<span class="line-modified">! import com.sun.tools.javac.jvm.Pool.DynamicMethod;</span>
<span class="line-modified">! import com.sun.tools.javac.jvm.Pool.Method;</span>
<span class="line-removed">- import com.sun.tools.javac.jvm.Pool.MethodHandle;</span>
<span class="line-removed">- import com.sun.tools.javac.jvm.Pool.Variable;</span>
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  import com.sun.tools.javac.util.*;
  
  import static com.sun.tools.javac.code.Flags.*;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
  import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  import static com.sun.tools.javac.code.TypeTag.*;
<span class="line-new-header">--- 41,18 ---</span>
  import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  import com.sun.tools.javac.code.Directive.*;
  import com.sun.tools.javac.code.Symbol.*;
  import com.sun.tools.javac.code.Type.*;
  import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
  import com.sun.tools.javac.comp.Check;
  import com.sun.tools.javac.file.PathFileObject;
<span class="line-modified">! import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
<span class="line-modified">! import com.sun.tools.javac.jvm.PoolConstant.Dynamic.BsmKey;</span>
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  import com.sun.tools.javac.util.*;
<span class="line-added">+ import com.sun.tools.javac.util.List;</span>
  
  import static com.sun.tools.javac.code.Flags.*;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
  import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  import static com.sun.tools.javac.code.TypeTag.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,41 ***</span>
       * If true, class files will be written in module-specific subdirectories
       * of the CLASS_OUTPUT location.
       */
      public boolean multiModuleMode;
  
      /** The initial sizes of the data and constant pool buffers.
       *  Sizes are increased when buffers get full.
       */
      static final int DATA_BUF_SIZE = 0x0fff0;
<span class="line-modified">!     static final int POOL_BUF_SIZE = 0x1fff0;</span>
  
      /** An output buffer for member info.
       */
<span class="line-modified">!     ByteBuffer databuf = new ByteBuffer(DATA_BUF_SIZE);</span>
  
      /** An output buffer for the constant pool.
       */
<span class="line-modified">!     ByteBuffer poolbuf = new ByteBuffer(POOL_BUF_SIZE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** The constant pool.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Pool pool;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** The inner classes to be written, as a set.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Set&lt;ClassSymbol&gt; innerClasses;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** The inner classes to be written, as a queue where</span>
<span class="line-removed">-      *  enclosing classes come first.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     ListBuffer&lt;ClassSymbol&gt; innerClassesQueue;</span>
  
<span class="line-modified">!     /** The bootstrap methods to be written in the corresponding class attribute</span>
<span class="line-removed">-      *  (one for each invokedynamic)</span>
       */
<span class="line-modified">!     Map&lt;DynamicMethod.BootstrapMethodsKey, DynamicMethod.BootstrapMethodsValue&gt; bootstrapMethods;</span>
  
      /** The log to use for verbose output.
       */
      private final Log log;
  
<span class="line-new-header">--- 112,29 ---</span>
       * If true, class files will be written in module-specific subdirectories
       * of the CLASS_OUTPUT location.
       */
      public boolean multiModuleMode;
  
<span class="line-added">+     private List&lt;ToIntFunction&lt;Symbol&gt;&gt; extraAttributeHooks = List.nil();</span>
<span class="line-added">+ </span>
      /** The initial sizes of the data and constant pool buffers.
       *  Sizes are increased when buffers get full.
       */
      static final int DATA_BUF_SIZE = 0x0fff0;
<span class="line-modified">!     static final int CLASS_BUF_SIZE = 0x1fff0;</span>
  
      /** An output buffer for member info.
       */
<span class="line-modified">!     public ByteBuffer databuf = new ByteBuffer(DATA_BUF_SIZE);</span>
  
      /** An output buffer for the constant pool.
       */
<span class="line-modified">!     ByteBuffer poolbuf = new ByteBuffer(CLASS_BUF_SIZE);</span>
  
<span class="line-modified">!     /** The constant pool writer.</span>
       */
<span class="line-modified">!     final PoolWriter poolWriter;</span>
  
      /** The log to use for verbose output.
       */
      private final Log log;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 157,13 ***</span>
      private final Names names;
  
      /** Access to files. */
      private final JavaFileManager fileManager;
  
<span class="line-removed">-     /** Sole signature generator */</span>
<span class="line-removed">-     private final CWSignatureGenerator signatureGen;</span>
<span class="line-removed">- </span>
      /** The tags and constants used in compressed stackmap. */
      static final int SAME_FRAME_SIZE = 64;
      static final int SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247;
      static final int SAME_FRAME_EXTENDED = 251;
      static final int FULL_FRAME = 255;
<span class="line-new-header">--- 142,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,11 ***</span>
          target = Target.instance(context);
          source = Source.instance(context);
          types = Types.instance(context);
          check = Check.instance(context);
          fileManager = context.get(JavaFileManager.class);
<span class="line-modified">!         signatureGen = new CWSignatureGenerator(types);</span>
  
          verbose        = options.isSet(VERBOSE);
          genCrt         = options.isSet(XJCOV);
          debugstackmap = options.isSet(&quot;debug.stackmap&quot;);
  
<span class="line-new-header">--- 171,11 ---</span>
          target = Target.instance(context);
          source = Source.instance(context);
          types = Types.instance(context);
          check = Check.instance(context);
          fileManager = context.get(JavaFileManager.class);
<span class="line-modified">!         poolWriter = Gen.instance(context).poolWriter;</span>
  
          verbose        = options.isSet(VERBOSE);
          genCrt         = options.isSet(XJCOV);
          debugstackmap = options.isSet(&quot;debug.stackmap&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 207,10 ***</span>
<span class="line-new-header">--- 189,14 ---</span>
              dumpInnerClassModifiers = modifierFlags.indexOf(&#39;i&#39;) != -1;
              dumpMethodModifiers = modifierFlags.indexOf(&#39;m&#39;) != -1;
          }
      }
  
<span class="line-added">+     public void addExtraAttributes(ToIntFunction&lt;Symbol&gt; addExtraAttributes) {</span>
<span class="line-added">+         extraAttributeHooks = extraAttributeHooks.prepend(addExtraAttributes);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
  /******************************************************************
   * Diagnostics: dump generated class names and modifiers
   ******************************************************************/
  
      /** Value of option &#39;dumpmodifiers&#39; is a string
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,266 ***</span>
          buf.elems[adr+1] = (byte)((x &gt;&gt; 16) &amp; 0xFF);
          buf.elems[adr+2] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
          buf.elems[adr+3] = (byte)((x      ) &amp; 0xFF);
      }
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Signature Generation</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private class CWSignatureGenerator extends Types.SignatureGenerator {</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * An output buffer for type signatures.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         ByteBuffer sigbuf = new ByteBuffer();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         CWSignatureGenerator(Types types) {</span>
<span class="line-removed">-             super(types);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         /**</span>
<span class="line-removed">-          * Assemble signature of given type in string buffer.</span>
<span class="line-removed">-          * Check for uninitialized types before calling the general case.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         public void assembleSig(Type type) {</span>
<span class="line-removed">-             switch (type.getTag()) {</span>
<span class="line-removed">-                 case UNINITIALIZED_THIS:</span>
<span class="line-removed">-                 case UNINITIALIZED_OBJECT:</span>
<span class="line-removed">-                     // we don&#39;t yet have a spec for uninitialized types in the</span>
<span class="line-removed">-                     // local variable table</span>
<span class="line-removed">-                     assembleSig(types.erasure(((UninitializedType)type).qtype));</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     super.assembleSig(type);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         protected void append(char ch) {</span>
<span class="line-removed">-             sigbuf.appendByte(ch);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         protected void append(byte[] ba) {</span>
<span class="line-removed">-             sigbuf.appendBytes(ba);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         protected void append(Name name) {</span>
<span class="line-removed">-             sigbuf.appendName(name);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         @Override</span>
<span class="line-removed">-         protected void classReference(ClassSymbol c) {</span>
<span class="line-removed">-             enterInner(c);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private void reset() {</span>
<span class="line-removed">-             sigbuf.reset();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private Name toName() {</span>
<span class="line-removed">-             return sigbuf.toName(names);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         private boolean isEmpty() {</span>
<span class="line-removed">-             return sigbuf.length == 0;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Return signature of given type</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Name typeSig(Type type) {</span>
<span class="line-removed">-         Assert.check(signatureGen.isEmpty());</span>
<span class="line-removed">-         //- System.out.println(&quot; ? &quot; + type);</span>
<span class="line-removed">-         signatureGen.assembleSig(type);</span>
<span class="line-removed">-         Name n = signatureGen.toName();</span>
<span class="line-removed">-         signatureGen.reset();</span>
<span class="line-removed">-         //- System.out.println(&quot;   &quot; + n);</span>
<span class="line-removed">-         return n;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Given a type t, return the extended class name of its erasure in</span>
<span class="line-removed">-      *  external representation.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public Name xClassName(Type t) {</span>
<span class="line-removed">-         if (t.hasTag(CLASS)) {</span>
<span class="line-removed">-             return names.fromUtf(externalize(t.tsym.flatName()));</span>
<span class="line-removed">-         } else if (t.hasTag(ARRAY)) {</span>
<span class="line-removed">-             return typeSig(types.erasure(t));</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             throw new AssertionError(&quot;xClassName expects class or array type, got &quot; + t);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
  /******************************************************************
   * Writing the Constant Pool
   ******************************************************************/
  
      /** Thrown when the constant pool is over full.
       */
<span class="line-modified">!     public static class PoolOverflow extends Exception {</span>
          private static final long serialVersionUID = 0;
          public PoolOverflow() {}
      }
<span class="line-modified">!     public static class StringOverflow extends Exception {</span>
          private static final long serialVersionUID = 0;
          public final String value;
          public StringOverflow(String s) {
              value = s;
          }
      }
  
<span class="line-removed">-     /** Write constant pool to pool buffer.</span>
<span class="line-removed">-      *  Note: during writing, constant pool</span>
<span class="line-removed">-      *  might grow since some parts of constants still need to be entered.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void writePool(Pool pool) throws PoolOverflow, StringOverflow {</span>
<span class="line-removed">-         int poolCountIdx = poolbuf.length;</span>
<span class="line-removed">-         poolbuf.appendChar(0);</span>
<span class="line-removed">-         int i = 1;</span>
<span class="line-removed">-         while (i &lt; pool.pp) {</span>
<span class="line-removed">-             Object value = pool.pool[i];</span>
<span class="line-removed">-             Assert.checkNonNull(value);</span>
<span class="line-removed">-             if (value instanceof Method || value instanceof Variable)</span>
<span class="line-removed">-                 value = ((DelegatedSymbol)value).getUnderlyingSymbol();</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (value instanceof MethodSymbol) {</span>
<span class="line-removed">-                 MethodSymbol m = (MethodSymbol)value;</span>
<span class="line-removed">-                 if (!m.isDynamic()) {</span>
<span class="line-removed">-                     poolbuf.appendByte((m.owner.flags() &amp; INTERFACE) != 0</span>
<span class="line-removed">-                               ? CONSTANT_InterfaceMethodref</span>
<span class="line-removed">-                               : CONSTANT_Methodref);</span>
<span class="line-removed">-                     poolbuf.appendChar(pool.put(m.owner));</span>
<span class="line-removed">-                     poolbuf.appendChar(pool.put(nameType(m)));</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     //invokedynamic</span>
<span class="line-removed">-                     DynamicMethodSymbol dynSym = (DynamicMethodSymbol)m;</span>
<span class="line-removed">-                     MethodHandle handle = new MethodHandle(dynSym.bsmKind, dynSym.bsm, types);</span>
<span class="line-removed">-                     DynamicMethod.BootstrapMethodsKey key = new DynamicMethod.BootstrapMethodsKey(dynSym, types);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     // Figure out the index for existing BSM; create a new BSM if no key</span>
<span class="line-removed">-                     DynamicMethod.BootstrapMethodsValue val = bootstrapMethods.get(key);</span>
<span class="line-removed">-                     if (val == null) {</span>
<span class="line-removed">-                         int index = bootstrapMethods.size();</span>
<span class="line-removed">-                         val = new DynamicMethod.BootstrapMethodsValue(handle, index);</span>
<span class="line-removed">-                         bootstrapMethods.put(key, val);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     //init cp entries</span>
<span class="line-removed">-                     pool.put(names.BootstrapMethods);</span>
<span class="line-removed">-                     pool.put(handle);</span>
<span class="line-removed">-                     for (Object staticArg : dynSym.staticArgs) {</span>
<span class="line-removed">-                         pool.put(staticArg);</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     poolbuf.appendByte(CONSTANT_InvokeDynamic);</span>
<span class="line-removed">-                     poolbuf.appendChar(val.index);</span>
<span class="line-removed">-                     poolbuf.appendChar(pool.put(nameType(dynSym)));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (value instanceof VarSymbol) {</span>
<span class="line-removed">-                 VarSymbol v = (VarSymbol)value;</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Fieldref);</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(v.owner));</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(nameType(v)));</span>
<span class="line-removed">-             } else if (value instanceof Name) {</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Utf8);</span>
<span class="line-removed">-                 byte[] bs = ((Name)value).toUtf();</span>
<span class="line-removed">-                 poolbuf.appendChar(bs.length);</span>
<span class="line-removed">-                 poolbuf.appendBytes(bs, 0, bs.length);</span>
<span class="line-removed">-                 if (bs.length &gt; Pool.MAX_STRING_LENGTH)</span>
<span class="line-removed">-                     throw new StringOverflow(value.toString());</span>
<span class="line-removed">-             } else if (value instanceof ClassSymbol) {</span>
<span class="line-removed">-                 ClassSymbol c = (ClassSymbol)value;</span>
<span class="line-removed">-                 if (c.owner.kind == TYP) pool.put(c.owner);</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Class);</span>
<span class="line-removed">-                 if (c.type.hasTag(ARRAY)) {</span>
<span class="line-removed">-                     poolbuf.appendChar(pool.put(typeSig(c.type)));</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     poolbuf.appendChar(pool.put(names.fromUtf(externalize(c.flatname))));</span>
<span class="line-removed">-                     enterInner(c);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (value instanceof NameAndType) {</span>
<span class="line-removed">-                 NameAndType nt = (NameAndType)value;</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_NameandType);</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(nt.name));</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(typeSig(nt.uniqueType.type)));</span>
<span class="line-removed">-             } else if (value instanceof Integer) {</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Integer);</span>
<span class="line-removed">-                 poolbuf.appendInt(((Integer)value).intValue());</span>
<span class="line-removed">-             } else if (value instanceof Long) {</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Long);</span>
<span class="line-removed">-                 poolbuf.appendLong(((Long)value).longValue());</span>
<span class="line-removed">-                 i++;</span>
<span class="line-removed">-             } else if (value instanceof Float) {</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Float);</span>
<span class="line-removed">-                 poolbuf.appendFloat(((Float)value).floatValue());</span>
<span class="line-removed">-             } else if (value instanceof Double) {</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Double);</span>
<span class="line-removed">-                 poolbuf.appendDouble(((Double)value).doubleValue());</span>
<span class="line-removed">-                 i++;</span>
<span class="line-removed">-             } else if (value instanceof String) {</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_String);</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(names.fromString((String)value)));</span>
<span class="line-removed">-             } else if (value instanceof UniqueType) {</span>
<span class="line-removed">-                 Type type = ((UniqueType)value).type;</span>
<span class="line-removed">-                 if (type.hasTag(METHOD)) {</span>
<span class="line-removed">-                     poolbuf.appendByte(CONSTANT_MethodType);</span>
<span class="line-removed">-                     poolbuf.appendChar(pool.put(typeSig((MethodType)type)));</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     Assert.check(type.hasTag(ARRAY));</span>
<span class="line-removed">-                     poolbuf.appendByte(CONSTANT_Class);</span>
<span class="line-removed">-                     poolbuf.appendChar(pool.put(xClassName(type)));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             } else if (value instanceof MethodHandle) {</span>
<span class="line-removed">-                 MethodHandle ref = (MethodHandle)value;</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_MethodHandle);</span>
<span class="line-removed">-                 poolbuf.appendByte(ref.refKind);</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(ref.refSym));</span>
<span class="line-removed">-             } else if (value instanceof ModuleSymbol) {</span>
<span class="line-removed">-                 ModuleSymbol m = (ModuleSymbol)value;</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Module);</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(m.name));</span>
<span class="line-removed">-             } else if (value instanceof PackageSymbol) {</span>
<span class="line-removed">-                 PackageSymbol m = (PackageSymbol)value;</span>
<span class="line-removed">-                 poolbuf.appendByte(CONSTANT_Package);</span>
<span class="line-removed">-                 poolbuf.appendChar(pool.put(names.fromUtf(externalize(m.fullname))));</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 Assert.error(&quot;writePool &quot; + value);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             i++;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (pool.pp &gt; Pool.MAX_ENTRIES)</span>
<span class="line-removed">-             throw new PoolOverflow();</span>
<span class="line-removed">-         putChar(poolbuf, poolCountIdx, pool.pp);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Given a symbol, return its name-and-type.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     NameAndType nameType(Symbol sym) {</span>
<span class="line-removed">-         return new NameAndType(sym.name, sym.externalType(types), types);</span>
<span class="line-removed">-         // the NameAndType is generated from a symbol reference, and the</span>
<span class="line-removed">-         // adjustment of adding an additional this$n parameter needs to be made.</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
  /******************************************************************
   * Writing Attributes
   ******************************************************************/
  
      /** Write header for an attribute to data buffer and return
       *  position past attribute length index.
       */
<span class="line-modified">!     int writeAttr(Name attrName) {</span>
<span class="line-modified">!         databuf.appendChar(pool.put(attrName));</span>
          databuf.appendInt(0);
          return databuf.length;
      }
  
      /** Fill in attribute length.
       */
<span class="line-modified">!     void endAttr(int index) {</span>
          putInt(databuf, index - 4, databuf.length - index);
      }
  
      /** Leave space for attribute count and return index for
       *  number of attributes field.
<span class="line-new-header">--- 256,45 ---</span>
          buf.elems[adr+1] = (byte)((x &gt;&gt; 16) &amp; 0xFF);
          buf.elems[adr+2] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
          buf.elems[adr+3] = (byte)((x      ) &amp; 0xFF);
      }
  
  /******************************************************************
   * Writing the Constant Pool
   ******************************************************************/
  
      /** Thrown when the constant pool is over full.
       */
<span class="line-modified">!     public static class PoolOverflow extends RuntimeException {</span>
          private static final long serialVersionUID = 0;
          public PoolOverflow() {}
      }
<span class="line-modified">!     public static class StringOverflow extends RuntimeException {</span>
          private static final long serialVersionUID = 0;
          public final String value;
          public StringOverflow(String s) {
              value = s;
          }
      }
  
  /******************************************************************
   * Writing Attributes
   ******************************************************************/
  
      /** Write header for an attribute to data buffer and return
       *  position past attribute length index.
       */
<span class="line-modified">!     public int writeAttr(Name attrName) {</span>
<span class="line-modified">!         int index = poolWriter.putName(attrName);</span>
<span class="line-added">+         databuf.appendChar(index);</span>
          databuf.appendInt(0);
          return databuf.length;
      }
  
      /** Fill in attribute length.
       */
<span class="line-modified">!     public void endAttr(int index) {</span>
          putInt(databuf, index - 4, databuf.length - index);
      }
  
      /** Leave space for attribute count and return index for
       *  number of attributes field.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 564,13 ***</span>
          ClassSymbol enclClass = c.owner.enclClass();
          MethodSymbol enclMethod =
              (c.owner.type == null // local to init block
               || c.owner.kind != MTH) // or member init
              ? null
<span class="line-modified">!             : (MethodSymbol)c.owner;</span>
<span class="line-modified">!         databuf.appendChar(pool.put(enclClass));</span>
<span class="line-modified">!         databuf.appendChar(enclMethod == null ? 0 : pool.put(nameType(c.owner)));</span>
          endAttr(alenIdx);
          return 1;
      }
  
      /** Write flag attributes; return number of attributes written.
<span class="line-new-header">--- 329,13 ---</span>
          ClassSymbol enclClass = c.owner.enclClass();
          MethodSymbol enclMethod =
              (c.owner.type == null // local to init block
               || c.owner.kind != MTH) // or member init
              ? null
<span class="line-modified">!             : ((MethodSymbol)c.owner).originalEnclosingMethod();</span>
<span class="line-modified">!         databuf.appendChar(poolWriter.putClass(enclClass));</span>
<span class="line-modified">!         databuf.appendChar(enclMethod == null ? 0 : poolWriter.putNameAndType(enclMethod));</span>
          endAttr(alenIdx);
          return 1;
      }
  
      /** Write flag attributes; return number of attributes written.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 586,21 ***</span>
      }
  
      /** Write member (field or method) attributes;
       *  return number of attributes written.
       */
<span class="line-modified">!     int writeMemberAttrs(Symbol sym) {</span>
<span class="line-modified">!         int acount = writeFlagAttrs(sym.flags());</span>
          long flags = sym.flags();
          if ((flags &amp; (SYNTHETIC | BRIDGE)) != SYNTHETIC &amp;&amp;
              (flags &amp; ANONCONSTR) == 0 &amp;&amp;
              (!types.isSameType(sym.type, sym.erasure(types)) ||
<span class="line-modified">!              signatureGen.hasTypeVar(sym.type.getThrownTypes()))) {</span>
              // note that a local class with captured variables
              // will get a signature attribute
              int alenIdx = writeAttr(names.Signature);
<span class="line-modified">!             databuf.appendChar(pool.put(typeSig(sym.type)));</span>
              endAttr(alenIdx);
              acount++;
          }
          acount += writeJavaAnnotations(sym.getRawAttributes());
          acount += writeTypeAnnotations(sym.getRawTypeAttributes(), false);
<span class="line-new-header">--- 351,24 ---</span>
      }
  
      /** Write member (field or method) attributes;
       *  return number of attributes written.
       */
<span class="line-modified">!     int writeMemberAttrs(Symbol sym, boolean isRecordComponent) {</span>
<span class="line-modified">!         int acount = 0;</span>
<span class="line-added">+         if (!isRecordComponent) {</span>
<span class="line-added">+             acount = writeFlagAttrs(sym.flags());</span>
<span class="line-added">+         }</span>
          long flags = sym.flags();
          if ((flags &amp; (SYNTHETIC | BRIDGE)) != SYNTHETIC &amp;&amp;
              (flags &amp; ANONCONSTR) == 0 &amp;&amp;
              (!types.isSameType(sym.type, sym.erasure(types)) ||
<span class="line-modified">!              poolWriter.signatureGen.hasTypeVar(sym.type.getThrownTypes()))) {</span>
              // note that a local class with captured variables
              // will get a signature attribute
              int alenIdx = writeAttr(names.Signature);
<span class="line-modified">!             databuf.appendChar(poolWriter.putSignature(sym));</span>
              endAttr(alenIdx);
              acount++;
          }
          acount += writeJavaAnnotations(sym.getRawAttributes());
          acount += writeTypeAnnotations(sym.getRawTypeAttributes(), false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 619,38 ***</span>
              // Write extra parameters first
              for (VarSymbol s : m.extraParams) {
                  final int flags =
                      ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
                      ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified">!                 databuf.appendChar(pool.put(s.name));</span>
                  databuf.appendChar(flags);
              }
              // Now write the real parameters
              for (VarSymbol s : m.params) {
                  final int flags =
                      ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
                      ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified">!                 databuf.appendChar(pool.put(s.name));</span>
                  databuf.appendChar(flags);
              }
              // Now write the captured locals
              for (VarSymbol s : m.capturedLocals) {
                  final int flags =
                      ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
                      ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified">!                 databuf.appendChar(pool.put(s.name));</span>
                  databuf.appendChar(flags);
              }
              endAttr(attrIndex);
              return 1;
          } else
              return 0;
      }
  
<span class="line-removed">- </span>
      private void writeParamAnnotations(List&lt;VarSymbol&gt; params,
                                         RetentionPolicy retention) {
          for (VarSymbol s : params) {
              ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
              for (Attribute.Compound a : s.getRawAttributes())
                  if (types.getRetention(a) == retention)
                      buf.append(a);
<span class="line-new-header">--- 387,38 ---</span>
              // Write extra parameters first
              for (VarSymbol s : m.extraParams) {
                  final int flags =
                      ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
                      ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified">!                 databuf.appendChar(poolWriter.putName(s.name));</span>
                  databuf.appendChar(flags);
              }
              // Now write the real parameters
              for (VarSymbol s : m.params) {
                  final int flags =
                      ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
                      ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified">!                 databuf.appendChar(poolWriter.putName(s.name));</span>
                  databuf.appendChar(flags);
              }
              // Now write the captured locals
              for (VarSymbol s : m.capturedLocals) {
                  final int flags =
                      ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
                      ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified">!                 databuf.appendChar(poolWriter.putName(s.name));</span>
                  databuf.appendChar(flags);
              }
              endAttr(attrIndex);
              return 1;
          } else
              return 0;
      }
  
      private void writeParamAnnotations(List&lt;VarSymbol&gt; params,
                                         RetentionPolicy retention) {
<span class="line-added">+         databuf.appendByte(params.length());</span>
          for (VarSymbol s : params) {
              ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
              for (Attribute.Compound a : s.getRawAttributes())
                  if (types.getRetention(a) == retention)
                      buf.append(a);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 668,15 ***</span>
      }
  
      /** Write method parameter annotations;
       *  return number of attributes written.
       */
<span class="line-modified">!     int writeParameterAttrs(MethodSymbol m) {</span>
          boolean hasVisible = false;
          boolean hasInvisible = false;
<span class="line-modified">!         if (m.params != null) {</span>
<span class="line-modified">!             for (VarSymbol s : m.params) {</span>
                  for (Attribute.Compound a : s.getRawAttributes()) {
                      switch (types.getRetention(a)) {
                      case SOURCE: break;
                      case CLASS: hasInvisible = true; break;
                      case RUNTIME: hasVisible = true; break;
<span class="line-new-header">--- 436,15 ---</span>
      }
  
      /** Write method parameter annotations;
       *  return number of attributes written.
       */
<span class="line-modified">!     int writeParameterAttrs(List&lt;VarSymbol&gt; vars) {</span>
          boolean hasVisible = false;
          boolean hasInvisible = false;
<span class="line-modified">!         if (vars != null) {</span>
<span class="line-modified">!             for (VarSymbol s : vars) {</span>
                  for (Attribute.Compound a : s.getRawAttributes()) {
                      switch (types.getRetention(a)) {
                      case SOURCE: break;
                      case CLASS: hasInvisible = true; break;
                      case RUNTIME: hasVisible = true; break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,17 ***</span>
          }
  
          int attrCount = 0;
          if (hasVisible) {
              int attrIndex = writeAttr(names.RuntimeVisibleParameterAnnotations);
<span class="line-modified">!             writeParamAnnotations(m, RetentionPolicy.RUNTIME);</span>
              endAttr(attrIndex);
              attrCount++;
          }
          if (hasInvisible) {
              int attrIndex = writeAttr(names.RuntimeInvisibleParameterAnnotations);
<span class="line-modified">!             writeParamAnnotations(m, RetentionPolicy.CLASS);</span>
              endAttr(attrIndex);
              attrCount++;
          }
          return attrCount;
      }
<span class="line-new-header">--- 455,17 ---</span>
          }
  
          int attrCount = 0;
          if (hasVisible) {
              int attrIndex = writeAttr(names.RuntimeVisibleParameterAnnotations);
<span class="line-modified">!             writeParamAnnotations(vars, RetentionPolicy.RUNTIME);</span>
              endAttr(attrIndex);
              attrCount++;
          }
          if (hasInvisible) {
              int attrIndex = writeAttr(names.RuntimeInvisibleParameterAnnotations);
<span class="line-modified">!             writeParamAnnotations(vars, RetentionPolicy.CLASS);</span>
              endAttr(attrIndex);
              attrCount++;
          }
          return attrCount;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 801,54 ***</span>
      /** A visitor to write an attribute including its leading
       *  single-character marker.
       */
      class AttributeWriter implements Attribute.Visitor {
          public void visitConstant(Attribute.Constant _value) {
<span class="line-modified">!             Object value = _value.value;</span>
<span class="line-modified">!             switch (_value.type.getTag()) {</span>
<span class="line-modified">!             case BYTE:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;B&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case CHAR:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;C&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case SHORT:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;S&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case INT:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;I&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case LONG:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;J&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case FLOAT:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;F&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case DOUBLE:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;D&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case BOOLEAN:</span>
<span class="line-removed">-                 databuf.appendByte(&#39;Z&#39;);</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case CLASS:</span>
<span class="line-removed">-                 Assert.check(value instanceof String);</span>
                  databuf.appendByte(&#39;s&#39;);
<span class="line-modified">!                 value = names.fromString(value.toString()); // CONSTANT_Utf8</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 throw new AssertionError(_value.type);</span>
              }
<span class="line-removed">-             databuf.appendChar(pool.put(value));</span>
          }
          public void visitEnum(Attribute.Enum e) {
              databuf.appendByte(&#39;e&#39;);
<span class="line-modified">!             databuf.appendChar(pool.put(typeSig(e.value.type)));</span>
<span class="line-modified">!             databuf.appendChar(pool.put(e.value.name));</span>
          }
          public void visitClass(Attribute.Class clazz) {
              databuf.appendByte(&#39;c&#39;);
<span class="line-modified">!             databuf.appendChar(pool.put(typeSig(types.erasure(clazz.classType))));</span>
          }
          public void visitCompound(Attribute.Compound compound) {
              databuf.appendByte(&#39;@&#39;);
              writeCompoundAttribute(compound);
          }
<span class="line-new-header">--- 569,55 ---</span>
      /** A visitor to write an attribute including its leading
       *  single-character marker.
       */
      class AttributeWriter implements Attribute.Visitor {
          public void visitConstant(Attribute.Constant _value) {
<span class="line-modified">!             if (_value.type.getTag() == CLASS) {</span>
<span class="line-modified">!                 Assert.check(_value.value instanceof String);</span>
<span class="line-modified">!                 String s = (String)_value.value;</span>
                  databuf.appendByte(&#39;s&#39;);
<span class="line-modified">!                 databuf.appendChar(poolWriter.putName(names.fromString(s)));</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 switch (_value.type.getTag()) {</span>
<span class="line-modified">!                     case BYTE:</span>
<span class="line-added">+                         databuf.appendByte(&#39;B&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case CHAR:</span>
<span class="line-added">+                         databuf.appendByte(&#39;C&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case SHORT:</span>
<span class="line-added">+                         databuf.appendByte(&#39;S&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case INT:</span>
<span class="line-added">+                         databuf.appendByte(&#39;I&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case LONG:</span>
<span class="line-added">+                         databuf.appendByte(&#39;J&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case FLOAT:</span>
<span class="line-added">+                         databuf.appendByte(&#39;F&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case DOUBLE:</span>
<span class="line-added">+                         databuf.appendByte(&#39;D&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case BOOLEAN:</span>
<span class="line-added">+                         databuf.appendByte(&#39;Z&#39;);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     default:</span>
<span class="line-added">+                         throw new AssertionError(_value.type);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 databuf.appendChar(poolWriter.putConstant(_value.value));</span>
              }
          }
          public void visitEnum(Attribute.Enum e) {
              databuf.appendByte(&#39;e&#39;);
<span class="line-modified">!             databuf.appendChar(poolWriter.putDescriptor(e.value.type));</span>
<span class="line-modified">!             databuf.appendChar(poolWriter.putName(e.value.name));</span>
          }
          public void visitClass(Attribute.Class clazz) {
              databuf.appendByte(&#39;c&#39;);
<span class="line-modified">!             databuf.appendChar(poolWriter.putDescriptor(clazz.classType));</span>
          }
          public void visitCompound(Attribute.Compound compound) {
              databuf.appendByte(&#39;@&#39;);
              writeCompoundAttribute(compound);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 865,14 ***</span>
      }
      AttributeWriter awriter = new AttributeWriter();
  
      /** Write a compound attribute excluding the &#39;@&#39; marker. */
      void writeCompoundAttribute(Attribute.Compound c) {
<span class="line-modified">!         databuf.appendChar(pool.put(typeSig(c.type)));</span>
          databuf.appendChar(c.values.length());
          for (Pair&lt;Symbol.MethodSymbol,Attribute&gt; p : c.values) {
<span class="line-modified">!             databuf.appendChar(pool.put(p.fst.name));</span>
              p.snd.accept(awriter);
          }
      }
  
      void writeTypeAnnotation(Attribute.TypeCompound c) {
<span class="line-new-header">--- 634,14 ---</span>
      }
      AttributeWriter awriter = new AttributeWriter();
  
      /** Write a compound attribute excluding the &#39;@&#39; marker. */
      void writeCompoundAttribute(Attribute.Compound c) {
<span class="line-modified">!         databuf.appendChar(poolWriter.putDescriptor(c.type));</span>
          databuf.appendChar(c.values.length());
          for (Pair&lt;Symbol.MethodSymbol,Attribute&gt; p : c.values) {
<span class="line-modified">!             databuf.appendChar(poolWriter.putName(p.fst.name));</span>
              p.snd.accept(awriter);
          }
      }
  
      void writeTypeAnnotation(Attribute.TypeCompound c) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 972,60 ***</span>
      int writeModuleAttribute(ClassSymbol c) {
          ModuleSymbol m = (ModuleSymbol) c.owner;
  
          int alenIdx = writeAttr(names.Module);
  
<span class="line-modified">!         databuf.appendChar(pool.put(m));</span>
          databuf.appendChar(ModuleFlags.value(m.flags)); // module_flags
<span class="line-modified">!         databuf.appendChar(m.version != null ? pool.put(m.version) : 0);</span>
  
          ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
          for (RequiresDirective r: m.requires) {
              if (!r.flags.contains(RequiresFlag.EXTRA))
                  requires.add(r);
          }
          databuf.appendChar(requires.size());
          for (RequiresDirective r: requires) {
<span class="line-modified">!             databuf.appendChar(pool.put(r.module));</span>
              databuf.appendChar(RequiresFlag.value(r.flags));
<span class="line-modified">!             databuf.appendChar(r.module.version != null ? pool.put(r.module.version) : 0);</span>
          }
  
          List&lt;ExportsDirective&gt; exports = m.exports;
          databuf.appendChar(exports.size());
          for (ExportsDirective e: exports) {
<span class="line-modified">!             databuf.appendChar(pool.put(e.packge));</span>
              databuf.appendChar(ExportsFlag.value(e.flags));
              if (e.modules == null) {
                  databuf.appendChar(0);
              } else {
                  databuf.appendChar(e.modules.size());
                  for (ModuleSymbol msym: e.modules) {
<span class="line-modified">!                     databuf.appendChar(pool.put(msym));</span>
                  }
              }
          }
  
          List&lt;OpensDirective&gt; opens = m.opens;
          databuf.appendChar(opens.size());
          for (OpensDirective o: opens) {
<span class="line-modified">!             databuf.appendChar(pool.put(o.packge));</span>
              databuf.appendChar(OpensFlag.value(o.flags));
              if (o.modules == null) {
                  databuf.appendChar(0);
              } else {
                  databuf.appendChar(o.modules.size());
                  for (ModuleSymbol msym: o.modules) {
<span class="line-modified">!                     databuf.appendChar(pool.put(msym));</span>
                  }
              }
          }
  
          List&lt;UsesDirective&gt; uses = m.uses;
          databuf.appendChar(uses.size());
          for (UsesDirective s: uses) {
<span class="line-modified">!             databuf.appendChar(pool.put(s.service));</span>
          }
  
          // temporary fix to merge repeated provides clause for same service;
          // eventually this should be disallowed when analyzing the module,
          // so that each service type only appears once.
<span class="line-new-header">--- 741,60 ---</span>
      int writeModuleAttribute(ClassSymbol c) {
          ModuleSymbol m = (ModuleSymbol) c.owner;
  
          int alenIdx = writeAttr(names.Module);
  
<span class="line-modified">!         databuf.appendChar(poolWriter.putModule(m));</span>
          databuf.appendChar(ModuleFlags.value(m.flags)); // module_flags
<span class="line-modified">!         databuf.appendChar(m.version != null ? poolWriter.putName(m.version) : 0);</span>
  
          ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
          for (RequiresDirective r: m.requires) {
              if (!r.flags.contains(RequiresFlag.EXTRA))
                  requires.add(r);
          }
          databuf.appendChar(requires.size());
          for (RequiresDirective r: requires) {
<span class="line-modified">!             databuf.appendChar(poolWriter.putModule(r.module));</span>
              databuf.appendChar(RequiresFlag.value(r.flags));
<span class="line-modified">!             databuf.appendChar(r.module.version != null ? poolWriter.putName(r.module.version) : 0);</span>
          }
  
          List&lt;ExportsDirective&gt; exports = m.exports;
          databuf.appendChar(exports.size());
          for (ExportsDirective e: exports) {
<span class="line-modified">!             databuf.appendChar(poolWriter.putPackage(e.packge));</span>
              databuf.appendChar(ExportsFlag.value(e.flags));
              if (e.modules == null) {
                  databuf.appendChar(0);
              } else {
                  databuf.appendChar(e.modules.size());
                  for (ModuleSymbol msym: e.modules) {
<span class="line-modified">!                     databuf.appendChar(poolWriter.putModule(msym));</span>
                  }
              }
          }
  
          List&lt;OpensDirective&gt; opens = m.opens;
          databuf.appendChar(opens.size());
          for (OpensDirective o: opens) {
<span class="line-modified">!             databuf.appendChar(poolWriter.putPackage(o.packge));</span>
              databuf.appendChar(OpensFlag.value(o.flags));
              if (o.modules == null) {
                  databuf.appendChar(0);
              } else {
                  databuf.appendChar(o.modules.size());
                  for (ModuleSymbol msym: o.modules) {
<span class="line-modified">!                     databuf.appendChar(poolWriter.putModule(msym));</span>
                  }
              }
          }
  
          List&lt;UsesDirective&gt; uses = m.uses;
          databuf.appendChar(uses.size());
          for (UsesDirective s: uses) {
<span class="line-modified">!             databuf.appendChar(poolWriter.putClass(s.service));</span>
          }
  
          // temporary fix to merge repeated provides clause for same service;
          // eventually this should be disallowed when analyzing the module,
          // so that each service type only appears once.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1033,94 ***</span>
          for (ProvidesDirective p : m.provides) {
              mergedProvides.computeIfAbsent(p.service, s -&gt; new LinkedHashSet&lt;&gt;()).addAll(p.impls);
          }
          databuf.appendChar(mergedProvides.size());
          mergedProvides.forEach((srvc, impls) -&gt; {
<span class="line-modified">!             databuf.appendChar(pool.put(srvc));</span>
              databuf.appendChar(impls.size());
<span class="line-modified">!             impls.forEach(impl -&gt; databuf.appendChar(pool.put(impl)));</span>
          });
  
          endAttr(alenIdx);
          return 1;
      }
  
  /**********************************************************************
   * Writing Objects
   **********************************************************************/
  
<span class="line-removed">-     /** Enter an inner class into the `innerClasses&#39; set/queue.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void enterInner(ClassSymbol c) {</span>
<span class="line-removed">-         if (c.type.isCompound()) {</span>
<span class="line-removed">-             throw new AssertionError(&quot;Unexpected intersection type: &quot; + c.type);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             c.complete();</span>
<span class="line-removed">-         } catch (CompletionFailure ex) {</span>
<span class="line-removed">-             System.err.println(&quot;error: &quot; + c + &quot;: &quot; + ex.getMessage());</span>
<span class="line-removed">-             throw ex;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (!c.type.hasTag(CLASS)) return; // arrays</span>
<span class="line-removed">-         if (pool != null &amp;&amp; // pool might be null if called from xClassName</span>
<span class="line-removed">-             c.owner.enclClass() != null &amp;&amp;</span>
<span class="line-removed">-             (innerClasses == null || !innerClasses.contains(c))) {</span>
<span class="line-removed">- //          log.errWriter.println(&quot;enter inner &quot; + c);//DEBUG</span>
<span class="line-removed">-             enterInner(c.owner.enclClass());</span>
<span class="line-removed">-             pool.put(c);</span>
<span class="line-removed">-             if (c.name != names.empty)</span>
<span class="line-removed">-                 pool.put(c.name);</span>
<span class="line-removed">-             if (innerClasses == null) {</span>
<span class="line-removed">-                 innerClasses = new HashSet&lt;&gt;();</span>
<span class="line-removed">-                 innerClassesQueue = new ListBuffer&lt;&gt;();</span>
<span class="line-removed">-                 pool.put(names.InnerClasses);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             innerClasses.add(c);</span>
<span class="line-removed">-             innerClassesQueue.append(c);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /** Write &quot;inner classes&quot; attribute.
       */
      void writeInnerClasses() {
          int alenIdx = writeAttr(names.InnerClasses);
<span class="line-modified">!         databuf.appendChar(innerClassesQueue.length());</span>
<span class="line-modified">!         for (List&lt;ClassSymbol&gt; l = innerClassesQueue.toList();</span>
<span class="line-removed">-              l.nonEmpty();</span>
<span class="line-removed">-              l = l.tail) {</span>
<span class="line-removed">-             ClassSymbol inner = l.head;</span>
              inner.markAbstractIfNeeded(types);
              char flags = (char) adjustFlags(inner.flags_field);
              if ((flags &amp; INTERFACE) != 0) flags |= ABSTRACT; // Interfaces are always ABSTRACT
              flags &amp;= ~STRICTFP; //inner classes should not have the strictfp flag set.
              if (dumpInnerClassModifiers) {
                  PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
                  pw.println(&quot;INNERCLASS  &quot; + inner.name);
                  pw.println(&quot;---&quot; + flagNames(flags));
              }
<span class="line-modified">!             databuf.appendChar(pool.get(inner));</span>
              databuf.appendChar(
<span class="line-modified">!                 inner.owner.kind == TYP &amp;&amp; !inner.name.isEmpty() ? pool.get(inner.owner) : 0);</span>
              databuf.appendChar(
<span class="line-modified">!                 !inner.name.isEmpty() ? pool.get(inner.name) : 0);</span>
              databuf.appendChar(flags);
          }
          endAttr(alenIdx);
      }
  
      /**
       * Write NestMembers attribute (if needed)
       */
      int writeNestMembersIfNeeded(ClassSymbol csym) {
<span class="line-modified">!         ListBuffer&lt;Symbol&gt; nested = new ListBuffer&lt;&gt;();</span>
          listNested(csym, nested);
<span class="line-modified">!         Set&lt;Symbol&gt; nestedUnique = new LinkedHashSet&lt;&gt;(nested);</span>
          if (csym.owner.kind == PCK &amp;&amp; !nestedUnique.isEmpty()) {
              int alenIdx = writeAttr(names.NestMembers);
              databuf.appendChar(nestedUnique.size());
<span class="line-modified">!             for (Symbol s : nestedUnique) {</span>
<span class="line-modified">!                 databuf.appendChar(pool.put(s));</span>
              }
              endAttr(alenIdx);
              return 1;
          }
          return 0;
<span class="line-new-header">--- 802,77 ---</span>
          for (ProvidesDirective p : m.provides) {
              mergedProvides.computeIfAbsent(p.service, s -&gt; new LinkedHashSet&lt;&gt;()).addAll(p.impls);
          }
          databuf.appendChar(mergedProvides.size());
          mergedProvides.forEach((srvc, impls) -&gt; {
<span class="line-modified">!             databuf.appendChar(poolWriter.putClass(srvc));</span>
              databuf.appendChar(impls.size());
<span class="line-modified">!             impls.forEach(impl -&gt; databuf.appendChar(poolWriter.putClass(impl)));</span>
          });
  
          endAttr(alenIdx);
          return 1;
      }
  
  /**********************************************************************
   * Writing Objects
   **********************************************************************/
  
      /** Write &quot;inner classes&quot; attribute.
       */
      void writeInnerClasses() {
          int alenIdx = writeAttr(names.InnerClasses);
<span class="line-modified">!         databuf.appendChar(poolWriter.innerClasses.size());</span>
<span class="line-modified">!         for (ClassSymbol inner : poolWriter.innerClasses) {</span>
              inner.markAbstractIfNeeded(types);
              char flags = (char) adjustFlags(inner.flags_field);
              if ((flags &amp; INTERFACE) != 0) flags |= ABSTRACT; // Interfaces are always ABSTRACT
              flags &amp;= ~STRICTFP; //inner classes should not have the strictfp flag set.
              if (dumpInnerClassModifiers) {
                  PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
                  pw.println(&quot;INNERCLASS  &quot; + inner.name);
                  pw.println(&quot;---&quot; + flagNames(flags));
              }
<span class="line-modified">!             databuf.appendChar(poolWriter.putClass(inner));</span>
              databuf.appendChar(
<span class="line-modified">!                 inner.owner.kind == TYP &amp;&amp; !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);</span>
              databuf.appendChar(
<span class="line-modified">!                 !inner.name.isEmpty() ? poolWriter.putName(inner.name) : 0);</span>
              databuf.appendChar(flags);
          }
          endAttr(alenIdx);
      }
  
<span class="line-added">+     int writeRecordAttribute(ClassSymbol csym) {</span>
<span class="line-added">+         int alenIdx = writeAttr(names.Record);</span>
<span class="line-added">+         Scope s = csym.members();</span>
<span class="line-added">+         databuf.appendChar(csym.getRecordComponents().size());</span>
<span class="line-added">+         for (VarSymbol v: csym.getRecordComponents()) {</span>
<span class="line-added">+             //databuf.appendChar(poolWriter.putMember(v.accessor.head.snd));</span>
<span class="line-added">+             databuf.appendChar(poolWriter.putName(v.name));</span>
<span class="line-added">+             databuf.appendChar(poolWriter.putDescriptor(v));</span>
<span class="line-added">+             int acountIdx = beginAttrs();</span>
<span class="line-added">+             int acount = 0;</span>
<span class="line-added">+             acount += writeMemberAttrs(v, true);</span>
<span class="line-added">+             endAttrs(acountIdx, acount);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         endAttr(alenIdx);</span>
<span class="line-added">+         return 1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Write NestMembers attribute (if needed)
       */
      int writeNestMembersIfNeeded(ClassSymbol csym) {
<span class="line-modified">!         ListBuffer&lt;ClassSymbol&gt; nested = new ListBuffer&lt;&gt;();</span>
          listNested(csym, nested);
<span class="line-modified">!         Set&lt;ClassSymbol&gt; nestedUnique = new LinkedHashSet&lt;&gt;(nested);</span>
          if (csym.owner.kind == PCK &amp;&amp; !nestedUnique.isEmpty()) {
              int alenIdx = writeAttr(names.NestMembers);
              databuf.appendChar(nestedUnique.size());
<span class="line-modified">!             for (ClassSymbol s : nestedUnique) {</span>
<span class="line-modified">!                 databuf.appendChar(poolWriter.putClass(s));</span>
              }
              endAttr(alenIdx);
              return 1;
          }
          return 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1130,18 ***</span>
       * Write NestHost attribute (if needed)
       */
      int writeNestHostIfNeeded(ClassSymbol csym) {
          if (csym.owner.kind != PCK) {
              int alenIdx = writeAttr(names.NestHost);
<span class="line-modified">!             databuf.appendChar(pool.put(csym.outermostClass()));</span>
              endAttr(alenIdx);
              return 1;
          }
          return 0;
      }
  
<span class="line-modified">!     private void listNested(Symbol sym, ListBuffer&lt;Symbol&gt; seen) {</span>
          if (sym.kind != TYP) return;
          ClassSymbol csym = (ClassSymbol)sym;
          if (csym.owner.kind != PCK) {
              seen.add(csym);
          }
<span class="line-new-header">--- 882,18 ---</span>
       * Write NestHost attribute (if needed)
       */
      int writeNestHostIfNeeded(ClassSymbol csym) {
          if (csym.owner.kind != PCK) {
              int alenIdx = writeAttr(names.NestHost);
<span class="line-modified">!             databuf.appendChar(poolWriter.putClass(csym.outermostClass()));</span>
              endAttr(alenIdx);
              return 1;
          }
          return 0;
      }
  
<span class="line-modified">!     private void listNested(Symbol sym, ListBuffer&lt;ClassSymbol&gt; seen) {</span>
          if (sym.kind != TYP) return;
          ClassSymbol csym = (ClassSymbol)sym;
          if (csym.owner.kind != PCK) {
              seen.add(csym);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1159,21 ***</span>
  
      /** Write &quot;bootstrapMethods&quot; attribute.
       */
      void writeBootstrapMethods() {
          int alenIdx = writeAttr(names.BootstrapMethods);
<span class="line-modified">!         databuf.appendChar(bootstrapMethods.size());</span>
<span class="line-modified">!         for (Map.Entry&lt;DynamicMethod.BootstrapMethodsKey, DynamicMethod.BootstrapMethodsValue&gt; entry : bootstrapMethods.entrySet()) {</span>
<span class="line-removed">-             DynamicMethod.BootstrapMethodsKey bsmKey = entry.getKey();</span>
              //write BSM handle
<span class="line-modified">!             databuf.appendChar(pool.get(entry.getValue().mh));</span>
<span class="line-modified">!             Object[] uniqueArgs = bsmKey.getUniqueArgs();</span>
              //write static args length
              databuf.appendChar(uniqueArgs.length);
              //write static args array
<span class="line-modified">!             for (Object o : uniqueArgs) {</span>
<span class="line-modified">!                 databuf.appendChar(pool.get(o));</span>
              }
          }
          endAttr(alenIdx);
      }
  
<span class="line-new-header">--- 911,20 ---</span>
  
      /** Write &quot;bootstrapMethods&quot; attribute.
       */
      void writeBootstrapMethods() {
          int alenIdx = writeAttr(names.BootstrapMethods);
<span class="line-modified">!         databuf.appendChar(poolWriter.bootstrapMethods.size());</span>
<span class="line-modified">!         for (BsmKey bsmKey : poolWriter.bootstrapMethods.keySet()) {</span>
              //write BSM handle
<span class="line-modified">!             databuf.appendChar(poolWriter.putConstant(bsmKey.bsm));</span>
<span class="line-modified">!             LoadableConstant[] uniqueArgs = bsmKey.staticArgs;</span>
              //write static args length
              databuf.appendChar(uniqueArgs.length);
              //write static args array
<span class="line-modified">!             for (LoadableConstant arg : uniqueArgs) {</span>
<span class="line-modified">!                 databuf.appendChar(poolWriter.putConstant(arg));</span>
              }
          }
          endAttr(alenIdx);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1185,21 ***</span>
          if (dumpFieldModifiers) {
              PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
              pw.println(&quot;FIELD  &quot; + v.name);
              pw.println(&quot;---&quot; + flagNames(v.flags()));
          }
<span class="line-modified">!         databuf.appendChar(pool.put(v.name));</span>
<span class="line-modified">!         databuf.appendChar(pool.put(typeSig(v.erasure(types))));</span>
          int acountIdx = beginAttrs();
          int acount = 0;
          if (v.getConstValue() != null) {
              int alenIdx = writeAttr(names.ConstantValue);
<span class="line-modified">!             databuf.appendChar(pool.put(v.getConstValue()));</span>
              endAttr(alenIdx);
              acount++;
          }
<span class="line-modified">!         acount += writeMemberAttrs(v);</span>
          endAttrs(acountIdx, acount);
      }
  
      /** Write method symbol, entering all references into constant pool.
       */
<span class="line-new-header">--- 936,22 ---</span>
          if (dumpFieldModifiers) {
              PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
              pw.println(&quot;FIELD  &quot; + v.name);
              pw.println(&quot;---&quot; + flagNames(v.flags()));
          }
<span class="line-modified">!         databuf.appendChar(poolWriter.putName(v.name));</span>
<span class="line-modified">!         databuf.appendChar(poolWriter.putDescriptor(v));</span>
          int acountIdx = beginAttrs();
          int acount = 0;
          if (v.getConstValue() != null) {
              int alenIdx = writeAttr(names.ConstantValue);
<span class="line-modified">!             databuf.appendChar(poolWriter.putConstant(v.getConstValue()));</span>
              endAttr(alenIdx);
              acount++;
          }
<span class="line-modified">!         acount += writeMemberAttrs(v, false);</span>
<span class="line-added">+         acount += writeExtraAttributes(v);</span>
          endAttrs(acountIdx, acount);
      }
  
      /** Write method symbol, entering all references into constant pool.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1209,12 ***</span>
          if (dumpMethodModifiers) {
              PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
              pw.println(&quot;METHOD  &quot; + m.name);
              pw.println(&quot;---&quot; + flagNames(m.flags()));
          }
<span class="line-modified">!         databuf.appendChar(pool.put(m.name));</span>
<span class="line-modified">!         databuf.appendChar(pool.put(typeSig(m.externalType(types))));</span>
          int acountIdx = beginAttrs();
          int acount = 0;
          if (m.code != null) {
              int alenIdx = writeAttr(names.Code);
              writeCode(m.code);
<span class="line-new-header">--- 961,12 ---</span>
          if (dumpMethodModifiers) {
              PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
              pw.println(&quot;METHOD  &quot; + m.name);
              pw.println(&quot;---&quot; + flagNames(m.flags()));
          }
<span class="line-modified">!         databuf.appendChar(poolWriter.putName(m.name));</span>
<span class="line-modified">!         databuf.appendChar(poolWriter.putDescriptor(m));</span>
          int acountIdx = beginAttrs();
          int acount = 0;
          if (m.code != null) {
              int alenIdx = writeAttr(names.Code);
              writeCode(m.code);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1225,27 ***</span>
          List&lt;Type&gt; thrown = m.erasure(types).getThrownTypes();
          if (thrown.nonEmpty()) {
              int alenIdx = writeAttr(names.Exceptions);
              databuf.appendChar(thrown.length());
              for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
<span class="line-modified">!                 databuf.appendChar(pool.put(l.head.tsym));</span>
              endAttr(alenIdx);
              acount++;
          }
          if (m.defaultValue != null) {
              int alenIdx = writeAttr(names.AnnotationDefault);
              m.defaultValue.accept(awriter);
              endAttr(alenIdx);
              acount++;
          }
<span class="line-modified">!         if (options.isSet(PARAMETERS) &amp;&amp; target.hasMethodParameters()) {</span>
              if (!m.isLambdaMethod()) // Per JDK-8138729, do not emit parameters table for lambda bodies.
                  acount += writeMethodParametersAttr(m);
          }
<span class="line-modified">!         acount += writeMemberAttrs(m);</span>
          if (!m.isLambdaMethod())
<span class="line-modified">!             acount += writeParameterAttrs(m);</span>
          endAttrs(acountIdx, acount);
      }
  
      /** Write code attribute of method.
       */
<span class="line-new-header">--- 977,28 ---</span>
          List&lt;Type&gt; thrown = m.erasure(types).getThrownTypes();
          if (thrown.nonEmpty()) {
              int alenIdx = writeAttr(names.Exceptions);
              databuf.appendChar(thrown.length());
              for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
<span class="line-modified">!                 databuf.appendChar(poolWriter.putClass(l.head));</span>
              endAttr(alenIdx);
              acount++;
          }
          if (m.defaultValue != null) {
              int alenIdx = writeAttr(names.AnnotationDefault);
              m.defaultValue.accept(awriter);
              endAttr(alenIdx);
              acount++;
          }
<span class="line-modified">!         if (target.hasMethodParameters() &amp;&amp; (options.isSet(PARAMETERS) || m.isConstructor() &amp;&amp; (m.flags_field &amp; RECORD) != 0)) {</span>
              if (!m.isLambdaMethod()) // Per JDK-8138729, do not emit parameters table for lambda bodies.
                  acount += writeMethodParametersAttr(m);
          }
<span class="line-modified">!         acount += writeMemberAttrs(m, false);</span>
          if (!m.isLambdaMethod())
<span class="line-modified">!             acount += writeParameterAttrs(m.params);</span>
<span class="line-added">+         acount += writeExtraAttributes(m);</span>
          endAttrs(acountIdx, acount);
      }
  
      /** Write code attribute of method.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1301,13 ***</span>
                      databuf.appendChar(r.start_pc);
                      Assert.check(r.length &gt; 0
                              &amp;&amp; (r.start_pc + r.length) &lt;= code.cp);
                      databuf.appendChar(r.length);
                      VarSymbol sym = var.sym;
<span class="line-modified">!                     databuf.appendChar(pool.put(sym.name));</span>
<span class="line-modified">!                     Type vartype = sym.erasure(types);</span>
<span class="line-removed">-                     databuf.appendChar(pool.put(typeSig(vartype)));</span>
                      databuf.appendChar(var.reg);
                      if (needsLocalVariableTypeEntry(var.sym.type)) {
                          nGenericVars++;
                      }
                  }
<span class="line-new-header">--- 1054,12 ---</span>
                      databuf.appendChar(r.start_pc);
                      Assert.check(r.length &gt; 0
                              &amp;&amp; (r.start_pc + r.length) &lt;= code.cp);
                      databuf.appendChar(r.length);
                      VarSymbol sym = var.sym;
<span class="line-modified">!                     databuf.appendChar(poolWriter.putName(sym.name));</span>
<span class="line-modified">!                     databuf.appendChar(poolWriter.putDescriptor(sym));</span>
                      databuf.appendChar(var.reg);
                      if (needsLocalVariableTypeEntry(var.sym.type)) {
                          nGenericVars++;
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1327,12 ***</span>
                          continue;
                      for (Code.LocalVar.Range r : var.aliveRanges) {
                          // write variable info
                          databuf.appendChar(r.start_pc);
                          databuf.appendChar(r.length);
<span class="line-modified">!                         databuf.appendChar(pool.put(sym.name));</span>
<span class="line-modified">!                         databuf.appendChar(pool.put(typeSig(sym.type)));</span>
                          databuf.appendChar(var.reg);
                          count++;
                      }
                  }
                  Assert.check(count == nGenericVars);
<span class="line-new-header">--- 1079,12 ---</span>
                          continue;
                      for (Code.LocalVar.Range r : var.aliveRanges) {
                          // write variable info
                          databuf.appendChar(r.start_pc);
                          databuf.appendChar(r.length);
<span class="line-modified">!                         databuf.appendChar(poolWriter.putName(sym.name));</span>
<span class="line-modified">!                         databuf.appendChar(poolWriter.putSignature(sym));</span>
                          databuf.appendChar(var.reg);
                          count++;
                      }
                  }
                  Assert.check(count == nGenericVars);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1455,18 ***</span>
                  if (debugstackmap) System.out.print(&quot;null&quot;);
                  databuf.appendByte(5);
                  break;
              case CLASS:
              case ARRAY:
<span class="line-removed">-                 if (debugstackmap) System.out.print(&quot;object(&quot; + t + &quot;)&quot;);</span>
<span class="line-removed">-                 databuf.appendByte(7);</span>
<span class="line-removed">-                 databuf.appendChar(pool.put(t));</span>
<span class="line-removed">-                 break;</span>
              case TYPEVAR:
                  if (debugstackmap) System.out.print(&quot;object(&quot; + types.erasure(t).tsym + &quot;)&quot;);
                  databuf.appendByte(7);
<span class="line-modified">!                 databuf.appendChar(pool.put(types.erasure(t).tsym));</span>
                  break;
              case UNINITIALIZED_THIS:
                  if (debugstackmap) System.out.print(&quot;uninit_this&quot;);
                  databuf.appendByte(6);
                  break;
<span class="line-new-header">--- 1207,14 ---</span>
                  if (debugstackmap) System.out.print(&quot;null&quot;);
                  databuf.appendByte(5);
                  break;
              case CLASS:
              case ARRAY:
              case TYPEVAR:
                  if (debugstackmap) System.out.print(&quot;object(&quot; + types.erasure(t).tsym + &quot;)&quot;);
                  databuf.appendByte(7);
<span class="line-modified">!                 databuf.appendChar(poolWriter.putClass(types.erasure(t)));</span>
                  break;
              case UNINITIALIZED_THIS:
                  if (debugstackmap) System.out.print(&quot;uninit_this&quot;);
                  databuf.appendByte(6);
                  break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1761,15 ***</span>
      public void writeClassFile(OutputStream out, ClassSymbol c)
          throws IOException, PoolOverflow, StringOverflow {
          Assert.check((c.flags() &amp; COMPOUND) == 0);
          databuf.reset();
          poolbuf.reset();
<span class="line-removed">-         signatureGen.reset();</span>
<span class="line-removed">-         pool = c.pool;</span>
<span class="line-removed">-         innerClasses = null;</span>
<span class="line-removed">-         innerClassesQueue = null;</span>
<span class="line-removed">-         bootstrapMethods = new LinkedHashMap&lt;&gt;();</span>
  
          Type supertype = types.supertype(c.type);
          List&lt;Type&gt; interfaces = types.interfaces(c.type);
          List&lt;Type&gt; typarams = c.type.getTypeArguments();
  
<span class="line-new-header">--- 1509,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1791,33 ***</span>
          }
          databuf.appendChar(flags);
  
          if (c.owner.kind == MDL) {
              PackageSymbol unnamed = ((ModuleSymbol) c.owner).unnamedPackage;
<span class="line-modified">!             databuf.appendChar(pool.put(new ClassSymbol(0, names.module_info, unnamed)));</span>
          } else {
<span class="line-modified">!             databuf.appendChar(pool.put(c));</span>
          }
<span class="line-modified">!         databuf.appendChar(supertype.hasTag(CLASS) ? pool.put(supertype.tsym) : 0);</span>
          databuf.appendChar(interfaces.length());
          for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)
<span class="line-modified">!             databuf.appendChar(pool.put(l.head.tsym));</span>
          int fieldsCount = 0;
          int methodsCount = 0;
          for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
              switch (sym.kind) {
              case VAR: fieldsCount++; break;
              case MTH: if ((sym.flags() &amp; HYPOTHETICAL) == 0) methodsCount++;
                        break;
<span class="line-modified">!             case TYP: enterInner((ClassSymbol)sym); break;</span>
              default : Assert.error();
              }
          }
  
          if (c.trans_local != null) {
              for (ClassSymbol local : c.trans_local) {
<span class="line-modified">!                 enterInner(local);</span>
              }
          }
  
          databuf.appendChar(fieldsCount);
          writeFields(c.members());
<span class="line-new-header">--- 1534,33 ---</span>
          }
          databuf.appendChar(flags);
  
          if (c.owner.kind == MDL) {
              PackageSymbol unnamed = ((ModuleSymbol) c.owner).unnamedPackage;
<span class="line-modified">!             databuf.appendChar(poolWriter.putClass(new ClassSymbol(0, names.module_info, unnamed)));</span>
          } else {
<span class="line-modified">!             databuf.appendChar(poolWriter.putClass(c));</span>
          }
<span class="line-modified">!         databuf.appendChar(supertype.hasTag(CLASS) ? poolWriter.putClass((ClassSymbol)supertype.tsym) : 0);</span>
          databuf.appendChar(interfaces.length());
          for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)
<span class="line-modified">!             databuf.appendChar(poolWriter.putClass((ClassSymbol)l.head.tsym));</span>
          int fieldsCount = 0;
          int methodsCount = 0;
          for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
              switch (sym.kind) {
              case VAR: fieldsCount++; break;
              case MTH: if ((sym.flags() &amp; HYPOTHETICAL) == 0) methodsCount++;
                        break;
<span class="line-modified">!             case TYP: poolWriter.enterInner((ClassSymbol)sym); break;</span>
              default : Assert.error();
              }
          }
  
          if (c.trans_local != null) {
              for (ClassSymbol local : c.trans_local) {
<span class="line-modified">!                 poolWriter.enterInner(local);</span>
              }
          }
  
          databuf.appendChar(fieldsCount);
          writeFields(c.members());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1831,41 ***</span>
              typarams.length() != 0 || supertype.allparams().length() != 0;
          for (List&lt;Type&gt; l = interfaces; !sigReq &amp;&amp; l.nonEmpty(); l = l.tail)
              sigReq = l.head.allparams().length() != 0;
          if (sigReq) {
              int alenIdx = writeAttr(names.Signature);
<span class="line-modified">!             if (typarams.length() != 0) signatureGen.assembleParamsSig(typarams);</span>
<span class="line-removed">-             signatureGen.assembleSig(supertype);</span>
<span class="line-removed">-             for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)</span>
<span class="line-removed">-                 signatureGen.assembleSig(l.head);</span>
<span class="line-removed">-             databuf.appendChar(pool.put(signatureGen.toName()));</span>
<span class="line-removed">-             signatureGen.reset();</span>
              endAttr(alenIdx);
              acount++;
          }
  
          if (c.sourcefile != null &amp;&amp; emitSourceFile) {
              int alenIdx = writeAttr(names.SourceFile);
              // WHM 6/29/1999: Strip file path prefix.  We do it here at
              // the last possible moment because the sourcefile may be used
              // elsewhere in error diagnostics. Fixes 4241573.
<span class="line-removed">-             //databuf.appendChar(c.pool.put(c.sourcefile));</span>
              String simpleName = PathFileObject.getSimpleName(c.sourcefile);
<span class="line-modified">!             databuf.appendChar(c.pool.put(names.fromString(simpleName)));</span>
              endAttr(alenIdx);
              acount++;
          }
  
          if (genCrt) {
              // Append SourceID attribute
              int alenIdx = writeAttr(names.SourceID);
<span class="line-modified">!             databuf.appendChar(c.pool.put(names.fromString(Long.toString(getLastModified(c.sourcefile)))));</span>
              endAttr(alenIdx);
              acount++;
              // Append CompilationID attribute
              alenIdx = writeAttr(names.CompilationID);
<span class="line-modified">!             databuf.appendChar(c.pool.put(names.fromString(Long.toString(System.currentTimeMillis()))));</span>
              endAttr(alenIdx);
              acount++;
          }
  
          acount += writeFlagAttrs(c.flags());
<span class="line-new-header">--- 1574,35 ---</span>
              typarams.length() != 0 || supertype.allparams().length() != 0;
          for (List&lt;Type&gt; l = interfaces; !sigReq &amp;&amp; l.nonEmpty(); l = l.tail)
              sigReq = l.head.allparams().length() != 0;
          if (sigReq) {
              int alenIdx = writeAttr(names.Signature);
<span class="line-modified">!             databuf.appendChar(poolWriter.putSignature(c));</span>
              endAttr(alenIdx);
              acount++;
          }
  
          if (c.sourcefile != null &amp;&amp; emitSourceFile) {
              int alenIdx = writeAttr(names.SourceFile);
              // WHM 6/29/1999: Strip file path prefix.  We do it here at
              // the last possible moment because the sourcefile may be used
              // elsewhere in error diagnostics. Fixes 4241573.
              String simpleName = PathFileObject.getSimpleName(c.sourcefile);
<span class="line-modified">!             databuf.appendChar(poolWriter.putName(names.fromString(simpleName)));</span>
              endAttr(alenIdx);
              acount++;
          }
  
          if (genCrt) {
              // Append SourceID attribute
              int alenIdx = writeAttr(names.SourceID);
<span class="line-modified">!             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(getLastModified(c.sourcefile)))));</span>
              endAttr(alenIdx);
              acount++;
              // Append CompilationID attribute
              alenIdx = writeAttr(names.CompilationID);
<span class="line-modified">!             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(System.currentTimeMillis()))));</span>
              endAttr(alenIdx);
              acount++;
          }
  
          acount += writeFlagAttrs(c.flags());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1875,10 ***</span>
<span class="line-new-header">--- 1612,11 ---</span>
          if (c.owner.kind == MDL) {
              acount += writeModuleAttribute(c);
              acount += writeFlagAttrs(c.owner.flags() &amp; ~DEPRECATED);
          }
          acount += writeExtraClassAttributes(c);
<span class="line-added">+         acount += writeExtraAttributes(c);</span>
  
          poolbuf.appendInt(JAVA_MAGIC);
          if (preview.isEnabled()) {
              poolbuf.appendChar(ClassFile.PREVIEW_MINOR_VERSION);
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1891,36 ***</span>
                  acount += writeNestMembersIfNeeded(c);
                  acount += writeNestHostIfNeeded(c);
              }
          }
  
<span class="line-modified">!         writePool(c.pool);</span>
  
<span class="line-modified">!         if (innerClasses != null) {</span>
<span class="line-modified">!             writeInnerClasses();</span>
              acount++;
          }
  
<span class="line-modified">!         if (!bootstrapMethods.isEmpty()) {</span>
<span class="line-modified">!             writeBootstrapMethods();</span>
              acount++;
          }
  
          endAttrs(acountIdx, acount);
  
<span class="line-removed">-         poolbuf.appendBytes(databuf.elems, 0, databuf.length);</span>
          out.write(poolbuf.elems, 0, poolbuf.length);
  
<span class="line-modified">!         pool = c.pool = null; // to conserve space</span>
<span class="line-modified">!      }</span>
  
<span class="line-modified">!     /**Allows subclasses to write additional class attributes</span>
       *
       * @return the number of attributes written
       */
<span class="line-modified">!     protected int writeExtraClassAttributes(ClassSymbol c) {</span>
<span class="line-modified">!         return 0;</span>
      }
  
      int adjustFlags(final long flags) {
          int result = (int)flags;
  
<span class="line-new-header">--- 1629,52 ---</span>
                  acount += writeNestMembersIfNeeded(c);
                  acount += writeNestHostIfNeeded(c);
              }
          }
  
<span class="line-modified">!         if (c.isRecord()) {</span>
<span class="line-added">+             acount += writeRecordAttribute(c);</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (!poolWriter.bootstrapMethods.isEmpty()) {</span>
<span class="line-modified">!             writeBootstrapMethods();</span>
              acount++;
          }
  
<span class="line-modified">!         if (!poolWriter.innerClasses.isEmpty()) {</span>
<span class="line-modified">!             writeInnerClasses();</span>
              acount++;
          }
  
          endAttrs(acountIdx, acount);
  
          out.write(poolbuf.elems, 0, poolbuf.length);
  
<span class="line-modified">!         poolWriter.writePool(out);</span>
<span class="line-modified">!         poolWriter.reset(); // to save space</span>
<span class="line-added">+ </span>
<span class="line-added">+         out.write(databuf.elems, 0, databuf.length);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+      /**Allows subclasses to write additional class attributes</span>
<span class="line-added">+       *</span>
<span class="line-added">+       * @return the number of attributes written</span>
<span class="line-added">+       */</span>
<span class="line-added">+     protected int writeExtraClassAttributes(ClassSymbol c) {</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     /**Allows friends to write additional attributes</span>
       *
       * @return the number of attributes written
       */
<span class="line-modified">!     protected int writeExtraAttributes(Symbol sym) {</span>
<span class="line-modified">!         int i = 0;</span>
<span class="line-added">+         for (ToIntFunction&lt;Symbol&gt; hook : extraAttributeHooks) {</span>
<span class="line-added">+             i += hook.applyAsInt(sym);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return i;</span>
      }
  
      int adjustFlags(final long flags) {
          int result = (int)flags;
  
</pre>
<center><a href="ClassReader.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Code.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
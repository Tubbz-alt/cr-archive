<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocTreeMaker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pretty.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 
<span class="line-removed">  50 import com.sun.source.tree.CaseTree.CaseKind;</span>
  51 import com.sun.source.tree.ModuleTree.ModuleKind;
  52 import com.sun.tools.javac.code.Directive.ExportsDirective;
  53 import com.sun.tools.javac.code.Directive.OpensDirective;
  54 import com.sun.tools.javac.code.Type.ModuleType;
<span class="line-removed">  55 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.PolyKind;</span>
  56 
  57 /**
  58  * Root class for abstract syntax tree nodes. It provides definitions
  59  * for specific tree nodes as subclasses nested inside.
  60  *
  61  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  62  * only tree fields for the syntactic subcomponents of the node.  Some
  63  * classes that represent identifier uses or definitions also define a
  64  * Symbol field that denotes the represented identifier.  Classes for
  65  * non-local jumps also carry the jump target as a field.  The root
  66  * class Tree itself defines fields for the tree&#39;s type and position.
  67  * No other fields are kept in a tree node; instead parameters are
  68  * passed to methods accessing the node.
  69  *
  70  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  71  * method defined in subclasses is `visit&#39; which applies a given
  72  * visitor to the tree. The actual tree processing is done by visitor
  73  * classes in other packages. The abstract class Visitor, as well as
  74  * an Factory interface for trees, are defined as inner classes in
  75  * Tree.
</pre>
<hr />
<pre>
 142         /** Foreach-loops, of type ForeachLoop.
 143          */
 144         FOREACHLOOP,
 145 
 146         /** Labelled statements, of type Labelled.
 147          */
 148         LABELLED,
 149 
 150         /** Switch statements, of type Switch.
 151          */
 152         SWITCH,
 153 
 154         /** Case parts in switch statements/expressions, of type Case.
 155          */
 156         CASE,
 157 
 158         /** Switch expression statements, of type Switch.
 159          */
 160         SWITCH_EXPRESSION,
 161 
<span class="line-modified"> 162         /** Synchronized statements, of type Synchonized.</span>
 163          */
 164         SYNCHRONIZED,
 165 
 166         /** Try statements, of type Try.
 167          */
 168         TRY,
 169 
 170         /** Catch clauses in try statements, of type Catch.
 171          */
 172         CATCH,
 173 
 174         /** Conditional expressions, of type Conditional.
 175          */
 176         CONDEXPR,
 177 
 178         /** Conditional statements, of type If.
 179          */
 180         IF,
 181 
 182         /** Expression statements, of type Exec.
 183          */
 184         EXEC,
 185 
 186         /** Break statements, of type Break.
 187          */
 188         BREAK,
 189 




 190         /** Continue statements, of type Continue.
 191          */
 192         CONTINUE,
 193 
 194         /** Return statements, of type Return.
 195          */
 196         RETURN,
 197 
 198         /** Throw statements, of type Throw.
 199          */
 200         THROW,
 201 
 202         /** Assert statements, of type Assert.
 203          */
 204         ASSERT,
 205 
 206         /** Method invocation expressions, of type Apply.
 207          */
 208         APPLY,
 209 
</pre>
<hr />
<pre>
 218         /** Lambda expression, of type Lambda.
 219          */
 220         LAMBDA,
 221 
 222         /** Parenthesized subexpressions, of type Parens.
 223          */
 224         PARENS,
 225 
 226         /** Assignment expressions, of type Assign.
 227          */
 228         ASSIGN,
 229 
 230         /** Type cast expressions, of type TypeCast.
 231          */
 232         TYPECAST,
 233 
 234         /** Type test expressions, of type TypeTest.
 235          */
 236         TYPETEST,
 237 




 238         /** Indexed array expressions, of type Indexed.
 239          */
 240         INDEXED,
 241 
 242         /** Selections, of type Select.
 243          */
 244         SELECT,
 245 
 246         /** Member references, of type Reference.
 247          */
 248         REFERENCE,
 249 
 250         /** Simple identifiers, of type Ident.
 251          */
 252         IDENT,
 253 
 254         /** Literals, of type Literal.
 255          */
 256         LITERAL,
 257 
</pre>
<hr />
<pre>
 762         public ClassSymbol sym;
 763         protected JCClassDecl(JCModifiers mods,
 764                            Name name,
 765                            List&lt;JCTypeParameter&gt; typarams,
 766                            JCExpression extending,
 767                            List&lt;JCExpression&gt; implementing,
 768                            List&lt;JCTree&gt; defs,
 769                            ClassSymbol sym)
 770         {
 771             this.mods = mods;
 772             this.name = name;
 773             this.typarams = typarams;
 774             this.extending = extending;
 775             this.implementing = implementing;
 776             this.defs = defs;
 777             this.sym = sym;
 778         }
 779         @Override
 780         public void accept(Visitor v) { v.visitClassDef(this); }
 781 

 782         @DefinedBy(Api.COMPILER_TREE)
 783         public Kind getKind() {
 784             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 785                 return Kind.ANNOTATION_TYPE;
 786             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 787                 return Kind.INTERFACE;
 788             else if ((mods.flags &amp; Flags.ENUM) != 0)
 789                 return Kind.ENUM;


 790             else
 791                 return Kind.CLASS;
 792         }
 793 
 794         @DefinedBy(Api.COMPILER_TREE)
 795         public JCModifiers getModifiers() { return mods; }
 796         @DefinedBy(Api.COMPILER_TREE)
 797         public Name getSimpleName() { return name; }
 798         @DefinedBy(Api.COMPILER_TREE)
 799         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 800             return typarams;
 801         }
 802         @DefinedBy(Api.COMPILER_TREE)
 803         public JCExpression getExtendsClause() { return extending; }
 804         @DefinedBy(Api.COMPILER_TREE)
 805         public List&lt;JCExpression&gt; getImplementsClause() {
 806             return implementing;
 807         }
 808         @DefinedBy(Api.COMPILER_TREE)
 809         public List&lt;JCTree&gt; getMembers() {
</pre>
<hr />
<pre>
 827         /** method modifiers */
 828         public JCModifiers mods;
 829         /** method name */
 830         public Name name;
 831         /** type of method return value */
 832         public JCExpression restype;
 833         /** type parameters */
 834         public List&lt;JCTypeParameter&gt; typarams;
 835         /** receiver parameter */
 836         public JCVariableDecl recvparam;
 837         /** value parameters */
 838         public List&lt;JCVariableDecl&gt; params;
 839         /** exceptions thrown by this method */
 840         public List&lt;JCExpression&gt; thrown;
 841         /** statements in the method */
 842         public JCBlock body;
 843         /** default value, for annotation types */
 844         public JCExpression defaultValue;
 845         /** method symbol */
 846         public MethodSymbol sym;



 847         protected JCMethodDecl(JCModifiers mods,
 848                             Name name,
 849                             JCExpression restype,
 850                             List&lt;JCTypeParameter&gt; typarams,
 851                             JCVariableDecl recvparam,
 852                             List&lt;JCVariableDecl&gt; params,
 853                             List&lt;JCExpression&gt; thrown,
 854                             JCBlock body,
 855                             JCExpression defaultValue,
 856                             MethodSymbol sym)
 857         {
 858             this.mods = mods;
 859             this.name = name;
 860             this.restype = restype;
 861             this.typarams = typarams;
 862             this.params = params;
 863             this.recvparam = recvparam;
 864             // TODO: do something special if the given type is null?
 865             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 866             this.thrown = thrown;
</pre>
<hr />
<pre>
1229         @DefinedBy(Api.COMPILER_TREE)
1230         public JCExpression getExpression() { return selector; }
1231         @DefinedBy(Api.COMPILER_TREE)
1232         public List&lt;JCCase&gt; getCases() { return cases; }
1233         @Override @DefinedBy(Api.COMPILER_TREE)
1234         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1235             return v.visitSwitch(this, d);
1236         }
1237         @Override
1238         public Tag getTag() {
1239             return SWITCH;
1240         }
1241     }
1242 
1243     /**
1244      * A &quot;case  :&quot; of a switch.
1245      */
1246     public static class JCCase extends JCStatement implements CaseTree {
1247         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1248         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
<span class="line-removed">1249         @SuppressWarnings(&quot;removal&quot;)</span>
1250         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
<span class="line-removed">1251         @SuppressWarnings(&quot;removal&quot;)</span>
1252         public static final CaseKind RULE = CaseKind.RULE;
<span class="line-removed">1253         @SuppressWarnings(&quot;removal&quot;)</span>
1254         public final CaseKind caseKind;
1255         public List&lt;JCExpression&gt; pats;
1256         public List&lt;JCStatement&gt; stats;
1257         public JCTree body;
1258         public boolean completesNormally;
<span class="line-modified">1259         protected JCCase(@SuppressWarnings(&quot;removal&quot;) CaseKind caseKind, List&lt;JCExpression&gt; pats,</span>
1260                          List&lt;JCStatement&gt; stats, JCTree body) {
1261             Assert.checkNonNull(pats);
1262             Assert.check(pats.isEmpty() || pats.head != null);
1263             this.caseKind = caseKind;
1264             this.pats = pats;
1265             this.stats = stats;
1266             this.body = body;
1267         }
1268         @Override
1269         public void accept(Visitor v) { v.visitCase(this); }
1270 
1271         @Override @DefinedBy(Api.COMPILER_TREE)
1272         public Kind getKind() { return Kind.CASE; }
<span class="line-modified">1273         @Override @DefinedBy(Api.COMPILER_TREE)</span>
1274         public JCExpression getExpression() { return pats.head; }
1275         @Override @DefinedBy(Api.COMPILER_TREE)
<span class="line-removed">1276         @SuppressWarnings(&quot;removal&quot;)</span>
1277         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1278         @Override @DefinedBy(Api.COMPILER_TREE)
<span class="line-removed">1279         @SuppressWarnings(&quot;removal&quot;)</span>
1280         public List&lt;JCStatement&gt; getStatements() {
1281             return caseKind == CaseKind.STATEMENT ? stats : null;
1282         }
1283         @Override @DefinedBy(Api.COMPILER_TREE)
<span class="line-removed">1284         @SuppressWarnings(&quot;removal&quot;)</span>
1285         public JCTree getBody() { return body; }
1286         @Override @DefinedBy(Api.COMPILER_TREE)
<span class="line-removed">1287         @SuppressWarnings(&quot;removal&quot;)</span>
1288         public CaseKind getCaseKind() {
1289             return caseKind;
1290         }
1291         @Override @DefinedBy(Api.COMPILER_TREE)
1292         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1293             return v.visitCase(this, d);
1294         }
1295         @Override
1296         public Tag getTag() {
1297             return CASE;
1298         }
1299     }
1300 
1301     /**
1302      * A &quot;switch ( ) { }&quot; construction.
1303      */
<span class="line-removed">1304     @SuppressWarnings(&quot;removal&quot;)</span>
1305     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1306         public JCExpression selector;
1307         public List&lt;JCCase&gt; cases;
1308         /** Position of closing brace, optional. */
1309         public int endpos = Position.NOPOS;
1310         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1311             this.selector = selector;
1312             this.cases = cases;
1313         }
1314         @Override
1315         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1316 
1317         @DefinedBy(Api.COMPILER_TREE)
1318         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1319         @DefinedBy(Api.COMPILER_TREE)
1320         public JCExpression getExpression() { return selector; }
1321         @DefinedBy(Api.COMPILER_TREE)
1322         public List&lt;JCCase&gt; getCases() { return cases; }
1323         @Override @DefinedBy(Api.COMPILER_TREE)
1324         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
</pre>
<hr />
<pre>
1534         /** Convert a expression-statement tree to a pretty-printed string. */
1535         @Override
1536         public String toString() {
1537             StringWriter s = new StringWriter();
1538             try {
1539                 new Pretty(s, false).printStat(this);
1540             }
1541             catch (IOException e) {
1542                 // should never happen, because StringWriter is defined
1543                 // never to throw any IOExceptions
1544                 throw new AssertionError(e);
1545             }
1546             return s.toString();
1547         }
1548     }
1549 
1550     /**
1551      * A break from a loop or switch.
1552      */
1553     public static class JCBreak extends JCStatement implements BreakTree {
<span class="line-modified">1554         public JCExpression value;</span>
1555         public JCTree target;
<span class="line-modified">1556         protected JCBreak(JCExpression value, JCTree target) {</span>
<span class="line-modified">1557             this.value = value;</span>
1558             this.target = target;
1559         }
1560         @Override
1561         public void accept(Visitor v) { v.visitBreak(this); }
1562         public boolean isValueBreak() {
1563             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1564         }
1565 
1566         @DefinedBy(Api.COMPILER_TREE)
1567         public Kind getKind() { return Kind.BREAK; }
1568         @DefinedBy(Api.COMPILER_TREE)
1569         public Name getLabel() {
<span class="line-modified">1570             return value != null &amp;&amp; value.getKind() == Kind.IDENTIFIER ? ((JCIdent) value).getName() : null;</span>
1571         }
<span class="line-removed">1572         @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-removed">1573         @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">1574         public JCExpression getValue() { return value; }</span>
1575         @Override @DefinedBy(Api.COMPILER_TREE)
1576         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1577             return v.visitBreak(this, d);
1578         }
1579         @Override
1580         public Tag getTag() {
1581             return BREAK;
1582         }
1583     }
1584 


























1585     /**
1586      * A continue of a loop.
1587      */
1588     public static class JCContinue extends JCStatement implements ContinueTree {
1589         public Name label;
1590         public JCTree target;
1591         protected JCContinue(Name label, JCTree target) {
1592             this.label = label;
1593             this.target = target;
1594         }
1595         @Override
1596         public void accept(Visitor v) { v.visitContinue(this); }
1597 
1598         @DefinedBy(Api.COMPILER_TREE)
1599         public Kind getKind() { return Kind.CONTINUE; }
1600         @DefinedBy(Api.COMPILER_TREE)
1601         public Name getLabel() { return label; }
1602         @Override @DefinedBy(Api.COMPILER_TREE)
1603         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1604             return v.visitContinue(this, d);
</pre>
<hr />
<pre>
2100         public Kind getKind() { return Kind.TYPE_CAST; }
2101         @DefinedBy(Api.COMPILER_TREE)
2102         public JCTree getType() { return clazz; }
2103         @DefinedBy(Api.COMPILER_TREE)
2104         public JCExpression getExpression() { return expr; }
2105         @Override @DefinedBy(Api.COMPILER_TREE)
2106         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2107             return v.visitTypeCast(this, d);
2108         }
2109         @Override
2110         public Tag getTag() {
2111             return TYPECAST;
2112         }
2113     }
2114 
2115     /**
2116      * A type test.
2117      */
2118     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2119         public JCExpression expr;
<span class="line-modified">2120         public JCTree clazz;</span>
<span class="line-modified">2121         protected JCInstanceOf(JCExpression expr, JCTree clazz) {</span>
2122             this.expr = expr;
<span class="line-modified">2123             this.clazz = clazz;</span>
2124         }
2125         @Override
2126         public void accept(Visitor v) { v.visitTypeTest(this); }
2127 
2128         @DefinedBy(Api.COMPILER_TREE)
2129         public Kind getKind() { return Kind.INSTANCE_OF; }
2130         @DefinedBy(Api.COMPILER_TREE)
<span class="line-modified">2131         public JCTree getType() { return clazz; }</span>






2132         @DefinedBy(Api.COMPILER_TREE)
2133         public JCExpression getExpression() { return expr; }
2134         @Override @DefinedBy(Api.COMPILER_TREE)
2135         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2136             return v.visitInstanceOf(this, d);
2137         }
2138         @Override
2139         public Tag getTag() {
2140             return TYPETEST;
2141         }
2142     }
2143 






















































2144     /**
2145      * An array selection
2146      */
2147     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2148         public JCExpression indexed;
2149         public JCExpression index;
2150         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2151             this.indexed = indexed;
2152             this.index = index;
2153         }
2154         @Override
2155         public void accept(Visitor v) { v.visitIndexed(this); }
2156 
2157         @DefinedBy(Api.COMPILER_TREE)
2158         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2159         @DefinedBy(Api.COMPILER_TREE)
2160         public JCExpression getExpression() { return indexed; }
2161         @DefinedBy(Api.COMPILER_TREE)
2162         public JCExpression getIndex() { return index; }
2163         @Override @DefinedBy(Api.COMPILER_TREE)
</pre>
<hr />
<pre>
3060                             List&lt;JCVariableDecl&gt; params,
3061                             List&lt;JCExpression&gt; thrown,
3062                             JCBlock body,
3063                             JCExpression defaultValue);
3064         JCVariableDecl VarDef(JCModifiers mods,
3065                       Name name,
3066                       JCExpression vartype,
3067                       JCExpression init);
3068         JCSkip Skip();
3069         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3070         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3071         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3072         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3073                         JCExpression cond,
3074                         List&lt;JCExpressionStatement&gt; step,
3075                         JCStatement body);
3076         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3077         JCLabeledStatement Labelled(Name label, JCStatement body);
3078         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3079         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
<span class="line-modified">3080         JCCase Case(@SuppressWarnings(&quot;removal&quot;) CaseKind caseKind, List&lt;JCExpression&gt; pat,</span>
3081                     List&lt;JCStatement&gt; stats, JCTree body);
3082         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3083         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3084         JCTry Try(List&lt;JCTree&gt; resources,
3085                   JCBlock body,
3086                   List&lt;JCCatch&gt; catchers,
3087                   JCBlock finalizer);
3088         JCCatch Catch(JCVariableDecl param, JCBlock body);
3089         JCConditional Conditional(JCExpression cond,
3090                                 JCExpression thenpart,
3091                                 JCExpression elsepart);
3092         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3093         JCExpressionStatement Exec(JCExpression expr);
<span class="line-modified">3094         JCBreak Break(JCExpression value);</span>

3095         JCContinue Continue(Name label);
3096         JCReturn Return(JCExpression expr);
3097         JCThrow Throw(JCExpression expr);
3098         JCAssert Assert(JCExpression cond, JCExpression detail);
3099         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3100                     JCExpression fn,
3101                     List&lt;JCExpression&gt; args);
3102         JCNewClass NewClass(JCExpression encl,
3103                           List&lt;JCExpression&gt; typeargs,
3104                           JCExpression clazz,
3105                           List&lt;JCExpression&gt; args,
3106                           JCClassDecl def);
3107         JCNewArray NewArray(JCExpression elemtype,
3108                           List&lt;JCExpression&gt; dims,
3109                           List&lt;JCExpression&gt; elems);
3110         JCParens Parens(JCExpression expr);
3111         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3112         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3113         JCUnary Unary(Tag opcode, JCExpression arg);
3114         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3115         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3116         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);

3117         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3118         JCFieldAccess Select(JCExpression selected, Name selector);
3119         JCIdent Ident(Name idname);
3120         JCLiteral Literal(TypeTag tag, Object value);
3121         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3122         JCArrayTypeTree TypeArray(JCExpression elemtype);
3123         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3124         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3125         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3126         TypeBoundKind TypeBoundKind(BoundKind kind);
3127         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3128         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3129         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3130         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3131         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3132         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3133         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3134         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3135         JCUses Uses(JCExpression qualId);
3136         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);
</pre>
<hr />
<pre>
3145         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3146         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3147         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3148         public void visitSkip(JCSkip that)                   { visitTree(that); }
3149         public void visitBlock(JCBlock that)                 { visitTree(that); }
3150         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3151         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3152         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3153         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3154         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3155         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3156         public void visitCase(JCCase that)                   { visitTree(that); }
3157         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3158         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3159         public void visitTry(JCTry that)                     { visitTree(that); }
3160         public void visitCatch(JCCatch that)                 { visitTree(that); }
3161         public void visitConditional(JCConditional that)     { visitTree(that); }
3162         public void visitIf(JCIf that)                       { visitTree(that); }
3163         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3164         public void visitBreak(JCBreak that)                 { visitTree(that); }

3165         public void visitContinue(JCContinue that)           { visitTree(that); }
3166         public void visitReturn(JCReturn that)               { visitTree(that); }
3167         public void visitThrow(JCThrow that)                 { visitTree(that); }
3168         public void visitAssert(JCAssert that)               { visitTree(that); }
3169         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3170         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3171         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3172         public void visitLambda(JCLambda that)               { visitTree(that); }
3173         public void visitParens(JCParens that)               { visitTree(that); }
3174         public void visitAssign(JCAssign that)               { visitTree(that); }
3175         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3176         public void visitUnary(JCUnary that)                 { visitTree(that); }
3177         public void visitBinary(JCBinary that)               { visitTree(that); }
3178         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3179         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }

3180         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3181         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3182         public void visitReference(JCMemberReference that)   { visitTree(that); }
3183         public void visitIdent(JCIdent that)                 { visitTree(that); }
3184         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3185         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3186         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3187         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3188         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3189         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3190         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3191         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3192         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3193         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3194         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3195         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3196         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3197         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3198         public void visitExports(JCExports that)             { visitTree(that); }
3199         public void visitOpens(JCOpens that)                 { visitTree(that); }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 

  50 import com.sun.source.tree.ModuleTree.ModuleKind;
  51 import com.sun.tools.javac.code.Directive.ExportsDirective;
  52 import com.sun.tools.javac.code.Directive.OpensDirective;
  53 import com.sun.tools.javac.code.Type.ModuleType;

  54 
  55 /**
  56  * Root class for abstract syntax tree nodes. It provides definitions
  57  * for specific tree nodes as subclasses nested inside.
  58  *
  59  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  60  * only tree fields for the syntactic subcomponents of the node.  Some
  61  * classes that represent identifier uses or definitions also define a
  62  * Symbol field that denotes the represented identifier.  Classes for
  63  * non-local jumps also carry the jump target as a field.  The root
  64  * class Tree itself defines fields for the tree&#39;s type and position.
  65  * No other fields are kept in a tree node; instead parameters are
  66  * passed to methods accessing the node.
  67  *
  68  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  69  * method defined in subclasses is `visit&#39; which applies a given
  70  * visitor to the tree. The actual tree processing is done by visitor
  71  * classes in other packages. The abstract class Visitor, as well as
  72  * an Factory interface for trees, are defined as inner classes in
  73  * Tree.
</pre>
<hr />
<pre>
 140         /** Foreach-loops, of type ForeachLoop.
 141          */
 142         FOREACHLOOP,
 143 
 144         /** Labelled statements, of type Labelled.
 145          */
 146         LABELLED,
 147 
 148         /** Switch statements, of type Switch.
 149          */
 150         SWITCH,
 151 
 152         /** Case parts in switch statements/expressions, of type Case.
 153          */
 154         CASE,
 155 
 156         /** Switch expression statements, of type Switch.
 157          */
 158         SWITCH_EXPRESSION,
 159 
<span class="line-modified"> 160         /** Synchronized statements, of type Synchronized.</span>
 161          */
 162         SYNCHRONIZED,
 163 
 164         /** Try statements, of type Try.
 165          */
 166         TRY,
 167 
 168         /** Catch clauses in try statements, of type Catch.
 169          */
 170         CATCH,
 171 
 172         /** Conditional expressions, of type Conditional.
 173          */
 174         CONDEXPR,
 175 
 176         /** Conditional statements, of type If.
 177          */
 178         IF,
 179 
 180         /** Expression statements, of type Exec.
 181          */
 182         EXEC,
 183 
 184         /** Break statements, of type Break.
 185          */
 186         BREAK,
 187 
<span class="line-added"> 188         /** Yield statements, of type Yield.</span>
<span class="line-added"> 189          */</span>
<span class="line-added"> 190         YIELD,</span>
<span class="line-added"> 191 </span>
 192         /** Continue statements, of type Continue.
 193          */
 194         CONTINUE,
 195 
 196         /** Return statements, of type Return.
 197          */
 198         RETURN,
 199 
 200         /** Throw statements, of type Throw.
 201          */
 202         THROW,
 203 
 204         /** Assert statements, of type Assert.
 205          */
 206         ASSERT,
 207 
 208         /** Method invocation expressions, of type Apply.
 209          */
 210         APPLY,
 211 
</pre>
<hr />
<pre>
 220         /** Lambda expression, of type Lambda.
 221          */
 222         LAMBDA,
 223 
 224         /** Parenthesized subexpressions, of type Parens.
 225          */
 226         PARENS,
 227 
 228         /** Assignment expressions, of type Assign.
 229          */
 230         ASSIGN,
 231 
 232         /** Type cast expressions, of type TypeCast.
 233          */
 234         TYPECAST,
 235 
 236         /** Type test expressions, of type TypeTest.
 237          */
 238         TYPETEST,
 239 
<span class="line-added"> 240         /** Patterns.</span>
<span class="line-added"> 241          */</span>
<span class="line-added"> 242         BINDINGPATTERN,</span>
<span class="line-added"> 243 </span>
 244         /** Indexed array expressions, of type Indexed.
 245          */
 246         INDEXED,
 247 
 248         /** Selections, of type Select.
 249          */
 250         SELECT,
 251 
 252         /** Member references, of type Reference.
 253          */
 254         REFERENCE,
 255 
 256         /** Simple identifiers, of type Ident.
 257          */
 258         IDENT,
 259 
 260         /** Literals, of type Literal.
 261          */
 262         LITERAL,
 263 
</pre>
<hr />
<pre>
 768         public ClassSymbol sym;
 769         protected JCClassDecl(JCModifiers mods,
 770                            Name name,
 771                            List&lt;JCTypeParameter&gt; typarams,
 772                            JCExpression extending,
 773                            List&lt;JCExpression&gt; implementing,
 774                            List&lt;JCTree&gt; defs,
 775                            ClassSymbol sym)
 776         {
 777             this.mods = mods;
 778             this.name = name;
 779             this.typarams = typarams;
 780             this.extending = extending;
 781             this.implementing = implementing;
 782             this.defs = defs;
 783             this.sym = sym;
 784         }
 785         @Override
 786         public void accept(Visitor v) { v.visitClassDef(this); }
 787 
<span class="line-added"> 788         @SuppressWarnings(&quot;preview&quot;)</span>
 789         @DefinedBy(Api.COMPILER_TREE)
 790         public Kind getKind() {
 791             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 792                 return Kind.ANNOTATION_TYPE;
 793             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 794                 return Kind.INTERFACE;
 795             else if ((mods.flags &amp; Flags.ENUM) != 0)
 796                 return Kind.ENUM;
<span class="line-added"> 797             else if ((mods.flags &amp; Flags.RECORD) != 0)</span>
<span class="line-added"> 798                 return Kind.RECORD;</span>
 799             else
 800                 return Kind.CLASS;
 801         }
 802 
 803         @DefinedBy(Api.COMPILER_TREE)
 804         public JCModifiers getModifiers() { return mods; }
 805         @DefinedBy(Api.COMPILER_TREE)
 806         public Name getSimpleName() { return name; }
 807         @DefinedBy(Api.COMPILER_TREE)
 808         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 809             return typarams;
 810         }
 811         @DefinedBy(Api.COMPILER_TREE)
 812         public JCExpression getExtendsClause() { return extending; }
 813         @DefinedBy(Api.COMPILER_TREE)
 814         public List&lt;JCExpression&gt; getImplementsClause() {
 815             return implementing;
 816         }
 817         @DefinedBy(Api.COMPILER_TREE)
 818         public List&lt;JCTree&gt; getMembers() {
</pre>
<hr />
<pre>
 836         /** method modifiers */
 837         public JCModifiers mods;
 838         /** method name */
 839         public Name name;
 840         /** type of method return value */
 841         public JCExpression restype;
 842         /** type parameters */
 843         public List&lt;JCTypeParameter&gt; typarams;
 844         /** receiver parameter */
 845         public JCVariableDecl recvparam;
 846         /** value parameters */
 847         public List&lt;JCVariableDecl&gt; params;
 848         /** exceptions thrown by this method */
 849         public List&lt;JCExpression&gt; thrown;
 850         /** statements in the method */
 851         public JCBlock body;
 852         /** default value, for annotation types */
 853         public JCExpression defaultValue;
 854         /** method symbol */
 855         public MethodSymbol sym;
<span class="line-added"> 856         /** does this method completes normally */</span>
<span class="line-added"> 857         public boolean completesNormally;</span>
<span class="line-added"> 858 </span>
 859         protected JCMethodDecl(JCModifiers mods,
 860                             Name name,
 861                             JCExpression restype,
 862                             List&lt;JCTypeParameter&gt; typarams,
 863                             JCVariableDecl recvparam,
 864                             List&lt;JCVariableDecl&gt; params,
 865                             List&lt;JCExpression&gt; thrown,
 866                             JCBlock body,
 867                             JCExpression defaultValue,
 868                             MethodSymbol sym)
 869         {
 870             this.mods = mods;
 871             this.name = name;
 872             this.restype = restype;
 873             this.typarams = typarams;
 874             this.params = params;
 875             this.recvparam = recvparam;
 876             // TODO: do something special if the given type is null?
 877             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 878             this.thrown = thrown;
</pre>
<hr />
<pre>
1241         @DefinedBy(Api.COMPILER_TREE)
1242         public JCExpression getExpression() { return selector; }
1243         @DefinedBy(Api.COMPILER_TREE)
1244         public List&lt;JCCase&gt; getCases() { return cases; }
1245         @Override @DefinedBy(Api.COMPILER_TREE)
1246         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1247             return v.visitSwitch(this, d);
1248         }
1249         @Override
1250         public Tag getTag() {
1251             return SWITCH;
1252         }
1253     }
1254 
1255     /**
1256      * A &quot;case  :&quot; of a switch.
1257      */
1258     public static class JCCase extends JCStatement implements CaseTree {
1259         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1260         //using indirection through these fields to avoid unnecessary @SuppressWarnings:

1261         public static final CaseKind STATEMENT = CaseKind.STATEMENT;

1262         public static final CaseKind RULE = CaseKind.RULE;

1263         public final CaseKind caseKind;
1264         public List&lt;JCExpression&gt; pats;
1265         public List&lt;JCStatement&gt; stats;
1266         public JCTree body;
1267         public boolean completesNormally;
<span class="line-modified">1268         protected JCCase(CaseKind caseKind, List&lt;JCExpression&gt; pats,</span>
1269                          List&lt;JCStatement&gt; stats, JCTree body) {
1270             Assert.checkNonNull(pats);
1271             Assert.check(pats.isEmpty() || pats.head != null);
1272             this.caseKind = caseKind;
1273             this.pats = pats;
1274             this.stats = stats;
1275             this.body = body;
1276         }
1277         @Override
1278         public void accept(Visitor v) { v.visitCase(this); }
1279 
1280         @Override @DefinedBy(Api.COMPILER_TREE)
1281         public Kind getKind() { return Kind.CASE; }
<span class="line-modified">1282         @Override @Deprecated @DefinedBy(Api.COMPILER_TREE)</span>
1283         public JCExpression getExpression() { return pats.head; }
1284         @Override @DefinedBy(Api.COMPILER_TREE)

1285         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1286         @Override @DefinedBy(Api.COMPILER_TREE)

1287         public List&lt;JCStatement&gt; getStatements() {
1288             return caseKind == CaseKind.STATEMENT ? stats : null;
1289         }
1290         @Override @DefinedBy(Api.COMPILER_TREE)

1291         public JCTree getBody() { return body; }
1292         @Override @DefinedBy(Api.COMPILER_TREE)

1293         public CaseKind getCaseKind() {
1294             return caseKind;
1295         }
1296         @Override @DefinedBy(Api.COMPILER_TREE)
1297         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1298             return v.visitCase(this, d);
1299         }
1300         @Override
1301         public Tag getTag() {
1302             return CASE;
1303         }
1304     }
1305 
1306     /**
1307      * A &quot;switch ( ) { }&quot; construction.
1308      */

1309     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1310         public JCExpression selector;
1311         public List&lt;JCCase&gt; cases;
1312         /** Position of closing brace, optional. */
1313         public int endpos = Position.NOPOS;
1314         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1315             this.selector = selector;
1316             this.cases = cases;
1317         }
1318         @Override
1319         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1320 
1321         @DefinedBy(Api.COMPILER_TREE)
1322         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1323         @DefinedBy(Api.COMPILER_TREE)
1324         public JCExpression getExpression() { return selector; }
1325         @DefinedBy(Api.COMPILER_TREE)
1326         public List&lt;JCCase&gt; getCases() { return cases; }
1327         @Override @DefinedBy(Api.COMPILER_TREE)
1328         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
</pre>
<hr />
<pre>
1538         /** Convert a expression-statement tree to a pretty-printed string. */
1539         @Override
1540         public String toString() {
1541             StringWriter s = new StringWriter();
1542             try {
1543                 new Pretty(s, false).printStat(this);
1544             }
1545             catch (IOException e) {
1546                 // should never happen, because StringWriter is defined
1547                 // never to throw any IOExceptions
1548                 throw new AssertionError(e);
1549             }
1550             return s.toString();
1551         }
1552     }
1553 
1554     /**
1555      * A break from a loop or switch.
1556      */
1557     public static class JCBreak extends JCStatement implements BreakTree {
<span class="line-modified">1558         public Name label;</span>
1559         public JCTree target;
<span class="line-modified">1560         protected JCBreak(Name label, JCTree target) {</span>
<span class="line-modified">1561             this.label = label;</span>
1562             this.target = target;
1563         }
1564         @Override
1565         public void accept(Visitor v) { v.visitBreak(this); }
1566         public boolean isValueBreak() {
1567             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1568         }
1569 
1570         @DefinedBy(Api.COMPILER_TREE)
1571         public Kind getKind() { return Kind.BREAK; }
1572         @DefinedBy(Api.COMPILER_TREE)
1573         public Name getLabel() {
<span class="line-modified">1574             return label;</span>
1575         }



1576         @Override @DefinedBy(Api.COMPILER_TREE)
1577         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1578             return v.visitBreak(this, d);
1579         }
1580         @Override
1581         public Tag getTag() {
1582             return BREAK;
1583         }
1584     }
1585 
<span class="line-added">1586     /**</span>
<span class="line-added">1587      * A break-with from a switch expression.</span>
<span class="line-added">1588      */</span>
<span class="line-added">1589     public static class JCYield extends JCStatement implements YieldTree {</span>
<span class="line-added">1590         public JCExpression value;</span>
<span class="line-added">1591         public JCTree target;</span>
<span class="line-added">1592         protected JCYield(JCExpression value, JCTree target) {</span>
<span class="line-added">1593             this.value = value;</span>
<span class="line-added">1594             this.target = target;</span>
<span class="line-added">1595         }</span>
<span class="line-added">1596         @Override</span>
<span class="line-added">1597         public void accept(Visitor v) { v.visitYield(this); }</span>
<span class="line-added">1598         @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">1599         public Kind getKind() { return Kind.YIELD; }</span>
<span class="line-added">1600         @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">1601         public JCExpression getValue() { return value; }</span>
<span class="line-added">1602         @Override @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">1603         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {</span>
<span class="line-added">1604             return v.visitYield(this, d);</span>
<span class="line-added">1605         }</span>
<span class="line-added">1606         @Override</span>
<span class="line-added">1607         public Tag getTag() {</span>
<span class="line-added">1608             return YIELD;</span>
<span class="line-added">1609         }</span>
<span class="line-added">1610     }</span>
<span class="line-added">1611 </span>
1612     /**
1613      * A continue of a loop.
1614      */
1615     public static class JCContinue extends JCStatement implements ContinueTree {
1616         public Name label;
1617         public JCTree target;
1618         protected JCContinue(Name label, JCTree target) {
1619             this.label = label;
1620             this.target = target;
1621         }
1622         @Override
1623         public void accept(Visitor v) { v.visitContinue(this); }
1624 
1625         @DefinedBy(Api.COMPILER_TREE)
1626         public Kind getKind() { return Kind.CONTINUE; }
1627         @DefinedBy(Api.COMPILER_TREE)
1628         public Name getLabel() { return label; }
1629         @Override @DefinedBy(Api.COMPILER_TREE)
1630         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1631             return v.visitContinue(this, d);
</pre>
<hr />
<pre>
2127         public Kind getKind() { return Kind.TYPE_CAST; }
2128         @DefinedBy(Api.COMPILER_TREE)
2129         public JCTree getType() { return clazz; }
2130         @DefinedBy(Api.COMPILER_TREE)
2131         public JCExpression getExpression() { return expr; }
2132         @Override @DefinedBy(Api.COMPILER_TREE)
2133         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2134             return v.visitTypeCast(this, d);
2135         }
2136         @Override
2137         public Tag getTag() {
2138             return TYPECAST;
2139         }
2140     }
2141 
2142     /**
2143      * A type test.
2144      */
2145     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2146         public JCExpression expr;
<span class="line-modified">2147         public JCTree pattern;</span>
<span class="line-modified">2148         protected JCInstanceOf(JCExpression expr, JCTree pattern) {</span>
2149             this.expr = expr;
<span class="line-modified">2150             this.pattern = pattern;</span>
2151         }
2152         @Override
2153         public void accept(Visitor v) { v.visitTypeTest(this); }
2154 
2155         @DefinedBy(Api.COMPILER_TREE)
2156         public Kind getKind() { return Kind.INSTANCE_OF; }
2157         @DefinedBy(Api.COMPILER_TREE)
<span class="line-modified">2158         public JCTree getType() { return pattern instanceof JCPattern ? pattern.hasTag(BINDINGPATTERN) ? ((JCBindingPattern) pattern).vartype : null : pattern; }</span>
<span class="line-added">2159 </span>
<span class="line-added">2160         @Override @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">2161         public JCPattern getPattern() {</span>
<span class="line-added">2162             return pattern instanceof JCPattern ? (JCPattern) pattern : null;</span>
<span class="line-added">2163         }</span>
<span class="line-added">2164 </span>
2165         @DefinedBy(Api.COMPILER_TREE)
2166         public JCExpression getExpression() { return expr; }
2167         @Override @DefinedBy(Api.COMPILER_TREE)
2168         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2169             return v.visitInstanceOf(this, d);
2170         }
2171         @Override
2172         public Tag getTag() {
2173             return TYPETEST;
2174         }
2175     }
2176 
<span class="line-added">2177     /**</span>
<span class="line-added">2178      * Pattern matching forms.</span>
<span class="line-added">2179      */</span>
<span class="line-added">2180     public static abstract class JCPattern extends JCTree</span>
<span class="line-added">2181             implements PatternTree {</span>
<span class="line-added">2182         public JCExpression constExpression() {</span>
<span class="line-added">2183             return null;</span>
<span class="line-added">2184         }</span>
<span class="line-added">2185     }</span>
<span class="line-added">2186 </span>
<span class="line-added">2187     public static class JCBindingPattern extends JCPattern</span>
<span class="line-added">2188             implements BindingPatternTree {</span>
<span class="line-added">2189         public Name name;</span>
<span class="line-added">2190         public BindingSymbol symbol;</span>
<span class="line-added">2191         public JCTree vartype;</span>
<span class="line-added">2192 </span>
<span class="line-added">2193         protected JCBindingPattern(Name name, BindingSymbol symbol, JCTree vartype) {</span>
<span class="line-added">2194             this.name = name;</span>
<span class="line-added">2195             this.symbol = symbol;</span>
<span class="line-added">2196             this.vartype = vartype;</span>
<span class="line-added">2197         }</span>
<span class="line-added">2198 </span>
<span class="line-added">2199         @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">2200         public Name getBinding() {</span>
<span class="line-added">2201             return name;</span>
<span class="line-added">2202         }</span>
<span class="line-added">2203 </span>
<span class="line-added">2204         @Override @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">2205         public Tree getType() {</span>
<span class="line-added">2206             return vartype;</span>
<span class="line-added">2207         }</span>
<span class="line-added">2208 </span>
<span class="line-added">2209         @Override</span>
<span class="line-added">2210         public void accept(Visitor v) {</span>
<span class="line-added">2211             v.visitBindingPattern(this);</span>
<span class="line-added">2212         }</span>
<span class="line-added">2213 </span>
<span class="line-added">2214         @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">2215         public Kind getKind() {</span>
<span class="line-added">2216             return Kind.BINDING_PATTERN;</span>
<span class="line-added">2217         }</span>
<span class="line-added">2218 </span>
<span class="line-added">2219         @Override</span>
<span class="line-added">2220         @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">2221         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {</span>
<span class="line-added">2222             return v.visitBindingPattern(this, d);</span>
<span class="line-added">2223         }</span>
<span class="line-added">2224 </span>
<span class="line-added">2225         @Override</span>
<span class="line-added">2226         public Tag getTag() {</span>
<span class="line-added">2227             return BINDINGPATTERN;</span>
<span class="line-added">2228         }</span>
<span class="line-added">2229     }</span>
<span class="line-added">2230 </span>
2231     /**
2232      * An array selection
2233      */
2234     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2235         public JCExpression indexed;
2236         public JCExpression index;
2237         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2238             this.indexed = indexed;
2239             this.index = index;
2240         }
2241         @Override
2242         public void accept(Visitor v) { v.visitIndexed(this); }
2243 
2244         @DefinedBy(Api.COMPILER_TREE)
2245         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2246         @DefinedBy(Api.COMPILER_TREE)
2247         public JCExpression getExpression() { return indexed; }
2248         @DefinedBy(Api.COMPILER_TREE)
2249         public JCExpression getIndex() { return index; }
2250         @Override @DefinedBy(Api.COMPILER_TREE)
</pre>
<hr />
<pre>
3147                             List&lt;JCVariableDecl&gt; params,
3148                             List&lt;JCExpression&gt; thrown,
3149                             JCBlock body,
3150                             JCExpression defaultValue);
3151         JCVariableDecl VarDef(JCModifiers mods,
3152                       Name name,
3153                       JCExpression vartype,
3154                       JCExpression init);
3155         JCSkip Skip();
3156         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3157         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3158         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3159         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3160                         JCExpression cond,
3161                         List&lt;JCExpressionStatement&gt; step,
3162                         JCStatement body);
3163         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3164         JCLabeledStatement Labelled(Name label, JCStatement body);
3165         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3166         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
<span class="line-modified">3167         JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pat,</span>
3168                     List&lt;JCStatement&gt; stats, JCTree body);
3169         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3170         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3171         JCTry Try(List&lt;JCTree&gt; resources,
3172                   JCBlock body,
3173                   List&lt;JCCatch&gt; catchers,
3174                   JCBlock finalizer);
3175         JCCatch Catch(JCVariableDecl param, JCBlock body);
3176         JCConditional Conditional(JCExpression cond,
3177                                 JCExpression thenpart,
3178                                 JCExpression elsepart);
3179         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3180         JCExpressionStatement Exec(JCExpression expr);
<span class="line-modified">3181         JCBreak Break(Name label);</span>
<span class="line-added">3182         JCYield Yield(JCExpression value);</span>
3183         JCContinue Continue(Name label);
3184         JCReturn Return(JCExpression expr);
3185         JCThrow Throw(JCExpression expr);
3186         JCAssert Assert(JCExpression cond, JCExpression detail);
3187         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3188                     JCExpression fn,
3189                     List&lt;JCExpression&gt; args);
3190         JCNewClass NewClass(JCExpression encl,
3191                           List&lt;JCExpression&gt; typeargs,
3192                           JCExpression clazz,
3193                           List&lt;JCExpression&gt; args,
3194                           JCClassDecl def);
3195         JCNewArray NewArray(JCExpression elemtype,
3196                           List&lt;JCExpression&gt; dims,
3197                           List&lt;JCExpression&gt; elems);
3198         JCParens Parens(JCExpression expr);
3199         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3200         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3201         JCUnary Unary(Tag opcode, JCExpression arg);
3202         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3203         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3204         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
<span class="line-added">3205         JCBindingPattern BindingPattern(Name name, JCTree vartype);</span>
3206         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3207         JCFieldAccess Select(JCExpression selected, Name selector);
3208         JCIdent Ident(Name idname);
3209         JCLiteral Literal(TypeTag tag, Object value);
3210         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3211         JCArrayTypeTree TypeArray(JCExpression elemtype);
3212         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3213         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3214         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3215         TypeBoundKind TypeBoundKind(BoundKind kind);
3216         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3217         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3218         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3219         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3220         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3221         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3222         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3223         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3224         JCUses Uses(JCExpression qualId);
3225         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);
</pre>
<hr />
<pre>
3234         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3235         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3236         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3237         public void visitSkip(JCSkip that)                   { visitTree(that); }
3238         public void visitBlock(JCBlock that)                 { visitTree(that); }
3239         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3240         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3241         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3242         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3243         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3244         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3245         public void visitCase(JCCase that)                   { visitTree(that); }
3246         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3247         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3248         public void visitTry(JCTry that)                     { visitTree(that); }
3249         public void visitCatch(JCCatch that)                 { visitTree(that); }
3250         public void visitConditional(JCConditional that)     { visitTree(that); }
3251         public void visitIf(JCIf that)                       { visitTree(that); }
3252         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3253         public void visitBreak(JCBreak that)                 { visitTree(that); }
<span class="line-added">3254         public void visitYield(JCYield that)                 { visitTree(that); }</span>
3255         public void visitContinue(JCContinue that)           { visitTree(that); }
3256         public void visitReturn(JCReturn that)               { visitTree(that); }
3257         public void visitThrow(JCThrow that)                 { visitTree(that); }
3258         public void visitAssert(JCAssert that)               { visitTree(that); }
3259         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3260         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3261         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3262         public void visitLambda(JCLambda that)               { visitTree(that); }
3263         public void visitParens(JCParens that)               { visitTree(that); }
3264         public void visitAssign(JCAssign that)               { visitTree(that); }
3265         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3266         public void visitUnary(JCUnary that)                 { visitTree(that); }
3267         public void visitBinary(JCBinary that)               { visitTree(that); }
3268         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3269         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
<span class="line-added">3270         public void visitBindingPattern(JCBindingPattern that) { visitTree(that); }</span>
3271         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3272         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3273         public void visitReference(JCMemberReference that)   { visitTree(that); }
3274         public void visitIdent(JCIdent that)                 { visitTree(that); }
3275         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3276         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3277         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3278         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3279         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3280         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3281         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3282         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3283         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3284         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3285         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3286         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3287         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3288         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3289         public void visitExports(JCExports that)             { visitTree(that); }
3290         public void visitOpens(JCOpens that)                 { visitTree(that); }
</pre>
</td>
</tr>
</table>
<center><a href="DocTreeMaker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pretty.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassWriter.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Gen.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,21 +25,34 @@</span>
  
  package com.sun.tools.javac.jvm;
  
  import com.sun.tools.javac.code.*;
  import com.sun.tools.javac.code.Symbol.*;
<span class="udiff-line-removed">- import com.sun.tools.javac.code.Types.UniqueType;</span>
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
<span class="udiff-line-removed">- import com.sun.tools.javac.tree.JCTree;</span>
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  
<span class="udiff-line-added">+ import java.util.function.ToIntBiFunction;</span>
<span class="udiff-line-added">+ import java.util.function.ToIntFunction;</span>
<span class="udiff-line-added">+ </span>
  import static com.sun.tools.javac.code.TypeTag.BOT;
  import static com.sun.tools.javac.code.TypeTag.INT;
  import static com.sun.tools.javac.jvm.ByteCodes.*;
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Class;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Double;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Fieldref;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Float;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Integer;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_InterfaceMethodref;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Long;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodHandle;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodType;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Methodref;</span>
<span class="udiff-line-added">+ import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_String;</span>
  import static com.sun.tools.javac.jvm.UninitializedType.*;
  import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableFrame;
<span class="udiff-line-added">+ import java.util.Arrays;</span>
  
  /** An internal structure that corresponds to the code attribute of
   *  methods in a classfile. The class also provides some utility operations to
   *  generate bytecode instructions.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -70,10 +83,11 @@</span>
          }
      }
  
      final Types types;
      final Symtab syms;
<span class="udiff-line-added">+     final PoolWriter poolWriter;</span>
  
  /*---------- classfile fields: --------------- */
  
      /** The maximum stack size.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -175,14 +189,10 @@</span>
  
      /** Emit line number info if map supplied
       */
      Position.LineMap lineMap;
  
<span class="udiff-line-removed">-     /** The constant pool of the current class.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     final Pool pool;</span>
<span class="udiff-line-removed">- </span>
      final MethodSymbol meth;
  
      private int letExprStackPos = 0;
  
      /** Construct a code object, given the settings of the fatcode,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -195,19 +205,20 @@</span>
                  StackMapFormat stackMap,
                  boolean debugCode,
                  CRTable crt,
                  Symtab syms,
                  Types types,
<span class="udiff-line-modified-removed">-                 Pool pool) {</span>
<span class="udiff-line-modified-added">+                 PoolWriter poolWriter) {</span>
          this.meth = meth;
          this.fatcode = fatcode;
          this.lineMap = lineMap;
          this.lineDebugInfo = lineMap != null;
          this.varDebugInfo = varDebugInfo;
          this.crt = crt;
          this.syms = syms;
          this.types = types;
<span class="udiff-line-added">+         this.poolWriter = poolWriter;</span>
          this.debugCode = debugCode;
          this.stackMap = stackMap;
          switch (stackMap) {
          case CLDC:
          case JSR202:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -216,11 +227,10 @@</span>
          default:
              this.needStackMap = false;
          }
          state = new State();
          lvar = new LocalVar[20];
<span class="udiff-line-removed">-         this.pool = pool;</span>
      }
  
  
  /* **************************************************************************
   * Typecodes &amp; related stuff
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -387,16 +397,17 @@</span>
          Assert.check(alive || isStatementStart());
      }
  
      /** Emit a ldc (or ldc_w) instruction, taking into account operand size
      */
<span class="udiff-line-modified-removed">-     public void emitLdc(int od) {</span>
<span class="udiff-line-modified-added">+     public void emitLdc(LoadableConstant constant) {</span>
<span class="udiff-line-added">+         int od = poolWriter.putConstant(constant);</span>
          if (od &lt;= 255) {
<span class="udiff-line-modified-removed">-             emitop1(ldc1, od);</span>
<span class="udiff-line-modified-added">+             emitop1(ldc1, od, constant);</span>
          }
          else {
<span class="udiff-line-modified-removed">-             emitop2(ldc2, od);</span>
<span class="udiff-line-modified-added">+             emitop2(ldc2, od, constant);</span>
          }
      }
  
      /** Emit a multinewarray instruction.
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -429,65 +440,64 @@</span>
          state.push(arrayType);
      }
  
      /** Emit an invokeinterface instruction.
       */
<span class="udiff-line-modified-removed">-     public void emitInvokeinterface(int meth, Type mtype) {</span>
<span class="udiff-line-modified-added">+     public void emitInvokeinterface(Symbol member, Type mtype) {</span>
          int argsize = width(mtype.getParameterTypes());
          emitop(invokeinterface);
          if (!alive) return;
<span class="udiff-line-modified-removed">-         emit2(meth);</span>
<span class="udiff-line-modified-added">+         emit2(poolWriter.putMember(member));</span>
          emit1(argsize + 1);
          emit1(0);
          state.pop(argsize + 1);
          state.push(mtype.getReturnType());
      }
  
      /** Emit an invokespecial instruction.
       */
<span class="udiff-line-modified-removed">-     public void emitInvokespecial(int meth, Type mtype) {</span>
<span class="udiff-line-modified-added">+     public void emitInvokespecial(Symbol member, Type mtype) {</span>
          int argsize = width(mtype.getParameterTypes());
          emitop(invokespecial);
          if (!alive) return;
<span class="udiff-line-modified-removed">-         emit2(meth);</span>
<span class="udiff-line-removed">-         Symbol sym = (Symbol)pool.pool[meth];</span>
<span class="udiff-line-modified-added">+         emit2(poolWriter.putMember(member));</span>
          state.pop(argsize);
<span class="udiff-line-modified-removed">-         if (sym.isConstructor())</span>
<span class="udiff-line-modified-added">+         if (member.isConstructor())</span>
              state.markInitialized((UninitializedType)state.peek());
          state.pop(1);
          state.push(mtype.getReturnType());
      }
  
      /** Emit an invokestatic instruction.
       */
<span class="udiff-line-modified-removed">-     public void emitInvokestatic(int meth, Type mtype) {</span>
<span class="udiff-line-modified-added">+     public void emitInvokestatic(Symbol member, Type mtype) {</span>
          int argsize = width(mtype.getParameterTypes());
          emitop(invokestatic);
          if (!alive) return;
<span class="udiff-line-modified-removed">-         emit2(meth);</span>
<span class="udiff-line-modified-added">+         emit2(poolWriter.putMember(member));</span>
          state.pop(argsize);
          state.push(mtype.getReturnType());
      }
  
      /** Emit an invokevirtual instruction.
       */
<span class="udiff-line-modified-removed">-     public void emitInvokevirtual(int meth, Type mtype) {</span>
<span class="udiff-line-modified-added">+     public void emitInvokevirtual(Symbol member, Type mtype) {</span>
          int argsize = width(mtype.getParameterTypes());
          emitop(invokevirtual);
          if (!alive) return;
<span class="udiff-line-modified-removed">-         emit2(meth);</span>
<span class="udiff-line-modified-added">+         emit2(poolWriter.putMember(member));</span>
          state.pop(argsize + 1);
          state.push(mtype.getReturnType());
      }
  
      /** Emit an invokedynamic instruction.
       */
<span class="udiff-line-modified-removed">-     public void emitInvokedynamic(int desc, Type mtype) {</span>
<span class="udiff-line-modified-added">+     public void emitInvokedynamic(DynamicMethodSymbol dynMember, Type mtype) {</span>
          int argsize = width(mtype.getParameterTypes());
          emitop(invokedynamic);
          if (!alive) return;
<span class="udiff-line-modified-removed">-         emit2(desc);</span>
<span class="udiff-line-modified-added">+         emit2(poolWriter.putDynamic(dynMember));</span>
          emit2(0);
          state.pop(argsize);
          state.push(mtype.getReturnType());
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -894,45 +904,30 @@</span>
      }
  
      /** Emit an opcode with a one-byte operand field.
       */
      public void emitop1(int op, int od) {
<span class="udiff-line-added">+         emitop1(op, od, null);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void emitop1(int op, int od, PoolConstant data) {</span>
          emitop(op);
          if (!alive) return;
          emit1(od);
          switch (op) {
          case bipush:
              state.push(syms.intType);
              break;
          case ldc1:
<span class="udiff-line-modified-removed">-             state.push(typeForPool(pool.pool[od]));</span>
<span class="udiff-line-modified-added">+             state.push(types.constantType((LoadableConstant)data));</span>
              break;
          default:
              throw new AssertionError(mnem(op));
          }
          postop();
      }
  
<span class="udiff-line-removed">-     /** The type of a constant pool entry. */</span>
<span class="udiff-line-removed">-     private Type typeForPool(Object o) {</span>
<span class="udiff-line-removed">-         if (o instanceof Integer) return syms.intType;</span>
<span class="udiff-line-removed">-         if (o instanceof Float) return syms.floatType;</span>
<span class="udiff-line-removed">-         if (o instanceof String) return syms.stringType;</span>
<span class="udiff-line-removed">-         if (o instanceof Long) return syms.longType;</span>
<span class="udiff-line-removed">-         if (o instanceof Double) return syms.doubleType;</span>
<span class="udiff-line-removed">-         if (o instanceof ClassSymbol) return syms.classType;</span>
<span class="udiff-line-removed">-         if (o instanceof Pool.MethodHandle) return syms.methodHandleType;</span>
<span class="udiff-line-removed">-         if (o instanceof UniqueType) return typeForPool(((UniqueType)o).type);</span>
<span class="udiff-line-removed">-         if (o instanceof Type) {</span>
<span class="udiff-line-removed">-             Type ty = (Type) o;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             if (ty instanceof Type.ArrayType) return syms.classType;</span>
<span class="udiff-line-removed">-             if (ty instanceof Type.MethodType) return syms.methodTypeType;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         throw new AssertionError(&quot;Invalid type of constant pool entry: &quot; + o.getClass());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      /** Emit an opcode with a one-byte operand field;
       *  widen if field does not fit in a byte.
       */
      public void emitop1w(int op, int od) {
          if (od &gt; 0xFF) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1001,33 +996,35 @@</span>
          }
      }
  
      /** Emit an opcode with a two-byte operand field.
       */
<span class="udiff-line-added">+     public &lt;P extends PoolConstant&gt; void emitop2(int op, P constant, ToIntBiFunction&lt;PoolWriter, P&gt; poolFunc) {</span>
<span class="udiff-line-added">+         int od = poolFunc.applyAsInt(poolWriter, constant);</span>
<span class="udiff-line-added">+         emitop2(op, od, constant);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public void emitop2(int op, int od) {
<span class="udiff-line-added">+         emitop2(op, od, null);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public void emitop2(int op, int od, PoolConstant data) {</span>
          emitop(op);
          if (!alive) return;
          emit2(od);
          switch (op) {
          case getstatic:
<span class="udiff-line-modified-removed">-             state.push(((Symbol)(pool.pool[od])).erasure(types));</span>
<span class="udiff-line-modified-added">+             state.push(((Symbol)data).erasure(types));</span>
              break;
          case putstatic:
<span class="udiff-line-modified-removed">-             state.pop(((Symbol)(pool.pool[od])).erasure(types));</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         case new_:</span>
<span class="udiff-line-removed">-             Symbol sym;</span>
<span class="udiff-line-removed">-             if (pool.pool[od] instanceof UniqueType) {</span>
<span class="udiff-line-removed">-                 // Required by change in Gen.makeRef to allow</span>
<span class="udiff-line-removed">-                 // annotated types.</span>
<span class="udiff-line-removed">-                 // TODO: is this needed anywhere else?</span>
<span class="udiff-line-removed">-                 sym = ((UniqueType)(pool.pool[od])).type.tsym;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 sym = (Symbol)(pool.pool[od]);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             state.push(uninitializedObject(sym.erasure(types), cp-3));</span>
<span class="udiff-line-modified-added">+             state.pop(((Symbol)data).erasure(types));</span>
              break;
<span class="udiff-line-added">+         case new_: {</span>
<span class="udiff-line-added">+             Type t = (Type)data;</span>
<span class="udiff-line-added">+             state.push(uninitializedObject(t.tsym.erasure(types), cp-3));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
          case sipush:
              state.push(syms.intType);
              break;
          case if_acmp_null:
          case if_acmp_nonnull:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1051,34 +1048,31 @@</span>
              break;
          case goto_:
              markDead();
              break;
          case putfield:
<span class="udiff-line-modified-removed">-             state.pop(((Symbol)(pool.pool[od])).erasure(types));</span>
<span class="udiff-line-modified-added">+             state.pop(((Symbol)data).erasure(types));</span>
              state.pop(1); // object ref
              break;
          case getfield:
              state.pop(1); // object ref
<span class="udiff-line-modified-removed">-             state.push(((Symbol)(pool.pool[od])).erasure(types));</span>
<span class="udiff-line-modified-added">+             state.push(((Symbol)data).erasure(types));</span>
              break;
          case checkcast: {
              state.pop(1); // object ref
<span class="udiff-line-modified-removed">-             Object o = pool.pool[od];</span>
<span class="udiff-line-removed">-             Type t = (o instanceof Symbol)</span>
<span class="udiff-line-removed">-                 ? ((Symbol)o).erasure(types)</span>
<span class="udiff-line-removed">-                 : types.erasure((((UniqueType)o).type));</span>
<span class="udiff-line-modified-added">+             Type t = types.erasure((Type)data);</span>
              state.push(t);
              break; }
          case ldc2w:
<span class="udiff-line-modified-removed">-             state.push(typeForPool(pool.pool[od]));</span>
<span class="udiff-line-modified-added">+             state.push(types.constantType((LoadableConstant)data));</span>
              break;
          case instanceof_:
              state.pop(1);
              state.push(syms.intType);
              break;
          case ldc2:
<span class="udiff-line-modified-removed">-             state.push(typeForPool(pool.pool[od]));</span>
<span class="udiff-line-modified-added">+             state.push(types.constantType((LoadableConstant)data));</span>
              break;
          case jsr:
              break;
          default:
              throw new AssertionError(mnem(op));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2080,10 +2074,11 @@</span>
              char length = (char)(curCP() - v.lastRange().start_pc);
              if (length &lt; Character.MAX_VALUE) {
                  lvar[adr] = v.dup();
                  v.closeRange(length);
                  putVar(v);
<span class="udiff-line-added">+                 fillLocalVarPosition(v);</span>
              } else {
                  v.removeLastRange();
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2111,24 +2106,35 @@</span>
      }
  
      private void fillLocalVarPosition(LocalVar lv) {
          if (lv == null || lv.sym == null || lv.sym.isExceptionParameter()|| !lv.sym.hasTypeAnnotations())
              return;
<span class="udiff-line-modified-removed">-         LocalVar.Range widestRange = lv.getWidestRange();</span>
<span class="udiff-line-modified-added">+         LocalVar.Range[] validRanges = lv.aliveRanges.stream().filter(r -&gt; r.closed() &amp;&amp; r.length &gt; 0).toArray(s -&gt; new LocalVar.Range[s]);</span>
<span class="udiff-line-added">+         if (validRanges.length == 0)</span>
<span class="udiff-line-added">+             return ;</span>
<span class="udiff-line-added">+         int[] lvarOffset = Arrays.stream(validRanges).mapToInt(r -&gt; r.start_pc).toArray();</span>
<span class="udiff-line-added">+         int[] lvarLength = Arrays.stream(validRanges).mapToInt(r -&gt; r.length).toArray();</span>
<span class="udiff-line-added">+         int[] lvarIndex = Arrays.stream(validRanges).mapToInt(r -&gt; lv.reg).toArray();</span>
          for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
              TypeAnnotationPosition p = ta.position;
<span class="udiff-line-modified-removed">-             if (widestRange.closed() &amp;&amp; widestRange.length &gt; 0) {</span>
<span class="udiff-line-modified-removed">-                 p.lvarOffset = new int[] { (int)widestRange.start_pc };</span>
<span class="udiff-line-modified-removed">-                 p.lvarLength = new int[] { (int)widestRange.length };</span>
<span class="udiff-line-modified-removed">-                 p.lvarIndex = new int[] { (int)lv.reg };</span>
<span class="udiff-line-removed">-                 p.isValidOffset = true;</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 p.isValidOffset = false;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+             p.lvarOffset = appendArray(p.lvarOffset, lvarOffset);</span>
<span class="udiff-line-modified-added">+             p.lvarLength = appendArray(p.lvarLength, lvarLength);</span>
<span class="udiff-line-modified-added">+             p.lvarIndex = appendArray(p.lvarIndex, lvarIndex);</span>
<span class="udiff-line-modified-added">+             p.isValidOffset = true;</span>
          }
      }
  
<span class="udiff-line-added">+     private int[] appendArray(int[] source, int[] append) {</span>
<span class="udiff-line-added">+         if (source == null || source.length == 0) return append;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         int[] result = new int[source.length + append.length];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         System.arraycopy(source, 0, result, 0, source.length);</span>
<span class="udiff-line-added">+         System.arraycopy(append, 0, result, source.length, append.length);</span>
<span class="udiff-line-added">+         return result;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      // Method to be called after compressCatchTable to
      // fill in the exception table index for type
      // annotations on exception parameters.
      public void fillExceptionParameterPositions() {
          for (int i = 0; i &lt; varBufferSize; ++i) {
</pre>
<center><a href="ClassWriter.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Gen.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
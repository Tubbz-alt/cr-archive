diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/StringConcat.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/StringConcat.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/StringConcat.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/StringConcat.java
@@ -24,11 +24,13 @@
  */
 
 package com.sun.tools.javac.jvm;
 
 import com.sun.tools.javac.code.*;
+import com.sun.tools.javac.code.Symbol.MethodSymbol;
 import com.sun.tools.javac.comp.Resolve;
+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.tree.TreeInfo;
 import com.sun.tools.javac.tree.TreeMaker;
 import com.sun.tools.javac.util.*;
 
@@ -220,11 +222,11 @@
             return gen.getItems().makeStackItem(syms.stringType);
         }
 
         private JCDiagnostic.DiagnosticPosition newStringBuilder(JCTree tree) {
             JCDiagnostic.DiagnosticPosition pos = tree.pos();
-            gen.getCode().emitop2(new_, gen.makeRef(pos, syms.stringBuilderType));
+            gen.getCode().emitop2(new_, gen.makeRef(pos, syms.stringBuilderType), syms.stringBuilderType);
             gen.getCode().emitop0(dup);
             gen.callMethod(pos, syms.stringBuilderType, names.init, List.nil(), false);
             return pos;
         }
 
@@ -376,14 +378,13 @@
                         bsm_staticArgs,
                         null);
 
                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcat,
                         syms.noSymbol,
-                        ClassFile.REF_invokeStatic,
-                        (Symbol.MethodSymbol)bsm,
+                        ((MethodSymbol)bsm).asHandle(),
                         indyType,
-                        List.nil().toArray());
+                        List.nil().toArray(new LoadableConstant[0]));
 
                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
                 item.invoke();
             } finally {
                 make.at(prevPos);
@@ -414,11 +415,11 @@
             for (List<JCTree> t : split) {
                 Assert.check(!t.isEmpty(), "Arguments list is empty");
 
                 StringBuilder recipe = new StringBuilder(t.size());
                 ListBuffer<Type> dynamicArgs = new ListBuffer<>();
-                ListBuffer<Object> staticArgs = new ListBuffer<>();
+                ListBuffer<LoadableConstant> staticArgs = new ListBuffer<>();
 
                 for (JCTree arg : t) {
                     Object constVal = arg.type.constValue();
                     if ("".equals(constVal)) continue;
                     if (arg.type == syms.botType) {
@@ -429,11 +430,11 @@
                         // for the case it contains special tags, which requires us
                         // to expose it as detached constant.
                         String a = arg.type.stringValue();
                         if (a.indexOf(TAG_CONST) != -1 || a.indexOf(TAG_ARG) != -1) {
                             recipe.append(TAG_CONST);
-                            staticArgs.add(a);
+                            staticArgs.add(LoadableConstant.String(a));
                         } else {
                             recipe.append(a);
                         }
                     } else {
                         // Ordinary arguments come through the dynamic arguments.
@@ -461,23 +462,23 @@
                 doCall(type, pos, recipe.toString(), List.nil(), argTypes.toList());
             }
         }
 
         /** Produce the actual invokedynamic call to StringConcatFactory */
-        private void doCall(Type type, JCDiagnostic.DiagnosticPosition pos, String recipe, List<Object> staticArgs, List<Type> dynamicArgTypes) {
+        private void doCall(Type type, JCDiagnostic.DiagnosticPosition pos, String recipe, List<LoadableConstant> staticArgs, List<Type> dynamicArgTypes) {
             Type.MethodType indyType = new Type.MethodType(dynamicArgTypes,
                     type,
                     List.nil(),
                     syms.methodClass);
 
             int prevPos = make.pos;
             try {
                 make.at(pos);
 
                 ListBuffer<Type> constTypes = new ListBuffer<>();
-                ListBuffer<Object> constants = new ListBuffer<>();
-                for (Object t : staticArgs) {
+                ListBuffer<LoadableConstant> constants = new ListBuffer<>();
+                for (LoadableConstant t : staticArgs) {
                     constants.add(t);
                     constTypes.add(syms.stringType);
                 }
 
                 List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,
@@ -493,14 +494,14 @@
                         bsm_staticArgs,
                         null);
 
                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcatWithConstants,
                         syms.noSymbol,
-                        ClassFile.REF_invokeStatic,
-                        (Symbol.MethodSymbol)bsm,
+                        ((MethodSymbol)bsm).asHandle(),
                         indyType,
-                        List.<Object>of(recipe).appendList(constants).toArray());
+                        List.of(LoadableConstant.String(recipe))
+                                .appendList(constants).toArray(new LoadableConstant[constants.size()]));
 
                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
                 item.invoke();
             } finally {
                 make.at(prevPos);

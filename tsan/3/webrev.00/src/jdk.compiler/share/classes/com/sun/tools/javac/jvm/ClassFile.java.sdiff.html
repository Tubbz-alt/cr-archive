<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CRTable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 
<span class="line-removed"> 28 import com.sun.tools.javac.code.Type;</span>
<span class="line-removed"> 29 import com.sun.tools.javac.code.Types;</span>
<span class="line-removed"> 30 import com.sun.tools.javac.code.Types.UniqueType;</span>
 31 import com.sun.tools.javac.util.Name;
 32 
 33 
 34 /** A JVM class file.
 35  *
 36  *  &lt;p&gt;Generic Java classfiles have one additional attribute for classes,
 37  *  methods and fields:
 38  *  &lt;pre&gt;
 39  *   &quot;Signature&quot; (u4 attr-length, u2 signature-index)
 40  *  &lt;/pre&gt;
 41  *
 42  *  &lt;p&gt;A signature gives the full Java type of a method or field. When
 43  *  used as a class attribute, it indicates type parameters, followed
 44  *  by supertype, followed by all interfaces.
 45  *  &lt;pre&gt;
 46  *     methodOrFieldSignature ::= type
 47  *     classSignature         ::= [ typeparams ] supertype { interfacetype }
 48  *  &lt;/pre&gt;
 49  *  &lt;p&gt;The type syntax in signatures is extended as follows:
 50  *  &lt;pre&gt;{@literal
</pre>
<hr />
<pre>
100     public final static int REF_invokeInterface = 9;
101 
102     public final static int MAX_PARAMETERS = 0xff;
103     public final static int MAX_DIMENSIONS = 0xff;
104     public final static int MAX_CODE = 0xffff;
105     public final static int MAX_LOCALS = 0xffff;
106     public final static int MAX_STACK = 0xffff;
107 
108     public final static int PREVIEW_MINOR_VERSION = 0xffff;
109 
110     public enum Version {
111         V45_3(45, 3), // base level for all attributes
112         V49(49, 0),   // JDK 1.5: enum, generics, annotations
113         V50(50, 0),   // JDK 1.6: stackmaps
114         V51(51, 0),   // JDK 1.7
115         V52(52, 0),   // JDK 1.8: lambda, type annos, param names
116         V53(53, 0),   // JDK 1.9: modules, indy string concat
117         V54(54, 0),   // JDK 10
118         V55(55, 0),   // JDK 11: constant dynamic, nest mates
119         V56(56, 0),   // JDK 12
<span class="line-modified">120         V57(57, 0);   // JDK 13</span>


121         Version(int major, int minor) {
122             this.major = major;
123             this.minor = minor;
124         }
125         public final int major, minor;
126 
127         private static final Version MIN = values()[0];
128         /** Return the least version supported, MIN */
129         public static Version MIN() { return MIN; }
130 
131         private static final Version MAX = values()[values().length-1];
132         /** Return the largest version supported, MAX */
133         public static Version MAX() { return MAX; }
134     }
135 
136 
137 /************************************************************************
138  * String Translation Routines
139  ***********************************************************************/
140 
</pre>
<hr />
<pre>
172      */
173     public static byte[] externalize(byte[] buf, int offset, int len) {
174         byte[] translated = new byte[len];
175         for (int j = 0; j &lt; len; j++) {
176             byte b = buf[offset + j];
177             if (b == &#39;.&#39;) translated[j] = (byte) &#39;/&#39;;
178             else translated[j] = b;
179         }
180         return translated;
181     }
182 
183     /**
184      * Return external representation of given name, converting &#39;/&#39; to &#39;.&#39;.
185      *
186      * Note: the naming is the inverse of that used by JVMS 4.2 The Internal Form Of Names,
187      * which defines &quot;internal name&quot; to be the form using &quot;/&quot; instead of &quot;.&quot;
188      */
189     public static byte[] externalize(Name name) {
190         return externalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());
191     }
<span class="line-removed">192 </span>
<span class="line-removed">193 /************************************************************************</span>
<span class="line-removed">194  * Name-and-type</span>
<span class="line-removed">195  ***********************************************************************/</span>
<span class="line-removed">196 </span>
<span class="line-removed">197     /** A class for the name-and-type signature of a method or field.</span>
<span class="line-removed">198      */</span>
<span class="line-removed">199     public static class NameAndType {</span>
<span class="line-removed">200         Name name;</span>
<span class="line-removed">201         UniqueType uniqueType;</span>
<span class="line-removed">202         Types types;</span>
<span class="line-removed">203 </span>
<span class="line-removed">204         NameAndType(Name name, Type type, Types types) {</span>
<span class="line-removed">205             this.name = name;</span>
<span class="line-removed">206             this.uniqueType = new UniqueType(type, types);</span>
<span class="line-removed">207             this.types = types;</span>
<span class="line-removed">208         }</span>
<span class="line-removed">209 </span>
<span class="line-removed">210         void setType(Type type) {</span>
<span class="line-removed">211             this.uniqueType = new UniqueType(type, types);</span>
<span class="line-removed">212         }</span>
<span class="line-removed">213 </span>
<span class="line-removed">214         @Override</span>
<span class="line-removed">215         public boolean equals(Object other) {</span>
<span class="line-removed">216             return (other instanceof NameAndType &amp;&amp;</span>
<span class="line-removed">217                     name == ((NameAndType) other).name &amp;&amp;</span>
<span class="line-removed">218                         uniqueType.equals(((NameAndType) other).uniqueType));</span>
<span class="line-removed">219         }</span>
<span class="line-removed">220 </span>
<span class="line-removed">221         @Override</span>
<span class="line-removed">222         public int hashCode() {</span>
<span class="line-removed">223             return name.hashCode() * uniqueType.hashCode();</span>
<span class="line-removed">224         }</span>
<span class="line-removed">225     }</span>
226 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 



 28 import com.sun.tools.javac.util.Name;
 29 
 30 
 31 /** A JVM class file.
 32  *
 33  *  &lt;p&gt;Generic Java classfiles have one additional attribute for classes,
 34  *  methods and fields:
 35  *  &lt;pre&gt;
 36  *   &quot;Signature&quot; (u4 attr-length, u2 signature-index)
 37  *  &lt;/pre&gt;
 38  *
 39  *  &lt;p&gt;A signature gives the full Java type of a method or field. When
 40  *  used as a class attribute, it indicates type parameters, followed
 41  *  by supertype, followed by all interfaces.
 42  *  &lt;pre&gt;
 43  *     methodOrFieldSignature ::= type
 44  *     classSignature         ::= [ typeparams ] supertype { interfacetype }
 45  *  &lt;/pre&gt;
 46  *  &lt;p&gt;The type syntax in signatures is extended as follows:
 47  *  &lt;pre&gt;{@literal
</pre>
<hr />
<pre>
 97     public final static int REF_invokeInterface = 9;
 98 
 99     public final static int MAX_PARAMETERS = 0xff;
100     public final static int MAX_DIMENSIONS = 0xff;
101     public final static int MAX_CODE = 0xffff;
102     public final static int MAX_LOCALS = 0xffff;
103     public final static int MAX_STACK = 0xffff;
104 
105     public final static int PREVIEW_MINOR_VERSION = 0xffff;
106 
107     public enum Version {
108         V45_3(45, 3), // base level for all attributes
109         V49(49, 0),   // JDK 1.5: enum, generics, annotations
110         V50(50, 0),   // JDK 1.6: stackmaps
111         V51(51, 0),   // JDK 1.7
112         V52(52, 0),   // JDK 1.8: lambda, type annos, param names
113         V53(53, 0),   // JDK 1.9: modules, indy string concat
114         V54(54, 0),   // JDK 10
115         V55(55, 0),   // JDK 11: constant dynamic, nest mates
116         V56(56, 0),   // JDK 12
<span class="line-modified">117         V57(57, 0),   // JDK 13</span>
<span class="line-added">118         V58(58, 0),   // JDK 14</span>
<span class="line-added">119         V59(59, 0);   // JDK 15</span>
120         Version(int major, int minor) {
121             this.major = major;
122             this.minor = minor;
123         }
124         public final int major, minor;
125 
126         private static final Version MIN = values()[0];
127         /** Return the least version supported, MIN */
128         public static Version MIN() { return MIN; }
129 
130         private static final Version MAX = values()[values().length-1];
131         /** Return the largest version supported, MAX */
132         public static Version MAX() { return MAX; }
133     }
134 
135 
136 /************************************************************************
137  * String Translation Routines
138  ***********************************************************************/
139 
</pre>
<hr />
<pre>
171      */
172     public static byte[] externalize(byte[] buf, int offset, int len) {
173         byte[] translated = new byte[len];
174         for (int j = 0; j &lt; len; j++) {
175             byte b = buf[offset + j];
176             if (b == &#39;.&#39;) translated[j] = (byte) &#39;/&#39;;
177             else translated[j] = b;
178         }
179         return translated;
180     }
181 
182     /**
183      * Return external representation of given name, converting &#39;/&#39; to &#39;.&#39;.
184      *
185      * Note: the naming is the inverse of that used by JVMS 4.2 The Internal Form Of Names,
186      * which defines &quot;internal name&quot; to be the form using &quot;/&quot; instead of &quot;.&quot;
187      */
188     public static byte[] externalize(Name name) {
189         return externalize(name.getByteArray(), name.getByteOffset(), name.getByteLength());
190     }


































191 }
</pre>
</td>
</tr>
</table>
<center><a href="CRTable.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
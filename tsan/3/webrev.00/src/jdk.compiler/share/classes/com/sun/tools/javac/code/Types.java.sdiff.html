<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeMetadata.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Analyzer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;


  51 import com.sun.tools.javac.util.*;
  52 
  53 import static com.sun.tools.javac.code.BoundKind.*;
  54 import static com.sun.tools.javac.code.Flags.*;
  55 import static com.sun.tools.javac.code.Kinds.Kind.*;
  56 import static com.sun.tools.javac.code.Scope.*;
  57 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  58 import static com.sun.tools.javac.code.Symbol.*;
  59 import static com.sun.tools.javac.code.Type.*;
  60 import static com.sun.tools.javac.code.TypeTag.*;
  61 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 
  64 /**
  65  * Utility class containing various operations on types.
  66  *
  67  * &lt;p&gt;Unless other names are more illustrative, the following naming
  68  * conventions should be observed in this file:
  69  *
  70  * &lt;dl&gt;
</pre>
<hr />
<pre>
 204             ProjectionKind complement() {
 205                 return UPWARDS;
 206             }
 207         };
 208 
 209         abstract ProjectionKind complement();
 210     }
 211 
 212     /**
 213      * This visitor performs upwards and downwards projections on types.
 214      *
 215      * A projection is defined as a function that takes a type T, a set of type variables V and that
 216      * produces another type S.
 217      *
 218      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 219      * and (ii) S is an upper bound of T.
 220      *
 221      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 222      * and (ii) S is a lower bound of T.
 223      *
<span class="line-modified"> 224      * Note that projections are only allowed to touch variables in V. Theferore it is possible for</span>
 225      * a projection to leave its input type unchanged if it does not contain any variables in V.
 226      *
 227      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 228      * a downwards projection is not always defined.
 229      *
 230      * Examples:
 231      *
 232      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 233      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 234      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 235      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 236      */
 237     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 238 
 239         List&lt;Type&gt; vars;
 240         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 241 
 242         public TypeProjection(List&lt;Type&gt; vars) {
 243             this.vars = vars;
 244         }
</pre>
<hr />
<pre>
 620 
 621     /**
 622      * Is t a subtype of or convertible via boxing/unboxing
 623      * conversions to s?
 624      */
 625     public boolean isConvertible(Type t, Type s) {
 626         return isConvertible(t, s, noWarnings);
 627     }
 628     // &lt;/editor-fold&gt;
 629 
 630     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 631 
 632     /**
 633      * Exception used to report a function descriptor lookup failure. The exception
 634      * wraps a diagnostic that can be used to generate more details error
 635      * messages.
 636      */
 637     public static class FunctionDescriptorLookupError extends RuntimeException {
 638         private static final long serialVersionUID = 0;
 639 
<span class="line-modified"> 640         JCDiagnostic diagnostic;</span>
 641 
 642         FunctionDescriptorLookupError() {
 643             this.diagnostic = null;
 644         }
 645 
 646         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 647             this.diagnostic = diag;
 648             return this;
 649         }
 650 
 651         public JCDiagnostic getDiagnostic() {
 652             return diagnostic;
 653         }
 654     }
 655 
 656     /**
 657      * A cache that keeps track of function descriptors associated with given
 658      * functional interfaces.
 659      */
 660     class DescriptorCache {
</pre>
<hr />
<pre>
2714             }
2715 
2716             @Override
2717             public Type visitTypeVar(TypeVar t, Void ignored) {
2718                 return classBound(supertype(t));
2719             }
2720 
2721             @Override
2722             public Type visitErrorType(ErrorType t, Void ignored) {
2723                 return t;
2724             }
2725         };
2726     // &lt;/editor-fold&gt;
2727 
2728     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2729     /**
2730      * Returns true iff the first signature is a &lt;em&gt;sub
2731      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2732      * relation.
2733      *
<span class="line-modified">2734      * @jls section 8.4.2.</span>
2735      * @see #overrideEquivalent(Type t, Type s)
2736      * @param t first signature (possibly raw).
2737      * @param s second signature (could be subjected to erasure).
2738      * @return true if t is a sub signature of s.
2739      */
2740     public boolean isSubSignature(Type t, Type s) {
2741         return isSubSignature(t, s, true);
2742     }
2743 
2744     public boolean isSubSignature(Type t, Type s, boolean strict) {
2745         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2746     }
2747 
2748     /**
2749      * Returns true iff these signatures are related by &lt;em&gt;override
2750      * equivalence&lt;/em&gt;.  This is the natural extension of
2751      * isSubSignature to an equivalence relation.
2752      *
<span class="line-modified">2753      * @jls section 8.4.2.</span>
2754      * @see #isSubSignature(Type t, Type s)
2755      * @param t a signature (possible raw, could be subjected to
2756      * erasure).
2757      * @param s a signature (possible raw, could be subjected to
2758      * erasure).
2759      * @return true if either argument is a sub signature of the other.
2760      */
2761     public boolean overrideEquivalent(Type t, Type s) {
2762         return hasSameArgs(t, s) ||
2763             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2764     }
2765 
2766     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2767         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2768             if (msym.overrides(sym, origin, Types.this, true)) {
2769                 return true;
2770             }
2771         }
2772         return false;
2773     }
</pre>
<hr />
<pre>
3726         } else {
3727             // t comes after head, or the two are unrelated
3728             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3729         }
3730     }
3731 
3732     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3733         return insert(cl, t, basicClosureSkip);
3734     }
3735 
3736     /**
3737      * Form the union of two closures
3738      */
3739     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3740         if (cl1.isEmpty()) {
3741             return cl2;
3742         } else if (cl2.isEmpty()) {
3743             return cl1;
3744         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3745             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
<span class="line-removed">3746         } else if (cl1.head.tsym.precedes(cl2.head.tsym, this)) {</span>
<span class="line-removed">3747             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);</span>
3748         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3749             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3750         } else {
<span class="line-removed">3751             // unrelated types</span>
3752             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3753         }
3754     }
3755 
3756     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3757         return union(cl1, cl2, basicClosureSkip);
3758     }
3759 
3760     /**
3761      * Intersect two closures
3762      */
3763     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3764         if (cl1 == cl2)
3765             return cl1;
3766         if (cl1.isEmpty() || cl2.isEmpty())
3767             return List.nil();
3768         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3769             return intersect(cl1.tail, cl2);
3770         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3771             return intersect(cl1, cl2.tail);
</pre>
<hr />
<pre>
4195 
4196     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4197     /**
4198      * Does t have a result that is a subtype of the result type of s,
4199      * suitable for covariant returns?  It is assumed that both types
4200      * are (possibly polymorphic) method types.  Monomorphic method
4201      * types are handled in the obvious way.  Polymorphic method types
4202      * require renaming all type variables of one to corresponding
4203      * type variables in the other, where correspondence is by
4204      * position in the type parameter list. */
4205     public boolean resultSubtype(Type t, Type s, Warner warner) {
4206         List&lt;Type&gt; tvars = t.getTypeArguments();
4207         List&lt;Type&gt; svars = s.getTypeArguments();
4208         Type tres = t.getReturnType();
4209         Type sres = subst(s.getReturnType(), svars, tvars);
4210         return covariantReturnType(tres, sres, warner);
4211     }
4212 
4213     /**
4214      * Return-Type-Substitutable.
<span class="line-modified">4215      * @jls section 8.4.5</span>
4216      */
4217     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4218         if (hasSameArgs(r1, r2))
4219             return resultSubtype(r1, r2, noWarnings);
4220         else
4221             return covariantReturnType(r1.getReturnType(),
4222                                        erasure(r2.getReturnType()),
4223                                        noWarnings);
4224     }
4225 
4226     public boolean returnTypeSubstitutable(Type r1,
4227                                            Type r2, Type r2res,
4228                                            Warner warner) {
4229         if (isSameType(r1.getReturnType(), r2res))
4230             return true;
4231         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4232             return false;
4233 
4234         if (hasSameArgs(r1, r2))
4235             return covariantReturnType(r1.getReturnType(), r2res, warner);
</pre>
<hr />
<pre>
4983             Attribute value = c.member(names.value);
4984             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
4985                 Name levelName = ((Attribute.Enum)value).value.name;
4986                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
4987                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
4988                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
4989                 else ;// /* fail soft */ throw new AssertionError(levelName);
4990             }
4991         }
4992         return vis;
4993     }
4994     // &lt;/editor-fold&gt;
4995 
4996     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
4997 
4998     public static abstract class SignatureGenerator {
4999 
5000         public static class InvalidSignatureException extends RuntimeException {
5001             private static final long serialVersionUID = 0;
5002 
<span class="line-modified">5003             private final Type type;</span>
5004 
5005             InvalidSignatureException(Type type) {
5006                 this.type = type;
5007             }
5008 
5009             public Type type() {
5010                 return type;
5011             }
5012         }
5013 
5014         private final Types types;
5015 
5016         protected abstract void append(char ch);
5017         protected abstract void append(byte[] ba);
5018         protected abstract void append(Name name);
5019         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5020 
5021         protected SignatureGenerator(Types types) {
5022             this.types = types;
5023         }
</pre>
<hr />
<pre>
5158             }
5159         }
5160 
5161         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5162             append(&#39;&lt;&#39;);
5163             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5164                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5165                 append(tvar.tsym.name);
5166                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5167                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5168                     append(&#39;:&#39;);
5169                 }
5170                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5171                     append(&#39;:&#39;);
5172                     assembleSig(l.head);
5173                 }
5174             }
5175             append(&#39;&gt;&#39;);
5176         }
5177 
<span class="line-modified">5178         private void assembleSig(List&lt;Type&gt; types) {</span>
5179             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5180                 assembleSig(ts.head);
5181             }
5182         }
5183     }

























5184     // &lt;/editor-fold&gt;
5185 
5186     public void newRound() {
5187         descCache._map.clear();
5188         isDerivedRawCache.clear();
5189         implCache._map.clear();
5190         membersCache._map.clear();
5191         closureCache.clear();
5192     }
5193 }
</pre>
</td>
<td>
<hr />
<pre>
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
<span class="line-added">  51 import com.sun.tools.javac.comp.LambdaToMethod;</span>
<span class="line-added">  52 import com.sun.tools.javac.jvm.ClassFile;</span>
  53 import com.sun.tools.javac.util.*;
  54 
  55 import static com.sun.tools.javac.code.BoundKind.*;
  56 import static com.sun.tools.javac.code.Flags.*;
  57 import static com.sun.tools.javac.code.Kinds.Kind.*;
  58 import static com.sun.tools.javac.code.Scope.*;
  59 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  60 import static com.sun.tools.javac.code.Symbol.*;
  61 import static com.sun.tools.javac.code.Type.*;
  62 import static com.sun.tools.javac.code.TypeTag.*;
  63 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  64 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  65 
  66 /**
  67  * Utility class containing various operations on types.
  68  *
  69  * &lt;p&gt;Unless other names are more illustrative, the following naming
  70  * conventions should be observed in this file:
  71  *
  72  * &lt;dl&gt;
</pre>
<hr />
<pre>
 206             ProjectionKind complement() {
 207                 return UPWARDS;
 208             }
 209         };
 210 
 211         abstract ProjectionKind complement();
 212     }
 213 
 214     /**
 215      * This visitor performs upwards and downwards projections on types.
 216      *
 217      * A projection is defined as a function that takes a type T, a set of type variables V and that
 218      * produces another type S.
 219      *
 220      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 221      * and (ii) S is an upper bound of T.
 222      *
 223      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 224      * and (ii) S is a lower bound of T.
 225      *
<span class="line-modified"> 226      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for</span>
 227      * a projection to leave its input type unchanged if it does not contain any variables in V.
 228      *
 229      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 230      * a downwards projection is not always defined.
 231      *
 232      * Examples:
 233      *
 234      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 235      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 236      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 237      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 238      */
 239     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 240 
 241         List&lt;Type&gt; vars;
 242         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 243 
 244         public TypeProjection(List&lt;Type&gt; vars) {
 245             this.vars = vars;
 246         }
</pre>
<hr />
<pre>
 622 
 623     /**
 624      * Is t a subtype of or convertible via boxing/unboxing
 625      * conversions to s?
 626      */
 627     public boolean isConvertible(Type t, Type s) {
 628         return isConvertible(t, s, noWarnings);
 629     }
 630     // &lt;/editor-fold&gt;
 631 
 632     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 633 
 634     /**
 635      * Exception used to report a function descriptor lookup failure. The exception
 636      * wraps a diagnostic that can be used to generate more details error
 637      * messages.
 638      */
 639     public static class FunctionDescriptorLookupError extends RuntimeException {
 640         private static final long serialVersionUID = 0;
 641 
<span class="line-modified"> 642         transient JCDiagnostic diagnostic;</span>
 643 
 644         FunctionDescriptorLookupError() {
 645             this.diagnostic = null;
 646         }
 647 
 648         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 649             this.diagnostic = diag;
 650             return this;
 651         }
 652 
 653         public JCDiagnostic getDiagnostic() {
 654             return diagnostic;
 655         }
 656     }
 657 
 658     /**
 659      * A cache that keeps track of function descriptors associated with given
 660      * functional interfaces.
 661      */
 662     class DescriptorCache {
</pre>
<hr />
<pre>
2716             }
2717 
2718             @Override
2719             public Type visitTypeVar(TypeVar t, Void ignored) {
2720                 return classBound(supertype(t));
2721             }
2722 
2723             @Override
2724             public Type visitErrorType(ErrorType t, Void ignored) {
2725                 return t;
2726             }
2727         };
2728     // &lt;/editor-fold&gt;
2729 
2730     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2731     /**
2732      * Returns true iff the first signature is a &lt;em&gt;sub
2733      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2734      * relation.
2735      *
<span class="line-modified">2736      * @jls 8.4.2 Method Signature</span>
2737      * @see #overrideEquivalent(Type t, Type s)
2738      * @param t first signature (possibly raw).
2739      * @param s second signature (could be subjected to erasure).
2740      * @return true if t is a sub signature of s.
2741      */
2742     public boolean isSubSignature(Type t, Type s) {
2743         return isSubSignature(t, s, true);
2744     }
2745 
2746     public boolean isSubSignature(Type t, Type s, boolean strict) {
2747         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2748     }
2749 
2750     /**
2751      * Returns true iff these signatures are related by &lt;em&gt;override
2752      * equivalence&lt;/em&gt;.  This is the natural extension of
2753      * isSubSignature to an equivalence relation.
2754      *
<span class="line-modified">2755      * @jls 8.4.2 Method Signature</span>
2756      * @see #isSubSignature(Type t, Type s)
2757      * @param t a signature (possible raw, could be subjected to
2758      * erasure).
2759      * @param s a signature (possible raw, could be subjected to
2760      * erasure).
2761      * @return true if either argument is a sub signature of the other.
2762      */
2763     public boolean overrideEquivalent(Type t, Type s) {
2764         return hasSameArgs(t, s) ||
2765             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2766     }
2767 
2768     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2769         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2770             if (msym.overrides(sym, origin, Types.this, true)) {
2771                 return true;
2772             }
2773         }
2774         return false;
2775     }
</pre>
<hr />
<pre>
3728         } else {
3729             // t comes after head, or the two are unrelated
3730             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3731         }
3732     }
3733 
3734     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3735         return insert(cl, t, basicClosureSkip);
3736     }
3737 
3738     /**
3739      * Form the union of two closures
3740      */
3741     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3742         if (cl1.isEmpty()) {
3743             return cl2;
3744         } else if (cl2.isEmpty()) {
3745             return cl1;
3746         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3747             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);


3748         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3749             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3750         } else {

3751             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3752         }
3753     }
3754 
3755     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3756         return union(cl1, cl2, basicClosureSkip);
3757     }
3758 
3759     /**
3760      * Intersect two closures
3761      */
3762     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3763         if (cl1 == cl2)
3764             return cl1;
3765         if (cl1.isEmpty() || cl2.isEmpty())
3766             return List.nil();
3767         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3768             return intersect(cl1.tail, cl2);
3769         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3770             return intersect(cl1, cl2.tail);
</pre>
<hr />
<pre>
4194 
4195     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4196     /**
4197      * Does t have a result that is a subtype of the result type of s,
4198      * suitable for covariant returns?  It is assumed that both types
4199      * are (possibly polymorphic) method types.  Monomorphic method
4200      * types are handled in the obvious way.  Polymorphic method types
4201      * require renaming all type variables of one to corresponding
4202      * type variables in the other, where correspondence is by
4203      * position in the type parameter list. */
4204     public boolean resultSubtype(Type t, Type s, Warner warner) {
4205         List&lt;Type&gt; tvars = t.getTypeArguments();
4206         List&lt;Type&gt; svars = s.getTypeArguments();
4207         Type tres = t.getReturnType();
4208         Type sres = subst(s.getReturnType(), svars, tvars);
4209         return covariantReturnType(tres, sres, warner);
4210     }
4211 
4212     /**
4213      * Return-Type-Substitutable.
<span class="line-modified">4214      * @jls 8.4.5 Method Result</span>
4215      */
4216     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4217         if (hasSameArgs(r1, r2))
4218             return resultSubtype(r1, r2, noWarnings);
4219         else
4220             return covariantReturnType(r1.getReturnType(),
4221                                        erasure(r2.getReturnType()),
4222                                        noWarnings);
4223     }
4224 
4225     public boolean returnTypeSubstitutable(Type r1,
4226                                            Type r2, Type r2res,
4227                                            Warner warner) {
4228         if (isSameType(r1.getReturnType(), r2res))
4229             return true;
4230         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4231             return false;
4232 
4233         if (hasSameArgs(r1, r2))
4234             return covariantReturnType(r1.getReturnType(), r2res, warner);
</pre>
<hr />
<pre>
4982             Attribute value = c.member(names.value);
4983             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
4984                 Name levelName = ((Attribute.Enum)value).value.name;
4985                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
4986                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
4987                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
4988                 else ;// /* fail soft */ throw new AssertionError(levelName);
4989             }
4990         }
4991         return vis;
4992     }
4993     // &lt;/editor-fold&gt;
4994 
4995     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
4996 
4997     public static abstract class SignatureGenerator {
4998 
4999         public static class InvalidSignatureException extends RuntimeException {
5000             private static final long serialVersionUID = 0;
5001 
<span class="line-modified">5002             private final transient Type type;</span>
5003 
5004             InvalidSignatureException(Type type) {
5005                 this.type = type;
5006             }
5007 
5008             public Type type() {
5009                 return type;
5010             }
5011         }
5012 
5013         private final Types types;
5014 
5015         protected abstract void append(char ch);
5016         protected abstract void append(byte[] ba);
5017         protected abstract void append(Name name);
5018         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5019 
5020         protected SignatureGenerator(Types types) {
5021             this.types = types;
5022         }
</pre>
<hr />
<pre>
5157             }
5158         }
5159 
5160         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5161             append(&#39;&lt;&#39;);
5162             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5163                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5164                 append(tvar.tsym.name);
5165                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5166                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5167                     append(&#39;:&#39;);
5168                 }
5169                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5170                     append(&#39;:&#39;);
5171                     assembleSig(l.head);
5172                 }
5173             }
5174             append(&#39;&gt;&#39;);
5175         }
5176 
<span class="line-modified">5177         public void assembleSig(List&lt;Type&gt; types) {</span>
5178             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5179                 assembleSig(ts.head);
5180             }
5181         }
5182     }
<span class="line-added">5183 </span>
<span class="line-added">5184     public Type constantType(LoadableConstant c) {</span>
<span class="line-added">5185         switch (c.poolTag()) {</span>
<span class="line-added">5186             case ClassFile.CONSTANT_Class:</span>
<span class="line-added">5187                 return syms.classType;</span>
<span class="line-added">5188             case ClassFile.CONSTANT_String:</span>
<span class="line-added">5189                 return syms.stringType;</span>
<span class="line-added">5190             case ClassFile.CONSTANT_Integer:</span>
<span class="line-added">5191                 return syms.intType;</span>
<span class="line-added">5192             case ClassFile.CONSTANT_Float:</span>
<span class="line-added">5193                 return syms.floatType;</span>
<span class="line-added">5194             case ClassFile.CONSTANT_Long:</span>
<span class="line-added">5195                 return syms.longType;</span>
<span class="line-added">5196             case ClassFile.CONSTANT_Double:</span>
<span class="line-added">5197                 return syms.doubleType;</span>
<span class="line-added">5198             case ClassFile.CONSTANT_MethodHandle:</span>
<span class="line-added">5199                 return syms.methodHandleType;</span>
<span class="line-added">5200             case ClassFile.CONSTANT_MethodType:</span>
<span class="line-added">5201                 return syms.methodTypeType;</span>
<span class="line-added">5202             case ClassFile.CONSTANT_Dynamic:</span>
<span class="line-added">5203                 return ((DynamicVarSymbol)c).type;</span>
<span class="line-added">5204             default:</span>
<span class="line-added">5205                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());</span>
<span class="line-added">5206         }</span>
<span class="line-added">5207     }</span>
5208     // &lt;/editor-fold&gt;
5209 
5210     public void newRound() {
5211         descCache._map.clear();
5212         isDerivedRawCache.clear();
5213         implCache._map.clear();
5214         membersCache._map.clear();
5215         closureCache.clear();
5216     }
5217 }
</pre>
</td>
</tr>
</table>
<center><a href="TypeMetadata.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Analyzer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
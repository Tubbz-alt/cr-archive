diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Items.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Items.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Items.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Items.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,10 +27,12 @@
 
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.code.Type.*;
 import com.sun.tools.javac.jvm.Code.*;
+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant.BasicConstant;
 import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.util.Assert;
 
 import static com.sun.tools.javac.jvm.ByteCodes.*;
 
@@ -48,13 +50,13 @@
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
  */
 public class Items {
 
-    /** The current constant pool.
+    /** The current constant pool writer.
      */
-    Pool pool;
+    PoolWriter poolWriter;
 
     /** The current code buffer.
      */
     Code code;
 
@@ -70,13 +72,13 @@
     private final Item voidItem;
     private final Item thisItem;
     private final Item superItem;
     private final Item[] stackItem = new Item[TypeCodeCount];
 
-    public Items(Pool pool, Code code, Symtab syms, Types types) {
+    public Items(PoolWriter poolWriter, Code code, Symtab syms, Types types) {
         this.code = code;
-        this.pool = pool;
+        this.poolWriter = poolWriter;
         this.types = types;
         voidItem = new Item(VOIDcode) {
                 public String toString() { return "void"; }
             };
         thisItem = new SelfItem(false);
@@ -170,13 +172,13 @@
         return new AssignItem(lhs);
     }
 
     /** Make an item representing a conditional or unconditional jump.
      *  @param opcode      The jump's opcode.
-     *  @param trueJumps   A chain encomassing all jumps that can be taken
+     *  @param trueJumps   A chain encompassing all jumps that can be taken
      *                     if the condition evaluates to true.
-     *  @param falseJumps  A chain encomassing all jumps that can be taken
+     *  @param falseJumps  A chain encompassing all jumps that can be taken
      *                     if the condition evaluates to false.
      */
     CondItem makeCondItem(int opcode, Chain trueJumps, Chain falseJumps) {
         return new CondItem(opcode, trueJumps, falseJumps);
     }
@@ -442,22 +444,22 @@
             super(Code.typecode(member.erasure(types)));
             this.member = member;
         }
 
         Item load() {
-            code.emitop2(getstatic, pool.put(member));
+            code.emitop2(getstatic, member, PoolWriter::putMember);
             return stackItem[typecode];
         }
 
         void store() {
-            code.emitop2(putstatic, pool.put(member));
+            code.emitop2(putstatic, member, PoolWriter::putMember);
         }
 
         Item invoke() {
             MethodType mtype = (MethodType)member.erasure(types);
             int rescode = Code.typecode(mtype.restype);
-            code.emitInvokestatic(pool.put(member), mtype);
+            code.emitInvokestatic(member, mtype);
             return stackItem[rescode];
         }
 
         public String toString() {
             return "static(" + member + ")";
@@ -470,23 +472,24 @@
         DynamicItem(Symbol member) {
             super(member);
         }
 
         Item load() {
-            assert false;
-            return null;
+            Assert.check(member.kind == Kinds.Kind.VAR);
+            Type type = member.erasure(types);
+            int rescode = Code.typecode(type);
+            code.emitLdc((DynamicVarSymbol)member);
+            return stackItem[rescode];
         }
 
-        void store() {
-            assert false;
-        }
+        void store() { Assert.error("this method shouldn't be invoked"); }
 
         Item invoke() {
-            // assert target.hasNativeInvokeDynamic();
+            Assert.check(member.kind == Kinds.Kind.MTH);
             MethodType mtype = (MethodType)member.erasure(types);
             int rescode = Code.typecode(mtype.restype);
-            code.emitInvokedynamic(pool.put(member), mtype);
+            code.emitInvokedynamic((DynamicMethodSymbol)member, mtype);
             return stackItem[rescode];
         }
 
         public String toString() {
             return "dynamic(" + member + ")";
@@ -510,27 +513,27 @@
             this.member = member;
             this.nonvirtual = nonvirtual;
         }
 
         Item load() {
-            code.emitop2(getfield, pool.put(member));
+            code.emitop2(getfield, member, PoolWriter::putMember);
             return stackItem[typecode];
         }
 
         void store() {
-            code.emitop2(putfield, pool.put(member));
+            code.emitop2(putfield, member, PoolWriter::putMember);
         }
 
         Item invoke() {
             MethodType mtype = (MethodType)member.externalType(types);
             int rescode = Code.typecode(mtype.restype);
             if ((member.owner.flags() & Flags.INTERFACE) != 0 && !nonvirtual) {
-                code.emitInvokeinterface(pool.put(member), mtype);
+                code.emitInvokeinterface(member, mtype);
             } else if (nonvirtual) {
-                code.emitInvokespecial(pool.put(member), mtype);
+                code.emitInvokespecial(member, mtype);
             } else {
-                code.emitInvokevirtual(pool.put(member), mtype);
+                code.emitInvokevirtual(member, mtype);
             }
             return stackItem[rescode];
         }
 
         void duplicate() {
@@ -558,56 +561,80 @@
      */
     class ImmediateItem extends Item {
 
         /** The literal's value.
          */
-        Object value;
+        final LoadableConstant value;
 
         ImmediateItem(Type type, Object value) {
             super(Code.typecode(type));
-            this.value = value;
+            switch (typecode) {
+                case BYTEcode:
+                case SHORTcode:
+                case CHARcode:
+                case INTcode:
+                    this.value = LoadableConstant.Int((int)value);
+                    break;
+                case LONGcode:
+                    this.value = LoadableConstant.Long((long)value);
+                    break;
+                case FLOATcode:
+                    this.value = LoadableConstant.Float((float)value);
+                    break;
+                case DOUBLEcode:
+                    this.value = LoadableConstant.Double((double)value);
+                    break;
+                case OBJECTcode:
+                    this.value = LoadableConstant.String((String)value);
+                    break;
+                default:
+                    throw new UnsupportedOperationException("unsupported tag: " + typecode);
+            }
         }
 
         private void ldc() {
-            int idx = pool.put(value);
             if (typecode == LONGcode || typecode == DOUBLEcode) {
-                code.emitop2(ldc2w, idx);
+                code.emitop2(ldc2w, value, PoolWriter::putConstant);
             } else {
-                code.emitLdc(idx);
+                code.emitLdc(value);
             }
         }
 
+        private Number numericValue() {
+            return (Number)((BasicConstant)value).data;
+        }
+
         Item load() {
             switch (typecode) {
             case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
-                int ival = ((Number)value).intValue();
+                int ival = numericValue().intValue();
                 if (-1 <= ival && ival <= 5)
                     code.emitop0(iconst_0 + ival);
                 else if (Byte.MIN_VALUE <= ival && ival <= Byte.MAX_VALUE)
                     code.emitop1(bipush, ival);
                 else if (Short.MIN_VALUE <= ival && ival <= Short.MAX_VALUE)
                     code.emitop2(sipush, ival);
                 else
                     ldc();
                 break;
             case LONGcode:
-                long lval = ((Number)value).longValue();
+                long lval = numericValue().longValue();
                 if (lval == 0 || lval == 1)
                     code.emitop0(lconst_0 + (int)lval);
                 else
                     ldc();
                 break;
             case FLOATcode:
-                float fval = ((Number)value).floatValue();
+                float fval = numericValue().floatValue();
                 if (isPosZero(fval) || fval == 1.0 || fval == 2.0)
                     code.emitop0(fconst_0 + (int)fval);
                 else {
                     ldc();
                 }
                 break;
             case DOUBLEcode:
-                double dval = ((Number)value).doubleValue();
+                double dval = numericValue().doubleValue();
                 if (isPosZero(dval) || dval == 1.0)
                     code.emitop0(dconst_0 + (int)dval);
                 else
                     ldc();
                 break;
@@ -630,11 +657,11 @@
             private boolean isPosZero(double x) {
                 return x == 0.0d && 1.0d / x > 0.0d;
             }
 
         CondItem mkCond() {
-            int ival = ((Number)value).intValue();
+            int ival = numericValue().intValue();
             return makeCondItem(ival != 0 ? goto_ : dontgoto);
         }
 
         Item coerce(int targetcode) {
             if (typecode == targetcode) {
@@ -645,35 +672,35 @@
                     if (Code.truncate(typecode) == INTcode)
                         return this;
                     else
                         return new ImmediateItem(
                             syms.intType,
-                            ((Number)value).intValue());
+                            numericValue().intValue());
                 case LONGcode:
                     return new ImmediateItem(
                         syms.longType,
-                        ((Number)value).longValue());
+                            numericValue().longValue());
                 case FLOATcode:
                     return new ImmediateItem(
                         syms.floatType,
-                        ((Number)value).floatValue());
+                        numericValue().floatValue());
                 case DOUBLEcode:
                     return new ImmediateItem(
                         syms.doubleType,
-                        ((Number)value).doubleValue());
+                        numericValue().doubleValue());
                 case BYTEcode:
                     return new ImmediateItem(
                         syms.byteType,
-                        (int)(byte)((Number)value).intValue());
+                        (int)(byte)numericValue().intValue());
                 case CHARcode:
                     return new ImmediateItem(
                         syms.charType,
-                        (int)(char)((Number)value).intValue());
+                        (int)(char)numericValue().intValue());
                 case SHORTcode:
                     return new ImmediateItem(
                         syms.shortType,
-                        (int)(short)((Number)value).intValue());
+                        (int)(short)numericValue().intValue());
                 default:
                     return super.coerce(targetcode);
                 }
             }
         }
@@ -725,16 +752,16 @@
 
     /** An item representing a conditional or unconditional jump.
      */
     class CondItem extends Item {
 
-        /** A chain encomassing all jumps that can be taken
+        /** A chain encompassing all jumps that can be taken
          *  if the condition evaluates to true.
          */
         Chain trueJumps;
 
-        /** A chain encomassing all jumps that can be taken
+        /** A chain encompassing all jumps that can be taken
          *  if the condition evaluates to false.
          */
         Chain falseJumps;
 
         /** The jump's opcode.

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompileStates.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Enter.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -39,34 +39,35 @@</span>
  import com.sun.tools.javac.tree.*;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.DefinedBy.Api;
  import com.sun.tools.javac.util.GraphUtils.DependencyKind;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<span class="udiff-line-removed">- import com.sun.tools.javac.code.Symbol.*;</span>
  import com.sun.tools.javac.comp.Attr.ResultInfo;
  import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.tree.JCTree.*;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  import com.sun.tools.javac.util.Log.DeferredDiagnosticHandler;
<span class="udiff-line-added">+ import com.sun.tools.javac.util.Log.DiagnosticHandler;</span>
  
  import java.util.ArrayList;
  import java.util.Collection;
  import java.util.Collections;
  import java.util.EnumSet;
  import java.util.HashSet;
  import java.util.LinkedHashSet;
  import java.util.Map;
  import java.util.Set;
  import java.util.WeakHashMap;
<span class="udiff-line-modified-removed">- import java.util.function.Function;</span>
<span class="udiff-line-modified-added">+ import java.util.function.Supplier;</span>
  
  import com.sun.source.tree.MemberReferenceTree;
  import com.sun.tools.javac.code.Type;
  import com.sun.tools.javac.tree.JCTree.JCMemberReference.OverloadKind;
  
  import static com.sun.tools.javac.code.TypeTag.*;
<span class="udiff-line-added">+ import com.sun.tools.javac.comp.Annotate.Queues;</span>
  import static com.sun.tools.javac.tree.JCTree.Tag.*;
  
  /**
   * This is an helper class that is used to perform deferred type-analysis.
   * Each time a poly expression occurs in argument position, javac attributes it
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -79,10 +80,11 @@</span>
   *  deletion without notice.&lt;/b&gt;
   */
  public class DeferredAttr extends JCTree.Visitor {
      protected static final Context.Key&lt;DeferredAttr&gt; deferredAttrKey = new Context.Key&lt;&gt;();
  
<span class="udiff-line-added">+     final Annotate annotate;</span>
      final Attr attr;
      final ArgumentAttr argumentAttr;
      final Check chk;
      final JCDiagnostic.Factory diags;
      final Enter enter;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -95,20 +97,22 @@</span>
      final TypeMapping&lt;Void&gt; deferredCopier;
      final Types types;
      final Flow flow;
      final Names names;
      final TypeEnvs typeEnvs;
<span class="udiff-line-added">+     final DeferredCompletionFailureHandler dcfh;</span>
  
      public static DeferredAttr instance(Context context) {
          DeferredAttr instance = context.get(deferredAttrKey);
          if (instance == null)
              instance = new DeferredAttr(context);
          return instance;
      }
  
      protected DeferredAttr(Context context) {
          context.put(deferredAttrKey, this);
<span class="udiff-line-added">+         annotate = Annotate.instance(context);</span>
          attr = Attr.instance(context);
          argumentAttr = ArgumentAttr.instance(context);
          chk = Check.instance(context);
          diags = JCDiagnostic.Factory.instance(context);
          enter = Enter.instance(context);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -120,10 +124,11 @@</span>
          types = Types.instance(context);
          flow = Flow.instance(context);
          names = Names.instance(context);
          stuckTree = make.Ident(names.empty).setType(Type.stuckType);
          typeEnvs = TypeEnvs.instance(context);
<span class="udiff-line-added">+         dcfh = DeferredCompletionFailureHandler.instance(context);</span>
          emptyDeferredAttrContext =
              new DeferredAttrContext(AttrMode.CHECK, null, MethodResolutionPhase.BOX, infer.emptyContext, null, null) {
                  @Override
                  void addDeferredAttrNode(DeferredType dt, ResultInfo ri, DeferredStuckPolicy deferredStuckPolicy) {
                      Assert.error(&quot;Empty deferred context!&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -480,60 +485,56 @@</span>
       * restored after type-checking. All diagnostics (but critical ones) are
       * disabled during speculative type-checking.
       */
      JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
          return attribSpeculative(tree, env, resultInfo, treeCopier,
<span class="udiff-line-modified-removed">-                 (newTree)-&gt;new DeferredAttrDiagHandler(log, newTree), null);</span>
<span class="udiff-line-modified-added">+                 null, AttributionMode.SPECULATIVE, null);</span>
      }
  
      JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, LocalCacheContext localCache) {
          return attribSpeculative(tree, env, resultInfo, treeCopier,
<span class="udiff-line-modified-removed">-                 (newTree)-&gt;new DeferredAttrDiagHandler(log, newTree), localCache);</span>
<span class="udiff-line-modified-added">+                 null, AttributionMode.SPECULATIVE, localCache);</span>
      }
  
      &lt;Z&gt; JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, TreeCopier&lt;Z&gt; deferredCopier,
<span class="udiff-line-modified-removed">-                                  Function&lt;JCTree, DeferredDiagnosticHandler&gt; diagHandlerCreator,</span>
<span class="udiff-line-modified-added">+                                  Supplier&lt;DiagnosticHandler&gt; diagHandlerCreator, AttributionMode attributionMode,</span>
                                   LocalCacheContext localCache) {
          final JCTree newTree = deferredCopier.copy(tree);
<span class="udiff-line-modified-removed">-         Env&lt;AttrContext&gt; speculativeEnv = env.dup(newTree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));</span>
<span class="udiff-line-modified-removed">-         speculativeEnv.info.isSpeculative = true;</span>
<span class="udiff-line-modified-removed">-         Log.DeferredDiagnosticHandler deferredDiagnosticHandler = diagHandlerCreator.apply(newTree);</span>
<span class="udiff-line-modified-added">+         return attribSpeculative(newTree, env, resultInfo, diagHandlerCreator, attributionMode, localCache);</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Attribute the given tree, mostly reverting side-effects applied to shared</span>
<span class="udiff-line-added">+      * compiler state. Exceptions include the ArgumentAttr.argumentTypeCache,</span>
<span class="udiff-line-added">+      * changes to which may be preserved if localCache is null and errors reported</span>
<span class="udiff-line-added">+      * outside of the speculatively attributed tree.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     &lt;Z&gt; JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo,</span>
<span class="udiff-line-added">+                               Supplier&lt;DiagnosticHandler&gt; diagHandlerCreator, AttributionMode attributionMode,</span>
<span class="udiff-line-added">+                               LocalCacheContext localCache) {</span>
<span class="udiff-line-added">+         Env&lt;AttrContext&gt; speculativeEnv = env.dup(tree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));</span>
<span class="udiff-line-added">+         speculativeEnv.info.attributionMode = attributionMode;</span>
<span class="udiff-line-added">+         Log.DiagnosticHandler deferredDiagnosticHandler = diagHandlerCreator != null ? diagHandlerCreator.get() : new DeferredAttrDiagHandler(log, tree);</span>
<span class="udiff-line-added">+         DeferredCompletionFailureHandler.Handler prevCFHandler = dcfh.setHandler(dcfh.speculativeCodeHandler);</span>
<span class="udiff-line-added">+         Queues prevQueues = annotate.setQueues(new Queues());</span>
<span class="udiff-line-added">+         int nwarnings = log.nwarnings;</span>
<span class="udiff-line-added">+         log.nwarnings = 0;</span>
          try {
<span class="udiff-line-modified-removed">-             attr.attribTree(newTree, speculativeEnv, resultInfo);</span>
<span class="udiff-line-modified-removed">-             return newTree;</span>
<span class="udiff-line-modified-added">+             attr.attribTree(tree, speculativeEnv, resultInfo);</span>
<span class="udiff-line-modified-added">+             return tree;</span>
          } finally {
<span class="udiff-line-modified-removed">-             new UnenterScanner(env.toplevel.modle).scan(newTree);</span>
<span class="udiff-line-modified-added">+             annotate.setQueues(prevQueues);</span>
<span class="udiff-line-added">+             dcfh.setHandler(prevCFHandler);</span>
<span class="udiff-line-added">+             log.nwarnings += nwarnings;</span>
<span class="udiff-line-added">+             enter.unenter(env.toplevel, tree);</span>
              log.popDiagnosticHandler(deferredDiagnosticHandler);
              if (localCache != null) {
                  localCache.leave();
              }
          }
      }
      //where
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         class UnenterScanner extends TreeScanner {</span>
<span class="udiff-line-removed">-             private final ModuleSymbol msym;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             public UnenterScanner(ModuleSymbol msym) {</span>
<span class="udiff-line-removed">-                 this.msym = msym;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             @Override</span>
<span class="udiff-line-removed">-             public void visitClassDef(JCClassDecl tree) {</span>
<span class="udiff-line-removed">-                 ClassSymbol csym = tree.sym;</span>
<span class="udiff-line-removed">-                 //if something went wrong during method applicability check</span>
<span class="udiff-line-removed">-                 //it is possible that nested expressions inside argument expression</span>
<span class="udiff-line-removed">-                 //are left unchecked - in such cases there&#39;s nothing to clean up.</span>
<span class="udiff-line-removed">-                 if (csym == null) return;</span>
<span class="udiff-line-removed">-                 typeEnvs.remove(csym);</span>
<span class="udiff-line-removed">-                 chk.removeCompiled(csym);</span>
<span class="udiff-line-removed">-                 chk.clearLocalClassNameIndexes(csym);</span>
<span class="udiff-line-removed">-                 syms.removeClass(msym, csym.flatname);</span>
<span class="udiff-line-removed">-                 super.visitClassDef(tree);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          static class DeferredAttrDiagHandler extends Log.DeferredDiagnosticHandler {
  
              static class PosScanner extends TreeScanner {
                  DiagnosticPosition pos;
                  boolean found = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -645,11 +646,11 @@</span>
                          DeferredAttrNode toUnstuck = pickDeferredNode();
                          inferenceContext.solveAny(List.from(toUnstuck.deferredStuckPolicy.stuckVars()), warn);
                          inferenceContext.notifyChange();
                      } catch (Infer.GraphStrategy.NodeNotFoundException ex) {
                          //this means that we are in speculative mode and the
<span class="udiff-line-modified-removed">-                         //set of contraints are too tight for progess to be made.</span>
<span class="udiff-line-modified-added">+                         //set of constraints are too tight for progress to be made.</span>
                          //Just leave the remaining expressions as stuck.
                          break;
                      }
                  }
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1159,11 +1160,11 @@</span>
       */
      static class SwitchExpressionScanner extends FilterScanner {
  
          SwitchExpressionScanner() {
              super(EnumSet.of(BLOCK, CASE, CATCH, DOLOOP, FOREACHLOOP,
<span class="udiff-line-modified-removed">-                     FORLOOP, IF, BREAK, SYNCHRONIZED, SWITCH, TRY, WHILELOOP));</span>
<span class="udiff-line-modified-added">+                     FORLOOP, IF, SYNCHRONIZED, SWITCH, TRY, WHILELOOP, YIELD));</span>
          }
      }
  
      /**
       * This visitor is used to check that structural expressions conform
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1308,6 +1309,28 @@</span>
              if (tree.getOverloadKind() != JCMemberReference.OverloadKind.UNOVERLOADED) {
                  stuck = true;
              }
          }
      }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Mode of attribution (used in AttrContext).</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     enum AttributionMode {</span>
<span class="udiff-line-added">+         /**Normal, non-speculative, attribution.*/</span>
<span class="udiff-line-added">+         FULL(false),</span>
<span class="udiff-line-added">+         /**Speculative attribution on behalf of an Analyzer.*/</span>
<span class="udiff-line-added">+         ANALYZER(true),</span>
<span class="udiff-line-added">+         /**Speculative attribution.*/</span>
<span class="udiff-line-added">+         SPECULATIVE(true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         AttributionMode(boolean isSpeculative) {</span>
<span class="udiff-line-added">+             this.isSpeculative = isSpeculative;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         boolean isSpeculative() {</span>
<span class="udiff-line-added">+             return isSpeculative;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         final boolean isSpeculative;</span>
<span class="udiff-line-added">+     }</span>
  }
</pre>
<center><a href="CompileStates.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Enter.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
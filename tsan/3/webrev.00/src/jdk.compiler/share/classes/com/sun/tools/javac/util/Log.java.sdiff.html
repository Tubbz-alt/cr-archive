<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/util/Log.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ForwardingDiagnosticFormatter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MandatoryWarningHandler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/util/Log.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
402         /** Default value for -Xmaxerrs.
403          */
404         protected int getDefaultMaxErrors() {
405             return 100;
406         }
407 
408         /** Default value for -Xmaxwarns.
409          */
410         protected int getDefaultMaxWarnings() {
411             return 100;
412         }
413 
414     /** The number of errors encountered so far.
415      */
416     public int nerrors = 0;
417 
418     /** The number of warnings encountered so far.
419      */
420     public int nwarnings = 0;
421 








422     /** A set of all errors generated so far. This is used to avoid printing an
423      *  error message more than once. For each error, a pair consisting of the
424      *  source file name and source code position of the error is added to the set.
425      */
426     protected Set&lt;Pair&lt;JavaFileObject, Integer&gt;&gt; recorded = new HashSet&lt;&gt;();
427 
428     /** A set of &quot;not-supported-in-source-X&quot; errors produced so far. This is used to only generate
429      *  one such error per file.
430      */
431     protected Set&lt;Pair&lt;JavaFileObject, List&lt;String&gt;&gt;&gt;  recordedSourceLevelErrors = new HashSet&lt;&gt;();
432 
433     public boolean hasDiagnosticListener() {
434         return diagListener != null;
435     }
436 
437     public void setEndPosTable(JavaFileObject name, EndPosTable endPosTable) {
438         Assert.checkNonNull(name);
439         getSource(name).setEndPosTable(endPosTable);
440     }
441 
</pre>
<hr />
<pre>
529             recordedSourceLevelErrors.add(coords);
530         return shouldReport;
531     }
532 
533     //where
534         private List&lt;String&gt; getCode(JCDiagnostic d) {
535             ListBuffer&lt;String&gt; buf = new ListBuffer&lt;&gt;();
536             getCodeRecursive(buf, d);
537             return buf.toList();
538         }
539 
540         private void getCodeRecursive(ListBuffer&lt;String&gt; buf, JCDiagnostic d) {
541             buf.add(d.getCode());
542             for (Object o : d.getArgs()) {
543                 if (o instanceof JCDiagnostic) {
544                     getCodeRecursive(buf, (JCDiagnostic)o);
545                 }
546             }
547         }
548 







549     /** Prompt user after an error.
550      */
551     public void prompt() {
552         if (promptOnError) {
553             System.err.println(localize(&quot;resume.abort&quot;));
554             try {
555                 while (true) {
556                     switch (System.in.read()) {
557                     case &#39;a&#39;: case &#39;A&#39;:
558                         System.exit(-1);
559                         return;
560                     case &#39;r&#39;: case &#39;R&#39;:
561                         return;
562                     case &#39;x&#39;: case &#39;X&#39;:
563                         throw new AssertionError(&quot;user abort&quot;);
564                     default:
565                     }
566                 }
567             } catch (IOException e) {}
568         }
</pre>
<hr />
<pre>
691                 expectDiagKeys.remove(diagnostic.getCode());
692 
693             switch (diagnostic.getType()) {
694             case FRAGMENT:
695                 throw new IllegalArgumentException();
696 
697             case NOTE:
698                 // Print out notes only when we are permitted to report warnings
699                 // Notes are only generated at the end of a compilation, so should be small
700                 // in number.
701                 if ((emitWarnings || diagnostic.isMandatory()) &amp;&amp; !suppressNotes) {
702                     writeDiagnostic(diagnostic);
703                 }
704                 break;
705 
706             case WARNING:
707                 if (emitWarnings || diagnostic.isMandatory()) {
708                     if (nwarnings &lt; MaxWarnings) {
709                         writeDiagnostic(diagnostic);
710                         nwarnings++;


711                     }
712                 }
713                 break;
714 
715             case ERROR:
<span class="line-modified">716                 if (nerrors &lt; MaxErrors &amp;&amp;</span>
<span class="line-modified">717                     (diagnostic.isFlagSet(DiagnosticFlag.API) ||</span>
<span class="line-modified">718                      shouldReport(diagnostic))) {</span>
<span class="line-modified">719                     writeDiagnostic(diagnostic);</span>
<span class="line-modified">720                     nerrors++;</span>



721                 }
722                 break;
723             }
724             if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {
725                 compressedOutput = true;
726             }
727         }
728     }
729 
730     /**
731      * Write out a diagnostic.
732      */
733     protected void writeDiagnostic(JCDiagnostic diag) {
734         if (diagListener != null) {
735             diagListener.report(diag);
736             return;
737         }
738 
739         PrintWriter writer = getWriterForDiagnosticType(diag.getType());
740 
</pre>
<hr />
<pre>
827         } else {
828             int line = source.getLineNumber(pos);
829             JavaFileObject file = source.getFile();
830             if (file != null)
831                 printRawLines(pw,
832                            file.getName() + &quot;:&quot; +
833                            line + &quot;: &quot; + msg);
834             printErrLine(pos, pw);
835         }
836         pw.flush();
837     }
838 
839     /** report an error:
840      */
841     public void rawError(int pos, String msg) {
842         PrintWriter errWriter = writers.get(WriterKind.ERROR);
843         if (nerrors &lt; MaxErrors &amp;&amp; shouldReport(currentSourceFile(), pos)) {
844             printRawDiag(errWriter, &quot;error: &quot;, pos, msg);
845             prompt();
846             nerrors++;


847         }
848         errWriter.flush();
849     }
850 
851     /** report a warning:
852      */
853     public void rawWarning(int pos, String msg) {
854         PrintWriter warnWriter = writers.get(WriterKind.ERROR);
<span class="line-modified">855         if (nwarnings &lt; MaxWarnings &amp;&amp; emitWarnings) {</span>
<span class="line-modified">856             printRawDiag(warnWriter, &quot;warning: &quot;, pos, msg);</span>




857         }
858         prompt();
859         nwarnings++;
860         warnWriter.flush();
861     }
862 
863     public static String format(String fmt, Object... args) {
864         return String.format((java.util.Locale)null, fmt, args);
865     }
866 
867 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
402         /** Default value for -Xmaxerrs.
403          */
404         protected int getDefaultMaxErrors() {
405             return 100;
406         }
407 
408         /** Default value for -Xmaxwarns.
409          */
410         protected int getDefaultMaxWarnings() {
411             return 100;
412         }
413 
414     /** The number of errors encountered so far.
415      */
416     public int nerrors = 0;
417 
418     /** The number of warnings encountered so far.
419      */
420     public int nwarnings = 0;
421 
<span class="line-added">422     /** The number of errors encountered after MaxErrors was reached.</span>
<span class="line-added">423      */</span>
<span class="line-added">424     public int nsuppressederrors = 0;</span>
<span class="line-added">425 </span>
<span class="line-added">426     /** The number of warnings encountered after MaxWarnings was reached.</span>
<span class="line-added">427      */</span>
<span class="line-added">428     public int nsuppressedwarns = 0;</span>
<span class="line-added">429 </span>
430     /** A set of all errors generated so far. This is used to avoid printing an
431      *  error message more than once. For each error, a pair consisting of the
432      *  source file name and source code position of the error is added to the set.
433      */
434     protected Set&lt;Pair&lt;JavaFileObject, Integer&gt;&gt; recorded = new HashSet&lt;&gt;();
435 
436     /** A set of &quot;not-supported-in-source-X&quot; errors produced so far. This is used to only generate
437      *  one such error per file.
438      */
439     protected Set&lt;Pair&lt;JavaFileObject, List&lt;String&gt;&gt;&gt;  recordedSourceLevelErrors = new HashSet&lt;&gt;();
440 
441     public boolean hasDiagnosticListener() {
442         return diagListener != null;
443     }
444 
445     public void setEndPosTable(JavaFileObject name, EndPosTable endPosTable) {
446         Assert.checkNonNull(name);
447         getSource(name).setEndPosTable(endPosTable);
448     }
449 
</pre>
<hr />
<pre>
537             recordedSourceLevelErrors.add(coords);
538         return shouldReport;
539     }
540 
541     //where
542         private List&lt;String&gt; getCode(JCDiagnostic d) {
543             ListBuffer&lt;String&gt; buf = new ListBuffer&lt;&gt;();
544             getCodeRecursive(buf, d);
545             return buf.toList();
546         }
547 
548         private void getCodeRecursive(ListBuffer&lt;String&gt; buf, JCDiagnostic d) {
549             buf.add(d.getCode());
550             for (Object o : d.getArgs()) {
551                 if (o instanceof JCDiagnostic) {
552                     getCodeRecursive(buf, (JCDiagnostic)o);
553                 }
554             }
555         }
556 
<span class="line-added">557     /**Is an error reported at the given pos (inside the current source)?*/</span>
<span class="line-added">558     public boolean hasErrorOn(DiagnosticPosition pos) {</span>
<span class="line-added">559         JavaFileObject file = source != null ? source.fileObject : null;</span>
<span class="line-added">560 </span>
<span class="line-added">561         return file != null &amp;&amp; recorded.contains(new Pair&lt;&gt;(file, pos.getPreferredPosition()));</span>
<span class="line-added">562     }</span>
<span class="line-added">563 </span>
564     /** Prompt user after an error.
565      */
566     public void prompt() {
567         if (promptOnError) {
568             System.err.println(localize(&quot;resume.abort&quot;));
569             try {
570                 while (true) {
571                     switch (System.in.read()) {
572                     case &#39;a&#39;: case &#39;A&#39;:
573                         System.exit(-1);
574                         return;
575                     case &#39;r&#39;: case &#39;R&#39;:
576                         return;
577                     case &#39;x&#39;: case &#39;X&#39;:
578                         throw new AssertionError(&quot;user abort&quot;);
579                     default:
580                     }
581                 }
582             } catch (IOException e) {}
583         }
</pre>
<hr />
<pre>
706                 expectDiagKeys.remove(diagnostic.getCode());
707 
708             switch (diagnostic.getType()) {
709             case FRAGMENT:
710                 throw new IllegalArgumentException();
711 
712             case NOTE:
713                 // Print out notes only when we are permitted to report warnings
714                 // Notes are only generated at the end of a compilation, so should be small
715                 // in number.
716                 if ((emitWarnings || diagnostic.isMandatory()) &amp;&amp; !suppressNotes) {
717                     writeDiagnostic(diagnostic);
718                 }
719                 break;
720 
721             case WARNING:
722                 if (emitWarnings || diagnostic.isMandatory()) {
723                     if (nwarnings &lt; MaxWarnings) {
724                         writeDiagnostic(diagnostic);
725                         nwarnings++;
<span class="line-added">726                     } else {</span>
<span class="line-added">727                         nsuppressedwarns++;</span>
728                     }
729                 }
730                 break;
731 
732             case ERROR:
<span class="line-modified">733                 if (diagnostic.isFlagSet(DiagnosticFlag.API) ||</span>
<span class="line-modified">734                      shouldReport(diagnostic)) {</span>
<span class="line-modified">735                     if (nerrors &lt; MaxErrors) {</span>
<span class="line-modified">736                         writeDiagnostic(diagnostic);</span>
<span class="line-modified">737                         nerrors++;</span>
<span class="line-added">738                     } else {</span>
<span class="line-added">739                         nsuppressederrors++;</span>
<span class="line-added">740                     }</span>
741                 }
742                 break;
743             }
744             if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {
745                 compressedOutput = true;
746             }
747         }
748     }
749 
750     /**
751      * Write out a diagnostic.
752      */
753     protected void writeDiagnostic(JCDiagnostic diag) {
754         if (diagListener != null) {
755             diagListener.report(diag);
756             return;
757         }
758 
759         PrintWriter writer = getWriterForDiagnosticType(diag.getType());
760 
</pre>
<hr />
<pre>
847         } else {
848             int line = source.getLineNumber(pos);
849             JavaFileObject file = source.getFile();
850             if (file != null)
851                 printRawLines(pw,
852                            file.getName() + &quot;:&quot; +
853                            line + &quot;: &quot; + msg);
854             printErrLine(pos, pw);
855         }
856         pw.flush();
857     }
858 
859     /** report an error:
860      */
861     public void rawError(int pos, String msg) {
862         PrintWriter errWriter = writers.get(WriterKind.ERROR);
863         if (nerrors &lt; MaxErrors &amp;&amp; shouldReport(currentSourceFile(), pos)) {
864             printRawDiag(errWriter, &quot;error: &quot;, pos, msg);
865             prompt();
866             nerrors++;
<span class="line-added">867         } else {</span>
<span class="line-added">868             nsuppressederrors++;</span>
869         }
870         errWriter.flush();
871     }
872 
873     /** report a warning:
874      */
875     public void rawWarning(int pos, String msg) {
876         PrintWriter warnWriter = writers.get(WriterKind.ERROR);
<span class="line-modified">877         if (emitWarnings) {</span>
<span class="line-modified">878             if (nwarnings &lt; MaxWarnings) {</span>
<span class="line-added">879                 printRawDiag(warnWriter, &quot;warning: &quot;, pos, msg);</span>
<span class="line-added">880             } else {</span>
<span class="line-added">881                 nsuppressedwarns++;</span>
<span class="line-added">882             }</span>
883         }
884         prompt();
885         nwarnings++;
886         warnWriter.flush();
887     }
888 
889     public static String format(String fmt, Object... args) {
890         return String.format((java.util.Locale)null, fmt, args);
891     }
892 
893 }
</pre>
</td>
</tr>
</table>
<center><a href="ForwardingDiagnosticFormatter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MandatoryWarningHandler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
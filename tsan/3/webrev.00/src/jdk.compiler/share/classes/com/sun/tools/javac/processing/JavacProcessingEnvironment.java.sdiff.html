<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacProcessingEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacMessager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacRoundEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacProcessingEnvironment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 171     private ServiceLoader&lt;Processor&gt; serviceLoader;
 172     private SecurityException processorLoaderException;
 173 
 174     private final JavaFileManager fileManager;
 175 
 176     /**
 177      * JavacMessages object used for localization
 178      */
 179     private JavacMessages messages;
 180 
 181     private MultiTaskListener taskListener;
 182     private final Symtab symtab;
 183     private final DeferredCompletionFailureHandler dcfh;
 184     private final Names names;
 185     private final Enter enter;
 186     private final Completer initialCompleter;
 187     private final Check chk;
 188 
 189     private final Context context;
 190 





 191     /** Get the JavacProcessingEnvironment instance for this context. */
 192     public static JavacProcessingEnvironment instance(Context context) {
 193         JavacProcessingEnvironment instance = context.get(JavacProcessingEnvironment.class);
 194         if (instance == null)
 195             instance = new JavacProcessingEnvironment(context);
 196         return instance;
 197     }
 198 
 199     protected JavacProcessingEnvironment(Context context) {
 200         this.context = context;
 201         context.put(JavacProcessingEnvironment.class, this);
 202         log = Log.instance(context);
 203         source = Source.instance(context);
 204         diags = JCDiagnostic.Factory.instance(context);
 205         options = Options.instance(context);
 206         printProcessorInfo = options.isSet(Option.XPRINTPROCESSORINFO);
 207         printRounds = options.isSet(Option.XPRINTROUNDS);
 208         verbose = options.isSet(Option.VERBOSE);
 209         lint = Lint.instance(context).isEnabled(PROCESSING);
 210         compiler = JavaCompiler.instance(context);
</pre>
<hr />
<pre>
 219 
 220         // Initialize services before any processors are initialized
 221         // in case processors use them.
 222         filer = new JavacFiler(context);
 223         messager = new JavacMessager(context, this);
 224         elementUtils = JavacElements.instance(context);
 225         typeUtils = JavacTypes.instance(context);
 226         modules = Modules.instance(context);
 227         types = Types.instance(context);
 228         annotate = Annotate.instance(context);
 229         processorOptions = initProcessorOptions();
 230         unmatchedProcessorOptions = initUnmatchedProcessorOptions();
 231         messages = JavacMessages.instance(context);
 232         taskListener = MultiTaskListener.instance(context);
 233         symtab = Symtab.instance(context);
 234         dcfh = DeferredCompletionFailureHandler.instance(context);
 235         names = Names.instance(context);
 236         enter = Enter.instance(context);
 237         initialCompleter = ClassFinder.instance(context).getCompleter();
 238         chk = Check.instance(context);

 239         initProcessorLoader();
 240     }
 241 
 242     public void setProcessors(Iterable&lt;? extends Processor&gt; processors) {
 243         Assert.checkNull(discoveredProcs);
 244         initProcessorIterator(processors);
 245     }
 246 
 247     private Set&lt;String&gt; initPlatformAnnotations() {
 248         final String module_prefix =
 249             Feature.MODULES.allowedInSource(source) ? &quot;java.base/&quot; : &quot;&quot;;
 250         return Set.of(module_prefix + &quot;java.lang.Deprecated&quot;,
 251                       module_prefix + &quot;java.lang.FunctionalInterface&quot;,
 252                       module_prefix + &quot;java.lang.Override&quot;,
 253                       module_prefix + &quot;java.lang.SafeVarargs&quot;,
 254                       module_prefix + &quot;java.lang.SuppressWarnings&quot;,
 255 
 256                       module_prefix + &quot;java.lang.annotation.Documented&quot;,
 257                       module_prefix + &quot;java.lang.annotation.Inherited&quot;,
 258                       module_prefix + &quot;java.lang.annotation.Native&quot;,
 259                       module_prefix + &quot;java.lang.annotation.Repeatable&quot;,
 260                       module_prefix + &quot;java.lang.annotation.Retention&quot;,
<span class="line-modified"> 261                       module_prefix + &quot;java.lang.annotation.Target&quot;);</span>


 262     }
 263 
 264     private void initProcessorLoader() {
 265         try {
 266             if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {
 267                 try {
 268                     serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);
 269                 } catch (IOException e) {
 270                     throw new Abort(e);
 271                 }
 272             } else {
 273                 // If processorpath is not explicitly set, use the classpath.
 274                 processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)
 275                     ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)
 276                     : fileManager.getClassLoader(CLASS_PATH);
 277 
 278                 if (options.isSet(&quot;accessInternalAPI&quot;))
 279                     ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());
 280 
 281                 if (processorClassLoader != null &amp;&amp; processorClassLoader instanceof Closeable) {
</pre>
<hr />
<pre>
 421                 }
 422             } catch (Throwable t) {
 423                 log.error(Errors.ProcServiceProblem);
 424                 throw new Abort(t);
 425             }
 426         }
 427 
 428         ServiceIterator(ServiceLoader&lt;Processor&gt; loader, Log log) {
 429             this.log = log;
 430             this.loader = loader;
 431             this.iterator = loader.iterator();
 432         }
 433 
 434         @Override
 435         public boolean hasNext() {
 436             try {
 437                 return internalHasNext();
 438             } catch(ServiceConfigurationError sce) {
 439                 log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
 440                 throw new Abort(sce);






 441             } catch (Throwable t) {

 442                 throw new Abort(t);
 443             }
 444         }
 445 
 446         boolean internalHasNext() {
 447             return iterator.hasNext();
 448         }
 449 
 450         @Override
 451         public Processor next() {
 452             try {
 453                 return internalNext();
 454             } catch (ServiceConfigurationError sce) {
 455                 log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
 456                 throw new Abort(sce);
 457             } catch (Throwable t) {

 458                 throw new Abort(t);
 459             }
 460         }
 461 
 462         Processor internalNext() {
 463             return iterator.next();
 464         }
 465 
 466         @Override
 467         public void remove() {
 468             throw new UnsupportedOperationException();
 469         }
 470 
 471         public void close() {
 472             if (loader != null) {
 473                 try {
 474                     loader.reload();
 475                 } catch(Exception e) {
 476                     // Ignore problems during a call to reload.
 477                 }
</pre>
<hr />
<pre>
 655         return Collections.unmodifiableMap(tempOptions);
 656     }
 657 
 658     private Set&lt;String&gt; initUnmatchedProcessorOptions() {
 659         Set&lt;String&gt; unmatchedProcessorOptions = new HashSet&lt;&gt;();
 660         unmatchedProcessorOptions.addAll(processorOptions.keySet());
 661         return unmatchedProcessorOptions;
 662     }
 663 
 664     /**
 665      * State about how a processor has been used by the tool.  If a
 666      * processor has been used on a prior round, its process method is
 667      * called on all subsequent rounds, perhaps with an empty set of
 668      * annotations to process.  The {@code annotationSupported} method
 669      * caches the supported annotation information from the first (and
 670      * only) getSupportedAnnotationTypes call to the processor.
 671      */
 672     static class ProcessorState {
 673         public Processor processor;
 674         public boolean   contributed;
<span class="line-modified"> 675         private ArrayList&lt;Pattern&gt; supportedAnnotationPatterns;</span>
<span class="line-modified"> 676         private ArrayList&lt;String&gt;  supportedOptionNames;</span>

 677 
 678         ProcessorState(Processor p, Log log, Source source, DeferredCompletionFailureHandler dcfh,
<span class="line-modified"> 679                        boolean allowModules, ProcessingEnvironment env) {</span>
 680             processor = p;
 681             contributed = false;
 682 
 683             Handler prevDeferredHandler = dcfh.setHandler(dcfh.userCodeHandler);
 684             try {
 685                 processor.init(env);
 686 
 687                 checkSourceVersionCompatibility(source, log);
 688 
<span class="line-modified"> 689                 supportedAnnotationPatterns = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 690                 for (String importString : processor.getSupportedAnnotationTypes()) {</span>
<span class="line-modified"> 691                     supportedAnnotationPatterns.add(importStringToPattern(allowModules,</span>
<span class="line-modified"> 692                                                                           importString,</span>
<span class="line-modified"> 693                                                                           processor,</span>
<span class="line-modified"> 694                                                                           log));</span>























 695                 }
 696 
<span class="line-modified"> 697                 supportedOptionNames = new ArrayList&lt;&gt;();</span>
 698                 for (String optionName : processor.getSupportedOptions() ) {
<span class="line-modified"> 699                     if (checkOptionName(optionName, log))</span>
<span class="line-modified"> 700                         supportedOptionNames.add(optionName);</span>





 701                 }
 702 
 703             } catch (ClientCodeException e) {
 704                 throw e;
 705             } catch (Throwable t) {
 706                 throw new AnnotationProcessingError(t);
 707             } finally {
 708                 dcfh.setHandler(prevDeferredHandler);
 709             }
 710         }
 711 
 712         /**
 713          * Checks whether or not a processor&#39;s source version is
 714          * compatible with the compilation source version.  The
 715          * processor&#39;s source version needs to be greater than or
 716          * equal to the source version of the compile.
 717          */
 718         private void checkSourceVersionCompatibility(Source source, Log log) {
 719             SourceVersion procSourceVersion = processor.getSupportedSourceVersion();
<span class="line-removed"> 720 </span>
 721             if (procSourceVersion.compareTo(Source.toSourceVersion(source)) &lt; 0 )  {
 722                 log.warning(Warnings.ProcProcessorIncompatibleSourceVersion(procSourceVersion,
 723                                                                             processor.getClass().getName(),
 724                                                                             source.name));
 725             }
 726         }
 727 
 728         private boolean checkOptionName(String optionName, Log log) {
 729             boolean valid = isValidOptionName(optionName);
 730             if (!valid)
 731                 log.error(Errors.ProcProcessorBadOptionName(optionName,
 732                                                             processor.getClass().getName()));
 733             return valid;
 734         }
 735 
 736         public boolean annotationSupported(String annotationName) {
 737             for(Pattern p: supportedAnnotationPatterns) {
 738                 if (p.matcher(annotationName).matches())
 739                     return true;
 740             }
</pre>
<hr />
<pre>
 746          */
 747         public void removeSupportedOptions(Set&lt;String&gt; unmatchedProcessorOptions) {
 748             unmatchedProcessorOptions.removeAll(supportedOptionNames);
 749         }
 750     }
 751 
 752     // TODO: These two classes can probably be rewritten better...
 753     /**
 754      * This class holds information about the processors that have
 755      * been discovered so far as well as the means to discover more, if
 756      * necessary.  A single iterator should be used per round of
 757      * annotation processing.  The iterator first visits already
 758      * discovered processors then fails over to the service provider
 759      * mechanism if additional queries are made.
 760      */
 761     class DiscoveredProcessors implements Iterable&lt;ProcessorState&gt; {
 762 
 763         class ProcessorStateIterator implements Iterator&lt;ProcessorState&gt; {
 764             DiscoveredProcessors psi;
 765             Iterator&lt;ProcessorState&gt; innerIter;
<span class="line-modified"> 766             boolean onProcInterator;</span>
 767 
 768             ProcessorStateIterator(DiscoveredProcessors psi) {
 769                 this.psi = psi;
 770                 this.innerIter = psi.procStateList.iterator();
<span class="line-modified"> 771                 this.onProcInterator = false;</span>
 772             }
 773 
 774             public ProcessorState next() {
<span class="line-modified"> 775                 if (!onProcInterator) {</span>
 776                     if (innerIter.hasNext())
 777                         return innerIter.next();
 778                     else
<span class="line-modified"> 779                         onProcInterator = true;</span>
 780                 }
 781 
 782                 if (psi.processorIterator.hasNext()) {
 783                     ProcessorState ps = new ProcessorState(psi.processorIterator.next(),
 784                                                            log, source, dcfh,
 785                                                            Feature.MODULES.allowedInSource(source),
<span class="line-modified"> 786                                                            JavacProcessingEnvironment.this);</span>

 787                     psi.procStateList.add(ps);
 788                     return ps;
 789                 } else
 790                     throw new NoSuchElementException();
 791             }
 792 
 793             public boolean hasNext() {
<span class="line-modified"> 794                 if (onProcInterator)</span>
 795                     return  psi.processorIterator.hasNext();
 796                 else
 797                     return innerIter.hasNext() || psi.processorIterator.hasNext();
 798             }
 799 
 800             public void remove () {
 801                 throw new UnsupportedOperationException();
 802             }
 803 
 804             /**
 805              * Run all remaining processors on the procStateList that
 806              * have not already run this round with an empty set of
 807              * annotations.
 808              */
 809             public void runContributingProcs(RoundEnvironment re) {
<span class="line-modified"> 810                 if (!onProcInterator) {</span>
 811                     Set&lt;TypeElement&gt; emptyTypeElements = Collections.emptySet();
 812                     while(innerIter.hasNext()) {
 813                         ProcessorState ps = innerIter.next();
 814                         if (ps.contributed)
 815                             callProcessor(ps.processor, emptyTypeElements, re);
 816                     }
 817                 }
 818             }
 819         }
 820 
 821         Iterator&lt;? extends Processor&gt; processorIterator;
 822         ArrayList&lt;ProcessorState&gt;  procStateList;
 823 
 824         public ProcessorStateIterator iterator() {
 825             return new ProcessorStateIterator(this);
 826         }
 827 
 828         DiscoveredProcessors(Iterator&lt;? extends Processor&gt; processorIterator) {
 829             this.processorIterator = processorIterator;
 830             this.procStateList = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
 910             }
 911         }
 912         unmatchedAnnotations.remove(&quot;&quot;);
 913 
 914         if (lint &amp;&amp; unmatchedAnnotations.size() &gt; 0) {
 915             // Remove annotations processed by javac
 916             unmatchedAnnotations.keySet().removeAll(platformAnnotations);
 917             if (unmatchedAnnotations.size() &gt; 0) {
 918                 log.warning(Warnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));
 919             }
 920         }
 921 
 922         // Run contributing processors that haven&#39;t run yet
 923         psi.runContributingProcs(renv);
 924     }
 925 
 926     /**
 927      * Computes the set of annotations on the symbol in question.
 928      * Leave class public for external testing purposes.
 929      */

 930     public static class ComputeAnnotationSet extends
<span class="line-modified"> 931         ElementScanner9&lt;Set&lt;TypeElement&gt;, Set&lt;TypeElement&gt;&gt; {</span>
 932         final Elements elements;
 933 
 934         public ComputeAnnotationSet(Elements elements) {
 935             super();
 936             this.elements = elements;
 937         }
 938 
 939         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 940         public Set&lt;TypeElement&gt; visitPackage(PackageElement e, Set&lt;TypeElement&gt; p) {
 941             // Don&#39;t scan enclosed elements of a package
 942             return p;
 943         }
 944 
 945         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 946         public Set&lt;TypeElement&gt; visitType(TypeElement e, Set&lt;TypeElement&gt; p) {
 947             // Type parameters are not considered to be enclosed by a type
 948             scan(e.getTypeParameters(), p);
 949             return super.visitType(e, p);
 950         }
 951 
</pre>
<hr />
<pre>
1098             packageInfoFiles = join(
1099                     getPackageInfoFiles(parsedFiles),
1100                     getPackageInfoFilesFromClasses(newClasses));
1101 
1102             moduleInfoFiles = List.nil(); //module-info cannot be generated
1103 
1104             findAnnotationsPresent();
1105         }
1106 
1107         /** Create the next round to be used. */
1108         Round next(Set&lt;JavaFileObject&gt; newSourceFiles, Map&lt;ModuleSymbol, Map&lt;String, JavaFileObject&gt;&gt; newClassFiles) {
1109             return new Round(this, newSourceFiles, newClassFiles);
1110         }
1111 
1112         /** Prepare the compiler for the final compilation. */
1113         void finalCompiler() {
1114             newRound();
1115         }
1116 
1117         /** Return the number of errors found so far in this round.
<span class="line-modified">1118          * This may include uncoverable errors, such as parse errors,</span>
1119          * and transient errors, such as missing symbols. */
1120         int errorCount() {
1121             return compiler.errorCount();
1122         }
1123 
1124         /** Return the number of warnings found so far in this round. */
1125         int warningCount() {
1126             return compiler.warningCount();
1127         }
1128 
1129         /** Return whether or not an unrecoverable error has occurred. */
1130         boolean unrecoverableError() {
1131             if (messager.errorRaised())
1132                 return true;
1133 
1134             for (JCDiagnostic d: deferredDiagnosticHandler.getDiagnostics()) {
1135                 switch (d.getKind()) {
1136                     case WARNING:
1137                         if (werror)
1138                             return true;
</pre>
<hr />
<pre>
1451             if (isPkgInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE)) {
1452                 packages = packages.prepend(unit.packge);
1453             }
1454         }
1455         return packages.reverse();
1456     }
1457 
1458     private List&lt;PackageSymbol&gt; getPackageInfoFilesFromClasses(List&lt;? extends ClassSymbol&gt; syms) {
1459         List&lt;PackageSymbol&gt; packages = List.nil();
1460         for (ClassSymbol sym : syms) {
1461             if (isPkgInfo(sym)) {
1462                 packages = packages.prepend((PackageSymbol) sym.owner);
1463             }
1464         }
1465         return packages.reverse();
1466     }
1467 
1468     private List&lt;ModuleSymbol&gt; getModuleInfoFiles(List&lt;? extends JCCompilationUnit&gt; units) {
1469         List&lt;ModuleSymbol&gt; modules = List.nil();
1470         for (JCCompilationUnit unit : units) {
<span class="line-modified">1471             if (isModuleInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE) &amp;&amp;</span>
<span class="line-modified">1472                 unit.defs.nonEmpty() &amp;&amp;</span>
<span class="line-modified">1473                 unit.defs.head.hasTag(Tag.MODULEDEF)) {</span>
<span class="line-modified">1474                 modules = modules.prepend(unit.modle);</span>









1475             }
1476         }
1477         return modules.reverse();
1478     }
1479 
1480     // avoid unchecked warning from use of varargs
1481     private static &lt;T&gt; List&lt;T&gt; join(List&lt;T&gt; list1, List&lt;T&gt; list2) {
1482         return list1.appendList(list2);
1483     }
1484 
1485     private boolean isPkgInfo(JavaFileObject fo, JavaFileObject.Kind kind) {
1486         return fo.isNameCompatible(&quot;package-info&quot;, kind);
1487     }
1488 
1489     private boolean isPkgInfo(ClassSymbol sym) {
1490         return isPkgInfo(sym.classfile, JavaFileObject.Kind.CLASS) &amp;&amp; (sym.packge().package_info == sym);
1491     }
1492 
1493     private boolean isModuleInfo(JavaFileObject fo, JavaFileObject.Kind kind) {
1494         return fo.isNameCompatible(&quot;module-info&quot;, kind);
</pre>
<hr />
<pre>
1658     @DefinedBy(Api.ANNOTATION_PROCESSING)
1659     public JavacElements getElementUtils() {
1660         return elementUtils;
1661     }
1662 
1663     @DefinedBy(Api.ANNOTATION_PROCESSING)
1664     public JavacTypes getTypeUtils() {
1665         return typeUtils;
1666     }
1667 
1668     @DefinedBy(Api.ANNOTATION_PROCESSING)
1669     public SourceVersion getSourceVersion() {
1670         return Source.toSourceVersion(source);
1671     }
1672 
1673     @DefinedBy(Api.ANNOTATION_PROCESSING)
1674     public Locale getLocale() {
1675         return messages.getCurrentLocale();
1676     }
1677 





1678     public Set&lt;Symbol.PackageSymbol&gt; getSpecifiedPackages() {
1679         return specifiedPackages;
1680     }
1681 
1682     public static final Pattern noMatches  = Pattern.compile(&quot;(\\P{all})+&quot;);
1683 
1684     /**
1685      * Convert import-style string for supported annotations into a
1686      * regex matching that string.  If the string is not a valid
1687      * import-style string, return a regex that won&#39;t match anything.
1688      */
<span class="line-modified">1689     private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {</span>
1690         String module;
1691         String pkg;
1692         int slash = s.indexOf(&#39;/&#39;);
1693         if (slash == (-1)) {
1694             if (s.equals(&quot;*&quot;)) {
1695                 return MatchingUtils.validImportStringToPattern(s);
1696             }
1697             module = allowModules ? &quot;.*/&quot; : &quot;&quot;;
1698             pkg = s;
1699         } else {
<span class="line-modified">1700             module = Pattern.quote(s.substring(0, slash + 1));</span>





1701             pkg = s.substring(slash + 1);
1702         }
1703         if (MatchingUtils.isValidImportString(pkg)) {
1704             return Pattern.compile(module + MatchingUtils.validImportStringToPatternString(pkg));
1705         } else {






1706             log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));
<span class="line-removed">1707             return noMatches; // won&#39;t match any valid identifier</span>
1708         }

1709     }
1710 
1711     /**
1712      * For internal use only.  This method may be removed without warning.
1713      */
1714     public Context getContext() {
1715         return context;
1716     }
1717 
1718     /**
1719      * For internal use only.  This method may be removed without warning.
1720      */
1721     public ClassLoader getProcessorClassLoader() {
1722         return processorClassLoader;
1723     }
1724 
1725     public String toString() {
1726         return &quot;javac ProcessingEnvironment&quot;;
1727     }
1728 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 171     private ServiceLoader&lt;Processor&gt; serviceLoader;
 172     private SecurityException processorLoaderException;
 173 
 174     private final JavaFileManager fileManager;
 175 
 176     /**
 177      * JavacMessages object used for localization
 178      */
 179     private JavacMessages messages;
 180 
 181     private MultiTaskListener taskListener;
 182     private final Symtab symtab;
 183     private final DeferredCompletionFailureHandler dcfh;
 184     private final Names names;
 185     private final Enter enter;
 186     private final Completer initialCompleter;
 187     private final Check chk;
 188 
 189     private final Context context;
 190 
<span class="line-added"> 191     /**</span>
<span class="line-added"> 192      * Support for preview language features.</span>
<span class="line-added"> 193      */</span>
<span class="line-added"> 194     private final Preview preview;</span>
<span class="line-added"> 195 </span>
 196     /** Get the JavacProcessingEnvironment instance for this context. */
 197     public static JavacProcessingEnvironment instance(Context context) {
 198         JavacProcessingEnvironment instance = context.get(JavacProcessingEnvironment.class);
 199         if (instance == null)
 200             instance = new JavacProcessingEnvironment(context);
 201         return instance;
 202     }
 203 
 204     protected JavacProcessingEnvironment(Context context) {
 205         this.context = context;
 206         context.put(JavacProcessingEnvironment.class, this);
 207         log = Log.instance(context);
 208         source = Source.instance(context);
 209         diags = JCDiagnostic.Factory.instance(context);
 210         options = Options.instance(context);
 211         printProcessorInfo = options.isSet(Option.XPRINTPROCESSORINFO);
 212         printRounds = options.isSet(Option.XPRINTROUNDS);
 213         verbose = options.isSet(Option.VERBOSE);
 214         lint = Lint.instance(context).isEnabled(PROCESSING);
 215         compiler = JavaCompiler.instance(context);
</pre>
<hr />
<pre>
 224 
 225         // Initialize services before any processors are initialized
 226         // in case processors use them.
 227         filer = new JavacFiler(context);
 228         messager = new JavacMessager(context, this);
 229         elementUtils = JavacElements.instance(context);
 230         typeUtils = JavacTypes.instance(context);
 231         modules = Modules.instance(context);
 232         types = Types.instance(context);
 233         annotate = Annotate.instance(context);
 234         processorOptions = initProcessorOptions();
 235         unmatchedProcessorOptions = initUnmatchedProcessorOptions();
 236         messages = JavacMessages.instance(context);
 237         taskListener = MultiTaskListener.instance(context);
 238         symtab = Symtab.instance(context);
 239         dcfh = DeferredCompletionFailureHandler.instance(context);
 240         names = Names.instance(context);
 241         enter = Enter.instance(context);
 242         initialCompleter = ClassFinder.instance(context).getCompleter();
 243         chk = Check.instance(context);
<span class="line-added"> 244         preview = Preview.instance(context);</span>
 245         initProcessorLoader();
 246     }
 247 
 248     public void setProcessors(Iterable&lt;? extends Processor&gt; processors) {
 249         Assert.checkNull(discoveredProcs);
 250         initProcessorIterator(processors);
 251     }
 252 
 253     private Set&lt;String&gt; initPlatformAnnotations() {
 254         final String module_prefix =
 255             Feature.MODULES.allowedInSource(source) ? &quot;java.base/&quot; : &quot;&quot;;
 256         return Set.of(module_prefix + &quot;java.lang.Deprecated&quot;,
 257                       module_prefix + &quot;java.lang.FunctionalInterface&quot;,
 258                       module_prefix + &quot;java.lang.Override&quot;,
 259                       module_prefix + &quot;java.lang.SafeVarargs&quot;,
 260                       module_prefix + &quot;java.lang.SuppressWarnings&quot;,
 261 
 262                       module_prefix + &quot;java.lang.annotation.Documented&quot;,
 263                       module_prefix + &quot;java.lang.annotation.Inherited&quot;,
 264                       module_prefix + &quot;java.lang.annotation.Native&quot;,
 265                       module_prefix + &quot;java.lang.annotation.Repeatable&quot;,
 266                       module_prefix + &quot;java.lang.annotation.Retention&quot;,
<span class="line-modified"> 267                       module_prefix + &quot;java.lang.annotation.Target&quot;,</span>
<span class="line-added"> 268 </span>
<span class="line-added"> 269                       module_prefix + &quot;java.io.Serial&quot;);</span>
 270     }
 271 
 272     private void initProcessorLoader() {
 273         try {
 274             if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {
 275                 try {
 276                     serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);
 277                 } catch (IOException e) {
 278                     throw new Abort(e);
 279                 }
 280             } else {
 281                 // If processorpath is not explicitly set, use the classpath.
 282                 processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)
 283                     ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)
 284                     : fileManager.getClassLoader(CLASS_PATH);
 285 
 286                 if (options.isSet(&quot;accessInternalAPI&quot;))
 287                     ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());
 288 
 289                 if (processorClassLoader != null &amp;&amp; processorClassLoader instanceof Closeable) {
</pre>
<hr />
<pre>
 429                 }
 430             } catch (Throwable t) {
 431                 log.error(Errors.ProcServiceProblem);
 432                 throw new Abort(t);
 433             }
 434         }
 435 
 436         ServiceIterator(ServiceLoader&lt;Processor&gt; loader, Log log) {
 437             this.log = log;
 438             this.loader = loader;
 439             this.iterator = loader.iterator();
 440         }
 441 
 442         @Override
 443         public boolean hasNext() {
 444             try {
 445                 return internalHasNext();
 446             } catch(ServiceConfigurationError sce) {
 447                 log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
 448                 throw new Abort(sce);
<span class="line-added"> 449             } catch (UnsupportedClassVersionError ucve) {</span>
<span class="line-added"> 450                 log.error(Errors.ProcCantLoadClass(ucve.getLocalizedMessage()));</span>
<span class="line-added"> 451                 throw new Abort(ucve);</span>
<span class="line-added"> 452             } catch (ClassFormatError cfe) {</span>
<span class="line-added"> 453                 log.error(Errors.ProcCantLoadClass(cfe.getLocalizedMessage()));</span>
<span class="line-added"> 454                 throw new Abort(cfe);</span>
 455             } catch (Throwable t) {
<span class="line-added"> 456                 log.error(Errors.ProcBadConfigFile(t.getLocalizedMessage()));</span>
 457                 throw new Abort(t);
 458             }
 459         }
 460 
 461         boolean internalHasNext() {
 462             return iterator.hasNext();
 463         }
 464 
 465         @Override
 466         public Processor next() {
 467             try {
 468                 return internalNext();
 469             } catch (ServiceConfigurationError sce) {
 470                 log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
 471                 throw new Abort(sce);
 472             } catch (Throwable t) {
<span class="line-added"> 473                 log.error(Errors.ProcBadConfigFile(t.getLocalizedMessage()));</span>
 474                 throw new Abort(t);
 475             }
 476         }
 477 
 478         Processor internalNext() {
 479             return iterator.next();
 480         }
 481 
 482         @Override
 483         public void remove() {
 484             throw new UnsupportedOperationException();
 485         }
 486 
 487         public void close() {
 488             if (loader != null) {
 489                 try {
 490                     loader.reload();
 491                 } catch(Exception e) {
 492                     // Ignore problems during a call to reload.
 493                 }
</pre>
<hr />
<pre>
 671         return Collections.unmodifiableMap(tempOptions);
 672     }
 673 
 674     private Set&lt;String&gt; initUnmatchedProcessorOptions() {
 675         Set&lt;String&gt; unmatchedProcessorOptions = new HashSet&lt;&gt;();
 676         unmatchedProcessorOptions.addAll(processorOptions.keySet());
 677         return unmatchedProcessorOptions;
 678     }
 679 
 680     /**
 681      * State about how a processor has been used by the tool.  If a
 682      * processor has been used on a prior round, its process method is
 683      * called on all subsequent rounds, perhaps with an empty set of
 684      * annotations to process.  The {@code annotationSupported} method
 685      * caches the supported annotation information from the first (and
 686      * only) getSupportedAnnotationTypes call to the processor.
 687      */
 688     static class ProcessorState {
 689         public Processor processor;
 690         public boolean   contributed;
<span class="line-modified"> 691         private Set&lt;String&gt; supportedAnnotationStrings; // Used for warning generation</span>
<span class="line-modified"> 692         private Set&lt;Pattern&gt; supportedAnnotationPatterns;</span>
<span class="line-added"> 693         private Set&lt;String&gt; supportedOptionNames;</span>
 694 
 695         ProcessorState(Processor p, Log log, Source source, DeferredCompletionFailureHandler dcfh,
<span class="line-modified"> 696                        boolean allowModules, ProcessingEnvironment env, boolean lint) {</span>
 697             processor = p;
 698             contributed = false;
 699 
 700             Handler prevDeferredHandler = dcfh.setHandler(dcfh.userCodeHandler);
 701             try {
 702                 processor.init(env);
 703 
 704                 checkSourceVersionCompatibility(source, log);
 705 
<span class="line-modified"> 706 </span>
<span class="line-modified"> 707                 // Check for direct duplicates in the strings of</span>
<span class="line-modified"> 708                 // supported annotation types. Do not check for</span>
<span class="line-modified"> 709                 // duplicates that would result after stripping of</span>
<span class="line-modified"> 710                 // module prefixes.</span>
<span class="line-modified"> 711                 supportedAnnotationStrings = new LinkedHashSet&lt;&gt;();</span>
<span class="line-added"> 712                 supportedAnnotationPatterns = new LinkedHashSet&lt;&gt;();</span>
<span class="line-added"> 713                 for (String annotationPattern : processor.getSupportedAnnotationTypes()) {</span>
<span class="line-added"> 714                     boolean patternAdded = supportedAnnotationStrings.add(annotationPattern);</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716                     supportedAnnotationPatterns.</span>
<span class="line-added"> 717                         add(importStringToPattern(allowModules, annotationPattern,</span>
<span class="line-added"> 718                                                   processor, log, lint));</span>
<span class="line-added"> 719                     if (lint &amp;&amp; !patternAdded) {</span>
<span class="line-added"> 720                         log.warning(Warnings.ProcDuplicateSupportedAnnotation(annotationPattern,</span>
<span class="line-added"> 721                                                                               p.getClass().getName()));</span>
<span class="line-added"> 722                     }</span>
<span class="line-added"> 723                 }</span>
<span class="line-added"> 724 </span>
<span class="line-added"> 725                 // If a processor supports &quot;*&quot;, that matches</span>
<span class="line-added"> 726                 // everything and other entries are redundant. With</span>
<span class="line-added"> 727                 // more work, it could be checked that the supported</span>
<span class="line-added"> 728                 // annotation types were otherwise non-overlapping</span>
<span class="line-added"> 729                 // with each other in other cases, for example &quot;foo.*&quot;</span>
<span class="line-added"> 730                 // and &quot;foo.bar.*&quot;.</span>
<span class="line-added"> 731                 if (lint &amp;&amp;</span>
<span class="line-added"> 732                     supportedAnnotationPatterns.contains(MatchingUtils.validImportStringToPattern(&quot;*&quot;)) &amp;&amp;</span>
<span class="line-added"> 733                     supportedAnnotationPatterns.size() &gt; 1) {</span>
<span class="line-added"> 734                     log.warning(Warnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));</span>
 735                 }
 736 
<span class="line-modified"> 737                 supportedOptionNames = new LinkedHashSet&lt;&gt;();</span>
 738                 for (String optionName : processor.getSupportedOptions() ) {
<span class="line-modified"> 739                     if (checkOptionName(optionName, log)) {</span>
<span class="line-modified"> 740                         boolean optionAdded = supportedOptionNames.add(optionName);</span>
<span class="line-added"> 741                         if (lint &amp;&amp; !optionAdded) {</span>
<span class="line-added"> 742                             log.warning(Warnings.ProcDuplicateOptionName(optionName,</span>
<span class="line-added"> 743                                                                          p.getClass().getName()));</span>
<span class="line-added"> 744                         }</span>
<span class="line-added"> 745                     }</span>
 746                 }
 747 
 748             } catch (ClientCodeException e) {
 749                 throw e;
 750             } catch (Throwable t) {
 751                 throw new AnnotationProcessingError(t);
 752             } finally {
 753                 dcfh.setHandler(prevDeferredHandler);
 754             }
 755         }
 756 
 757         /**
 758          * Checks whether or not a processor&#39;s source version is
 759          * compatible with the compilation source version.  The
 760          * processor&#39;s source version needs to be greater than or
 761          * equal to the source version of the compile.
 762          */
 763         private void checkSourceVersionCompatibility(Source source, Log log) {
 764             SourceVersion procSourceVersion = processor.getSupportedSourceVersion();

 765             if (procSourceVersion.compareTo(Source.toSourceVersion(source)) &lt; 0 )  {
 766                 log.warning(Warnings.ProcProcessorIncompatibleSourceVersion(procSourceVersion,
 767                                                                             processor.getClass().getName(),
 768                                                                             source.name));
 769             }
 770         }
 771 
 772         private boolean checkOptionName(String optionName, Log log) {
 773             boolean valid = isValidOptionName(optionName);
 774             if (!valid)
 775                 log.error(Errors.ProcProcessorBadOptionName(optionName,
 776                                                             processor.getClass().getName()));
 777             return valid;
 778         }
 779 
 780         public boolean annotationSupported(String annotationName) {
 781             for(Pattern p: supportedAnnotationPatterns) {
 782                 if (p.matcher(annotationName).matches())
 783                     return true;
 784             }
</pre>
<hr />
<pre>
 790          */
 791         public void removeSupportedOptions(Set&lt;String&gt; unmatchedProcessorOptions) {
 792             unmatchedProcessorOptions.removeAll(supportedOptionNames);
 793         }
 794     }
 795 
 796     // TODO: These two classes can probably be rewritten better...
 797     /**
 798      * This class holds information about the processors that have
 799      * been discovered so far as well as the means to discover more, if
 800      * necessary.  A single iterator should be used per round of
 801      * annotation processing.  The iterator first visits already
 802      * discovered processors then fails over to the service provider
 803      * mechanism if additional queries are made.
 804      */
 805     class DiscoveredProcessors implements Iterable&lt;ProcessorState&gt; {
 806 
 807         class ProcessorStateIterator implements Iterator&lt;ProcessorState&gt; {
 808             DiscoveredProcessors psi;
 809             Iterator&lt;ProcessorState&gt; innerIter;
<span class="line-modified"> 810             boolean onProcIterator;</span>
 811 
 812             ProcessorStateIterator(DiscoveredProcessors psi) {
 813                 this.psi = psi;
 814                 this.innerIter = psi.procStateList.iterator();
<span class="line-modified"> 815                 this.onProcIterator = false;</span>
 816             }
 817 
 818             public ProcessorState next() {
<span class="line-modified"> 819                 if (!onProcIterator) {</span>
 820                     if (innerIter.hasNext())
 821                         return innerIter.next();
 822                     else
<span class="line-modified"> 823                         onProcIterator = true;</span>
 824                 }
 825 
 826                 if (psi.processorIterator.hasNext()) {
 827                     ProcessorState ps = new ProcessorState(psi.processorIterator.next(),
 828                                                            log, source, dcfh,
 829                                                            Feature.MODULES.allowedInSource(source),
<span class="line-modified"> 830                                                            JavacProcessingEnvironment.this,</span>
<span class="line-added"> 831                                                            lint);</span>
 832                     psi.procStateList.add(ps);
 833                     return ps;
 834                 } else
 835                     throw new NoSuchElementException();
 836             }
 837 
 838             public boolean hasNext() {
<span class="line-modified"> 839                 if (onProcIterator)</span>
 840                     return  psi.processorIterator.hasNext();
 841                 else
 842                     return innerIter.hasNext() || psi.processorIterator.hasNext();
 843             }
 844 
 845             public void remove () {
 846                 throw new UnsupportedOperationException();
 847             }
 848 
 849             /**
 850              * Run all remaining processors on the procStateList that
 851              * have not already run this round with an empty set of
 852              * annotations.
 853              */
 854             public void runContributingProcs(RoundEnvironment re) {
<span class="line-modified"> 855                 if (!onProcIterator) {</span>
 856                     Set&lt;TypeElement&gt; emptyTypeElements = Collections.emptySet();
 857                     while(innerIter.hasNext()) {
 858                         ProcessorState ps = innerIter.next();
 859                         if (ps.contributed)
 860                             callProcessor(ps.processor, emptyTypeElements, re);
 861                     }
 862                 }
 863             }
 864         }
 865 
 866         Iterator&lt;? extends Processor&gt; processorIterator;
 867         ArrayList&lt;ProcessorState&gt;  procStateList;
 868 
 869         public ProcessorStateIterator iterator() {
 870             return new ProcessorStateIterator(this);
 871         }
 872 
 873         DiscoveredProcessors(Iterator&lt;? extends Processor&gt; processorIterator) {
 874             this.processorIterator = processorIterator;
 875             this.procStateList = new ArrayList&lt;&gt;();
</pre>
<hr />
<pre>
 955             }
 956         }
 957         unmatchedAnnotations.remove(&quot;&quot;);
 958 
 959         if (lint &amp;&amp; unmatchedAnnotations.size() &gt; 0) {
 960             // Remove annotations processed by javac
 961             unmatchedAnnotations.keySet().removeAll(platformAnnotations);
 962             if (unmatchedAnnotations.size() &gt; 0) {
 963                 log.warning(Warnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));
 964             }
 965         }
 966 
 967         // Run contributing processors that haven&#39;t run yet
 968         psi.runContributingProcs(renv);
 969     }
 970 
 971     /**
 972      * Computes the set of annotations on the symbol in question.
 973      * Leave class public for external testing purposes.
 974      */
<span class="line-added"> 975     @SuppressWarnings(&quot;preview&quot;)</span>
 976     public static class ComputeAnnotationSet extends
<span class="line-modified"> 977         ElementScanner14&lt;Set&lt;TypeElement&gt;, Set&lt;TypeElement&gt;&gt; {</span>
 978         final Elements elements;
 979 
 980         public ComputeAnnotationSet(Elements elements) {
 981             super();
 982             this.elements = elements;
 983         }
 984 
 985         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 986         public Set&lt;TypeElement&gt; visitPackage(PackageElement e, Set&lt;TypeElement&gt; p) {
 987             // Don&#39;t scan enclosed elements of a package
 988             return p;
 989         }
 990 
 991         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 992         public Set&lt;TypeElement&gt; visitType(TypeElement e, Set&lt;TypeElement&gt; p) {
 993             // Type parameters are not considered to be enclosed by a type
 994             scan(e.getTypeParameters(), p);
 995             return super.visitType(e, p);
 996         }
 997 
</pre>
<hr />
<pre>
1144             packageInfoFiles = join(
1145                     getPackageInfoFiles(parsedFiles),
1146                     getPackageInfoFilesFromClasses(newClasses));
1147 
1148             moduleInfoFiles = List.nil(); //module-info cannot be generated
1149 
1150             findAnnotationsPresent();
1151         }
1152 
1153         /** Create the next round to be used. */
1154         Round next(Set&lt;JavaFileObject&gt; newSourceFiles, Map&lt;ModuleSymbol, Map&lt;String, JavaFileObject&gt;&gt; newClassFiles) {
1155             return new Round(this, newSourceFiles, newClassFiles);
1156         }
1157 
1158         /** Prepare the compiler for the final compilation. */
1159         void finalCompiler() {
1160             newRound();
1161         }
1162 
1163         /** Return the number of errors found so far in this round.
<span class="line-modified">1164          * This may include unrecoverable errors, such as parse errors,</span>
1165          * and transient errors, such as missing symbols. */
1166         int errorCount() {
1167             return compiler.errorCount();
1168         }
1169 
1170         /** Return the number of warnings found so far in this round. */
1171         int warningCount() {
1172             return compiler.warningCount();
1173         }
1174 
1175         /** Return whether or not an unrecoverable error has occurred. */
1176         boolean unrecoverableError() {
1177             if (messager.errorRaised())
1178                 return true;
1179 
1180             for (JCDiagnostic d: deferredDiagnosticHandler.getDiagnostics()) {
1181                 switch (d.getKind()) {
1182                     case WARNING:
1183                         if (werror)
1184                             return true;
</pre>
<hr />
<pre>
1497             if (isPkgInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE)) {
1498                 packages = packages.prepend(unit.packge);
1499             }
1500         }
1501         return packages.reverse();
1502     }
1503 
1504     private List&lt;PackageSymbol&gt; getPackageInfoFilesFromClasses(List&lt;? extends ClassSymbol&gt; syms) {
1505         List&lt;PackageSymbol&gt; packages = List.nil();
1506         for (ClassSymbol sym : syms) {
1507             if (isPkgInfo(sym)) {
1508                 packages = packages.prepend((PackageSymbol) sym.owner);
1509             }
1510         }
1511         return packages.reverse();
1512     }
1513 
1514     private List&lt;ModuleSymbol&gt; getModuleInfoFiles(List&lt;? extends JCCompilationUnit&gt; units) {
1515         List&lt;ModuleSymbol&gt; modules = List.nil();
1516         for (JCCompilationUnit unit : units) {
<span class="line-modified">1517             if (isModuleInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE) &amp;&amp; unit.defs.nonEmpty()) {</span>
<span class="line-modified">1518                 for (JCTree tree : unit.defs) {</span>
<span class="line-modified">1519                     if (tree.hasTag(Tag.IMPORT)) {</span>
<span class="line-modified">1520                         continue;</span>
<span class="line-added">1521                     }</span>
<span class="line-added">1522                     else if (tree.hasTag(Tag.MODULEDEF)) {</span>
<span class="line-added">1523                         modules = modules.prepend(unit.modle);</span>
<span class="line-added">1524                         break;</span>
<span class="line-added">1525                     }</span>
<span class="line-added">1526                     else {</span>
<span class="line-added">1527                         break;</span>
<span class="line-added">1528                     }</span>
<span class="line-added">1529                 }</span>
1530             }
1531         }
1532         return modules.reverse();
1533     }
1534 
1535     // avoid unchecked warning from use of varargs
1536     private static &lt;T&gt; List&lt;T&gt; join(List&lt;T&gt; list1, List&lt;T&gt; list2) {
1537         return list1.appendList(list2);
1538     }
1539 
1540     private boolean isPkgInfo(JavaFileObject fo, JavaFileObject.Kind kind) {
1541         return fo.isNameCompatible(&quot;package-info&quot;, kind);
1542     }
1543 
1544     private boolean isPkgInfo(ClassSymbol sym) {
1545         return isPkgInfo(sym.classfile, JavaFileObject.Kind.CLASS) &amp;&amp; (sym.packge().package_info == sym);
1546     }
1547 
1548     private boolean isModuleInfo(JavaFileObject fo, JavaFileObject.Kind kind) {
1549         return fo.isNameCompatible(&quot;module-info&quot;, kind);
</pre>
<hr />
<pre>
1713     @DefinedBy(Api.ANNOTATION_PROCESSING)
1714     public JavacElements getElementUtils() {
1715         return elementUtils;
1716     }
1717 
1718     @DefinedBy(Api.ANNOTATION_PROCESSING)
1719     public JavacTypes getTypeUtils() {
1720         return typeUtils;
1721     }
1722 
1723     @DefinedBy(Api.ANNOTATION_PROCESSING)
1724     public SourceVersion getSourceVersion() {
1725         return Source.toSourceVersion(source);
1726     }
1727 
1728     @DefinedBy(Api.ANNOTATION_PROCESSING)
1729     public Locale getLocale() {
1730         return messages.getCurrentLocale();
1731     }
1732 
<span class="line-added">1733     @DefinedBy(Api.ANNOTATION_PROCESSING)</span>
<span class="line-added">1734     public boolean isPreviewEnabled() {</span>
<span class="line-added">1735         return preview.isEnabled();</span>
<span class="line-added">1736     }</span>
<span class="line-added">1737 </span>
1738     public Set&lt;Symbol.PackageSymbol&gt; getSpecifiedPackages() {
1739         return specifiedPackages;
1740     }
1741 
1742     public static final Pattern noMatches  = Pattern.compile(&quot;(\\P{all})+&quot;);
1743 
1744     /**
1745      * Convert import-style string for supported annotations into a
1746      * regex matching that string.  If the string is not a valid
1747      * import-style string, return a regex that won&#39;t match anything.
1748      */
<span class="line-modified">1749     private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, boolean lint) {</span>
1750         String module;
1751         String pkg;
1752         int slash = s.indexOf(&#39;/&#39;);
1753         if (slash == (-1)) {
1754             if (s.equals(&quot;*&quot;)) {
1755                 return MatchingUtils.validImportStringToPattern(s);
1756             }
1757             module = allowModules ? &quot;.*/&quot; : &quot;&quot;;
1758             pkg = s;
1759         } else {
<span class="line-modified">1760             String moduleName = s.substring(0, slash);</span>
<span class="line-added">1761             if (!SourceVersion.isName(moduleName)) {</span>
<span class="line-added">1762                 return warnAndNoMatches(s, p, log, lint);</span>
<span class="line-added">1763             }</span>
<span class="line-added">1764             module = Pattern.quote(moduleName + &quot;/&quot;);</span>
<span class="line-added">1765             // And warn if module is specified if modules aren&#39;t supported, conditional on -Xlint:proc?</span>
1766             pkg = s.substring(slash + 1);
1767         }
1768         if (MatchingUtils.isValidImportString(pkg)) {
1769             return Pattern.compile(module + MatchingUtils.validImportStringToPatternString(pkg));
1770         } else {
<span class="line-added">1771             return warnAndNoMatches(s, p, log, lint);</span>
<span class="line-added">1772         }</span>
<span class="line-added">1773     }</span>
<span class="line-added">1774 </span>
<span class="line-added">1775     private static Pattern warnAndNoMatches(String s, Processor p, Log log, boolean lint) {</span>
<span class="line-added">1776         if (lint) {</span>
1777             log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));

1778         }
<span class="line-added">1779         return noMatches; // won&#39;t match any valid identifier</span>
1780     }
1781 
1782     /**
1783      * For internal use only.  This method may be removed without warning.
1784      */
1785     public Context getContext() {
1786         return context;
1787     }
1788 
1789     /**
1790      * For internal use only.  This method may be removed without warning.
1791      */
1792     public ClassLoader getProcessorClassLoader() {
1793         return processorClassLoader;
1794     }
1795 
1796     public String toString() {
1797         return &quot;javac ProcessingEnvironment&quot;;
1798     }
1799 
</pre>
</td>
</tr>
</table>
<center><a href="JavacMessager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacRoundEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Operators.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TransTypes.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -41,19 +41,21 @@</span>
  import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  import com.sun.tools.javac.jvm.*;
  import com.sun.tools.javac.main.Option;
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<span class="udiff-line-added">+ import com.sun.tools.javac.resources.CompilerProperties.Warnings;</span>
  import com.sun.tools.javac.tree.*;
  import com.sun.tools.javac.tree.JCTree.*;
  import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.DefinedBy.Api;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
<span class="udiff-line-added">+ import com.sun.tools.javac.util.JCDiagnostic.Warning;</span>
  
  import java.util.Arrays;
  import java.util.Collection;
  import java.util.EnumSet;
  import java.util.HashSet;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,10 +63,11 @@</span>
  import java.util.LinkedHashMap;
  import java.util.Map;
  import java.util.Set;
  import java.util.function.BiFunction;
  import java.util.function.BiPredicate;
<span class="udiff-line-added">+ import java.util.function.Consumer;</span>
  import java.util.function.Function;
  import java.util.function.Predicate;
  import java.util.stream.Stream;
  
  import javax.lang.model.element.ElementVisitor;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -103,10 +106,11 @@</span>
      public final boolean allowFunctionalInterfaceMostSpecific;
      public final boolean allowModules;
      public final boolean checkVarargsAccessAfterResolution;
      private final boolean compactMethodDiags;
      private final boolean allowLocalVariableTypeInference;
<span class="udiff-line-added">+     private final boolean allowYieldStatement;</span>
      final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
  
      WriteableScope polymorphicSignatureScope;
  
      protected Resolve(Context context) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126,18 +130,21 @@</span>
          infer = Infer.instance(context);
          finder = ClassFinder.instance(context);
          moduleFinder = ModuleFinder.instance(context);
          types = Types.instance(context);
          diags = JCDiagnostic.Factory.instance(context);
<span class="udiff-line-added">+         Preview preview = Preview.instance(context);</span>
          Source source = Source.instance(context);
          Options options = Options.instance(context);
          compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
                  options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
          verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
          Target target = Target.instance(context);
          allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
          allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
<span class="udiff-line-added">+         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;</span>
<span class="udiff-line-added">+                 Feature.SWITCH_EXPRESSION.allowedInSource(source);</span>
          checkVarargsAccessAfterResolution =
                  Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
          polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
          allowModules = Feature.MODULES.allowedInSource(source);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -287,11 +294,11 @@</span>
              (owner.kind == VAR ||
               owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
              (owner.flags() &amp; STATIC) == 0;
      }
  
<span class="udiff-line-modified-removed">-     /** Is class accessible in given evironment?</span>
<span class="udiff-line-modified-added">+     /** Is class accessible in given environment?</span>
       *  @param env    The current environment.
       *  @param c      The class whose accessibility is checked.
       */
      public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
          return isAccessible(env, c, false);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1378,11 +1385,11 @@</span>
      }
  
      public static class InapplicableMethodException extends RuntimeException {
          private static final long serialVersionUID = 0;
  
<span class="udiff-line-modified-removed">-         JCDiagnostic diagnostic;</span>
<span class="udiff-line-modified-added">+         transient JCDiagnostic diagnostic;</span>
  
          InapplicableMethodException(JCDiagnostic diag) {
              this.diagnostic = diag;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1480,11 +1487,17 @@</span>
                  sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
              }
              if (sym.exists()) {
                  if (staticOnly &amp;&amp;
                      sym.kind == VAR &amp;&amp;
<span class="udiff-line-modified-removed">-                     sym.owner.kind == TYP &amp;&amp;</span>
<span class="udiff-line-modified-added">+                         // if it is a field</span>
<span class="udiff-line-added">+                         (sym.owner.kind == TYP ||</span>
<span class="udiff-line-added">+                         // or it is a local variable but it is not declared inside of the static local type</span>
<span class="udiff-line-added">+                         // only records so far, then error</span>
<span class="udiff-line-added">+                         (sym.owner.kind == MTH) &amp;&amp;</span>
<span class="udiff-line-added">+                         (env.enclClass.sym.flags() &amp; STATIC) != 0 &amp;&amp;</span>
<span class="udiff-line-added">+                         sym.enclClass() != env.enclClass.sym) &amp;&amp;</span>
                      (sym.flags() &amp; STATIC) == 0)
                      return new StaticError(sym);
                  else
                      return sym;
              } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2328,17 +2341,19 @@</span>
  
          return bestSoFar;
      }
  
      /** Find an unqualified identifier which matches a specified kind set.
<span class="udiff-line-added">+      *  @param pos       position on which report warnings, if any;</span>
<span class="udiff-line-added">+      *                   null warnings should not be reported</span>
       *  @param env       The current environment.
       *  @param name      The identifier&#39;s name.
       *  @param kind      Indicates the possible symbol kinds
       *                   (a subset of VAL, TYP, PCK).
       */
<span class="udiff-line-modified-removed">-     Symbol findIdent(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {</span>
<span class="udiff-line-modified-removed">-         return checkVarType(findIdentInternal(env, name, kind), name);</span>
<span class="udiff-line-modified-added">+     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {</span>
<span class="udiff-line-modified-added">+         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);</span>
      }
  
      Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
          Symbol bestSoFar = typeNotFound;
          Symbol sym;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2360,28 +2375,31 @@</span>
              return lookupPackage(env, name);
          else return bestSoFar;
      }
  
      /** Find an identifier in a package which matches a specified kind set.
<span class="udiff-line-added">+      *  @param pos       position on which report warnings, if any;</span>
<span class="udiff-line-added">+      *                   null warnings should not be reported</span>
       *  @param env       The current environment.
       *  @param name      The identifier&#39;s name.
       *  @param kind      Indicates the possible symbol kinds
       *                   (a nonempty subset of TYP, PCK).
       */
<span class="udiff-line-modified-removed">-     Symbol findIdentInPackage(Env&lt;AttrContext&gt; env, TypeSymbol pck,</span>
<span class="udiff-line-modified-added">+     Symbol findIdentInPackage(DiagnosticPosition pos,</span>
<span class="udiff-line-added">+                               Env&lt;AttrContext&gt; env, TypeSymbol pck,</span>
                                Name name, KindSelector kind) {
<span class="udiff-line-modified-removed">-         return checkVarType(findIdentInPackageInternal(env, pck, name, kind), name);</span>
<span class="udiff-line-modified-added">+         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);</span>
      }
  
      Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
                                Name name, KindSelector kind) {
          Name fullname = TypeSymbol.formFullName(name, pck);
          Symbol bestSoFar = typeNotFound;
          if (kind.contains(KindSelector.TYP)) {
              RecoveryLoadClass recoveryLoadClass =
                      allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
<span class="udiff-line-modified-removed">-                     !pck.exists() &amp;&amp; !env.info.isSpeculative ?</span>
<span class="udiff-line-modified-added">+                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?</span>
                          doRecoveryLoadClass : noRecovery;
              Symbol sym = loadClass(env, fullname, recoveryLoadClass);
              if (sym.exists()) {
                  // don&#39;t allow programs to use flatnames
                  if (name == sym.name) return sym;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2393,19 +2411,22 @@</span>
          }
          return bestSoFar;
      }
  
      /** Find an identifier among the members of a given type `site&#39;.
<span class="udiff-line-added">+      *  @param pos       position on which report warnings, if any;</span>
<span class="udiff-line-added">+      *                   null warnings should not be reported</span>
       *  @param env       The current environment.
       *  @param site      The type containing the symbol to be found.
       *  @param name      The identifier&#39;s name.
       *  @param kind      Indicates the possible symbol kinds
       *                   (a subset of VAL, TYP).
       */
<span class="udiff-line-modified-removed">-     Symbol findIdentInType(Env&lt;AttrContext&gt; env, Type site,</span>
<span class="udiff-line-modified-added">+     Symbol findIdentInType(DiagnosticPosition pos,</span>
<span class="udiff-line-added">+                            Env&lt;AttrContext&gt; env, Type site,</span>
                             Name name, KindSelector kind) {
<span class="udiff-line-modified-removed">-         return checkVarType(findIdentInTypeInternal(env, site, name, kind), name);</span>
<span class="udiff-line-modified-added">+         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);</span>
      }
  
      Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
                             Name name, KindSelector kind) {
          Symbol bestSoFar = typeNotFound;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2422,14 +2443,21 @@</span>
              else bestSoFar = bestOf(bestSoFar, sym);
          }
          return bestSoFar;
      }
  
<span class="udiff-line-modified-removed">-     private Symbol checkVarType(Symbol bestSoFar, Name name) {</span>
<span class="udiff-line-modified-removed">-         if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                 (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP)) {</span>
<span class="udiff-line-modified-removed">-             bestSoFar = new BadVarTypeError();</span>
<span class="udiff-line-modified-added">+     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {</span>
<span class="udiff-line-modified-added">+         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {</span>
<span class="udiff-line-modified-added">+             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {</span>
<span class="udiff-line-modified-added">+                 bestSoFar = new BadRestrictedTypeError(names.var);</span>
<span class="udiff-line-added">+             } else if (name.equals(names.yield)) {</span>
<span class="udiff-line-added">+                 if (allowYieldStatement) {</span>
<span class="udiff-line-added">+                     bestSoFar = new BadRestrictedTypeError(names.yield);</span>
<span class="udiff-line-added">+                 } else if (pos != null) {</span>
<span class="udiff-line-added">+                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
          }
          return bestSoFar;
      }
  
  /* ***************************************************************************
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2595,11 +2623,11 @@</span>
       *  @param kind      The set of admissible symbol kinds for the identifier.
       */
      Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
                          Name name, KindSelector kind) {
          return accessBase(
<span class="udiff-line-modified-removed">-             findIdent(env, name, kind),</span>
<span class="udiff-line-modified-added">+             findIdent(pos, env, name, kind),</span>
              pos, env.enclClass.sym.type, name, false);
      }
  
      /** Resolve an unqualified method identifier.
       *  @param pos       The position to use for error reporting.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2795,10 +2823,11 @@</span>
          Symbol sym = findMethod(env, site,
                                      names.init, argtypes,
                                      typeargtypes, allowBoxing,
                                      useVarargs);
          chk.checkDeprecated(pos, env.info.scope.owner, sym);
<span class="udiff-line-added">+         chk.checkPreview(pos, sym);</span>
          return sym;
      }
  
      /** Resolve constructor using diamond inference.
       *  @param pos       The position to use for error reporting.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3199,11 +3228,11 @@</span>
          }
  
          @Override
          ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
              if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
<span class="udiff-line-modified-removed">-                 //the first serach has at least one applicable static method</span>
<span class="udiff-line-modified-added">+                 //the first search has at least one applicable static method</span>
                  return boundRes;
              } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
                  //the second search has at least one applicable non-static method
                  return unboundRes;
              } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3831,18 +3860,20 @@</span>
              else
                  return sym;
          }
      }
  
<span class="udiff-line-modified-removed">-     class BadVarTypeError extends ResolveError {</span>
<span class="udiff-line-modified-removed">-         BadVarTypeError() {</span>
<span class="udiff-line-modified-removed">-             super(Kind.BAD_VAR, &quot;bad var use&quot;);</span>
<span class="udiff-line-modified-added">+     class BadRestrictedTypeError extends ResolveError {</span>
<span class="udiff-line-modified-added">+         private final Name typeName;</span>
<span class="udiff-line-modified-added">+         BadRestrictedTypeError(Name typeName) {</span>
<span class="udiff-line-added">+             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);</span>
<span class="udiff-line-added">+             this.typeName = typeName;</span>
          }
  
          @Override
          JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<span class="udiff-line-modified-removed">-             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.var.type&quot;);</span>
<span class="udiff-line-modified-added">+             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);</span>
          }
      }
  
      /**
       * InvalidSymbolError error class indicating that a symbol matching a
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4560,11 +4591,11 @@</span>
           * A diagnostic rewriter transforms a method resolution diagnostic
           * into a simpler one
           */
          interface DiagnosticRewriter {
              JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<span class="udiff-line-modified-removed">-                     DiagnosticPosition preferedPos, DiagnosticSource preferredSource,</span>
<span class="udiff-line-modified-added">+                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,</span>
                      DiagnosticType preferredKind, JCDiagnostic d);
          }
  
          /**
           * A diagnostic template is made up of two ingredients: (i) a regular
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4616,16 +4647,16 @@</span>
                  this.causeIndex = causeIndex;
              }
  
              @Override
              public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<span class="udiff-line-modified-removed">-                     DiagnosticPosition preferedPos, DiagnosticSource preferredSource,</span>
<span class="udiff-line-modified-added">+                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,</span>
                      DiagnosticType preferredKind, JCDiagnostic d) {
                  JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
                  DiagnosticPosition pos = d.getDiagnosticPosition();
                  if (pos == null) {
<span class="udiff-line-modified-removed">-                     pos = preferedPos;</span>
<span class="udiff-line-modified-added">+                     pos = preferredPos;</span>
                  }
                  return diags.create(preferredKind, preferredSource, pos,
                          &quot;prob.found.req&quot;, cause);
              }
          }
</pre>
<center><a href="Operators.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TransTypes.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
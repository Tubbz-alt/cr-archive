<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocCommentParser.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacParser.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -23,19 +23,26 @@</span>
   * questions.
   */
  
  package com.sun.tools.javac.parser;
  
<span class="udiff-line-added">+ import com.sun.tools.javac.code.Lint;</span>
<span class="udiff-line-added">+ import com.sun.tools.javac.code.Lint.LintCategory;</span>
  import com.sun.tools.javac.code.Preview;
  import com.sun.tools.javac.code.Source;
  import com.sun.tools.javac.code.Source.Feature;
  import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
<span class="udiff-line-added">+ import com.sun.tools.javac.resources.CompilerProperties.Warnings;</span>
  import com.sun.tools.javac.util.*;
<span class="udiff-line-modified-removed">- import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;</span>
<span class="udiff-line-modified-added">+ import com.sun.tools.javac.util.JCDiagnostic.*;</span>
  
<span class="udiff-line-added">+ import java.lang.reflect.InvocationTargetException;</span>
<span class="udiff-line-added">+ import java.lang.reflect.Method;</span>
  import java.nio.CharBuffer;
<span class="udiff-line-added">+ import java.util.HashSet;</span>
<span class="udiff-line-added">+ import java.util.Set;</span>
  
  import static com.sun.tools.javac.parser.Tokens.*;
  import static com.sun.tools.javac.util.LayoutCharacters.*;
  
  /** The lexical analyzer maps an input stream consisting of
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,12 +89,25 @@</span>
  
      /** The Unicode reader (low-level stream reader).
       */
      protected UnicodeReader reader;
  
<span class="udiff-line-added">+     /** If is a text block</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     protected boolean isTextBlock;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** If contains escape sequences</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     protected boolean hasEscapeSequences;</span>
<span class="udiff-line-added">+ </span>
      protected ScannerFactory fac;
  
<span class="udiff-line-added">+     // The set of lint options currently in effect. It is initialized</span>
<span class="udiff-line-added">+     // from the context, and then is set/reset as needed by Attr as it</span>
<span class="udiff-line-added">+     // visits all the various parts of the trees during attribution.</span>
<span class="udiff-line-added">+     protected Lint lint;</span>
<span class="udiff-line-added">+ </span>
      private static final boolean hexFloatsWork = hexFloatsWork();
      private static boolean hexFloatsWork() {
          try {
              Float.valueOf(&quot;0x1.0p1&quot;);
              return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -119,10 +139,11 @@</span>
          this.log = fac.log;
          this.tokens = fac.tokens;
          this.source = fac.source;
          this.preview = fac.preview;
          this.reader = reader;
<span class="udiff-line-added">+         this.lint = fac.lint;</span>
      }
  
      protected void checkSourceLevel(int pos, Feature feature) {
          if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
              //preview feature without --preview flag, error
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,60 +169,336 @@</span>
          log.error(flags, pos, key);
          tk = TokenKind.ERROR;
          errPos = pos;
      }
  
<span class="udiff-line-added">+     protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {</span>
<span class="udiff-line-added">+         DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;</span>
<span class="udiff-line-added">+         log.warning(lc, dp, key);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Read next character in character or string literal and copy into sbuf.
<span class="udiff-line-added">+      *      pos - start of literal offset</span>
<span class="udiff-line-added">+      *      translateEscapesNow - true if String::translateEscapes is not available</span>
<span class="udiff-line-added">+      *                            in the java.base libs. Occurs during bootstrapping.</span>
<span class="udiff-line-added">+      *      multiline - true if scanning a text block. Allows newlines to be embedded</span>
<span class="udiff-line-added">+      *                  in the result.</span>
       */
<span class="udiff-line-modified-removed">-     private void scanLitChar(int pos) {</span>
<span class="udiff-line-modified-removed">-         if (reader.ch == &#39;\\&#39;) {</span>
<span class="udiff-line-modified-added">+     private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {</span>
<span class="udiff-line-modified-added">+          if (reader.ch == &#39;\\&#39;) {</span>
              if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {
                  reader.skipChar();
<span class="udiff-line-modified-removed">-                 reader.putChar(&#39;\\&#39;, true);</span>
<span class="udiff-line-modified-added">+                 if (!translateEscapesNow) {</span>
<span class="udiff-line-added">+                     reader.putChar(false);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 reader.putChar(true);</span>
              } else {
<span class="udiff-line-modified-removed">-                 reader.scanChar();</span>
<span class="udiff-line-modified-added">+                 reader.nextChar(translateEscapesNow);</span>
                  switch (reader.ch) {
                  case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
                  case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
                      char leadch = reader.ch;
                      int oct = reader.digit(pos, 8);
<span class="udiff-line-modified-removed">-                     reader.scanChar();</span>
<span class="udiff-line-modified-added">+                     reader.nextChar(translateEscapesNow);</span>
                      if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
                          oct = oct * 8 + reader.digit(pos, 8);
<span class="udiff-line-modified-removed">-                         reader.scanChar();</span>
<span class="udiff-line-modified-added">+                         reader.nextChar(translateEscapesNow);</span>
                          if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
                              oct = oct * 8 + reader.digit(pos, 8);
<span class="udiff-line-modified-removed">-                             reader.scanChar();</span>
<span class="udiff-line-modified-added">+                             reader.nextChar(translateEscapesNow);</span>
                          }
                      }
<span class="udiff-line-modified-removed">-                     reader.putChar((char)oct);</span>
<span class="udiff-line-modified-added">+                     if (translateEscapesNow) {</span>
<span class="udiff-line-added">+                         reader.putChar((char)oct);</span>
<span class="udiff-line-added">+                     }</span>
                      break;
                  case &#39;b&#39;:
<span class="udiff-line-modified-removed">-                     reader.putChar(&#39;\b&#39;, true); break;</span>
<span class="udiff-line-modified-added">+                     reader.putChar(translateEscapesNow ? &#39;\b&#39; : &#39;b&#39;, true); break;</span>
                  case &#39;t&#39;:
<span class="udiff-line-modified-removed">-                     reader.putChar(&#39;\t&#39;, true); break;</span>
<span class="udiff-line-modified-added">+                     reader.putChar(translateEscapesNow ? &#39;\t&#39; : &#39;t&#39;, true); break;</span>
                  case &#39;n&#39;:
<span class="udiff-line-modified-removed">-                     reader.putChar(&#39;\n&#39;, true); break;</span>
<span class="udiff-line-modified-added">+                     reader.putChar(translateEscapesNow ? &#39;\n&#39; : &#39;n&#39;, true); break;</span>
                  case &#39;f&#39;:
<span class="udiff-line-modified-removed">-                     reader.putChar(&#39;\f&#39;, true); break;</span>
<span class="udiff-line-modified-added">+                     reader.putChar(translateEscapesNow ? &#39;\f&#39; : &#39;f&#39;, true); break;</span>
                  case &#39;r&#39;:
<span class="udiff-line-modified-removed">-                     reader.putChar(&#39;\r&#39;, true); break;</span>
<span class="udiff-line-modified-added">+                     reader.putChar(translateEscapesNow ? &#39;\r&#39; : &#39;r&#39;, true); break;</span>
                  case &#39;\&#39;&#39;:
<span class="udiff-line-removed">-                     reader.putChar(&#39;\&#39;&#39;, true); break;</span>
                  case &#39;\&quot;&#39;:
<span class="udiff-line-removed">-                     reader.putChar(&#39;\&quot;&#39;, true); break;</span>
                  case &#39;\\&#39;:
<span class="udiff-line-modified-removed">-                     reader.putChar(&#39;\\&#39;, true); break;</span>
<span class="udiff-line-modified-added">+                     reader.putChar(true); break;</span>
<span class="udiff-line-added">+                 case &#39;s&#39;:</span>
<span class="udiff-line-added">+                     checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="udiff-line-added">+                     reader.putChar(translateEscapesNow ? &#39; &#39; : &#39;s&#39;, true); break;</span>
<span class="udiff-line-added">+                 case &#39;\n&#39;:</span>
<span class="udiff-line-added">+                 case &#39;\r&#39;:</span>
<span class="udiff-line-added">+                     if (!multiline) {</span>
<span class="udiff-line-added">+                         lexError(reader.bp, Errors.IllegalEscChar);</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         int start = reader.bp;</span>
<span class="udiff-line-added">+                         checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="udiff-line-added">+                         if (reader.ch == &#39;\r&#39; &amp;&amp; reader.peekChar() == &#39;\n&#39;) {</span>
<span class="udiff-line-added">+                            reader.nextChar(translateEscapesNow);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         reader.nextChar(translateEscapesNow);</span>
<span class="udiff-line-added">+                         processLineTerminator(start, reader.bp);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     break;</span>
                  default:
                      lexError(reader.bp, Errors.IllegalEscChar);
                  }
              }
          } else if (reader.bp != reader.buflen) {
              reader.putChar(true);
          }
      }
  
<span class="udiff-line-added">+     /** Interim access to String methods used to support text blocks.</span>
<span class="udiff-line-added">+      *  Required to handle bootstrapping with pre-text block jdks.</span>
<span class="udiff-line-added">+      *  Should be replaced with direct calls in the &#39;next&#39; jdk.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static class TextBlockSupport {</span>
<span class="udiff-line-added">+         /** Reflection method to remove incidental indentation.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private static final Method stripIndent;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** Reflection method to translate escape sequences.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private static final Method translateEscapes;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private static final boolean hasSupport;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** Get a string method via refection or null if not available.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private static Method getStringMethodOrNull(String name) {</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 return String.class.getMethod(name);</span>
<span class="udiff-line-added">+             } catch (Exception ex) {</span>
<span class="udiff-line-added">+                 // Method not available, return null.</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static {</span>
<span class="udiff-line-added">+             // Get text block string methods.</span>
<span class="udiff-line-added">+             stripIndent = getStringMethodOrNull(&quot;stripIndent&quot;);</span>
<span class="udiff-line-added">+             translateEscapes = getStringMethodOrNull(&quot;translateEscapes&quot;);</span>
<span class="udiff-line-added">+             // true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="udiff-line-added">+             hasSupport = stripIndent != null &amp;&amp; translateEscapes != null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         static boolean hasSupport() {</span>
<span class="udiff-line-added">+             return hasSupport;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** Return the leading whitespace count (indentation) of the line.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private static int indent(String line) {</span>
<span class="udiff-line-added">+             return line.length() - line.stripLeading().length();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         enum WhitespaceChecks {</span>
<span class="udiff-line-added">+             INCONSISTENT,</span>
<span class="udiff-line-added">+             TRAILING</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** Check that the use of white space in content is not problematic.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         static Set&lt;WhitespaceChecks&gt; checkWhitespace(String string) {</span>
<span class="udiff-line-added">+             // Start with empty result set.</span>
<span class="udiff-line-added">+             Set&lt;WhitespaceChecks&gt; checks = new HashSet&lt;&gt;();</span>
<span class="udiff-line-added">+             // No need to check empty strings.</span>
<span class="udiff-line-added">+             if (string.isEmpty()) {</span>
<span class="udiff-line-added">+                 return checks;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             // Maximum common indentation.</span>
<span class="udiff-line-added">+             int outdent = 0;</span>
<span class="udiff-line-added">+             // No need to check indentation if opting out (last line is empty.)</span>
<span class="udiff-line-added">+             char lastChar = string.charAt(string.length() - 1);</span>
<span class="udiff-line-added">+             boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;</span>
<span class="udiff-line-added">+             // Split string based at line terminators.</span>
<span class="udiff-line-added">+             String[] lines = string.split(&quot;\\R&quot;);</span>
<span class="udiff-line-added">+             int length = lines.length;</span>
<span class="udiff-line-added">+             // Extract last line.</span>
<span class="udiff-line-added">+             String lastLine = length == 0 ? &quot;&quot; : lines[length - 1];</span>
<span class="udiff-line-added">+              if (!optOut) {</span>
<span class="udiff-line-added">+                 // Prime with the last line indentation (may be blank.)</span>
<span class="udiff-line-added">+                 outdent = indent(lastLine);</span>
<span class="udiff-line-added">+                 for (String line : lines) {</span>
<span class="udiff-line-added">+                     // Blanks lines have no influence (last line accounted for.)</span>
<span class="udiff-line-added">+                     if (!line.isBlank()) {</span>
<span class="udiff-line-added">+                         outdent = Integer.min(outdent, indent(line));</span>
<span class="udiff-line-added">+                         if (outdent == 0) {</span>
<span class="udiff-line-added">+                             break;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             // Last line is representative.</span>
<span class="udiff-line-added">+             String start = lastLine.substring(0, outdent);</span>
<span class="udiff-line-added">+             for (String line : lines) {</span>
<span class="udiff-line-added">+                 // Fail if a line does not have the same indentation.</span>
<span class="udiff-line-added">+                 if (!line.isBlank() &amp;&amp; !line.startsWith(start)) {</span>
<span class="udiff-line-added">+                     // Mix of different white space</span>
<span class="udiff-line-added">+                     checks.add(WhitespaceChecks.INCONSISTENT);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 // Line has content even after indent is removed.</span>
<span class="udiff-line-added">+                 if (outdent &lt; line.length()) {</span>
<span class="udiff-line-added">+                     // Is the last character a white space.</span>
<span class="udiff-line-added">+                     lastChar = line.charAt(line.length() - 1);</span>
<span class="udiff-line-added">+                     if (Character.isWhitespace(lastChar)) {</span>
<span class="udiff-line-added">+                         // Has trailing white space.</span>
<span class="udiff-line-added">+                         checks.add(WhitespaceChecks.TRAILING);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return checks;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** Invoke String::stripIndent through reflection.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         static String stripIndent(String string) {</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 string = (String)stripIndent.invoke(string);</span>
<span class="udiff-line-added">+             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="udiff-line-added">+                 throw new RuntimeException(ex);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return string;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /** Invoke String::translateEscapes through reflection.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         static String translateEscapes(String string) {</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 string = (String)translateEscapes.invoke(string);</span>
<span class="udiff-line-added">+             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="udiff-line-added">+                 throw new RuntimeException(ex);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return string;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Test for EOLN.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private boolean isEOLN() {</span>
<span class="udiff-line-added">+         return reader.ch == LF || reader.ch == CR;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Test for CRLF.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private boolean isCRLF() {</span>
<span class="udiff-line-added">+         return reader.ch == CR &amp;&amp; reader.peekChar() == LF;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Count and skip repeated occurrences of the specified character.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private int countChar(char ch, int max) {</span>
<span class="udiff-line-added">+         int count = 0;</span>
<span class="udiff-line-added">+         for ( ; count &lt; max &amp;&amp; reader.bp &lt; reader.buflen &amp;&amp; reader.ch == ch; count++) {</span>
<span class="udiff-line-added">+             reader.scanChar();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return count;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Scan a string literal or text block.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     private void scanString(int pos) {</span>
<span class="udiff-line-added">+         // Clear flags.</span>
<span class="udiff-line-added">+         isTextBlock = false;</span>
<span class="udiff-line-added">+         hasEscapeSequences = false;</span>
<span class="udiff-line-added">+         // Track the end of first line for error recovery.</span>
<span class="udiff-line-added">+         int firstEOLN = -1;</span>
<span class="udiff-line-added">+         // Attempt to scan for up to 3 double quotes.</span>
<span class="udiff-line-added">+         int openCount = countChar(&#39;\&quot;&#39;, 3);</span>
<span class="udiff-line-added">+         switch (openCount) {</span>
<span class="udiff-line-added">+         case 1: // Starting a string literal.</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case 2: // Starting an empty string literal.</span>
<span class="udiff-line-added">+             // Start again but only consume one quote.</span>
<span class="udiff-line-added">+             reader.reset(pos);</span>
<span class="udiff-line-added">+             openCount = countChar(&#39;\&quot;&#39;, 1);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         case 3: // Starting a text block.</span>
<span class="udiff-line-added">+             // Check if preview feature is enabled for text blocks.</span>
<span class="udiff-line-added">+             checkSourceLevel(pos, Feature.TEXT_BLOCKS);</span>
<span class="udiff-line-added">+             isTextBlock = true;</span>
<span class="udiff-line-added">+             // Verify the open delimiter sequence.</span>
<span class="udiff-line-added">+             boolean hasOpenEOLN = false;</span>
<span class="udiff-line-added">+             while (reader.bp &lt; reader.buflen &amp;&amp; Character.isWhitespace(reader.ch)) {</span>
<span class="udiff-line-added">+                 hasOpenEOLN = isEOLN();</span>
<span class="udiff-line-added">+                 if (hasOpenEOLN) {</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 reader.scanChar();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             // Error if the open delimiter sequence not is &quot;&quot;&quot;&lt;Whitespace&gt;*&lt;LineTerminator&gt;.</span>
<span class="udiff-line-added">+             if (!hasOpenEOLN) {</span>
<span class="udiff-line-added">+                 lexError(reader.bp, Errors.IllegalTextBlockOpen);</span>
<span class="udiff-line-added">+                 return;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             // Skip line terminator.</span>
<span class="udiff-line-added">+             int start = reader.bp;</span>
<span class="udiff-line-added">+             if (isCRLF()) {</span>
<span class="udiff-line-added">+                 reader.scanChar();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             reader.scanChar();</span>
<span class="udiff-line-added">+             processLineTerminator(start, reader.bp);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // While characters are available.</span>
<span class="udiff-line-added">+         while (reader.bp &lt; reader.buflen) {</span>
<span class="udiff-line-added">+             // If possible close delimiter sequence.</span>
<span class="udiff-line-added">+             if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="udiff-line-added">+                 // Check to see if enough double quotes are present.</span>
<span class="udiff-line-added">+                 int closeCount = countChar(&#39;\&quot;&#39;, openCount);</span>
<span class="udiff-line-added">+                 if (openCount == closeCount) {</span>
<span class="udiff-line-added">+                     // Good result.</span>
<span class="udiff-line-added">+                     tk = Tokens.TokenKind.STRINGLITERAL;</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 // False alarm, add double quotes to string buffer.</span>
<span class="udiff-line-added">+                 reader.repeat(&#39;\&quot;&#39;, closeCount);</span>
<span class="udiff-line-added">+             } else if (isEOLN()) {</span>
<span class="udiff-line-added">+                 // Line terminator in string literal is an error.</span>
<span class="udiff-line-added">+                 // Fall out to unclosed string literal error.</span>
<span class="udiff-line-added">+                 if (openCount == 1) {</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                  // Add line terminator to string buffer.</span>
<span class="udiff-line-added">+                 int start = reader.bp;</span>
<span class="udiff-line-added">+                 if (isCRLF()) {</span>
<span class="udiff-line-added">+                     reader.scanChar();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 reader.putChar(&#39;\n&#39;, true);</span>
<span class="udiff-line-added">+                 processLineTerminator(start, reader.bp);</span>
<span class="udiff-line-added">+                 // Record first line terminator for error recovery.</span>
<span class="udiff-line-added">+                 if (firstEOLN == -1) {</span>
<span class="udiff-line-added">+                     firstEOLN = reader.bp;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else if (reader.ch == &#39;\\&#39;) {</span>
<span class="udiff-line-added">+                 // Handle escape sequences.</span>
<span class="udiff-line-added">+                 hasEscapeSequences = true;</span>
<span class="udiff-line-added">+                 // Translate escapes immediately if TextBlockSupport is not available</span>
<span class="udiff-line-added">+                 // during bootstrapping.</span>
<span class="udiff-line-added">+                 boolean translateEscapesNow = !TextBlockSupport.hasSupport();</span>
<span class="udiff-line-added">+                 scanLitChar(pos, translateEscapesNow, openCount != 1);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 // Add character to string buffer.</span>
<span class="udiff-line-added">+                 reader.putChar(true);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // String ended without close delimiter sequence.</span>
<span class="udiff-line-added">+         lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);</span>
<span class="udiff-line-added">+         if (firstEOLN  != -1) {</span>
<span class="udiff-line-added">+             // Reset recovery position to point after open delimiter sequence.</span>
<span class="udiff-line-added">+             reader.reset(firstEOLN);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      private void scanDigits(int pos, int digitRadix) {
          char saveCh;
          int savePos;
          do {
              if (reader.ch != &#39;_&#39;) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -622,33 +919,25 @@</span>
                      reader.scanChar();
                      if (reader.ch == &#39;\&#39;&#39;) {
                          lexError(pos, Errors.EmptyCharLit);
                          reader.scanChar();
                      } else {
<span class="udiff-line-modified-removed">-                         if (reader.ch == CR || reader.ch == LF)</span>
<span class="udiff-line-modified-added">+                         if (isEOLN())</span>
                              lexError(pos, Errors.IllegalLineEndInCharLit);
<span class="udiff-line-modified-removed">-                         scanLitChar(pos);</span>
<span class="udiff-line-modified-added">+                         scanLitChar(pos, true, false);</span>
                          if (reader.ch == &#39;\&#39;&#39;) {
                              reader.scanChar();
                              tk = TokenKind.CHARLITERAL;
                          } else {
                              lexError(pos, Errors.UnclosedCharLit);
                          }
                      }
                      break loop;
                  case &#39;\&quot;&#39;:
<span class="udiff-line-modified-removed">-                     reader.scanChar();</span>
<span class="udiff-line-removed">-                     while (reader.ch != &#39;\&quot;&#39; &amp;&amp; reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen)</span>
<span class="udiff-line-removed">-                         scanLitChar(pos);</span>
<span class="udiff-line-removed">-                     if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="udiff-line-removed">-                         tk = TokenKind.STRINGLITERAL;</span>
<span class="udiff-line-removed">-                         reader.scanChar();</span>
<span class="udiff-line-removed">-                     } else {</span>
<span class="udiff-line-removed">-                         lexError(pos, Errors.UnclosedStrLit);</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-modified-added">+                     scanString(pos);</span>
                      break loop;
<span class="udiff-line-modified-removed">-                default:</span>
<span class="udiff-line-modified-added">+                 default:</span>
                      if (isSpecial(reader.ch)) {
                          scanOperator();
                      } else {
                          boolean isJavaIdentifierStart;
                          int codePoint = -1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -693,11 +982,46 @@</span>
              }
              endPos = reader.bp;
              switch (tk.tag) {
                  case DEFAULT: return new Token(tk, pos, endPos, comments);
                  case NAMED: return new NamedToken(tk, pos, endPos, name, comments);
<span class="udiff-line-modified-removed">-                 case STRING: return new StringToken(tk, pos, endPos, reader.chars(), comments);</span>
<span class="udiff-line-modified-added">+                 case STRING: {</span>
<span class="udiff-line-added">+                     // Get characters from string buffer.</span>
<span class="udiff-line-added">+                     String string = reader.chars();</span>
<span class="udiff-line-added">+                     // If a text block.</span>
<span class="udiff-line-added">+                     if (isTextBlock &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="udiff-line-added">+                         // Verify that the incidental indentation is consistent.</span>
<span class="udiff-line-added">+                         if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {</span>
<span class="udiff-line-added">+                             Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =</span>
<span class="udiff-line-added">+                                     TextBlockSupport.checkWhitespace(string);</span>
<span class="udiff-line-added">+                             if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {</span>
<span class="udiff-line-added">+                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="udiff-line-added">+                                         Warnings.InconsistentWhiteSpaceIndentation);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {</span>
<span class="udiff-line-added">+                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="udiff-line-added">+                                         Warnings.TrailingWhiteSpaceWillBeRemoved);</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         // Remove incidental indentation.</span>
<span class="udiff-line-added">+                         try {</span>
<span class="udiff-line-added">+                             string = TextBlockSupport.stripIndent(string);</span>
<span class="udiff-line-added">+                         } catch (Exception ex) {</span>
<span class="udiff-line-added">+                             // Error already reported, just use unstripped string.</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     // Translate escape sequences if present.</span>
<span class="udiff-line-added">+                     if (hasEscapeSequences &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="udiff-line-added">+                         try {</span>
<span class="udiff-line-added">+                             string = TextBlockSupport.translateEscapes(string);</span>
<span class="udiff-line-added">+                         } catch (Exception ex) {</span>
<span class="udiff-line-added">+                             // Error already reported, just use untranslated string.</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     // Build string token.</span>
<span class="udiff-line-added">+                     return new StringToken(tk, pos, endPos, string, comments);</span>
<span class="udiff-line-added">+                 }</span>
                  case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);
                  default: throw new AssertionError();
              }
          }
          finally {
</pre>
<center><a href="DocCommentParser.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacParser.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/util/MandatoryWarningHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.util;
 27 
 28 import java.util.HashSet;
<a name="2" id="anc2"></a><span class="line-added"> 29 import java.util.Objects;</span>
 30 import java.util.Set;
 31 import javax.tools.JavaFileObject;
 32 
 33 import com.sun.tools.javac.code.Lint.LintCategory;
 34 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 35 import com.sun.tools.javac.util.JCDiagnostic.Note;
 36 import com.sun.tools.javac.util.JCDiagnostic.Warning;
 37 
 38 
 39 /**
 40  * A handler to process mandatory warnings, setting up a deferred diagnostic
 41  * to be printed at the end of the compilation if some warnings get suppressed
 42  * because too many warnings have already been generated.
 43  *
 44  * Note that the SuppressWarnings annotation can be used to suppress warnings
 45  * about conditions that would otherwise merit a warning. Such processing
 46  * is done when the condition is detected, and in those cases, no call is
 47  * made on any API to generate a warning at all. In consequence, this handler only
 48  * Returns to handle those warnings that JLS says must be generated.
 49  *
 50  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 51  *  If you write code that depends on this, you do so at your own risk.
 52  *  This code and its internal interfaces are subject to change or
 53  *  deletion without notice.&lt;/b&gt;
 54  */
 55 public class MandatoryWarningHandler {
 56 
 57     /**
 58      * The kinds of different deferred diagnostics that might be generated
 59      * if a mandatory warning is suppressed because too many warnings have
 60      * already been output.
 61      *
 62      * The parameter is a fragment used to build an I18N message key for Log.
 63      */
 64     private enum DeferredDiagnosticKind {
 65         /**
 66          * This kind is used when a single specific file is found to have warnings
 67          * and no similar warnings have already been given.
 68          * It generates a message like:
 69          *      FILE has ISSUES
 70          */
 71         IN_FILE(&quot;.filename&quot;),
 72         /**
 73          * This kind is used when a single specific file is found to have warnings
 74          * and when similar warnings have already been reported for the file.
 75          * It generates a message like:
 76          *      FILE has additional ISSUES
 77          */
 78         ADDITIONAL_IN_FILE(&quot;.filename.additional&quot;),
 79         /**
 80          * This kind is used when multiple files have been found to have warnings,
 81          * and none of them have had any similar warnings.
 82          * It generates a message like:
 83          *      Some files have ISSUES
 84          */
 85         IN_FILES(&quot;.plural&quot;),
 86         /**
 87          * This kind is used when multiple files have been found to have warnings,
 88          * and some of them have had already had specific similar warnings.
 89          * It generates a message like:
 90          *      Some files have additional ISSUES
 91          */
 92         ADDITIONAL_IN_FILES(&quot;.plural.additional&quot;);
 93 
 94         DeferredDiagnosticKind(String v) { value = v; }
 95         String getKey(String prefix) { return prefix + value; }
 96 
 97         private final String value;
 98     }
 99 
100 
101     /**
102      * Create a handler for mandatory warnings.
103      * @param log     The log on which to generate any diagnostics
104      * @param verbose Specify whether or not detailed messages about
105      *                individual instances should be given, or whether an aggregate
106      *                message should be generated at the end of the compilation.
107      *                Typically set via  -Xlint:option.
108      * @param enforceMandatory
109      *                True if mandatory warnings and notes are being enforced.
110      * @param prefix  A common prefix for the set of message keys for
111      *                the messages that may be generated.
112      * @param lc      An associated lint category for the warnings, or null if none.
113      */
114     public MandatoryWarningHandler(Log log, boolean verbose,
115                                    boolean enforceMandatory, String prefix,
116                                    LintCategory lc) {
117         this.log = log;
118         this.verbose = verbose;
119         this.prefix = prefix;
120         this.enforceMandatory = enforceMandatory;
121         this.lintCategory = lc;
122     }
123 
124     /**
125      * Report a mandatory warning.
126      */
127     public void report(DiagnosticPosition pos, Warning warnKey) {
128         JavaFileObject currentSource = log.currentSourceFile();
129 
130         if (verbose) {
131             if (sourcesWithReportedWarnings == null)
132                 sourcesWithReportedWarnings = new HashSet&lt;&gt;();
133 
134             if (log.nwarnings &lt; log.MaxWarnings) {
135                 // generate message and remember the source file
136                 logMandatoryWarning(pos, warnKey);
137                 sourcesWithReportedWarnings.add(currentSource);
138             } else if (deferredDiagnosticKind == null) {
139                 // set up deferred message
140                 if (sourcesWithReportedWarnings.contains(currentSource)) {
141                     // more errors in a file that already has reported warnings
142                     deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;
143                 } else {
144                     // warnings in a new source file
145                     deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;
146                 }
147                 deferredDiagnosticSource = currentSource;
148                 deferredDiagnosticArg = currentSource;
149             } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE
150                         || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)
<a name="3" id="anc3"></a><span class="line-modified">151                        &amp;&amp; !Objects.equals(deferredDiagnosticSource, currentSource)) {</span>
152                 // additional errors in more than one source file
153                 deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;
154                 deferredDiagnosticArg = null;
155             }
156         } else {
157             if (deferredDiagnosticKind == null) {
158                 // warnings in a single source
159                 deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;
160                 deferredDiagnosticSource = currentSource;
161                 deferredDiagnosticArg = currentSource;
162             }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &amp;&amp;
<a name="4" id="anc4"></a><span class="line-modified">163                         !Objects.equals(deferredDiagnosticSource, currentSource)) {</span>
164                 // warnings in multiple source files
165                 deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;
166                 deferredDiagnosticArg = null;
167             }
168         }
169     }
170 
171     /**
172      * Report any diagnostic that might have been deferred by previous calls of report().
173      */
174     public void reportDeferredDiagnostic() {
175         if (deferredDiagnosticKind != null) {
176             if (deferredDiagnosticArg == null)
177                 logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));
178             else
179                 logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);
180 
181             if (!verbose)
182                 logMandatoryNote(deferredDiagnosticSource, prefix + &quot;.recompile&quot;);
183         }
184     }
185 
<a name="5" id="anc5"></a>






186     /**
187      * The log to which to report warnings.
188      */
<a name="6" id="anc6"></a><span class="line-modified">189     private final Log log;</span>
190 
191     /**
192      * Whether or not to report individual warnings, or simply to report a
193      * single aggregate warning at the end of the compilation.
194      */
<a name="7" id="anc7"></a><span class="line-modified">195     private final boolean verbose;</span>
196 
197     /**
198      * The common prefix for all I18N message keys generated by this handler.
199      */
<a name="8" id="anc8"></a><span class="line-modified">200     private final String prefix;</span>
201 
202     /**
203      * A set containing the names of the source files for which specific
204      * warnings have been generated -- i.e. in verbose mode.  If a source name
205      * appears in this list, then deferred diagnostics will be phrased to
206      * include &quot;additionally&quot;...
207      */
208     private Set&lt;JavaFileObject&gt; sourcesWithReportedWarnings;
209 
210     /**
211      * A variable indicating the latest best guess at what the final
212      * deferred diagnostic will be. Initially as specific and helpful
213      * as possible, as more warnings are reported, the scope of the
214      * diagnostic will be broadened.
215      */
216     private DeferredDiagnosticKind deferredDiagnosticKind;
217 
218     /**
219      * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable
220      * gives the value of log.currentSource() for the file in question.
221      */
222     private JavaFileObject deferredDiagnosticSource;
223 
224     /**
225      * An optional argument to be used when constructing the
226      * deferred diagnostic message, based on deferredDiagnosticKind.
227      * This variable should normally be set/updated whenever
228      * deferredDiagnosticKind is updated.
229      */
230     private Object deferredDiagnosticArg;
231 
232     /**
233      * True if mandatory warnings and notes are being enforced.
234      */
235     private final boolean enforceMandatory;
236 
237     /**
238      * A LintCategory to be included in point-of-use diagnostics to indicate
239      * how messages might be suppressed (i.e. with @SuppressWarnings).
240      */
241     private final LintCategory lintCategory;
242 
243     /**
244      * Reports a mandatory warning to the log.  If mandatory warnings
245      * are not being enforced, treat this as an ordinary warning.
246      */
247     private void logMandatoryWarning(DiagnosticPosition pos, Warning warnKey) {
248         // Note: the following log methods are safe if lintCategory is null.
249         if (enforceMandatory)
250             log.mandatoryWarning(lintCategory, pos, warnKey);
251         else
252             log.warning(lintCategory, pos, warnKey);
253     }
254 
255     /**
256      * Reports a mandatory note to the log.  If mandatory notes are
257      * not being enforced, treat this as an ordinary note.
258      */
259     private void logMandatoryNote(JavaFileObject file, String msg, Object... args) {
260         if (enforceMandatory)
261             log.mandatoryNote(file, new Note(&quot;compiler&quot;, msg, args));
262         else
263             log.note(file, new Note(&quot;compiler&quot;, msg, args));
264     }
<a name="9" id="anc9"></a><span class="line-added">265 </span>
<span class="line-added">266     public void clear() {</span>
<span class="line-added">267         sourcesWithReportedWarnings = null;</span>
<span class="line-added">268         deferredDiagnosticKind = null;</span>
<span class="line-added">269         deferredDiagnosticSource = null;</span>
<span class="line-added">270         deferredDiagnosticArg = null;</span>
<span class="line-added">271     }</span>
272 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
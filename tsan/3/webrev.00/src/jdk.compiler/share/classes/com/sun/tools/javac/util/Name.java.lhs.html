<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/util/Name.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.util;
 27 
<a name="1" id="anc1"></a>

 28 import com.sun.tools.javac.util.DefinedBy.Api;
 29 
 30 /** An abstraction for internal compiler strings. They are stored in
 31  *  Utf8 format. Names are stored in a Name.Table, and are unique within
 32  *  that table.
 33  *
 34  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 35  *  If you write code that depends on this, you do so at your own risk.
 36  *  This code and its internal interfaces are subject to change or
 37  *  deletion without notice.&lt;/b&gt;
 38  */
<a name="2" id="anc2"></a><span class="line-modified"> 39 public abstract class Name implements javax.lang.model.element.Name {</span>
 40 
 41     public final Table table;
 42 
 43     protected Name(Table table) {
 44         this.table = table;
 45     }
 46 
 47     /**
 48      * {@inheritDoc}
 49      */
 50     @DefinedBy(Api.LANGUAGE_MODEL)
 51     public boolean contentEquals(CharSequence cs) {
 52         return toString().equals(cs.toString());
 53     }
 54 
<a name="3" id="anc3"></a>




 55     /**
 56      * {@inheritDoc}
 57      */
 58     public int length() {
 59         return toString().length();
 60     }
 61 
 62     /**
 63      * {@inheritDoc}
 64      */
 65     public char charAt(int index) {
 66         return toString().charAt(index);
 67     }
 68 
 69     /**
 70      * {@inheritDoc}
 71      */
 72     public CharSequence subSequence(int start, int end) {
 73         return toString().subSequence(start, end);
 74     }
 75 
 76     /** Return the concatenation of this name and name `n&#39;.
 77      */
 78     public Name append(Name n) {
 79         int len = getByteLength();
 80         byte[] bs = new byte[len + n.getByteLength()];
 81         getBytes(bs, 0);
 82         n.getBytes(bs, len);
 83         return table.fromUtf(bs, 0, bs.length);
 84     }
 85 
 86     /** Return the concatenation of this name, the given ASCII
 87      *  character, and name `n&#39;.
 88      */
 89     public Name append(char c, Name n) {
 90         int len = getByteLength();
 91         byte[] bs = new byte[len + 1 + n.getByteLength()];
 92         getBytes(bs, 0);
 93         bs[len] = (byte) c;
 94         n.getBytes(bs, len+1);
 95         return table.fromUtf(bs, 0, bs.length);
 96     }
 97 
 98     /** An arbitrary but consistent complete order among all Names.
 99      */
100     public int compareTo(Name other) {
101         return other.getIndex() - this.getIndex();
102     }
103 
104     /** Return true if this is the empty name.
105      */
106     public boolean isEmpty() {
107         return getByteLength() == 0;
108     }
109 
110     /** Returns last occurrence of byte b in this name, -1 if not found.
111      */
112     public int lastIndexOf(byte b) {
113         byte[] bytes = getByteArray();
114         int offset = getByteOffset();
115         int i = getByteLength() - 1;
116         while (i &gt;= 0 &amp;&amp; bytes[offset + i] != b) i--;
117         return i;
118     }
119 
120     /** Does this name start with prefix?
121      */
122     public boolean startsWith(Name prefix) {
123         byte[] thisBytes = this.getByteArray();
124         int thisOffset   = this.getByteOffset();
125         int thisLength   = this.getByteLength();
126         byte[] prefixBytes = prefix.getByteArray();
127         int prefixOffset   = prefix.getByteOffset();
128         int prefixLength   = prefix.getByteLength();
129 
130         if (thisLength &lt; prefixLength)
131             return false;
132 
133         int i = 0;
134         while (i &lt; prefixLength &amp;&amp;
135                thisBytes[thisOffset + i] == prefixBytes[prefixOffset + i])
136             i++;
137         return i == prefixLength;
138     }
139 
140     /** Returns the sub-name starting at position start, up to and
141      *  excluding position end.
142      */
143     public Name subName(int start, int end) {
144         if (end &lt; start) end = start;
145         return table.fromUtf(getByteArray(), getByteOffset() + start, end - start);
146     }
147 
148     /** Return the string representation of this name.
149      */
150     @Override
151     public String toString() {
152         return Convert.utf2string(getByteArray(), getByteOffset(), getByteLength());
153     }
154 
155     /** Return the Utf8 representation of this name.
156      */
157     public byte[] toUtf() {
158         byte[] bs = new byte[getByteLength()];
159         getBytes(bs, 0);
160         return bs;
161     }
162 
163     /* Get a &quot;reasonably small&quot; value that uniquely identifies this name
164      * within its name table.
165      */
166     public abstract int getIndex();
167 
168     /** Get the length (in bytes) of this name.
169      */
170     public abstract int getByteLength();
171 
172     /** Returns i&#39;th byte of this name.
173      */
174     public abstract byte getByteAt(int i);
175 
176     /** Copy all bytes of this name to buffer cs, starting at start.
177      */
178     public void getBytes(byte cs[], int start) {
179         System.arraycopy(getByteArray(), getByteOffset(), cs, start, getByteLength());
180     }
181 
182     /** Get the underlying byte array for this name. The contents of the
183      * array must not be modified.
184      */
185     public abstract byte[] getByteArray();
186 
187     /** Get the start offset of this name within its byte array.
188      */
189     public abstract int getByteOffset();
190 
<a name="4" id="anc4"></a>







191     /** An abstraction for the hash table used to create unique Name instances.
192      */
193     public static abstract class Table {
194         /** Standard name table.
195          */
196         public final Names names;
197 
198         Table(Names names) {
199             this.names = names;
200         }
201 
202         /** Get the name from the characters in cs[start..start+len-1].
203          */
204         public abstract Name fromChars(char[] cs, int start, int len);
205 
206         /** Get the name for the characters in string s.
207          */
208         public Name fromString(String s) {
209             char[] cs = s.toCharArray();
210             return fromChars(cs, 0, cs.length);
211         }
212 
213         /** Get the name for the bytes in array cs.
214          *  Assume that bytes are in utf8 format.
215          */
216         public Name fromUtf(byte[] cs) {
217             return fromUtf(cs, 0, cs.length);
218         }
219 
220         /** get the name for the bytes in cs[start..start+len-1].
221          *  Assume that bytes are in utf8 format.
222          */
223         public abstract Name fromUtf(byte[] cs, int start, int len);
224 
225         /** Release any resources used by this table.
226          */
227         public abstract void dispose();
228 
229         /** The hashcode of a name.
230          */
231         protected static int hashValue(byte bytes[], int offset, int length) {
232             int h = 0;
233             int off = offset;
234 
235             for (int i = 0; i &lt; length; i++) {
236                 h = (h &lt;&lt; 5) - h + bytes[off++];
237             }
238             return h;
239         }
240 
241         /** Compare two subarrays
242          */
243         protected static boolean equals(byte[] bytes1, int offset1,
244                 byte[] bytes2, int offset2, int length) {
245             int i = 0;
246             while (i &lt; length &amp;&amp; bytes1[offset1 + i] == bytes2[offset2 + i]) {
247                 i++;
248             }
249             return i == length;
250         }
251     }
252 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
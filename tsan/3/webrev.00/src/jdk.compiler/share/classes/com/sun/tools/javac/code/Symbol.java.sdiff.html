<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Source.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SymbolMetadata.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.annotation.Inherited;
  30 import java.util.Collections;
  31 import java.util.EnumSet;

  32 import java.util.Map;
  33 import java.util.Set;
  34 import java.util.concurrent.Callable;

  35 
  36 import javax.lang.model.element.Element;
  37 import javax.lang.model.element.ElementKind;
  38 import javax.lang.model.element.ElementVisitor;
  39 import javax.lang.model.element.ExecutableElement;
  40 import javax.lang.model.element.Modifier;
  41 import javax.lang.model.element.ModuleElement;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.lang.model.element.PackageElement;

  44 import javax.lang.model.element.TypeElement;
  45 import javax.lang.model.element.TypeParameterElement;
  46 import javax.lang.model.element.VariableElement;
  47 import javax.tools.JavaFileManager;
  48 import javax.tools.JavaFileObject;
  49 
  50 import com.sun.tools.javac.code.Kinds.Kind;
  51 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  52 import com.sun.tools.javac.code.Type.*;
  53 import com.sun.tools.javac.comp.Attr;
  54 import com.sun.tools.javac.comp.AttrContext;
  55 import com.sun.tools.javac.comp.Env;
  56 import com.sun.tools.javac.jvm.*;



  57 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
  58 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  59 import com.sun.tools.javac.tree.JCTree.Tag;
  60 import com.sun.tools.javac.util.*;
  61 import com.sun.tools.javac.util.DefinedBy.Api;

  62 import com.sun.tools.javac.util.Name;
  63 
  64 import static com.sun.tools.javac.code.Flags.*;
  65 import static com.sun.tools.javac.code.Kinds.*;
  66 import static com.sun.tools.javac.code.Kinds.Kind.*;
  67 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  68 import com.sun.tools.javac.code.Scope.WriteableScope;
<span class="line-removed">  69 import static com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode.FIRSTASGOP;</span>
  70 import static com.sun.tools.javac.code.TypeTag.CLASS;
  71 import static com.sun.tools.javac.code.TypeTag.FORALL;
  72 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  73 import static com.sun.tools.javac.jvm.ByteCodes.iadd;
  74 import static com.sun.tools.javac.jvm.ByteCodes.ishll;
  75 import static com.sun.tools.javac.jvm.ByteCodes.lushrl;
  76 import static com.sun.tools.javac.jvm.ByteCodes.lxor;
  77 import static com.sun.tools.javac.jvm.ByteCodes.string_add;
  78 
  79 /** Root class for Java symbols. It contains subclasses
  80  *  for specific sorts of symbols, such as variables, methods and operators,
  81  *  types, packages. Each subclass is represented as a static inner class
  82  *  inside Symbol.
  83  *
  84  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  *  If you write code that depends on this, you do so at your own risk.
  86  *  This code and its internal interfaces are subject to change or
  87  *  deletion without notice.&lt;/b&gt;
  88  */
<span class="line-modified">  89 public abstract class Symbol extends AnnoConstruct implements Element {</span>
  90 
  91     /** The kind of this symbol.
  92      *  @see Kinds
  93      */
  94     public Kind kind;
  95 
  96     /** The flags of this symbol.
  97      */
  98     public long flags_field;
  99 
 100     /** An accessor method for the flags of this symbol.
 101      *  Flags of class symbols should be accessed through the accessor
 102      *  method to make sure that the class symbol is loaded.
 103      */
 104     public long flags() { return flags_field; }
 105 
 106     /** The name of this symbol in Utf8 representation.
 107      */
 108     public Name name;
 109 
</pre>
<hr />
<pre>
 264 
 265     /** This method is intended for debugging only. */
 266     public SymbolMetadata getMetadata() {
 267         return metadata;
 268     }
 269 
 270     // &lt;/editor-fold&gt;
 271 
 272     /** Construct a symbol with given kind, flags, name, type and owner.
 273      */
 274     public Symbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 275         this.kind = kind;
 276         this.flags_field = flags;
 277         this.type = type;
 278         this.owner = owner;
 279         this.completer = Completer.NULL_COMPLETER;
 280         this.erasure_field = null;
 281         this.name = name;
 282     }
 283 





 284     /** Clone this symbol with new owner.
 285      *  Legal only for fields and methods.
 286      */
 287     public Symbol clone(Symbol newOwner) {
 288         throw new AssertionError();
 289     }
 290 
 291     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 292         return v.visitSymbol(this, p);
 293     }
 294 
 295     /** The Java source which this symbol represents.
 296      *  A description of this symbol; overrides Object.
 297      */
 298     public String toString() {
 299         return name.toString();
 300     }
 301 
 302     /** A Java source description of the location of this symbol; used for
 303      *  error reporting.
</pre>
<hr />
<pre>
 350                                   t.getReturnType(),
 351                                   t.getThrownTypes(),
 352                                   t.tsym);
 353         } else {
 354             return t;
 355         }
 356     }
 357 
 358     public boolean isDeprecated() {
 359         return (flags_field &amp; DEPRECATED) != 0;
 360     }
 361 
 362     public boolean hasDeprecatedAnnotation() {
 363         return (flags_field &amp; DEPRECATED_ANNOTATION) != 0;
 364     }
 365 
 366     public boolean isDeprecatedForRemoval() {
 367         return (flags_field &amp; DEPRECATED_REMOVAL) != 0;
 368     }
 369 




 370     public boolean isDeprecatableViaAnnotation() {
 371         switch (getKind()) {
 372             case LOCAL_VARIABLE:
 373             case PACKAGE:
 374             case PARAMETER:
 375             case RESOURCE_VARIABLE:
 376             case EXCEPTION_PARAMETER:
 377                 return false;
 378             default:
 379                 return true;
 380         }
 381     }
 382 
 383     public boolean isStatic() {
 384         return
 385             (flags() &amp; STATIC) != 0 ||
 386             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 387              name != name.table.names._this;
 388     }
 389 
 390     public boolean isInterface() {
 391         return (flags() &amp; INTERFACE) != 0;
 392     }
 393 




 394     public boolean isPrivate() {
 395         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 396     }
 397 




 398     public boolean isEnum() {
 399         return (flags() &amp; ENUM) != 0;
 400     }
 401 
<span class="line-modified"> 402     /** Is this symbol declared (directly or indirectly) local</span>




 403      *  to a method or variable initializer?
 404      *  Also includes fields of inner classes which are in
 405      *  turn local to a method or variable initializer.
 406      */
 407     public boolean isLocal() {
 408         return
 409             (owner.kind.matches(KindSelector.VAL_MTH) ||
 410              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 411     }
 412 
 413     /** Has this symbol an empty name? This includes anonymous
 414      *  inner classes.
 415      */
 416     public boolean isAnonymous() {
 417         return name.isEmpty();
 418     }
 419 
 420     /** Is this symbol a constructor?
 421      */
 422     public boolean isConstructor() {
 423         return name == name.table.names.init;
 424     }
 425 




 426     /** The fully qualified name of this symbol.
 427      *  This is the same as the symbol&#39;s name except for class symbols,
 428      *  which are handled separately.
 429      */
 430     public Name getQualifiedName() {
 431         return name;
 432     }
 433 
 434     /** The fully qualified name of this symbol after converting to flat
 435      *  representation. This is the same as the symbol&#39;s name except for
 436      *  class symbols, which are handled separately.
 437      */
 438     public Name flatName() {
 439         return getQualifiedName();
 440     }
 441 
 442     /** If this is a class or package, its members, otherwise null.
 443      */
 444     public WriteableScope members() {
 445         return null;
</pre>
<hr />
<pre>
 792          *
 793          * Type variables always precede other kinds of symbols.
 794          */
 795         public final boolean precedes(TypeSymbol that, Types types) {
 796             if (this == that)
 797                 return false;
 798             if (type.hasTag(that.type.getTag())) {
 799                 if (type.hasTag(CLASS)) {
 800                     return
 801                         types.rank(that.type) &lt; types.rank(this.type) ||
 802                         types.rank(that.type) == types.rank(this.type) &amp;&amp;
 803                         that.getQualifiedName().compareTo(this.getQualifiedName()) &lt; 0;
 804                 } else if (type.hasTag(TYPEVAR)) {
 805                     return types.isSubtype(this.type, that.type);
 806                 }
 807             }
 808             return type.hasTag(TYPEVAR);
 809         }
 810 
 811         @Override @DefinedBy(Api.LANGUAGE_MODEL)
<span class="line-modified"> 812         public java.util.List&lt;Symbol&gt; getEnclosedElements() {</span>
 813             List&lt;Symbol&gt; list = List.nil();
 814             if (kind == TYP &amp;&amp; type.hasTag(TYPEVAR)) {
 815                 return list;
 816             }
 817             apiComplete();
 818             for (Symbol sym : members().getSymbols(NON_RECURSIVE)) {
 819                 sym.apiComplete();
 820                 if ((sym.flags() &amp; SYNTHETIC) == 0 &amp;&amp; sym.owner == this &amp;&amp; sym.kind != ERR) {
 821                     list = list.prepend(sym);
 822                 }
 823             }
 824             return list;
 825         }
 826 
 827         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
 828             Assert.error(&quot;Only on ClassSymbol&quot;);
 829             return null; //unreachable
 830         }
 831 
 832         public boolean isAnnotationType() { return false; }
</pre>
<hr />
<pre>
 949 
 950         /**
 951          * Create a ModuleSymbol with an associated module-info ClassSymbol.
 952          */
 953         public static ModuleSymbol create(Name name, Name module_info) {
 954             ModuleSymbol msym = new ModuleSymbol(name, null);
 955             ClassSymbol info = new ClassSymbol(Flags.MODULE, module_info, msym);
 956             info.fullname = formFullName(module_info, msym);
 957             info.flatname = info.fullname;
 958             info.members_field = WriteableScope.create(info);
 959             msym.module_info = info;
 960             return msym;
 961         }
 962 
 963         public ModuleSymbol(Name name, Symbol owner) {
 964             super(MDL, 0, name, null, owner);
 965             Assert.checkNonNull(name);
 966             this.type = new ModuleType(this);
 967         }
 968 





 969         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 970         public Name getSimpleName() {
 971             return Convert.shortName(name);
 972         }
 973 
 974         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 975         public boolean isOpen() {
 976             return flags.contains(ModuleFlags.OPEN);
 977         }
 978 
 979         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 980         public boolean isUnnamed() {
 981             return name.isEmpty() &amp;&amp; owner == null;
 982         }
 983 
 984         @Override
 985         public boolean isDeprecated() {
 986             return hasDeprecatedAnnotation();
 987         }
 988 
</pre>
<hr />
<pre>
1115 
1116         public String toString() {
1117             return fullname.toString();
1118         }
1119 
1120         @DefinedBy(Api.LANGUAGE_MODEL)
1121         public Name getQualifiedName() {
1122             return fullname;
1123         }
1124 
1125         @DefinedBy(Api.LANGUAGE_MODEL)
1126         public boolean isUnnamed() {
1127             return name.isEmpty() &amp;&amp; owner != null;
1128         }
1129 
1130         public WriteableScope members() {
1131             complete();
1132             return members_field;
1133         }
1134 





1135         public long flags() {
1136             complete();
1137             return flags_field;
1138         }
1139 
1140         @Override
1141         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1142             complete();
1143             if (package_info != null) {
1144                 package_info.complete();
1145                 mergeAttributes();
1146             }
1147             return super.getRawAttributes();
1148         }
1149 
1150         private void mergeAttributes() {
1151             if (metadata == null &amp;&amp;
1152                 package_info.metadata != null) {
1153                 metadata = new SymbolMetadata(this);
1154                 metadata.setAttributes(package_info.metadata);
</pre>
<hr />
<pre>
1171         public Symbol getEnclosingElement() {
1172             return modle != null &amp;&amp; !modle.isNoModule() ? modle : null;
1173         }
1174 
1175         @DefinedBy(Api.LANGUAGE_MODEL)
1176         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1177             return v.visitPackage(this, p);
1178         }
1179 
1180         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1181             return v.visitPackageSymbol(this, p);
1182         }
1183 
1184         /**Resets the Symbol into the state good for next round of annotation processing.*/
1185         public void reset() {
1186             metadata = null;
1187         }
1188 
1189     }
1190 










1191     /** A class for class symbols
1192      */
1193     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1194 
1195         /** a scope for all class members; variables, methods and inner classes
1196          *  type parameters are not part of this scope
1197          */
1198         public WriteableScope members_field;
1199 
1200         /** the fully qualified name of the class, i.e. pck.outer.inner.
1201          *  null for anonymous classes
1202          */
1203         public Name fullname;
1204 
1205         /** the fully qualified name of the class after converting to flat
1206          *  representation, i.e. pck.outer$inner,
1207          *  set externally for local and anonymous classes
1208          */
1209         public Name flatname;
1210 
1211         /** the sourcefile where the class came from
1212          */
1213         public JavaFileObject sourcefile;
1214 
1215         /** the classfile from where to load this class
1216          *  this will have extension .class or .java
1217          */
1218         public JavaFileObject classfile;
1219 
1220         /** the list of translated local classes (used for generating
1221          * InnerClasses attribute)
1222          */
1223         public List&lt;ClassSymbol&gt; trans_local;
1224 
<span class="line-removed">1225         /** the constant pool of the class</span>
<span class="line-removed">1226          */</span>
<span class="line-removed">1227         public Pool pool;</span>
<span class="line-removed">1228 </span>
1229         /** the annotation metadata attached to this class */
1230         private AnnotationTypeMetadata annotationTypeMetadata;
1231 





1232         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1233             super(TYP, flags, name, type, owner);
1234             this.members_field = null;
1235             this.fullname = formFullName(name, owner);
1236             this.flatname = formFlatName(name, owner);
1237             this.sourcefile = null;
1238             this.classfile = null;
<span class="line-removed">1239             this.pool = null;</span>
1240             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1241         }
1242 
1243         public ClassSymbol(long flags, Name name, Symbol owner) {
1244             this(
1245                 flags,
1246                 name,
1247                 new ClassType(Type.noType, null, null),
1248                 owner);
1249             this.type.tsym = this;
1250         }
1251 
1252         /** The Java source which this symbol represents.
1253          */
1254         public String toString() {
1255             return className();
1256         }
1257 
1258         public long flags() {
1259             complete();
</pre>
<hr />
<pre>
1281             if (erasure_field == null)
1282                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1283                                               List.nil(), this,
1284                                               type.getMetadata());
1285             return erasure_field;
1286         }
1287 
1288         public String className() {
1289             if (name.isEmpty())
1290                 return
1291                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
1292             else
1293                 return fullname.toString();
1294         }
1295 
1296         @DefinedBy(Api.LANGUAGE_MODEL)
1297         public Name getQualifiedName() {
1298             return fullname;
1299         }
1300 












1301         public Name flatName() {
1302             return flatname;
1303         }
1304 
1305         public boolean isSubClass(Symbol base, Types types) {
1306             if (this == base) {
1307                 return true;
1308             } else if ((base.flags() &amp; INTERFACE) != 0) {
1309                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1310                     for (List&lt;Type&gt; is = types.interfaces(t);
1311                          is.nonEmpty();
1312                          is = is.tail)
1313                         if (is.head.tsym.isSubClass(base, types)) return true;
1314             } else {
1315                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1316                     if (t.tsym == base) return true;
1317             }
1318             return false;
1319         }
1320 
</pre>
<hr />
<pre>
1373             Type sup = getSuperclass();
1374 
1375             if (!sup.hasTag(CLASS) || sup.isErroneous())
1376                 return null;
1377 
1378             return (ClassSymbol) sup.tsym;
1379         }
1380 
1381 
1382         @Override
1383         protected &lt;A extends Annotation&gt; A[] getInheritedAnnotations(Class&lt;A&gt; annoType) {
1384 
1385             ClassSymbol sup = getSuperClassToSearchForAnnotations();
1386 
1387             return sup == null ? super.getInheritedAnnotations(annoType)
1388                                : sup.getAnnotationsByType(annoType);
1389         }
1390 
1391 
1392         @DefinedBy(Api.LANGUAGE_MODEL)

1393         public ElementKind getKind() {
1394             apiComplete();
1395             long flags = flags();
1396             if ((flags &amp; ANNOTATION) != 0)
1397                 return ElementKind.ANNOTATION_TYPE;
1398             else if ((flags &amp; INTERFACE) != 0)
1399                 return ElementKind.INTERFACE;
1400             else if ((flags &amp; ENUM) != 0)
1401                 return ElementKind.ENUM;


1402             else
1403                 return ElementKind.CLASS;
1404         }
1405 
1406         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1407         public Set&lt;Modifier&gt; getModifiers() {
1408             apiComplete();
1409             long flags = flags();
1410             return Flags.asModifierSet(flags &amp; ~DEFAULT);
1411         }
1412 




























1413         @DefinedBy(Api.LANGUAGE_MODEL)
1414         public NestingKind getNestingKind() {
1415             apiComplete();
1416             if (owner.kind == PCK)
1417                 return NestingKind.TOP_LEVEL;
1418             else if (name.isEmpty())
1419                 return NestingKind.ANONYMOUS;
1420             else if (owner.kind == MTH)
1421                 return NestingKind.LOCAL;
1422             else
1423                 return NestingKind.MEMBER;
1424         }
1425 
<span class="line-removed">1426 </span>
1427         @Override
1428         protected &lt;A extends Annotation&gt; Attribute.Compound getAttribute(final Class&lt;A&gt; annoType) {
1429 
1430             Attribute.Compound attrib = super.getAttribute(annoType);
1431 
1432             boolean inherited = annoType.isAnnotationPresent(Inherited.class);
1433             if (attrib != null || !inherited)
1434                 return attrib;
1435 
1436             // Search supertypes
1437             ClassSymbol superType = getSuperClassToSearchForAnnotations();
1438             return superType == null ? null
1439                                      : superType.getAttribute(annoType);
1440         }
1441 
<span class="line-removed">1442 </span>
<span class="line-removed">1443 </span>
<span class="line-removed">1444 </span>
1445         @DefinedBy(Api.LANGUAGE_MODEL)
1446         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1447             return v.visitType(this, p);
1448         }
1449 
1450         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1451             return v.visitClassSymbol(this, p);
1452         }
1453 
1454         public void markAbstractIfNeeded(Types types) {
1455             if (types.enter.getEnv(this) != null &amp;&amp;
1456                 (flags() &amp; ENUM) != 0 &amp;&amp; types.supertype(type).tsym == types.syms.enumSym &amp;&amp;
1457                 (flags() &amp; (FINAL | ABSTRACT)) == 0) {
1458                 if (types.firstUnimplementedAbstract(this) != null)
1459                     // add the ABSTRACT flag to an enum
1460                     flags_field |= ABSTRACT;
1461             }
1462         }
1463 
1464         /**Resets the Symbol into the state good for next round of annotation processing.*/
</pre>
<hr />
<pre>
1483         public void clearAnnotationMetadata() {
1484             metadata = null;
1485             annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1486         }
1487 
1488         @Override
1489         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1490             return annotationTypeMetadata;
1491         }
1492 
1493         @Override
1494         public boolean isAnnotationType() {
1495             return (flags_field &amp; Flags.ANNOTATION) != 0;
1496         }
1497 
1498         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1499             Assert.checkNonNull(a);
1500             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1501             this.annotationTypeMetadata = a;
1502         }




1503     }
1504 
1505 
1506     /** A class for variable symbols
1507      */
1508     public static class VarSymbol extends Symbol implements VariableElement {
1509 
1510         /** The variable&#39;s declaration position.
1511          */
1512         public int pos = Position.NOPOS;
1513 
1514         /** The variable&#39;s address. Used for different purposes during
1515          *  flow analysis, translation and code generation.
1516          *  Flow analysis:
1517          *    If this is a blank final or local variable, its sequence number.
1518          *  Translation:
1519          *    If this is a private field, its access number.
1520          *  Code generation:
1521          *    If this is a local variable, its logical slot number.
1522          */
1523         public int adr = -1;
1524 
1525         /** Construct a variable symbol, given its flags, name, type and owner.
1526          */
1527         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1528             super(VAR, flags, name, type, owner);
1529         }
1530 









1531         /** Clone this symbol with new owner.
1532          */
1533         public VarSymbol clone(Symbol newOwner) {
1534             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1535                 @Override
1536                 public Symbol baseSymbol() {
1537                     return VarSymbol.this;
1538                 }





1539             };
1540             v.pos = pos;
1541             v.adr = adr;
1542             v.data = data;
1543 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1544             return v;
1545         }
1546 
1547         public String toString() {
1548             return name.toString();
1549         }
1550 
1551         public Symbol asMemberOf(Type site, Types types) {
1552             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1553         }
1554 
1555         @DefinedBy(Api.LANGUAGE_MODEL)
1556         public ElementKind getKind() {
1557             long flags = flags();
1558             if ((flags &amp; PARAMETER) != 0) {
1559                 if (isExceptionParameter())
1560                     return ElementKind.EXCEPTION_PARAMETER;
1561                 else
1562                     return ElementKind.PARAMETER;
1563             } else if ((flags &amp; ENUM) != 0) {
1564                 return ElementKind.ENUM_CONSTANT;
1565             } else if (owner.kind == TYP || owner.kind == ERR) {
1566                 return ElementKind.FIELD;
1567             } else if (isResourceVariable()) {
1568                 return ElementKind.RESOURCE_VARIABLE;




1569             } else {
1570                 return ElementKind.LOCAL_VARIABLE;
1571             }
1572         }
1573 
1574         @DefinedBy(Api.LANGUAGE_MODEL)
1575         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1576             return v.visitVariable(this, p);
1577         }
1578 
1579         @DefinedBy(Api.LANGUAGE_MODEL)
1580         public Object getConstantValue() { // Mirror API
1581             return Constants.decode(getConstValue(), type);
1582         }
1583 
1584         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1585                                       final Attr attr,
1586                                       final JCVariableDecl variable)
1587         {
1588             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
</pre>
<hr />
<pre>
1616                 data = null; // to make sure we don&#39;t evaluate this twice.
1617                 try {
1618                     data = eval.call();
1619                 } catch (Exception ex) {
1620                     throw new AssertionError(ex);
1621                 }
1622             }
1623             return data;
1624         }
1625 
1626         public void setData(Object data) {
1627             Assert.check(!(data instanceof Env&lt;?&gt;), this);
1628             this.data = data;
1629         }
1630 
1631         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1632             return v.visitVarSymbol(this, p);
1633         }
1634     }
1635 



















































































1636     /** A class for method symbols.
1637      */
1638     public static class MethodSymbol extends Symbol implements ExecutableElement {
1639 
1640         /** The code of the method. */
1641         public Code code = null;
1642 
1643         /** The extra (synthetic/mandated) parameters of the method. */
1644         public List&lt;VarSymbol&gt; extraParams = List.nil();
1645 
1646         /** The captured local variables in an anonymous class */
1647         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1648 
1649         /** The parameters of the method. */
1650         public List&lt;VarSymbol&gt; params = null;
1651 
1652         /** For an annotation type element, its default value if any.
1653          *  The value is null if none appeared in the method
1654          *  declaration.
1655          */
1656         public Attribute defaultValue = null;
1657 
1658         /** Construct a method symbol, given its flags, name, type and owner.
1659          */
1660         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1661             super(MTH, flags, name, type, owner);
1662             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1663         }
1664 
1665         /** Clone this symbol with new owner.
1666          */
1667         public MethodSymbol clone(Symbol newOwner) {
1668             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1669                 @Override
1670                 public Symbol baseSymbol() {
1671                     return MethodSymbol.this;
1672                 }





1673             };
1674             m.code = code;
1675             return m;
1676         }
1677 
1678         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1679         public Set&lt;Modifier&gt; getModifiers() {
1680             long flags = flags();
1681             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1682         }
1683 
1684         /** The Java source which this symbol represents.
1685          */
1686         public String toString() {
1687             if ((flags() &amp; BLOCK) != 0) {
1688                 return owner.name.toString();
1689             } else {
1690                 String s = (name == name.table.names.init)
1691                     ? owner.name.toString()
1692                     : name.toString();
1693                 if (type != null) {
1694                     if (type.hasTag(FORALL))
1695                         s = &quot;&lt;&quot; + ((ForAll)type).getTypeArguments() + &quot;&gt;&quot; + s;
1696                     s += &quot;(&quot; + type.argtypes((flags() &amp; VARARGS) != 0) + &quot;)&quot;;
1697                 }
1698                 return s;
1699             }
1700         }
1701 
<span class="line-modified">1702         public boolean isDynamic() {</span>






1703             return false;
1704         }
1705 





1706         /** find a symbol that this (proxy method) symbol implements.
1707          *  @param    c       The class whose members are searched for
1708          *                    implementations
1709          */
1710         public Symbol implemented(TypeSymbol c, Types types) {
1711             Symbol impl = null;
1712             for (List&lt;Type&gt; is = types.interfaces(c.type);
1713                  impl == null &amp;&amp; is.nonEmpty();
1714                  is = is.tail) {
1715                 TypeSymbol i = is.head.tsym;
1716                 impl = implementedIn(i, types);
1717                 if (impl == null)
1718                     impl = implemented(i, types);
1719             }
1720             return impl;
1721         }
1722 
1723         public Symbol implementedIn(TypeSymbol c, Types types) {
1724             Symbol impl = null;
1725             for (Symbol sym : c.members().getSymbolsByName(name)) {
</pre>
<hr />
<pre>
1860                 return false;
1861             }
1862         }
1863 
1864         @Override
1865         public boolean isInheritedIn(Symbol clazz, Types types) {
1866             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
1867                 case PUBLIC:
1868                     return !this.owner.isInterface() ||
1869                             clazz == owner ||
1870                             (flags_field &amp; STATIC) == 0;
1871                 default:
1872                     return super.isInheritedIn(clazz, types);
1873             }
1874         }
1875 
1876         public boolean isLambdaMethod() {
1877             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
1878         }
1879 







1880         /** The implementation of this (abstract) symbol in class origin;
1881          *  null if none exists. Synthetic methods are not considered
1882          *  as possible implementations.
1883          */
1884         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
1885             return implementation(origin, types, checkResult, implementation_filter);
1886         }
1887         // where
1888             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
1889                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
1890 
1891         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
1892             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
1893             if (res != null)
1894                 return res;
1895             // if origin is derived from a raw type, we might have missed
1896             // an implementation because we do not know enough about instantiations.
1897             // in this case continue with the supertype as origin.
1898             if (types.isDerivedRaw(origin.type) &amp;&amp; !origin.isInterface())
1899                 return implementation(types.supertype(origin.type).tsym, types, checkResult);
</pre>
<hr />
<pre>
1953         public boolean isVarArgs() {
1954             return (flags() &amp; VARARGS) != 0;
1955         }
1956 
1957         @DefinedBy(Api.LANGUAGE_MODEL)
1958         public boolean isDefault() {
1959             return (flags() &amp; DEFAULT) != 0;
1960         }
1961 
1962         @DefinedBy(Api.LANGUAGE_MODEL)
1963         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1964             return v.visitExecutable(this, p);
1965         }
1966 
1967         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1968             return v.visitMethodSymbol(this, p);
1969         }
1970 
1971         @DefinedBy(Api.LANGUAGE_MODEL)
1972         public Type getReceiverType() {
<span class="line-modified">1973             return asType().getReceiverType();</span>

1974         }
1975 
1976         @DefinedBy(Api.LANGUAGE_MODEL)
1977         public Type getReturnType() {
1978             return asType().getReturnType();
1979         }
1980 
1981         @DefinedBy(Api.LANGUAGE_MODEL)
1982         public List&lt;Type&gt; getThrownTypes() {
1983             return asType().getThrownTypes();
1984         }
1985     }
1986 
1987     /** A class for invokedynamic method calls.
1988      */
<span class="line-modified">1989     public static class DynamicMethodSymbol extends MethodSymbol {</span>
1990 
<span class="line-modified">1991         public Object[] staticArgs;</span>
<span class="line-modified">1992         public Symbol bsm;</span>
<span class="line-removed">1993         public int bsmKind;</span>
1994 
<span class="line-modified">1995         public DynamicMethodSymbol(Name name, Symbol owner, int bsmKind, MethodSymbol bsm, Type type, Object[] staticArgs) {</span>
1996             super(0, name, type, owner);
1997             this.bsm = bsm;
<span class="line-removed">1998             this.bsmKind = bsmKind;</span>
1999             this.staticArgs = staticArgs;
2000         }
2001 
2002         @Override
2003         public boolean isDynamic() {
2004             return true;
2005         }































































































































2006     }
2007 
2008     /** A class for predefined operators.
2009      */
2010     public static class OperatorSymbol extends MethodSymbol {
2011 
2012         public int opcode;
2013         private int accessCode = Integer.MIN_VALUE;
2014 
2015         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2016             super(PUBLIC | STATIC, name, type, owner);
2017             this.opcode = opcode;
2018         }
2019 
2020         @Override
2021         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2022             return v.visitOperatorSymbol(this, p);
2023         }
2024 
2025         public int getAccessCode(Tag tag) {
</pre>
<hr />
<pre>
2109         };
2110 
2111         void complete(Symbol sym) throws CompletionFailure;
2112 
2113         /** Returns true if this completer is &lt;em&gt;terminal&lt;/em&gt;. A terminal
2114          * completer is used as a place holder when the symbol is completed.
2115          * Calling complete on a terminal completer will not affect the symbol.
2116          *
2117          * The dummy NULL_COMPLETER and the GraphDependencies completer are
2118          * examples of terminal completers.
2119          *
2120          * @return true iff this completer is terminal
2121          */
2122         default boolean isTerminal() {
2123             return false;
2124         }
2125     }
2126 
2127     public static class CompletionFailure extends RuntimeException {
2128         private static final long serialVersionUID = 0;
<span class="line-modified">2129         public final DeferredCompletionFailureHandler dcfh;</span>
<span class="line-modified">2130         public Symbol sym;</span>
2131 
2132         /** A diagnostic object describing the failure
2133          */
<span class="line-modified">2134         public JCDiagnostic diag;</span>


2135 
<span class="line-modified">2136         public CompletionFailure(Symbol sym, JCDiagnostic diag, DeferredCompletionFailureHandler dcfh) {</span>
2137             this.dcfh = dcfh;
2138             this.sym = sym;
<span class="line-modified">2139             this.diag = diag;</span>
2140 //          this.printStackTrace();//DEBUG
2141         }
2142 
2143         public JCDiagnostic getDiagnostic() {



2144             return diag;
2145         }
2146 
2147         @Override
2148         public String getMessage() {
<span class="line-modified">2149             return diag.getMessage(null);</span>
2150         }
2151 
2152         public JCDiagnostic getDetailValue() {
<span class="line-modified">2153             return diag;</span>
2154         }
2155 
2156         @Override
2157         public CompletionFailure initCause(Throwable cause) {
2158             super.initCause(cause);
2159             return this;
2160         }
2161 





2162     }
2163 
2164     /**
2165      * A visitor for symbols.  A visitor is used to implement operations
2166      * (or relations) on symbols.  Most common operations on types are
2167      * binary relations and this interface is designed for binary
2168      * relations, that is, operations on the form
2169      * Symbol&amp;nbsp;&amp;times;&amp;nbsp;P&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2170      * &lt;!-- In plain text: Type x P -&gt; R --&gt;
2171      *
2172      * @param &lt;R&gt; the return type of the operation implemented by this
2173      * visitor; use Void if no return type is needed.
2174      * @param &lt;P&gt; the type of the second argument (the first being the
2175      * symbol itself) of the operation implemented by this visitor; use
2176      * Void if a second argument is not needed.
2177      */
2178     public interface Visitor&lt;R,P&gt; {
2179         R visitClassSymbol(ClassSymbol s, P arg);
2180         R visitMethodSymbol(MethodSymbol s, P arg);
2181         R visitPackageSymbol(PackageSymbol s, P arg);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.annotation.Inherited;
  30 import java.util.Collections;
  31 import java.util.EnumSet;
<span class="line-added">  32 import java.util.HashMap;</span>
  33 import java.util.Map;
  34 import java.util.Set;
  35 import java.util.concurrent.Callable;
<span class="line-added">  36 import java.util.function.Supplier;</span>
  37 
  38 import javax.lang.model.element.Element;
  39 import javax.lang.model.element.ElementKind;
  40 import javax.lang.model.element.ElementVisitor;
  41 import javax.lang.model.element.ExecutableElement;
  42 import javax.lang.model.element.Modifier;
  43 import javax.lang.model.element.ModuleElement;
  44 import javax.lang.model.element.NestingKind;
  45 import javax.lang.model.element.PackageElement;
<span class="line-added">  46 import javax.lang.model.element.RecordComponentElement;</span>
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.element.TypeParameterElement;
  49 import javax.lang.model.element.VariableElement;
  50 import javax.tools.JavaFileManager;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.tools.javac.code.Kinds.Kind;
  54 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Attr;
  57 import com.sun.tools.javac.comp.AttrContext;
  58 import com.sun.tools.javac.comp.Env;
  59 import com.sun.tools.javac.jvm.*;
<span class="line-added">  60 import com.sun.tools.javac.jvm.PoolConstant;</span>
<span class="line-added">  61 import com.sun.tools.javac.tree.JCTree;</span>
<span class="line-added">  62 import com.sun.tools.javac.tree.JCTree.JCAnnotation;</span>
  63 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
  64 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  65 import com.sun.tools.javac.tree.JCTree.Tag;
  66 import com.sun.tools.javac.util.*;
  67 import com.sun.tools.javac.util.DefinedBy.Api;
<span class="line-added">  68 import com.sun.tools.javac.util.List;</span>
  69 import com.sun.tools.javac.util.Name;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Kinds.*;
  73 import static com.sun.tools.javac.code.Kinds.Kind.*;
  74 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  75 import com.sun.tools.javac.code.Scope.WriteableScope;

  76 import static com.sun.tools.javac.code.TypeTag.CLASS;
  77 import static com.sun.tools.javac.code.TypeTag.FORALL;
  78 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  79 import static com.sun.tools.javac.jvm.ByteCodes.iadd;
  80 import static com.sun.tools.javac.jvm.ByteCodes.ishll;
  81 import static com.sun.tools.javac.jvm.ByteCodes.lushrl;
  82 import static com.sun.tools.javac.jvm.ByteCodes.lxor;
  83 import static com.sun.tools.javac.jvm.ByteCodes.string_add;
  84 
  85 /** Root class for Java symbols. It contains subclasses
  86  *  for specific sorts of symbols, such as variables, methods and operators,
  87  *  types, packages. Each subclass is represented as a static inner class
  88  *  inside Symbol.
  89  *
  90  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  91  *  If you write code that depends on this, you do so at your own risk.
  92  *  This code and its internal interfaces are subject to change or
  93  *  deletion without notice.&lt;/b&gt;
  94  */
<span class="line-modified">  95 public abstract class Symbol extends AnnoConstruct implements PoolConstant, Element {</span>
  96 
  97     /** The kind of this symbol.
  98      *  @see Kinds
  99      */
 100     public Kind kind;
 101 
 102     /** The flags of this symbol.
 103      */
 104     public long flags_field;
 105 
 106     /** An accessor method for the flags of this symbol.
 107      *  Flags of class symbols should be accessed through the accessor
 108      *  method to make sure that the class symbol is loaded.
 109      */
 110     public long flags() { return flags_field; }
 111 
 112     /** The name of this symbol in Utf8 representation.
 113      */
 114     public Name name;
 115 
</pre>
<hr />
<pre>
 270 
 271     /** This method is intended for debugging only. */
 272     public SymbolMetadata getMetadata() {
 273         return metadata;
 274     }
 275 
 276     // &lt;/editor-fold&gt;
 277 
 278     /** Construct a symbol with given kind, flags, name, type and owner.
 279      */
 280     public Symbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 281         this.kind = kind;
 282         this.flags_field = flags;
 283         this.type = type;
 284         this.owner = owner;
 285         this.completer = Completer.NULL_COMPLETER;
 286         this.erasure_field = null;
 287         this.name = name;
 288     }
 289 
<span class="line-added"> 290     @Override</span>
<span class="line-added"> 291     public int poolTag() {</span>
<span class="line-added"> 292         throw new AssertionError(&quot;Invalid pool entry&quot;);</span>
<span class="line-added"> 293     }</span>
<span class="line-added"> 294 </span>
 295     /** Clone this symbol with new owner.
 296      *  Legal only for fields and methods.
 297      */
 298     public Symbol clone(Symbol newOwner) {
 299         throw new AssertionError();
 300     }
 301 
 302     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 303         return v.visitSymbol(this, p);
 304     }
 305 
 306     /** The Java source which this symbol represents.
 307      *  A description of this symbol; overrides Object.
 308      */
 309     public String toString() {
 310         return name.toString();
 311     }
 312 
 313     /** A Java source description of the location of this symbol; used for
 314      *  error reporting.
</pre>
<hr />
<pre>
 361                                   t.getReturnType(),
 362                                   t.getThrownTypes(),
 363                                   t.tsym);
 364         } else {
 365             return t;
 366         }
 367     }
 368 
 369     public boolean isDeprecated() {
 370         return (flags_field &amp; DEPRECATED) != 0;
 371     }
 372 
 373     public boolean hasDeprecatedAnnotation() {
 374         return (flags_field &amp; DEPRECATED_ANNOTATION) != 0;
 375     }
 376 
 377     public boolean isDeprecatedForRemoval() {
 378         return (flags_field &amp; DEPRECATED_REMOVAL) != 0;
 379     }
 380 
<span class="line-added"> 381     public boolean isPreviewApi() {</span>
<span class="line-added"> 382         return (flags_field &amp; PREVIEW_API) != 0;</span>
<span class="line-added"> 383     }</span>
<span class="line-added"> 384 </span>
 385     public boolean isDeprecatableViaAnnotation() {
 386         switch (getKind()) {
 387             case LOCAL_VARIABLE:
 388             case PACKAGE:
 389             case PARAMETER:
 390             case RESOURCE_VARIABLE:
 391             case EXCEPTION_PARAMETER:
 392                 return false;
 393             default:
 394                 return true;
 395         }
 396     }
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
<span class="line-added"> 409     public boolean isAbstract() {</span>
<span class="line-added"> 410         return (flags_field &amp; ABSTRACT) != 0;</span>
<span class="line-added"> 411     }</span>
<span class="line-added"> 412 </span>
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
<span class="line-added"> 417     public boolean isPublic() {</span>
<span class="line-added"> 418         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
 421     public boolean isEnum() {
 422         return (flags() &amp; ENUM) != 0;
 423     }
 424 
<span class="line-modified"> 425     public boolean isFinal() {</span>
<span class="line-added"> 426         return (flags_field &amp; FINAL) != 0;</span>
<span class="line-added"> 427     }</span>
<span class="line-added"> 428 </span>
<span class="line-added"> 429    /** Is this symbol declared (directly or indirectly) local</span>
 430      *  to a method or variable initializer?
 431      *  Also includes fields of inner classes which are in
 432      *  turn local to a method or variable initializer.
 433      */
 434     public boolean isLocal() {
 435         return
 436             (owner.kind.matches(KindSelector.VAL_MTH) ||
 437              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 438     }
 439 
 440     /** Has this symbol an empty name? This includes anonymous
 441      *  inner classes.
 442      */
 443     public boolean isAnonymous() {
 444         return name.isEmpty();
 445     }
 446 
 447     /** Is this symbol a constructor?
 448      */
 449     public boolean isConstructor() {
 450         return name == name.table.names.init;
 451     }
 452 
<span class="line-added"> 453     public boolean isDynamic() {</span>
<span class="line-added"> 454         return false;</span>
<span class="line-added"> 455     }</span>
<span class="line-added"> 456 </span>
 457     /** The fully qualified name of this symbol.
 458      *  This is the same as the symbol&#39;s name except for class symbols,
 459      *  which are handled separately.
 460      */
 461     public Name getQualifiedName() {
 462         return name;
 463     }
 464 
 465     /** The fully qualified name of this symbol after converting to flat
 466      *  representation. This is the same as the symbol&#39;s name except for
 467      *  class symbols, which are handled separately.
 468      */
 469     public Name flatName() {
 470         return getQualifiedName();
 471     }
 472 
 473     /** If this is a class or package, its members, otherwise null.
 474      */
 475     public WriteableScope members() {
 476         return null;
</pre>
<hr />
<pre>
 823          *
 824          * Type variables always precede other kinds of symbols.
 825          */
 826         public final boolean precedes(TypeSymbol that, Types types) {
 827             if (this == that)
 828                 return false;
 829             if (type.hasTag(that.type.getTag())) {
 830                 if (type.hasTag(CLASS)) {
 831                     return
 832                         types.rank(that.type) &lt; types.rank(this.type) ||
 833                         types.rank(that.type) == types.rank(this.type) &amp;&amp;
 834                         that.getQualifiedName().compareTo(this.getQualifiedName()) &lt; 0;
 835                 } else if (type.hasTag(TYPEVAR)) {
 836                     return types.isSubtype(this.type, that.type);
 837                 }
 838             }
 839             return type.hasTag(TYPEVAR);
 840         }
 841 
 842         @Override @DefinedBy(Api.LANGUAGE_MODEL)
<span class="line-modified"> 843         public List&lt;Symbol&gt; getEnclosedElements() {</span>
 844             List&lt;Symbol&gt; list = List.nil();
 845             if (kind == TYP &amp;&amp; type.hasTag(TYPEVAR)) {
 846                 return list;
 847             }
 848             apiComplete();
 849             for (Symbol sym : members().getSymbols(NON_RECURSIVE)) {
 850                 sym.apiComplete();
 851                 if ((sym.flags() &amp; SYNTHETIC) == 0 &amp;&amp; sym.owner == this &amp;&amp; sym.kind != ERR) {
 852                     list = list.prepend(sym);
 853                 }
 854             }
 855             return list;
 856         }
 857 
 858         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
 859             Assert.error(&quot;Only on ClassSymbol&quot;);
 860             return null; //unreachable
 861         }
 862 
 863         public boolean isAnnotationType() { return false; }
</pre>
<hr />
<pre>
 980 
 981         /**
 982          * Create a ModuleSymbol with an associated module-info ClassSymbol.
 983          */
 984         public static ModuleSymbol create(Name name, Name module_info) {
 985             ModuleSymbol msym = new ModuleSymbol(name, null);
 986             ClassSymbol info = new ClassSymbol(Flags.MODULE, module_info, msym);
 987             info.fullname = formFullName(module_info, msym);
 988             info.flatname = info.fullname;
 989             info.members_field = WriteableScope.create(info);
 990             msym.module_info = info;
 991             return msym;
 992         }
 993 
 994         public ModuleSymbol(Name name, Symbol owner) {
 995             super(MDL, 0, name, null, owner);
 996             Assert.checkNonNull(name);
 997             this.type = new ModuleType(this);
 998         }
 999 
<span class="line-added">1000         @Override</span>
<span class="line-added">1001         public int poolTag() {</span>
<span class="line-added">1002             return ClassFile.CONSTANT_Module;</span>
<span class="line-added">1003         }</span>
<span class="line-added">1004 </span>
1005         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1006         public Name getSimpleName() {
1007             return Convert.shortName(name);
1008         }
1009 
1010         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1011         public boolean isOpen() {
1012             return flags.contains(ModuleFlags.OPEN);
1013         }
1014 
1015         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1016         public boolean isUnnamed() {
1017             return name.isEmpty() &amp;&amp; owner == null;
1018         }
1019 
1020         @Override
1021         public boolean isDeprecated() {
1022             return hasDeprecatedAnnotation();
1023         }
1024 
</pre>
<hr />
<pre>
1151 
1152         public String toString() {
1153             return fullname.toString();
1154         }
1155 
1156         @DefinedBy(Api.LANGUAGE_MODEL)
1157         public Name getQualifiedName() {
1158             return fullname;
1159         }
1160 
1161         @DefinedBy(Api.LANGUAGE_MODEL)
1162         public boolean isUnnamed() {
1163             return name.isEmpty() &amp;&amp; owner != null;
1164         }
1165 
1166         public WriteableScope members() {
1167             complete();
1168             return members_field;
1169         }
1170 
<span class="line-added">1171         @Override</span>
<span class="line-added">1172         public int poolTag() {</span>
<span class="line-added">1173             return ClassFile.CONSTANT_Package;</span>
<span class="line-added">1174         }</span>
<span class="line-added">1175 </span>
1176         public long flags() {
1177             complete();
1178             return flags_field;
1179         }
1180 
1181         @Override
1182         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1183             complete();
1184             if (package_info != null) {
1185                 package_info.complete();
1186                 mergeAttributes();
1187             }
1188             return super.getRawAttributes();
1189         }
1190 
1191         private void mergeAttributes() {
1192             if (metadata == null &amp;&amp;
1193                 package_info.metadata != null) {
1194                 metadata = new SymbolMetadata(this);
1195                 metadata.setAttributes(package_info.metadata);
</pre>
<hr />
<pre>
1212         public Symbol getEnclosingElement() {
1213             return modle != null &amp;&amp; !modle.isNoModule() ? modle : null;
1214         }
1215 
1216         @DefinedBy(Api.LANGUAGE_MODEL)
1217         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1218             return v.visitPackage(this, p);
1219         }
1220 
1221         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1222             return v.visitPackageSymbol(this, p);
1223         }
1224 
1225         /**Resets the Symbol into the state good for next round of annotation processing.*/
1226         public void reset() {
1227             metadata = null;
1228         }
1229 
1230     }
1231 
<span class="line-added">1232     public static class RootPackageSymbol extends PackageSymbol {</span>
<span class="line-added">1233         public final MissingInfoHandler missingInfoHandler;</span>
<span class="line-added">1234 </span>
<span class="line-added">1235         public RootPackageSymbol(Name name, Symbol owner, MissingInfoHandler missingInfoHandler) {</span>
<span class="line-added">1236             super(name, owner);</span>
<span class="line-added">1237             this.missingInfoHandler = missingInfoHandler;</span>
<span class="line-added">1238         }</span>
<span class="line-added">1239 </span>
<span class="line-added">1240     }</span>
<span class="line-added">1241 </span>
1242     /** A class for class symbols
1243      */
1244     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1245 
1246         /** a scope for all class members; variables, methods and inner classes
1247          *  type parameters are not part of this scope
1248          */
1249         public WriteableScope members_field;
1250 
1251         /** the fully qualified name of the class, i.e. pck.outer.inner.
1252          *  null for anonymous classes
1253          */
1254         public Name fullname;
1255 
1256         /** the fully qualified name of the class after converting to flat
1257          *  representation, i.e. pck.outer$inner,
1258          *  set externally for local and anonymous classes
1259          */
1260         public Name flatname;
1261 
1262         /** the sourcefile where the class came from
1263          */
1264         public JavaFileObject sourcefile;
1265 
1266         /** the classfile from where to load this class
1267          *  this will have extension .class or .java
1268          */
1269         public JavaFileObject classfile;
1270 
1271         /** the list of translated local classes (used for generating
1272          * InnerClasses attribute)
1273          */
1274         public List&lt;ClassSymbol&gt; trans_local;
1275 




1276         /** the annotation metadata attached to this class */
1277         private AnnotationTypeMetadata annotationTypeMetadata;
1278 
<span class="line-added">1279         /* the list of any of record components, only non empty if the class is a record</span>
<span class="line-added">1280          * and it has at least one record component</span>
<span class="line-added">1281          */</span>
<span class="line-added">1282         private List&lt;RecordComponent&gt; recordComponents = List.nil();</span>
<span class="line-added">1283 </span>
1284         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1285             super(TYP, flags, name, type, owner);
1286             this.members_field = null;
1287             this.fullname = formFullName(name, owner);
1288             this.flatname = formFlatName(name, owner);
1289             this.sourcefile = null;
1290             this.classfile = null;

1291             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1292         }
1293 
1294         public ClassSymbol(long flags, Name name, Symbol owner) {
1295             this(
1296                 flags,
1297                 name,
1298                 new ClassType(Type.noType, null, null),
1299                 owner);
1300             this.type.tsym = this;
1301         }
1302 
1303         /** The Java source which this symbol represents.
1304          */
1305         public String toString() {
1306             return className();
1307         }
1308 
1309         public long flags() {
1310             complete();
</pre>
<hr />
<pre>
1332             if (erasure_field == null)
1333                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1334                                               List.nil(), this,
1335                                               type.getMetadata());
1336             return erasure_field;
1337         }
1338 
1339         public String className() {
1340             if (name.isEmpty())
1341                 return
1342                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
1343             else
1344                 return fullname.toString();
1345         }
1346 
1347         @DefinedBy(Api.LANGUAGE_MODEL)
1348         public Name getQualifiedName() {
1349             return fullname;
1350         }
1351 
<span class="line-added">1352         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">1353         public List&lt;Symbol&gt; getEnclosedElements() {</span>
<span class="line-added">1354             List&lt;Symbol&gt; result = super.getEnclosedElements();</span>
<span class="line-added">1355             if (!recordComponents.isEmpty()) {</span>
<span class="line-added">1356                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();</span>
<span class="line-added">1357                 for (RecordComponent rc : reversed) {</span>
<span class="line-added">1358                     result = result.prepend(rc);</span>
<span class="line-added">1359                 }</span>
<span class="line-added">1360             }</span>
<span class="line-added">1361             return result;</span>
<span class="line-added">1362         }</span>
<span class="line-added">1363 </span>
1364         public Name flatName() {
1365             return flatname;
1366         }
1367 
1368         public boolean isSubClass(Symbol base, Types types) {
1369             if (this == base) {
1370                 return true;
1371             } else if ((base.flags() &amp; INTERFACE) != 0) {
1372                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1373                     for (List&lt;Type&gt; is = types.interfaces(t);
1374                          is.nonEmpty();
1375                          is = is.tail)
1376                         if (is.head.tsym.isSubClass(base, types)) return true;
1377             } else {
1378                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1379                     if (t.tsym == base) return true;
1380             }
1381             return false;
1382         }
1383 
</pre>
<hr />
<pre>
1436             Type sup = getSuperclass();
1437 
1438             if (!sup.hasTag(CLASS) || sup.isErroneous())
1439                 return null;
1440 
1441             return (ClassSymbol) sup.tsym;
1442         }
1443 
1444 
1445         @Override
1446         protected &lt;A extends Annotation&gt; A[] getInheritedAnnotations(Class&lt;A&gt; annoType) {
1447 
1448             ClassSymbol sup = getSuperClassToSearchForAnnotations();
1449 
1450             return sup == null ? super.getInheritedAnnotations(annoType)
1451                                : sup.getAnnotationsByType(annoType);
1452         }
1453 
1454 
1455         @DefinedBy(Api.LANGUAGE_MODEL)
<span class="line-added">1456         @SuppressWarnings(&quot;preview&quot;)</span>
1457         public ElementKind getKind() {
1458             apiComplete();
1459             long flags = flags();
1460             if ((flags &amp; ANNOTATION) != 0)
1461                 return ElementKind.ANNOTATION_TYPE;
1462             else if ((flags &amp; INTERFACE) != 0)
1463                 return ElementKind.INTERFACE;
1464             else if ((flags &amp; ENUM) != 0)
1465                 return ElementKind.ENUM;
<span class="line-added">1466             else if ((flags &amp; RECORD) != 0)</span>
<span class="line-added">1467                 return ElementKind.RECORD;</span>
1468             else
1469                 return ElementKind.CLASS;
1470         }
1471 
1472         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1473         public Set&lt;Modifier&gt; getModifiers() {
1474             apiComplete();
1475             long flags = flags();
1476             return Flags.asModifierSet(flags &amp; ~DEFAULT);
1477         }
1478 
<span class="line-added">1479         public RecordComponent getRecordComponent(VarSymbol field) {</span>
<span class="line-added">1480             for (RecordComponent rc : recordComponents) {</span>
<span class="line-added">1481                 if (rc.name == field.name) {</span>
<span class="line-added">1482                     return rc;</span>
<span class="line-added">1483                 }</span>
<span class="line-added">1484             }</span>
<span class="line-added">1485             return null;</span>
<span class="line-added">1486         }</span>
<span class="line-added">1487 </span>
<span class="line-added">1488         public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing) {</span>
<span class="line-added">1489             for (RecordComponent rc : recordComponents) {</span>
<span class="line-added">1490                 if (rc.name == var.name) {</span>
<span class="line-added">1491                     return rc;</span>
<span class="line-added">1492                 }</span>
<span class="line-added">1493             }</span>
<span class="line-added">1494             RecordComponent rc = null;</span>
<span class="line-added">1495             if (addIfMissing) {</span>
<span class="line-added">1496                 recordComponents = recordComponents.append(rc = new RecordComponent(var));</span>
<span class="line-added">1497             }</span>
<span class="line-added">1498             return rc;</span>
<span class="line-added">1499         }</span>
<span class="line-added">1500 </span>
<span class="line-added">1501         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">1502         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1503         public List&lt;? extends RecordComponent&gt; getRecordComponents() {</span>
<span class="line-added">1504             return recordComponents;</span>
<span class="line-added">1505         }</span>
<span class="line-added">1506 </span>
1507         @DefinedBy(Api.LANGUAGE_MODEL)
1508         public NestingKind getNestingKind() {
1509             apiComplete();
1510             if (owner.kind == PCK)
1511                 return NestingKind.TOP_LEVEL;
1512             else if (name.isEmpty())
1513                 return NestingKind.ANONYMOUS;
1514             else if (owner.kind == MTH)
1515                 return NestingKind.LOCAL;
1516             else
1517                 return NestingKind.MEMBER;
1518         }
1519 

1520         @Override
1521         protected &lt;A extends Annotation&gt; Attribute.Compound getAttribute(final Class&lt;A&gt; annoType) {
1522 
1523             Attribute.Compound attrib = super.getAttribute(annoType);
1524 
1525             boolean inherited = annoType.isAnnotationPresent(Inherited.class);
1526             if (attrib != null || !inherited)
1527                 return attrib;
1528 
1529             // Search supertypes
1530             ClassSymbol superType = getSuperClassToSearchForAnnotations();
1531             return superType == null ? null
1532                                      : superType.getAttribute(annoType);
1533         }
1534 



1535         @DefinedBy(Api.LANGUAGE_MODEL)
1536         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1537             return v.visitType(this, p);
1538         }
1539 
1540         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1541             return v.visitClassSymbol(this, p);
1542         }
1543 
1544         public void markAbstractIfNeeded(Types types) {
1545             if (types.enter.getEnv(this) != null &amp;&amp;
1546                 (flags() &amp; ENUM) != 0 &amp;&amp; types.supertype(type).tsym == types.syms.enumSym &amp;&amp;
1547                 (flags() &amp; (FINAL | ABSTRACT)) == 0) {
1548                 if (types.firstUnimplementedAbstract(this) != null)
1549                     // add the ABSTRACT flag to an enum
1550                     flags_field |= ABSTRACT;
1551             }
1552         }
1553 
1554         /**Resets the Symbol into the state good for next round of annotation processing.*/
</pre>
<hr />
<pre>
1573         public void clearAnnotationMetadata() {
1574             metadata = null;
1575             annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1576         }
1577 
1578         @Override
1579         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1580             return annotationTypeMetadata;
1581         }
1582 
1583         @Override
1584         public boolean isAnnotationType() {
1585             return (flags_field &amp; Flags.ANNOTATION) != 0;
1586         }
1587 
1588         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1589             Assert.checkNonNull(a);
1590             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1591             this.annotationTypeMetadata = a;
1592         }
<span class="line-added">1593 </span>
<span class="line-added">1594         public boolean isRecord() {</span>
<span class="line-added">1595             return (flags_field &amp; RECORD) != 0;</span>
<span class="line-added">1596         }</span>
1597     }
1598 
1599 
1600     /** A class for variable symbols
1601      */
1602     public static class VarSymbol extends Symbol implements VariableElement {
1603 
1604         /** The variable&#39;s declaration position.
1605          */
1606         public int pos = Position.NOPOS;
1607 
1608         /** The variable&#39;s address. Used for different purposes during
1609          *  flow analysis, translation and code generation.
1610          *  Flow analysis:
1611          *    If this is a blank final or local variable, its sequence number.
1612          *  Translation:
1613          *    If this is a private field, its access number.
1614          *  Code generation:
1615          *    If this is a local variable, its logical slot number.
1616          */
1617         public int adr = -1;
1618 
1619         /** Construct a variable symbol, given its flags, name, type and owner.
1620          */
1621         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1622             super(VAR, flags, name, type, owner);
1623         }
1624 
<span class="line-added">1625         @Override</span>
<span class="line-added">1626         public int poolTag() {</span>
<span class="line-added">1627             return ClassFile.CONSTANT_Fieldref;</span>
<span class="line-added">1628         }</span>
<span class="line-added">1629 </span>
<span class="line-added">1630         public MethodHandleSymbol asMethodHandle(boolean getter) {</span>
<span class="line-added">1631             return new MethodHandleSymbol(this, getter);</span>
<span class="line-added">1632         }</span>
<span class="line-added">1633 </span>
1634         /** Clone this symbol with new owner.
1635          */
1636         public VarSymbol clone(Symbol newOwner) {
1637             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1638                 @Override
1639                 public Symbol baseSymbol() {
1640                     return VarSymbol.this;
1641                 }
<span class="line-added">1642 </span>
<span class="line-added">1643                 @Override</span>
<span class="line-added">1644                 public Object poolKey(Types types) {</span>
<span class="line-added">1645                     return new Pair&lt;&gt;(newOwner, baseSymbol());</span>
<span class="line-added">1646                 }</span>
1647             };
1648             v.pos = pos;
1649             v.adr = adr;
1650             v.data = data;
1651 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1652             return v;
1653         }
1654 
1655         public String toString() {
1656             return name.toString();
1657         }
1658 
1659         public Symbol asMemberOf(Type site, Types types) {
1660             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1661         }
1662 
1663         @DefinedBy(Api.LANGUAGE_MODEL)
1664         public ElementKind getKind() {
1665             long flags = flags();
1666             if ((flags &amp; PARAMETER) != 0) {
1667                 if (isExceptionParameter())
1668                     return ElementKind.EXCEPTION_PARAMETER;
1669                 else
1670                     return ElementKind.PARAMETER;
1671             } else if ((flags &amp; ENUM) != 0) {
1672                 return ElementKind.ENUM_CONSTANT;
1673             } else if (owner.kind == TYP || owner.kind == ERR) {
1674                 return ElementKind.FIELD;
1675             } else if (isResourceVariable()) {
1676                 return ElementKind.RESOURCE_VARIABLE;
<span class="line-added">1677             } else if ((flags &amp; MATCH_BINDING) != 0) {</span>
<span class="line-added">1678                 @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1679                 ElementKind kind = ElementKind.BINDING_VARIABLE;</span>
<span class="line-added">1680                 return kind;</span>
1681             } else {
1682                 return ElementKind.LOCAL_VARIABLE;
1683             }
1684         }
1685 
1686         @DefinedBy(Api.LANGUAGE_MODEL)
1687         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1688             return v.visitVariable(this, p);
1689         }
1690 
1691         @DefinedBy(Api.LANGUAGE_MODEL)
1692         public Object getConstantValue() { // Mirror API
1693             return Constants.decode(getConstValue(), type);
1694         }
1695 
1696         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1697                                       final Attr attr,
1698                                       final JCVariableDecl variable)
1699         {
1700             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
</pre>
<hr />
<pre>
1728                 data = null; // to make sure we don&#39;t evaluate this twice.
1729                 try {
1730                     data = eval.call();
1731                 } catch (Exception ex) {
1732                     throw new AssertionError(ex);
1733                 }
1734             }
1735             return data;
1736         }
1737 
1738         public void setData(Object data) {
1739             Assert.check(!(data instanceof Env&lt;?&gt;), this);
1740             this.data = data;
1741         }
1742 
1743         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1744             return v.visitVarSymbol(this, p);
1745         }
1746     }
1747 
<span class="line-added">1748     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1749     public static class RecordComponent extends VarSymbol implements RecordComponentElement {</span>
<span class="line-added">1750         public MethodSymbol accessor;</span>
<span class="line-added">1751         public JCTree.JCMethodDecl accessorMeth;</span>
<span class="line-added">1752         private final List&lt;JCAnnotation&gt; originalAnnos;</span>
<span class="line-added">1753 </span>
<span class="line-added">1754         /**</span>
<span class="line-added">1755          * Construct a record component, given its flags, name, type and owner.</span>
<span class="line-added">1756          */</span>
<span class="line-added">1757         public RecordComponent(JCVariableDecl fieldDecl) {</span>
<span class="line-added">1758             super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);</span>
<span class="line-added">1759             this.originalAnnos = fieldDecl.mods.annotations;</span>
<span class="line-added">1760         }</span>
<span class="line-added">1761 </span>
<span class="line-added">1762         public List&lt;JCAnnotation&gt; getOriginalAnnos() { return originalAnnos; }</span>
<span class="line-added">1763 </span>
<span class="line-added">1764         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">1765         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1766         public ElementKind getKind() {</span>
<span class="line-added">1767             return ElementKind.RECORD_COMPONENT;</span>
<span class="line-added">1768         }</span>
<span class="line-added">1769 </span>
<span class="line-added">1770         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">1771         public ExecutableElement getAccessor() {</span>
<span class="line-added">1772             return accessor;</span>
<span class="line-added">1773         }</span>
<span class="line-added">1774 </span>
<span class="line-added">1775         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">1776         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">1777         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {</span>
<span class="line-added">1778             return v.visitRecordComponent(this, p);</span>
<span class="line-added">1779         }</span>
<span class="line-added">1780     }</span>
<span class="line-added">1781 </span>
<span class="line-added">1782     public static class ParamSymbol extends VarSymbol {</span>
<span class="line-added">1783         public ParamSymbol(long flags, Name name, Type type, Symbol owner) {</span>
<span class="line-added">1784             super(flags, name, type, owner);</span>
<span class="line-added">1785         }</span>
<span class="line-added">1786 </span>
<span class="line-added">1787         @Override</span>
<span class="line-added">1788         public Name getSimpleName() {</span>
<span class="line-added">1789             if ((flags_field &amp; NAME_FILLED) == 0) {</span>
<span class="line-added">1790                 flags_field |= NAME_FILLED;</span>
<span class="line-added">1791                 Symbol rootPack = this;</span>
<span class="line-added">1792                 while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {</span>
<span class="line-added">1793                     rootPack = rootPack.owner;</span>
<span class="line-added">1794                 }</span>
<span class="line-added">1795                 if (rootPack != null) {</span>
<span class="line-added">1796                     Name inferredName =</span>
<span class="line-added">1797                             ((RootPackageSymbol) rootPack).missingInfoHandler.getParameterName(this);</span>
<span class="line-added">1798                     if (inferredName != null) {</span>
<span class="line-added">1799                         this.name = inferredName;</span>
<span class="line-added">1800                     }</span>
<span class="line-added">1801                 }</span>
<span class="line-added">1802             }</span>
<span class="line-added">1803             return super.getSimpleName();</span>
<span class="line-added">1804         }</span>
<span class="line-added">1805 </span>
<span class="line-added">1806     }</span>
<span class="line-added">1807 </span>
<span class="line-added">1808     public static class BindingSymbol extends VarSymbol {</span>
<span class="line-added">1809 </span>
<span class="line-added">1810         public BindingSymbol(Name name, Type type, Symbol owner) {</span>
<span class="line-added">1811             super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);</span>
<span class="line-added">1812         }</span>
<span class="line-added">1813 </span>
<span class="line-added">1814         public boolean isAliasFor(BindingSymbol b) {</span>
<span class="line-added">1815             return aliases().containsAll(b.aliases());</span>
<span class="line-added">1816         }</span>
<span class="line-added">1817 </span>
<span class="line-added">1818         List&lt;BindingSymbol&gt; aliases() {</span>
<span class="line-added">1819             return List.of(this);</span>
<span class="line-added">1820         }</span>
<span class="line-added">1821 </span>
<span class="line-added">1822         public void preserveBinding() {</span>
<span class="line-added">1823             flags_field |= Flags.MATCH_BINDING_TO_OUTER;</span>
<span class="line-added">1824         }</span>
<span class="line-added">1825 </span>
<span class="line-added">1826         public boolean isPreserved() {</span>
<span class="line-added">1827             return (flags_field &amp; Flags.MATCH_BINDING_TO_OUTER) != 0;</span>
<span class="line-added">1828         }</span>
<span class="line-added">1829     }</span>
<span class="line-added">1830 </span>
1831     /** A class for method symbols.
1832      */
1833     public static class MethodSymbol extends Symbol implements ExecutableElement {
1834 
1835         /** The code of the method. */
1836         public Code code = null;
1837 
1838         /** The extra (synthetic/mandated) parameters of the method. */
1839         public List&lt;VarSymbol&gt; extraParams = List.nil();
1840 
1841         /** The captured local variables in an anonymous class */
1842         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1843 
1844         /** The parameters of the method. */
1845         public List&lt;VarSymbol&gt; params = null;
1846 
1847         /** For an annotation type element, its default value if any.
1848          *  The value is null if none appeared in the method
1849          *  declaration.
1850          */
1851         public Attribute defaultValue = null;
1852 
1853         /** Construct a method symbol, given its flags, name, type and owner.
1854          */
1855         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1856             super(MTH, flags, name, type, owner);
1857             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1858         }
1859 
1860         /** Clone this symbol with new owner.
1861          */
1862         public MethodSymbol clone(Symbol newOwner) {
1863             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1864                 @Override
1865                 public Symbol baseSymbol() {
1866                     return MethodSymbol.this;
1867                 }
<span class="line-added">1868 </span>
<span class="line-added">1869                 @Override</span>
<span class="line-added">1870                 public Object poolKey(Types types) {</span>
<span class="line-added">1871                     return new Pair&lt;&gt;(newOwner, baseSymbol());</span>
<span class="line-added">1872                 }</span>
1873             };
1874             m.code = code;
1875             return m;
1876         }
1877 
1878         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1879         public Set&lt;Modifier&gt; getModifiers() {
1880             long flags = flags();
1881             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1882         }
1883 
1884         /** The Java source which this symbol represents.
1885          */
1886         public String toString() {
1887             if ((flags() &amp; BLOCK) != 0) {
1888                 return owner.name.toString();
1889             } else {
1890                 String s = (name == name.table.names.init)
1891                     ? owner.name.toString()
1892                     : name.toString();
1893                 if (type != null) {
1894                     if (type.hasTag(FORALL))
1895                         s = &quot;&lt;&quot; + ((ForAll)type).getTypeArguments() + &quot;&gt;&quot; + s;
1896                     s += &quot;(&quot; + type.argtypes((flags() &amp; VARARGS) != 0) + &quot;)&quot;;
1897                 }
1898                 return s;
1899             }
1900         }
1901 
<span class="line-modified">1902         @Override</span>
<span class="line-added">1903         public int poolTag() {</span>
<span class="line-added">1904             return owner.isInterface() ?</span>
<span class="line-added">1905                     ClassFile.CONSTANT_InterfaceMethodref : ClassFile.CONSTANT_Methodref;</span>
<span class="line-added">1906         }</span>
<span class="line-added">1907 </span>
<span class="line-added">1908         public boolean isHandle() {</span>
1909             return false;
1910         }
1911 
<span class="line-added">1912 </span>
<span class="line-added">1913         public MethodHandleSymbol asHandle() {</span>
<span class="line-added">1914             return new MethodHandleSymbol(this);</span>
<span class="line-added">1915         }</span>
<span class="line-added">1916 </span>
1917         /** find a symbol that this (proxy method) symbol implements.
1918          *  @param    c       The class whose members are searched for
1919          *                    implementations
1920          */
1921         public Symbol implemented(TypeSymbol c, Types types) {
1922             Symbol impl = null;
1923             for (List&lt;Type&gt; is = types.interfaces(c.type);
1924                  impl == null &amp;&amp; is.nonEmpty();
1925                  is = is.tail) {
1926                 TypeSymbol i = is.head.tsym;
1927                 impl = implementedIn(i, types);
1928                 if (impl == null)
1929                     impl = implemented(i, types);
1930             }
1931             return impl;
1932         }
1933 
1934         public Symbol implementedIn(TypeSymbol c, Types types) {
1935             Symbol impl = null;
1936             for (Symbol sym : c.members().getSymbolsByName(name)) {
</pre>
<hr />
<pre>
2071                 return false;
2072             }
2073         }
2074 
2075         @Override
2076         public boolean isInheritedIn(Symbol clazz, Types types) {
2077             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2078                 case PUBLIC:
2079                     return !this.owner.isInterface() ||
2080                             clazz == owner ||
2081                             (flags_field &amp; STATIC) == 0;
2082                 default:
2083                     return super.isInheritedIn(clazz, types);
2084             }
2085         }
2086 
2087         public boolean isLambdaMethod() {
2088             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2089         }
2090 
<span class="line-added">2091         /** override this method to point to the original enclosing method if this method symbol represents a synthetic</span>
<span class="line-added">2092          *  lambda method</span>
<span class="line-added">2093          */</span>
<span class="line-added">2094         public MethodSymbol originalEnclosingMethod() {</span>
<span class="line-added">2095             return this;</span>
<span class="line-added">2096         }</span>
<span class="line-added">2097 </span>
2098         /** The implementation of this (abstract) symbol in class origin;
2099          *  null if none exists. Synthetic methods are not considered
2100          *  as possible implementations.
2101          */
2102         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2103             return implementation(origin, types, checkResult, implementation_filter);
2104         }
2105         // where
2106             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2107                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2108 
2109         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2110             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
2111             if (res != null)
2112                 return res;
2113             // if origin is derived from a raw type, we might have missed
2114             // an implementation because we do not know enough about instantiations.
2115             // in this case continue with the supertype as origin.
2116             if (types.isDerivedRaw(origin.type) &amp;&amp; !origin.isInterface())
2117                 return implementation(types.supertype(origin.type).tsym, types, checkResult);
</pre>
<hr />
<pre>
2171         public boolean isVarArgs() {
2172             return (flags() &amp; VARARGS) != 0;
2173         }
2174 
2175         @DefinedBy(Api.LANGUAGE_MODEL)
2176         public boolean isDefault() {
2177             return (flags() &amp; DEFAULT) != 0;
2178         }
2179 
2180         @DefinedBy(Api.LANGUAGE_MODEL)
2181         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
2182             return v.visitExecutable(this, p);
2183         }
2184 
2185         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2186             return v.visitMethodSymbol(this, p);
2187         }
2188 
2189         @DefinedBy(Api.LANGUAGE_MODEL)
2190         public Type getReceiverType() {
<span class="line-modified">2191             Type result = asType().getReceiverType();</span>
<span class="line-added">2192             return (result == null) ? Type.noType : result;</span>
2193         }
2194 
2195         @DefinedBy(Api.LANGUAGE_MODEL)
2196         public Type getReturnType() {
2197             return asType().getReturnType();
2198         }
2199 
2200         @DefinedBy(Api.LANGUAGE_MODEL)
2201         public List&lt;Type&gt; getThrownTypes() {
2202             return asType().getThrownTypes();
2203         }
2204     }
2205 
2206     /** A class for invokedynamic method calls.
2207      */
<span class="line-modified">2208     public static class DynamicMethodSymbol extends MethodSymbol implements Dynamic {</span>
2209 
<span class="line-modified">2210         public LoadableConstant[] staticArgs;</span>
<span class="line-modified">2211         public MethodHandleSymbol bsm;</span>

2212 
<span class="line-modified">2213         public DynamicMethodSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {</span>
2214             super(0, name, type, owner);
2215             this.bsm = bsm;

2216             this.staticArgs = staticArgs;
2217         }
2218 
2219         @Override
2220         public boolean isDynamic() {
2221             return true;
2222         }
<span class="line-added">2223 </span>
<span class="line-added">2224         @Override</span>
<span class="line-added">2225         public LoadableConstant[] staticArgs() {</span>
<span class="line-added">2226             return staticArgs;</span>
<span class="line-added">2227         }</span>
<span class="line-added">2228 </span>
<span class="line-added">2229         @Override</span>
<span class="line-added">2230         public MethodHandleSymbol bootstrapMethod() {</span>
<span class="line-added">2231             return bsm;</span>
<span class="line-added">2232         }</span>
<span class="line-added">2233 </span>
<span class="line-added">2234         @Override</span>
<span class="line-added">2235         public int poolTag() {</span>
<span class="line-added">2236             return ClassFile.CONSTANT_InvokeDynamic;</span>
<span class="line-added">2237         }</span>
<span class="line-added">2238 </span>
<span class="line-added">2239         @Override</span>
<span class="line-added">2240         public Type dynamicType() {</span>
<span class="line-added">2241             return type;</span>
<span class="line-added">2242         }</span>
<span class="line-added">2243     }</span>
<span class="line-added">2244 </span>
<span class="line-added">2245     /** A class for condy.</span>
<span class="line-added">2246      */</span>
<span class="line-added">2247     public static class DynamicVarSymbol extends VarSymbol implements Dynamic, LoadableConstant {</span>
<span class="line-added">2248         public LoadableConstant[] staticArgs;</span>
<span class="line-added">2249         public MethodHandleSymbol bsm;</span>
<span class="line-added">2250 </span>
<span class="line-added">2251         public DynamicVarSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {</span>
<span class="line-added">2252             super(0, name, type, owner);</span>
<span class="line-added">2253             this.bsm = bsm;</span>
<span class="line-added">2254             this.staticArgs = staticArgs;</span>
<span class="line-added">2255         }</span>
<span class="line-added">2256 </span>
<span class="line-added">2257         @Override</span>
<span class="line-added">2258         public boolean isDynamic() {</span>
<span class="line-added">2259             return true;</span>
<span class="line-added">2260         }</span>
<span class="line-added">2261 </span>
<span class="line-added">2262         @Override</span>
<span class="line-added">2263         public PoolConstant dynamicType() {</span>
<span class="line-added">2264             return type;</span>
<span class="line-added">2265         }</span>
<span class="line-added">2266 </span>
<span class="line-added">2267         @Override</span>
<span class="line-added">2268         public LoadableConstant[] staticArgs() {</span>
<span class="line-added">2269             return staticArgs;</span>
<span class="line-added">2270         }</span>
<span class="line-added">2271 </span>
<span class="line-added">2272         @Override</span>
<span class="line-added">2273         public LoadableConstant bootstrapMethod() {</span>
<span class="line-added">2274             return bsm;</span>
<span class="line-added">2275         }</span>
<span class="line-added">2276 </span>
<span class="line-added">2277         @Override</span>
<span class="line-added">2278         public int poolTag() {</span>
<span class="line-added">2279             return ClassFile.CONSTANT_Dynamic;</span>
<span class="line-added">2280         }</span>
<span class="line-added">2281     }</span>
<span class="line-added">2282 </span>
<span class="line-added">2283     /** A class for method handles.</span>
<span class="line-added">2284      */</span>
<span class="line-added">2285     public static class MethodHandleSymbol extends MethodSymbol implements LoadableConstant {</span>
<span class="line-added">2286 </span>
<span class="line-added">2287         private Symbol refSym;</span>
<span class="line-added">2288         private boolean getter;</span>
<span class="line-added">2289 </span>
<span class="line-added">2290         public MethodHandleSymbol(Symbol msym) {</span>
<span class="line-added">2291             this(msym, false);</span>
<span class="line-added">2292         }</span>
<span class="line-added">2293 </span>
<span class="line-added">2294         public MethodHandleSymbol(Symbol msym, boolean getter) {</span>
<span class="line-added">2295             super(msym.flags_field, msym.name, msym.type, msym.owner);</span>
<span class="line-added">2296             this.refSym = msym;</span>
<span class="line-added">2297             this.getter = getter;</span>
<span class="line-added">2298         }</span>
<span class="line-added">2299 </span>
<span class="line-added">2300         /**</span>
<span class="line-added">2301          * Returns the kind associated with this method handle.</span>
<span class="line-added">2302          */</span>
<span class="line-added">2303         public int referenceKind() {</span>
<span class="line-added">2304             if (refSym.kind == VAR) {</span>
<span class="line-added">2305                 return getter ?</span>
<span class="line-added">2306                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :</span>
<span class="line-added">2307                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;</span>
<span class="line-added">2308             } else {</span>
<span class="line-added">2309                 if (refSym.isConstructor()) {</span>
<span class="line-added">2310                     return ClassFile.REF_newInvokeSpecial;</span>
<span class="line-added">2311                 } else {</span>
<span class="line-added">2312                     if (refSym.isStatic()) {</span>
<span class="line-added">2313                         return ClassFile.REF_invokeStatic;</span>
<span class="line-added">2314                     } else if ((refSym.flags() &amp; PRIVATE) != 0) {</span>
<span class="line-added">2315                         return ClassFile.REF_invokeSpecial;</span>
<span class="line-added">2316                     } else if (refSym.enclClass().isInterface()) {</span>
<span class="line-added">2317                         return ClassFile.REF_invokeInterface;</span>
<span class="line-added">2318                     } else {</span>
<span class="line-added">2319                         return ClassFile.REF_invokeVirtual;</span>
<span class="line-added">2320                     }</span>
<span class="line-added">2321                 }</span>
<span class="line-added">2322             }</span>
<span class="line-added">2323         }</span>
<span class="line-added">2324 </span>
<span class="line-added">2325         @Override</span>
<span class="line-added">2326         public int poolTag() {</span>
<span class="line-added">2327             return ClassFile.CONSTANT_MethodHandle;</span>
<span class="line-added">2328         }</span>
<span class="line-added">2329 </span>
<span class="line-added">2330         @Override</span>
<span class="line-added">2331         public Object poolKey(Types types) {</span>
<span class="line-added">2332             return new Pair&lt;&gt;(baseSymbol(), referenceKind());</span>
<span class="line-added">2333         }</span>
<span class="line-added">2334 </span>
<span class="line-added">2335         @Override</span>
<span class="line-added">2336         public MethodHandleSymbol asHandle() {</span>
<span class="line-added">2337             return this;</span>
<span class="line-added">2338         }</span>
<span class="line-added">2339 </span>
<span class="line-added">2340         @Override</span>
<span class="line-added">2341         public Symbol baseSymbol() {</span>
<span class="line-added">2342             return refSym;</span>
<span class="line-added">2343         }</span>
<span class="line-added">2344 </span>
<span class="line-added">2345 </span>
<span class="line-added">2346         @Override</span>
<span class="line-added">2347         public boolean isHandle() {</span>
<span class="line-added">2348             return true;</span>
<span class="line-added">2349         }</span>
2350     }
2351 
2352     /** A class for predefined operators.
2353      */
2354     public static class OperatorSymbol extends MethodSymbol {
2355 
2356         public int opcode;
2357         private int accessCode = Integer.MIN_VALUE;
2358 
2359         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2360             super(PUBLIC | STATIC, name, type, owner);
2361             this.opcode = opcode;
2362         }
2363 
2364         @Override
2365         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2366             return v.visitOperatorSymbol(this, p);
2367         }
2368 
2369         public int getAccessCode(Tag tag) {
</pre>
<hr />
<pre>
2453         };
2454 
2455         void complete(Symbol sym) throws CompletionFailure;
2456 
2457         /** Returns true if this completer is &lt;em&gt;terminal&lt;/em&gt;. A terminal
2458          * completer is used as a place holder when the symbol is completed.
2459          * Calling complete on a terminal completer will not affect the symbol.
2460          *
2461          * The dummy NULL_COMPLETER and the GraphDependencies completer are
2462          * examples of terminal completers.
2463          *
2464          * @return true iff this completer is terminal
2465          */
2466         default boolean isTerminal() {
2467             return false;
2468         }
2469     }
2470 
2471     public static class CompletionFailure extends RuntimeException {
2472         private static final long serialVersionUID = 0;
<span class="line-modified">2473         public final transient DeferredCompletionFailureHandler dcfh;</span>
<span class="line-modified">2474         public transient Symbol sym;</span>
2475 
2476         /** A diagnostic object describing the failure
2477          */
<span class="line-modified">2478         private transient JCDiagnostic diag;</span>
<span class="line-added">2479 </span>
<span class="line-added">2480         private transient Supplier&lt;JCDiagnostic&gt; diagSupplier;</span>
2481 
<span class="line-modified">2482         public CompletionFailure(Symbol sym, Supplier&lt;JCDiagnostic&gt; diagSupplier, DeferredCompletionFailureHandler dcfh) {</span>
2483             this.dcfh = dcfh;
2484             this.sym = sym;
<span class="line-modified">2485             this.diagSupplier = diagSupplier;</span>
2486 //          this.printStackTrace();//DEBUG
2487         }
2488 
2489         public JCDiagnostic getDiagnostic() {
<span class="line-added">2490             if (diag == null &amp;&amp; diagSupplier != null) {</span>
<span class="line-added">2491                 diag = diagSupplier.get();</span>
<span class="line-added">2492             }</span>
2493             return diag;
2494         }
2495 
2496         @Override
2497         public String getMessage() {
<span class="line-modified">2498             return getDiagnostic().getMessage(null);</span>
2499         }
2500 
2501         public JCDiagnostic getDetailValue() {
<span class="line-modified">2502             return getDiagnostic();</span>
2503         }
2504 
2505         @Override
2506         public CompletionFailure initCause(Throwable cause) {
2507             super.initCause(cause);
2508             return this;
2509         }
2510 
<span class="line-added">2511         public void resetDiagnostic(Supplier&lt;JCDiagnostic&gt; diagSupplier) {</span>
<span class="line-added">2512             this.diagSupplier = diagSupplier;</span>
<span class="line-added">2513             this.diag = null;</span>
<span class="line-added">2514         }</span>
<span class="line-added">2515 </span>
2516     }
2517 
2518     /**
2519      * A visitor for symbols.  A visitor is used to implement operations
2520      * (or relations) on symbols.  Most common operations on types are
2521      * binary relations and this interface is designed for binary
2522      * relations, that is, operations on the form
2523      * Symbol&amp;nbsp;&amp;times;&amp;nbsp;P&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2524      * &lt;!-- In plain text: Type x P -&gt; R --&gt;
2525      *
2526      * @param &lt;R&gt; the return type of the operation implemented by this
2527      * visitor; use Void if no return type is needed.
2528      * @param &lt;P&gt; the type of the second argument (the first being the
2529      * symbol itself) of the operation implemented by this visitor; use
2530      * Void if a second argument is not needed.
2531      */
2532     public interface Visitor&lt;R,P&gt; {
2533         R visitClassSymbol(ClassSymbol s, P arg);
2534         R visitMethodSymbol(MethodSymbol s, P arg);
2535         R visitPackageSymbol(PackageSymbol s, P arg);
</pre>
</td>
</tr>
</table>
<center><a href="Source.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SymbolMetadata.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java
@@ -34,11 +34,14 @@
 import javax.lang.model.type.*;
 
 import com.sun.tools.javac.code.Symbol.*;
 import com.sun.tools.javac.code.TypeMetadata.Entry;
 import com.sun.tools.javac.code.Types.TypeMapping;
+import com.sun.tools.javac.code.Types.UniqueType;
 import com.sun.tools.javac.comp.Infer.IncorporationAction;
+import com.sun.tools.javac.jvm.ClassFile;
+import com.sun.tools.javac.jvm.PoolConstant;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.DefinedBy.Api;
 
 import static com.sun.tools.javac.code.BoundKind.*;
 import static com.sun.tools.javac.code.Flags.*;
@@ -71,11 +74,11 @@
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
  *
  *  @see TypeTag
  */
-public abstract class Type extends AnnoConstruct implements TypeMirror {
+public abstract class Type extends AnnoConstruct implements TypeMirror, PoolConstant {
 
     /**
      * Type metadata,  Should be {@code null} for the default value.
      *
      * Note: it is an invariant that for any {@code TypeMetadata}
@@ -123,10 +126,20 @@
 
     /** The defining class / interface / package / type variable.
      */
     public TypeSymbol tsym;
 
+    @Override
+    public int poolTag() {
+        throw new AssertionError("Invalid pool entry");
+    }
+
+    @Override
+    public Object poolKey(Types types) {
+        return new UniqueType(this, types);
+    }
+
     /**
      * Checks if the current type tag is equal to the given tag.
      * @return true if tag is equal to the current type tag.
      */
     public boolean hasTag(TypeTag tag) {
@@ -462,11 +475,11 @@
         return sb.toString();
     }
 
     /**
      * The Java source which this type list represents.  A List is
-     * represented as a comma-spearated listing of the elements in
+     * represented as a comma-separated listing of the elements in
      * that list.
      */
     public static String toString(List<Type> ts) {
         if (ts.isEmpty()) {
             return "";
@@ -928,11 +941,11 @@
         public <R, P> R accept(TypeVisitor<R, P> v, P p) {
             return v.visitWildcard(this, p);
         }
     }
 
-    public static class ClassType extends Type implements DeclaredType,
+    public static class ClassType extends Type implements DeclaredType, LoadableConstant,
                                                           javax.lang.model.type.ErrorType {
 
         /** The enclosing type of this type. If this is the type of an inner
          *  class, outer_field refers to the type of its enclosing
          *  instance class, in all other cases it refers to noType.
@@ -973,10 +986,14 @@
             this.allparams_field = null;
             this.supertype_field = null;
             this.interfaces_field = null;
         }
 
+        public int poolTag() {
+            return ClassFile.CONSTANT_Class;
+        }
+
         @Override
         public ClassType cloneWithMetadata(TypeMetadata md) {
             return new ClassType(outer_field, typarams_field, tsym, md) {
                 @Override
                 public Type baseType() { return ClassType.this.baseType(); }
@@ -1275,11 +1292,11 @@
             return v.visitIntersection(this, p);
         }
     }
 
     public static class ArrayType extends Type
-            implements javax.lang.model.type.ArrayType {
+            implements LoadableConstant, javax.lang.model.type.ArrayType {
 
         public Type elemtype;
 
         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
             this(elemtype, arrayClass, TypeMetadata.EMPTY);
@@ -1295,10 +1312,14 @@
             //note: type metadata is deliberately shared here, as we want side-effects from annotation
             //processing to flow from original array to the cloned array.
             this(that.elemtype, that.tsym, that.getMetadata());
         }
 
+        public int poolTag() {
+            return ClassFile.CONSTANT_Class;
+        }
+
         @Override
         public ArrayType cloneWithMetadata(TypeMetadata md) {
             return new ArrayType(elemtype, tsym, md) {
                 @Override
                 public Type baseType() { return ArrayType.this.baseType(); }
@@ -1410,11 +1431,11 @@
         public <R, P> R accept(TypeVisitor<R, P> v, P p) {
             return v.visitArray(this, p);
         }
     }
 
-    public static class MethodType extends Type implements ExecutableType {
+    public static class MethodType extends Type implements ExecutableType, LoadableConstant {
 
         public List<Type> argtypes;
         public Type restype;
         public List<Type> thrown;
 
@@ -1477,10 +1498,15 @@
             return
                 isErroneous(argtypes) ||
                 restype != null && restype.isErroneous();
         }
 
+        @Override
+        public int poolTag() {
+            return ClassFile.CONSTANT_MethodType;
+        }
+
         public boolean contains(Type elem) {
             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
         }
 
         public MethodType asMethodType() { return this; }

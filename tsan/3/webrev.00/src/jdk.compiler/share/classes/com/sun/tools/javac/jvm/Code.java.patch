diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,21 +25,34 @@
 
 package com.sun.tools.javac.jvm;
 
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.code.Symbol.*;
-import com.sun.tools.javac.code.Types.UniqueType;
 import com.sun.tools.javac.resources.CompilerProperties.Errors;
-import com.sun.tools.javac.tree.JCTree;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 
+import java.util.function.ToIntBiFunction;
+import java.util.function.ToIntFunction;
+
 import static com.sun.tools.javac.code.TypeTag.BOT;
 import static com.sun.tools.javac.code.TypeTag.INT;
 import static com.sun.tools.javac.jvm.ByteCodes.*;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Class;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Double;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Fieldref;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Float;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Integer;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_InterfaceMethodref;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Long;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodHandle;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodType;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Methodref;
+import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_String;
 import static com.sun.tools.javac.jvm.UninitializedType.*;
 import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableFrame;
+import java.util.Arrays;
 
 /** An internal structure that corresponds to the code attribute of
  *  methods in a classfile. The class also provides some utility operations to
  *  generate bytecode instructions.
  *
@@ -70,10 +83,11 @@
         }
     }
 
     final Types types;
     final Symtab syms;
+    final PoolWriter poolWriter;
 
 /*---------- classfile fields: --------------- */
 
     /** The maximum stack size.
      */
@@ -175,14 +189,10 @@
 
     /** Emit line number info if map supplied
      */
     Position.LineMap lineMap;
 
-    /** The constant pool of the current class.
-     */
-    final Pool pool;
-
     final MethodSymbol meth;
 
     private int letExprStackPos = 0;
 
     /** Construct a code object, given the settings of the fatcode,
@@ -195,19 +205,20 @@
                 StackMapFormat stackMap,
                 boolean debugCode,
                 CRTable crt,
                 Symtab syms,
                 Types types,
-                Pool pool) {
+                PoolWriter poolWriter) {
         this.meth = meth;
         this.fatcode = fatcode;
         this.lineMap = lineMap;
         this.lineDebugInfo = lineMap != null;
         this.varDebugInfo = varDebugInfo;
         this.crt = crt;
         this.syms = syms;
         this.types = types;
+        this.poolWriter = poolWriter;
         this.debugCode = debugCode;
         this.stackMap = stackMap;
         switch (stackMap) {
         case CLDC:
         case JSR202:
@@ -216,11 +227,10 @@
         default:
             this.needStackMap = false;
         }
         state = new State();
         lvar = new LocalVar[20];
-        this.pool = pool;
     }
 
 
 /* **************************************************************************
  * Typecodes & related stuff
@@ -387,16 +397,17 @@
         Assert.check(alive || isStatementStart());
     }
 
     /** Emit a ldc (or ldc_w) instruction, taking into account operand size
     */
-    public void emitLdc(int od) {
+    public void emitLdc(LoadableConstant constant) {
+        int od = poolWriter.putConstant(constant);
         if (od <= 255) {
-            emitop1(ldc1, od);
+            emitop1(ldc1, od, constant);
         }
         else {
-            emitop2(ldc2, od);
+            emitop2(ldc2, od, constant);
         }
     }
 
     /** Emit a multinewarray instruction.
      */
@@ -429,65 +440,64 @@
         state.push(arrayType);
     }
 
     /** Emit an invokeinterface instruction.
      */
-    public void emitInvokeinterface(int meth, Type mtype) {
+    public void emitInvokeinterface(Symbol member, Type mtype) {
         int argsize = width(mtype.getParameterTypes());
         emitop(invokeinterface);
         if (!alive) return;
-        emit2(meth);
+        emit2(poolWriter.putMember(member));
         emit1(argsize + 1);
         emit1(0);
         state.pop(argsize + 1);
         state.push(mtype.getReturnType());
     }
 
     /** Emit an invokespecial instruction.
      */
-    public void emitInvokespecial(int meth, Type mtype) {
+    public void emitInvokespecial(Symbol member, Type mtype) {
         int argsize = width(mtype.getParameterTypes());
         emitop(invokespecial);
         if (!alive) return;
-        emit2(meth);
-        Symbol sym = (Symbol)pool.pool[meth];
+        emit2(poolWriter.putMember(member));
         state.pop(argsize);
-        if (sym.isConstructor())
+        if (member.isConstructor())
             state.markInitialized((UninitializedType)state.peek());
         state.pop(1);
         state.push(mtype.getReturnType());
     }
 
     /** Emit an invokestatic instruction.
      */
-    public void emitInvokestatic(int meth, Type mtype) {
+    public void emitInvokestatic(Symbol member, Type mtype) {
         int argsize = width(mtype.getParameterTypes());
         emitop(invokestatic);
         if (!alive) return;
-        emit2(meth);
+        emit2(poolWriter.putMember(member));
         state.pop(argsize);
         state.push(mtype.getReturnType());
     }
 
     /** Emit an invokevirtual instruction.
      */
-    public void emitInvokevirtual(int meth, Type mtype) {
+    public void emitInvokevirtual(Symbol member, Type mtype) {
         int argsize = width(mtype.getParameterTypes());
         emitop(invokevirtual);
         if (!alive) return;
-        emit2(meth);
+        emit2(poolWriter.putMember(member));
         state.pop(argsize + 1);
         state.push(mtype.getReturnType());
     }
 
     /** Emit an invokedynamic instruction.
      */
-    public void emitInvokedynamic(int desc, Type mtype) {
+    public void emitInvokedynamic(DynamicMethodSymbol dynMember, Type mtype) {
         int argsize = width(mtype.getParameterTypes());
         emitop(invokedynamic);
         if (!alive) return;
-        emit2(desc);
+        emit2(poolWriter.putDynamic(dynMember));
         emit2(0);
         state.pop(argsize);
         state.push(mtype.getReturnType());
     }
 
@@ -894,45 +904,30 @@
     }
 
     /** Emit an opcode with a one-byte operand field.
      */
     public void emitop1(int op, int od) {
+        emitop1(op, od, null);
+    }
+
+    public void emitop1(int op, int od, PoolConstant data) {
         emitop(op);
         if (!alive) return;
         emit1(od);
         switch (op) {
         case bipush:
             state.push(syms.intType);
             break;
         case ldc1:
-            state.push(typeForPool(pool.pool[od]));
+            state.push(types.constantType((LoadableConstant)data));
             break;
         default:
             throw new AssertionError(mnem(op));
         }
         postop();
     }
 
-    /** The type of a constant pool entry. */
-    private Type typeForPool(Object o) {
-        if (o instanceof Integer) return syms.intType;
-        if (o instanceof Float) return syms.floatType;
-        if (o instanceof String) return syms.stringType;
-        if (o instanceof Long) return syms.longType;
-        if (o instanceof Double) return syms.doubleType;
-        if (o instanceof ClassSymbol) return syms.classType;
-        if (o instanceof Pool.MethodHandle) return syms.methodHandleType;
-        if (o instanceof UniqueType) return typeForPool(((UniqueType)o).type);
-        if (o instanceof Type) {
-            Type ty = (Type) o;
-
-            if (ty instanceof Type.ArrayType) return syms.classType;
-            if (ty instanceof Type.MethodType) return syms.methodTypeType;
-        }
-        throw new AssertionError("Invalid type of constant pool entry: " + o.getClass());
-    }
-
     /** Emit an opcode with a one-byte operand field;
      *  widen if field does not fit in a byte.
      */
     public void emitop1w(int op, int od) {
         if (od > 0xFF) {
@@ -1001,33 +996,35 @@
         }
     }
 
     /** Emit an opcode with a two-byte operand field.
      */
+    public <P extends PoolConstant> void emitop2(int op, P constant, ToIntBiFunction<PoolWriter, P> poolFunc) {
+        int od = poolFunc.applyAsInt(poolWriter, constant);
+        emitop2(op, od, constant);
+    }
+
     public void emitop2(int op, int od) {
+        emitop2(op, od, null);
+    }
+
+    public void emitop2(int op, int od, PoolConstant data) {
         emitop(op);
         if (!alive) return;
         emit2(od);
         switch (op) {
         case getstatic:
-            state.push(((Symbol)(pool.pool[od])).erasure(types));
+            state.push(((Symbol)data).erasure(types));
             break;
         case putstatic:
-            state.pop(((Symbol)(pool.pool[od])).erasure(types));
-            break;
-        case new_:
-            Symbol sym;
-            if (pool.pool[od] instanceof UniqueType) {
-                // Required by change in Gen.makeRef to allow
-                // annotated types.
-                // TODO: is this needed anywhere else?
-                sym = ((UniqueType)(pool.pool[od])).type.tsym;
-            } else {
-                sym = (Symbol)(pool.pool[od]);
-            }
-            state.push(uninitializedObject(sym.erasure(types), cp-3));
+            state.pop(((Symbol)data).erasure(types));
             break;
+        case new_: {
+            Type t = (Type)data;
+            state.push(uninitializedObject(t.tsym.erasure(types), cp-3));
+            break;
+        }
         case sipush:
             state.push(syms.intType);
             break;
         case if_acmp_null:
         case if_acmp_nonnull:
@@ -1051,34 +1048,31 @@
             break;
         case goto_:
             markDead();
             break;
         case putfield:
-            state.pop(((Symbol)(pool.pool[od])).erasure(types));
+            state.pop(((Symbol)data).erasure(types));
             state.pop(1); // object ref
             break;
         case getfield:
             state.pop(1); // object ref
-            state.push(((Symbol)(pool.pool[od])).erasure(types));
+            state.push(((Symbol)data).erasure(types));
             break;
         case checkcast: {
             state.pop(1); // object ref
-            Object o = pool.pool[od];
-            Type t = (o instanceof Symbol)
-                ? ((Symbol)o).erasure(types)
-                : types.erasure((((UniqueType)o).type));
+            Type t = types.erasure((Type)data);
             state.push(t);
             break; }
         case ldc2w:
-            state.push(typeForPool(pool.pool[od]));
+            state.push(types.constantType((LoadableConstant)data));
             break;
         case instanceof_:
             state.pop(1);
             state.push(syms.intType);
             break;
         case ldc2:
-            state.push(typeForPool(pool.pool[od]));
+            state.push(types.constantType((LoadableConstant)data));
             break;
         case jsr:
             break;
         default:
             throw new AssertionError(mnem(op));
@@ -2080,10 +2074,11 @@
             char length = (char)(curCP() - v.lastRange().start_pc);
             if (length < Character.MAX_VALUE) {
                 lvar[adr] = v.dup();
                 v.closeRange(length);
                 putVar(v);
+                fillLocalVarPosition(v);
             } else {
                 v.removeLastRange();
             }
         }
     }
@@ -2111,24 +2106,35 @@
     }
 
     private void fillLocalVarPosition(LocalVar lv) {
         if (lv == null || lv.sym == null || lv.sym.isExceptionParameter()|| !lv.sym.hasTypeAnnotations())
             return;
-        LocalVar.Range widestRange = lv.getWidestRange();
+        LocalVar.Range[] validRanges = lv.aliveRanges.stream().filter(r -> r.closed() && r.length > 0).toArray(s -> new LocalVar.Range[s]);
+        if (validRanges.length == 0)
+            return ;
+        int[] lvarOffset = Arrays.stream(validRanges).mapToInt(r -> r.start_pc).toArray();
+        int[] lvarLength = Arrays.stream(validRanges).mapToInt(r -> r.length).toArray();
+        int[] lvarIndex = Arrays.stream(validRanges).mapToInt(r -> lv.reg).toArray();
         for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
             TypeAnnotationPosition p = ta.position;
-            if (widestRange.closed() && widestRange.length > 0) {
-                p.lvarOffset = new int[] { (int)widestRange.start_pc };
-                p.lvarLength = new int[] { (int)widestRange.length };
-                p.lvarIndex = new int[] { (int)lv.reg };
-                p.isValidOffset = true;
-            } else {
-                p.isValidOffset = false;
-            }
+            p.lvarOffset = appendArray(p.lvarOffset, lvarOffset);
+            p.lvarLength = appendArray(p.lvarLength, lvarLength);
+            p.lvarIndex = appendArray(p.lvarIndex, lvarIndex);
+            p.isValidOffset = true;
         }
     }
 
+    private int[] appendArray(int[] source, int[] append) {
+        if (source == null || source.length == 0) return append;
+
+        int[] result = new int[source.length + append.length];
+
+        System.arraycopy(source, 0, result, 0, source.length);
+        System.arraycopy(append, 0, result, source.length, append.length);
+        return result;
+    }
+
     // Method to be called after compressCatchTable to
     // fill in the exception table index for type
     // annotations on exception parameters.
     public void fillExceptionParameterPositions() {
         for (int i = 0; i < varBufferSize; ++i) {

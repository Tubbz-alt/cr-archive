<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeCopier.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2006, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.tree;
 27 
 28 import com.sun.source.tree.*;
 29 import com.sun.source.tree.Tree.Kind;
 30 import com.sun.tools.javac.tree.JCTree.*;
 31 import com.sun.tools.javac.util.DefinedBy;
 32 import com.sun.tools.javac.util.DefinedBy.Api;
 33 import com.sun.tools.javac.util.List;
 34 import com.sun.tools.javac.util.ListBuffer;
 35 
 36 /**
 37  * Creates a copy of a tree, using a given TreeMaker.
 38  * Names, literal values, etc are shared with the original.
 39  *
 40  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 41  *  If you write code that depends on this, you do so at your own risk.
 42  *  This code and its internal interfaces are subject to change or
 43  *  deletion without notice.&lt;/b&gt;
 44  */
 45 public class TreeCopier&lt;P&gt; implements TreeVisitor&lt;JCTree,P&gt; {
 46     private TreeMaker M;
 47 
 48     /** Creates a new instance of TreeCopier */
 49     public TreeCopier(TreeMaker M) {
 50         this.M = M;
 51     }
 52 
 53     public &lt;T extends JCTree&gt; T copy(T tree) {
 54         return copy(tree, null);
 55     }
 56 
 57     @SuppressWarnings(&quot;unchecked&quot;)
 58     public &lt;T extends JCTree&gt; T copy(T tree, P p) {
 59         if (tree == null)
 60             return null;
 61         return (T) (tree.accept(this, p));
 62     }
 63 
 64     public &lt;T extends JCTree&gt; List&lt;T&gt; copy(List&lt;T&gt; trees) {
 65         return copy(trees, null);
 66     }
 67 
 68     public &lt;T extends JCTree&gt; List&lt;T&gt; copy(List&lt;T&gt; trees, P p) {
 69         if (trees == null)
 70             return null;
 71         ListBuffer&lt;T&gt; lb = new ListBuffer&lt;&gt;();
 72         for (T tree: trees)
 73             lb.append(copy(tree, p));
 74         return lb.toList();
 75     }
 76 
 77     @DefinedBy(Api.COMPILER_TREE)
 78     public JCTree visitAnnotatedType(AnnotatedTypeTree node, P p) {
 79         JCAnnotatedType t = (JCAnnotatedType) node;
 80         List&lt;JCAnnotation&gt; annotations = copy(t.annotations, p);
 81         JCExpression underlyingType = copy(t.underlyingType, p);
 82         return M.at(t.pos).AnnotatedType(annotations, underlyingType);
 83     }
 84 
 85     @DefinedBy(Api.COMPILER_TREE)
 86     public JCTree visitAnnotation(AnnotationTree node, P p) {
 87         JCAnnotation t = (JCAnnotation) node;
 88         JCTree annotationType = copy(t.annotationType, p);
 89         List&lt;JCExpression&gt; args = copy(t.args, p);
 90         if (t.getKind() == Tree.Kind.TYPE_ANNOTATION) {
 91             JCAnnotation newTA = M.at(t.pos).TypeAnnotation(annotationType, args);
 92             newTA.attribute = t.attribute;
 93             return newTA;
 94         } else {
 95             JCAnnotation newT = M.at(t.pos).Annotation(annotationType, args);
 96             newT.attribute = t.attribute;
 97             return newT;
 98         }
 99     }
100 
101     @DefinedBy(Api.COMPILER_TREE)
102     public JCTree visitAssert(AssertTree node, P p) {
103         JCAssert t = (JCAssert) node;
104         JCExpression cond = copy(t.cond, p);
105         JCExpression detail = copy(t.detail, p);
106         return M.at(t.pos).Assert(cond, detail);
107     }
108 
109     @DefinedBy(Api.COMPILER_TREE)
110     public JCTree visitAssignment(AssignmentTree node, P p) {
111         JCAssign t = (JCAssign) node;
112         JCExpression lhs = copy(t.lhs, p);
113         JCExpression rhs = copy(t.rhs, p);
114         return M.at(t.pos).Assign(lhs, rhs);
115     }
116 
117     @DefinedBy(Api.COMPILER_TREE)
118     public JCTree visitCompoundAssignment(CompoundAssignmentTree node, P p) {
119         JCAssignOp t = (JCAssignOp) node;
120         JCTree lhs = copy(t.lhs, p);
121         JCTree rhs = copy(t.rhs, p);
122         return M.at(t.pos).Assignop(t.getTag(), lhs, rhs);
123     }
124 
125     @DefinedBy(Api.COMPILER_TREE)
126     public JCTree visitBinary(BinaryTree node, P p) {
127         JCBinary t = (JCBinary) node;
128         JCExpression lhs = copy(t.lhs, p);
129         JCExpression rhs = copy(t.rhs, p);
130         return M.at(t.pos).Binary(t.getTag(), lhs, rhs);
131     }
132 
133     @DefinedBy(Api.COMPILER_TREE)
134     public JCTree visitBlock(BlockTree node, P p) {
135         JCBlock t = (JCBlock) node;
136         List&lt;JCStatement&gt; stats = copy(t.stats, p);
137         return M.at(t.pos).Block(t.flags, stats);
138     }
139 
140     @DefinedBy(Api.COMPILER_TREE)
141     public JCTree visitBreak(BreakTree node, P p) {
142         JCBreak t = (JCBreak) node;
143         JCExpression value = copy(t.value, p);
144         return M.at(t.pos).Break(value);
145     }
146 
147     @DefinedBy(Api.COMPILER_TREE)
148     public JCTree visitCase(CaseTree node, P p) {
149         JCCase t = (JCCase) node;
150         List&lt;JCExpression&gt; pats = copy(t.pats, p);
151         List&lt;JCStatement&gt; stats = copy(t.stats, p);
152         JCTree body = copy(t.body, p);
153         return M.at(t.pos).Case(t.caseKind, pats, stats, body);
154     }
155 
156     @DefinedBy(Api.COMPILER_TREE)
157     public JCTree visitCatch(CatchTree node, P p) {
158         JCCatch t = (JCCatch) node;
159         JCVariableDecl param = copy(t.param, p);
160         JCBlock body = copy(t.body, p);
161         return M.at(t.pos).Catch(param, body);
162     }
163 
164     @DefinedBy(Api.COMPILER_TREE)
165     public JCTree visitClass(ClassTree node, P p) {
166         JCClassDecl t = (JCClassDecl) node;
167         JCModifiers mods = copy(t.mods, p);
168         List&lt;JCTypeParameter&gt; typarams = copy(t.typarams, p);
169         JCExpression extending = copy(t.extending, p);
170         List&lt;JCExpression&gt; implementing = copy(t.implementing, p);
171         List&lt;JCTree&gt; defs = copy(t.defs, p);
172         return M.at(t.pos).ClassDef(mods, t.name, typarams, extending, implementing, defs);
173     }
174 
175     @DefinedBy(Api.COMPILER_TREE)
176     public JCTree visitConditionalExpression(ConditionalExpressionTree node, P p) {
177         JCConditional t = (JCConditional) node;
178         JCExpression cond = copy(t.cond, p);
179         JCExpression truepart = copy(t.truepart, p);
180         JCExpression falsepart = copy(t.falsepart, p);
181         return M.at(t.pos).Conditional(cond, truepart, falsepart);
182     }
183 
184     @DefinedBy(Api.COMPILER_TREE)
185     public JCTree visitContinue(ContinueTree node, P p) {
186         JCContinue t = (JCContinue) node;
187         return M.at(t.pos).Continue(t.label);
188     }
189 
190     @DefinedBy(Api.COMPILER_TREE)
191     public JCTree visitDoWhileLoop(DoWhileLoopTree node, P p) {
192         JCDoWhileLoop t = (JCDoWhileLoop) node;
193         JCStatement body = copy(t.body, p);
194         JCExpression cond = copy(t.cond, p);
195         return M.at(t.pos).DoLoop(body, cond);
196     }
197 
198     @DefinedBy(Api.COMPILER_TREE)
199     public JCTree visitErroneous(ErroneousTree node, P p) {
200         JCErroneous t = (JCErroneous) node;
201         List&lt;? extends JCTree&gt; errs = copy(t.errs, p);
202         return M.at(t.pos).Erroneous(errs);
203     }
204 
205     @DefinedBy(Api.COMPILER_TREE)
206     public JCTree visitExpressionStatement(ExpressionStatementTree node, P p) {
207         JCExpressionStatement t = (JCExpressionStatement) node;
208         JCExpression expr = copy(t.expr, p);
209         return M.at(t.pos).Exec(expr);
210     }
211 
212     @DefinedBy(Api.COMPILER_TREE)
213     public JCTree visitEnhancedForLoop(EnhancedForLoopTree node, P p) {
214         JCEnhancedForLoop t = (JCEnhancedForLoop) node;
215         JCVariableDecl var = copy(t.var, p);
216         JCExpression expr = copy(t.expr, p);
217         JCStatement body = copy(t.body, p);
218         return M.at(t.pos).ForeachLoop(var, expr, body);
219     }
220 
221     @DefinedBy(Api.COMPILER_TREE)
222     public JCTree visitForLoop(ForLoopTree node, P p) {
223         JCForLoop t = (JCForLoop) node;
224         List&lt;JCStatement&gt; init = copy(t.init, p);
225         JCExpression cond = copy(t.cond, p);
226         List&lt;JCExpressionStatement&gt; step = copy(t.step, p);
227         JCStatement body = copy(t.body, p);
228         return M.at(t.pos).ForLoop(init, cond, step, body);
229     }
230 
231     @DefinedBy(Api.COMPILER_TREE)
232     public JCTree visitIdentifier(IdentifierTree node, P p) {
233         JCIdent t = (JCIdent) node;
234         return M.at(t.pos).Ident(t.name);
235     }
236 
237     @DefinedBy(Api.COMPILER_TREE)
238     public JCTree visitIf(IfTree node, P p) {
239         JCIf t = (JCIf) node;
240         JCExpression cond = copy(t.cond, p);
241         JCStatement thenpart = copy(t.thenpart, p);
242         JCStatement elsepart = copy(t.elsepart, p);
243         return M.at(t.pos).If(cond, thenpart, elsepart);
244     }
245 
246     @DefinedBy(Api.COMPILER_TREE)
247     public JCTree visitImport(ImportTree node, P p) {
248         JCImport t = (JCImport) node;
249         JCTree qualid = copy(t.qualid, p);
250         return M.at(t.pos).Import(qualid, t.staticImport);
251     }
252 
253     @DefinedBy(Api.COMPILER_TREE)
254     public JCTree visitArrayAccess(ArrayAccessTree node, P p) {
255         JCArrayAccess t = (JCArrayAccess) node;
256         JCExpression indexed = copy(t.indexed, p);
257         JCExpression index = copy(t.index, p);
258         return M.at(t.pos).Indexed(indexed, index);
259     }
260 
261     @DefinedBy(Api.COMPILER_TREE)
262     public JCTree visitLabeledStatement(LabeledStatementTree node, P p) {
263         JCLabeledStatement t = (JCLabeledStatement) node;
264         JCStatement body = copy(t.body, p);
265         return M.at(t.pos).Labelled(t.label, body);
266     }
267 
268     @DefinedBy(Api.COMPILER_TREE)
269     public JCTree visitLiteral(LiteralTree node, P p) {
270         JCLiteral t = (JCLiteral) node;
271         return M.at(t.pos).Literal(t.typetag, t.value);
272     }
273 
274     @DefinedBy(Api.COMPILER_TREE)
275     public JCTree visitMethod(MethodTree node, P p) {
276         JCMethodDecl t  = (JCMethodDecl) node;
277         JCModifiers mods = copy(t.mods, p);
278         JCExpression restype = copy(t.restype, p);
279         List&lt;JCTypeParameter&gt; typarams = copy(t.typarams, p);
280         List&lt;JCVariableDecl&gt; params = copy(t.params, p);
281         JCVariableDecl recvparam = copy(t.recvparam, p);
282         List&lt;JCExpression&gt; thrown = copy(t.thrown, p);
283         JCBlock body = copy(t.body, p);
284         JCExpression defaultValue = copy(t.defaultValue, p);
285         return M.at(t.pos).MethodDef(mods, t.name, restype, typarams, recvparam, params, thrown, body, defaultValue);
286     }
287 
288     @DefinedBy(Api.COMPILER_TREE)
289     public JCTree visitMethodInvocation(MethodInvocationTree node, P p) {
290         JCMethodInvocation t = (JCMethodInvocation) node;
291         List&lt;JCExpression&gt; typeargs = copy(t.typeargs, p);
292         JCExpression meth = copy(t.meth, p);
293         List&lt;JCExpression&gt; args = copy(t.args, p);
294         return M.at(t.pos).Apply(typeargs, meth, args);
295     }
296 
297     @DefinedBy(Api.COMPILER_TREE)
298     public JCTree visitModifiers(ModifiersTree node, P p) {
299         JCModifiers t = (JCModifiers) node;
300         List&lt;JCAnnotation&gt; annotations = copy(t.annotations, p);
301         return M.at(t.pos).Modifiers(t.flags, annotations);
302     }
303 
304     @DefinedBy(Api.COMPILER_TREE)
305     public JCTree visitNewArray(NewArrayTree node, P p) {
306         JCNewArray t = (JCNewArray) node;
307         JCExpression elemtype = copy(t.elemtype, p);
308         List&lt;JCExpression&gt; dims = copy(t.dims, p);
309         List&lt;JCExpression&gt; elems = copy(t.elems, p);
310         return M.at(t.pos).NewArray(elemtype, dims, elems);
311     }
312 
313     @DefinedBy(Api.COMPILER_TREE)
314     public JCTree visitNewClass(NewClassTree node, P p) {
315         JCNewClass t = (JCNewClass) node;
316         JCExpression encl = copy(t.encl, p);
317         List&lt;JCExpression&gt; typeargs = copy(t.typeargs, p);
318         JCExpression clazz = copy(t.clazz, p);
319         List&lt;JCExpression&gt; args = copy(t.args, p);
320         JCClassDecl def = copy(t.def, p);
321         return M.at(t.pos).NewClass(encl, typeargs, clazz, args, def);
322     }
323 
324     @DefinedBy(Api.COMPILER_TREE)
325     public JCTree visitLambdaExpression(LambdaExpressionTree node, P p) {
326         JCLambda t = (JCLambda) node;
327         List&lt;JCVariableDecl&gt; params = copy(t.params, p);
328         JCTree body = copy(t.body, p);
329         return M.at(t.pos).Lambda(params, body);
330     }
331 
332     @DefinedBy(Api.COMPILER_TREE)
333     public JCTree visitParenthesized(ParenthesizedTree node, P p) {
334         JCParens t = (JCParens) node;
335         JCExpression expr = copy(t.expr, p);
336         return M.at(t.pos).Parens(expr);
337     }
338 
339     @DefinedBy(Api.COMPILER_TREE)
340     public JCTree visitReturn(ReturnTree node, P p) {
341         JCReturn t = (JCReturn) node;
342         JCExpression expr = copy(t.expr, p);
343         return M.at(t.pos).Return(expr);
344     }
345 
346     @DefinedBy(Api.COMPILER_TREE)
347     public JCTree visitMemberSelect(MemberSelectTree node, P p) {
348         JCFieldAccess t = (JCFieldAccess) node;
349         JCExpression selected = copy(t.selected, p);
350         return M.at(t.pos).Select(selected, t.name);
351     }
352 
353     @DefinedBy(Api.COMPILER_TREE)
354     public JCTree visitMemberReference(MemberReferenceTree node, P p) {
355         JCMemberReference t = (JCMemberReference) node;
356         JCExpression expr = copy(t.expr, p);
357         List&lt;JCExpression&gt; typeargs = copy(t.typeargs, p);
358         return M.at(t.pos).Reference(t.mode, t.name, expr, typeargs);
359     }
360 
361     @DefinedBy(Api.COMPILER_TREE)
362     public JCTree visitEmptyStatement(EmptyStatementTree node, P p) {
363         JCSkip t = (JCSkip) node;
364         return M.at(t.pos).Skip();
365     }
366 
367     @DefinedBy(Api.COMPILER_TREE)
368     public JCTree visitSwitch(SwitchTree node, P p) {
369         JCSwitch t = (JCSwitch) node;
370         JCExpression selector = copy(t.selector, p);
371         List&lt;JCCase&gt; cases = copy(t.cases, p);
372         return M.at(t.pos).Switch(selector, cases);
373     }
374 
375     @DefinedBy(Api.COMPILER_TREE)
376     @SuppressWarnings(&quot;removal&quot;)
377     public JCTree visitSwitchExpression(SwitchExpressionTree node, P p) {
378         JCSwitchExpression t = (JCSwitchExpression) node;
379         JCExpression selector = copy(t.selector, p);
380         List&lt;JCCase&gt; cases = copy(t.cases, p);
381         return M.at(t.pos).SwitchExpression(selector, cases);
382     }
383 
384     @DefinedBy(Api.COMPILER_TREE)
385     public JCTree visitSynchronized(SynchronizedTree node, P p) {
386         JCSynchronized t = (JCSynchronized) node;
387         JCExpression lock = copy(t.lock, p);
388         JCBlock body = copy(t.body, p);
389         return M.at(t.pos).Synchronized(lock, body);
390     }
391 
392     @DefinedBy(Api.COMPILER_TREE)
393     public JCTree visitThrow(ThrowTree node, P p) {
394         JCThrow t = (JCThrow) node;
395         JCExpression expr = copy(t.expr, p);
396         return M.at(t.pos).Throw(expr);
397     }
398 
399     @DefinedBy(Api.COMPILER_TREE)
400     public JCTree visitCompilationUnit(CompilationUnitTree node, P p) {
401         JCCompilationUnit t = (JCCompilationUnit) node;
402         List&lt;JCTree&gt; defs = copy(t.defs, p);
403         return M.at(t.pos).TopLevel(defs);
404     }
405 
406     @DefinedBy(Api.COMPILER_TREE)
407     public JCTree visitPackage(PackageTree node, P p) {
408         JCPackageDecl t = (JCPackageDecl) node;
409         List&lt;JCAnnotation&gt; annotations = copy(t.annotations, p);
410         JCExpression pid = copy(t.pid, p);
411         return M.at(t.pos).PackageDecl(annotations, pid);
412     }
413 
414     @DefinedBy(Api.COMPILER_TREE)
415     public JCTree visitTry(TryTree node, P p) {
416         JCTry t = (JCTry) node;
417         List&lt;JCTree&gt; resources = copy(t.resources, p);
418         JCBlock body = copy(t.body, p);
419         List&lt;JCCatch&gt; catchers = copy(t.catchers, p);
420         JCBlock finalizer = copy(t.finalizer, p);
421         return M.at(t.pos).Try(resources, body, catchers, finalizer);
422     }
423 
424     @DefinedBy(Api.COMPILER_TREE)
425     public JCTree visitParameterizedType(ParameterizedTypeTree node, P p) {
426         JCTypeApply t = (JCTypeApply) node;
427         JCExpression clazz = copy(t.clazz, p);
428         List&lt;JCExpression&gt; arguments = copy(t.arguments, p);
429         return M.at(t.pos).TypeApply(clazz, arguments);
430     }
431 
432     @DefinedBy(Api.COMPILER_TREE)
433     public JCTree visitUnionType(UnionTypeTree node, P p) {
434         JCTypeUnion t = (JCTypeUnion) node;
435         List&lt;JCExpression&gt; components = copy(t.alternatives, p);
436         return M.at(t.pos).TypeUnion(components);
437     }
438 
439     @DefinedBy(Api.COMPILER_TREE)
440     public JCTree visitIntersectionType(IntersectionTypeTree node, P p) {
441         JCTypeIntersection t = (JCTypeIntersection) node;
442         List&lt;JCExpression&gt; bounds = copy(t.bounds, p);
443         return M.at(t.pos).TypeIntersection(bounds);
444     }
445 
446     @DefinedBy(Api.COMPILER_TREE)
447     public JCTree visitArrayType(ArrayTypeTree node, P p) {
448         JCArrayTypeTree t = (JCArrayTypeTree) node;
449         JCExpression elemtype = copy(t.elemtype, p);
450         return M.at(t.pos).TypeArray(elemtype);
451     }
452 
453     @DefinedBy(Api.COMPILER_TREE)
454     public JCTree visitTypeCast(TypeCastTree node, P p) {
455         JCTypeCast t = (JCTypeCast) node;
456         JCTree clazz = copy(t.clazz, p);
457         JCExpression expr = copy(t.expr, p);
458         return M.at(t.pos).TypeCast(clazz, expr);
459     }
460 
461     @DefinedBy(Api.COMPILER_TREE)
462     public JCTree visitPrimitiveType(PrimitiveTypeTree node, P p) {
463         JCPrimitiveTypeTree t = (JCPrimitiveTypeTree) node;
464         return M.at(t.pos).TypeIdent(t.typetag);
465     }
466 
467     @DefinedBy(Api.COMPILER_TREE)
468     public JCTree visitTypeParameter(TypeParameterTree node, P p) {
469         JCTypeParameter t = (JCTypeParameter) node;
470         List&lt;JCAnnotation&gt; annos = copy(t.annotations, p);
471         List&lt;JCExpression&gt; bounds = copy(t.bounds, p);
472         return M.at(t.pos).TypeParameter(t.name, bounds, annos);
473     }
474 
475     @DefinedBy(Api.COMPILER_TREE)
476     public JCTree visitInstanceOf(InstanceOfTree node, P p) {
477         JCInstanceOf t = (JCInstanceOf) node;
478         JCExpression expr = copy(t.expr, p);
479         JCTree clazz = copy(t.clazz, p);
480         return M.at(t.pos).TypeTest(expr, clazz);
481     }
482 
483     @DefinedBy(Api.COMPILER_TREE)
484     public JCTree visitUnary(UnaryTree node, P p) {
485         JCUnary t = (JCUnary) node;
486         JCExpression arg = copy(t.arg, p);
487         return M.at(t.pos).Unary(t.getTag(), arg);
488     }
489 
490     @DefinedBy(Api.COMPILER_TREE)
491     public JCTree visitVariable(VariableTree node, P p) {
492         JCVariableDecl t = (JCVariableDecl) node;
493         JCModifiers mods = copy(t.mods, p);
494         JCExpression vartype = copy(t.vartype, p);
495         if (t.nameexpr == null) {
496             JCExpression init = copy(t.init, p);
497             return M.at(t.pos).VarDef(mods, t.name, vartype, init);
498         } else {
499             JCExpression nameexpr = copy(t.nameexpr, p);
500             return M.at(t.pos).ReceiverVarDef(mods, nameexpr, vartype);
501         }
502     }
503 
504     @DefinedBy(Api.COMPILER_TREE)
505     public JCTree visitWhileLoop(WhileLoopTree node, P p) {
506         JCWhileLoop t = (JCWhileLoop) node;
507         JCStatement body = copy(t.body, p);
508         JCExpression cond = copy(t.cond, p);
509         return M.at(t.pos).WhileLoop(cond, body);
510     }
511 
512     @DefinedBy(Api.COMPILER_TREE)
513     public JCTree visitWildcard(WildcardTree node, P p) {
514         JCWildcard t = (JCWildcard) node;
515         TypeBoundKind kind = M.at(t.kind.pos).TypeBoundKind(t.kind.kind);
516         JCTree inner = copy(t.inner, p);
517         return M.at(t.pos).Wildcard(kind, inner);
518     }
519 
520     @Override @DefinedBy(Api.COMPILER_TREE)
521     public JCTree visitModule(ModuleTree node, P p) {
522         JCModuleDecl t = (JCModuleDecl) node;
523         JCModifiers mods = copy(t.mods, p);
524         JCExpression qualId = copy(t.qualId);
525         List&lt;JCDirective&gt; directives = copy(t.directives);
526         return M.at(t.pos).ModuleDef(mods, t.getModuleType(), qualId, directives);
527     }
528 
529     @Override @DefinedBy(Api.COMPILER_TREE)
530     public JCExports visitExports(ExportsTree node, P p) {
531         JCExports t = (JCExports) node;
532         JCExpression qualId = copy(t.qualid, p);
533         List&lt;JCExpression&gt; moduleNames = copy(t.moduleNames, p);
534         return M.at(t.pos).Exports(qualId, moduleNames);
535     }
536 
537     @Override @DefinedBy(Api.COMPILER_TREE)
538     public JCOpens visitOpens(OpensTree node, P p) {
539         JCOpens t = (JCOpens) node;
540         JCExpression qualId = copy(t.qualid, p);
541         List&lt;JCExpression&gt; moduleNames = copy(t.moduleNames, p);
542         return M.at(t.pos).Opens(qualId, moduleNames);
543     }
544 
545     @Override @DefinedBy(Api.COMPILER_TREE)
546     public JCProvides visitProvides(ProvidesTree node, P p) {
547         JCProvides t = (JCProvides) node;
548         JCExpression serviceName = copy(t.serviceName, p);
549         List&lt;JCExpression&gt; implNames = copy(t.implNames, p);
550         return M.at(t.pos).Provides(serviceName, implNames);
551     }
552 
553     @Override @DefinedBy(Api.COMPILER_TREE)
554     public JCRequires visitRequires(RequiresTree node, P p) {
555         JCRequires t = (JCRequires) node;
556         JCExpression moduleName = copy(t.moduleName, p);
557         return M.at(t.pos).Requires(t.isTransitive, t.isStaticPhase, moduleName);
558     }
559 
560     @Override @DefinedBy(Api.COMPILER_TREE)
561     public JCUses visitUses(UsesTree node, P p) {
562         JCUses t = (JCUses) node;
563         JCExpression serviceName = copy(t.qualid, p);
564         return M.at(t.pos).Uses(serviceName);
565     }
566 
567     @DefinedBy(Api.COMPILER_TREE)
568     public JCTree visitOther(Tree node, P p) {
569         JCTree tree = (JCTree) node;
570         switch (tree.getTag()) {
571             case LETEXPR: {
572                 LetExpr t = (LetExpr) node;
573                 List&lt;JCStatement&gt; defs = copy(t.defs, p);
574                 JCExpression expr = copy(t.expr, p);
575                 return M.at(t.pos).LetExpr(defs, expr);
576             }
577             default:
578                 throw new AssertionError(&quot;unknown tree tag: &quot; + tree.getTag());
579         }
580     }
581 
582 }
    </pre>
  </body>
</html>
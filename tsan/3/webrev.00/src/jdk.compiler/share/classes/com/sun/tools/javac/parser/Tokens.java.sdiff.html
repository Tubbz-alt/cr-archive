<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/Tokens.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScannerFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="UnicodeReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/Tokens.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 68         Tokens instance = context.get(tokensKey);
 69         if (instance == null)
 70             instance = new Tokens(context);
 71         return instance;
 72     }
 73 
 74     protected Tokens(Context context) {
 75         context.put(tokensKey, this);
 76         names = Names.instance(context);
 77         for (TokenKind t : TokenKind.values()) {
 78             if (t.name != null)
 79                 enterKeyword(t.name, t);
 80             else
 81                 tokenName[t.ordinal()] = null;
 82         }
 83 
 84         key = new TokenKind[maxKey+1];
 85         for (int i = 0; i &lt;= maxKey; i++) key[i] = TokenKind.IDENTIFIER;
 86         for (TokenKind t : TokenKind.values()) {
 87             if (t.name != null)
<span class="line-modified"> 88             key[tokenName[t.ordinal()].getIndex()] = t;</span>
 89         }
 90     }
 91 
 92     private void enterKeyword(String s, TokenKind token) {
 93         Name n = names.fromString(s);
 94         tokenName[token.ordinal()] = n;
 95         if (n.getIndex() &gt; maxKey) maxKey = n.getIndex();
 96     }
 97 
 98     /**
 99      * Create a new token given a name; if the name corresponds to a token name,
100      * a new token of the corresponding kind is returned; otherwise, an
101      * identifier token is returned.
102      */
103     TokenKind lookupKind(Name name) {
104         return (name.getIndex() &gt; maxKey) ? TokenKind.IDENTIFIER : key[name.getIndex()];
105     }
106 
107     TokenKind lookupKind(String name) {
108         return lookupKind(names.fromString(name));
</pre>
<hr />
<pre>
298             JAVADOC,
299         }
300 
301         String getText();
302         int getSourcePos(int index);
303         CommentStyle getStyle();
304         boolean isDeprecated();
305     }
306 
307     /**
308      * This is the class representing a javac token. Each token has several fields
309      * that are set by the javac lexer (i.e. start/end position, string value, etc).
310      */
311     public static class Token {
312 
313         /** tags constants **/
314         enum Tag {
315             DEFAULT,
316             NAMED,
317             STRING,
<span class="line-modified">318             NUMERIC</span>
319         }
320 
321         /** The token kind */
322         public final TokenKind kind;
323 
324         /** The start position of this token */
325         public final int pos;
326 
327         /** The end position of this token */
328         public final int endPos;
329 
330         /** Comment reader associated with this token */
331         public final List&lt;Comment&gt; comments;
332 
333         Token(TokenKind kind, int pos, int endPos, List&lt;Comment&gt; comments) {
334             this.kind = kind;
335             this.pos = pos;
336             this.endPos = endPos;
337             this.comments = comments;
338             checkKind();
</pre>
<hr />
<pre>
340 
341         Token[] split(Tokens tokens) {
342             if (kind.name.length() &lt; 2 || kind.tag != Tag.DEFAULT) {
343                 throw new AssertionError(&quot;Cant split&quot; + kind);
344             }
345 
346             TokenKind t1 = tokens.lookupKind(kind.name.substring(0, 1));
347             TokenKind t2 = tokens.lookupKind(kind.name.substring(1));
348 
349             if (t1 == null || t2 == null) {
350                 throw new AssertionError(&quot;Cant split - bad subtokens&quot;);
351             }
352             return new Token[] {
353                 new Token(t1, pos, pos + t1.name.length(), comments),
354                 new Token(t2, pos + t1.name.length(), endPos, null)
355             };
356         }
357 
358         protected void checkKind() {
359             if (kind.tag != Tag.DEFAULT) {
<span class="line-modified">360                 throw new AssertionError(&quot;Bad token kind - expected &quot; + Tag.STRING);</span>
361             }
362         }
363 
364         public Name name() {
365             throw new UnsupportedOperationException();
366         }
367 
368         public String stringVal() {
369             throw new UnsupportedOperationException();
370         }
371 
372         public int radix() {
373             throw new UnsupportedOperationException();
374         }
375 
376         /**
377          * Preserve classic semantics - if multiple javadocs are found on the token
378          * the last one is returned
379          */
380         public Comment comment(Comment.CommentStyle style) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 68         Tokens instance = context.get(tokensKey);
 69         if (instance == null)
 70             instance = new Tokens(context);
 71         return instance;
 72     }
 73 
 74     protected Tokens(Context context) {
 75         context.put(tokensKey, this);
 76         names = Names.instance(context);
 77         for (TokenKind t : TokenKind.values()) {
 78             if (t.name != null)
 79                 enterKeyword(t.name, t);
 80             else
 81                 tokenName[t.ordinal()] = null;
 82         }
 83 
 84         key = new TokenKind[maxKey+1];
 85         for (int i = 0; i &lt;= maxKey; i++) key[i] = TokenKind.IDENTIFIER;
 86         for (TokenKind t : TokenKind.values()) {
 87             if (t.name != null)
<span class="line-modified"> 88                 key[tokenName[t.ordinal()].getIndex()] = t;</span>
 89         }
 90     }
 91 
 92     private void enterKeyword(String s, TokenKind token) {
 93         Name n = names.fromString(s);
 94         tokenName[token.ordinal()] = n;
 95         if (n.getIndex() &gt; maxKey) maxKey = n.getIndex();
 96     }
 97 
 98     /**
 99      * Create a new token given a name; if the name corresponds to a token name,
100      * a new token of the corresponding kind is returned; otherwise, an
101      * identifier token is returned.
102      */
103     TokenKind lookupKind(Name name) {
104         return (name.getIndex() &gt; maxKey) ? TokenKind.IDENTIFIER : key[name.getIndex()];
105     }
106 
107     TokenKind lookupKind(String name) {
108         return lookupKind(names.fromString(name));
</pre>
<hr />
<pre>
298             JAVADOC,
299         }
300 
301         String getText();
302         int getSourcePos(int index);
303         CommentStyle getStyle();
304         boolean isDeprecated();
305     }
306 
307     /**
308      * This is the class representing a javac token. Each token has several fields
309      * that are set by the javac lexer (i.e. start/end position, string value, etc).
310      */
311     public static class Token {
312 
313         /** tags constants **/
314         enum Tag {
315             DEFAULT,
316             NAMED,
317             STRING,
<span class="line-modified">318             NUMERIC;</span>
319         }
320 
321         /** The token kind */
322         public final TokenKind kind;
323 
324         /** The start position of this token */
325         public final int pos;
326 
327         /** The end position of this token */
328         public final int endPos;
329 
330         /** Comment reader associated with this token */
331         public final List&lt;Comment&gt; comments;
332 
333         Token(TokenKind kind, int pos, int endPos, List&lt;Comment&gt; comments) {
334             this.kind = kind;
335             this.pos = pos;
336             this.endPos = endPos;
337             this.comments = comments;
338             checkKind();
</pre>
<hr />
<pre>
340 
341         Token[] split(Tokens tokens) {
342             if (kind.name.length() &lt; 2 || kind.tag != Tag.DEFAULT) {
343                 throw new AssertionError(&quot;Cant split&quot; + kind);
344             }
345 
346             TokenKind t1 = tokens.lookupKind(kind.name.substring(0, 1));
347             TokenKind t2 = tokens.lookupKind(kind.name.substring(1));
348 
349             if (t1 == null || t2 == null) {
350                 throw new AssertionError(&quot;Cant split - bad subtokens&quot;);
351             }
352             return new Token[] {
353                 new Token(t1, pos, pos + t1.name.length(), comments),
354                 new Token(t2, pos + t1.name.length(), endPos, null)
355             };
356         }
357 
358         protected void checkKind() {
359             if (kind.tag != Tag.DEFAULT) {
<span class="line-modified">360                 throw new AssertionError(&quot;Bad token kind - expected &quot; + Tag.DEFAULT);</span>
361             }
362         }
363 
364         public Name name() {
365             throw new UnsupportedOperationException();
366         }
367 
368         public String stringVal() {
369             throw new UnsupportedOperationException();
370         }
371 
372         public int radix() {
373             throw new UnsupportedOperationException();
374         }
375 
376         /**
377          * Preserve classic semantics - if multiple javadocs are found on the token
378          * the last one is returned
379          */
380         public Comment comment(Comment.CommentStyle style) {
</pre>
</td>
</tr>
</table>
<center><a href="ScannerFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="UnicodeReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
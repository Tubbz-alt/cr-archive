<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacRoundEnvironment.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 37,12 ---</span>
  
  import java.io.PrintWriter;
  import java.io.Writer;
  import java.util.*;
  import java.util.stream.Collectors;
<span class="line-added">+ import java.util.stream.Stream;</span>
<span class="line-added">+ </span>
  
  import com.sun.tools.javac.util.DefinedBy;
  import com.sun.tools.javac.util.DefinedBy.Api;
  import com.sun.tools.javac.util.StringUtils;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,11 ***</span>
   * If you write code that depends on this, you do so at your own risk.
   * This code and its internal interfaces are subject to change or
   * deletion without notice.&lt;/b&gt;
   */
  @SupportedAnnotationTypes(&quot;*&quot;)
<span class="line-modified">! @SupportedSourceVersion(SourceVersion.RELEASE_13)</span>
  public class PrintingProcessor extends AbstractProcessor {
      PrintWriter writer;
  
      public PrintingProcessor() {
          super();
<span class="line-new-header">--- 55,11 ---</span>
   * If you write code that depends on this, you do so at your own risk.
   * This code and its internal interfaces are subject to change or
   * deletion without notice.&lt;/b&gt;
   */
  @SupportedAnnotationTypes(&quot;*&quot;)
<span class="line-modified">! @SupportedSourceVersion(SourceVersion.RELEASE_15)</span>
  public class PrintingProcessor extends AbstractProcessor {
      PrintWriter writer;
  
      public PrintingProcessor() {
          super();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,12 ***</span>
      }
  
      /**
       * Used for the -Xprint option and called by Elements.printElements
       */
      public static class PrintingElementVisitor
<span class="line-modified">!         extends SimpleElementVisitor9&lt;PrintingElementVisitor, Boolean&gt; {</span>
          int indentation; // Indentation level;
          final PrintWriter writer;
          final Elements elementUtils;
  
          public PrintingElementVisitor(Writer w, Elements elementUtils) {
<span class="line-new-header">--- 88,13 ---</span>
      }
  
      /**
       * Used for the -Xprint option and called by Elements.printElements
       */
<span class="line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
      public static class PrintingElementVisitor
<span class="line-modified">!         extends SimpleElementVisitor14&lt;PrintingElementVisitor, Boolean&gt; {</span>
          int indentation; // Indentation level;
          final PrintWriter writer;
          final Elements elementUtils;
  
          public PrintingElementVisitor(Writer w, Elements elementUtils) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,10 ***</span>
<span class="line-new-header">--- 111,17 ---</span>
              printDocComment(e);
              printModifiers(e);
              return this;
          }
  
<span class="line-added">+         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">+         public PrintingElementVisitor visitRecordComponent(RecordComponentElement e, Boolean p) {</span>
<span class="line-added">+                 // Do nothing; printing of component information done by</span>
<span class="line-added">+                 // printing the record type itself</span>
<span class="line-added">+             return this;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override @DefinedBy(Api.LANGUAGE_MODEL)
          public PrintingElementVisitor visitExecutable(ExecutableElement e, Boolean p) {
              ElementKind kind = e.getKind();
  
              if (kind != STATIC_INIT &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,11 ***</span>
                  // Don&#39;t print out the constructor of an anonymous class
                  if (kind == CONSTRUCTOR &amp;&amp;
                      enclosing != null &amp;&amp;
                      NestingKind.ANONYMOUS ==
                      // Use an anonymous class to determine anonymity!
<span class="line-modified">!                     (new SimpleElementVisitor9&lt;NestingKind, Void&gt;() {</span>
                          @Override @DefinedBy(Api.LANGUAGE_MODEL)
                          public NestingKind visitType(TypeElement e, Void p) {
                              return e.getNestingKind();
                          }
                      }).visit(enclosing))
<span class="line-new-header">--- 131,11 ---</span>
                  // Don&#39;t print out the constructor of an anonymous class
                  if (kind == CONSTRUCTOR &amp;&amp;
                      enclosing != null &amp;&amp;
                      NestingKind.ANONYMOUS ==
                      // Use an anonymous class to determine anonymity!
<span class="line-modified">!                     (new SimpleElementVisitor14&lt;NestingKind, Void&gt;() {</span>
                          @Override @DefinedBy(Api.LANGUAGE_MODEL)
                          public NestingKind visitType(TypeElement e, Void p) {
                              return e.getNestingKind();
                          }
                      }).visit(enclosing))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,10 ***</span>
<span class="line-new-header">--- 224,20 ---</span>
                  writer.print(&quot; &quot;);
                  writer.print(e.getSimpleName());
  
                  printFormalTypeParameters(e, false);
  
<span class="line-added">+                 if (kind == RECORD) {</span>
<span class="line-added">+                     // Print out record components</span>
<span class="line-added">+                     writer.print(&quot;(&quot;);</span>
<span class="line-added">+                     writer.print(e.getRecordComponents()</span>
<span class="line-added">+                                  .stream()</span>
<span class="line-added">+                                  .map(recordDes -&gt; recordDes.asType().toString() + &quot; &quot; + recordDes.getSimpleName())</span>
<span class="line-added">+                                  .collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="line-added">+                     writer.print(&quot;)&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
                  // Print superclass information if informative
                  if (kind == CLASS) {
                      TypeMirror supertype = e.getSuperclass();
                      if (supertype.getKind() != TypeKind.NONE) {
                          TypeElement e2 = (TypeElement)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
                  }
  
                  for(Element element : enclosedElements)
                      this.visit(element);
              } else {
<span class="line-modified">!                 for(Element element : e.getEnclosedElements())</span>
                      this.visit(element);
              }
  
              indentation--;
              indent();
<span class="line-new-header">--- 273,17 ---</span>
                  }
  
                  for(Element element : enclosedElements)
                      this.visit(element);
              } else {
<span class="line-modified">!                 for(Element element :</span>
<span class="line-added">+                         (kind != RECORD ?</span>
<span class="line-added">+                          e.getEnclosedElements() :</span>
<span class="line-added">+                          e.getEnclosedElements()</span>
<span class="line-added">+                          .stream()</span>
<span class="line-added">+                          .filter(elt -&gt; elementUtils.getOrigin(elt) == Elements.Origin.EXPLICIT )</span>
<span class="line-added">+                          .collect(Collectors.toList()) ) )</span>
                      this.visit(element);
              }
  
              indentation--;
              indent();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 422,11 ***</span>
          }
  
          private void printModifiers(Element e) {
              ElementKind kind = e.getKind();
              if (kind == PARAMETER) {
<span class="line-modified">!                 printAnnotationsInline(e);</span>
              } else {
                  printAnnotations(e);
                  indent();
              }
  
<span class="line-new-header">--- 448,12 ---</span>
          }
  
          private void printModifiers(Element e) {
              ElementKind kind = e.getKind();
              if (kind == PARAMETER) {
<span class="line-modified">!                 // Print annotation inline</span>
<span class="line-added">+                 writer.print(annotationsToString(e));</span>
              } else {
                  printAnnotations(e);
                  indent();
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,10 ***</span>
<span class="line-new-header">--- 472,14 ---</span>
              case ENUM:
                  modifiers.remove(Modifier.FINAL);
                  modifiers.remove(Modifier.ABSTRACT);
                  break;
  
<span class="line-added">+             case RECORD:</span>
<span class="line-added">+                 modifiers.remove(Modifier.FINAL);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
              case METHOD:
              case FIELD:
                  Element enclosingElement = e.getEnclosingElement();
                  if (enclosingElement != null &amp;&amp;
                      enclosingElement.getKind().isInterface()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,43 ***</span>
                      modifiers.remove(Modifier.FINAL);    // only for fields
                  }
                  break;
  
              }
<span class="line-modified">! </span>
<span class="line-modified">!             for(Modifier m: modifiers) {</span>
<span class="line-modified">!                 writer.print(m.toString() + &quot; &quot;);</span>
              }
          }
  
          private void printFormalTypeParameters(Parameterizable e,
                                                 boolean pad) {
              List&lt;? extends TypeParameterElement&gt; typeParams = e.getTypeParameters();
<span class="line-modified">!             if (typeParams.size() &gt; 0) {</span>
<span class="line-modified">!                 writer.print(&quot;&lt;&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 boolean first = true;</span>
<span class="line-removed">-                 for(TypeParameterElement tpe: typeParams) {</span>
<span class="line-removed">-                     if (!first)</span>
<span class="line-removed">-                         writer.print(&quot;, &quot;);</span>
<span class="line-removed">-                     printAnnotationsInline(tpe);</span>
<span class="line-removed">-                     writer.print(tpe.toString());</span>
<span class="line-removed">-                     first = false;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 writer.print(&quot;&gt;&quot;);</span>
                  if (pad)
                      writer.print(&quot; &quot;);
              }
          }
  
<span class="line-modified">!         private void printAnnotationsInline(Element e) {</span>
<span class="line-modified">!             List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();</span>
<span class="line-modified">!             for(AnnotationMirror annotationMirror : annots) {</span>
<span class="line-modified">!                 writer.print(annotationMirror);</span>
<span class="line-modified">!                 writer.print(&quot; &quot;);</span>
<span class="line-modified">!             }</span>
          }
  
          private void printAnnotations(Element e) {
              List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();
              for(AnnotationMirror annotationMirror : annots) {
<span class="line-new-header">--- 489,36 ---</span>
                      modifiers.remove(Modifier.FINAL);    // only for fields
                  }
                  break;
  
              }
<span class="line-modified">!             if (!modifiers.isEmpty()) {</span>
<span class="line-modified">!                 writer.print(modifiers.stream()</span>
<span class="line-modified">!                              .map(Modifier::toString)</span>
<span class="line-added">+                              .collect(Collectors.joining(&quot; &quot;, &quot;&quot;, &quot; &quot;)));</span>
              }
          }
  
          private void printFormalTypeParameters(Parameterizable e,
                                                 boolean pad) {
              List&lt;? extends TypeParameterElement&gt; typeParams = e.getTypeParameters();
<span class="line-modified">!             if (!typeParams.isEmpty()) {</span>
<span class="line-modified">!                 writer.print(typeParams.stream()</span>
<span class="line-modified">!                              .map(tpe -&gt; annotationsToString(tpe) + tpe.toString())</span>
<span class="line-modified">!                              .collect(Collectors.joining(&quot;, &quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));</span>
                  if (pad)
                      writer.print(&quot; &quot;);
              }
          }
  
<span class="line-modified">!         private String annotationsToString(Element e) {</span>
<span class="line-modified">!             List&lt;? extends AnnotationMirror&gt; annotations = e.getAnnotationMirrors();</span>
<span class="line-modified">!             return annotations.isEmpty() ?</span>
<span class="line-modified">!                 &quot;&quot; :</span>
<span class="line-modified">!                 annotations.stream()</span>
<span class="line-modified">!                 .map(AnnotationMirror::toString)</span>
<span class="line-added">+                 .collect(Collectors.joining(&quot; &quot;, &quot;&quot;, &quot; &quot;));</span>
          }
  
          private void printAnnotations(Element e) {
              List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();
              for(AnnotationMirror annotationMirror : annots) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 567,21 ***</span>
          private void printInterfaces(TypeElement e) {
              ElementKind kind = e.getKind();
  
              if(kind != ANNOTATION_TYPE) {
                  List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
<span class="line-modified">!                 if (interfaces.size() &gt; 0) {</span>
<span class="line-modified">!                     writer.print((kind.isClass() ? &quot; implements&quot; : &quot; extends&quot;));</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     boolean first = true;</span>
<span class="line-modified">!                     for(TypeMirror interf: interfaces) {</span>
<span class="line-removed">-                         if (!first)</span>
<span class="line-removed">-                             writer.print(&quot;,&quot;);</span>
<span class="line-removed">-                         writer.print(&quot; &quot;);</span>
<span class="line-removed">-                         writer.print(interf.toString());</span>
<span class="line-removed">-                         first = false;</span>
<span class="line-removed">-                     }</span>
                  }
              }
          }
  
          private void printThrows(ExecutableElement e) {
<span class="line-new-header">--- 591,15 ---</span>
          private void printInterfaces(TypeElement e) {
              ElementKind kind = e.getKind();
  
              if(kind != ANNOTATION_TYPE) {
                  List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
<span class="line-modified">!                 if (!interfaces.isEmpty()) {</span>
<span class="line-modified">!                     writer.print((kind.isClass() ? &quot; implements &quot; : &quot; extends &quot;));</span>
<span class="line-modified">!                     writer.print(interfaces.stream()</span>
<span class="line-modified">!                                  .map(TypeMirror::toString)</span>
<span class="line-modified">!                                  .collect(Collectors.joining(&quot;, &quot;)));</span>
                  }
              }
          }
  
          private void printThrows(ExecutableElement e) {
</pre>
<center><a href="JavacRoundEnvironment.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
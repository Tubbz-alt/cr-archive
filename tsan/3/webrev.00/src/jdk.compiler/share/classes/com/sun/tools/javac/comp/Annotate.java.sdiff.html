<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Annotate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Analyzer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ArgumentAttr.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Annotate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 259             try {
 260                 if (s.hasAnnotations() &amp;&amp; annotations.nonEmpty())
 261                     log.error(annotations.head.pos, Errors.AlreadyAnnotated(Kinds.kindName(s), s));
 262 
 263                 Assert.checkNonNull(s, &quot;Symbol argument to actualEnterAnnotations is null&quot;);
 264 
 265                 // false is passed as fifth parameter since annotateLater is
 266                 // never called for a type parameter
 267                 annotateNow(s, annotations, localEnv, false, false);
 268             } finally {
 269                 if (prevLint != null)
 270                     chk.setLint(prevLint);
 271                 deferredLintHandler.setPos(prevLintPos);
 272                 log.useSource(prev);
 273             }
 274         });
 275 
 276         validate(() -&gt; { //validate annotations
 277             JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
 278             try {
<span class="line-modified"> 279                 chk.validateAnnotations(annotations, s);</span>
 280             } finally {
 281                 log.useSource(prev);
 282             }
 283         });
 284     }
 285 
 286 
 287     /** Queue processing of an attribute default value. */
 288     public void annotateDefaultValueLater(JCExpression defaultValue, Env&lt;AttrContext&gt; localEnv,
 289             MethodSymbol m, DiagnosticPosition deferPos)
 290     {
 291         normal(() -&gt; {
 292             JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
 293             DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);
 294             try {
 295                 enterDefaultValue(defaultValue, localEnv, m);
 296             } finally {
 297                 deferredLintHandler.setPos(prevLintPos);
 298                 log.useSource(prev);
 299             }
</pre>
<hr />
<pre>
 347             if (a.type.tsym.isAnnotationType()) {
 348                 if (annotated.containsKey(a.type.tsym)) {
 349                     if (!allowRepeatedAnnos) {
 350                         log.error(DiagnosticFlag.SOURCE_LEVEL, a.pos(), Feature.REPEATED_ANNOTATIONS.error(sourceName));
 351                     }
 352                     ListBuffer&lt;T&gt; l = annotated.get(a.type.tsym);
 353                     l = l.append(c);
 354                     annotated.put(a.type.tsym, l);
 355                     pos.put(c, a.pos());
 356                 } else {
 357                     annotated.put(a.type.tsym, ListBuffer.of(c));
 358                     pos.put(c, a.pos());
 359                 }
 360             }
 361 
 362             // Note: @Deprecated has no effect on local variables and parameters
 363             if (!c.type.isErroneous()
 364                     &amp;&amp; (toAnnotate.kind == MDL || toAnnotate.owner.kind != MTH)
 365                     &amp;&amp; types.isSameType(c.type, syms.deprecatedType)) {
 366                 toAnnotate.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
<span class="line-modified"> 367                 Attribute fr = c.member(names.forRemoval);</span>
<span class="line-modified"> 368                 if (fr instanceof Attribute.Constant) {</span>
<span class="line-modified"> 369                     Attribute.Constant v = (Attribute.Constant) fr;</span>
<span class="line-modified"> 370                     if (v.type == syms.booleanType &amp;&amp; ((Integer) v.value) != 0) {</span>
<span class="line-modified"> 371                         toAnnotate.flags_field |= Flags.DEPRECATED_REMOVAL;</span>
<span class="line-modified"> 372                     }</span>





 373                 }
 374             }
 375         }
 376 
 377         List&lt;T&gt; buf = List.nil();
 378         for (ListBuffer&lt;T&gt; lb : annotated.values()) {
 379             if (lb.size() == 1) {
 380                 buf = buf.prepend(lb.first());
 381             } else {
 382                 AnnotationContext&lt;T&gt; ctx = new AnnotationContext&lt;&gt;(env, annotated, pos, typeAnnotations);
 383                 T res = makeContainerAnnotation(lb.toList(), ctx, toAnnotate, isTypeParam);
 384                 if (res != null)
 385                     buf = buf.prepend(res);
 386             }
 387         }
 388 
 389         if (typeAnnotations) {
 390             @SuppressWarnings(&quot;unchecked&quot;)
 391             List&lt;TypeCompound&gt; attrs = (List&lt;TypeCompound&gt;)buf.reverse();
 392             toAnnotate.appendUniqueTypeAttributes(attrs);
 393         } else {
 394             @SuppressWarnings(&quot;unchecked&quot;)
 395             List&lt;Attribute.Compound&gt; attrs =  (List&lt;Attribute.Compound&gt;)buf.reverse();
 396             toAnnotate.resetAnnotations();
 397             toAnnotate.setDeclarationAttributes(attrs);
 398         }
 399     }










 400 
 401     /**
 402      * Attribute and store a semantic representation of the annotation tree {@code tree} into the
 403      * tree.attribute field.
 404      *
 405      * @param tree the tree representing an annotation
 406      * @param expectedAnnotationType the expected (super)type of the annotation
 407      * @param env the current env in where the annotation instance is found
 408      */
 409     public Attribute.Compound attributeAnnotation(JCAnnotation tree, Type expectedAnnotationType,
 410                                                   Env&lt;AttrContext&gt; env)
 411     {
<span class="line-modified"> 412         // The attribute might have been entered if it is Target or Repetable</span>
 413         // Because TreeCopier does not copy type, redo this if type is null
 414         if (tree.attribute != null &amp;&amp; tree.type != null)
 415             return tree.attribute;
 416 
 417         List&lt;Pair&lt;MethodSymbol, Attribute&gt;&gt; elems = attributeAnnotationValues(tree, expectedAnnotationType, env);
 418         Attribute.Compound ac = new Attribute.Compound(tree.type, elems);
 419 
 420         return tree.attribute = ac;
 421     }
 422 
 423     /** Attribute and store a semantic representation of the type annotation tree {@code tree} into
 424      * the tree.attribute field.
 425      *
 426      * @param a the tree representing an annotation
 427      * @param expectedAnnotationType the expected (super)type of the annotation
 428      * @param env the the current env in where the annotation instance is found
 429      */
 430     public Attribute.TypeCompound attributeTypeAnnotation(JCAnnotation a, Type expectedAnnotationType,
 431                                                           Env&lt;AttrContext&gt; env)
 432     {
<span class="line-modified"> 433         // The attribute might have been entered if it is Target or Repetable</span>
 434         // Because TreeCopier does not copy type, redo this if type is null
 435         if (a.attribute == null || a.type == null || !(a.attribute instanceof Attribute.TypeCompound)) {
 436             // Create a new TypeCompound
 437             List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; elems =
 438                     attributeAnnotationValues(a, expectedAnnotationType, env);
 439 
 440             Attribute.TypeCompound tc =
 441                     new Attribute.TypeCompound(a.type, elems, TypeAnnotationPosition.unknown);
 442             a.attribute = tc;
 443             return tc;
 444         } else {
 445             // Use an existing TypeCompound
 446             return (Attribute.TypeCompound)a.attribute;
 447         }
 448     }
 449 
 450     /**
 451      *  Attribute annotation elements creating a list of pairs of the Symbol representing that
 452      *  element and the value of that element as an Attribute. */
 453     private List&lt;Pair&lt;MethodSymbol, Attribute&gt;&gt; attributeAnnotationValues(JCAnnotation a,
</pre>
<hr />
<pre>
 508                 env, thisAnnotationType,
 509                 left.name, List.nil(), null);
 510         left.sym = method;
 511         left.type = method.type;
 512         if (method.owner != thisAnnotationType.tsym &amp;&amp; !badAnnotation)
 513             log.error(left.pos(), Errors.NoAnnotationMember(left.name, thisAnnotationType));
 514         Type resultType = method.type.getReturnType();
 515 
 516         // Compute value part
 517         Attribute value = attributeAnnotationValue(resultType, assign.rhs, env);
 518         nameValuePair.type = resultType;
 519 
 520         return method.type.isErroneous() ? null : new Pair&lt;&gt;((MethodSymbol)method, value);
 521 
 522     }
 523 
 524     /** Attribute an annotation element value */
 525     private Attribute attributeAnnotationValue(Type expectedElementType, JCExpression tree,
 526             Env&lt;AttrContext&gt; env)
 527     {
<span class="line-modified"> 528         //first, try completing the symbol for the annotation value - if acompletion</span>
 529         //error is thrown, we should recover gracefully, and display an
 530         //ordinary resolution diagnostic.
 531         try {
 532             expectedElementType.tsym.complete();
 533         } catch(CompletionFailure e) {
 534             log.error(tree.pos(), Errors.CantResolve(Kinds.kindName(e.sym), e.sym.getQualifiedName(), null, null));
 535             expectedElementType = syms.errType;
 536         }
 537 
 538         if (expectedElementType.hasTag(ARRAY)) {
 539             return getAnnotationArrayValue(expectedElementType, tree, env);
 540 
 541         }
 542 
 543         //error recovery
 544         if (tree.hasTag(NEWARRAY)) {
 545             if (!expectedElementType.isErroneous())
 546                 log.error(tree.pos(), Errors.AnnotationValueNotAllowableType);
 547             JCNewArray na = (JCNewArray)tree;
 548             if (na.elemtype != null) {
</pre>
<hr />
<pre>
 803                         ((Attribute.TypeCompound)annotations.head).position);
 804 
 805                 JCAnnotation annoTree = m.TypeAnnotation(at);
 806                 if (!chk.validateAnnotationDeferErrors(annoTree))
 807                     log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
 808 
 809                 if (!chk.isTypeAnnotation(annoTree, isTypeParam)) {
 810                     log.error(pos, isTypeParam ? Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on)
 811                                                : Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));
 812                 }
 813 
 814                 at.setSynthesized(true);
 815 
 816                 @SuppressWarnings(&quot;unchecked&quot;)
 817                 T x = (T) at;
 818                 return x;
 819             } else {
 820                 Attribute.Compound c = new Attribute.Compound(targetContainerType, List.of(p));
 821                 JCAnnotation annoTree = m.Annotation(c);
 822 
<span class="line-modified"> 823                 if (!chk.annotationApplicable(annoTree, on)) {</span>




 824                     log.error(annoTree.pos(),
 825                               Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on));
 826                 }
 827 
 828                 if (!chk.validateAnnotationDeferErrors(annoTree))
 829                     log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
 830 
 831                 c = attributeAnnotation(annoTree, targetContainerType, ctx.env);
 832                 c.setSynthesized(true);
 833 
 834                 @SuppressWarnings(&quot;unchecked&quot;)
 835                 T x = (T) c;
 836                 return x;
 837             }
 838         } else {
 839             return null; // errors should have been reported elsewhere
 840         }
 841     }
 842 
 843     /**
</pre>
<hr />
<pre>
1089             // Do not annotate the body, just the signature.
1090         }
1091 
1092         @Override
1093         public void visitVarDef(JCVariableDecl tree) {
1094             DiagnosticPosition prevPos = deferPos;
1095             deferPos = tree.pos();
1096             try {
1097                 if (sym != null &amp;&amp; sym.kind == VAR) {
1098                     // Don&#39;t visit a parameter once when the sym is the method
1099                     // and once when the sym is the parameter.
1100                     scan(tree.mods);
1101                     scan(tree.vartype);
1102                 }
1103                 scan(tree.init);
1104             } finally {
1105                 deferPos = prevPos;
1106             }
1107         }
1108 







1109         @Override
1110         public void visitClassDef(JCClassDecl tree) {
1111             // We can only hit a classdef if it is declared within
1112             // a method. Ignore it - the class will be visited
1113             // separately later.
1114         }
1115 
1116         @Override
1117         public void visitNewClass(JCNewClass tree) {
1118             scan(tree.encl);
1119             scan(tree.typeargs);
1120             if (tree.def == null) {
1121                 scan(tree.clazz);
1122             }
1123             scan(tree.args);
1124             // the anonymous class instantiation if any will be visited separately.
1125         }
1126     }
1127 
1128     /*********************
1129      * Completer support *
1130      *********************/
1131 
1132     private AnnotationTypeCompleter theSourceCompleter = new AnnotationTypeCompleter() {
1133         @Override
1134         public void complete(ClassSymbol sym) throws CompletionFailure {
1135             Env&lt;AttrContext&gt; context = typeEnvs.get(sym);
1136             Annotate.this.attributeAnnotationType(context);
1137         }
1138     };
1139 
1140     /* Last stage completer to enter just enough annotations to have a prototype annotation type.
<span class="line-modified">1141      * This currently means entering @Target and @Repetable.</span>
1142      */
1143     public AnnotationTypeCompleter annotationTypeSourceCompleter() {
1144         return theSourceCompleter;
1145     }
1146 
1147     private void attributeAnnotationType(Env&lt;AttrContext&gt; env) {
1148         Assert.check(((JCClassDecl)env.tree).sym.isAnnotationType(),
1149                 &quot;Trying to annotation type complete a non-annotation type&quot;);
1150 
1151         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
1152         try {
1153             JCClassDecl tree = (JCClassDecl)env.tree;
1154             AnnotationTypeVisitor v = new AnnotationTypeVisitor(attr, chk, syms, typeEnvs);
1155             v.scanAnnotationType(tree);
1156             tree.sym.getAnnotationTypeMetadata().setRepeatable(v.repeatable);
1157             tree.sym.getAnnotationTypeMetadata().setTarget(v.target);
1158         } finally {
1159             log.useSource(prev);
1160         }
1161     }
</pre>
<hr />
<pre>
1345                     @Override
1346                     public boolean isMetadataForAnnotationType() {
1347                         return false;
1348                     }
1349 
1350                     @Override
1351                     public Compound getTarget() {
1352                         return null;
1353                     }
1354 
1355                     @Override
1356                     public Compound getRepeatable() {
1357                         return null;
1358                     }
1359                 };
1360     }
1361 
1362     public void newRound() {
1363         blockCount = 1;
1364     }



























1365 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 259             try {
 260                 if (s.hasAnnotations() &amp;&amp; annotations.nonEmpty())
 261                     log.error(annotations.head.pos, Errors.AlreadyAnnotated(Kinds.kindName(s), s));
 262 
 263                 Assert.checkNonNull(s, &quot;Symbol argument to actualEnterAnnotations is null&quot;);
 264 
 265                 // false is passed as fifth parameter since annotateLater is
 266                 // never called for a type parameter
 267                 annotateNow(s, annotations, localEnv, false, false);
 268             } finally {
 269                 if (prevLint != null)
 270                     chk.setLint(prevLint);
 271                 deferredLintHandler.setPos(prevLintPos);
 272                 log.useSource(prev);
 273             }
 274         });
 275 
 276         validate(() -&gt; { //validate annotations
 277             JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
 278             try {
<span class="line-modified"> 279                 chk.validateAnnotations(annotations, TreeInfo.declarationFor(s, localEnv.tree), s);</span>
 280             } finally {
 281                 log.useSource(prev);
 282             }
 283         });
 284     }
 285 
 286 
 287     /** Queue processing of an attribute default value. */
 288     public void annotateDefaultValueLater(JCExpression defaultValue, Env&lt;AttrContext&gt; localEnv,
 289             MethodSymbol m, DiagnosticPosition deferPos)
 290     {
 291         normal(() -&gt; {
 292             JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);
 293             DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);
 294             try {
 295                 enterDefaultValue(defaultValue, localEnv, m);
 296             } finally {
 297                 deferredLintHandler.setPos(prevLintPos);
 298                 log.useSource(prev);
 299             }
</pre>
<hr />
<pre>
 347             if (a.type.tsym.isAnnotationType()) {
 348                 if (annotated.containsKey(a.type.tsym)) {
 349                     if (!allowRepeatedAnnos) {
 350                         log.error(DiagnosticFlag.SOURCE_LEVEL, a.pos(), Feature.REPEATED_ANNOTATIONS.error(sourceName));
 351                     }
 352                     ListBuffer&lt;T&gt; l = annotated.get(a.type.tsym);
 353                     l = l.append(c);
 354                     annotated.put(a.type.tsym, l);
 355                     pos.put(c, a.pos());
 356                 } else {
 357                     annotated.put(a.type.tsym, ListBuffer.of(c));
 358                     pos.put(c, a.pos());
 359                 }
 360             }
 361 
 362             // Note: @Deprecated has no effect on local variables and parameters
 363             if (!c.type.isErroneous()
 364                     &amp;&amp; (toAnnotate.kind == MDL || toAnnotate.owner.kind != MTH)
 365                     &amp;&amp; types.isSameType(c.type, syms.deprecatedType)) {
 366                 toAnnotate.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
<span class="line-modified"> 367                 if (isAttributeTrue(c.member(names.forRemoval))) {</span>
<span class="line-modified"> 368                     toAnnotate.flags_field |= Flags.DEPRECATED_REMOVAL;</span>
<span class="line-modified"> 369                 }</span>
<span class="line-modified"> 370             }</span>
<span class="line-modified"> 371 </span>
<span class="line-modified"> 372             // Note: @Deprecated has no effect on local variables and parameters</span>
<span class="line-added"> 373             if (!c.type.isErroneous()</span>
<span class="line-added"> 374                     &amp;&amp; types.isSameType(c.type, syms.previewFeatureType)) {</span>
<span class="line-added"> 375                 toAnnotate.flags_field |= Flags.PREVIEW_API;</span>
<span class="line-added"> 376                 if (isAttributeTrue(c.member(names.essentialAPI))) {</span>
<span class="line-added"> 377                     toAnnotate.flags_field |= Flags.PREVIEW_ESSENTIAL_API;</span>
 378                 }
 379             }
 380         }
 381 
 382         List&lt;T&gt; buf = List.nil();
 383         for (ListBuffer&lt;T&gt; lb : annotated.values()) {
 384             if (lb.size() == 1) {
 385                 buf = buf.prepend(lb.first());
 386             } else {
 387                 AnnotationContext&lt;T&gt; ctx = new AnnotationContext&lt;&gt;(env, annotated, pos, typeAnnotations);
 388                 T res = makeContainerAnnotation(lb.toList(), ctx, toAnnotate, isTypeParam);
 389                 if (res != null)
 390                     buf = buf.prepend(res);
 391             }
 392         }
 393 
 394         if (typeAnnotations) {
 395             @SuppressWarnings(&quot;unchecked&quot;)
 396             List&lt;TypeCompound&gt; attrs = (List&lt;TypeCompound&gt;)buf.reverse();
 397             toAnnotate.appendUniqueTypeAttributes(attrs);
 398         } else {
 399             @SuppressWarnings(&quot;unchecked&quot;)
 400             List&lt;Attribute.Compound&gt; attrs =  (List&lt;Attribute.Compound&gt;)buf.reverse();
 401             toAnnotate.resetAnnotations();
 402             toAnnotate.setDeclarationAttributes(attrs);
 403         }
 404     }
<span class="line-added"> 405     //where:</span>
<span class="line-added"> 406         private boolean isAttributeTrue(Attribute attr) {</span>
<span class="line-added"> 407             if (attr instanceof Attribute.Constant) {</span>
<span class="line-added"> 408                 Attribute.Constant v = (Attribute.Constant) attr;</span>
<span class="line-added"> 409                 if (v.type == syms.booleanType &amp;&amp; ((Integer) v.value) != 0) {</span>
<span class="line-added"> 410                     return true;</span>
<span class="line-added"> 411                 }</span>
<span class="line-added"> 412             }</span>
<span class="line-added"> 413             return false;</span>
<span class="line-added"> 414         }</span>
 415 
 416     /**
 417      * Attribute and store a semantic representation of the annotation tree {@code tree} into the
 418      * tree.attribute field.
 419      *
 420      * @param tree the tree representing an annotation
 421      * @param expectedAnnotationType the expected (super)type of the annotation
 422      * @param env the current env in where the annotation instance is found
 423      */
 424     public Attribute.Compound attributeAnnotation(JCAnnotation tree, Type expectedAnnotationType,
 425                                                   Env&lt;AttrContext&gt; env)
 426     {
<span class="line-modified"> 427         // The attribute might have been entered if it is Target or Repeatable</span>
 428         // Because TreeCopier does not copy type, redo this if type is null
 429         if (tree.attribute != null &amp;&amp; tree.type != null)
 430             return tree.attribute;
 431 
 432         List&lt;Pair&lt;MethodSymbol, Attribute&gt;&gt; elems = attributeAnnotationValues(tree, expectedAnnotationType, env);
 433         Attribute.Compound ac = new Attribute.Compound(tree.type, elems);
 434 
 435         return tree.attribute = ac;
 436     }
 437 
 438     /** Attribute and store a semantic representation of the type annotation tree {@code tree} into
 439      * the tree.attribute field.
 440      *
 441      * @param a the tree representing an annotation
 442      * @param expectedAnnotationType the expected (super)type of the annotation
 443      * @param env the the current env in where the annotation instance is found
 444      */
 445     public Attribute.TypeCompound attributeTypeAnnotation(JCAnnotation a, Type expectedAnnotationType,
 446                                                           Env&lt;AttrContext&gt; env)
 447     {
<span class="line-modified"> 448         // The attribute might have been entered if it is Target or Repeatable</span>
 449         // Because TreeCopier does not copy type, redo this if type is null
 450         if (a.attribute == null || a.type == null || !(a.attribute instanceof Attribute.TypeCompound)) {
 451             // Create a new TypeCompound
 452             List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; elems =
 453                     attributeAnnotationValues(a, expectedAnnotationType, env);
 454 
 455             Attribute.TypeCompound tc =
 456                     new Attribute.TypeCompound(a.type, elems, TypeAnnotationPosition.unknown);
 457             a.attribute = tc;
 458             return tc;
 459         } else {
 460             // Use an existing TypeCompound
 461             return (Attribute.TypeCompound)a.attribute;
 462         }
 463     }
 464 
 465     /**
 466      *  Attribute annotation elements creating a list of pairs of the Symbol representing that
 467      *  element and the value of that element as an Attribute. */
 468     private List&lt;Pair&lt;MethodSymbol, Attribute&gt;&gt; attributeAnnotationValues(JCAnnotation a,
</pre>
<hr />
<pre>
 523                 env, thisAnnotationType,
 524                 left.name, List.nil(), null);
 525         left.sym = method;
 526         left.type = method.type;
 527         if (method.owner != thisAnnotationType.tsym &amp;&amp; !badAnnotation)
 528             log.error(left.pos(), Errors.NoAnnotationMember(left.name, thisAnnotationType));
 529         Type resultType = method.type.getReturnType();
 530 
 531         // Compute value part
 532         Attribute value = attributeAnnotationValue(resultType, assign.rhs, env);
 533         nameValuePair.type = resultType;
 534 
 535         return method.type.isErroneous() ? null : new Pair&lt;&gt;((MethodSymbol)method, value);
 536 
 537     }
 538 
 539     /** Attribute an annotation element value */
 540     private Attribute attributeAnnotationValue(Type expectedElementType, JCExpression tree,
 541             Env&lt;AttrContext&gt; env)
 542     {
<span class="line-modified"> 543         //first, try completing the symbol for the annotation value - if a completion</span>
 544         //error is thrown, we should recover gracefully, and display an
 545         //ordinary resolution diagnostic.
 546         try {
 547             expectedElementType.tsym.complete();
 548         } catch(CompletionFailure e) {
 549             log.error(tree.pos(), Errors.CantResolve(Kinds.kindName(e.sym), e.sym.getQualifiedName(), null, null));
 550             expectedElementType = syms.errType;
 551         }
 552 
 553         if (expectedElementType.hasTag(ARRAY)) {
 554             return getAnnotationArrayValue(expectedElementType, tree, env);
 555 
 556         }
 557 
 558         //error recovery
 559         if (tree.hasTag(NEWARRAY)) {
 560             if (!expectedElementType.isErroneous())
 561                 log.error(tree.pos(), Errors.AnnotationValueNotAllowableType);
 562             JCNewArray na = (JCNewArray)tree;
 563             if (na.elemtype != null) {
</pre>
<hr />
<pre>
 818                         ((Attribute.TypeCompound)annotations.head).position);
 819 
 820                 JCAnnotation annoTree = m.TypeAnnotation(at);
 821                 if (!chk.validateAnnotationDeferErrors(annoTree))
 822                     log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
 823 
 824                 if (!chk.isTypeAnnotation(annoTree, isTypeParam)) {
 825                     log.error(pos, isTypeParam ? Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on)
 826                                                : Errors.InvalidRepeatableAnnotationNotApplicableInContext(targetContainerType));
 827                 }
 828 
 829                 at.setSynthesized(true);
 830 
 831                 @SuppressWarnings(&quot;unchecked&quot;)
 832                 T x = (T) at;
 833                 return x;
 834             } else {
 835                 Attribute.Compound c = new Attribute.Compound(targetContainerType, List.of(p));
 836                 JCAnnotation annoTree = m.Annotation(c);
 837 
<span class="line-modified"> 838                 boolean isRecordMember = (on.flags_field &amp; Flags.RECORD) != 0 || on.enclClass() != null &amp;&amp; on.enclClass().isRecord();</span>
<span class="line-added"> 839                 /* if it is a record member we will not issue the error now and wait until annotations on records are</span>
<span class="line-added"> 840                  * checked at Check::validateAnnotation, which will issue it</span>
<span class="line-added"> 841                  */</span>
<span class="line-added"> 842                 if (!chk.annotationApplicable(annoTree, on) &amp;&amp; (!isRecordMember || isRecordMember &amp;&amp; (on.flags_field &amp; Flags.GENERATED_MEMBER) == 0)) {</span>
 843                     log.error(annoTree.pos(),
 844                               Errors.InvalidRepeatableAnnotationNotApplicable(targetContainerType, on));
 845                 }
 846 
 847                 if (!chk.validateAnnotationDeferErrors(annoTree))
 848                     log.error(annoTree.pos(), Errors.DuplicateAnnotationInvalidRepeated(origAnnoType));
 849 
 850                 c = attributeAnnotation(annoTree, targetContainerType, ctx.env);
 851                 c.setSynthesized(true);
 852 
 853                 @SuppressWarnings(&quot;unchecked&quot;)
 854                 T x = (T) c;
 855                 return x;
 856             }
 857         } else {
 858             return null; // errors should have been reported elsewhere
 859         }
 860     }
 861 
 862     /**
</pre>
<hr />
<pre>
1108             // Do not annotate the body, just the signature.
1109         }
1110 
1111         @Override
1112         public void visitVarDef(JCVariableDecl tree) {
1113             DiagnosticPosition prevPos = deferPos;
1114             deferPos = tree.pos();
1115             try {
1116                 if (sym != null &amp;&amp; sym.kind == VAR) {
1117                     // Don&#39;t visit a parameter once when the sym is the method
1118                     // and once when the sym is the parameter.
1119                     scan(tree.mods);
1120                     scan(tree.vartype);
1121                 }
1122                 scan(tree.init);
1123             } finally {
1124                 deferPos = prevPos;
1125             }
1126         }
1127 
<span class="line-added">1128         @Override</span>
<span class="line-added">1129         public void visitBindingPattern(JCTree.JCBindingPattern tree) {</span>
<span class="line-added">1130             //type binding pattern&#39;s type will be annotated separately, avoid</span>
<span class="line-added">1131             //adding its annotations into the owning method here (would clash</span>
<span class="line-added">1132             //with repeatable annotations).</span>
<span class="line-added">1133         }</span>
<span class="line-added">1134 </span>
1135         @Override
1136         public void visitClassDef(JCClassDecl tree) {
1137             // We can only hit a classdef if it is declared within
1138             // a method. Ignore it - the class will be visited
1139             // separately later.
1140         }
1141 
1142         @Override
1143         public void visitNewClass(JCNewClass tree) {
1144             scan(tree.encl);
1145             scan(tree.typeargs);
1146             if (tree.def == null) {
1147                 scan(tree.clazz);
1148             }
1149             scan(tree.args);
1150             // the anonymous class instantiation if any will be visited separately.
1151         }
1152     }
1153 
1154     /*********************
1155      * Completer support *
1156      *********************/
1157 
1158     private AnnotationTypeCompleter theSourceCompleter = new AnnotationTypeCompleter() {
1159         @Override
1160         public void complete(ClassSymbol sym) throws CompletionFailure {
1161             Env&lt;AttrContext&gt; context = typeEnvs.get(sym);
1162             Annotate.this.attributeAnnotationType(context);
1163         }
1164     };
1165 
1166     /* Last stage completer to enter just enough annotations to have a prototype annotation type.
<span class="line-modified">1167      * This currently means entering @Target and @Repeatable.</span>
1168      */
1169     public AnnotationTypeCompleter annotationTypeSourceCompleter() {
1170         return theSourceCompleter;
1171     }
1172 
1173     private void attributeAnnotationType(Env&lt;AttrContext&gt; env) {
1174         Assert.check(((JCClassDecl)env.tree).sym.isAnnotationType(),
1175                 &quot;Trying to annotation type complete a non-annotation type&quot;);
1176 
1177         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
1178         try {
1179             JCClassDecl tree = (JCClassDecl)env.tree;
1180             AnnotationTypeVisitor v = new AnnotationTypeVisitor(attr, chk, syms, typeEnvs);
1181             v.scanAnnotationType(tree);
1182             tree.sym.getAnnotationTypeMetadata().setRepeatable(v.repeatable);
1183             tree.sym.getAnnotationTypeMetadata().setTarget(v.target);
1184         } finally {
1185             log.useSource(prev);
1186         }
1187     }
</pre>
<hr />
<pre>
1371                     @Override
1372                     public boolean isMetadataForAnnotationType() {
1373                         return false;
1374                     }
1375 
1376                     @Override
1377                     public Compound getTarget() {
1378                         return null;
1379                     }
1380 
1381                     @Override
1382                     public Compound getRepeatable() {
1383                         return null;
1384                     }
1385                 };
1386     }
1387 
1388     public void newRound() {
1389         blockCount = 1;
1390     }
<span class="line-added">1391 </span>
<span class="line-added">1392     public Queues setQueues(Queues nue) {</span>
<span class="line-added">1393         Queues stored = new Queues(q, validateQ, typesQ, afterTypesQ);</span>
<span class="line-added">1394         this.q = nue.q;</span>
<span class="line-added">1395         this.typesQ = nue.typesQ;</span>
<span class="line-added">1396         this.afterTypesQ = nue.afterTypesQ;</span>
<span class="line-added">1397         this.validateQ = nue.validateQ;</span>
<span class="line-added">1398         return stored;</span>
<span class="line-added">1399     }</span>
<span class="line-added">1400 </span>
<span class="line-added">1401     static class Queues {</span>
<span class="line-added">1402         private final ListBuffer&lt;Runnable&gt; q;</span>
<span class="line-added">1403         private final ListBuffer&lt;Runnable&gt; validateQ;</span>
<span class="line-added">1404         private final ListBuffer&lt;Runnable&gt; typesQ;</span>
<span class="line-added">1405         private final ListBuffer&lt;Runnable&gt; afterTypesQ;</span>
<span class="line-added">1406 </span>
<span class="line-added">1407         public Queues() {</span>
<span class="line-added">1408             this(new ListBuffer&lt;Runnable&gt;(), new ListBuffer&lt;Runnable&gt;(), new ListBuffer&lt;Runnable&gt;(), new ListBuffer&lt;Runnable&gt;());</span>
<span class="line-added">1409         }</span>
<span class="line-added">1410 </span>
<span class="line-added">1411         public Queues(ListBuffer&lt;Runnable&gt; q, ListBuffer&lt;Runnable&gt; validateQ, ListBuffer&lt;Runnable&gt; typesQ, ListBuffer&lt;Runnable&gt; afterTypesQ) {</span>
<span class="line-added">1412             this.q = q;</span>
<span class="line-added">1413             this.validateQ = validateQ;</span>
<span class="line-added">1414             this.typesQ = typesQ;</span>
<span class="line-added">1415             this.afterTypesQ = afterTypesQ;</span>
<span class="line-added">1416         }</span>
<span class="line-added">1417     }</span>
1418 }
</pre>
</td>
</tr>
</table>
<center><a href="Analyzer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ArgumentAttr.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Items.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Gen.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JNIWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Items.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 
 28 import com.sun.tools.javac.code.*;
 29 import com.sun.tools.javac.code.Symbol.*;
 30 import com.sun.tools.javac.code.Type.*;
 31 import com.sun.tools.javac.jvm.Code.*;


 32 import com.sun.tools.javac.tree.JCTree;
 33 import com.sun.tools.javac.util.Assert;
 34 
 35 import static com.sun.tools.javac.jvm.ByteCodes.*;
 36 
 37 /** A helper class for code generation. Items are objects
 38  *  that stand for addressable entities in the bytecode. Each item
 39  *  supports a fixed protocol for loading the item on the stack, storing
 40  *  into it, converting it into a jump condition, and several others.
 41  *  There are many individual forms of items, such as local, static,
 42  *  indexed, or instance variables, values on the top of stack, the
 43  *  special values this or super, etc. Individual items are represented as
 44  *  inner classes in class Items.
 45  *
 46  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 47  *  If you write code that depends on this, you do so at your own risk.
 48  *  This code and its internal interfaces are subject to change or
 49  *  deletion without notice.&lt;/b&gt;
 50  */
 51 public class Items {
 52 
<span class="line-modified"> 53     /** The current constant pool.</span>
 54      */
<span class="line-modified"> 55     Pool pool;</span>
 56 
 57     /** The current code buffer.
 58      */
 59     Code code;
 60 
 61     /** The current symbol table.
 62      */
 63     Symtab syms;
 64 
 65     /** Type utilities. */
 66     Types types;
 67 
 68     /** Items that exist only once (flyweight pattern).
 69      */
 70     private final Item voidItem;
 71     private final Item thisItem;
 72     private final Item superItem;
 73     private final Item[] stackItem = new Item[TypeCodeCount];
 74 
<span class="line-modified"> 75     public Items(Pool pool, Code code, Symtab syms, Types types) {</span>
 76         this.code = code;
<span class="line-modified"> 77         this.pool = pool;</span>
 78         this.types = types;
 79         voidItem = new Item(VOIDcode) {
 80                 public String toString() { return &quot;void&quot;; }
 81             };
 82         thisItem = new SelfItem(false);
 83         superItem = new SelfItem(true);
 84         for (int i = 0; i &lt; VOIDcode; i++) stackItem[i] = new StackItem(i);
 85         stackItem[VOIDcode] = voidItem;
 86         this.syms = syms;
 87     }
 88 
 89     /** Make a void item
 90      */
 91     Item makeVoidItem() {
 92         return voidItem;
 93     }
 94     /** Make an item representing `this&#39;.
 95      */
 96     Item makeThisItem() {
 97         return thisItem;
</pre>
<hr />
<pre>
155         return new MemberItem(member, nonvirtual);
156     }
157 
158     /** Make an item representing a literal.
159      *  @param type     The literal&#39;s type.
160      *  @param value    The literal&#39;s value.
161      */
162     Item makeImmediateItem(Type type, Object value) {
163         return new ImmediateItem(type, value);
164     }
165 
166     /** Make an item representing an assignment expression.
167      *  @param lhs      The item representing the assignment&#39;s left hand side.
168      */
169     Item makeAssignItem(Item lhs) {
170         return new AssignItem(lhs);
171     }
172 
173     /** Make an item representing a conditional or unconditional jump.
174      *  @param opcode      The jump&#39;s opcode.
<span class="line-modified">175      *  @param trueJumps   A chain encomassing all jumps that can be taken</span>
176      *                     if the condition evaluates to true.
<span class="line-modified">177      *  @param falseJumps  A chain encomassing all jumps that can be taken</span>
178      *                     if the condition evaluates to false.
179      */
180     CondItem makeCondItem(int opcode, Chain trueJumps, Chain falseJumps) {
181         return new CondItem(opcode, trueJumps, falseJumps);
182     }
183 
184     /** Make an item representing a conditional or unconditional jump.
185      *  @param opcode      The jump&#39;s opcode.
186      */
187     CondItem makeCondItem(int opcode) {
188         return makeCondItem(opcode, null, null);
189     }
190 
191     /** The base class of all items, which implements default behavior.
192      */
193     abstract class Item {
194 
195         /** The type code of values represented by this item.
196          */
197         int typecode;
</pre>
<hr />
<pre>
427 
428         public String toString() {
429             return &quot;localItem(type=&quot; + type + &quot;; reg=&quot; + reg + &quot;)&quot;;
430         }
431     }
432 
433     /** An item representing a static variable or method.
434      */
435     class StaticItem extends Item {
436 
437         /** The represented symbol.
438          */
439         Symbol member;
440 
441         StaticItem(Symbol member) {
442             super(Code.typecode(member.erasure(types)));
443             this.member = member;
444         }
445 
446         Item load() {
<span class="line-modified">447             code.emitop2(getstatic, pool.put(member));</span>
448             return stackItem[typecode];
449         }
450 
451         void store() {
<span class="line-modified">452             code.emitop2(putstatic, pool.put(member));</span>
453         }
454 
455         Item invoke() {
456             MethodType mtype = (MethodType)member.erasure(types);
457             int rescode = Code.typecode(mtype.restype);
<span class="line-modified">458             code.emitInvokestatic(pool.put(member), mtype);</span>
459             return stackItem[rescode];
460         }
461 
462         public String toString() {
463             return &quot;static(&quot; + member + &quot;)&quot;;
464         }
465     }
466 
467     /** An item representing a dynamic call site.
468      */
469     class DynamicItem extends StaticItem {
470         DynamicItem(Symbol member) {
471             super(member);
472         }
473 
474         Item load() {
<span class="line-modified">475             assert false;</span>
<span class="line-modified">476             return null;</span>



477         }
478 
<span class="line-modified">479         void store() {</span>
<span class="line-removed">480             assert false;</span>
<span class="line-removed">481         }</span>
482 
483         Item invoke() {
<span class="line-modified">484             // assert target.hasNativeInvokeDynamic();</span>
485             MethodType mtype = (MethodType)member.erasure(types);
486             int rescode = Code.typecode(mtype.restype);
<span class="line-modified">487             code.emitInvokedynamic(pool.put(member), mtype);</span>
488             return stackItem[rescode];
489         }
490 
491         public String toString() {
492             return &quot;dynamic(&quot; + member + &quot;)&quot;;
493         }
494     }
495 
496     /** An item representing an instance variable or method.
497      */
498     class MemberItem extends Item {
499 
500         /** The represented symbol.
501          */
502         Symbol member;
503 
504         /** Flag that determines whether or not access is virtual.
505          */
506         boolean nonvirtual;
507 
508         MemberItem(Symbol member, boolean nonvirtual) {
509             super(Code.typecode(member.erasure(types)));
510             this.member = member;
511             this.nonvirtual = nonvirtual;
512         }
513 
514         Item load() {
<span class="line-modified">515             code.emitop2(getfield, pool.put(member));</span>
516             return stackItem[typecode];
517         }
518 
519         void store() {
<span class="line-modified">520             code.emitop2(putfield, pool.put(member));</span>
521         }
522 
523         Item invoke() {
524             MethodType mtype = (MethodType)member.externalType(types);
525             int rescode = Code.typecode(mtype.restype);
526             if ((member.owner.flags() &amp; Flags.INTERFACE) != 0 &amp;&amp; !nonvirtual) {
<span class="line-modified">527                 code.emitInvokeinterface(pool.put(member), mtype);</span>
528             } else if (nonvirtual) {
<span class="line-modified">529                 code.emitInvokespecial(pool.put(member), mtype);</span>
530             } else {
<span class="line-modified">531                 code.emitInvokevirtual(pool.put(member), mtype);</span>
532             }
533             return stackItem[rescode];
534         }
535 
536         void duplicate() {
537             stackItem[OBJECTcode].duplicate();
538         }
539 
540         void drop() {
541             stackItem[OBJECTcode].drop();
542         }
543 
544         void stash(int toscode) {
545             stackItem[OBJECTcode].stash(toscode);
546         }
547 
548         int width() {
549             return 1;
550         }
551 
552         public String toString() {
553             return &quot;member(&quot; + member + (nonvirtual ? &quot; nonvirtual)&quot; : &quot;)&quot;);
554         }
555     }
556 
557     /** An item representing a literal.
558      */
559     class ImmediateItem extends Item {
560 
561         /** The literal&#39;s value.
562          */
<span class="line-modified">563         Object value;</span>
564 
565         ImmediateItem(Type type, Object value) {
566             super(Code.typecode(type));
<span class="line-modified">567             this.value = value;</span>





















568         }
569 
570         private void ldc() {
<span class="line-removed">571             int idx = pool.put(value);</span>
572             if (typecode == LONGcode || typecode == DOUBLEcode) {
<span class="line-modified">573                 code.emitop2(ldc2w, idx);</span>
574             } else {
<span class="line-modified">575                 code.emitLdc(idx);</span>
576             }
577         }
578 




579         Item load() {
580             switch (typecode) {
581             case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
<span class="line-modified">582                 int ival = ((Number)value).intValue();</span>
583                 if (-1 &lt;= ival &amp;&amp; ival &lt;= 5)
584                     code.emitop0(iconst_0 + ival);
585                 else if (Byte.MIN_VALUE &lt;= ival &amp;&amp; ival &lt;= Byte.MAX_VALUE)
586                     code.emitop1(bipush, ival);
587                 else if (Short.MIN_VALUE &lt;= ival &amp;&amp; ival &lt;= Short.MAX_VALUE)
588                     code.emitop2(sipush, ival);
589                 else
590                     ldc();
591                 break;
592             case LONGcode:
<span class="line-modified">593                 long lval = ((Number)value).longValue();</span>
594                 if (lval == 0 || lval == 1)
595                     code.emitop0(lconst_0 + (int)lval);
596                 else
597                     ldc();
598                 break;
599             case FLOATcode:
<span class="line-modified">600                 float fval = ((Number)value).floatValue();</span>
601                 if (isPosZero(fval) || fval == 1.0 || fval == 2.0)
602                     code.emitop0(fconst_0 + (int)fval);
603                 else {
604                     ldc();
605                 }
606                 break;
607             case DOUBLEcode:
<span class="line-modified">608                 double dval = ((Number)value).doubleValue();</span>
609                 if (isPosZero(dval) || dval == 1.0)
610                     code.emitop0(dconst_0 + (int)dval);
611                 else
612                     ldc();
613                 break;
614             case OBJECTcode:
615                 ldc();
616                 break;
617             default:
618                 Assert.error();
619             }
620             return stackItem[typecode];
621         }
622         //where
623             /** Return true iff float number is positive 0.
624              */
625             private boolean isPosZero(float x) {
626                 return x == 0.0f &amp;&amp; 1.0f / x &gt; 0.0f;
627             }
628             /** Return true iff double number is positive 0.
629              */
630             private boolean isPosZero(double x) {
631                 return x == 0.0d &amp;&amp; 1.0d / x &gt; 0.0d;
632             }
633 
634         CondItem mkCond() {
<span class="line-modified">635             int ival = ((Number)value).intValue();</span>
636             return makeCondItem(ival != 0 ? goto_ : dontgoto);
637         }
638 
639         Item coerce(int targetcode) {
640             if (typecode == targetcode) {
641                 return this;
642             } else {
643                 switch (targetcode) {
644                 case INTcode:
645                     if (Code.truncate(typecode) == INTcode)
646                         return this;
647                     else
648                         return new ImmediateItem(
649                             syms.intType,
<span class="line-modified">650                             ((Number)value).intValue());</span>
651                 case LONGcode:
652                     return new ImmediateItem(
653                         syms.longType,
<span class="line-modified">654                         ((Number)value).longValue());</span>
655                 case FLOATcode:
656                     return new ImmediateItem(
657                         syms.floatType,
<span class="line-modified">658                         ((Number)value).floatValue());</span>
659                 case DOUBLEcode:
660                     return new ImmediateItem(
661                         syms.doubleType,
<span class="line-modified">662                         ((Number)value).doubleValue());</span>
663                 case BYTEcode:
664                     return new ImmediateItem(
665                         syms.byteType,
<span class="line-modified">666                         (int)(byte)((Number)value).intValue());</span>
667                 case CHARcode:
668                     return new ImmediateItem(
669                         syms.charType,
<span class="line-modified">670                         (int)(char)((Number)value).intValue());</span>
671                 case SHORTcode:
672                     return new ImmediateItem(
673                         syms.shortType,
<span class="line-modified">674                         (int)(short)((Number)value).intValue());</span>
675                 default:
676                     return super.coerce(targetcode);
677                 }
678             }
679         }
680 
681         public String toString() {
682             return &quot;immediate(&quot; + value + &quot;)&quot;;
683         }
684     }
685 
686     /** An item representing an assignment expressions.
687      */
688     class AssignItem extends Item {
689 
690         /** The item representing the assignment&#39;s left hand side.
691          */
692         Item lhs;
693 
694         AssignItem(Item lhs) {
</pre>
<hr />
<pre>
710             lhs.store();
711         }
712 
713         void stash(int toscode) {
714             Assert.error();
715         }
716 
717         int width() {
718             return lhs.width() + Code.width(typecode);
719         }
720 
721         public String toString() {
722             return &quot;assign(lhs = &quot; + lhs + &quot;)&quot;;
723         }
724     }
725 
726     /** An item representing a conditional or unconditional jump.
727      */
728     class CondItem extends Item {
729 
<span class="line-modified">730         /** A chain encomassing all jumps that can be taken</span>
731          *  if the condition evaluates to true.
732          */
733         Chain trueJumps;
734 
<span class="line-modified">735         /** A chain encomassing all jumps that can be taken</span>
736          *  if the condition evaluates to false.
737          */
738         Chain falseJumps;
739 
740         /** The jump&#39;s opcode.
741          */
742         int opcode;
743 
744         /*
745          *  An abstract syntax tree of this item. It is needed
746          *  for branch entries in &#39;CharacterRangeTable&#39; attribute.
747          */
748         JCTree tree;
749 
750         CondItem(int opcode, Chain truejumps, Chain falsejumps) {
751             super(BYTEcode);
752             this.opcode = opcode;
753             this.trueJumps = truejumps;
754             this.falseJumps = falsejumps;
755         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 
 28 import com.sun.tools.javac.code.*;
 29 import com.sun.tools.javac.code.Symbol.*;
 30 import com.sun.tools.javac.code.Type.*;
 31 import com.sun.tools.javac.jvm.Code.*;
<span class="line-added"> 32 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
<span class="line-added"> 33 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant.BasicConstant;</span>
 34 import com.sun.tools.javac.tree.JCTree;
 35 import com.sun.tools.javac.util.Assert;
 36 
 37 import static com.sun.tools.javac.jvm.ByteCodes.*;
 38 
 39 /** A helper class for code generation. Items are objects
 40  *  that stand for addressable entities in the bytecode. Each item
 41  *  supports a fixed protocol for loading the item on the stack, storing
 42  *  into it, converting it into a jump condition, and several others.
 43  *  There are many individual forms of items, such as local, static,
 44  *  indexed, or instance variables, values on the top of stack, the
 45  *  special values this or super, etc. Individual items are represented as
 46  *  inner classes in class Items.
 47  *
 48  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 49  *  If you write code that depends on this, you do so at your own risk.
 50  *  This code and its internal interfaces are subject to change or
 51  *  deletion without notice.&lt;/b&gt;
 52  */
 53 public class Items {
 54 
<span class="line-modified"> 55     /** The current constant pool writer.</span>
 56      */
<span class="line-modified"> 57     PoolWriter poolWriter;</span>
 58 
 59     /** The current code buffer.
 60      */
 61     Code code;
 62 
 63     /** The current symbol table.
 64      */
 65     Symtab syms;
 66 
 67     /** Type utilities. */
 68     Types types;
 69 
 70     /** Items that exist only once (flyweight pattern).
 71      */
 72     private final Item voidItem;
 73     private final Item thisItem;
 74     private final Item superItem;
 75     private final Item[] stackItem = new Item[TypeCodeCount];
 76 
<span class="line-modified"> 77     public Items(PoolWriter poolWriter, Code code, Symtab syms, Types types) {</span>
 78         this.code = code;
<span class="line-modified"> 79         this.poolWriter = poolWriter;</span>
 80         this.types = types;
 81         voidItem = new Item(VOIDcode) {
 82                 public String toString() { return &quot;void&quot;; }
 83             };
 84         thisItem = new SelfItem(false);
 85         superItem = new SelfItem(true);
 86         for (int i = 0; i &lt; VOIDcode; i++) stackItem[i] = new StackItem(i);
 87         stackItem[VOIDcode] = voidItem;
 88         this.syms = syms;
 89     }
 90 
 91     /** Make a void item
 92      */
 93     Item makeVoidItem() {
 94         return voidItem;
 95     }
 96     /** Make an item representing `this&#39;.
 97      */
 98     Item makeThisItem() {
 99         return thisItem;
</pre>
<hr />
<pre>
157         return new MemberItem(member, nonvirtual);
158     }
159 
160     /** Make an item representing a literal.
161      *  @param type     The literal&#39;s type.
162      *  @param value    The literal&#39;s value.
163      */
164     Item makeImmediateItem(Type type, Object value) {
165         return new ImmediateItem(type, value);
166     }
167 
168     /** Make an item representing an assignment expression.
169      *  @param lhs      The item representing the assignment&#39;s left hand side.
170      */
171     Item makeAssignItem(Item lhs) {
172         return new AssignItem(lhs);
173     }
174 
175     /** Make an item representing a conditional or unconditional jump.
176      *  @param opcode      The jump&#39;s opcode.
<span class="line-modified">177      *  @param trueJumps   A chain encompassing all jumps that can be taken</span>
178      *                     if the condition evaluates to true.
<span class="line-modified">179      *  @param falseJumps  A chain encompassing all jumps that can be taken</span>
180      *                     if the condition evaluates to false.
181      */
182     CondItem makeCondItem(int opcode, Chain trueJumps, Chain falseJumps) {
183         return new CondItem(opcode, trueJumps, falseJumps);
184     }
185 
186     /** Make an item representing a conditional or unconditional jump.
187      *  @param opcode      The jump&#39;s opcode.
188      */
189     CondItem makeCondItem(int opcode) {
190         return makeCondItem(opcode, null, null);
191     }
192 
193     /** The base class of all items, which implements default behavior.
194      */
195     abstract class Item {
196 
197         /** The type code of values represented by this item.
198          */
199         int typecode;
</pre>
<hr />
<pre>
429 
430         public String toString() {
431             return &quot;localItem(type=&quot; + type + &quot;; reg=&quot; + reg + &quot;)&quot;;
432         }
433     }
434 
435     /** An item representing a static variable or method.
436      */
437     class StaticItem extends Item {
438 
439         /** The represented symbol.
440          */
441         Symbol member;
442 
443         StaticItem(Symbol member) {
444             super(Code.typecode(member.erasure(types)));
445             this.member = member;
446         }
447 
448         Item load() {
<span class="line-modified">449             code.emitop2(getstatic, member, PoolWriter::putMember);</span>
450             return stackItem[typecode];
451         }
452 
453         void store() {
<span class="line-modified">454             code.emitop2(putstatic, member, PoolWriter::putMember);</span>
455         }
456 
457         Item invoke() {
458             MethodType mtype = (MethodType)member.erasure(types);
459             int rescode = Code.typecode(mtype.restype);
<span class="line-modified">460             code.emitInvokestatic(member, mtype);</span>
461             return stackItem[rescode];
462         }
463 
464         public String toString() {
465             return &quot;static(&quot; + member + &quot;)&quot;;
466         }
467     }
468 
469     /** An item representing a dynamic call site.
470      */
471     class DynamicItem extends StaticItem {
472         DynamicItem(Symbol member) {
473             super(member);
474         }
475 
476         Item load() {
<span class="line-modified">477             Assert.check(member.kind == Kinds.Kind.VAR);</span>
<span class="line-modified">478             Type type = member.erasure(types);</span>
<span class="line-added">479             int rescode = Code.typecode(type);</span>
<span class="line-added">480             code.emitLdc((DynamicVarSymbol)member);</span>
<span class="line-added">481             return stackItem[rescode];</span>
482         }
483 
<span class="line-modified">484         void store() { Assert.error(&quot;this method shouldn&#39;t be invoked&quot;); }</span>


485 
486         Item invoke() {
<span class="line-modified">487             Assert.check(member.kind == Kinds.Kind.MTH);</span>
488             MethodType mtype = (MethodType)member.erasure(types);
489             int rescode = Code.typecode(mtype.restype);
<span class="line-modified">490             code.emitInvokedynamic((DynamicMethodSymbol)member, mtype);</span>
491             return stackItem[rescode];
492         }
493 
494         public String toString() {
495             return &quot;dynamic(&quot; + member + &quot;)&quot;;
496         }
497     }
498 
499     /** An item representing an instance variable or method.
500      */
501     class MemberItem extends Item {
502 
503         /** The represented symbol.
504          */
505         Symbol member;
506 
507         /** Flag that determines whether or not access is virtual.
508          */
509         boolean nonvirtual;
510 
511         MemberItem(Symbol member, boolean nonvirtual) {
512             super(Code.typecode(member.erasure(types)));
513             this.member = member;
514             this.nonvirtual = nonvirtual;
515         }
516 
517         Item load() {
<span class="line-modified">518             code.emitop2(getfield, member, PoolWriter::putMember);</span>
519             return stackItem[typecode];
520         }
521 
522         void store() {
<span class="line-modified">523             code.emitop2(putfield, member, PoolWriter::putMember);</span>
524         }
525 
526         Item invoke() {
527             MethodType mtype = (MethodType)member.externalType(types);
528             int rescode = Code.typecode(mtype.restype);
529             if ((member.owner.flags() &amp; Flags.INTERFACE) != 0 &amp;&amp; !nonvirtual) {
<span class="line-modified">530                 code.emitInvokeinterface(member, mtype);</span>
531             } else if (nonvirtual) {
<span class="line-modified">532                 code.emitInvokespecial(member, mtype);</span>
533             } else {
<span class="line-modified">534                 code.emitInvokevirtual(member, mtype);</span>
535             }
536             return stackItem[rescode];
537         }
538 
539         void duplicate() {
540             stackItem[OBJECTcode].duplicate();
541         }
542 
543         void drop() {
544             stackItem[OBJECTcode].drop();
545         }
546 
547         void stash(int toscode) {
548             stackItem[OBJECTcode].stash(toscode);
549         }
550 
551         int width() {
552             return 1;
553         }
554 
555         public String toString() {
556             return &quot;member(&quot; + member + (nonvirtual ? &quot; nonvirtual)&quot; : &quot;)&quot;);
557         }
558     }
559 
560     /** An item representing a literal.
561      */
562     class ImmediateItem extends Item {
563 
564         /** The literal&#39;s value.
565          */
<span class="line-modified">566         final LoadableConstant value;</span>
567 
568         ImmediateItem(Type type, Object value) {
569             super(Code.typecode(type));
<span class="line-modified">570             switch (typecode) {</span>
<span class="line-added">571                 case BYTEcode:</span>
<span class="line-added">572                 case SHORTcode:</span>
<span class="line-added">573                 case CHARcode:</span>
<span class="line-added">574                 case INTcode:</span>
<span class="line-added">575                     this.value = LoadableConstant.Int((int)value);</span>
<span class="line-added">576                     break;</span>
<span class="line-added">577                 case LONGcode:</span>
<span class="line-added">578                     this.value = LoadableConstant.Long((long)value);</span>
<span class="line-added">579                     break;</span>
<span class="line-added">580                 case FLOATcode:</span>
<span class="line-added">581                     this.value = LoadableConstant.Float((float)value);</span>
<span class="line-added">582                     break;</span>
<span class="line-added">583                 case DOUBLEcode:</span>
<span class="line-added">584                     this.value = LoadableConstant.Double((double)value);</span>
<span class="line-added">585                     break;</span>
<span class="line-added">586                 case OBJECTcode:</span>
<span class="line-added">587                     this.value = LoadableConstant.String((String)value);</span>
<span class="line-added">588                     break;</span>
<span class="line-added">589                 default:</span>
<span class="line-added">590                     throw new UnsupportedOperationException(&quot;unsupported tag: &quot; + typecode);</span>
<span class="line-added">591             }</span>
592         }
593 
594         private void ldc() {

595             if (typecode == LONGcode || typecode == DOUBLEcode) {
<span class="line-modified">596                 code.emitop2(ldc2w, value, PoolWriter::putConstant);</span>
597             } else {
<span class="line-modified">598                 code.emitLdc(value);</span>
599             }
600         }
601 
<span class="line-added">602         private Number numericValue() {</span>
<span class="line-added">603             return (Number)((BasicConstant)value).data;</span>
<span class="line-added">604         }</span>
<span class="line-added">605 </span>
606         Item load() {
607             switch (typecode) {
608             case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
<span class="line-modified">609                 int ival = numericValue().intValue();</span>
610                 if (-1 &lt;= ival &amp;&amp; ival &lt;= 5)
611                     code.emitop0(iconst_0 + ival);
612                 else if (Byte.MIN_VALUE &lt;= ival &amp;&amp; ival &lt;= Byte.MAX_VALUE)
613                     code.emitop1(bipush, ival);
614                 else if (Short.MIN_VALUE &lt;= ival &amp;&amp; ival &lt;= Short.MAX_VALUE)
615                     code.emitop2(sipush, ival);
616                 else
617                     ldc();
618                 break;
619             case LONGcode:
<span class="line-modified">620                 long lval = numericValue().longValue();</span>
621                 if (lval == 0 || lval == 1)
622                     code.emitop0(lconst_0 + (int)lval);
623                 else
624                     ldc();
625                 break;
626             case FLOATcode:
<span class="line-modified">627                 float fval = numericValue().floatValue();</span>
628                 if (isPosZero(fval) || fval == 1.0 || fval == 2.0)
629                     code.emitop0(fconst_0 + (int)fval);
630                 else {
631                     ldc();
632                 }
633                 break;
634             case DOUBLEcode:
<span class="line-modified">635                 double dval = numericValue().doubleValue();</span>
636                 if (isPosZero(dval) || dval == 1.0)
637                     code.emitop0(dconst_0 + (int)dval);
638                 else
639                     ldc();
640                 break;
641             case OBJECTcode:
642                 ldc();
643                 break;
644             default:
645                 Assert.error();
646             }
647             return stackItem[typecode];
648         }
649         //where
650             /** Return true iff float number is positive 0.
651              */
652             private boolean isPosZero(float x) {
653                 return x == 0.0f &amp;&amp; 1.0f / x &gt; 0.0f;
654             }
655             /** Return true iff double number is positive 0.
656              */
657             private boolean isPosZero(double x) {
658                 return x == 0.0d &amp;&amp; 1.0d / x &gt; 0.0d;
659             }
660 
661         CondItem mkCond() {
<span class="line-modified">662             int ival = numericValue().intValue();</span>
663             return makeCondItem(ival != 0 ? goto_ : dontgoto);
664         }
665 
666         Item coerce(int targetcode) {
667             if (typecode == targetcode) {
668                 return this;
669             } else {
670                 switch (targetcode) {
671                 case INTcode:
672                     if (Code.truncate(typecode) == INTcode)
673                         return this;
674                     else
675                         return new ImmediateItem(
676                             syms.intType,
<span class="line-modified">677                             numericValue().intValue());</span>
678                 case LONGcode:
679                     return new ImmediateItem(
680                         syms.longType,
<span class="line-modified">681                             numericValue().longValue());</span>
682                 case FLOATcode:
683                     return new ImmediateItem(
684                         syms.floatType,
<span class="line-modified">685                         numericValue().floatValue());</span>
686                 case DOUBLEcode:
687                     return new ImmediateItem(
688                         syms.doubleType,
<span class="line-modified">689                         numericValue().doubleValue());</span>
690                 case BYTEcode:
691                     return new ImmediateItem(
692                         syms.byteType,
<span class="line-modified">693                         (int)(byte)numericValue().intValue());</span>
694                 case CHARcode:
695                     return new ImmediateItem(
696                         syms.charType,
<span class="line-modified">697                         (int)(char)numericValue().intValue());</span>
698                 case SHORTcode:
699                     return new ImmediateItem(
700                         syms.shortType,
<span class="line-modified">701                         (int)(short)numericValue().intValue());</span>
702                 default:
703                     return super.coerce(targetcode);
704                 }
705             }
706         }
707 
708         public String toString() {
709             return &quot;immediate(&quot; + value + &quot;)&quot;;
710         }
711     }
712 
713     /** An item representing an assignment expressions.
714      */
715     class AssignItem extends Item {
716 
717         /** The item representing the assignment&#39;s left hand side.
718          */
719         Item lhs;
720 
721         AssignItem(Item lhs) {
</pre>
<hr />
<pre>
737             lhs.store();
738         }
739 
740         void stash(int toscode) {
741             Assert.error();
742         }
743 
744         int width() {
745             return lhs.width() + Code.width(typecode);
746         }
747 
748         public String toString() {
749             return &quot;assign(lhs = &quot; + lhs + &quot;)&quot;;
750         }
751     }
752 
753     /** An item representing a conditional or unconditional jump.
754      */
755     class CondItem extends Item {
756 
<span class="line-modified">757         /** A chain encompassing all jumps that can be taken</span>
758          *  if the condition evaluates to true.
759          */
760         Chain trueJumps;
761 
<span class="line-modified">762         /** A chain encompassing all jumps that can be taken</span>
763          *  if the condition evaluates to false.
764          */
765         Chain falseJumps;
766 
767         /** The jump&#39;s opcode.
768          */
769         int opcode;
770 
771         /*
772          *  An abstract syntax tree of this item. It is needed
773          *  for branch entries in &#39;CharacterRangeTable&#39; attribute.
774          */
775         JCTree tree;
776 
777         CondItem(int opcode, Chain truejumps, Chain falsejumps) {
778             super(BYTEcode);
779             this.opcode = opcode;
780             this.trueJumps = truejumps;
781             this.falseJumps = falsejumps;
782         }
</pre>
</td>
</tr>
</table>
<center><a href="Gen.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JNIWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LambdaToMethod.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemberEnter.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,19 ***</span>
   */
  
  package com.sun.tools.javac.comp;
  
  import java.util.*;
<span class="line-modified">! import java.util.Map.Entry;</span>
<span class="line-removed">- import java.util.function.Function;</span>
<span class="line-removed">- import java.util.stream.Stream;</span>
  
<span class="line-removed">- import com.sun.source.tree.CaseTree.CaseKind;</span>
  import com.sun.tools.javac.code.*;
  import com.sun.tools.javac.code.Kinds.KindSelector;
  import com.sun.tools.javac.code.Scope.WriteableScope;
  import com.sun.tools.javac.jvm.*;
  import com.sun.tools.javac.main.Option.PkgInfo;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  import com.sun.tools.javac.tree.*;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<span class="line-new-header">--- 24,17 ---</span>
   */
  
  package com.sun.tools.javac.comp;
  
  import java.util.*;
<span class="line-modified">! import java.util.stream.Collectors;</span>
  
  import com.sun.tools.javac.code.*;
  import com.sun.tools.javac.code.Kinds.KindSelector;
  import com.sun.tools.javac.code.Scope.WriteableScope;
  import com.sun.tools.javac.jvm.*;
<span class="line-added">+ import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
  import com.sun.tools.javac.main.Option.PkgInfo;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  import com.sun.tools.javac.tree.*;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,11 ***</span>
  import static com.sun.tools.javac.code.Flags.*;
  import static com.sun.tools.javac.code.Flags.BLOCK;
  import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  import static com.sun.tools.javac.code.TypeTag.*;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
<span class="line-removed">- import static com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode.DEREF;</span>
  import static com.sun.tools.javac.jvm.ByteCodes.*;
  import com.sun.tools.javac.tree.JCTree.JCBreak;
  import com.sun.tools.javac.tree.JCTree.JCCase;
  import com.sun.tools.javac.tree.JCTree.JCExpression;
  import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;
<span class="line-new-header">--- 52,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,11 ***</span>
      private final Operators operators;
      private final Check chk;
      private final Attr attr;
      private TreeMaker make;
      private DiagnosticPosition make_pos;
<span class="line-removed">-     private final ClassWriter writer;</span>
      private final ConstFold cfolder;
      private final Target target;
      private final Source source;
      private final TypeEnvs typeEnvs;
      private final Name dollarAssertionsDisabled;
<span class="line-new-header">--- 88,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 114,11 ***</span>
          rs = Resolve.instance(context);
          operators = Operators.instance(context);
          chk = Check.instance(context);
          attr = Attr.instance(context);
          make = TreeMaker.instance(context);
<span class="line-removed">-         writer = ClassWriter.instance(context);</span>
          cfolder = ConstFold.instance(context);
          target = Target.instance(context);
          source = Source.instance(context);
          typeEnvs = TypeEnvs.instance(context);
          dollarAssertionsDisabled = names.
<span class="line-new-header">--- 110,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,13 ***</span>
              }
              super.visitApply(tree);
          }
  
          @Override
<span class="line-modified">!         public void visitBreak(JCBreak tree) {</span>
<span class="line-modified">!             if (tree.isValueBreak())</span>
<span class="line-removed">-                 scan(tree.value);</span>
          }
  
      }
  
      /**
<span class="line-new-header">--- 267,12 ---</span>
              }
              super.visitApply(tree);
          }
  
          @Override
<span class="line-modified">!         public void visitYield(JCYield tree) {</span>
<span class="line-modified">!             scan(tree.value);</span>
          }
  
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 473,11 ***</span>
              this.pos = pos;
              Name varName = names
                  .fromString(target.syntheticNameChar() +
                              &quot;SwitchMap&quot; +
                              target.syntheticNameChar() +
<span class="line-modified">!                             writer.xClassName(forEnum.type).toString()</span>
                              .replace(&#39;/&#39;, &#39;.&#39;)
                              .replace(&#39;.&#39;, target.syntheticNameChar()));
              ClassSymbol outerCacheClass = outerCacheClass();
              this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,
                                          varName,
<span class="line-new-header">--- 467,11 ---</span>
              this.pos = pos;
              Name varName = names
                  .fromString(target.syntheticNameChar() +
                              &quot;SwitchMap&quot; +
                              target.syntheticNameChar() +
<span class="line-modified">!                             names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()</span>
                              .replace(&#39;/&#39;, &#39;.&#39;)
                              .replace(&#39;.&#39;, target.syntheticNameChar()));
              ClassSymbol outerCacheClass = outerCacheClass();
              this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,
                                          varName,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
          return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());
      }
  
      /** Anon inner classes are used as access constructor tags.
       * accessConstructorTag will use an existing anon class if one is available,
<span class="line-modified">!      * and synthethise a class (with makeEmptyClass) if one is not available.</span>
       * However, there is a small possibility that an existing class will not
       * be generated as expected if it is inside a conditional with a constant
       * expression. If that is found to be the case, create an empty class tree here.
       */
      private void checkAccessConstructorTags() {
<span class="line-new-header">--- 799,11 ---</span>
          return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());
      }
  
      /** Anon inner classes are used as access constructor tags.
       * accessConstructorTag will use an existing anon class if one is available,
<span class="line-modified">!      * and synthesize a class (with makeEmptyClass) if one is not available.</span>
       * However, there is a small possibility that an existing class will not
       * be generated as expected if it is inside a conditional with a constant
       * expression. If that is found to be the case, create an empty class tree here.
       */
      private void checkAccessConstructorTags() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1341,11 ***</span>
              args = make.Idents(md.params);
          } else {
              JCExpression site = make.Ident(md.params.head);
              if (acode % 2 != 0) {
                  //odd access codes represent qualified super accesses - need to
<span class="line-modified">!                 //emit reference to the direct superclass, even if the refered</span>
                  //member is from an indirect superclass (JLS 13.1)
                  site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));
              }
              ref = make.Select(site, sym);
              args = make.Idents(md.params.tail);
<span class="line-new-header">--- 1335,11 ---</span>
              args = make.Idents(md.params);
          } else {
              JCExpression site = make.Ident(md.params.head);
              if (acode % 2 != 0) {
                  //odd access codes represent qualified super accesses - need to
<span class="line-modified">!                 //emit reference to the direct superclass, even if the referred</span>
                  //member is from an indirect superclass (JLS 13.1)
                  site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));
              }
              ref = make.Select(site, sym);
              args = make.Idents(md.params.tail);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1887,11 ***</span>
          case DOUBLE: case BOOLEAN: case VOID:
              // replace with &lt;BoxedClass&gt;.TYPE
              ClassSymbol c = types.boxedClass(type);
              Symbol typeSym =
                  rs.accessBase(
<span class="line-modified">!                     rs.findIdentInType(attrEnv, c.type, names.TYPE, KindSelector.VAR),</span>
                      pos, c.type, names.TYPE, true);
              if (typeSym.kind == VAR)
                  ((VarSymbol)typeSym).getConstValue(); // ensure initializer is evaluated
              return make.QualIdent(typeSym);
          case CLASS: case ARRAY:
<span class="line-new-header">--- 1881,11 ---</span>
          case DOUBLE: case BOOLEAN: case VOID:
              // replace with &lt;BoxedClass&gt;.TYPE
              ClassSymbol c = types.boxedClass(type);
              Symbol typeSym =
                  rs.accessBase(
<span class="line-modified">!                     rs.findIdentInType(pos, attrEnv, c.type, names.TYPE, KindSelector.VAR),</span>
                      pos, c.type, names.TYPE, true);
              if (typeSym.kind == VAR)
                  ((VarSymbol)typeSym).getConstValue(); // ensure initializer is evaluated
              return make.QualIdent(typeSym);
          case CLASS: case ARRAY:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2189,10 ***</span>
<span class="line-new-header">--- 2183,14 ---</span>
          // If this is an enum definition
          if ((tree.mods.flags &amp; ENUM) != 0 &amp;&amp;
              (types.supertype(currentClass.type).tsym.flags() &amp; ENUM) == 0)
              visitEnumDef(tree);
  
<span class="line-added">+         if ((tree.mods.flags &amp; RECORD) != 0) {</span>
<span class="line-added">+             visitRecordDef(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // If this is a nested class, define a this$n field for
          // it and add to proxies.
          JCVariableDecl otdef = null;
          if (currentClass.hasOuterInstance())
              otdef = outerThisDef(tree.pos, currentClass);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2258,10 ***</span>
<span class="line-new-header">--- 2256,23 ---</span>
  
          // Return empty block {} as a placeholder for an inner class.
          result = make_at(tree.pos()).Block(SYNTHETIC, List.nil());
      }
  
<span class="line-added">+     List&lt;JCTree&gt; generateMandatedAccessors(JCClassDecl tree) {</span>
<span class="line-added">+         List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);</span>
<span class="line-added">+         return tree.sym.getRecordComponents().stream()</span>
<span class="line-added">+                 .filter(rc -&gt; (rc.accessor.flags() &amp; Flags.GENERATED_MEMBER) != 0)</span>
<span class="line-added">+                 .map(rc -&gt; {</span>
<span class="line-added">+                     // we need to return the field not the record component</span>
<span class="line-added">+                     JCVariableDecl field = fields.stream().filter(f -&gt; f.name == rc.name).findAny().get();</span>
<span class="line-added">+                     make_at(tree.pos());</span>
<span class="line-added">+                     return make.MethodDef(rc.accessor, make.Block(0,</span>
<span class="line-added">+                             List.of(make.Return(make.Ident(field)))));</span>
<span class="line-added">+                 }).collect(List.collector());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /** Translate an enum class. */
      private void visitEnumDef(JCClassDecl tree) {
          make_at(tree.pos());
  
          // add the supertype, if needed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2413,10 ***</span>
<span class="line-new-header">--- 2424,183 ---</span>
          varDef.args = varDef.args.
              prepend(makeLit(syms.intType, ordinal)).
              prepend(makeLit(syms.stringType, var.name.toString()));
      }
  
<span class="line-added">+     private List&lt;VarSymbol&gt; recordVars(Type t) {</span>
<span class="line-added">+         List&lt;VarSymbol&gt; vars = List.nil();</span>
<span class="line-added">+         while (!t.hasTag(NONE)) {</span>
<span class="line-added">+             if (t.hasTag(CLASS)) {</span>
<span class="line-added">+                 for (Symbol s : t.tsym.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; (s.flags() &amp; RECORD) != 0)) {</span>
<span class="line-added">+                     vars = vars.prepend((VarSymbol)s);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             t = types.supertype(t);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return vars;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /** Translate a record. */</span>
<span class="line-added">+     private void visitRecordDef(JCClassDecl tree) {</span>
<span class="line-added">+         make_at(tree.pos());</span>
<span class="line-added">+         List&lt;VarSymbol&gt; vars = recordVars(tree.type);</span>
<span class="line-added">+         MethodHandleSymbol[] getterMethHandles = new MethodHandleSymbol[vars.size()];</span>
<span class="line-added">+         int index = 0;</span>
<span class="line-added">+         for (VarSymbol var : vars) {</span>
<span class="line-added">+             if (var.owner != tree.sym) {</span>
<span class="line-added">+                 var = new VarSymbol(var.flags_field, var.name, var.type, tree.sym);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             getterMethHandles[index] = var.asMethodHandle(true);</span>
<span class="line-added">+             index++;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         tree.defs = tree.defs.appendList(generateMandatedAccessors(tree));</span>
<span class="line-added">+         tree.defs = tree.defs.appendList(List.of(</span>
<span class="line-added">+                 generateRecordMethod(tree, names.toString, vars, getterMethHandles),</span>
<span class="line-added">+                 generateRecordMethod(tree, names.hashCode, vars, getterMethHandles),</span>
<span class="line-added">+                 generateRecordMethod(tree, names.equals, vars, getterMethHandles)</span>
<span class="line-added">+         ));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     JCTree generateRecordMethod(JCClassDecl tree, Name name, List&lt;VarSymbol&gt; vars, MethodHandleSymbol[] getterMethHandles) {</span>
<span class="line-added">+         make_at(tree.pos());</span>
<span class="line-added">+         boolean isEquals = name == names.equals;</span>
<span class="line-added">+         MethodSymbol msym = lookupMethod(tree.pos(),</span>
<span class="line-added">+                 name,</span>
<span class="line-added">+                 tree.sym.type,</span>
<span class="line-added">+                 isEquals ? List.of(syms.objectType) : List.nil());</span>
<span class="line-added">+         // compiler generated methods have the record flag set, user defined ones dont</span>
<span class="line-added">+         if ((msym.flags() &amp; RECORD) != 0) {</span>
<span class="line-added">+             /* class java.lang.runtime.ObjectMethods provides a common bootstrap that provides a customized implementation</span>
<span class="line-added">+              * for methods: toString, hashCode and equals. Here we just need to generate and indy call to:</span>
<span class="line-added">+              * java.lang.runtime.ObjectMethods::bootstrap and provide: the record class, the record component names and</span>
<span class="line-added">+              * the accessors.</span>
<span class="line-added">+              */</span>
<span class="line-added">+             Name bootstrapName = names.bootstrap;</span>
<span class="line-added">+             LoadableConstant[] staticArgsValues = new LoadableConstant[2 + getterMethHandles.length];</span>
<span class="line-added">+             staticArgsValues[0] = (ClassType)tree.sym.type;</span>
<span class="line-added">+             String concatNames = vars.stream()</span>
<span class="line-added">+                     .map(v -&gt; v.name)</span>
<span class="line-added">+                     .collect(Collectors.joining(&quot;;&quot;, &quot;&quot;, &quot;&quot;));</span>
<span class="line-added">+             staticArgsValues[1] = LoadableConstant.String(concatNames);</span>
<span class="line-added">+             int index = 2;</span>
<span class="line-added">+             for (MethodHandleSymbol mho : getterMethHandles) {</span>
<span class="line-added">+                 staticArgsValues[index] = mho;</span>
<span class="line-added">+                 index++;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             List&lt;Type&gt; staticArgTypes = List.of(syms.classType,</span>
<span class="line-added">+                     syms.stringType,</span>
<span class="line-added">+                     new ArrayType(syms.methodHandleType, syms.arrayClass));</span>
<span class="line-added">+ </span>
<span class="line-added">+             JCFieldAccess qualifier = makeIndyQualifier(syms.objectMethodsType, tree, msym,</span>
<span class="line-added">+                     List.of(syms.methodHandleLookupType,</span>
<span class="line-added">+                             syms.stringType,</span>
<span class="line-added">+                             syms.typeDescriptorType).appendList(staticArgTypes),</span>
<span class="line-added">+                     staticArgsValues, bootstrapName, name, false);</span>
<span class="line-added">+ </span>
<span class="line-added">+             VarSymbol _this = new VarSymbol(SYNTHETIC, names._this, tree.sym.type, tree.sym);</span>
<span class="line-added">+ </span>
<span class="line-added">+             JCMethodInvocation proxyCall;</span>
<span class="line-added">+             if (!isEquals) {</span>
<span class="line-added">+                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this)));</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 VarSymbol o = msym.params.head;</span>
<span class="line-added">+                 o.adr = 0;</span>
<span class="line-added">+                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this), make.Ident(o)));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             proxyCall.type = qualifier.type;</span>
<span class="line-added">+             return make.MethodDef(msym, make.Block(0, List.of(make.Return(proxyCall))));</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return make.Block(SYNTHETIC, List.nil());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private String argsTypeSig(List&lt;Type&gt; typeList) {</span>
<span class="line-added">+         LowerSignatureGenerator sg = new LowerSignatureGenerator();</span>
<span class="line-added">+         sg.assembleSig(typeList);</span>
<span class="line-added">+         return sg.toString();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Signature Generation</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private class LowerSignatureGenerator extends Types.SignatureGenerator {</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * An output buffer for type signatures.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         StringBuilder sb = new StringBuilder();</span>
<span class="line-added">+ </span>
<span class="line-added">+         LowerSignatureGenerator() {</span>
<span class="line-added">+             super(types);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected void append(char ch) {</span>
<span class="line-added">+             sb.append(ch);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected void append(byte[] ba) {</span>
<span class="line-added">+             sb.append(new String(ba));</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected void append(Name name) {</span>
<span class="line-added">+             sb.append(name.toString());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public String toString() {</span>
<span class="line-added">+             return sb.toString();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Creates an indy qualifier, helpful to be part of an indy invocation</span>
<span class="line-added">+      * @param site                the site</span>
<span class="line-added">+      * @param tree                a class declaration tree</span>
<span class="line-added">+      * @param msym                the method symbol</span>
<span class="line-added">+      * @param staticArgTypes      the static argument types</span>
<span class="line-added">+      * @param staticArgValues     the static argument values</span>
<span class="line-added">+      * @param bootstrapName       the bootstrap name to look for</span>
<span class="line-added">+      * @param argName             normally bootstraps receives a method name as second argument, if you want that name</span>
<span class="line-added">+      *                            to be different to that of the bootstrap name pass a different name here</span>
<span class="line-added">+      * @param isStatic            is it static or not</span>
<span class="line-added">+      * @return                    a field access tree</span>
<span class="line-added">+      */</span>
<span class="line-added">+     JCFieldAccess makeIndyQualifier(</span>
<span class="line-added">+             Type site,</span>
<span class="line-added">+             JCClassDecl tree,</span>
<span class="line-added">+             MethodSymbol msym,</span>
<span class="line-added">+             List&lt;Type&gt; staticArgTypes,</span>
<span class="line-added">+             LoadableConstant[] staticArgValues,</span>
<span class="line-added">+             Name bootstrapName,</span>
<span class="line-added">+             Name argName,</span>
<span class="line-added">+             boolean isStatic) {</span>
<span class="line-added">+         Symbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,</span>
<span class="line-added">+                 bootstrapName, staticArgTypes, List.nil());</span>
<span class="line-added">+ </span>
<span class="line-added">+         MethodType indyType = msym.type.asMethodType();</span>
<span class="line-added">+         indyType = new MethodType(</span>
<span class="line-added">+                 isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),</span>
<span class="line-added">+                 indyType.restype,</span>
<span class="line-added">+                 indyType.thrown,</span>
<span class="line-added">+                 syms.methodClass</span>
<span class="line-added">+         );</span>
<span class="line-added">+         DynamicMethodSymbol dynSym = new DynamicMethodSymbol(argName,</span>
<span class="line-added">+                 syms.noSymbol,</span>
<span class="line-added">+                 ((MethodSymbol)bsm).asHandle(),</span>
<span class="line-added">+                 indyType,</span>
<span class="line-added">+                 staticArgValues);</span>
<span class="line-added">+         JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), argName);</span>
<span class="line-added">+         qualifier.sym = dynSym;</span>
<span class="line-added">+         qualifier.type = msym.type.asMethodType().restype;</span>
<span class="line-added">+         return qualifier;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public void visitMethodDef(JCMethodDecl tree) {
          if (tree.name == names.init &amp;&amp; (currentClass.flags_field&amp;ENUM) != 0) {
              // Add &quot;String $enum$name, int $enum$ordinal&quot; to the beginning of the
              // argument list for each constructor of an enum.
              JCVariableDecl nameParam = make_at(tree.pos()).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2540,10 ***</span>
<span class="line-new-header">--- 2724,31 ---</span>
                  super.visitMethodDef(tree);
              } finally {
                  lambdaTranslationMap = prevLambdaTranslationMap;
              }
          }
<span class="line-added">+         if (tree.name == names.init &amp;&amp; (tree.sym.flags_field &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {</span>
<span class="line-added">+             // lets find out if there is any field waiting to be initialized</span>
<span class="line-added">+             ListBuffer&lt;VarSymbol&gt; fields = new ListBuffer&lt;&gt;();</span>
<span class="line-added">+             for (Symbol sym : currentClass.getEnclosedElements()) {</span>
<span class="line-added">+                 if (sym.kind == Kinds.Kind.VAR &amp;&amp; ((sym.flags() &amp; RECORD) != 0))</span>
<span class="line-added">+                     fields.append((VarSymbol) sym);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             for (VarSymbol field: fields) {</span>
<span class="line-added">+                 if ((field.flags_field &amp; Flags.UNINITIALIZED_FIELD) != 0) {</span>
<span class="line-added">+                     VarSymbol param = tree.params.stream().filter(p -&gt; p.name == field.name).findFirst().get().sym;</span>
<span class="line-added">+                     make.at(tree.pos);</span>
<span class="line-added">+                     tree.body.stats = tree.body.stats.append(</span>
<span class="line-added">+                             make.Exec(</span>
<span class="line-added">+                                     make.Assign(</span>
<span class="line-added">+                                             make.Select(make.This(field.owner.erasure(types)), field),</span>
<span class="line-added">+                                             make.Ident(param)).setType(field.erasure(types))));</span>
<span class="line-added">+                     // we don&#39;t need the flag at the field anymore</span>
<span class="line-added">+                     field.flags_field &amp;= ~Flags.UNINITIALIZED_FIELD;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
          result = tree;
      }
      //where
          private Map&lt;Symbol, Symbol&gt; makeTranslationMap(JCMethodDecl tree) {
              Map&lt;Symbol, Symbol&gt; translationMap = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3224,10 ***</span>
<span class="line-new-header">--- 3429,15 ---</span>
              class Patcher extends TreeScanner {
                  public void visitBreak(JCBreak tree) {
                      if (tree.target == src)
                          tree.target = dest;
                  }
<span class="line-added">+                 public void visitYield(JCYield tree) {</span>
<span class="line-added">+                     if (tree.target == src)</span>
<span class="line-added">+                         tree.target = dest;</span>
<span class="line-added">+                     scan(tree.value);</span>
<span class="line-added">+                 }</span>
                  public void visitContinue(JCContinue tree) {
                      if (tree.target == src)
                          tree.target = dest;
                  }
                  public void visitClassDef(JCClassDecl tree) {}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3676,13 ***</span>
          }
      }
  
      @Override
      public void visitBreak(JCBreak tree) {
<span class="line-modified">!         if (tree.isValueBreak()) {</span>
<span class="line-modified">!             tree.value = translate(tree.value, tree.target.type);</span>
<span class="line-modified">!         }</span>
          result = tree;
      }
  
      public void visitNewArray(JCNewArray tree) {
          tree.elemtype = translate(tree.elemtype);
<span class="line-new-header">--- 3886,16 ---</span>
          }
      }
  
      @Override
      public void visitBreak(JCBreak tree) {
<span class="line-modified">!         result = tree;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-added">+     @Override</span>
<span class="line-added">+     public void visitYield(JCYield tree) {</span>
<span class="line-added">+         tree.value = translate(tree.value, tree.target.type);</span>
          result = tree;
      }
  
      public void visitNewArray(JCNewArray tree) {
          tree.elemtype = translate(tree.elemtype);
</pre>
<center><a href="LambdaToMethod.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemberEnter.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
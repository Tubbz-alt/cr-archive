<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.parser;
 27 
<a name="2" id="anc2"></a>

 28 import com.sun.tools.javac.code.Preview;
 29 import com.sun.tools.javac.code.Source;
 30 import com.sun.tools.javac.code.Source.Feature;
 31 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
 32 import com.sun.tools.javac.resources.CompilerProperties.Errors;
<a name="3" id="anc3"></a>
 33 import com.sun.tools.javac.util.*;
<a name="4" id="anc4"></a><span class="line-modified"> 34 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;</span>
 35 
<a name="5" id="anc5"></a>

 36 import java.nio.CharBuffer;
<a name="6" id="anc6"></a>

 37 
 38 import static com.sun.tools.javac.parser.Tokens.*;
 39 import static com.sun.tools.javac.util.LayoutCharacters.*;
 40 
 41 /** The lexical analyzer maps an input stream consisting of
 42  *  ASCII characters and Unicode escapes into a token sequence.
 43  *
 44  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 45  *  If you write code that depends on this, you do so at your own risk.
 46  *  This code and its internal interfaces are subject to change or
 47  *  deletion without notice.&lt;/b&gt;
 48  */
 49 public class JavaTokenizer {
 50 
 51     private static final boolean scannerDebug = false;
 52 
 53     /** The source language setting.
 54      */
 55     private Source source;
 56 
 57     /** The preview language setting. */
 58     private Preview preview;
 59 
 60     /** The log to be used for error reporting.
 61      */
 62     private final Log log;
 63 
 64     /** The token factory. */
 65     private final Tokens tokens;
 66 
 67     /** The token kind, set by nextToken().
 68      */
 69     protected TokenKind tk;
 70 
 71     /** The token&#39;s radix, set by nextToken().
 72      */
 73     protected int radix;
 74 
 75     /** The token&#39;s name, set by nextToken().
 76      */
 77     protected Name name;
 78 
 79     /** The position where a lexical error occurred;
 80      */
 81     protected int errPos = Position.NOPOS;
 82 
 83     /** The Unicode reader (low-level stream reader).
 84      */
 85     protected UnicodeReader reader;
 86 
<a name="7" id="anc7"></a>







 87     protected ScannerFactory fac;
 88 
<a name="8" id="anc8"></a>




 89     private static final boolean hexFloatsWork = hexFloatsWork();
 90     private static boolean hexFloatsWork() {
 91         try {
 92             Float.valueOf(&quot;0x1.0p1&quot;);
 93             return true;
 94         } catch (NumberFormatException ex) {
 95             return false;
 96         }
 97     }
 98 
 99     /**
100      * Create a scanner from the input array.  This method might
101      * modify the array.  To avoid copying the input array, ensure
102      * that {@code inputLength &lt; input.length} or
103      * {@code input[input.length -1]} is a white space character.
104      *
105      * @param fac the factory which created this Scanner
106      * @param buf the input, might be modified
107      * Must be positive and less than or equal to input.length.
108      */
109     protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {
110         this(fac, new UnicodeReader(fac, buf));
111     }
112 
113     protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {
114         this(fac, new UnicodeReader(fac, buf, inputLength));
115     }
116 
117     protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {
118         this.fac = fac;
119         this.log = fac.log;
120         this.tokens = fac.tokens;
121         this.source = fac.source;
122         this.preview = fac.preview;
123         this.reader = reader;
<a name="9" id="anc9"></a>
124     }
125 
126     protected void checkSourceLevel(int pos, Feature feature) {
127         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
128             //preview feature without --preview flag, error
129             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
130         } else if (!feature.allowedInSource(source)) {
131             //incompatible source level, error
132             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
133         } else if (preview.isPreview(feature)) {
134             //use of preview feature, warn
135             preview.warnPreview(pos, feature);
136         }
137     }
138 
139     /** Report an error at the given position using the provided arguments.
140      */
141     protected void lexError(int pos, JCDiagnostic.Error key) {
142         log.error(pos, key);
143         tk = TokenKind.ERROR;
144         errPos = pos;
145     }
146 
147     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
148         log.error(flags, pos, key);
149         tk = TokenKind.ERROR;
150         errPos = pos;
151     }
152 
<a name="10" id="anc10"></a>




153     /** Read next character in character or string literal and copy into sbuf.
<a name="11" id="anc11"></a>




154      */
<a name="12" id="anc12"></a><span class="line-modified">155     private void scanLitChar(int pos) {</span>
<span class="line-modified">156         if (reader.ch == &#39;\\&#39;) {</span>
157             if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {
158                 reader.skipChar();
<a name="13" id="anc13"></a><span class="line-modified">159                 reader.putChar(&#39;\\&#39;, true);</span>



160             } else {
<a name="14" id="anc14"></a><span class="line-modified">161                 reader.scanChar();</span>
162                 switch (reader.ch) {
163                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
164                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
165                     char leadch = reader.ch;
166                     int oct = reader.digit(pos, 8);
<a name="15" id="anc15"></a><span class="line-modified">167                     reader.scanChar();</span>
168                     if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
169                         oct = oct * 8 + reader.digit(pos, 8);
<a name="16" id="anc16"></a><span class="line-modified">170                         reader.scanChar();</span>
171                         if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
172                             oct = oct * 8 + reader.digit(pos, 8);
<a name="17" id="anc17"></a><span class="line-modified">173                             reader.scanChar();</span>
174                         }
175                     }
<a name="18" id="anc18"></a><span class="line-modified">176                     reader.putChar((char)oct);</span>


177                     break;
178                 case &#39;b&#39;:
<a name="19" id="anc19"></a><span class="line-modified">179                     reader.putChar(&#39;\b&#39;, true); break;</span>
180                 case &#39;t&#39;:
<a name="20" id="anc20"></a><span class="line-modified">181                     reader.putChar(&#39;\t&#39;, true); break;</span>
182                 case &#39;n&#39;:
<a name="21" id="anc21"></a><span class="line-modified">183                     reader.putChar(&#39;\n&#39;, true); break;</span>
184                 case &#39;f&#39;:
<a name="22" id="anc22"></a><span class="line-modified">185                     reader.putChar(&#39;\f&#39;, true); break;</span>
186                 case &#39;r&#39;:
<a name="23" id="anc23"></a><span class="line-modified">187                     reader.putChar(&#39;\r&#39;, true); break;</span>
188                 case &#39;\&#39;&#39;:
<a name="24" id="anc24"></a><span class="line-removed">189                     reader.putChar(&#39;\&#39;&#39;, true); break;</span>
190                 case &#39;\&quot;&#39;:
<a name="25" id="anc25"></a><span class="line-removed">191                     reader.putChar(&#39;\&quot;&#39;, true); break;</span>
192                 case &#39;\\&#39;:
<a name="26" id="anc26"></a><span class="line-modified">193                     reader.putChar(&#39;\\&#39;, true); break;</span>

















194                 default:
195                     lexError(reader.bp, Errors.IllegalEscChar);
196                 }
197             }
198         } else if (reader.bp != reader.buflen) {
199             reader.putChar(true);
200         }
201     }
202 
<a name="27" id="anc27"></a>





















































































































































































































































203     private void scanDigits(int pos, int digitRadix) {
204         char saveCh;
205         int savePos;
206         do {
207             if (reader.ch != &#39;_&#39;) {
208                 reader.putChar(false);
209             }
210             saveCh = reader.ch;
211             savePos = reader.bp;
212             reader.scanChar();
213         } while (reader.digit(pos, digitRadix) &gt;= 0 || reader.ch == &#39;_&#39;);
214         if (saveCh == &#39;_&#39;)
215             lexError(savePos, Errors.IllegalUnderscore);
216     }
217 
218     /** Read fractional part of hexadecimal floating point number.
219      */
220     private void scanHexExponentAndSuffix(int pos) {
221         if (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;) {
222             reader.putChar(true);
223             skipIllegalUnderscores();
224             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {
225                 reader.putChar(true);
226             }
227             skipIllegalUnderscores();
228             if (reader.digit(pos, 10) &gt;= 0) {
229                 scanDigits(pos, 10);
230                 if (!hexFloatsWork)
231                     lexError(pos, Errors.UnsupportedCrossFpLit);
232             } else
233                 lexError(pos, Errors.MalformedFpLit);
234         } else {
235             lexError(pos, Errors.MalformedFpLit);
236         }
237         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {
238             reader.putChar(true);
239             tk = TokenKind.FLOATLITERAL;
240             radix = 16;
241         } else {
242             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {
243                 reader.putChar(true);
244             }
245             tk = TokenKind.DOUBLELITERAL;
246             radix = 16;
247         }
248     }
249 
250     /** Read fractional part of floating point number.
251      */
252     private void scanFraction(int pos) {
253         skipIllegalUnderscores();
254         if (reader.digit(pos, 10) &gt;= 0) {
255             scanDigits(pos, 10);
256         }
257         int sp1 = reader.sp;
258         if (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39;) {
259             reader.putChar(true);
260             skipIllegalUnderscores();
261             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {
262                 reader.putChar(true);
263             }
264             skipIllegalUnderscores();
265             if (reader.digit(pos, 10) &gt;= 0) {
266                 scanDigits(pos, 10);
267                 return;
268             }
269             lexError(pos, Errors.MalformedFpLit);
270             reader.sp = sp1;
271         }
272     }
273 
274     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.
275      */
276     private void scanFractionAndSuffix(int pos) {
277         radix = 10;
278         scanFraction(pos);
279         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {
280             reader.putChar(true);
281             tk = TokenKind.FLOATLITERAL;
282         } else {
283             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {
284                 reader.putChar(true);
285             }
286             tk = TokenKind.DOUBLELITERAL;
287         }
288     }
289 
290     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.
291      */
292     private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
293         radix = 16;
294         Assert.check(reader.ch == &#39;.&#39;);
295         reader.putChar(true);
296         skipIllegalUnderscores();
297         if (reader.digit(pos, 16) &gt;= 0) {
298             seendigit = true;
299             scanDigits(pos, 16);
300         }
301         if (!seendigit)
302             lexError(pos, Errors.InvalidHexNumber);
303         else
304             scanHexExponentAndSuffix(pos);
305     }
306 
307     private void skipIllegalUnderscores() {
308         if (reader.ch == &#39;_&#39;) {
309             lexError(reader.bp, Errors.IllegalUnderscore);
310             while (reader.ch == &#39;_&#39;)
311                 reader.scanChar();
312         }
313     }
314 
315     /** Read a number.
316      *  @param radix  The radix of the number; one of 2, 8, 10, 16.
317      */
318     private void scanNumber(int pos, int radix) {
319         // for octal, allow base-10 digit in case it&#39;s a float literal
320         this.radix = radix;
321         int digitRadix = (radix == 8 ? 10 : radix);
322         int firstDigit = reader.digit(pos, Math.max(10, digitRadix));
323         boolean seendigit = firstDigit &gt;= 0;
324         boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;
325         if (seendigit) {
326             scanDigits(pos, digitRadix);
327         }
328         if (radix == 16 &amp;&amp; reader.ch == &#39;.&#39;) {
329             scanHexFractionAndSuffix(pos, seendigit);
330         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;)) {
331             scanHexExponentAndSuffix(pos);
332         } else if (digitRadix == 10 &amp;&amp; reader.ch == &#39;.&#39;) {
333             reader.putChar(true);
334             scanFractionAndSuffix(pos);
335         } else if (digitRadix == 10 &amp;&amp;
336                    (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39; ||
337                     reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39; ||
338                     reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;)) {
339             scanFractionAndSuffix(pos);
340         } else {
341             if (!seenValidDigit) {
342                 switch (radix) {
343                 case 2:
344                     lexError(pos, Errors.InvalidBinaryNumber);
345                     break;
346                 case 16:
347                     lexError(pos, Errors.InvalidHexNumber);
348                     break;
349                 }
350             }
351             if (reader.ch == &#39;l&#39; || reader.ch == &#39;L&#39;) {
352                 reader.scanChar();
353                 tk = TokenKind.LONGLITERAL;
354             } else {
355                 tk = TokenKind.INTLITERAL;
356             }
357         }
358     }
359 
360     /** Read an identifier.
361      */
362     private void scanIdent() {
363         boolean isJavaIdentifierPart;
364         char high;
365         reader.putChar(true);
366         do {
367             switch (reader.ch) {
368             case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
369             case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
370             case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
371             case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
372             case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
373             case &#39;Z&#39;:
374             case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
375             case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
376             case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
377             case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
378             case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
379             case &#39;z&#39;:
380             case &#39;$&#39;: case &#39;_&#39;:
381             case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
382             case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
383                 break;
384             case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
385             case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
386             case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
387             case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
388             case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
389             case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
390             case &#39;\u007F&#39;:
391                 reader.scanChar();
392                 continue;
393             case &#39;\u001A&#39;: // EOI is also a legal identifier part
394                 if (reader.bp &gt;= reader.buflen) {
395                     name = reader.name();
396                     tk = tokens.lookupKind(name);
397                     return;
398                 }
399                 reader.scanChar();
400                 continue;
401             default:
402                 if (reader.ch &lt; &#39;\u0080&#39;) {
403                     // all ASCII range chars already handled, above
404                     isJavaIdentifierPart = false;
405                 } else {
406                     if (Character.isIdentifierIgnorable(reader.ch)) {
407                         reader.scanChar();
408                         continue;
409                     } else {
410                         int codePoint = reader.peekSurrogates();
411                         if (codePoint &gt;= 0) {
412                             if (isJavaIdentifierPart = Character.isJavaIdentifierPart(codePoint)) {
413                                 reader.putChar(true);
414                             }
415                         } else {
416                             isJavaIdentifierPart = Character.isJavaIdentifierPart(reader.ch);
417                         }
418                     }
419                 }
420                 if (!isJavaIdentifierPart) {
421                     name = reader.name();
422                     tk = tokens.lookupKind(name);
423                     return;
424                 }
425             }
426             reader.putChar(true);
427         } while (true);
428     }
429 
430     /** Return true if reader.ch can be part of an operator.
431      */
432     private boolean isSpecial(char ch) {
433         switch (ch) {
434         case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
435         case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
436         case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
437         case &#39;@&#39;:
438             return true;
439         default:
440             return false;
441         }
442     }
443 
444     /** Read longest possible sequence of special characters and convert
445      *  to token.
446      */
447     private void scanOperator() {
448         while (true) {
449             reader.putChar(false);
450             Name newname = reader.name();
451             TokenKind tk1 = tokens.lookupKind(newname);
452             if (tk1 == TokenKind.IDENTIFIER) {
453                 reader.sp--;
454                 break;
455             }
456             tk = tk1;
457             reader.scanChar();
458             if (!isSpecial(reader.ch)) break;
459         }
460     }
461 
462     /** Read token.
463      */
464     public Token readToken() {
465 
466         reader.sp = 0;
467         name = null;
468         radix = 0;
469 
470         int pos = 0;
471         int endPos = 0;
472         List&lt;Comment&gt; comments = null;
473 
474         try {
475             loop: while (true) {
476                 pos = reader.bp;
477                 switch (reader.ch) {
478                 case &#39; &#39;: // (Spec 3.6)
479                 case &#39;\t&#39;: // (Spec 3.6)
480                 case FF: // (Spec 3.6)
481                     do {
482                         reader.scanChar();
483                     } while (reader.ch == &#39; &#39; || reader.ch == &#39;\t&#39; || reader.ch == FF);
484                     processWhiteSpace(pos, reader.bp);
485                     break;
486                 case LF: // (Spec 3.4)
487                     reader.scanChar();
488                     processLineTerminator(pos, reader.bp);
489                     break;
490                 case CR: // (Spec 3.4)
491                     reader.scanChar();
492                     if (reader.ch == LF) {
493                         reader.scanChar();
494                     }
495                     processLineTerminator(pos, reader.bp);
496                     break;
497                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
498                 case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
499                 case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
500                 case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
501                 case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
502                 case &#39;Z&#39;:
503                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
504                 case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
505                 case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
506                 case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
507                 case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
508                 case &#39;z&#39;:
509                 case &#39;$&#39;: case &#39;_&#39;:
510                     scanIdent();
511                     break loop;
512                 case &#39;0&#39;:
513                     reader.scanChar();
514                     if (reader.ch == &#39;x&#39; || reader.ch == &#39;X&#39;) {
515                         reader.scanChar();
516                         skipIllegalUnderscores();
517                         scanNumber(pos, 16);
518                     } else if (reader.ch == &#39;b&#39; || reader.ch == &#39;B&#39;) {
519                         reader.scanChar();
520                         skipIllegalUnderscores();
521                         scanNumber(pos, 2);
522                     } else {
523                         reader.putChar(&#39;0&#39;);
524                         if (reader.ch == &#39;_&#39;) {
525                             int savePos = reader.bp;
526                             do {
527                                 reader.scanChar();
528                             } while (reader.ch == &#39;_&#39;);
529                             if (reader.digit(pos, 10) &lt; 0) {
530                                 lexError(savePos, Errors.IllegalUnderscore);
531                             }
532                         }
533                         scanNumber(pos, 8);
534                     }
535                     break loop;
536                 case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
537                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
538                     scanNumber(pos, 10);
539                     break loop;
540                 case &#39;.&#39;:
541                     reader.scanChar();
542                     if (reader.digit(pos, 10) &gt;= 0) {
543                         reader.putChar(&#39;.&#39;);
544                         scanFractionAndSuffix(pos);
545                     } else if (reader.ch == &#39;.&#39;) {
546                         int savePos = reader.bp;
547                         reader.putChar(&#39;.&#39;); reader.putChar(&#39;.&#39;, true);
548                         if (reader.ch == &#39;.&#39;) {
549                             reader.scanChar();
550                             reader.putChar(&#39;.&#39;);
551                             tk = TokenKind.ELLIPSIS;
552                         } else {
553                             lexError(savePos, Errors.IllegalDot);
554                         }
555                     } else {
556                         tk = TokenKind.DOT;
557                     }
558                     break loop;
559                 case &#39;,&#39;:
560                     reader.scanChar(); tk = TokenKind.COMMA; break loop;
561                 case &#39;;&#39;:
562                     reader.scanChar(); tk = TokenKind.SEMI; break loop;
563                 case &#39;(&#39;:
564                     reader.scanChar(); tk = TokenKind.LPAREN; break loop;
565                 case &#39;)&#39;:
566                     reader.scanChar(); tk = TokenKind.RPAREN; break loop;
567                 case &#39;[&#39;:
568                     reader.scanChar(); tk = TokenKind.LBRACKET; break loop;
569                 case &#39;]&#39;:
570                     reader.scanChar(); tk = TokenKind.RBRACKET; break loop;
571                 case &#39;{&#39;:
572                     reader.scanChar(); tk = TokenKind.LBRACE; break loop;
573                 case &#39;}&#39;:
574                     reader.scanChar(); tk = TokenKind.RBRACE; break loop;
575                 case &#39;/&#39;:
576                     reader.scanChar();
577                     if (reader.ch == &#39;/&#39;) {
578                         do {
579                             reader.scanCommentChar();
580                         } while (reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen);
581                         if (reader.bp &lt; reader.buflen) {
582                             comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));
583                         }
584                         break;
585                     } else if (reader.ch == &#39;*&#39;) {
586                         boolean isEmpty = false;
587                         reader.scanChar();
588                         CommentStyle style;
589                         if (reader.ch == &#39;*&#39;) {
590                             style = CommentStyle.JAVADOC;
591                             reader.scanCommentChar();
592                             if (reader.ch == &#39;/&#39;) {
593                                 isEmpty = true;
594                             }
595                         } else {
596                             style = CommentStyle.BLOCK;
597                         }
598                         while (!isEmpty &amp;&amp; reader.bp &lt; reader.buflen) {
599                             if (reader.ch == &#39;*&#39;) {
600                                 reader.scanChar();
601                                 if (reader.ch == &#39;/&#39;) break;
602                             } else {
603                                 reader.scanCommentChar();
604                             }
605                         }
606                         if (reader.ch == &#39;/&#39;) {
607                             reader.scanChar();
608                             comments = addComment(comments, processComment(pos, reader.bp, style));
609                             break;
610                         } else {
611                             lexError(pos, Errors.UnclosedComment);
612                             break loop;
613                         }
614                     } else if (reader.ch == &#39;=&#39;) {
615                         tk = TokenKind.SLASHEQ;
616                         reader.scanChar();
617                     } else {
618                         tk = TokenKind.SLASH;
619                     }
620                     break loop;
621                 case &#39;\&#39;&#39;:
622                     reader.scanChar();
623                     if (reader.ch == &#39;\&#39;&#39;) {
624                         lexError(pos, Errors.EmptyCharLit);
625                         reader.scanChar();
626                     } else {
<a name="28" id="anc28"></a><span class="line-modified">627                         if (reader.ch == CR || reader.ch == LF)</span>
628                             lexError(pos, Errors.IllegalLineEndInCharLit);
<a name="29" id="anc29"></a><span class="line-modified">629                         scanLitChar(pos);</span>
630                         if (reader.ch == &#39;\&#39;&#39;) {
631                             reader.scanChar();
632                             tk = TokenKind.CHARLITERAL;
633                         } else {
634                             lexError(pos, Errors.UnclosedCharLit);
635                         }
636                     }
637                     break loop;
638                 case &#39;\&quot;&#39;:
<a name="30" id="anc30"></a><span class="line-modified">639                     reader.scanChar();</span>
<span class="line-removed">640                     while (reader.ch != &#39;\&quot;&#39; &amp;&amp; reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen)</span>
<span class="line-removed">641                         scanLitChar(pos);</span>
<span class="line-removed">642                     if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="line-removed">643                         tk = TokenKind.STRINGLITERAL;</span>
<span class="line-removed">644                         reader.scanChar();</span>
<span class="line-removed">645                     } else {</span>
<span class="line-removed">646                         lexError(pos, Errors.UnclosedStrLit);</span>
<span class="line-removed">647                     }</span>
648                     break loop;
<a name="31" id="anc31"></a><span class="line-modified">649                default:</span>
650                     if (isSpecial(reader.ch)) {
651                         scanOperator();
652                     } else {
653                         boolean isJavaIdentifierStart;
654                         int codePoint = -1;
655                         if (reader.ch &lt; &#39;\u0080&#39;) {
656                             // all ASCII range chars already handled, above
657                             isJavaIdentifierStart = false;
658                         } else {
659                             codePoint = reader.peekSurrogates();
660                             if (codePoint &gt;= 0) {
661                                 if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {
662                                     reader.putChar(true);
663                                 }
664                             } else {
665                                 isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);
666                             }
667                         }
668                         if (isJavaIdentifierStart) {
669                             scanIdent();
670                         } else if (reader.digit(pos, 10) &gt;= 0) {
671                             scanNumber(pos, 10);
672                         } else if (reader.bp == reader.buflen || reader.ch == EOI &amp;&amp; reader.bp + 1 == reader.buflen) { // JLS 3.5
673                             tk = TokenKind.EOF;
674                             pos = reader.realLength;
675                         } else {
676                             String arg;
677 
678                             if (codePoint &gt;= 0) {
679                                 char high = reader.ch;
680                                 reader.scanChar();
681                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) high, (int)reader.ch);
682                             } else {
683                                 arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ?
684                                                 String.format(&quot;%s&quot;, reader.ch) :
685                                                 String.format(&quot;\\u%04x&quot;, (int)reader.ch);
686                             }
687                             lexError(pos, Errors.IllegalChar(arg));
688                             reader.scanChar();
689                         }
690                     }
691                     break loop;
692                 }
693             }
694             endPos = reader.bp;
695             switch (tk.tag) {
696                 case DEFAULT: return new Token(tk, pos, endPos, comments);
697                 case NAMED: return new NamedToken(tk, pos, endPos, name, comments);
<a name="32" id="anc32"></a><span class="line-modified">698                 case STRING: return new StringToken(tk, pos, endPos, reader.chars(), comments);</span>



































699                 case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);
700                 default: throw new AssertionError();
701             }
702         }
703         finally {
704             if (scannerDebug) {
705                     System.out.println(&quot;nextToken(&quot; + pos
706                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
707                                        new String(reader.getRawCharacters(pos, endPos))
708                                        + &quot;|&quot;);
709             }
710         }
711     }
712     //where
713         List&lt;Comment&gt; addComment(List&lt;Comment&gt; comments, Comment comment) {
714             return comments == null ?
715                     List.of(comment) :
716                     comments.prepend(comment);
717         }
718 
719     /** Return the position where a lexical error occurred;
720      */
721     public int errPos() {
722         return errPos;
723     }
724 
725     /** Set the position where a lexical error occurred;
726      */
727     public void errPos(int pos) {
728         errPos = pos;
729     }
730 
731     /**
732      * Called when a complete comment has been scanned. pos and endPos
733      * will mark the comment boundary.
734      */
735     protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
736         if (scannerDebug)
737             System.out.println(&quot;processComment(&quot; + pos
738                                + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;
739                                + new String(reader.getRawCharacters(pos, endPos))
740                                + &quot;|&quot;);
741         char[] buf = reader.getRawCharacters(pos, endPos);
742         return new BasicComment&lt;&gt;(new UnicodeReader(fac, buf, buf.length), style);
743     }
744 
745     /**
746      * Called when a complete whitespace run has been scanned. pos and endPos
747      * will mark the whitespace boundary.
748      */
749     protected void processWhiteSpace(int pos, int endPos) {
750         if (scannerDebug)
751             System.out.println(&quot;processWhitespace(&quot; + pos
752                                + &quot;,&quot; + endPos + &quot;)=|&quot; +
753                                new String(reader.getRawCharacters(pos, endPos))
754                                + &quot;|&quot;);
755     }
756 
757     /**
758      * Called when a line terminator has been processed.
759      */
760     protected void processLineTerminator(int pos, int endPos) {
761         if (scannerDebug)
762             System.out.println(&quot;processTerminator(&quot; + pos
763                                + &quot;,&quot; + endPos + &quot;)=|&quot; +
764                                new String(reader.getRawCharacters(pos, endPos))
765                                + &quot;|&quot;);
766     }
767 
768     /** Build a map for translating between line numbers and
769      * positions in the input.
770      *
771      * @return a LineMap */
772     public Position.LineMap getLineMap() {
773         return Position.makeLineMap(reader.getRawCharacters(), reader.buflen, false);
774     }
775 
776 
777     /**
778     * Scan a documentation comment; determine if a deprecated tag is present.
779     * Called once the initial /, * have been skipped, positioned at the second *
780     * (which is treated as the beginning of the first line).
781     * Stops positioned at the closing &#39;/&#39;.
782     */
783     protected static class BasicComment&lt;U extends UnicodeReader&gt; implements Comment {
784 
785         CommentStyle cs;
786         U comment_reader;
787 
788         protected boolean deprecatedFlag = false;
789         protected boolean scanned = false;
790 
791         protected BasicComment(U comment_reader, CommentStyle cs) {
792             this.comment_reader = comment_reader;
793             this.cs = cs;
794         }
795 
796         public String getText() {
797             return null;
798         }
799 
800         public int getSourcePos(int pos) {
801             return -1;
802         }
803 
804         public CommentStyle getStyle() {
805             return cs;
806         }
807 
808         public boolean isDeprecated() {
809             if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
810                 scanDocComment();
811             }
812             return deprecatedFlag;
813         }
814 
815         @SuppressWarnings(&quot;fallthrough&quot;)
816         protected void scanDocComment() {
817             try {
818                 boolean deprecatedPrefix = false;
819 
820                 comment_reader.bp += 3; // &#39;/**&#39;
821                 comment_reader.ch = comment_reader.buf[comment_reader.bp];
822 
823                 forEachLine:
824                 while (comment_reader.bp &lt; comment_reader.buflen) {
825 
826                     // Skip optional WhiteSpace at beginning of line
827                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {
828                         comment_reader.scanCommentChar();
829                     }
830 
831                     // Skip optional consecutive Stars
832                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == &#39;*&#39;) {
833                         comment_reader.scanCommentChar();
834                         if (comment_reader.ch == &#39;/&#39;) {
835                             return;
836                         }
837                     }
838 
839                     // Skip optional WhiteSpace after Stars
840                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {
841                         comment_reader.scanCommentChar();
842                     }
843 
844                     deprecatedPrefix = false;
845                     // At beginning of line in the JavaDoc sense.
846                     if (!deprecatedFlag) {
847                         String deprecated = &quot;@deprecated&quot;;
848                         int i = 0;
849                         while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == deprecated.charAt(i)) {
850                             comment_reader.scanCommentChar();
851                             i++;
852                             if (i == deprecated.length()) {
853                                 deprecatedPrefix = true;
854                                 break;
855                             }
856                         }
857                     }
858 
859                     if (deprecatedPrefix &amp;&amp; comment_reader.bp &lt; comment_reader.buflen) {
860                         if (Character.isWhitespace(comment_reader.ch)) {
861                             deprecatedFlag = true;
862                         } else if (comment_reader.ch == &#39;*&#39;) {
863                             comment_reader.scanCommentChar();
864                             if (comment_reader.ch == &#39;/&#39;) {
865                                 deprecatedFlag = true;
866                                 return;
867                             }
868                         }
869                     }
870 
871                     // Skip rest of line
872                     while (comment_reader.bp &lt; comment_reader.buflen) {
873                         switch (comment_reader.ch) {
874                             case &#39;*&#39;:
875                                 comment_reader.scanCommentChar();
876                                 if (comment_reader.ch == &#39;/&#39;) {
877                                     return;
878                                 }
879                                 break;
880                             case CR: // (Spec 3.4)
881                                 comment_reader.scanCommentChar();
882                                 if (comment_reader.ch != LF) {
883                                     continue forEachLine;
884                                 }
885                             /* fall through to LF case */
886                             case LF: // (Spec 3.4)
887                                 comment_reader.scanCommentChar();
888                                 continue forEachLine;
889                             default:
890                                 comment_reader.scanCommentChar();
891                         }
892                     } // rest of line
893                 } // forEachLine
894                 return;
895             } finally {
896                 scanned = true;
897             }
898         }
899     }
900 }
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
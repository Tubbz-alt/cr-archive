<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacProcessingEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.processing;
  27 
  28 import java.io.Closeable;
  29 import java.io.IOException;
  30 import java.io.PrintWriter;
  31 import java.io.StringWriter;
  32 import java.lang.reflect.Method;
  33 import java.net.MalformedURLException;
  34 import java.net.URL;
  35 import java.nio.file.Path;
  36 import java.util.*;
  37 import java.util.Map.Entry;
  38 import java.util.function.Predicate;
  39 import java.util.regex.*;
  40 import java.util.stream.Collectors;
  41 
  42 import javax.annotation.processing.*;
  43 import javax.lang.model.SourceVersion;
  44 import javax.lang.model.element.*;
  45 import javax.lang.model.util.*;
  46 import javax.tools.JavaFileManager;
  47 import javax.tools.JavaFileObject;
  48 import javax.tools.JavaFileObject.Kind;
  49 import javax.tools.StandardJavaFileManager;
  50 
  51 import static javax.tools.StandardLocation.*;
  52 
  53 import com.sun.source.util.TaskEvent;
  54 import com.sun.tools.javac.api.MultiTaskListener;
  55 import com.sun.tools.javac.code.*;
  56 import com.sun.tools.javac.code.DeferredCompletionFailureHandler.Handler;
  57 import com.sun.tools.javac.code.Scope.WriteableScope;
  58 import com.sun.tools.javac.code.Source.Feature;
  59 import com.sun.tools.javac.code.Symbol.*;
  60 import com.sun.tools.javac.code.Type.ClassType;
  61 import com.sun.tools.javac.code.Types;
  62 import com.sun.tools.javac.comp.AttrContext;
  63 import com.sun.tools.javac.comp.Check;
  64 import com.sun.tools.javac.comp.Enter;
  65 import com.sun.tools.javac.comp.Env;
  66 import com.sun.tools.javac.comp.Modules;
  67 import com.sun.tools.javac.file.JavacFileManager;
  68 import com.sun.tools.javac.main.JavaCompiler;
  69 import com.sun.tools.javac.main.Option;
  70 import com.sun.tools.javac.model.JavacElements;
  71 import com.sun.tools.javac.model.JavacTypes;
  72 import com.sun.tools.javac.platform.PlatformDescription;
  73 import com.sun.tools.javac.platform.PlatformDescription.PluginInfo;
  74 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  75 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  76 import com.sun.tools.javac.tree.*;
  77 import com.sun.tools.javac.tree.JCTree.*;
  78 import com.sun.tools.javac.util.Abort;
  79 import com.sun.tools.javac.util.Assert;
  80 import com.sun.tools.javac.util.ClientCodeException;
  81 import com.sun.tools.javac.util.Context;
  82 import com.sun.tools.javac.util.Convert;
  83 import com.sun.tools.javac.util.DefinedBy;
  84 import com.sun.tools.javac.util.DefinedBy.Api;
  85 import com.sun.tools.javac.util.Iterators;
  86 import com.sun.tools.javac.util.JCDiagnostic;
  87 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  88 import com.sun.tools.javac.util.JavacMessages;
  89 import com.sun.tools.javac.util.List;
  90 import com.sun.tools.javac.util.Log;
  91 import com.sun.tools.javac.util.MatchingUtils;
  92 import com.sun.tools.javac.util.ModuleHelper;
  93 import com.sun.tools.javac.util.Name;
  94 import com.sun.tools.javac.util.Names;
  95 import com.sun.tools.javac.util.Options;
  96 
  97 import static com.sun.tools.javac.code.Lint.LintCategory.PROCESSING;
  98 import static com.sun.tools.javac.code.Kinds.Kind.*;
  99 import com.sun.tools.javac.comp.Annotate;
 100 import static com.sun.tools.javac.comp.CompileStates.CompileState;
 101 import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;
 102 
 103 /**
 104  * Objects of this class hold and manage the state needed to support
 105  * annotation processing.
 106  *
 107  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 108  * If you write code that depends on this, you do so at your own risk.
 109  * This code and its internal interfaces are subject to change or
 110  * deletion without notice.&lt;/b&gt;
 111  */
 112 public class JavacProcessingEnvironment implements ProcessingEnvironment, Closeable {
 113     private final Options options;
 114 
 115     private final boolean printProcessorInfo;
 116     private final boolean printRounds;
 117     private final boolean verbose;
 118     private final boolean lint;
 119     private final boolean fatalErrors;
 120     private final boolean werror;
 121     private final boolean showResolveErrors;
 122 
 123     private final JavacFiler filer;
 124     private final JavacMessager messager;
 125     private final JavacElements elementUtils;
 126     private final JavacTypes typeUtils;
 127     private final JavaCompiler compiler;
 128     private final Modules modules;
 129     private final Types types;
 130     private final Annotate annotate;
 131 
 132     /**
 133      * Holds relevant state history of which processors have been
 134      * used.
 135      */
 136     private DiscoveredProcessors discoveredProcs;
 137 
 138     /**
 139      * Map of processor-specific options.
 140      */
 141     private final Map&lt;String, String&gt; processorOptions;
 142 
 143     /**
 144      */
 145     private final Set&lt;String&gt; unmatchedProcessorOptions;
 146 
 147     /**
 148      * Annotations implicitly processed and claimed by javac.
 149      */
 150     private final Set&lt;String&gt; platformAnnotations;
 151 
 152     /**
 153      * Set of packages given on command line.
 154      */
 155     private Set&lt;PackageSymbol&gt; specifiedPackages = Collections.emptySet();
 156 
 157     /** The log to be used for error reporting.
 158      */
 159     final Log log;
 160 
 161     /** Diagnostic factory.
 162      */
 163     JCDiagnostic.Factory diags;
 164 
 165     /**
 166      * Source level of the compile.
 167      */
 168     Source source;
 169 
 170     private ClassLoader processorClassLoader;
 171     private ServiceLoader&lt;Processor&gt; serviceLoader;
 172     private SecurityException processorLoaderException;
 173 
 174     private final JavaFileManager fileManager;
 175 
 176     /**
 177      * JavacMessages object used for localization
 178      */
 179     private JavacMessages messages;
 180 
 181     private MultiTaskListener taskListener;
 182     private final Symtab symtab;
 183     private final DeferredCompletionFailureHandler dcfh;
 184     private final Names names;
 185     private final Enter enter;
 186     private final Completer initialCompleter;
 187     private final Check chk;
 188 
 189     private final Context context;
 190 
 191     /**
 192      * Support for preview language features.
 193      */
 194     private final Preview preview;
 195 
 196     /** Get the JavacProcessingEnvironment instance for this context. */
 197     public static JavacProcessingEnvironment instance(Context context) {
 198         JavacProcessingEnvironment instance = context.get(JavacProcessingEnvironment.class);
 199         if (instance == null)
 200             instance = new JavacProcessingEnvironment(context);
 201         return instance;
 202     }
 203 
 204     protected JavacProcessingEnvironment(Context context) {
 205         this.context = context;
 206         context.put(JavacProcessingEnvironment.class, this);
 207         log = Log.instance(context);
 208         source = Source.instance(context);
 209         diags = JCDiagnostic.Factory.instance(context);
 210         options = Options.instance(context);
 211         printProcessorInfo = options.isSet(Option.XPRINTPROCESSORINFO);
 212         printRounds = options.isSet(Option.XPRINTROUNDS);
 213         verbose = options.isSet(Option.VERBOSE);
 214         lint = Lint.instance(context).isEnabled(PROCESSING);
 215         compiler = JavaCompiler.instance(context);
 216         if (options.isSet(Option.PROC, &quot;only&quot;) || options.isSet(Option.XPRINT)) {
 217             compiler.shouldStopPolicyIfNoError = CompileState.PROCESS;
 218         }
 219         fatalErrors = options.isSet(&quot;fatalEnterError&quot;);
 220         showResolveErrors = options.isSet(&quot;showResolveErrors&quot;);
 221         werror = options.isSet(Option.WERROR);
 222         fileManager = context.get(JavaFileManager.class);
 223         platformAnnotations = initPlatformAnnotations();
 224 
 225         // Initialize services before any processors are initialized
 226         // in case processors use them.
 227         filer = new JavacFiler(context);
 228         messager = new JavacMessager(context, this);
 229         elementUtils = JavacElements.instance(context);
 230         typeUtils = JavacTypes.instance(context);
 231         modules = Modules.instance(context);
 232         types = Types.instance(context);
 233         annotate = Annotate.instance(context);
 234         processorOptions = initProcessorOptions();
 235         unmatchedProcessorOptions = initUnmatchedProcessorOptions();
 236         messages = JavacMessages.instance(context);
 237         taskListener = MultiTaskListener.instance(context);
 238         symtab = Symtab.instance(context);
 239         dcfh = DeferredCompletionFailureHandler.instance(context);
 240         names = Names.instance(context);
 241         enter = Enter.instance(context);
 242         initialCompleter = ClassFinder.instance(context).getCompleter();
 243         chk = Check.instance(context);
 244         preview = Preview.instance(context);
 245         initProcessorLoader();
 246     }
 247 
 248     public void setProcessors(Iterable&lt;? extends Processor&gt; processors) {
 249         Assert.checkNull(discoveredProcs);
 250         initProcessorIterator(processors);
 251     }
 252 
 253     private Set&lt;String&gt; initPlatformAnnotations() {
 254         final String module_prefix =
 255             Feature.MODULES.allowedInSource(source) ? &quot;java.base/&quot; : &quot;&quot;;
 256         return Set.of(module_prefix + &quot;java.lang.Deprecated&quot;,
 257                       module_prefix + &quot;java.lang.FunctionalInterface&quot;,
 258                       module_prefix + &quot;java.lang.Override&quot;,
 259                       module_prefix + &quot;java.lang.SafeVarargs&quot;,
 260                       module_prefix + &quot;java.lang.SuppressWarnings&quot;,
 261 
 262                       module_prefix + &quot;java.lang.annotation.Documented&quot;,
 263                       module_prefix + &quot;java.lang.annotation.Inherited&quot;,
 264                       module_prefix + &quot;java.lang.annotation.Native&quot;,
 265                       module_prefix + &quot;java.lang.annotation.Repeatable&quot;,
 266                       module_prefix + &quot;java.lang.annotation.Retention&quot;,
 267                       module_prefix + &quot;java.lang.annotation.Target&quot;,
 268 
 269                       module_prefix + &quot;java.io.Serial&quot;);
 270     }
 271 
 272     private void initProcessorLoader() {
 273         try {
 274             if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {
 275                 try {
 276                     serviceLoader = fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, Processor.class);
 277                 } catch (IOException e) {
 278                     throw new Abort(e);
 279                 }
 280             } else {
 281                 // If processorpath is not explicitly set, use the classpath.
 282                 processorClassLoader = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)
 283                     ? fileManager.getClassLoader(ANNOTATION_PROCESSOR_PATH)
 284                     : fileManager.getClassLoader(CLASS_PATH);
 285 
 286                 if (options.isSet(&quot;accessInternalAPI&quot;))
 287                     ModuleHelper.addExports(getClass().getModule(), processorClassLoader.getUnnamedModule());
 288 
 289                 if (processorClassLoader != null &amp;&amp; processorClassLoader instanceof Closeable) {
 290                     compiler.closeables = compiler.closeables.prepend((Closeable) processorClassLoader);
 291                 }
 292             }
 293         } catch (SecurityException e) {
 294             processorLoaderException = e;
 295         }
 296     }
 297 
 298     private void initProcessorIterator(Iterable&lt;? extends Processor&gt; processors) {
 299         Iterator&lt;? extends Processor&gt; processorIterator;
 300 
 301         if (options.isSet(Option.XPRINT)) {
 302             try {
 303                 processorIterator = List.of(new PrintingProcessor()).iterator();
 304             } catch (Throwable t) {
 305                 AssertionError assertError =
 306                     new AssertionError(&quot;Problem instantiating PrintingProcessor.&quot;);
 307                 assertError.initCause(t);
 308                 throw assertError;
 309             }
 310         } else if (processors != null) {
 311             processorIterator = processors.iterator();
 312         } else {
 313             if (processorLoaderException == null) {
 314                 /*
 315                  * If the &quot;-processor&quot; option is used, search the appropriate
 316                  * path for the named class.  Otherwise, use a service
 317                  * provider mechanism to create the processor iterator.
 318                  */
 319                 String processorNames = options.get(Option.PROCESSOR);
 320                 if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {
 321                     processorIterator = (processorNames == null) ?
 322                             new ServiceIterator(serviceLoader, log) :
 323                             new NameServiceIterator(serviceLoader, log, processorNames);
 324                 } else if (processorNames != null) {
 325                     processorIterator = new NameProcessIterator(processorNames, processorClassLoader, log);
 326                 } else {
 327                     processorIterator = new ServiceIterator(processorClassLoader, log);
 328                 }
 329             } else {
 330                 /*
 331                  * A security exception will occur if we can&#39;t create a classloader.
 332                  * Ignore the exception if, with hindsight, we didn&#39;t need it anyway
 333                  * (i.e. no processor was specified either explicitly, or implicitly,
 334                  * in service configuration file.) Otherwise, we cannot continue.
 335                  */
 336                 processorIterator = handleServiceLoaderUnavailability(&quot;proc.cant.create.loader&quot;,
 337                         processorLoaderException);
 338             }
 339         }
 340         PlatformDescription platformProvider = context.get(PlatformDescription.class);
 341         java.util.List&lt;Processor&gt; platformProcessors = Collections.emptyList();
 342         if (platformProvider != null) {
 343             platformProcessors = platformProvider.getAnnotationProcessors()
 344                                                  .stream()
 345                                                  .map(PluginInfo::getPlugin)
 346                                                  .collect(Collectors.toList());
 347         }
 348         List&lt;Iterator&lt;? extends Processor&gt;&gt; iterators = List.of(processorIterator,
 349                                                                 platformProcessors.iterator());
 350         Iterator&lt;? extends Processor&gt; compoundIterator =
 351                 Iterators.createCompoundIterator(iterators, i -&gt; i);
 352         discoveredProcs = new DiscoveredProcessors(compoundIterator);
 353     }
 354 
 355     public &lt;S&gt; ServiceLoader&lt;S&gt; getServiceLoader(Class&lt;S&gt; service) {
 356         if (fileManager.hasLocation(ANNOTATION_PROCESSOR_MODULE_PATH)) {
 357             try {
 358                 return fileManager.getServiceLoader(ANNOTATION_PROCESSOR_MODULE_PATH, service);
 359             } catch (IOException e) {
 360                 throw new Abort(e);
 361             }
 362         } else {
 363             return ServiceLoader.load(service, getProcessorClassLoader());
 364         }
 365     }
 366 
 367     /**
 368      * Returns an empty processor iterator if no processors are on the
 369      * relevant path, otherwise if processors are present, logs an
 370      * error.  Called when a service loader is unavailable for some
 371      * reason, either because a service loader class cannot be found
 372      * or because a security policy prevents class loaders from being
 373      * created.
 374      *
 375      * @param key The resource key to use to log an error message
 376      * @param e   If non-null, pass this exception to Abort
 377      */
 378     private Iterator&lt;Processor&gt; handleServiceLoaderUnavailability(String key, Exception e) {
 379         if (fileManager instanceof JavacFileManager) {
 380             StandardJavaFileManager standardFileManager = (JavacFileManager) fileManager;
 381             Iterable&lt;? extends Path&gt; workingPath = fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH)
 382                 ? standardFileManager.getLocationAsPaths(ANNOTATION_PROCESSOR_PATH)
 383                 : standardFileManager.getLocationAsPaths(CLASS_PATH);
 384 
 385             if (needClassLoader(options.get(Option.PROCESSOR), workingPath) )
 386                 handleException(key, e);
 387 
 388         } else {
 389             handleException(key, e);
 390         }
 391 
 392         java.util.List&lt;Processor&gt; pl = Collections.emptyList();
 393         return pl.iterator();
 394     }
 395 
 396     /**
 397      * Handle a security exception thrown during initializing the
 398      * Processor iterator.
 399      */
 400     private void handleException(String key, Exception e) {
 401         if (e != null) {
 402             log.error(key, e.getLocalizedMessage());
 403             throw new Abort(e);
 404         } else {
 405             log.error(key);
 406             throw new Abort();
 407         }
 408     }
 409 
 410     /**
 411      * Use a service loader appropriate for the platform to provide an
 412      * iterator over annotations processors; fails if a loader is
 413      * needed but unavailable.
 414      */
 415     private class ServiceIterator implements Iterator&lt;Processor&gt; {
 416         Iterator&lt;Processor&gt; iterator;
 417         Log log;
 418         ServiceLoader&lt;Processor&gt; loader;
 419 
 420         ServiceIterator(ClassLoader classLoader, Log log) {
 421             this.log = log;
 422             try {
 423                 try {
 424                     loader = ServiceLoader.load(Processor.class, classLoader);
 425                     this.iterator = loader.iterator();
 426                 } catch (Exception e) {
 427                     // Fail softly if a loader is not actually needed.
 428                     this.iterator = handleServiceLoaderUnavailability(&quot;proc.no.service&quot;, null);
 429                 }
 430             } catch (Throwable t) {
 431                 log.error(Errors.ProcServiceProblem);
 432                 throw new Abort(t);
 433             }
 434         }
 435 
 436         ServiceIterator(ServiceLoader&lt;Processor&gt; loader, Log log) {
 437             this.log = log;
 438             this.loader = loader;
 439             this.iterator = loader.iterator();
 440         }
 441 
 442         @Override
 443         public boolean hasNext() {
 444             try {
 445                 return internalHasNext();
 446             } catch(ServiceConfigurationError sce) {
 447                 log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
 448                 throw new Abort(sce);
 449             } catch (UnsupportedClassVersionError ucve) {
 450                 log.error(Errors.ProcCantLoadClass(ucve.getLocalizedMessage()));
 451                 throw new Abort(ucve);
 452             } catch (ClassFormatError cfe) {
 453                 log.error(Errors.ProcCantLoadClass(cfe.getLocalizedMessage()));
 454                 throw new Abort(cfe);
 455             } catch (Throwable t) {
 456                 log.error(Errors.ProcBadConfigFile(t.getLocalizedMessage()));
 457                 throw new Abort(t);
 458             }
 459         }
 460 
 461         boolean internalHasNext() {
 462             return iterator.hasNext();
 463         }
 464 
 465         @Override
 466         public Processor next() {
 467             try {
 468                 return internalNext();
 469             } catch (ServiceConfigurationError sce) {
 470                 log.error(Errors.ProcBadConfigFile(sce.getLocalizedMessage()));
 471                 throw new Abort(sce);
 472             } catch (Throwable t) {
 473                 log.error(Errors.ProcBadConfigFile(t.getLocalizedMessage()));
 474                 throw new Abort(t);
 475             }
 476         }
 477 
 478         Processor internalNext() {
 479             return iterator.next();
 480         }
 481 
 482         @Override
 483         public void remove() {
 484             throw new UnsupportedOperationException();
 485         }
 486 
 487         public void close() {
 488             if (loader != null) {
 489                 try {
 490                     loader.reload();
 491                 } catch(Exception e) {
 492                     // Ignore problems during a call to reload.
 493                 }
 494             }
 495         }
 496     }
 497 
 498     private class NameServiceIterator extends ServiceIterator {
 499         private Map&lt;String, Processor&gt; namedProcessorsMap = new HashMap&lt;&gt;();;
 500         private Iterator&lt;String&gt; processorNames = null;
 501         private Processor nextProc = null;
 502 
 503         public NameServiceIterator(ServiceLoader&lt;Processor&gt; loader, Log log, String theNames) {
 504             super(loader, log);
 505             this.processorNames = Arrays.asList(theNames.split(&quot;,&quot;)).iterator();
 506         }
 507 
 508         @Override
 509         boolean internalHasNext() {
 510             if (nextProc != null) {
 511                 return true;
 512             }
 513             if (!processorNames.hasNext()) {
 514                 namedProcessorsMap = null;
 515                 return false;
 516             }
 517             String processorName = processorNames.next();
 518             Processor theProcessor = namedProcessorsMap.get(processorName);
 519             if (theProcessor != null) {
 520                 namedProcessorsMap.remove(processorName);
 521                 nextProc = theProcessor;
 522                 return true;
 523             } else {
 524                 while (iterator.hasNext()) {
 525                     theProcessor = iterator.next();
 526                     String name = theProcessor.getClass().getName();
 527                     if (name.equals(processorName)) {
 528                         nextProc = theProcessor;
 529                         return true;
 530                     } else {
 531                         namedProcessorsMap.put(name, theProcessor);
 532                     }
 533                 }
 534                 log.error(Errors.ProcProcessorNotFound(processorName));
 535                 return false;
 536             }
 537         }
 538 
 539         @Override
 540         Processor internalNext() {
 541             if (hasNext()) {
 542                 Processor p = nextProc;
 543                 nextProc = null;
 544                 return p;
 545             } else {
 546                 throw new NoSuchElementException();
 547             }
 548         }
 549     }
 550 
 551     private static class NameProcessIterator implements Iterator&lt;Processor&gt; {
 552         Processor nextProc = null;
 553         Iterator&lt;String&gt; names;
 554         ClassLoader processorCL;
 555         Log log;
 556 
 557         NameProcessIterator(String names, ClassLoader processorCL, Log log) {
 558             this.names = Arrays.asList(names.split(&quot;,&quot;)).iterator();
 559             this.processorCL = processorCL;
 560             this.log = log;
 561         }
 562 
 563         public boolean hasNext() {
 564             if (nextProc != null)
 565                 return true;
 566             else {
 567                 if (!names.hasNext()) {
 568                     return false;
 569                 } else {
 570                     Processor processor = getNextProcessor(names.next());
 571                     if (processor == null) {
 572                         return false;
 573                     } else {
 574                         nextProc = processor;
 575                         return true;
 576                     }
 577                 }
 578             }
 579         }
 580 
 581         private Processor getNextProcessor(String processorName) {
 582             try {
 583                 try {
 584                     Class&lt;?&gt; processorClass = processorCL.loadClass(processorName);
 585                     ensureReadable(processorClass);
 586                     return (Processor) processorClass.getConstructor().newInstance();
 587                 } catch (ClassNotFoundException cnfe) {
 588                     log.error(Errors.ProcProcessorNotFound(processorName));
 589                     return null;
 590                 } catch (ClassCastException cce) {
 591                     log.error(Errors.ProcProcessorWrongType(processorName));
 592                     return null;
 593                 } catch (Exception e ) {
 594                     log.error(Errors.ProcProcessorCantInstantiate(processorName));
 595                     return null;
 596                 }
 597             } catch (ClientCodeException e) {
 598                 throw e;
 599             } catch (Throwable t) {
 600                 throw new AnnotationProcessingError(t);
 601             }
 602         }
 603 
 604         public Processor next() {
 605             if (hasNext()) {
 606                 Processor p = nextProc;
 607                 nextProc = null;
 608                 return p;
 609             } else
 610                 throw new NoSuchElementException();
 611         }
 612 
 613         public void remove () {
 614             throw new UnsupportedOperationException();
 615         }
 616 
 617         /**
 618          * Ensures that the module of the given class is readable to this
 619          * module.
 620          */
 621         private void ensureReadable(Class&lt;?&gt; targetClass) {
 622             try {
 623                 Method getModuleMethod = Class.class.getMethod(&quot;getModule&quot;);
 624                 Object thisModule = getModuleMethod.invoke(this.getClass());
 625                 Object targetModule = getModuleMethod.invoke(targetClass);
 626 
 627                 Class&lt;?&gt; moduleClass = getModuleMethod.getReturnType();
 628                 Method addReadsMethod = moduleClass.getMethod(&quot;addReads&quot;, moduleClass);
 629                 addReadsMethod.invoke(thisModule, targetModule);
 630             } catch (NoSuchMethodException e) {
 631                 // ignore
 632             } catch (Exception e) {
 633                 throw new InternalError(e);
 634             }
 635         }
 636     }
 637 
 638     public boolean atLeastOneProcessor() {
 639         return discoveredProcs.iterator().hasNext();
 640     }
 641 
 642     private Map&lt;String, String&gt; initProcessorOptions() {
 643         Set&lt;String&gt; keySet = options.keySet();
 644         Map&lt;String, String&gt; tempOptions = new LinkedHashMap&lt;&gt;();
 645 
 646         for(String key : keySet) {
 647             if (key.startsWith(&quot;-A&quot;) &amp;&amp; key.length() &gt; 2) {
 648                 int sepIndex = key.indexOf(&#39;=&#39;);
 649                 String candidateKey = null;
 650                 String candidateValue = null;
 651 
 652                 if (sepIndex == -1)
 653                     candidateKey = key.substring(2);
 654                 else if (sepIndex &gt;= 3) {
 655                     candidateKey = key.substring(2, sepIndex);
 656                     candidateValue = (sepIndex &lt; key.length()-1)?
 657                         key.substring(sepIndex+1) : null;
 658                 }
 659                 tempOptions.put(candidateKey, candidateValue);
 660             }
 661         }
 662 
 663         PlatformDescription platformProvider = context.get(PlatformDescription.class);
 664 
 665         if (platformProvider != null) {
 666             for (PluginInfo&lt;Processor&gt; ap : platformProvider.getAnnotationProcessors()) {
 667                 tempOptions.putAll(ap.getOptions());
 668             }
 669         }
 670 
 671         return Collections.unmodifiableMap(tempOptions);
 672     }
 673 
 674     private Set&lt;String&gt; initUnmatchedProcessorOptions() {
 675         Set&lt;String&gt; unmatchedProcessorOptions = new HashSet&lt;&gt;();
 676         unmatchedProcessorOptions.addAll(processorOptions.keySet());
 677         return unmatchedProcessorOptions;
 678     }
 679 
 680     /**
 681      * State about how a processor has been used by the tool.  If a
 682      * processor has been used on a prior round, its process method is
 683      * called on all subsequent rounds, perhaps with an empty set of
 684      * annotations to process.  The {@code annotationSupported} method
 685      * caches the supported annotation information from the first (and
 686      * only) getSupportedAnnotationTypes call to the processor.
 687      */
 688     static class ProcessorState {
 689         public Processor processor;
 690         public boolean   contributed;
 691         private Set&lt;String&gt; supportedAnnotationStrings; // Used for warning generation
 692         private Set&lt;Pattern&gt; supportedAnnotationPatterns;
 693         private Set&lt;String&gt; supportedOptionNames;
 694 
 695         ProcessorState(Processor p, Log log, Source source, DeferredCompletionFailureHandler dcfh,
 696                        boolean allowModules, ProcessingEnvironment env, boolean lint) {
 697             processor = p;
 698             contributed = false;
 699 
 700             Handler prevDeferredHandler = dcfh.setHandler(dcfh.userCodeHandler);
 701             try {
 702                 processor.init(env);
 703 
 704                 checkSourceVersionCompatibility(source, log);
 705 
 706 
 707                 // Check for direct duplicates in the strings of
 708                 // supported annotation types. Do not check for
 709                 // duplicates that would result after stripping of
 710                 // module prefixes.
 711                 supportedAnnotationStrings = new LinkedHashSet&lt;&gt;();
 712                 supportedAnnotationPatterns = new LinkedHashSet&lt;&gt;();
 713                 for (String annotationPattern : processor.getSupportedAnnotationTypes()) {
 714                     boolean patternAdded = supportedAnnotationStrings.add(annotationPattern);
 715 
 716                     supportedAnnotationPatterns.
 717                         add(importStringToPattern(allowModules, annotationPattern,
 718                                                   processor, log, lint));
 719                     if (lint &amp;&amp; !patternAdded) {
 720                         log.warning(Warnings.ProcDuplicateSupportedAnnotation(annotationPattern,
 721                                                                               p.getClass().getName()));
 722                     }
 723                 }
 724 
 725                 // If a processor supports &quot;*&quot;, that matches
 726                 // everything and other entries are redundant. With
 727                 // more work, it could be checked that the supported
 728                 // annotation types were otherwise non-overlapping
 729                 // with each other in other cases, for example &quot;foo.*&quot;
 730                 // and &quot;foo.bar.*&quot;.
 731                 if (lint &amp;&amp;
 732                     supportedAnnotationPatterns.contains(MatchingUtils.validImportStringToPattern(&quot;*&quot;)) &amp;&amp;
 733                     supportedAnnotationPatterns.size() &gt; 1) {
 734                     log.warning(Warnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));
 735                 }
 736 
 737                 supportedOptionNames = new LinkedHashSet&lt;&gt;();
 738                 for (String optionName : processor.getSupportedOptions() ) {
 739                     if (checkOptionName(optionName, log)) {
 740                         boolean optionAdded = supportedOptionNames.add(optionName);
 741                         if (lint &amp;&amp; !optionAdded) {
 742                             log.warning(Warnings.ProcDuplicateOptionName(optionName,
 743                                                                          p.getClass().getName()));
 744                         }
 745                     }
 746                 }
 747 
 748             } catch (ClientCodeException e) {
 749                 throw e;
 750             } catch (Throwable t) {
 751                 throw new AnnotationProcessingError(t);
 752             } finally {
 753                 dcfh.setHandler(prevDeferredHandler);
 754             }
 755         }
 756 
 757         /**
 758          * Checks whether or not a processor&#39;s source version is
 759          * compatible with the compilation source version.  The
 760          * processor&#39;s source version needs to be greater than or
 761          * equal to the source version of the compile.
 762          */
 763         private void checkSourceVersionCompatibility(Source source, Log log) {
 764             SourceVersion procSourceVersion = processor.getSupportedSourceVersion();
 765             if (procSourceVersion.compareTo(Source.toSourceVersion(source)) &lt; 0 )  {
 766                 log.warning(Warnings.ProcProcessorIncompatibleSourceVersion(procSourceVersion,
 767                                                                             processor.getClass().getName(),
 768                                                                             source.name));
 769             }
 770         }
 771 
 772         private boolean checkOptionName(String optionName, Log log) {
 773             boolean valid = isValidOptionName(optionName);
 774             if (!valid)
 775                 log.error(Errors.ProcProcessorBadOptionName(optionName,
 776                                                             processor.getClass().getName()));
 777             return valid;
 778         }
 779 
 780         public boolean annotationSupported(String annotationName) {
 781             for(Pattern p: supportedAnnotationPatterns) {
 782                 if (p.matcher(annotationName).matches())
 783                     return true;
 784             }
 785             return false;
 786         }
 787 
 788         /**
 789          * Remove options that are matched by this processor.
 790          */
 791         public void removeSupportedOptions(Set&lt;String&gt; unmatchedProcessorOptions) {
 792             unmatchedProcessorOptions.removeAll(supportedOptionNames);
 793         }
 794     }
 795 
 796     // TODO: These two classes can probably be rewritten better...
 797     /**
 798      * This class holds information about the processors that have
 799      * been discovered so far as well as the means to discover more, if
 800      * necessary.  A single iterator should be used per round of
 801      * annotation processing.  The iterator first visits already
 802      * discovered processors then fails over to the service provider
 803      * mechanism if additional queries are made.
 804      */
 805     class DiscoveredProcessors implements Iterable&lt;ProcessorState&gt; {
 806 
 807         class ProcessorStateIterator implements Iterator&lt;ProcessorState&gt; {
 808             DiscoveredProcessors psi;
 809             Iterator&lt;ProcessorState&gt; innerIter;
 810             boolean onProcIterator;
 811 
 812             ProcessorStateIterator(DiscoveredProcessors psi) {
 813                 this.psi = psi;
 814                 this.innerIter = psi.procStateList.iterator();
 815                 this.onProcIterator = false;
 816             }
 817 
 818             public ProcessorState next() {
 819                 if (!onProcIterator) {
 820                     if (innerIter.hasNext())
 821                         return innerIter.next();
 822                     else
 823                         onProcIterator = true;
 824                 }
 825 
 826                 if (psi.processorIterator.hasNext()) {
 827                     ProcessorState ps = new ProcessorState(psi.processorIterator.next(),
 828                                                            log, source, dcfh,
 829                                                            Feature.MODULES.allowedInSource(source),
 830                                                            JavacProcessingEnvironment.this,
 831                                                            lint);
 832                     psi.procStateList.add(ps);
 833                     return ps;
 834                 } else
 835                     throw new NoSuchElementException();
 836             }
 837 
 838             public boolean hasNext() {
 839                 if (onProcIterator)
 840                     return  psi.processorIterator.hasNext();
 841                 else
 842                     return innerIter.hasNext() || psi.processorIterator.hasNext();
 843             }
 844 
 845             public void remove () {
 846                 throw new UnsupportedOperationException();
 847             }
 848 
 849             /**
 850              * Run all remaining processors on the procStateList that
 851              * have not already run this round with an empty set of
 852              * annotations.
 853              */
 854             public void runContributingProcs(RoundEnvironment re) {
 855                 if (!onProcIterator) {
 856                     Set&lt;TypeElement&gt; emptyTypeElements = Collections.emptySet();
 857                     while(innerIter.hasNext()) {
 858                         ProcessorState ps = innerIter.next();
 859                         if (ps.contributed)
 860                             callProcessor(ps.processor, emptyTypeElements, re);
 861                     }
 862                 }
 863             }
 864         }
 865 
 866         Iterator&lt;? extends Processor&gt; processorIterator;
 867         ArrayList&lt;ProcessorState&gt;  procStateList;
 868 
 869         public ProcessorStateIterator iterator() {
 870             return new ProcessorStateIterator(this);
 871         }
 872 
 873         DiscoveredProcessors(Iterator&lt;? extends Processor&gt; processorIterator) {
 874             this.processorIterator = processorIterator;
 875             this.procStateList = new ArrayList&lt;&gt;();
 876         }
 877 
 878         /**
 879          * Free jar files, etc. if using a service loader.
 880          */
 881         public void close() {
 882             if (processorIterator != null &amp;&amp;
 883                 processorIterator instanceof ServiceIterator) {
 884                 ((ServiceIterator) processorIterator).close();
 885             }
 886         }
 887     }
 888 
 889     private void discoverAndRunProcs(Set&lt;TypeElement&gt; annotationsPresent,
 890                                      List&lt;ClassSymbol&gt; topLevelClasses,
 891                                      List&lt;PackageSymbol&gt; packageInfoFiles,
 892                                      List&lt;ModuleSymbol&gt; moduleInfoFiles) {
 893         Map&lt;String, TypeElement&gt; unmatchedAnnotations = new HashMap&lt;&gt;(annotationsPresent.size());
 894 
 895         for(TypeElement a  : annotationsPresent) {
 896             ModuleElement mod = elementUtils.getModuleOf(a);
 897             String moduleSpec = Feature.MODULES.allowedInSource(source) &amp;&amp; mod != null ? mod.getQualifiedName() + &quot;/&quot; : &quot;&quot;;
 898             unmatchedAnnotations.put(moduleSpec + a.getQualifiedName().toString(),
 899                                      a);
 900         }
 901 
 902         // Give &quot;*&quot; processors a chance to match
 903         if (unmatchedAnnotations.size() == 0)
 904             unmatchedAnnotations.put(&quot;&quot;, null);
 905 
 906         DiscoveredProcessors.ProcessorStateIterator psi = discoveredProcs.iterator();
 907         // TODO: Create proper argument values; need past round
 908         // information to fill in this constructor.  Note that the 1
 909         // st round of processing could be the last round if there
 910         // were parse errors on the initial source files; however, we
 911         // are not doing processing in that case.
 912 
 913         Set&lt;Element&gt; rootElements = new LinkedHashSet&lt;&gt;();
 914         rootElements.addAll(topLevelClasses);
 915         rootElements.addAll(packageInfoFiles);
 916         rootElements.addAll(moduleInfoFiles);
 917         rootElements = Collections.unmodifiableSet(rootElements);
 918 
 919         RoundEnvironment renv = new JavacRoundEnvironment(false,
 920                                                           false,
 921                                                           rootElements,
 922                                                           JavacProcessingEnvironment.this);
 923 
 924         while(unmatchedAnnotations.size() &gt; 0 &amp;&amp; psi.hasNext() ) {
 925             ProcessorState ps = psi.next();
 926             Set&lt;String&gt;  matchedNames = new HashSet&lt;&gt;();
 927             Set&lt;TypeElement&gt; typeElements = new LinkedHashSet&lt;&gt;();
 928 
 929             for (Map.Entry&lt;String, TypeElement&gt; entry: unmatchedAnnotations.entrySet()) {
 930                 String unmatchedAnnotationName = entry.getKey();
 931                 if (ps.annotationSupported(unmatchedAnnotationName) ) {
 932                     matchedNames.add(unmatchedAnnotationName);
 933                     TypeElement te = entry.getValue();
 934                     if (te != null)
 935                         typeElements.add(te);
 936                 }
 937             }
 938 
 939             if (matchedNames.size() &gt; 0 || ps.contributed) {
 940                 boolean processingResult = callProcessor(ps.processor, typeElements, renv);
 941                 ps.contributed = true;
 942                 ps.removeSupportedOptions(unmatchedProcessorOptions);
 943 
 944                 if (printProcessorInfo || verbose) {
 945                     log.printLines(&quot;x.print.processor.info&quot;,
 946                             ps.processor.getClass().getName(),
 947                             matchedNames.toString(),
 948                             processingResult);
 949                 }
 950 
 951                 if (processingResult) {
 952                     unmatchedAnnotations.keySet().removeAll(matchedNames);
 953                 }
 954 
 955             }
 956         }
 957         unmatchedAnnotations.remove(&quot;&quot;);
 958 
 959         if (lint &amp;&amp; unmatchedAnnotations.size() &gt; 0) {
 960             // Remove annotations processed by javac
 961             unmatchedAnnotations.keySet().removeAll(platformAnnotations);
 962             if (unmatchedAnnotations.size() &gt; 0) {
 963                 log.warning(Warnings.ProcAnnotationsWithoutProcessors(unmatchedAnnotations.keySet()));
 964             }
 965         }
 966 
 967         // Run contributing processors that haven&#39;t run yet
 968         psi.runContributingProcs(renv);
 969     }
 970 
 971     /**
 972      * Computes the set of annotations on the symbol in question.
 973      * Leave class public for external testing purposes.
 974      */
 975     @SuppressWarnings(&quot;preview&quot;)
 976     public static class ComputeAnnotationSet extends
 977         ElementScanner14&lt;Set&lt;TypeElement&gt;, Set&lt;TypeElement&gt;&gt; {
 978         final Elements elements;
 979 
 980         public ComputeAnnotationSet(Elements elements) {
 981             super();
 982             this.elements = elements;
 983         }
 984 
 985         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 986         public Set&lt;TypeElement&gt; visitPackage(PackageElement e, Set&lt;TypeElement&gt; p) {
 987             // Don&#39;t scan enclosed elements of a package
 988             return p;
 989         }
 990 
 991         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 992         public Set&lt;TypeElement&gt; visitType(TypeElement e, Set&lt;TypeElement&gt; p) {
 993             // Type parameters are not considered to be enclosed by a type
 994             scan(e.getTypeParameters(), p);
 995             return super.visitType(e, p);
 996         }
 997 
 998         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 999         public Set&lt;TypeElement&gt; visitExecutable(ExecutableElement e, Set&lt;TypeElement&gt; p) {
1000             // Type parameters are not considered to be enclosed by an executable
1001             scan(e.getTypeParameters(), p);
1002             return super.visitExecutable(e, p);
1003         }
1004 
1005         void addAnnotations(Element e, Set&lt;TypeElement&gt; p) {
1006             for (AnnotationMirror annotationMirror :
1007                      elements.getAllAnnotationMirrors(e) ) {
1008                 Element e2 = annotationMirror.getAnnotationType().asElement();
1009                 p.add((TypeElement) e2);
1010             }
1011         }
1012 
1013         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1014         public Set&lt;TypeElement&gt; scan(Element e, Set&lt;TypeElement&gt; p) {
1015             addAnnotations(e, p);
1016             return super.scan(e, p);
1017         }
1018     }
1019 
1020     private boolean callProcessor(Processor proc,
1021                                          Set&lt;? extends TypeElement&gt; tes,
1022                                          RoundEnvironment renv) {
1023         Handler prevDeferredHandler = dcfh.setHandler(dcfh.userCodeHandler);
1024         try {
1025             return proc.process(tes, renv);
1026         } catch (ClassFinder.BadClassFile ex) {
1027             log.error(Errors.ProcCantAccess1(ex.sym, ex.getDetailValue()));
1028             return false;
1029         } catch (CompletionFailure ex) {
1030             StringWriter out = new StringWriter();
1031             ex.printStackTrace(new PrintWriter(out));
1032             log.error(Errors.ProcCantAccess(ex.sym, ex.getDetailValue(), out.toString()));
1033             return false;
1034         } catch (ClientCodeException e) {
1035             throw e;
1036         } catch (Throwable t) {
1037             throw new AnnotationProcessingError(t);
1038         } finally {
1039             dcfh.setHandler(prevDeferredHandler);
1040         }
1041     }
1042 
1043     /**
1044      * Helper object for a single round of annotation processing.
1045      */
1046     class Round {
1047         /** The round number. */
1048         final int number;
1049         /** The diagnostic handler for the round. */
1050         final Log.DeferredDiagnosticHandler deferredDiagnosticHandler;
1051 
1052         /** The ASTs to be compiled. */
1053         List&lt;JCCompilationUnit&gt; roots;
1054         /** The trees that need to be cleaned - includes roots and implicitly parsed trees. */
1055         Set&lt;JCCompilationUnit&gt; treesToClean;
1056         /** The classes to be compiler that have were generated. */
1057         Map&lt;ModuleSymbol, Map&lt;String, JavaFileObject&gt;&gt; genClassFiles;
1058 
1059         /** The set of annotations to be processed this round. */
1060         Set&lt;TypeElement&gt; annotationsPresent;
1061         /** The set of top level classes to be processed this round. */
1062         List&lt;ClassSymbol&gt; topLevelClasses;
1063         /** The set of package-info files to be processed this round. */
1064         List&lt;PackageSymbol&gt; packageInfoFiles;
1065         /** The set of module-info files to be processed this round. */
1066         List&lt;ModuleSymbol&gt; moduleInfoFiles;
1067 
1068         /** Create a round (common code). */
1069         private Round(int number, Set&lt;JCCompilationUnit&gt; treesToClean,
1070                 Log.DeferredDiagnosticHandler deferredDiagnosticHandler) {
1071             this.number = number;
1072 
1073             if (number == 1) {
1074                 Assert.checkNonNull(deferredDiagnosticHandler);
1075                 this.deferredDiagnosticHandler = deferredDiagnosticHandler;
1076             } else {
1077                 this.deferredDiagnosticHandler = new Log.DeferredDiagnosticHandler(log);
1078                 compiler.setDeferredDiagnosticHandler(this.deferredDiagnosticHandler);
1079             }
1080 
1081             // the following will be populated as needed
1082             topLevelClasses  = List.nil();
1083             packageInfoFiles = List.nil();
1084             moduleInfoFiles = List.nil();
1085             this.treesToClean = treesToClean;
1086         }
1087 
1088         /** Create the first round. */
1089         Round(List&lt;JCCompilationUnit&gt; roots,
1090               List&lt;ClassSymbol&gt; classSymbols,
1091               Set&lt;JCCompilationUnit&gt; treesToClean,
1092               Log.DeferredDiagnosticHandler deferredDiagnosticHandler) {
1093             this(1, treesToClean, deferredDiagnosticHandler);
1094             this.roots = roots;
1095             genClassFiles = new HashMap&lt;&gt;();
1096 
1097             // The reverse() in the following line is to maintain behavioural
1098             // compatibility with the previous revision of the code. Strictly speaking,
1099             // it should not be necessary, but a javah golden file test fails without it.
1100             topLevelClasses =
1101                 getTopLevelClasses(roots).prependList(classSymbols.reverse());
1102 
1103             packageInfoFiles = getPackageInfoFiles(roots);
1104 
1105             moduleInfoFiles = getModuleInfoFiles(roots);
1106 
1107             findAnnotationsPresent();
1108         }
1109 
1110         /** Create a new round. */
1111         private Round(Round prev,
1112                 Set&lt;JavaFileObject&gt; newSourceFiles, Map&lt;ModuleSymbol, Map&lt;String,JavaFileObject&gt;&gt; newClassFiles) {
1113             this(prev.number+1, prev.treesToClean, null);
1114             prev.newRound();
1115             this.genClassFiles = prev.genClassFiles;
1116 
1117             //parse the generated files even despite errors reported so far, to eliminate
1118             //recoverable errors related to the type declared in the generated files:
1119             List&lt;JCCompilationUnit&gt; parsedFiles = compiler.parseFiles(newSourceFiles, true);
1120             roots = prev.roots.appendList(parsedFiles);
1121 
1122             // Check for errors after parsing
1123             if (unrecoverableError()) {
1124                 compiler.initModules(List.nil());
1125                 return;
1126             }
1127 
1128             roots = compiler.initModules(roots);
1129 
1130             enterClassFiles(genClassFiles);
1131             List&lt;ClassSymbol&gt; newClasses = enterClassFiles(newClassFiles);
1132             for (Entry&lt;ModuleSymbol, Map&lt;String, JavaFileObject&gt;&gt; moduleAndClassFiles : newClassFiles.entrySet()) {
1133                 genClassFiles.computeIfAbsent(moduleAndClassFiles.getKey(), m -&gt; new LinkedHashMap&lt;&gt;()).putAll(moduleAndClassFiles.getValue());
1134             }
1135             enterTrees(roots);
1136 
1137             if (unrecoverableError())
1138                 return;
1139 
1140             topLevelClasses = join(
1141                     getTopLevelClasses(parsedFiles),
1142                     getTopLevelClassesFromClasses(newClasses));
1143 
1144             packageInfoFiles = join(
1145                     getPackageInfoFiles(parsedFiles),
1146                     getPackageInfoFilesFromClasses(newClasses));
1147 
1148             moduleInfoFiles = List.nil(); //module-info cannot be generated
1149 
1150             findAnnotationsPresent();
1151         }
1152 
1153         /** Create the next round to be used. */
1154         Round next(Set&lt;JavaFileObject&gt; newSourceFiles, Map&lt;ModuleSymbol, Map&lt;String, JavaFileObject&gt;&gt; newClassFiles) {
1155             return new Round(this, newSourceFiles, newClassFiles);
1156         }
1157 
1158         /** Prepare the compiler for the final compilation. */
1159         void finalCompiler() {
1160             newRound();
1161         }
1162 
1163         /** Return the number of errors found so far in this round.
1164          * This may include unrecoverable errors, such as parse errors,
1165          * and transient errors, such as missing symbols. */
1166         int errorCount() {
1167             return compiler.errorCount();
1168         }
1169 
1170         /** Return the number of warnings found so far in this round. */
1171         int warningCount() {
1172             return compiler.warningCount();
1173         }
1174 
1175         /** Return whether or not an unrecoverable error has occurred. */
1176         boolean unrecoverableError() {
1177             if (messager.errorRaised())
1178                 return true;
1179 
1180             for (JCDiagnostic d: deferredDiagnosticHandler.getDiagnostics()) {
1181                 switch (d.getKind()) {
1182                     case WARNING:
1183                         if (werror)
1184                             return true;
1185                         break;
1186 
1187                     case ERROR:
1188                         if (fatalErrors || !d.isFlagSet(RECOVERABLE))
1189                             return true;
1190                         break;
1191                 }
1192             }
1193 
1194             return false;
1195         }
1196 
1197         /** Find the set of annotations present in the set of top level
1198          *  classes and package info files to be processed this round. */
1199         void findAnnotationsPresent() {
1200             ComputeAnnotationSet annotationComputer = new ComputeAnnotationSet(elementUtils);
1201             // Use annotation processing to compute the set of annotations present
1202             annotationsPresent = new LinkedHashSet&lt;&gt;();
1203             for (ClassSymbol classSym : topLevelClasses)
1204                 annotationComputer.scan(classSym, annotationsPresent);
1205             for (PackageSymbol pkgSym : packageInfoFiles)
1206                 annotationComputer.scan(pkgSym, annotationsPresent);
1207             for (ModuleSymbol mdlSym : moduleInfoFiles)
1208                 annotationComputer.scan(mdlSym, annotationsPresent);
1209         }
1210 
1211         /** Enter a set of generated class files. */
1212         private List&lt;ClassSymbol&gt; enterClassFiles(Map&lt;ModuleSymbol, Map&lt;String, JavaFileObject&gt;&gt; modulesAndClassFiles) {
1213             List&lt;ClassSymbol&gt; list = List.nil();
1214 
1215             for (Entry&lt;ModuleSymbol, Map&lt;String, JavaFileObject&gt;&gt; moduleAndClassFiles : modulesAndClassFiles.entrySet()) {
1216                 for (Map.Entry&lt;String,JavaFileObject&gt; entry : moduleAndClassFiles.getValue().entrySet()) {
1217                     Name name = names.fromString(entry.getKey());
1218                     JavaFileObject file = entry.getValue();
1219                     if (file.getKind() != JavaFileObject.Kind.CLASS)
1220                         throw new AssertionError(file);
1221                     ClassSymbol cs;
1222                     if (isPkgInfo(file, JavaFileObject.Kind.CLASS)) {
1223                         Name packageName = Convert.packagePart(name);
1224                         PackageSymbol p = symtab.enterPackage(moduleAndClassFiles.getKey(), packageName);
1225                         if (p.package_info == null)
1226                             p.package_info = symtab.enterClass(moduleAndClassFiles.getKey(), Convert.shortName(name), p);
1227                         cs = p.package_info;
1228                         cs.reset();
1229                         if (cs.classfile == null)
1230                             cs.classfile = file;
1231                         cs.completer = initialCompleter;
1232                     } else {
1233                         cs = symtab.enterClass(moduleAndClassFiles.getKey(), name);
1234                         cs.reset();
1235                         cs.classfile = file;
1236                         cs.completer = initialCompleter;
1237                         if (cs.owner.kind == PCK) {
1238                             cs.owner.members().enter(cs); //XXX - OverwriteBetweenCompilations; syms.getClass is not sufficient anymore
1239                         }
1240                     }
1241                     list = list.prepend(cs);
1242                 }
1243             }
1244             return list.reverse();
1245         }
1246 
1247         /** Enter a set of syntax trees. */
1248         private void enterTrees(List&lt;JCCompilationUnit&gt; roots) {
1249             compiler.enterTrees(roots);
1250         }
1251 
1252         /** Run a processing round. */
1253         void run(boolean lastRound, boolean errorStatus) {
1254             printRoundInfo(lastRound);
1255 
1256             if (!taskListener.isEmpty())
1257                 taskListener.started(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING_ROUND));
1258 
1259             try {
1260                 if (lastRound) {
1261                     filer.setLastRound(true);
1262                     Set&lt;Element&gt; emptyRootElements = Collections.emptySet(); // immutable
1263                     RoundEnvironment renv = new JavacRoundEnvironment(true,
1264                             errorStatus,
1265                             emptyRootElements,
1266                             JavacProcessingEnvironment.this);
1267                     discoveredProcs.iterator().runContributingProcs(renv);
1268                 } else {
1269                     discoverAndRunProcs(annotationsPresent, topLevelClasses, packageInfoFiles, moduleInfoFiles);
1270                 }
1271             } catch (Throwable t) {
1272                 // we&#39;re specifically expecting Abort here, but if any Throwable
1273                 // comes by, we should flush all deferred diagnostics, rather than
1274                 // drop them on the ground.
1275                 deferredDiagnosticHandler.reportDeferredDiagnostics();
1276                 log.popDiagnosticHandler(deferredDiagnosticHandler);
1277                 compiler.setDeferredDiagnosticHandler(null);
1278                 throw t;
1279             } finally {
1280                 if (!taskListener.isEmpty())
1281                     taskListener.finished(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING_ROUND));
1282             }
1283         }
1284 
1285         void showDiagnostics(boolean showAll) {
1286             deferredDiagnosticHandler.reportDeferredDiagnostics(showAll ? ACCEPT_ALL
1287                                                                         : ACCEPT_NON_RECOVERABLE);
1288             log.popDiagnosticHandler(deferredDiagnosticHandler);
1289             compiler.setDeferredDiagnosticHandler(null);
1290         }
1291         //where:
1292             private final Predicate&lt;JCDiagnostic&gt; ACCEPT_NON_RECOVERABLE =
1293                     d -&gt; d.getKind() != JCDiagnostic.Kind.ERROR ||
1294                          !d.isFlagSet(DiagnosticFlag.RECOVERABLE) ||
1295                          d.isFlagSet(DiagnosticFlag.API);
1296             private final Predicate&lt;JCDiagnostic&gt; ACCEPT_ALL = d -&gt; true;
1297 
1298         /** Print info about this round. */
1299         private void printRoundInfo(boolean lastRound) {
1300             if (printRounds || verbose) {
1301                 List&lt;ClassSymbol&gt; tlc = lastRound ? List.nil() : topLevelClasses;
1302                 Set&lt;TypeElement&gt; ap = lastRound ? Collections.emptySet() : annotationsPresent;
1303                 log.printLines(&quot;x.print.rounds&quot;,
1304                         number,
1305                         &quot;{&quot; + tlc.toString(&quot;, &quot;) + &quot;}&quot;,
1306                         ap,
1307                         lastRound);
1308             }
1309         }
1310 
1311         /** Prepare for new round of annotation processing. Cleans trees, resets symbols, and
1312          * asks selected services to prepare to a new round of annotation processing.
1313          */
1314         private void newRound() {
1315             //ensure treesToClean contains all trees, including implicitly parsed ones
1316             for (Env&lt;AttrContext&gt; env : enter.getEnvs()) {
1317                 treesToClean.add(env.toplevel);
1318             }
1319             for (JCCompilationUnit node : treesToClean) {
1320                 treeCleaner.scan(node);
1321             }
1322             chk.newRound();
1323             enter.newRound();
1324             filer.newRound();
1325             messager.newRound();
1326             compiler.newRound();
1327             modules.newRound();
1328             types.newRound();
1329             annotate.newRound();
1330             elementUtils.newRound();
1331 
1332             boolean foundError = false;
1333 
1334             for (ClassSymbol cs : symtab.getAllClasses()) {
1335                 if (cs.kind == ERR) {
1336                     foundError = true;
1337                     break;
1338                 }
1339             }
1340 
1341             if (foundError) {
1342                 for (ClassSymbol cs : symtab.getAllClasses()) {
1343                     if (cs.classfile != null || cs.kind == ERR) {
1344                         cs.reset();
1345                         if (cs.kind == ERR) {
1346                             cs.type = new ClassType(cs.type.getEnclosingType(), null, cs);
1347                         }
1348                         if (cs.isCompleted()) {
1349                             cs.completer = initialCompleter;
1350                         }
1351                     }
1352                 }
1353             }
1354         }
1355     }
1356 
1357 
1358     // TODO: internal catch clauses?; catch and rethrow an annotation
1359     // processing error
1360     public boolean doProcessing(List&lt;JCCompilationUnit&gt; roots,
1361                                 List&lt;ClassSymbol&gt; classSymbols,
1362                                 Iterable&lt;? extends PackageSymbol&gt; pckSymbols,
1363                                 Log.DeferredDiagnosticHandler deferredDiagnosticHandler) {
1364         final Set&lt;JCCompilationUnit&gt; treesToClean =
1365                 Collections.newSetFromMap(new IdentityHashMap&lt;JCCompilationUnit, Boolean&gt;());
1366 
1367         //fill already attributed implicit trees:
1368         for (Env&lt;AttrContext&gt; env : enter.getEnvs()) {
1369             treesToClean.add(env.toplevel);
1370         }
1371 
1372         Set&lt;PackageSymbol&gt; specifiedPackages = new LinkedHashSet&lt;&gt;();
1373         for (PackageSymbol psym : pckSymbols)
1374             specifiedPackages.add(psym);
1375         this.specifiedPackages = Collections.unmodifiableSet(specifiedPackages);
1376 
1377         Round round = new Round(roots, classSymbols, treesToClean, deferredDiagnosticHandler);
1378 
1379         boolean errorStatus;
1380         boolean moreToDo;
1381         do {
1382             // Run processors for round n
1383             round.run(false, false);
1384 
1385             // Processors for round n have run to completion.
1386             // Check for errors and whether there is more work to do.
1387             errorStatus = round.unrecoverableError();
1388             moreToDo = moreToDo();
1389 
1390             round.showDiagnostics(showResolveErrors);
1391 
1392             // Set up next round.
1393             // Copy mutable collections returned from filer.
1394             round = round.next(
1395                     new LinkedHashSet&lt;&gt;(filer.getGeneratedSourceFileObjects()),
1396                     new LinkedHashMap&lt;&gt;(filer.getGeneratedClasses()));
1397 
1398              // Check for errors during setup.
1399             if (round.unrecoverableError())
1400                 errorStatus = true;
1401 
1402         } while (moreToDo &amp;&amp; !errorStatus);
1403 
1404         // run last round
1405         round.run(true, errorStatus);
1406         round.showDiagnostics(true);
1407 
1408         filer.warnIfUnclosedFiles();
1409         warnIfUnmatchedOptions();
1410 
1411         /*
1412          * If an annotation processor raises an error in a round,
1413          * that round runs to completion and one last round occurs.
1414          * The last round may also occur because no more source or
1415          * class files have been generated.  Therefore, if an error
1416          * was raised on either of the last *two* rounds, the compile
1417          * should exit with a nonzero exit code.  The current value of
1418          * errorStatus holds whether or not an error was raised on the
1419          * second to last round; errorRaised() gives the error status
1420          * of the last round.
1421          */
1422         if (messager.errorRaised()
1423                 || werror &amp;&amp; round.warningCount() &gt; 0 &amp;&amp; round.errorCount() &gt; 0)
1424             errorStatus = true;
1425 
1426         Set&lt;JavaFileObject&gt; newSourceFiles =
1427                 new LinkedHashSet&lt;&gt;(filer.getGeneratedSourceFileObjects());
1428         roots = round.roots;
1429 
1430         errorStatus = errorStatus || (compiler.errorCount() &gt; 0);
1431 
1432         round.finalCompiler();
1433 
1434         if (newSourceFiles.size() &gt; 0)
1435             roots = roots.appendList(compiler.parseFiles(newSourceFiles));
1436 
1437         errorStatus = errorStatus || (compiler.errorCount() &gt; 0);
1438 
1439         // Free resources
1440         this.close();
1441 
1442         if (errorStatus &amp;&amp; compiler.errorCount() == 0) {
1443             compiler.log.nerrors++;
1444         }
1445 
1446         compiler.enterTreesIfNeeded(roots);
1447 
1448         if (!taskListener.isEmpty())
1449             taskListener.finished(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING));
1450 
1451         return true;
1452     }
1453 
1454     private void warnIfUnmatchedOptions() {
1455         if (!unmatchedProcessorOptions.isEmpty()) {
1456             log.warning(Warnings.ProcUnmatchedProcessorOptions(unmatchedProcessorOptions.toString()));
1457         }
1458     }
1459 
1460     /**
1461      * Free resources related to annotation processing.
1462      */
1463     public void close() {
1464         filer.close();
1465         if (discoveredProcs != null) // Make calling close idempotent
1466             discoveredProcs.close();
1467         discoveredProcs = null;
1468     }
1469 
1470     private List&lt;ClassSymbol&gt; getTopLevelClasses(List&lt;? extends JCCompilationUnit&gt; units) {
1471         List&lt;ClassSymbol&gt; classes = List.nil();
1472         for (JCCompilationUnit unit : units) {
1473             for (JCTree node : unit.defs) {
1474                 if (node.hasTag(JCTree.Tag.CLASSDEF)) {
1475                     ClassSymbol sym = ((JCClassDecl) node).sym;
1476                     Assert.checkNonNull(sym);
1477                     classes = classes.prepend(sym);
1478                 }
1479             }
1480         }
1481         return classes.reverse();
1482     }
1483 
1484     private List&lt;ClassSymbol&gt; getTopLevelClassesFromClasses(List&lt;? extends ClassSymbol&gt; syms) {
1485         List&lt;ClassSymbol&gt; classes = List.nil();
1486         for (ClassSymbol sym : syms) {
1487             if (!isPkgInfo(sym)) {
1488                 classes = classes.prepend(sym);
1489             }
1490         }
1491         return classes.reverse();
1492     }
1493 
1494     private List&lt;PackageSymbol&gt; getPackageInfoFiles(List&lt;? extends JCCompilationUnit&gt; units) {
1495         List&lt;PackageSymbol&gt; packages = List.nil();
1496         for (JCCompilationUnit unit : units) {
1497             if (isPkgInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE)) {
1498                 packages = packages.prepend(unit.packge);
1499             }
1500         }
1501         return packages.reverse();
1502     }
1503 
1504     private List&lt;PackageSymbol&gt; getPackageInfoFilesFromClasses(List&lt;? extends ClassSymbol&gt; syms) {
1505         List&lt;PackageSymbol&gt; packages = List.nil();
1506         for (ClassSymbol sym : syms) {
1507             if (isPkgInfo(sym)) {
1508                 packages = packages.prepend((PackageSymbol) sym.owner);
1509             }
1510         }
1511         return packages.reverse();
1512     }
1513 
1514     private List&lt;ModuleSymbol&gt; getModuleInfoFiles(List&lt;? extends JCCompilationUnit&gt; units) {
1515         List&lt;ModuleSymbol&gt; modules = List.nil();
1516         for (JCCompilationUnit unit : units) {
1517             if (isModuleInfo(unit.sourcefile, JavaFileObject.Kind.SOURCE) &amp;&amp; unit.defs.nonEmpty()) {
1518                 for (JCTree tree : unit.defs) {
1519                     if (tree.hasTag(Tag.IMPORT)) {
1520                         continue;
1521                     }
1522                     else if (tree.hasTag(Tag.MODULEDEF)) {
1523                         modules = modules.prepend(unit.modle);
1524                         break;
1525                     }
1526                     else {
1527                         break;
1528                     }
1529                 }
1530             }
1531         }
1532         return modules.reverse();
1533     }
1534 
1535     // avoid unchecked warning from use of varargs
1536     private static &lt;T&gt; List&lt;T&gt; join(List&lt;T&gt; list1, List&lt;T&gt; list2) {
1537         return list1.appendList(list2);
1538     }
1539 
1540     private boolean isPkgInfo(JavaFileObject fo, JavaFileObject.Kind kind) {
1541         return fo.isNameCompatible(&quot;package-info&quot;, kind);
1542     }
1543 
1544     private boolean isPkgInfo(ClassSymbol sym) {
1545         return isPkgInfo(sym.classfile, JavaFileObject.Kind.CLASS) &amp;&amp; (sym.packge().package_info == sym);
1546     }
1547 
1548     private boolean isModuleInfo(JavaFileObject fo, JavaFileObject.Kind kind) {
1549         return fo.isNameCompatible(&quot;module-info&quot;, kind);
1550     }
1551 
1552     /*
1553      * Called retroactively to determine if a class loader was required,
1554      * after we have failed to create one.
1555      */
1556     private boolean needClassLoader(String procNames, Iterable&lt;? extends Path&gt; workingpath) {
1557         if (procNames != null)
1558             return true;
1559 
1560         URL[] urls = new URL[1];
1561         for(Path pathElement : workingpath) {
1562             try {
1563                 urls[0] = pathElement.toUri().toURL();
1564                 if (ServiceProxy.hasService(Processor.class, urls))
1565                     return true;
1566             } catch (MalformedURLException ex) {
1567                 throw new AssertionError(ex);
1568             }
1569             catch (ServiceProxy.ServiceConfigurationError e) {
1570                 log.error(Errors.ProcBadConfigFile(e.getLocalizedMessage()));
1571                 return true;
1572             }
1573         }
1574 
1575         return false;
1576     }
1577 
1578     class ImplicitCompleter implements Completer {
1579 
1580         private final JCCompilationUnit topLevel;
1581 
1582         public ImplicitCompleter(JCCompilationUnit topLevel) {
1583             this.topLevel = topLevel;
1584         }
1585 
1586         @Override public void complete(Symbol sym) throws CompletionFailure {
1587             compiler.readSourceFile(topLevel, (ClassSymbol) sym);
1588         }
1589     }
1590 
1591     private final TreeScanner treeCleaner = new TreeScanner() {
1592             public void scan(JCTree node) {
1593                 super.scan(node);
1594                 if (node != null)
1595                     node.type = null;
1596             }
1597             JCCompilationUnit topLevel;
1598             public void visitTopLevel(JCCompilationUnit node) {
1599                 if (node.packge != null) {
1600                     if (isPkgInfo(node.sourcefile, Kind.SOURCE)) {
1601                         node.packge.package_info.reset();
1602                     }
1603                     node.packge.reset();
1604                 }
1605                 if (isModuleInfo(node.sourcefile, Kind.SOURCE)) {
1606                     node.modle.reset();
1607                     node.modle.completer = sym -&gt; modules.enter(List.of(node), node.modle.module_info);
1608                     node.modle.module_info.reset();
1609                     node.modle.module_info.members_field = WriteableScope.create(node.modle.module_info);
1610                 }
1611                 node.packge = null;
1612                 topLevel = node;
1613                 try {
1614                     super.visitTopLevel(node);
1615                 } finally {
1616                     topLevel = null;
1617                 }
1618             }
1619             public void visitClassDef(JCClassDecl node) {
1620                 super.visitClassDef(node);
1621                 // remove generated constructor that may have been added during attribution:
1622                 List&lt;JCTree&gt; beforeConstructor = List.nil();
1623                 List&lt;JCTree&gt; defs = node.defs;
1624                 while (defs.nonEmpty() &amp;&amp; !defs.head.hasTag(Tag.METHODDEF)) {
1625                     beforeConstructor = beforeConstructor.prepend(defs.head);
1626                     defs = defs.tail;
1627                 }
1628                 if (defs.nonEmpty() &amp;&amp;
1629                     (((JCMethodDecl) defs.head).mods.flags &amp; Flags.GENERATEDCONSTR) != 0) {
1630                     defs = defs.tail;
1631                     while (beforeConstructor.nonEmpty()) {
1632                         defs = defs.prepend(beforeConstructor.head);
1633                         beforeConstructor = beforeConstructor.tail;
1634                     }
1635                     node.defs = defs;
1636                 }
1637                 if (node.sym != null) {
1638                     node.sym.completer = new ImplicitCompleter(topLevel);
1639                 }
1640                 node.sym = null;
1641             }
1642             public void visitMethodDef(JCMethodDecl node) {
1643                 // remove super constructor call that may have been added during attribution:
1644                 if (TreeInfo.isConstructor(node) &amp;&amp; node.sym != null &amp;&amp; node.sym.owner.isEnum() &amp;&amp;
1645                     node.body.stats.nonEmpty() &amp;&amp; TreeInfo.isSuperCall(node.body.stats.head) &amp;&amp;
1646                     node.body.stats.head.pos == node.body.pos) {
1647                     node.body.stats = node.body.stats.tail;
1648                 }
1649                 node.sym = null;
1650                 super.visitMethodDef(node);
1651             }
1652             public void visitVarDef(JCVariableDecl node) {
1653                 node.sym = null;
1654                 super.visitVarDef(node);
1655             }
1656             public void visitNewClass(JCNewClass node) {
1657                 node.constructor = null;
1658                 super.visitNewClass(node);
1659             }
1660             public void visitAssignop(JCAssignOp node) {
1661                 node.operator = null;
1662                 super.visitAssignop(node);
1663             }
1664             public void visitUnary(JCUnary node) {
1665                 node.operator = null;
1666                 super.visitUnary(node);
1667             }
1668             public void visitBinary(JCBinary node) {
1669                 node.operator = null;
1670                 super.visitBinary(node);
1671             }
1672             public void visitSelect(JCFieldAccess node) {
1673                 node.sym = null;
1674                 super.visitSelect(node);
1675             }
1676             public void visitIdent(JCIdent node) {
1677                 node.sym = null;
1678                 super.visitIdent(node);
1679             }
1680             public void visitAnnotation(JCAnnotation node) {
1681                 node.attribute = null;
1682                 super.visitAnnotation(node);
1683             }
1684         };
1685 
1686 
1687     private boolean moreToDo() {
1688         return filer.newFiles();
1689     }
1690 
1691     /**
1692      * {@inheritDoc}
1693      *
1694      * Command line options suitable for presenting to annotation
1695      * processors.
1696      * {@literal &quot;-Afoo=bar&quot;} should be {@literal &quot;-Afoo&quot; =&gt; &quot;bar&quot;}.
1697      */
1698     @DefinedBy(Api.ANNOTATION_PROCESSING)
1699     public Map&lt;String,String&gt; getOptions() {
1700         return processorOptions;
1701     }
1702 
1703     @DefinedBy(Api.ANNOTATION_PROCESSING)
1704     public Messager getMessager() {
1705         return messager;
1706     }
1707 
1708     @DefinedBy(Api.ANNOTATION_PROCESSING)
1709     public JavacFiler getFiler() {
1710         return filer;
1711     }
1712 
1713     @DefinedBy(Api.ANNOTATION_PROCESSING)
1714     public JavacElements getElementUtils() {
1715         return elementUtils;
1716     }
1717 
1718     @DefinedBy(Api.ANNOTATION_PROCESSING)
1719     public JavacTypes getTypeUtils() {
1720         return typeUtils;
1721     }
1722 
1723     @DefinedBy(Api.ANNOTATION_PROCESSING)
1724     public SourceVersion getSourceVersion() {
1725         return Source.toSourceVersion(source);
1726     }
1727 
1728     @DefinedBy(Api.ANNOTATION_PROCESSING)
1729     public Locale getLocale() {
1730         return messages.getCurrentLocale();
1731     }
1732 
1733     @DefinedBy(Api.ANNOTATION_PROCESSING)
1734     public boolean isPreviewEnabled() {
1735         return preview.isEnabled();
1736     }
1737 
1738     public Set&lt;Symbol.PackageSymbol&gt; getSpecifiedPackages() {
1739         return specifiedPackages;
1740     }
1741 
1742     public static final Pattern noMatches  = Pattern.compile(&quot;(\\P{all})+&quot;);
1743 
1744     /**
1745      * Convert import-style string for supported annotations into a
1746      * regex matching that string.  If the string is not a valid
1747      * import-style string, return a regex that won&#39;t match anything.
1748      */
1749     private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, boolean lint) {
1750         String module;
1751         String pkg;
1752         int slash = s.indexOf(&#39;/&#39;);
1753         if (slash == (-1)) {
1754             if (s.equals(&quot;*&quot;)) {
1755                 return MatchingUtils.validImportStringToPattern(s);
1756             }
1757             module = allowModules ? &quot;.*/&quot; : &quot;&quot;;
1758             pkg = s;
1759         } else {
1760             String moduleName = s.substring(0, slash);
1761             if (!SourceVersion.isName(moduleName)) {
1762                 return warnAndNoMatches(s, p, log, lint);
1763             }
1764             module = Pattern.quote(moduleName + &quot;/&quot;);
1765             // And warn if module is specified if modules aren&#39;t supported, conditional on -Xlint:proc?
1766             pkg = s.substring(slash + 1);
1767         }
1768         if (MatchingUtils.isValidImportString(pkg)) {
1769             return Pattern.compile(module + MatchingUtils.validImportStringToPatternString(pkg));
1770         } else {
1771             return warnAndNoMatches(s, p, log, lint);
1772         }
1773     }
1774 
1775     private static Pattern warnAndNoMatches(String s, Processor p, Log log, boolean lint) {
1776         if (lint) {
1777             log.warning(Warnings.ProcMalformedSupportedString(s, p.getClass().getName()));
1778         }
1779         return noMatches; // won&#39;t match any valid identifier
1780     }
1781 
1782     /**
1783      * For internal use only.  This method may be removed without warning.
1784      */
1785     public Context getContext() {
1786         return context;
1787     }
1788 
1789     /**
1790      * For internal use only.  This method may be removed without warning.
1791      */
1792     public ClassLoader getProcessorClassLoader() {
1793         return processorClassLoader;
1794     }
1795 
1796     public String toString() {
1797         return &quot;javac ProcessingEnvironment&quot;;
1798     }
1799 
1800     public static boolean isValidOptionName(String optionName) {
1801         for(String s : optionName.split(&quot;\\.&quot;, -1)) {
1802             if (!SourceVersion.isIdentifier(s))
1803                 return false;
1804         }
1805         return true;
1806     }
1807 }
    </pre>
  </body>
</html>
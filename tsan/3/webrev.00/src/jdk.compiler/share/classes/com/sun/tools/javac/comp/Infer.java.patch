diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java
@@ -135,11 +135,11 @@
     * to inference errors that can arise during a method applicability check.
     */
     public static class InferenceException extends InapplicableMethodException {
         private static final long serialVersionUID = 0;
 
-        List<JCDiagnostic> messages = List.nil();
+        transient List<JCDiagnostic> messages = List.nil();
 
         InferenceException() {
             super(null);
         }
 
@@ -277,11 +277,11 @@
                 return List.of(mt.getReturnType());
             }
         }
 
     /**
-     * A partially infered method/constructor type; such a type can be checked multiple times
+     * A partially inferred method/constructor type; such a type can be checked multiple times
      * against different targets.
      */
     public class PartiallyInferredMethodType extends MethodType {
         public PartiallyInferredMethodType(MethodType mtype, InferenceContext inferenceContext, Env<AttrContext> env, Warner warn) {
             super(mtype.getParameterTypes(), mtype.getReturnType(), mtype.getThrownTypes(), mtype.tsym);
@@ -304,11 +304,11 @@
             return true;
         }
 
         /**
          * Checks this type against a target; this means generating return type constraints, solve
-         * and then roll back the results (to avoid poolluting the context).
+         * and then roll back the results (to avoid polluting the context).
          */
         Type check(Attr.ResultInfo resultInfo) {
             Warner noWarnings = new Warner(null);
             List<Type> saved_undet = null;
             try {
@@ -1319,11 +1319,11 @@
          * to pick the next node to solve in the inference graph.
          */
         public static class NodeNotFoundException extends RuntimeException {
             private static final long serialVersionUID = 0;
 
-            InferenceGraph graph;
+            transient InferenceGraph graph;
 
             public NodeNotFoundException(InferenceGraph graph) {
                 this.graph = graph;
             }
         }
@@ -1619,14 +1619,14 @@
         /** bound dependency */
         BOUND("dotted"),
         /** stuck dependency */
         STUCK("dashed");
 
-        final String dotSyle;
+        final String dotStyle;
 
-        private DependencyKind(String dotSyle) {
-            this.dotSyle = dotSyle;
+        private DependencyKind(String dotStyle) {
+            this.dotStyle = dotStyle;
         }
     }
 
     /**
      * This is the graph inference solver - the solver organizes all inference variables in
@@ -1827,11 +1827,11 @@
                 }
 
                 @Override
                 public Properties dependencyAttributes(Node sink, GraphUtils.DependencyKind dk) {
                     Properties p = new Properties();
-                    p.put("style", ((DependencyKind)dk).dotSyle);
+                    p.put("style", ((DependencyKind)dk).dotStyle);
                     StringBuilder buf = new StringBuilder();
                     String sep = "";
                     for (Type from : data) {
                         UndetVar uv = (UndetVar)inferenceContext.asUndetVar(from);
                         for (Type bound : uv.getBounds(InferenceBound.values())) {

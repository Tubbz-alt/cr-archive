diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,19 +41,21 @@
 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
 import com.sun.tools.javac.jvm.*;
 import com.sun.tools.javac.main.Option;
 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
+import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 import com.sun.tools.javac.tree.*;
 import com.sun.tools.javac.tree.JCTree.*;
 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.DefinedBy.Api;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
+import com.sun.tools.javac.util.JCDiagnostic.Warning;
 
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.EnumSet;
 import java.util.HashSet;
@@ -61,10 +63,11 @@
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.function.BiFunction;
 import java.util.function.BiPredicate;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 
 import javax.lang.model.element.ElementVisitor;
@@ -103,10 +106,11 @@
     public final boolean allowFunctionalInterfaceMostSpecific;
     public final boolean allowModules;
     public final boolean checkVarargsAccessAfterResolution;
     private final boolean compactMethodDiags;
     private final boolean allowLocalVariableTypeInference;
+    private final boolean allowYieldStatement;
     final EnumSet<VerboseResolutionMode> verboseResolutionMode;
 
     WriteableScope polymorphicSignatureScope;
 
     protected Resolve(Context context) {
@@ -126,18 +130,21 @@
         infer = Infer.instance(context);
         finder = ClassFinder.instance(context);
         moduleFinder = ModuleFinder.instance(context);
         types = Types.instance(context);
         diags = JCDiagnostic.Factory.instance(context);
+        Preview preview = Preview.instance(context);
         Source source = Source.instance(context);
         Options options = Options.instance(context);
         compactMethodDiags = options.isSet(Option.XDIAGS, "compact") ||
                 options.isUnset(Option.XDIAGS) && options.isUnset("rawDiagnostics");
         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
         Target target = Target.instance(context);
         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
+        allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &&
+                Feature.SWITCH_EXPRESSION.allowedInSource(source);
         checkVarargsAccessAfterResolution =
                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
         allowModules = Feature.MODULES.allowedInSource(source);
     }
@@ -287,11 +294,11 @@
             (owner.kind == VAR ||
              owner.kind == MTH && (owner.flags() & BLOCK) != 0) &&
             (owner.flags() & STATIC) == 0;
     }
 
-    /** Is class accessible in given evironment?
+    /** Is class accessible in given environment?
      *  @param env    The current environment.
      *  @param c      The class whose accessibility is checked.
      */
     public boolean isAccessible(Env<AttrContext> env, TypeSymbol c) {
         return isAccessible(env, c, false);
@@ -1378,11 +1385,11 @@
     }
 
     public static class InapplicableMethodException extends RuntimeException {
         private static final long serialVersionUID = 0;
 
-        JCDiagnostic diagnostic;
+        transient JCDiagnostic diagnostic;
 
         InapplicableMethodException(JCDiagnostic diag) {
             this.diagnostic = diag;
         }
 
@@ -1480,11 +1487,17 @@
                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
             }
             if (sym.exists()) {
                 if (staticOnly &&
                     sym.kind == VAR &&
-                    sym.owner.kind == TYP &&
+                        // if it is a field
+                        (sym.owner.kind == TYP ||
+                        // or it is a local variable but it is not declared inside of the static local type
+                        // only records so far, then error
+                        (sym.owner.kind == MTH) &&
+                        (env.enclClass.sym.flags() & STATIC) != 0 &&
+                        sym.enclClass() != env.enclClass.sym) &&
                     (sym.flags() & STATIC) == 0)
                     return new StaticError(sym);
                 else
                     return sym;
             } else {
@@ -2328,17 +2341,19 @@
 
         return bestSoFar;
     }
 
     /** Find an unqualified identifier which matches a specified kind set.
+     *  @param pos       position on which report warnings, if any;
+     *                   null warnings should not be reported
      *  @param env       The current environment.
      *  @param name      The identifier's name.
      *  @param kind      Indicates the possible symbol kinds
      *                   (a subset of VAL, TYP, PCK).
      */
-    Symbol findIdent(Env<AttrContext> env, Name name, KindSelector kind) {
-        return checkVarType(findIdentInternal(env, name, kind), name);
+    Symbol findIdent(DiagnosticPosition pos, Env<AttrContext> env, Name name, KindSelector kind) {
+        return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);
     }
 
     Symbol findIdentInternal(Env<AttrContext> env, Name name, KindSelector kind) {
         Symbol bestSoFar = typeNotFound;
         Symbol sym;
@@ -2360,28 +2375,31 @@
             return lookupPackage(env, name);
         else return bestSoFar;
     }
 
     /** Find an identifier in a package which matches a specified kind set.
+     *  @param pos       position on which report warnings, if any;
+     *                   null warnings should not be reported
      *  @param env       The current environment.
      *  @param name      The identifier's name.
      *  @param kind      Indicates the possible symbol kinds
      *                   (a nonempty subset of TYP, PCK).
      */
-    Symbol findIdentInPackage(Env<AttrContext> env, TypeSymbol pck,
+    Symbol findIdentInPackage(DiagnosticPosition pos,
+                              Env<AttrContext> env, TypeSymbol pck,
                               Name name, KindSelector kind) {
-        return checkVarType(findIdentInPackageInternal(env, pck, name, kind), name);
+        return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
     }
 
     Symbol findIdentInPackageInternal(Env<AttrContext> env, TypeSymbol pck,
                               Name name, KindSelector kind) {
         Name fullname = TypeSymbol.formFullName(name, pck);
         Symbol bestSoFar = typeNotFound;
         if (kind.contains(KindSelector.TYP)) {
             RecoveryLoadClass recoveryLoadClass =
                     allowModules && !kind.contains(KindSelector.PCK) &&
-                    !pck.exists() && !env.info.isSpeculative ?
+                    !pck.exists() && !env.info.attributionMode.isSpeculative ?
                         doRecoveryLoadClass : noRecovery;
             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
             if (sym.exists()) {
                 // don't allow programs to use flatnames
                 if (name == sym.name) return sym;
@@ -2393,19 +2411,22 @@
         }
         return bestSoFar;
     }
 
     /** Find an identifier among the members of a given type `site'.
+     *  @param pos       position on which report warnings, if any;
+     *                   null warnings should not be reported
      *  @param env       The current environment.
      *  @param site      The type containing the symbol to be found.
      *  @param name      The identifier's name.
      *  @param kind      Indicates the possible symbol kinds
      *                   (a subset of VAL, TYP).
      */
-    Symbol findIdentInType(Env<AttrContext> env, Type site,
+    Symbol findIdentInType(DiagnosticPosition pos,
+                           Env<AttrContext> env, Type site,
                            Name name, KindSelector kind) {
-        return checkVarType(findIdentInTypeInternal(env, site, name, kind), name);
+        return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);
     }
 
     Symbol findIdentInTypeInternal(Env<AttrContext> env, Type site,
                            Name name, KindSelector kind) {
         Symbol bestSoFar = typeNotFound;
@@ -2422,14 +2443,21 @@
             else bestSoFar = bestOf(bestSoFar, sym);
         }
         return bestSoFar;
     }
 
-    private Symbol checkVarType(Symbol bestSoFar, Name name) {
-        if (allowLocalVariableTypeInference && name.equals(names.var) &&
-                (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP)) {
-            bestSoFar = new BadVarTypeError();
+    private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {
+        if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {
+            if (allowLocalVariableTypeInference && name.equals(names.var)) {
+                bestSoFar = new BadRestrictedTypeError(names.var);
+            } else if (name.equals(names.yield)) {
+                if (allowYieldStatement) {
+                    bestSoFar = new BadRestrictedTypeError(names.yield);
+                } else if (pos != null) {
+                    log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));
+                }
+            }
         }
         return bestSoFar;
     }
 
 /* ***************************************************************************
@@ -2595,11 +2623,11 @@
      *  @param kind      The set of admissible symbol kinds for the identifier.
      */
     Symbol resolveIdent(DiagnosticPosition pos, Env<AttrContext> env,
                         Name name, KindSelector kind) {
         return accessBase(
-            findIdent(env, name, kind),
+            findIdent(pos, env, name, kind),
             pos, env.enclClass.sym.type, name, false);
     }
 
     /** Resolve an unqualified method identifier.
      *  @param pos       The position to use for error reporting.
@@ -2795,10 +2823,11 @@
         Symbol sym = findMethod(env, site,
                                     names.init, argtypes,
                                     typeargtypes, allowBoxing,
                                     useVarargs);
         chk.checkDeprecated(pos, env.info.scope.owner, sym);
+        chk.checkPreview(pos, sym);
         return sym;
     }
 
     /** Resolve constructor using diamond inference.
      *  @param pos       The position to use for error reporting.
@@ -3199,11 +3228,11 @@
         }
 
         @Override
         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
             if (boundRes.isSuccess() && !boundRes.hasKind(StaticKind.NON_STATIC)) {
-                //the first serach has at least one applicable static method
+                //the first search has at least one applicable static method
                 return boundRes;
             } else if (unboundRes.isSuccess() && !unboundRes.hasKind(StaticKind.STATIC)) {
                 //the second search has at least one applicable non-static method
                 return unboundRes;
             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
@@ -3831,18 +3860,20 @@
             else
                 return sym;
         }
     }
 
-    class BadVarTypeError extends ResolveError {
-        BadVarTypeError() {
-            super(Kind.BAD_VAR, "bad var use");
+    class BadRestrictedTypeError extends ResolveError {
+        private final Name typeName;
+        BadRestrictedTypeError(Name typeName) {
+            super(Kind.BAD_RESTRICTED_TYPE, "bad var use");
+            this.typeName = typeName;
         }
 
         @Override
         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List<Type> argtypes, List<Type> typeargtypes) {
-            return diags.create(dkind, log.currentSource(), pos, "illegal.ref.to.var.type");
+            return diags.create(dkind, log.currentSource(), pos, "illegal.ref.to.restricted.type", typeName);
         }
     }
 
     /**
      * InvalidSymbolError error class indicating that a symbol matching a
@@ -4560,11 +4591,11 @@
          * A diagnostic rewriter transforms a method resolution diagnostic
          * into a simpler one
          */
         interface DiagnosticRewriter {
             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
-                    DiagnosticPosition preferedPos, DiagnosticSource preferredSource,
+                    DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
                     DiagnosticType preferredKind, JCDiagnostic d);
         }
 
         /**
          * A diagnostic template is made up of two ingredients: (i) a regular
@@ -4616,16 +4647,16 @@
                 this.causeIndex = causeIndex;
             }
 
             @Override
             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
-                    DiagnosticPosition preferedPos, DiagnosticSource preferredSource,
+                    DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
                     DiagnosticType preferredKind, JCDiagnostic d) {
                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
                 DiagnosticPosition pos = d.getDiagnosticPosition();
                 if (pos == null) {
-                    pos = preferedPos;
+                    pos = preferredPos;
                 }
                 return diags.create(preferredKind, preferredSource, pos,
                         "prob.found.req", cause);
             }
         }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.util.Collection;
 29 import java.util.Collections;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.LinkedHashMap;
 33 import java.util.Map;
 34 
 35 import javax.lang.model.element.ElementVisitor;
 36 
 37 import com.sun.tools.javac.code.Scope.WriteableScope;
 38 import com.sun.tools.javac.code.Source.Feature;
 39 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 40 import com.sun.tools.javac.code.Symbol.Completer;
 41 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 42 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 43 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 44 import com.sun.tools.javac.code.Symbol.PackageSymbol;
<a name="2" id="anc2"></a>
 45 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 46 import com.sun.tools.javac.code.Symbol.VarSymbol;
 47 import com.sun.tools.javac.code.Type.BottomType;
 48 import com.sun.tools.javac.code.Type.ClassType;
 49 import com.sun.tools.javac.code.Type.ErrorType;
 50 import com.sun.tools.javac.code.Type.JCPrimitiveType;
 51 import com.sun.tools.javac.code.Type.JCVoidType;
 52 import com.sun.tools.javac.code.Type.MethodType;
 53 import com.sun.tools.javac.code.Type.UnknownType;
 54 import com.sun.tools.javac.code.Types.UniqueType;
 55 import com.sun.tools.javac.comp.Modules;
 56 import com.sun.tools.javac.util.Assert;
 57 import com.sun.tools.javac.util.Context;
 58 import com.sun.tools.javac.util.Convert;
 59 import com.sun.tools.javac.util.DefinedBy;
 60 import com.sun.tools.javac.util.DefinedBy.Api;
 61 import com.sun.tools.javac.util.Iterators;
 62 import com.sun.tools.javac.util.JavacMessages;
 63 import com.sun.tools.javac.util.List;
 64 import com.sun.tools.javac.util.Name;
 65 import com.sun.tools.javac.util.Names;
 66 
 67 import static com.sun.tools.javac.code.Flags.*;
 68 import static com.sun.tools.javac.code.Kinds.Kind.*;
 69 import static com.sun.tools.javac.code.TypeTag.*;
 70 
 71 /** A class that defines all predefined constants and operators
 72  *  as well as special classes such as java.lang.Object, which need
 73  *  to be known to the compiler. All symbols are held in instance
 74  *  fields. This makes it possible to work in multiple concurrent
 75  *  projects, which might use different class files for library classes.
 76  *
 77  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 78  *  If you write code that depends on this, you do so at your own risk.
 79  *  This code and its internal interfaces are subject to change or
 80  *  deletion without notice.&lt;/b&gt;
 81  */
 82 public class Symtab {
 83     /** The context key for the symbol table. */
 84     protected static final Context.Key&lt;Symtab&gt; symtabKey = new Context.Key&lt;&gt;();
 85 
 86     /** Get the symbol table instance. */
 87     public static Symtab instance(Context context) {
 88         Symtab instance = context.get(symtabKey);
 89         if (instance == null)
 90             instance = new Symtab(context);
 91         return instance;
 92     }
 93 
 94     /** Builtin types.
 95      */
 96     public final JCPrimitiveType byteType = new JCPrimitiveType(BYTE, null);
 97     public final JCPrimitiveType charType = new JCPrimitiveType(CHAR, null);
 98     public final JCPrimitiveType shortType = new JCPrimitiveType(SHORT, null);
 99     public final JCPrimitiveType intType = new JCPrimitiveType(INT, null);
100     public final JCPrimitiveType longType = new JCPrimitiveType(LONG, null);
101     public final JCPrimitiveType floatType = new JCPrimitiveType(FLOAT, null);
102     public final JCPrimitiveType doubleType = new JCPrimitiveType(DOUBLE, null);
103     public final JCPrimitiveType booleanType = new JCPrimitiveType(BOOLEAN, null);
104     public final Type botType = new BottomType();
105     public final JCVoidType voidType = new JCVoidType();
106 
107     private final Names names;
108     private final JavacMessages messages;
109     private final Completer initialCompleter;
110     private final Completer moduleCompleter;
111 
112     /** A symbol for the unnamed module.
113      */
114     public final ModuleSymbol unnamedModule;
115 
116     /** The error module.
117      */
118     public final ModuleSymbol errModule;
119 
120     /** A symbol for no module, for use with -source 8 or less
121      */
122     public final ModuleSymbol noModule;
123 
124     /** A symbol for the root package.
125      */
126     public final PackageSymbol rootPackage;
127 
128     /** A symbol that stands for a missing symbol.
129      */
130     public final TypeSymbol noSymbol;
131 
132     /** The error symbol.
133      */
134     public final ClassSymbol errSymbol;
135 
136     /** The unknown symbol.
137      */
138     public final ClassSymbol unknownSymbol;
139 
140     /** A value for the errType, with a originalType of noType */
141     public final Type errType;
142 
143     /** A value for the unknown type. */
144     public final Type unknownType;
145 
146     /** The builtin type of all arrays. */
147     public final ClassSymbol arrayClass;
148     public final MethodSymbol arrayCloneMethod;
149 
150     /** VGJ: The (singleton) type of all bound types. */
151     public final ClassSymbol boundClass;
152 
153     /** The builtin type of all methods. */
154     public final ClassSymbol methodClass;
155 
156     /** A symbol for the java.base module.
157      */
158     public final ModuleSymbol java_base;
159 
160     /** Predefined types.
161      */
162     public final Type objectType;
<a name="3" id="anc3"></a>
163     public final Type objectsType;
164     public final Type classType;
165     public final Type classLoaderType;
166     public final Type stringType;
167     public final Type stringBufferType;
168     public final Type stringBuilderType;
169     public final Type cloneableType;
170     public final Type serializableType;
171     public final Type serializedLambdaType;
172     public final Type varHandleType;
173     public final Type methodHandleType;
174     public final Type methodHandleLookupType;
175     public final Type methodTypeType;
176     public final Type nativeHeaderType;
177     public final Type throwableType;
178     public final Type errorType;
179     public final Type interruptedExceptionType;
180     public final Type illegalArgumentExceptionType;
181     public final Type exceptionType;
182     public final Type runtimeExceptionType;
183     public final Type classNotFoundExceptionType;
184     public final Type noClassDefFoundErrorType;
185     public final Type noSuchFieldErrorType;
186     public final Type assertionErrorType;
187     public final Type incompatibleClassChangeErrorType;
188     public final Type cloneNotSupportedExceptionType;
189     public final Type annotationType;
190     public final TypeSymbol enumSym;
191     public final Type listType;
192     public final Type collectionsType;
193     public final Type comparableType;
194     public final Type comparatorType;
195     public final Type arraysType;
196     public final Type iterableType;
197     public final Type iteratorType;
198     public final Type annotationTargetType;
199     public final Type overrideType;
200     public final Type retentionType;
201     public final Type deprecatedType;
202     public final Type suppressWarningsType;
203     public final Type supplierType;
204     public final Type inheritedType;
205     public final Type profileType;
206     public final Type proprietaryType;
207     public final Type systemType;
208     public final Type autoCloseableType;
209     public final Type trustMeType;
210     public final Type lambdaMetafactory;
211     public final Type stringConcatFactory;
212     public final Type repeatableType;
213     public final Type documentedType;
214     public final Type elementTypeType;
215     public final Type functionalInterfaceType;
<a name="4" id="anc4"></a>


216 
217     /** The symbol representing the length field of an array.
218      */
219     public final VarSymbol lengthVar;
220 
221     /** The symbol representing the final finalize method on enums */
222     public final MethodSymbol enumFinalFinalize;
223 
224     /** The symbol representing the close method on TWR AutoCloseable type */
225     public final MethodSymbol autoCloseableClose;
226 
227     /** The predefined type that belongs to a tag.
228      */
229     public final Type[] typeOfTag = new Type[TypeTag.getTypeTagCount()];
230 
231     /** The name of the class that belongs to a basic type tag.
232      */
233     public final Name[] boxedName = new Name[TypeTag.getTypeTagCount()];
234 
235     /** A hashtable containing the encountered top-level and member classes,
236      *  indexed by flat names. The table does not contain local classes.
237      *  It should be updated from the outside to reflect classes defined
238      *  by compiled source files.
239      */
240     private final Map&lt;Name, Map&lt;ModuleSymbol,ClassSymbol&gt;&gt; classes = new HashMap&lt;&gt;();
241 
242     /** A hashtable containing the encountered packages.
243      *  the table should be updated from outside to reflect packages defined
244      *  by compiled source files.
245      */
246     private final Map&lt;Name, Map&lt;ModuleSymbol,PackageSymbol&gt;&gt; packages = new HashMap&lt;&gt;();
247 
248     /** A hashtable giving the encountered modules.
249      */
250     private final Map&lt;Name, ModuleSymbol&gt; modules = new LinkedHashMap&lt;&gt;();
251 
252     private final Map&lt;Types.UniqueType, VarSymbol&gt; classFields = new HashMap&lt;&gt;();
253 
254     public VarSymbol getClassField(Type type, Types types) {
255         return classFields.computeIfAbsent(
256             new UniqueType(type, types), k -&gt; {
257                 Type arg = null;
258                 if (type.getTag() == ARRAY || type.getTag() == CLASS)
259                     arg = types.erasure(type);
260                 else if (type.isPrimitiveOrVoid())
261                     arg = types.boxedClass(type).type;
262                 else
263                     throw new AssertionError(type);
264 
265                 Type t = new ClassType(
266                     classType.getEnclosingType(), List.of(arg), classType.tsym);
267                 return new VarSymbol(
268                     STATIC | PUBLIC | FINAL, names._class, t, type.tsym);
269             });
270     }
271 
272     public void initType(Type type, ClassSymbol c) {
273         type.tsym = c;
274         typeOfTag[type.getTag().ordinal()] = type;
275     }
276 
277     public void initType(Type type, String name) {
278         initType(
279             type,
280             new ClassSymbol(
281                 PUBLIC, names.fromString(name), type, rootPackage));
282     }
283 
284     public void initType(Type type, String name, String bname) {
285         initType(type, name);
286         boxedName[type.getTag().ordinal()] = names.fromString(&quot;java.lang.&quot; + bname);
287     }
288 
289     /** The class symbol that owns all predefined symbols.
290      */
291     public final ClassSymbol predefClass;
292 
293     /** Enter a class into symbol table.
294      *  @param s The name of the class.
295      */
296     private Type enterClass(String s) {
297         return enterClass(java_base, names.fromString(s)).type;
298     }
299 
300     public void synthesizeEmptyInterfaceIfMissing(final Type type) {
301         final Completer completer = type.tsym.completer;
302         type.tsym.completer = new Completer() {
303             @Override
304             public void complete(Symbol sym) throws CompletionFailure {
305                 try {
306                     completer.complete(sym);
307                 } catch (CompletionFailure e) {
308                     sym.flags_field |= (PUBLIC | INTERFACE);
309                     ((ClassType) sym.type).supertype_field = objectType;
310                 }
311             }
312 
313             @Override
314             public boolean isTerminal() {
315                 return completer.isTerminal();
316             }
317         };
318     }
319 
320     public void synthesizeBoxTypeIfMissing(final Type type) {
321         ClassSymbol sym = enterClass(java_base, boxedName[type.getTag().ordinal()]);
322         final Completer completer = sym.completer;
323         sym.completer = new Completer() {
324             @Override
325             public void complete(Symbol sym) throws CompletionFailure {
326                 try {
327                     completer.complete(sym);
328                 } catch (CompletionFailure e) {
329                     sym.flags_field |= PUBLIC;
330                     ((ClassType) sym.type).supertype_field = objectType;
331                     MethodSymbol boxMethod =
332                         new MethodSymbol(PUBLIC | STATIC, names.valueOf,
333                                          new MethodType(List.of(type), sym.type,
334                                 List.nil(), methodClass),
335                             sym);
336                     sym.members().enter(boxMethod);
337                     MethodSymbol unboxMethod =
338                         new MethodSymbol(PUBLIC,
339                             type.tsym.name.append(names.Value), // x.intValue()
340                             new MethodType(List.nil(), type,
341                                 List.nil(), methodClass),
342                             sym);
343                     sym.members().enter(unboxMethod);
344                 }
345             }
346 
347             @Override
348             public boolean isTerminal() {
349                 return completer.isTerminal();
350             }
351         };
352     }
353 
354     // Enter a synthetic class that is used to mark classes in ct.sym.
355     // This class does not have a class file.
356     private Type enterSyntheticAnnotation(String name) {
357         // for now, leave the module null, to prevent problems from synthesizing the
358         // existence of a class in any specific module, including noModule
359         ClassType type = (ClassType)enterClass(java_base, names.fromString(name)).type;
360         ClassSymbol sym = (ClassSymbol)type.tsym;
361         sym.completer = Completer.NULL_COMPLETER;
362         sym.flags_field = PUBLIC|ACYCLIC|ANNOTATION|INTERFACE;
363         sym.erasure_field = type;
364         sym.members_field = WriteableScope.create(sym);
365         type.typarams_field = List.nil();
366         type.allparams_field = List.nil();
367         type.supertype_field = annotationType;
368         type.interfaces_field = List.nil();
369         return type;
370     }
371 
372     /** Constructor; enters all predefined identifiers and operators
373      *  into symbol table.
374      */
375     protected Symtab(Context context) throws CompletionFailure {
376         context.put(symtabKey, this);
377 
378         names = Names.instance(context);
379 
380         // Create the unknown type
381         unknownType = new UnknownType();
382 
383         messages = JavacMessages.instance(context);
384 
<a name="5" id="anc5"></a><span class="line-modified">385         rootPackage = new PackageSymbol(names.empty, null);</span>


386 
387         // create the basic builtin symbols
388         unnamedModule = new ModuleSymbol(names.empty, null) {
389                 {
390                     directives = List.nil();
391                     exports = List.nil();
392                     provides = List.nil();
393                     uses = List.nil();
394                     ModuleSymbol java_base = enterModule(names.java_base);
395                     com.sun.tools.javac.code.Directive.RequiresDirective d =
396                             new com.sun.tools.javac.code.Directive.RequiresDirective(java_base,
397                                     EnumSet.of(com.sun.tools.javac.code.Directive.RequiresFlag.MANDATED));
398                     requires = List.of(d);
399                 }
400                 @Override
401                 public String toString() {
402                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.module&quot;);
403                 }
404             };
405         addRootPackageFor(unnamedModule);
406         unnamedModule.enclosedPackages = unnamedModule.enclosedPackages.prepend(unnamedModule.unnamedPackage);
407 
408         errModule = new ModuleSymbol(names.empty, null) {
409                 {
410                     directives = List.nil();
411                     exports = List.nil();
412                     provides = List.nil();
413                     uses = List.nil();
414                     ModuleSymbol java_base = enterModule(names.java_base);
415                     com.sun.tools.javac.code.Directive.RequiresDirective d =
416                             new com.sun.tools.javac.code.Directive.RequiresDirective(java_base,
417                                     EnumSet.of(com.sun.tools.javac.code.Directive.RequiresFlag.MANDATED));
418                     requires = List.of(d);
419                 }
420             };
421         addRootPackageFor(errModule);
422 
423         noModule = new ModuleSymbol(names.empty, null) {
424             @Override public boolean isNoModule() {
425                 return true;
426             }
427         };
428         addRootPackageFor(noModule);
429 
430         noSymbol = new TypeSymbol(NIL, 0, names.empty, Type.noType, rootPackage) {
431             @Override @DefinedBy(Api.LANGUAGE_MODEL)
432             public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
433                 return v.visitUnknown(this, p);
434             }
435         };
436 
437         // create the error symbols
438         errSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.any, null, rootPackage);
439         errType = new ErrorType(errSymbol, Type.noType);
440 
441         unknownSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.fromString(&quot;&lt;any?&gt;&quot;), null, rootPackage);
442         unknownSymbol.members_field = new Scope.ErrorScope(unknownSymbol);
443         unknownSymbol.type = unknownType;
444 
445         // initialize builtin types
446         initType(byteType, &quot;byte&quot;, &quot;Byte&quot;);
447         initType(shortType, &quot;short&quot;, &quot;Short&quot;);
448         initType(charType, &quot;char&quot;, &quot;Character&quot;);
449         initType(intType, &quot;int&quot;, &quot;Integer&quot;);
450         initType(longType, &quot;long&quot;, &quot;Long&quot;);
451         initType(floatType, &quot;float&quot;, &quot;Float&quot;);
452         initType(doubleType, &quot;double&quot;, &quot;Double&quot;);
453         initType(booleanType, &quot;boolean&quot;, &quot;Boolean&quot;);
454         initType(voidType, &quot;void&quot;, &quot;Void&quot;);
455         initType(botType, &quot;&lt;nulltype&gt;&quot;);
456         initType(errType, errSymbol);
457         initType(unknownType, unknownSymbol);
458 
459         // the builtin class of all arrays
460         arrayClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Array, noSymbol);
461 
462         // VGJ
463         boundClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Bound, noSymbol);
464         boundClass.members_field = new Scope.ErrorScope(boundClass);
465 
466         // the builtin class of all methods
467         methodClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Method, noSymbol);
468         methodClass.members_field = new Scope.ErrorScope(boundClass);
469 
470         // Create class to hold all predefined constants and operations.
471         predefClass = new ClassSymbol(PUBLIC|ACYCLIC, names.empty, rootPackage);
472         WriteableScope scope = WriteableScope.create(predefClass);
473         predefClass.members_field = scope;
474 
475         // Get the initial completer for Symbols from the ClassFinder
476         initialCompleter = ClassFinder.instance(context).getCompleter();
477         rootPackage.members_field = WriteableScope.create(rootPackage);
478 
479         // Enter symbols for basic types.
480         scope.enter(byteType.tsym);
481         scope.enter(shortType.tsym);
482         scope.enter(charType.tsym);
483         scope.enter(intType.tsym);
484         scope.enter(longType.tsym);
485         scope.enter(floatType.tsym);
486         scope.enter(doubleType.tsym);
487         scope.enter(booleanType.tsym);
488         scope.enter(errType.tsym);
489 
490         // Enter symbol for the errSymbol
491         scope.enter(errSymbol);
492 
493         Source source = Source.instance(context);
494         if (Feature.MODULES.allowedInSource(source)) {
495             java_base = enterModule(names.java_base);
496             //avoid completing java.base during the Symtab initialization
497             java_base.completer = Completer.NULL_COMPLETER;
498             java_base.visiblePackages = Collections.emptyMap();
499         } else {
500             java_base = noModule;
501         }
502 
503         // Get the initial completer for ModuleSymbols from Modules
504         moduleCompleter = Modules.instance(context).getCompleter();
505 
506         // Enter predefined classes. All are assumed to be in the java.base module.
507         objectType = enterClass(&quot;java.lang.Object&quot;);
<a name="6" id="anc6"></a>
508         objectsType = enterClass(&quot;java.util.Objects&quot;);
509         classType = enterClass(&quot;java.lang.Class&quot;);
510         stringType = enterClass(&quot;java.lang.String&quot;);
511         stringBufferType = enterClass(&quot;java.lang.StringBuffer&quot;);
512         stringBuilderType = enterClass(&quot;java.lang.StringBuilder&quot;);
513         cloneableType = enterClass(&quot;java.lang.Cloneable&quot;);
514         throwableType = enterClass(&quot;java.lang.Throwable&quot;);
515         serializableType = enterClass(&quot;java.io.Serializable&quot;);
516         serializedLambdaType = enterClass(&quot;java.lang.invoke.SerializedLambda&quot;);
517         varHandleType = enterClass(&quot;java.lang.invoke.VarHandle&quot;);
518         methodHandleType = enterClass(&quot;java.lang.invoke.MethodHandle&quot;);
519         methodHandleLookupType = enterClass(&quot;java.lang.invoke.MethodHandles$Lookup&quot;);
520         methodTypeType = enterClass(&quot;java.lang.invoke.MethodType&quot;);
521         errorType = enterClass(&quot;java.lang.Error&quot;);
522         illegalArgumentExceptionType = enterClass(&quot;java.lang.IllegalArgumentException&quot;);
523         interruptedExceptionType = enterClass(&quot;java.lang.InterruptedException&quot;);
524         exceptionType = enterClass(&quot;java.lang.Exception&quot;);
525         runtimeExceptionType = enterClass(&quot;java.lang.RuntimeException&quot;);
526         classNotFoundExceptionType = enterClass(&quot;java.lang.ClassNotFoundException&quot;);
527         noClassDefFoundErrorType = enterClass(&quot;java.lang.NoClassDefFoundError&quot;);
528         noSuchFieldErrorType = enterClass(&quot;java.lang.NoSuchFieldError&quot;);
529         assertionErrorType = enterClass(&quot;java.lang.AssertionError&quot;);
530         incompatibleClassChangeErrorType = enterClass(&quot;java.lang.IncompatibleClassChangeError&quot;);
531         cloneNotSupportedExceptionType = enterClass(&quot;java.lang.CloneNotSupportedException&quot;);
532         annotationType = enterClass(&quot;java.lang.annotation.Annotation&quot;);
533         classLoaderType = enterClass(&quot;java.lang.ClassLoader&quot;);
534         enumSym = enterClass(java_base, names.java_lang_Enum);
535         enumFinalFinalize =
536             new MethodSymbol(PROTECTED|FINAL|HYPOTHETICAL,
537                              names.finalize,
538                              new MethodType(List.nil(), voidType,
539                                             List.nil(), methodClass),
540                              enumSym);
541         listType = enterClass(&quot;java.util.List&quot;);
542         collectionsType = enterClass(&quot;java.util.Collections&quot;);
543         comparableType = enterClass(&quot;java.lang.Comparable&quot;);
544         comparatorType = enterClass(&quot;java.util.Comparator&quot;);
545         arraysType = enterClass(&quot;java.util.Arrays&quot;);
546         iterableType = enterClass(&quot;java.lang.Iterable&quot;);
547         iteratorType = enterClass(&quot;java.util.Iterator&quot;);
548         annotationTargetType = enterClass(&quot;java.lang.annotation.Target&quot;);
549         overrideType = enterClass(&quot;java.lang.Override&quot;);
550         retentionType = enterClass(&quot;java.lang.annotation.Retention&quot;);
551         deprecatedType = enterClass(&quot;java.lang.Deprecated&quot;);
552         suppressWarningsType = enterClass(&quot;java.lang.SuppressWarnings&quot;);
553         supplierType = enterClass(&quot;java.util.function.Supplier&quot;);
554         inheritedType = enterClass(&quot;java.lang.annotation.Inherited&quot;);
555         repeatableType = enterClass(&quot;java.lang.annotation.Repeatable&quot;);
556         documentedType = enterClass(&quot;java.lang.annotation.Documented&quot;);
557         elementTypeType = enterClass(&quot;java.lang.annotation.ElementType&quot;);
558         systemType = enterClass(&quot;java.lang.System&quot;);
559         autoCloseableType = enterClass(&quot;java.lang.AutoCloseable&quot;);
560         autoCloseableClose = new MethodSymbol(PUBLIC,
561                              names.close,
562                              new MethodType(List.nil(), voidType,
563                                             List.of(exceptionType), methodClass),
564                              autoCloseableType.tsym);
565         trustMeType = enterClass(&quot;java.lang.SafeVarargs&quot;);
566         nativeHeaderType = enterClass(&quot;java.lang.annotation.Native&quot;);
567         lambdaMetafactory = enterClass(&quot;java.lang.invoke.LambdaMetafactory&quot;);
568         stringConcatFactory = enterClass(&quot;java.lang.invoke.StringConcatFactory&quot;);
569         functionalInterfaceType = enterClass(&quot;java.lang.FunctionalInterface&quot;);
<a name="7" id="anc7"></a>


570 
571         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
572         synthesizeEmptyInterfaceIfMissing(cloneableType);
573         synthesizeEmptyInterfaceIfMissing(serializableType);
574         synthesizeEmptyInterfaceIfMissing(lambdaMetafactory);
575         synthesizeEmptyInterfaceIfMissing(serializedLambdaType);
576         synthesizeEmptyInterfaceIfMissing(stringConcatFactory);
577         synthesizeBoxTypeIfMissing(doubleType);
578         synthesizeBoxTypeIfMissing(floatType);
579         synthesizeBoxTypeIfMissing(voidType);
580 
581         // Enter a synthetic class that is used to mark internal
582         // proprietary classes in ct.sym.  This class does not have a
583         // class file.
584         proprietaryType = enterSyntheticAnnotation(&quot;sun.Proprietary+Annotation&quot;);
585 
586         // Enter a synthetic class that is used to provide profile info for
587         // classes in ct.sym.  This class does not have a class file.
588         profileType = enterSyntheticAnnotation(&quot;jdk.Profile+Annotation&quot;);
589         MethodSymbol m = new MethodSymbol(PUBLIC | ABSTRACT, names.value, intType, profileType.tsym);
590         profileType.tsym.members().enter(m);
591 
592         // Enter a class for arrays.
593         // The class implements java.lang.Cloneable and java.io.Serializable.
594         // It has a final length field and a clone method.
595         ClassType arrayClassType = (ClassType)arrayClass.type;
596         arrayClassType.supertype_field = objectType;
597         arrayClassType.interfaces_field = List.of(cloneableType, serializableType);
598         arrayClass.members_field = WriteableScope.create(arrayClass);
599         lengthVar = new VarSymbol(
600             PUBLIC | FINAL,
601             names.length,
602             intType,
603             arrayClass);
604         arrayClass.members().enter(lengthVar);
605         arrayCloneMethod = new MethodSymbol(
606             PUBLIC,
607             names.clone,
608             new MethodType(List.nil(), objectType,
609                            List.nil(), methodClass),
610             arrayClass);
611         arrayClass.members().enter(arrayCloneMethod);
612 
613         if (java_base != noModule)
614             java_base.completer = moduleCompleter::complete; //bootstrap issues
615 
616     }
617 
618     /** Define a new class given its name and owner.
619      */
620     public ClassSymbol defineClass(Name name, Symbol owner) {
621         ClassSymbol c = new ClassSymbol(0, name, owner);
622         c.completer = initialCompleter;
623         return c;
624     }
625 
626     /** Create a new toplevel or member class symbol with given name
627      *  and owner and enter in `classes&#39; unless already there.
628      */
629     public ClassSymbol enterClass(ModuleSymbol msym, Name name, TypeSymbol owner) {
630         Assert.checkNonNull(msym);
631         Name flatname = TypeSymbol.formFlatName(name, owner);
632         ClassSymbol c = getClass(msym, flatname);
633         if (c == null) {
634             c = defineClass(name, owner);
635             doEnterClass(msym, c);
636         } else if ((c.name != name || c.owner != owner) &amp;&amp; owner.kind == TYP &amp;&amp; c.owner.kind == PCK) {
637             // reassign fields of classes that might have been loaded with
638             // their flat names.
639             c.owner.members().remove(c);
640             c.name = name;
641             c.owner = owner;
642             c.fullname = ClassSymbol.formFullName(name, owner);
643         }
644         return c;
645     }
646 
647     public ClassSymbol getClass(ModuleSymbol msym, Name flatName) {
648         Assert.checkNonNull(msym, flatName::toString);
649         return classes.getOrDefault(flatName, Collections.emptyMap()).get(msym);
650     }
651 
652     public PackageSymbol lookupPackage(ModuleSymbol msym, Name flatName) {
653         Assert.checkNonNull(msym);
654 
655         if (flatName.isEmpty()) {
656             //unnamed packages only from the current module - visiblePackages contains *root* package, not unnamed package!
657             return msym.unnamedPackage;
658         }
659 
660         if (msym == noModule) {
661             return enterPackage(msym, flatName);
662         }
663 
664         msym.complete();
665 
666         PackageSymbol pack;
667 
668         pack = msym.visiblePackages.get(flatName);
669 
670         if (pack != null)
671             return pack;
672 
673         pack = getPackage(msym, flatName);
674 
675         if (pack != null &amp;&amp; pack.exists())
676             return pack;
677 
678         boolean dependsOnUnnamed = msym.requires != null &amp;&amp;
679                                    msym.requires.stream()
680                                                 .map(rd -&gt; rd.module)
681                                                 .anyMatch(mod -&gt; mod == unnamedModule);
682 
683         if (dependsOnUnnamed) {
684             //msyms depends on the unnamed module, for which we generally don&#39;t know
685             //the list of packages it &quot;exports&quot; ahead of time. So try to lookup the package in the
686             //current module, and in the unnamed module and see if it exists in one of them
687             PackageSymbol unnamedPack = getPackage(unnamedModule, flatName);
688 
689             if (unnamedPack != null &amp;&amp; unnamedPack.exists()) {
690                 msym.visiblePackages.put(unnamedPack.fullname, unnamedPack);
691                 return unnamedPack;
692             }
693 
694             pack = enterPackage(msym, flatName);
695             pack.complete();
696             if (pack.exists())
697                 return pack;
698 
699             unnamedPack = enterPackage(unnamedModule, flatName);
700             unnamedPack.complete();
701             if (unnamedPack.exists()) {
702                 msym.visiblePackages.put(unnamedPack.fullname, unnamedPack);
703                 return unnamedPack;
704             }
705 
706             return pack;
707         }
708 
709         return enterPackage(msym, flatName);
710     }
711 
712     private static final Map&lt;ModuleSymbol, ClassSymbol&gt; EMPTY = new HashMap&lt;&gt;();
713 
714     public void removeClass(ModuleSymbol msym, Name flatName) {
715         classes.getOrDefault(flatName, EMPTY).remove(msym);
716     }
717 
718     public Iterable&lt;ClassSymbol&gt; getAllClasses() {
719         return () -&gt; Iterators.createCompoundIterator(classes.values(), v -&gt; v.values().iterator());
720     }
721 
722     private void doEnterClass(ModuleSymbol msym, ClassSymbol cs) {
723         classes.computeIfAbsent(cs.flatname, n -&gt; new HashMap&lt;&gt;()).put(msym, cs);
724     }
725 
726     /** Create a new member or toplevel class symbol with given flat name
727      *  and enter in `classes&#39; unless already there.
728      */
729     public ClassSymbol enterClass(ModuleSymbol msym, Name flatname) {
730         Assert.checkNonNull(msym);
731         PackageSymbol ps = lookupPackage(msym, Convert.packagePart(flatname));
732         Assert.checkNonNull(ps);
733         Assert.checkNonNull(ps.modle);
734         ClassSymbol c = getClass(ps.modle, flatname);
735         if (c == null) {
736             c = defineClass(Convert.shortName(flatname), ps);
737             doEnterClass(ps.modle, c);
738             return c;
739         } else
740             return c;
741     }
742 
743     /** Check to see if a package exists, given its fully qualified name.
744      */
745     public boolean packageExists(ModuleSymbol msym, Name fullname) {
746         Assert.checkNonNull(msym);
747         return lookupPackage(msym, fullname).exists();
748     }
749 
750     /** Make a package, given its fully qualified name.
751      */
752     public PackageSymbol enterPackage(ModuleSymbol currModule, Name fullname) {
753         Assert.checkNonNull(currModule);
754         PackageSymbol p = getPackage(currModule, fullname);
755         if (p == null) {
756             Assert.check(!fullname.isEmpty(), () -&gt; &quot;rootPackage missing!; currModule: &quot; + currModule);
757             p = new PackageSymbol(
758                     Convert.shortName(fullname),
759                     enterPackage(currModule, Convert.packagePart(fullname)));
760             p.completer = initialCompleter;
761             p.modle = currModule;
762             doEnterPackage(currModule, p);
763         }
764         return p;
765     }
766 
767     private void doEnterPackage(ModuleSymbol msym, PackageSymbol pack) {
768         packages.computeIfAbsent(pack.fullname, n -&gt; new HashMap&lt;&gt;()).put(msym, pack);
769         msym.enclosedPackages = msym.enclosedPackages.prepend(pack);
770     }
771 
772     private void addRootPackageFor(ModuleSymbol module) {
773         doEnterPackage(module, rootPackage);
774         PackageSymbol unnamedPackage = new PackageSymbol(names.empty, rootPackage) {
775                 @Override
776                 public String toString() {
777                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.package&quot;);
778                 }
779             };
780         unnamedPackage.modle = module;
781         //we cannot use a method reference below, as initialCompleter might be null now
782         unnamedPackage.completer = s -&gt; initialCompleter.complete(s);
<a name="8" id="anc8"></a>
783         module.unnamedPackage = unnamedPackage;
784     }
785 
786     public PackageSymbol getPackage(ModuleSymbol module, Name fullname) {
787         return packages.getOrDefault(fullname, Collections.emptyMap()).get(module);
788     }
789 
790     public ModuleSymbol enterModule(Name name) {
791         ModuleSymbol msym = modules.get(name);
792         if (msym == null) {
793             msym = ModuleSymbol.create(name, names.module_info);
794             addRootPackageFor(msym);
795             msym.completer = s -&gt; moduleCompleter.complete(s); //bootstrap issues
796             modules.put(name, msym);
797         }
798         return msym;
799     }
800 
801     public ModuleSymbol getModule(Name name) {
802         return modules.get(name);
803     }
804 
805     //temporary:
806     public ModuleSymbol inferModule(Name packageName) {
807         if (packageName.isEmpty())
808             return java_base == noModule ? noModule : unnamedModule;//!
809 
810         ModuleSymbol msym = null;
811         Map&lt;ModuleSymbol,PackageSymbol&gt; map = packages.get(packageName);
812         if (map == null)
813             return null;
814         for (Map.Entry&lt;ModuleSymbol,PackageSymbol&gt; e: map.entrySet()) {
815             if (!e.getValue().members().isEmpty()) {
816                 if (msym == null) {
817                     msym = e.getKey();
818                 } else {
819                     return null;
820                 }
821             }
822         }
823         return msym;
824     }
825 
826     public List&lt;ModuleSymbol&gt; listPackageModules(Name packageName) {
827         if (packageName.isEmpty())
828             return List.nil();
829 
830         List&lt;ModuleSymbol&gt; result = List.nil();
831         Map&lt;ModuleSymbol,PackageSymbol&gt; map = packages.get(packageName);
832         if (map != null) {
833             for (Map.Entry&lt;ModuleSymbol, PackageSymbol&gt; e: map.entrySet()) {
834                 if (!e.getValue().members().isEmpty()) {
835                     result = result.prepend(e.getKey());
836                 }
837             }
838         }
839         return result;
840     }
841 
842     public Collection&lt;ModuleSymbol&gt; getAllModules() {
843         return modules.values();
844     }
845 
846     public Iterable&lt;ClassSymbol&gt; getClassesForName(Name candidate) {
847         return classes.getOrDefault(candidate, Collections.emptyMap()).values();
848     }
849 
850     public Iterable&lt;PackageSymbol&gt; getPackagesForName(Name candidate) {
851         return packages.getOrDefault(candidate, Collections.emptyMap()).values();
852     }
853 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
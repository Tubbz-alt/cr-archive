<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassFile.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 34,11 ---</span>
  import java.util.EnumSet;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.Map;
  import java.util.Set;
<span class="line-added">+ import java.util.function.IntFunction;</span>
  
  import javax.lang.model.element.Modifier;
  import javax.lang.model.element.NestingKind;
  import javax.tools.JavaFileManager;
  import javax.tools.JavaFileObject;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,12 ***</span>
  import com.sun.tools.javac.code.Symtab;
  import com.sun.tools.javac.code.Type.*;
  import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  import com.sun.tools.javac.file.BaseFileManager;
  import com.sun.tools.javac.file.PathFileObject;
<span class="line-removed">- import com.sun.tools.javac.jvm.ClassFile.NameAndType;</span>
  import com.sun.tools.javac.jvm.ClassFile.Version;
  import com.sun.tools.javac.main.Option;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.DefinedBy.Api;
<span class="line-new-header">--- 54,12 ---</span>
  import com.sun.tools.javac.code.Symtab;
  import com.sun.tools.javac.code.Type.*;
  import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  import com.sun.tools.javac.file.BaseFileManager;
  import com.sun.tools.javac.file.PathFileObject;
  import com.sun.tools.javac.jvm.ClassFile.Version;
<span class="line-added">+ import com.sun.tools.javac.jvm.PoolConstant.NameAndType;</span>
  import com.sun.tools.javac.main.Option;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.DefinedBy.Api;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,19 ***</span>
  
      /** Switch: verbose output.
       */
      boolean verbose;
  
<span class="line-removed">-     /** Switch: read constant pool and code sections. This switch is initially</span>
<span class="line-removed">-      *  set to false but can be turned on from outside.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     public boolean readAllOfClassFile = false;</span>
<span class="line-removed">- </span>
      /** Switch: allow modules.
       */
      boolean allowModules;
  
     /** Lint option: warn about classfile issues
       */
      boolean lintClassfile;
  
      /** Switch: preserve parameter names from the variable table.
<span class="line-new-header">--- 99,18 ---</span>
  
      /** Switch: verbose output.
       */
      boolean verbose;
  
      /** Switch: allow modules.
       */
      boolean allowModules;
  
<span class="line-added">+     /** Switch: allow records</span>
<span class="line-added">+      */</span>
<span class="line-added">+     boolean allowRecords;</span>
<span class="line-added">+ </span>
     /** Lint option: warn about classfile issues
       */
      boolean lintClassfile;
  
      /** Switch: preserve parameter names from the variable table.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,24 ***</span>
       */
      protected ModuleSymbol currentModule = null;
  
      /** The buffer containing the currently read class file.
       */
<span class="line-modified">!     byte[] buf = new byte[INITIAL_BUFFER_SIZE];</span>
  
      /** The current input pointer.
       */
      protected int bp;
  
<span class="line-modified">!     /** The objects of the constant pool.</span>
       */
<span class="line-modified">!     Object[] poolObj;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** For every constant pool entry, an index into buf where the</span>
<span class="line-removed">-      *  defining section of the entry is found.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     int[] poolIdx;</span>
  
      /** The major version number of the class file being read. */
      int majorVersion;
      /** The minor version number of the class file being read. */
      int minorVersion;
<span class="line-new-header">--- 168,19 ---</span>
       */
      protected ModuleSymbol currentModule = null;
  
      /** The buffer containing the currently read class file.
       */
<span class="line-modified">!     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);</span>
  
      /** The current input pointer.
       */
      protected int bp;
  
<span class="line-modified">!     /** The pool reader.</span>
       */
<span class="line-modified">!     PoolReader poolReader;</span>
  
      /** The major version number of the class file being read. */
      int majorVersion;
      /** The minor version number of the class file being read. */
      int minorVersion;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,11 ***</span>
       * @Target
       */
      CompoundAnnotationProxy target;
  
      /**
<span class="line-modified">!      * The prototype @Repetable Attribute.Compound if this class is an annotation annotated with</span>
       * @Repeatable
       */
      CompoundAnnotationProxy repeatable;
  
      /** Get the ClassReader instance for this invocation. */
<span class="line-new-header">--- 232,11 ---</span>
       * @Target
       */
      CompoundAnnotationProxy target;
  
      /**
<span class="line-modified">!      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with</span>
       * @Repeatable
       */
      CompoundAnnotationProxy repeatable;
  
      /** Get the ClassReader instance for this invocation. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,10 ***</span>
<span class="line-new-header">--- 266,12 ---</span>
          verbose         = options.isSet(Option.VERBOSE);
  
          Source source = Source.instance(context);
          preview = Preview.instance(context);
          allowModules     = Feature.MODULES.allowedInSource(source);
<span class="line-added">+         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added">+                 Feature.RECORDS.allowedInSource(source);</span>
  
          saveParameterNames = options.isSet(PARAMETERS);
  
          profile = Profile.instance(context);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 321,298 ***</span>
   ***********************************************************************/
  
      /** Read a character.
       */
      char nextChar() {
<span class="line-modified">!         return (char)(((buf[bp++] &amp; 0xFF) &lt;&lt; 8) + (buf[bp++] &amp; 0xFF));</span>
      }
  
      /** Read a byte.
       */
      int nextByte() {
<span class="line-modified">!         return buf[bp++] &amp; 0xFF;</span>
      }
  
      /** Read an integer.
       */
      int nextInt() {
<span class="line-modified">!         return</span>
<span class="line-modified">!             ((buf[bp++] &amp; 0xFF) &lt;&lt; 24) +</span>
<span class="line-modified">!             ((buf[bp++] &amp; 0xFF) &lt;&lt; 16) +</span>
<span class="line-removed">-             ((buf[bp++] &amp; 0xFF) &lt;&lt; 8) +</span>
<span class="line-removed">-             (buf[bp++] &amp; 0xFF);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Extract a character at position bp from buf.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     char getChar(int bp) {</span>
<span class="line-removed">-         return</span>
<span class="line-removed">-             (char)(((buf[bp] &amp; 0xFF) &lt;&lt; 8) + (buf[bp+1] &amp; 0xFF));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Extract an integer at position bp from buf.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     int getInt(int bp) {</span>
<span class="line-removed">-         return</span>
<span class="line-removed">-             ((buf[bp] &amp; 0xFF) &lt;&lt; 24) +</span>
<span class="line-removed">-             ((buf[bp+1] &amp; 0xFF) &lt;&lt; 16) +</span>
<span class="line-removed">-             ((buf[bp+2] &amp; 0xFF) &lt;&lt; 8) +</span>
<span class="line-removed">-             (buf[bp+3] &amp; 0xFF);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Extract a long integer at position bp from buf.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     long getLong(int bp) {</span>
<span class="line-removed">-         DataInputStream bufin =</span>
<span class="line-removed">-             new DataInputStream(new ByteArrayInputStream(buf, bp, 8));</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             return bufin.readLong();</span>
<span class="line-removed">-         } catch (IOException e) {</span>
<span class="line-removed">-             throw new AssertionError(e);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Extract a float at position bp from buf.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     float getFloat(int bp) {</span>
<span class="line-removed">-         DataInputStream bufin =</span>
<span class="line-removed">-             new DataInputStream(new ByteArrayInputStream(buf, bp, 4));</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             return bufin.readFloat();</span>
<span class="line-removed">-         } catch (IOException e) {</span>
<span class="line-removed">-             throw new AssertionError(e);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Extract a double at position bp from buf.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     double getDouble(int bp) {</span>
<span class="line-removed">-         DataInputStream bufin =</span>
<span class="line-removed">-             new DataInputStream(new ByteArrayInputStream(buf, bp, 8));</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             return bufin.readDouble();</span>
<span class="line-removed">-         } catch (IOException e) {</span>
<span class="line-removed">-             throw new AssertionError(e);</span>
<span class="line-removed">-         }</span>
      }
  
  /************************************************************************
   * Constant Pool Access
   ***********************************************************************/
  
<span class="line-removed">-     /** Index all constant pool entries, writing their start addresses into</span>
<span class="line-removed">-      *  poolIdx.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     void indexPool() {</span>
<span class="line-removed">-         poolIdx = new int[nextChar()];</span>
<span class="line-removed">-         poolObj = new Object[poolIdx.length];</span>
<span class="line-removed">-         int i = 1;</span>
<span class="line-removed">-         while (i &lt; poolIdx.length) {</span>
<span class="line-removed">-             poolIdx[i++] = bp;</span>
<span class="line-removed">-             byte tag = buf[bp++];</span>
<span class="line-removed">-             switch (tag) {</span>
<span class="line-removed">-             case CONSTANT_Utf8: case CONSTANT_Unicode: {</span>
<span class="line-removed">-                 int len = nextChar();</span>
<span class="line-removed">-                 bp = bp + len;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             case CONSTANT_Class:</span>
<span class="line-removed">-             case CONSTANT_String:</span>
<span class="line-removed">-             case CONSTANT_MethodType:</span>
<span class="line-removed">-             case CONSTANT_Module:</span>
<span class="line-removed">-             case CONSTANT_Package:</span>
<span class="line-removed">-                 bp = bp + 2;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case CONSTANT_MethodHandle:</span>
<span class="line-removed">-                 bp = bp + 3;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case CONSTANT_Fieldref:</span>
<span class="line-removed">-             case CONSTANT_Methodref:</span>
<span class="line-removed">-             case CONSTANT_InterfaceMethodref:</span>
<span class="line-removed">-             case CONSTANT_NameandType:</span>
<span class="line-removed">-             case CONSTANT_Integer:</span>
<span class="line-removed">-             case CONSTANT_Float:</span>
<span class="line-removed">-             case CONSTANT_Dynamic:</span>
<span class="line-removed">-             case CONSTANT_InvokeDynamic:</span>
<span class="line-removed">-                 bp = bp + 4;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             case CONSTANT_Long:</span>
<span class="line-removed">-             case CONSTANT_Double:</span>
<span class="line-removed">-                 bp = bp + 8;</span>
<span class="line-removed">-                 i++;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             default:</span>
<span class="line-removed">-                 throw badClassFile(&quot;bad.const.pool.tag.at&quot;,</span>
<span class="line-removed">-                                    Byte.toString(tag),</span>
<span class="line-removed">-                                    Integer.toString(bp -1));</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Read constant pool entry at start address i, use pool as a cache.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Object readPool(int i) {</span>
<span class="line-removed">-         Object result = poolObj[i];</span>
<span class="line-removed">-         if (result != null) return result;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         int index = poolIdx[i];</span>
<span class="line-removed">-         if (index == 0) return null;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         byte tag = buf[index];</span>
<span class="line-removed">-         switch (tag) {</span>
<span class="line-removed">-         case CONSTANT_Utf8:</span>
<span class="line-removed">-             poolObj[i] = names.fromUtf(buf, index + 3, getChar(index + 1));</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Unicode:</span>
<span class="line-removed">-             throw badClassFile(&quot;unicode.str.not.supported&quot;);</span>
<span class="line-removed">-         case CONSTANT_Class:</span>
<span class="line-removed">-             poolObj[i] = readClassOrType(getChar(index + 1));</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_String:</span>
<span class="line-removed">-             // FIXME: (footprint) do not use toString here</span>
<span class="line-removed">-             poolObj[i] = readName(getChar(index + 1)).toString();</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Fieldref: {</span>
<span class="line-removed">-             ClassSymbol owner = readClassSymbol(getChar(index + 1));</span>
<span class="line-removed">-             NameAndType nt = readNameAndType(getChar(index + 3));</span>
<span class="line-removed">-             poolObj[i] = new VarSymbol(0, nt.name, nt.uniqueType.type, owner);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         case CONSTANT_Methodref:</span>
<span class="line-removed">-         case CONSTANT_InterfaceMethodref: {</span>
<span class="line-removed">-             ClassSymbol owner = readClassSymbol(getChar(index + 1));</span>
<span class="line-removed">-             NameAndType nt = readNameAndType(getChar(index + 3));</span>
<span class="line-removed">-             poolObj[i] = new MethodSymbol(0, nt.name, nt.uniqueType.type, owner);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         case CONSTANT_NameandType:</span>
<span class="line-removed">-             poolObj[i] = new NameAndType(</span>
<span class="line-removed">-                 readName(getChar(index + 1)),</span>
<span class="line-removed">-                 readType(getChar(index + 3)), types);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Integer:</span>
<span class="line-removed">-             poolObj[i] = getInt(index + 1);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Float:</span>
<span class="line-removed">-             poolObj[i] = Float.valueOf(getFloat(index + 1));</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Long:</span>
<span class="line-removed">-             poolObj[i] = Long.valueOf(getLong(index + 1));</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Double:</span>
<span class="line-removed">-             poolObj[i] = Double.valueOf(getDouble(index + 1));</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_MethodHandle:</span>
<span class="line-removed">-             skipBytes(4);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_MethodType:</span>
<span class="line-removed">-             skipBytes(3);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Dynamic:</span>
<span class="line-removed">-         case CONSTANT_InvokeDynamic:</span>
<span class="line-removed">-             skipBytes(5);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case CONSTANT_Module:</span>
<span class="line-removed">-         case CONSTANT_Package:</span>
<span class="line-removed">-             // this is temporary for now: treat as a simple reference to the underlying Utf8.</span>
<span class="line-removed">-             poolObj[i] = readName(getChar(index + 1));</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         default:</span>
<span class="line-removed">-             throw badClassFile(&quot;bad.const.pool.tag&quot;, Byte.toString(tag));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return poolObj[i];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Read signature and convert to type.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Type readType(int i) {</span>
<span class="line-removed">-         int index = poolIdx[i];</span>
<span class="line-removed">-         return sigToType(buf, index + 3, getChar(index + 1));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** If name is an array type or class signature, return the</span>
<span class="line-removed">-      *  corresponding type; otherwise return a ClassSymbol with given name.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Object readClassOrType(int i) {</span>
<span class="line-removed">-         int index =  poolIdx[i];</span>
<span class="line-removed">-         int len = getChar(index + 1);</span>
<span class="line-removed">-         int start = index + 3;</span>
<span class="line-removed">-         Assert.check(buf[start] == &#39;[&#39; || buf[start + len - 1] != &#39;;&#39;);</span>
<span class="line-removed">-         // by the above assertion, the following test can be</span>
<span class="line-removed">-         // simplified to (buf[start] == &#39;[&#39;)</span>
<span class="line-removed">-         return (buf[start] == &#39;[&#39; || buf[start + len - 1] == &#39;;&#39;)</span>
<span class="line-removed">-             ? (Object)sigToType(buf, start, len)</span>
<span class="line-removed">-             : (Object)enterClass(names.fromUtf(internalize(buf, start,</span>
<span class="line-removed">-                                                            len)));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Read signature and convert to type parameters.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     List&lt;Type&gt; readTypeParams(int i) {</span>
<span class="line-removed">-         int index = poolIdx[i];</span>
<span class="line-removed">-         return sigToTypeParams(buf, index + 3, getChar(index + 1));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Read class entry.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     ClassSymbol readClassSymbol(int i) {</span>
<span class="line-removed">-         Object obj = readPool(i);</span>
<span class="line-removed">-         if (obj != null &amp;&amp; !(obj instanceof ClassSymbol))</span>
<span class="line-removed">-             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed">-                                currentClassFile.toString(),</span>
<span class="line-removed">-                                &quot;CONSTANT_Class_info&quot;, i);</span>
<span class="line-removed">-         return (ClassSymbol)obj;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Name readClassName(int i) {</span>
<span class="line-removed">-         int index = poolIdx[i];</span>
<span class="line-removed">-         if (index == 0) return null;</span>
<span class="line-removed">-         byte tag = buf[index];</span>
<span class="line-removed">-         if (tag != CONSTANT_Class) {</span>
<span class="line-removed">-             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed">-                                currentClassFile.toString(),</span>
<span class="line-removed">-                                &quot;CONSTANT_Class_info&quot;, i);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         int nameIndex =  poolIdx[getChar(index + 1)];</span>
<span class="line-removed">-         int len = getChar(nameIndex + 1);</span>
<span class="line-removed">-         int start = nameIndex + 3;</span>
<span class="line-removed">-         if (buf[start] == &#39;[&#39; || buf[start + len - 1] == &#39;;&#39;)</span>
<span class="line-removed">-             throw badClassFile(&quot;wrong class name&quot;); //TODO: proper diagnostics</span>
<span class="line-removed">-         return names.fromUtf(internalize(buf, start, len));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Read name.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Name readName(int i) {</span>
<span class="line-removed">-         Object obj = readPool(i);</span>
<span class="line-removed">-         if (obj != null &amp;&amp; !(obj instanceof Name))</span>
<span class="line-removed">-             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed">-                                currentClassFile.toString(),</span>
<span class="line-removed">-                                &quot;CONSTANT_Utf8_info or CONSTANT_String_info&quot;, i);</span>
<span class="line-removed">-         return (Name)obj;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Read name and type.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     NameAndType readNameAndType(int i) {</span>
<span class="line-removed">-         Object obj = readPool(i);</span>
<span class="line-removed">-         if (obj != null &amp;&amp; !(obj instanceof NameAndType))</span>
<span class="line-removed">-             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed">-                                currentClassFile.toString(),</span>
<span class="line-removed">-                                &quot;CONSTANT_NameAndType_info&quot;, i);</span>
<span class="line-removed">-         return (NameAndType)obj;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /** Read the name of a module.</span>
<span class="line-removed">-      * The name is stored in a CONSTANT_Module entry, in</span>
<span class="line-removed">-      * JVMS 4.2 binary form (using &quot;.&quot;, not &quot;/&quot;)</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     Name readModuleName(int i) {</span>
<span class="line-removed">-         return readName(i);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      /** Read module_flags.
       */
      Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
          Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
          for (ModuleFlags f : ModuleFlags.values()) {
<span class="line-new-header">--- 318,33 ---</span>
   ***********************************************************************/
  
      /** Read a character.
       */
      char nextChar() {
<span class="line-modified">!         char res = buf.getChar(bp);</span>
<span class="line-added">+         bp += 2;</span>
<span class="line-added">+         return res;</span>
      }
  
      /** Read a byte.
       */
      int nextByte() {
<span class="line-modified">!         return buf.getByte(bp++) &amp; 0xFF;</span>
      }
  
      /** Read an integer.
       */
      int nextInt() {
<span class="line-modified">!         int res = buf.getInt(bp);</span>
<span class="line-modified">!         bp += 4;</span>
<span class="line-modified">!         return res;</span>
      }
  
  /************************************************************************
   * Constant Pool Access
   ***********************************************************************/
  
      /** Read module_flags.
       */
      Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
          Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
          for (ModuleFlags f : ModuleFlags.values()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 760,11 ***</span>
          case &#39;(&#39;:
              sigp++;
              List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
              Type restype = sigToType();
              List&lt;Type&gt; thrown = List.nil();
<span class="line-modified">!             while (signature[sigp] == &#39;^&#39;) {</span>
                  sigp++;
                  thrown = thrown.prepend(sigToType());
              }
              // if there is a typevar in the throws clause we should state it.
              for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
<span class="line-new-header">--- 492,11 ---</span>
          case &#39;(&#39;:
              sigp++;
              List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
              Type restype = sigToType();
              List&lt;Type&gt; thrown = List.nil();
<span class="line-modified">!             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {</span>
                  sigp++;
                  thrown = thrown.prepend(sigToType());
              }
              // if there is a typevar in the throws clause we should state it.
              for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 853,11 ***</span>
                              throw new UnsupportedOperationException();
                          }
                      };
                  switch (signature[sigp++]) {
                  case &#39;;&#39;:
<span class="line-modified">!                     if (sigp &lt; signature.length &amp;&amp; signature[sigp] == &#39;.&#39;) {</span>
                          // support old-style GJC signatures
                          // The signature produced was
                          // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
                          // rather than say
                          // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
<span class="line-new-header">--- 585,11 ---</span>
                              throw new UnsupportedOperationException();
                          }
                      };
                  switch (signature[sigp++]) {
                  case &#39;;&#39;:
<span class="line-modified">!                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {</span>
                          // support old-style GJC signatures
                          // The signature produced was
                          // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
                          // rather than say
                          // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1047,20 ***</span>
          AttributeReader[] readers = {
              // v45.3 attributes
  
              new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
<span class="line-modified">!                     if (readAllOfClassFile || saveParameterNames)</span>
                          ((MethodSymbol)sym).code = readCode(sym);
                      else
                          bp = bp + attrLen;
                  }
              },
  
              new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
<span class="line-modified">!                     Object v = readPool(nextChar());</span>
                      // Ignore ConstantValue attribute if field not final.
                      if ((sym.flags() &amp; FINAL) == 0) {
                          return;
                      }
                      VarSymbol var = (VarSymbol) sym;
<span class="line-new-header">--- 779,20 ---</span>
          AttributeReader[] readers = {
              // v45.3 attributes
  
              new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
<span class="line-modified">!                     if (saveParameterNames)</span>
                          ((MethodSymbol)sym).code = readCode(sym);
                      else
                          bp = bp + attrLen;
                  }
              },
  
              new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
<span class="line-modified">!                     Object v = poolReader.getConstant(nextChar());</span>
                      // Ignore ConstantValue attribute if field not final.
                      if ((sym.flags() &amp; FINAL) == 0) {
                          return;
                      }
                      VarSymbol var = (VarSymbol) sym;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,12 ***</span>
                             break;
                         case DOUBLE:
                             checkType(var, Double.class, v);
                             break;
                         case CLASS:
<span class="line-modified">!                            Assert.check(var.type.tsym == syms.stringType.tsym);</span>
<span class="line-modified">!                            checkType(var, String.class, v);</span>
                             break;
                         default:
                             // ignore ConstantValue attribute if type is not primitive or String
                             return;
                      }
<span class="line-new-header">--- 812,15 ---</span>
                             break;
                         case DOUBLE:
                             checkType(var, Double.class, v);
                             break;
                         case CLASS:
<span class="line-modified">!                            if (var.type.tsym == syms.stringType.tsym) {</span>
<span class="line-modified">!                                checkType(var, String.class, v);</span>
<span class="line-added">+                            } else {</span>
<span class="line-added">+                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);</span>
<span class="line-added">+                            }</span>
                             break;
                         default:
                             // ignore ConstantValue attribute if type is not primitive or String
                             return;
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1113,11 ***</span>
              new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
                      int nexceptions = nextChar();
                      List&lt;Type&gt; thrown = List.nil();
                      for (int j = 0; j &lt; nexceptions; j++)
<span class="line-modified">!                         thrown = thrown.prepend(readClassSymbol(nextChar()).type);</span>
                      if (sym.type.getThrownTypes().isEmpty())
                          sym.type.asMethodType().thrown = thrown.reverse();
                  }
              },
  
<span class="line-new-header">--- 848,11 ---</span>
              new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
                      int nexceptions = nextChar();
                      List&lt;Type&gt; thrown = List.nil();
                      for (int j = 0; j &lt; nexceptions; j++)
<span class="line-modified">!                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);</span>
                      if (sym.type.getThrownTypes().isEmpty())
                          sym.type.asMethodType().thrown = thrown.reverse();
                  }
              },
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1139,12 ***</span>
                      if (saveParameterNames &amp;&amp; !sawMethodParameters) {
                          // Pick up parameter names from the variable table.
                          // Parameter names are not explicitly identified as such,
                          // but all parameter name entries in the LocalVariableTable
                          // have a start_pc of 0.  Therefore, we record the name
<span class="line-modified">!                         // indicies of all slots with a start_pc of zero in the</span>
<span class="line-modified">!                         // parameterNameIndicies array.</span>
                          // Note that this implicitly honors the JVMS spec that
                          // there may be more than one LocalVariableTable, and that
                          // there is no specified ordering for the entries.
                          int numEntries = nextChar();
                          for (int i = 0; i &lt; numEntries; i++) {
<span class="line-new-header">--- 874,12 ---</span>
                      if (saveParameterNames &amp;&amp; !sawMethodParameters) {
                          // Pick up parameter names from the variable table.
                          // Parameter names are not explicitly identified as such,
                          // but all parameter name entries in the LocalVariableTable
                          // have a start_pc of 0.  Therefore, we record the name
<span class="line-modified">!                         // indices of all slots with a start_pc of zero in the</span>
<span class="line-modified">!                         // parameterNameIndices array.</span>
                          // Note that this implicitly honors the JVMS spec that
                          // there may be more than one LocalVariableTable, and that
                          // there is no specified ordering for the entries.
                          int numEntries = nextChar();
                          for (int i = 0; i &lt; numEntries; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1171,11 ***</span>
              },
  
              new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
                      ClassSymbol c = (ClassSymbol) sym;
<span class="line-modified">!                     Name n = readName(nextChar());</span>
                      c.sourcefile = new SourceFileObject(n);
                      // If the class is a toplevel class, originating from a Java source file,
                      // but the class name does not match the file name, then it is
                      // an auxiliary class.
                      String sn = n.toString();
<span class="line-new-header">--- 906,11 ---</span>
              },
  
              new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
                      ClassSymbol c = (ClassSymbol) sym;
<span class="line-modified">!                     Name n = poolReader.getName(nextChar());</span>
                      c.sourcefile = new SourceFileObject(n);
                      // If the class is a toplevel class, originating from a Java source file,
                      // but the class name does not match the file name, then it is
                      // an auxiliary class.
                      String sn = n.toString();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1209,21 ***</span>
                          ClassSymbol c = (ClassSymbol) sym;
                          readingClassAttr = true;
                          try {
                              ClassType ct1 = (ClassType)c.type;
                              Assert.check(c == currentOwner);
<span class="line-modified">!                             ct1.typarams_field = readTypeParams(nextChar());</span>
                              ct1.supertype_field = sigToType();
                              ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
                              while (sigp != siglimit) is.append(sigToType());
                              ct1.interfaces_field = is.toList();
                          } finally {
                              readingClassAttr = false;
                          }
                      } else {
                          List&lt;Type&gt; thrown = sym.type.getThrownTypes();
<span class="line-modified">!                         sym.type = readType(nextChar());</span>
                          //- System.err.println(&quot; # &quot; + sym.type);
                          if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
                              sym.type.asMethodType().thrown = thrown;
  
                      }
<span class="line-new-header">--- 944,22 ---</span>
                          ClassSymbol c = (ClassSymbol) sym;
                          readingClassAttr = true;
                          try {
                              ClassType ct1 = (ClassType)c.type;
                              Assert.check(c == currentOwner);
<span class="line-modified">!                             ct1.typarams_field = poolReader.getName(nextChar())</span>
<span class="line-added">+                                     .map(ClassReader.this::sigToTypeParams);</span>
                              ct1.supertype_field = sigToType();
                              ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
                              while (sigp != siglimit) is.append(sigToType());
                              ct1.interfaces_field = is.toList();
                          } finally {
                              readingClassAttr = false;
                          }
                      } else {
                          List&lt;Type&gt; thrown = sym.type.getThrownTypes();
<span class="line-modified">!                         sym.type = poolReader.getType(nextChar());</span>
                          //- System.err.println(&quot; # &quot; + sym.type);
                          if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
                              sym.type.asMethodType().thrown = thrown;
  
                      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1260,11 ***</span>
                  protected void read(Symbol sym, int attrLen) {
                      readParameterAnnotations(sym);
                  }
              },
  
<span class="line-modified">!             // additional &quot;legacy&quot; v49 attributes, superceded by flags</span>
  
              new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
                      sym.flags_field |= ANNOTATION;
                  }
<span class="line-new-header">--- 996,11 ---</span>
                  protected void read(Symbol sym, int attrLen) {
                      readParameterAnnotations(sym);
                  }
              },
  
<span class="line-modified">!             // additional &quot;legacy&quot; v49 attributes, superseded by flags</span>
  
              new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
                  protected void read(Symbol sym, int attrLen) {
                      sym.flags_field |= ANNOTATION;
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1340,23 ***</span>
                  protected void read(Symbol sym, int attrLen) {
                      if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
                          ModuleSymbol msym = (ModuleSymbol) sym.owner;
                          ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
  
<span class="line-modified">!                         Name moduleName = readModuleName(nextChar());</span>
                          if (currentModule.name != moduleName) {
                              throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
                          }
  
                          Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
                          msym.flags.addAll(moduleFlags);
<span class="line-modified">!                         msym.version = readName(nextChar());</span>
  
                          ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
                          int nrequires = nextChar();
                          for (int i = 0; i &lt; nrequires; i++) {
<span class="line-modified">!                             ModuleSymbol rsym = syms.enterModule(readModuleName(nextChar()));</span>
                              Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
                              if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
                                  if (flags.contains(RequiresFlag.TRANSITIVE)) {
                                      throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
                                  }
<span class="line-new-header">--- 1076,23 ---</span>
                  protected void read(Symbol sym, int attrLen) {
                      if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
                          ModuleSymbol msym = (ModuleSymbol) sym.owner;
                          ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
  
<span class="line-modified">!                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);</span>
                          if (currentModule.name != moduleName) {
                              throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
                          }
  
                          Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
                          msym.flags.addAll(moduleFlags);
<span class="line-modified">!                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);</span>
  
                          ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
                          int nrequires = nextChar();
                          for (int i = 0; i &lt; nrequires; i++) {
<span class="line-modified">!                             ModuleSymbol rsym = poolReader.getModule(nextChar());</span>
                              Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
                              if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
                                  if (flags.contains(RequiresFlag.TRANSITIVE)) {
                                      throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
                                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1371,21 ***</span>
                          directives.addAll(msym.requires);
  
                          ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
                          int nexports = nextChar();
                          for (int i = 0; i &lt; nexports; i++) {
<span class="line-modified">!                             Name n = readName(nextChar());</span>
<span class="line-removed">-                             PackageSymbol p = syms.enterPackage(currentModule, names.fromUtf(internalize(n)));</span>
                              Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
                              int nto = nextChar();
                              List&lt;ModuleSymbol&gt; to;
                              if (nto == 0) {
                                  to = null;
                              } else {
                                  ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
                                  for (int t = 0; t &lt; nto; t++)
<span class="line-modified">!                                     lb.append(syms.enterModule(readModuleName(nextChar())));</span>
                                  to = lb.toList();
                              }
                              exports.add(new ExportsDirective(p, to, flags));
                          }
                          msym.exports = exports.toList();
<span class="line-new-header">--- 1107,20 ---</span>
                          directives.addAll(msym.requires);
  
                          ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
                          int nexports = nextChar();
                          for (int i = 0; i &lt; nexports; i++) {
<span class="line-modified">!                             PackageSymbol p = poolReader.getPackage(nextChar());</span>
                              Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
                              int nto = nextChar();
                              List&lt;ModuleSymbol&gt; to;
                              if (nto == 0) {
                                  to = null;
                              } else {
                                  ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
                                  for (int t = 0; t &lt; nto; t++)
<span class="line-modified">!                                     lb.append(poolReader.getModule(nextChar()));</span>
                                  to = lb.toList();
                              }
                              exports.add(new ExportsDirective(p, to, flags));
                          }
                          msym.exports = exports.toList();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1394,21 ***</span>
                          int nopens = nextChar();
                          if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
                              throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
                          }
                          for (int i = 0; i &lt; nopens; i++) {
<span class="line-modified">!                             Name n = readName(nextChar());</span>
<span class="line-removed">-                             PackageSymbol p = syms.enterPackage(currentModule, names.fromUtf(internalize(n)));</span>
                              Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
                              int nto = nextChar();
                              List&lt;ModuleSymbol&gt; to;
                              if (nto == 0) {
                                  to = null;
                              } else {
                                  ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
                                  for (int t = 0; t &lt; nto; t++)
<span class="line-modified">!                                     lb.append(syms.enterModule(readModuleName(nextChar())));</span>
                                  to = lb.toList();
                              }
                              opens.add(new OpensDirective(p, to, flags));
                          }
                          msym.opens = opens.toList();
<span class="line-new-header">--- 1129,20 ---</span>
                          int nopens = nextChar();
                          if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
                              throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
                          }
                          for (int i = 0; i &lt; nopens; i++) {
<span class="line-modified">!                             PackageSymbol p = poolReader.getPackage(nextChar());</span>
                              Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
                              int nto = nextChar();
                              List&lt;ModuleSymbol&gt; to;
                              if (nto == 0) {
                                  to = null;
                              } else {
                                  ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
                                  for (int t = 0; t &lt; nto; t++)
<span class="line-modified">!                                     lb.append(poolReader.getModule(nextChar()));</span>
                                  to = lb.toList();
                              }
                              opens.add(new OpensDirective(p, to, flags));
                          }
                          msym.opens = opens.toList();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1417,29 ***</span>
                          msym.directives = directives.toList();
  
                          ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
                          int nuses = nextChar();
                          for (int i = 0; i &lt; nuses; i++) {
<span class="line-modified">!                             Name srvc = readClassName(nextChar());</span>
                              uses.add(new InterimUsesDirective(srvc));
                          }
                          interimUses = uses.toList();
  
                          ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
                          int nprovides = nextChar();
                          for (int p = 0; p &lt; nprovides; p++) {
<span class="line-modified">!                             Name srvc = readClassName(nextChar());</span>
                              int nimpls = nextChar();
                              ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
                              for (int i = 0; i &lt; nimpls; i++) {
<span class="line-modified">!                                 impls.append(readClassName(nextChar()));</span>
                              provides.add(new InterimProvidesDirective(srvc, impls.toList()));
                              }
                          }
                          interimProvides = provides.toList();
                      }
                  }
              },
  
              new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
                  @Override
                  protected boolean accepts(AttributeKind kind) {
<span class="line-new-header">--- 1151,33 ---</span>
                          msym.directives = directives.toList();
  
                          ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
                          int nuses = nextChar();
                          for (int i = 0; i &lt; nuses; i++) {
<span class="line-modified">!                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);</span>
                              uses.add(new InterimUsesDirective(srvc));
                          }
                          interimUses = uses.toList();
  
                          ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
                          int nprovides = nextChar();
                          for (int p = 0; p &lt; nprovides; p++) {
<span class="line-modified">!                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);</span>
                              int nimpls = nextChar();
                              ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
                              for (int i = 0; i &lt; nimpls; i++) {
<span class="line-modified">!                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));</span>
                              provides.add(new InterimProvidesDirective(srvc, impls.toList()));
                              }
                          }
                          interimProvides = provides.toList();
                      }
                  }
<span class="line-added">+ </span>
<span class="line-added">+                 private Name classNameMapper(byte[] arr, int offset, int length) {</span>
<span class="line-added">+                     return names.fromUtf(ClassFile.internalize(arr, offset, length));</span>
<span class="line-added">+                 }</span>
              },
  
              new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
                  @Override
                  protected boolean accepts(AttributeKind kind) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1450,10 ***</span>
<span class="line-new-header">--- 1188,23 ---</span>
                          ModuleSymbol msym = (ModuleSymbol) sym.owner;
                          msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
                      }
                  }
              },
<span class="line-added">+ </span>
<span class="line-added">+             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 protected boolean accepts(AttributeKind kind) {</span>
<span class="line-added">+                     return super.accepts(kind) &amp;&amp; allowRecords;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 protected void read(Symbol sym, int attrLen) {</span>
<span class="line-added">+                     if (sym.kind == TYP) {</span>
<span class="line-added">+                         sym.flags_field |= RECORD;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     bp = bp + attrLen;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          };
  
          for (AttributeReader r: readers)
              attributeReaders.put(r.name, r);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1462,12 ***</span>
          // sym is a nested class with an &quot;Enclosing Method&quot; attribute
          // remove sym from it&#39;s current owners scope and place it in
          // the scope specified by the attribute
          sym.owner.members().remove(sym);
          ClassSymbol self = (ClassSymbol)sym;
<span class="line-modified">!         ClassSymbol c = readClassSymbol(nextChar());</span>
<span class="line-modified">!         NameAndType nt = readNameAndType(nextChar());</span>
  
          if (c.members_field == null || c.kind != TYP)
              throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
  
          MethodSymbol m = findMethod(nt, c.members_field, self.flags());
<span class="line-new-header">--- 1213,12 ---</span>
          // sym is a nested class with an &quot;Enclosing Method&quot; attribute
          // remove sym from it&#39;s current owners scope and place it in
          // the scope specified by the attribute
          sym.owner.members().remove(sym);
          ClassSymbol self = (ClassSymbol)sym;
<span class="line-modified">!         ClassSymbol c = poolReader.getClass(nextChar());</span>
<span class="line-modified">!         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);</span>
  
          if (c.members_field == null || c.kind != TYP)
              throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
  
          MethodSymbol m = findMethod(nt, c.members_field, self.flags());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1500,10 ***</span>
<span class="line-new-header">--- 1251,14 ---</span>
          }
      }
  
      // See java.lang.Class
      private Name simpleBinaryName(Name self, Name enclosing) {
<span class="line-added">+         if (!self.startsWith(enclosing)) {</span>
<span class="line-added">+             throw badClassFile(&quot;bad.enclosing.method&quot;, self);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          String simpleBinaryName = self.toString().substring(enclosing.toString().length());
          if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
              throw badClassFile(&quot;bad.enclosing.method&quot;, self);
          int index = 1;
          while (index &lt; simpleBinaryName.length() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1514,11 ***</span>
  
      private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
          if (nt == null)
              return null;
  
<span class="line-modified">!         MethodType type = nt.uniqueType.type.asMethodType();</span>
  
          for (Symbol sym : scope.getSymbolsByName(nt.name)) {
              if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
                  return (MethodSymbol)sym;
          }
<span class="line-new-header">--- 1269,11 ---</span>
  
      private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
          if (nt == null)
              return null;
  
<span class="line-modified">!         MethodType type = nt.type.asMethodType();</span>
  
          for (Symbol sym : scope.getSymbolsByName(nt.name)) {
              if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
                  return (MethodSymbol)sym;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1527,19 ***</span>
              // not a constructor
              return null;
          if ((flags &amp; INTERFACE) != 0)
              // no enclosing instance
              return null;
<span class="line-modified">!         if (nt.uniqueType.type.getParameterTypes().isEmpty())</span>
              // no parameters
              return null;
  
          // A constructor of an inner class.
          // Remove the first argument (the enclosing instance)
<span class="line-modified">!         nt.setType(new MethodType(nt.uniqueType.type.getParameterTypes().tail,</span>
<span class="line-modified">!                                  nt.uniqueType.type.getReturnType(),</span>
<span class="line-modified">!                                  nt.uniqueType.type.getThrownTypes(),</span>
                                   syms.methodClass));
          // Try searching again
          return findMethod(nt, scope, flags);
      }
  
<span class="line-new-header">--- 1282,19 ---</span>
              // not a constructor
              return null;
          if ((flags &amp; INTERFACE) != 0)
              // no enclosing instance
              return null;
<span class="line-modified">!         if (nt.type.getParameterTypes().isEmpty())</span>
              // no parameters
              return null;
  
          // A constructor of an inner class.
          // Remove the first argument (the enclosing instance)
<span class="line-modified">!         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,</span>
<span class="line-modified">!                                  nt.type.getReturnType(),</span>
<span class="line-modified">!                                  nt.type.getThrownTypes(),</span>
                                   syms.methodClass));
          // Try searching again
          return findMethod(nt, scope, flags);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1572,11 ***</span>
      }
  
      void readAttrs(Symbol sym, AttributeKind kind) {
          char ac = nextChar();
          for (int i = 0; i &lt; ac; i++) {
<span class="line-modified">!             Name attrName = readName(nextChar());</span>
              int attrLen = nextInt();
              AttributeReader r = attributeReaders.get(attrName);
              if (r != null &amp;&amp; r.accepts(kind))
                  r.read(sym, attrLen);
              else  {
<span class="line-new-header">--- 1327,11 ---</span>
      }
  
      void readAttrs(Symbol sym, AttributeKind kind) {
          char ac = nextChar();
          for (int i = 0; i &lt; ac; i++) {
<span class="line-modified">!             Name attrName = poolReader.getName(nextChar());</span>
              int attrLen = nextInt();
              AttributeReader r = attributeReaders.get(attrName);
              if (r != null &amp;&amp; r.accepts(kind))
                  r.read(sym, attrLen);
              else  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1657,29 ***</span>
                      target = proxy;
                  } else if (proxy.type.tsym == syms.repeatableType.tsym) {
                      repeatable = proxy;
                  } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
                      sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
<span class="line-modified">!                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {</span>
<span class="line-modified">!                         if (v.fst == names.forRemoval &amp;&amp; v.snd instanceof Attribute.Constant) {</span>
<span class="line-modified">!                             Attribute.Constant c = (Attribute.Constant)v.snd;</span>
<span class="line-modified">!                             if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {</span>
<span class="line-removed">-                                 sym.flags_field |= DEPRECATED_REMOVAL;</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
                  }
                  proxies.append(proxy);
              }
          }
          annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
      }
  
      /** Read parameter annotations.
       */
      void readParameterAnnotations(Symbol meth) {
<span class="line-modified">!         int numParameters = buf[bp++] &amp; 0xFF;</span>
          if (parameterAnnotations == null) {
              parameterAnnotations = new ParameterAnnotations[numParameters];
          } else if (parameterAnnotations.length != numParameters) {
              throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
          }
<span class="line-new-header">--- 1412,36 ---</span>
                      target = proxy;
                  } else if (proxy.type.tsym == syms.repeatableType.tsym) {
                      repeatable = proxy;
                  } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
                      sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
<span class="line-modified">!                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);</span>
<span class="line-modified">!                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {</span>
<span class="line-modified">!                     sym.flags_field |= PREVIEW_API;</span>
<span class="line-modified">!                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);</span>
                  }
                  proxies.append(proxy);
              }
          }
          annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
      }
<span class="line-added">+     //where:</span>
<span class="line-added">+         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {</span>
<span class="line-added">+             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {</span>
<span class="line-added">+                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {</span>
<span class="line-added">+                     Attribute.Constant c = (Attribute.Constant)v.snd;</span>
<span class="line-added">+                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {</span>
<span class="line-added">+                         sym.flags_field |= flag;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
      /** Read parameter annotations.
       */
      void readParameterAnnotations(Symbol meth) {
<span class="line-modified">!         int numParameters = buf.getByte(bp++) &amp; 0xFF;</span>
          if (parameterAnnotations == null) {
              parameterAnnotations = new ParameterAnnotations[numParameters];
          } else if (parameterAnnotations.length != numParameters) {
              throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1719,43 ***</span>
          annotate.normal(new AnnotationDefaultCompleter(meth, value));
      }
  
      Type readTypeOrClassSymbol(int i) {
          // support preliminary jsr175-format class files
<span class="line-modified">!         if (buf[poolIdx[i]] == CONSTANT_Class)</span>
<span class="line-modified">!             return readClassSymbol(i).type;</span>
<span class="line-removed">-         return readTypeToProxy(i);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     Type readEnumType(int i) {</span>
<span class="line-removed">-         // support preliminary jsr175-format class files</span>
<span class="line-removed">-         int index = poolIdx[i];</span>
<span class="line-removed">-         int length = getChar(index + 1);</span>
<span class="line-removed">-         if (buf[index + length + 2] != &#39;;&#39;)</span>
<span class="line-removed">-             return enterClass(readName(i)).type;</span>
          return readTypeToProxy(i);
      }
      Type readTypeToProxy(int i) {
          if (currentModule.module_info == currentOwner) {
<span class="line-modified">!             int index = poolIdx[i];</span>
<span class="line-removed">-             return new ProxyType(Arrays.copyOfRange(buf, index + 3, index + 3 + getChar(index + 1)));</span>
          } else {
<span class="line-modified">!             return readType(i);</span>
          }
      }
  
      CompoundAnnotationProxy readCompoundAnnotation() {
          Type t;
          if (currentModule.module_info == currentOwner) {
<span class="line-modified">!             int index = poolIdx[nextChar()];</span>
<span class="line-modified">!             t = new ProxyType(Arrays.copyOfRange(buf, index + 3, index + 3 + getChar(index + 1)));</span>
          } else {
              t = readTypeOrClassSymbol(nextChar());
          }
          int numFields = nextChar();
          ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
          for (int i=0; i&lt;numFields; i++) {
<span class="line-modified">!             Name name = readName(nextChar());</span>
              Attribute value = readAttributeValue();
              pairs.append(new Pair&lt;&gt;(name, value));
          }
          return new CompoundAnnotationProxy(t, pairs.toList());
      }
<span class="line-new-header">--- 1481,34 ---</span>
          annotate.normal(new AnnotationDefaultCompleter(meth, value));
      }
  
      Type readTypeOrClassSymbol(int i) {
          // support preliminary jsr175-format class files
<span class="line-modified">!         if (poolReader.hasTag(i, CONSTANT_Class))</span>
<span class="line-modified">!             return poolReader.getClass(i).type;</span>
          return readTypeToProxy(i);
      }
      Type readTypeToProxy(int i) {
          if (currentModule.module_info == currentOwner) {
<span class="line-modified">!             return new ProxyType(i);</span>
          } else {
<span class="line-modified">!             return poolReader.getType(i);</span>
          }
      }
  
      CompoundAnnotationProxy readCompoundAnnotation() {
          Type t;
          if (currentModule.module_info == currentOwner) {
<span class="line-modified">!             int cpIndex = nextChar();</span>
<span class="line-modified">!             t = new ProxyType(cpIndex);</span>
          } else {
              t = readTypeOrClassSymbol(nextChar());
          }
          int numFields = nextChar();
          ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
          for (int i=0; i&lt;numFields; i++) {
<span class="line-modified">!             Name name = poolReader.getName(nextChar());</span>
              Attribute value = readAttributeValue();
              pairs.append(new Pair&lt;&gt;(name, value));
          }
          return new CompoundAnnotationProxy(t, pairs.toList());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1964,33 ***</span>
  
          return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
  
      }
  
      Attribute readAttributeValue() {
<span class="line-modified">!         char c = (char) buf[bp++];</span>
          switch (c) {
          case &#39;B&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.byteType, readPool(nextChar()));</span>
          case &#39;C&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.charType, readPool(nextChar()));</span>
          case &#39;D&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.doubleType, readPool(nextChar()));</span>
          case &#39;F&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.floatType, readPool(nextChar()));</span>
          case &#39;I&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.intType, readPool(nextChar()));</span>
          case &#39;J&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.longType, readPool(nextChar()));</span>
          case &#39;S&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.shortType, readPool(nextChar()));</span>
          case &#39;Z&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.booleanType, readPool(nextChar()));</span>
          case &#39;s&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.stringType, readPool(nextChar()).toString());</span>
          case &#39;e&#39;:
<span class="line-modified">!             return new EnumAttributeProxy(readEnumType(nextChar()), readName(nextChar()));</span>
          case &#39;c&#39;:
              return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
          case &#39;[&#39;: {
              int n = nextChar();
              ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
<span class="line-new-header">--- 1717,44 ---</span>
  
          return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
  
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Helper function to read an optional pool entry (with given function); this is used while parsing</span>
<span class="line-added">+      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,</span>
<span class="line-added">+      * as per JVMS.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {</span>
<span class="line-added">+         return (index == 0) ?</span>
<span class="line-added">+                 defaultValue :</span>
<span class="line-added">+                 poolFunc.apply(index);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      Attribute readAttributeValue() {
<span class="line-modified">!         char c = (char) buf.getByte(bp++);</span>
          switch (c) {
          case &#39;B&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));</span>
          case &#39;C&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));</span>
          case &#39;D&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));</span>
          case &#39;F&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));</span>
          case &#39;I&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));</span>
          case &#39;J&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));</span>
          case &#39;S&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));</span>
          case &#39;Z&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));</span>
          case &#39;s&#39;:
<span class="line-modified">!             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());</span>
          case &#39;e&#39;:
<span class="line-modified">!             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));</span>
          case &#39;c&#39;:
              return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
          case &#39;[&#39;: {
              int n = nextChar();
              ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2395,23 ***</span>
  
      /** Read a field.
       */
      VarSymbol readField() {
          long flags = adjustFieldFlags(nextChar());
<span class="line-modified">!         Name name = readName(nextChar());</span>
<span class="line-modified">!         Type type = readType(nextChar());</span>
          VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
          readMemberAttrs(v);
          return v;
      }
  
      /** Read a method.
       */
      MethodSymbol readMethod() {
          long flags = adjustMethodFlags(nextChar());
<span class="line-modified">!         Name name = readName(nextChar());</span>
<span class="line-modified">!         Type type = readType(nextChar());</span>
          if (currentOwner.isInterface() &amp;&amp;
                  (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
              if (majorVersion &gt; Version.V52.major ||
                      (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
                  if ((flags &amp; (STATIC | PRIVATE)) == 0) {
<span class="line-new-header">--- 2159,23 ---</span>
  
      /** Read a field.
       */
      VarSymbol readField() {
          long flags = adjustFieldFlags(nextChar());
<span class="line-modified">!         Name name = poolReader.getName(nextChar());</span>
<span class="line-modified">!         Type type = poolReader.getType(nextChar());</span>
          VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
          readMemberAttrs(v);
          return v;
      }
  
      /** Read a method.
       */
      MethodSymbol readMethod() {
          long flags = adjustMethodFlags(nextChar());
<span class="line-modified">!         Name name = poolReader.getName(nextChar());</span>
<span class="line-modified">!         Type type = poolReader.getType(nextChar());</span>
          if (currentOwner.isInterface() &amp;&amp;
                  (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
              if (majorVersion &gt; Version.V52.major ||
                      (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
                  if ((flags &amp; (STATIC | PRIVATE)) == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2551,18 ***</span>
                  int skip = Code.width(jvmType.getParameterTypes())
                          - Code.width(sym.type.getParameterTypes());
                  firstParam += skip;
              }
          }
<span class="line-modified">!         List&lt;Name&gt; paramNames = List.nil();</span>
          ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
          int nameIndex = firstParam;
          int annotationIndex = 0;
          for (Type t: sym.type.getParameterTypes()) {
<span class="line-modified">!             Name name = parameterName(nameIndex, paramNames);</span>
<span class="line-removed">-             paramNames = paramNames.prepend(name);</span>
<span class="line-removed">-             VarSymbol param = new VarSymbol(PARAMETER, name, t, sym);</span>
              params.append(param);
              if (parameterAnnotations != null) {
                  ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
                  if (annotations != null &amp;&amp; annotations.proxies != null
                          &amp;&amp; !annotations.proxies.isEmpty()) {
<span class="line-new-header">--- 2315,16 ---</span>
                  int skip = Code.width(jvmType.getParameterTypes())
                          - Code.width(sym.type.getParameterTypes());
                  firstParam += skip;
              }
          }
<span class="line-modified">!         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();</span>
          ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
          int nameIndex = firstParam;
          int annotationIndex = 0;
          for (Type t: sym.type.getParameterTypes()) {
<span class="line-modified">!             VarSymbol param = parameter(nameIndex, t, sym, paramNames);</span>
              params.append(param);
              if (parameterAnnotations != null) {
                  ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
                  if (annotations != null &amp;&amp; annotations.proxies != null
                          &amp;&amp; !annotations.proxies.isEmpty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2583,22 ***</span>
  
  
      // Returns the name for the parameter at position &#39;index&#39;, either using
      // names read from the MethodParameters, or by synthesizing a name that
      // is not on the &#39;exclude&#39; list.
<span class="line-modified">!     private Name parameterName(int index, List&lt;Name&gt; exclude) {</span>
          if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
                  &amp;&amp; parameterNameIndices[index] != 0) {
<span class="line-modified">!             return readName(parameterNameIndices[index]);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         String prefix = &quot;arg&quot;;</span>
<span class="line-modified">!         while (true) {</span>
<span class="line-modified">!             Name argName = names.fromString(prefix + exclude.size());</span>
<span class="line-modified">!             if (!exclude.contains(argName))</span>
<span class="line-modified">!                 return argName;</span>
<span class="line-modified">!             prefix += &quot;$&quot;;</span>
          }
      }
  
      /**
       * skip n bytes
       */
<span class="line-new-header">--- 2345,28 ---</span>
  
  
      // Returns the name for the parameter at position &#39;index&#39;, either using
      // names read from the MethodParameters, or by synthesizing a name that
      // is not on the &#39;exclude&#39; list.
<span class="line-modified">!     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {</span>
<span class="line-added">+         long flags = PARAMETER;</span>
<span class="line-added">+         Name argName;</span>
          if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
                  &amp;&amp; parameterNameIndices[index] != 0) {
<span class="line-modified">!             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);</span>
<span class="line-modified">!             flags |= NAME_FILLED;</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!             String prefix = &quot;arg&quot;;</span>
<span class="line-modified">!             while (true) {</span>
<span class="line-modified">!                 argName = names.fromString(prefix + exclude.size());</span>
<span class="line-modified">!                 if (!exclude.contains(argName))</span>
<span class="line-modified">!                     break;</span>
<span class="line-added">+                 prefix += &quot;$&quot;;</span>
<span class="line-added">+             }</span>
          }
<span class="line-added">+         exclude.add(argName);</span>
<span class="line-added">+         return new ParamSymbol(flags, argName, t, owner);</span>
      }
  
      /**
       * skip n bytes
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2671,11 ***</span>
          long flags = adjustClassFlags(f);
          if ((flags &amp; MODULE) == 0) {
              if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
              // read own class name and check that it matches
              currentModule = c.packge().modle;
<span class="line-modified">!             ClassSymbol self = readClassSymbol(nextChar());</span>
              if (c != self) {
                  throw badClassFile(&quot;class.file.wrong.class&quot;,
                                     self.flatname);
              }
          } else {
<span class="line-new-header">--- 2439,11 ---</span>
          long flags = adjustClassFlags(f);
          if ((flags &amp; MODULE) == 0) {
              if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
              // read own class name and check that it matches
              currentModule = c.packge().modle;
<span class="line-modified">!             ClassSymbol self = poolReader.getClass(nextChar());</span>
              if (c != self) {
                  throw badClassFile(&quot;class.file.wrong.class&quot;,
                                     self.flatname);
              }
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2700,29 ***</span>
          for (int i = 0; i &lt; fieldCount; i++) skipMember();
          char methodCount = nextChar();
          for (int i = 0; i &lt; methodCount; i++) skipMember();
          readClassAttrs(c);
  
<span class="line-removed">-         if (readAllOfClassFile) {</span>
<span class="line-removed">-             for (int i = 1; i &lt; poolObj.length; i++) readPool(i);</span>
<span class="line-removed">-             c.pool = new Pool(poolObj.length, poolObj, types);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          // reset and read rest of classinfo
          bp = startbp;
          int n = nextChar();
          if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
              throw badClassFile(&quot;module.info.invalid.super.class&quot;);
          }
          if (ct.supertype_field == null)
<span class="line-modified">!             ct.supertype_field = (n == 0)</span>
<span class="line-modified">!                 ? Type.noType</span>
<span class="line-removed">-                 : readClassSymbol(n).erasure(types);</span>
          n = nextChar();
          List&lt;Type&gt; is = List.nil();
          for (int i = 0; i &lt; n; i++) {
<span class="line-modified">!             Type _inter = readClassSymbol(nextChar()).erasure(types);</span>
              is = is.prepend(_inter);
          }
          if (ct.interfaces_field == null)
              ct.interfaces_field = is.reverse();
  
<span class="line-new-header">--- 2468,23 ---</span>
          for (int i = 0; i &lt; fieldCount; i++) skipMember();
          char methodCount = nextChar();
          for (int i = 0; i &lt; methodCount; i++) skipMember();
          readClassAttrs(c);
  
          // reset and read rest of classinfo
          bp = startbp;
          int n = nextChar();
          if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
              throw badClassFile(&quot;module.info.invalid.super.class&quot;);
          }
          if (ct.supertype_field == null)
<span class="line-modified">!             ct.supertype_field =</span>
<span class="line-modified">!                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);</span>
          n = nextChar();
          List&lt;Type&gt; is = List.nil();
          for (int i = 0; i &lt; n; i++) {
<span class="line-modified">!             Type _inter = poolReader.getClass(nextChar()).erasure(types);</span>
              is = is.prepend(_inter);
          }
          if (ct.interfaces_field == null)
              ct.interfaces_field = is.reverse();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2739,12 ***</span>
       */
      void readInnerClasses(ClassSymbol c) {
          int n = nextChar();
          for (int i = 0; i &lt; n; i++) {
              nextChar(); // skip inner class symbol
<span class="line-modified">!             ClassSymbol outer = readClassSymbol(nextChar());</span>
<span class="line-modified">!             Name name = readName(nextChar());</span>
              if (name == null) name = names.empty;
              long flags = adjustClassFlags(nextChar());
              if (outer != null) { // we have a member class
                  if (name == names.empty)
                      name = names.one;
<span class="line-new-header">--- 2501,14 ---</span>
       */
      void readInnerClasses(ClassSymbol c) {
          int n = nextChar();
          for (int i = 0; i &lt; n; i++) {
              nextChar(); // skip inner class symbol
<span class="line-modified">!             int outerIdx = nextChar();</span>
<span class="line-modified">!             int nameIdx = nextChar();</span>
<span class="line-added">+             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);</span>
<span class="line-added">+             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);</span>
              if (name == null) name = names.empty;
              long flags = adjustClassFlags(nextChar());
              if (outer != null) { // we have a member class
                  if (name == names.empty)
                      name = names.one;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2794,11 ***</span>
              } else {
                  preview.warnPreview(c.classfile, majorVersion);
              }
          }
  
<span class="line-modified">!         indexPool();</span>
          if (signatureBuffer.length &lt; bp) {
              int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
              signatureBuffer = new byte[ns];
          }
          readClass(c);
<span class="line-new-header">--- 2558,12 ---</span>
              } else {
                  preview.warnPreview(c.classfile, majorVersion);
              }
          }
  
<span class="line-modified">!         poolReader = new PoolReader(this, names, syms);</span>
<span class="line-added">+         bp = poolReader.readPool(buf, bp);</span>
          if (signatureBuffer.length &lt; bp) {
              int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
              signatureBuffer = new byte[ns];
          }
          readClass(c);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2811,11 ***</span>
          filling = true;
          target = null;
          repeatable = null;
          try {
              bp = 0;
<span class="line-modified">!             buf = readInputStream(buf, c.classfile.openInputStream());</span>
              readClassBuffer(c);
              if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
                  List&lt;Type&gt; missing = missingTypeVariables;
                  List&lt;Type&gt; found = foundTypeVariables;
                  missingTypeVariables = List.nil();
<span class="line-new-header">--- 2576,12 ---</span>
          filling = true;
          target = null;
          repeatable = null;
          try {
              bp = 0;
<span class="line-modified">!             buf.reset();</span>
<span class="line-added">+             buf.appendStream(c.classfile.openInputStream());</span>
              readClassBuffer(c);
              if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
                  List&lt;Type&gt; missing = missingTypeVariables;
                  List&lt;Type&gt; found = foundTypeVariables;
                  missingTypeVariables = List.nil();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2865,47 ***</span>
              missingTypeVariables = List.nil();
              foundTypeVariables = List.nil();
              filling = false;
          }
      }
<span class="line-removed">-     // where</span>
<span class="line-removed">-         private static byte[] readInputStream(byte[] buf, InputStream s) throws IOException {</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 buf = ensureCapacity(buf, s.available());</span>
<span class="line-removed">-                 int r = s.read(buf);</span>
<span class="line-removed">-                 int bp = 0;</span>
<span class="line-removed">-                 while (r != -1) {</span>
<span class="line-removed">-                     bp += r;</span>
<span class="line-removed">-                     buf = ensureCapacity(buf, bp);</span>
<span class="line-removed">-                     r = s.read(buf, bp, buf.length - bp);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 return buf;</span>
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 try {</span>
<span class="line-removed">-                     s.close();</span>
<span class="line-removed">-                 } catch (IOException e) {</span>
<span class="line-removed">-                     /* Ignore any errors, as this stream may have already</span>
<span class="line-removed">-                      * thrown a related exception which is the one that</span>
<span class="line-removed">-                      * should be reported.</span>
<span class="line-removed">-                      */</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-          * ensureCapacity will increase the buffer as needed, taking note that</span>
<span class="line-removed">-          * the new buffer will always be greater than the needed and never</span>
<span class="line-removed">-          * exactly equal to the needed size or bp. If equal then the read (above)</span>
<span class="line-removed">-          * will infinitely loop as buf.length - bp == 0.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         private static byte[] ensureCapacity(byte[] buf, int needed) {</span>
<span class="line-removed">-             if (buf.length &lt;= needed) {</span>
<span class="line-removed">-                 byte[] old = buf;</span>
<span class="line-removed">-                 buf = new byte[Integer.highestOneBit(needed) &lt;&lt; 1];</span>
<span class="line-removed">-                 System.arraycopy(old, 0, buf, 0, old.length);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return buf;</span>
<span class="line-removed">-         }</span>
  
      /** We can only read a single class file at a time; this
       *  flag keeps track of when we are currently reading a class
       *  file.
       */
<span class="line-new-header">--- 2631,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3077,26 ***</span>
                      deproxy = new AnnotationDeproxy(proxyOn);
                      theRepeatable = deproxy.deproxyCompound(repeatable);
                  }
              } catch (Exception e) {
                  throw new CompletionFailure(sym,
<span class="line-modified">!                                             ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),</span>
                                              dcfh);
              }
  
              sym.getAnnotationTypeMetadata().setTarget(theTarget);
              sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
          }
      }
  
      private class ProxyType extends Type {
  
<span class="line-modified">!         private final byte[] content;</span>
  
<span class="line-modified">!         public ProxyType(byte[] content) {</span>
              super(syms.noSymbol, TypeMetadata.EMPTY);
<span class="line-modified">!             this.content = content;</span>
          }
  
          @Override
          public TypeTag getTag() {
              return TypeTag.NONE;
<span class="line-new-header">--- 2806,26 ---</span>
                      deproxy = new AnnotationDeproxy(proxyOn);
                      theRepeatable = deproxy.deproxyCompound(repeatable);
                  }
              } catch (Exception e) {
                  throw new CompletionFailure(sym,
<span class="line-modified">!                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),</span>
                                              dcfh);
              }
  
              sym.getAnnotationTypeMetadata().setTarget(theTarget);
              sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
          }
      }
  
      private class ProxyType extends Type {
  
<span class="line-modified">!         private final Name name;</span>
  
<span class="line-modified">!         public ProxyType(int index) {</span>
              super(syms.noSymbol, TypeMetadata.EMPTY);
<span class="line-modified">!             this.name = poolReader.getName(index);</span>
          }
  
          @Override
          public TypeTag getTag() {
              return TypeTag.NONE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3106,11 ***</span>
          public Type cloneWithMetadata(TypeMetadata metadata) {
              throw new UnsupportedOperationException();
          }
  
          public Type resolve() {
<span class="line-modified">!             return sigToType(content, 0, content.length);</span>
          }
  
          @Override @DefinedBy(Api.LANGUAGE_MODEL)
          public String toString() {
              return &quot;&lt;ProxyType&gt;&quot;;
<span class="line-new-header">--- 2835,11 ---</span>
          public Type cloneWithMetadata(TypeMetadata metadata) {
              throw new UnsupportedOperationException();
          }
  
          public Type resolve() {
<span class="line-modified">!             return name.map(ClassReader.this::sigToType);</span>
          }
  
          @Override @DefinedBy(Api.LANGUAGE_MODEL)
          public String toString() {
              return &quot;&lt;ProxyType&gt;&quot;;
</pre>
<center><a href="ClassFile.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
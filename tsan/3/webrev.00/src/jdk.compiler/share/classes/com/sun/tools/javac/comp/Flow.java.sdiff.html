<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Enter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Infer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;

  33 
  34 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  35 import com.sun.tools.javac.code.*;
  36 import com.sun.tools.javac.code.Scope.WriteableScope;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  39 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  40 import com.sun.tools.javac.tree.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  43 import com.sun.tools.javac.util.JCDiagnostic.Error;
  44 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  45 
  46 import com.sun.tools.javac.code.Symbol.*;
  47 import com.sun.tools.javac.tree.JCTree.*;
  48 
  49 import static com.sun.tools.javac.code.Flags.*;
  50 import static com.sun.tools.javac.code.Flags.BLOCK;
  51 import static com.sun.tools.javac.code.Kinds.Kind.*;
  52 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
</pre>
<hr />
<pre>
 119  *  continue&quot; iff any intervening finally cannot complete normally or V
 120  *  is DU at the end of every intervening finally block.  This &quot;due to
 121  *  the continue&quot; concept is then used in the spec for the loops.
 122  *
 123  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 124  *  blocks.  For liveness analysis, a break statement for which any
 125  *  intervening finally cannot complete normally is not considered to
 126  *  cause the target statement to be able to complete normally. Then
 127  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 128  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 129  *  to the break&quot; iff any intervening finally cannot complete normally
 130  *  or V is DU at the break and at the end of every intervening
 131  *  finally block.  (I suspect this latter condition can be
 132  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 133  *  all statements that can be &quot;broken&quot;.
 134  *
 135  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 136  *  return statement&quot; iff V is DA before the return statement or V is
 137  *  DA at the end of any intervening finally block.  Note that we
 138  *  don&#39;t have to worry about the return expression because this
<span class="line-modified"> 139  *  concept is only used for construcrors.</span>
 140  *
 141  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 142  *  assigned at the end of a constructor, which is needed for final
 143  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 144  *  of the constructor iff it is DA and the end of the body of the
 145  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 146  *
 147  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 148  *  intervening finally that cannot complete normally allows us to ignore
 149  *  an otherwise uncaught exception.
 150  *
 151  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 152  *  nonlocal transfers (break, continue, return, throw, method call that
 153  *  can throw a checked exception, and a constructor invocation that can
 154  *  thrown a checked exception) are recorded in a queue, and removed
 155  *  from the queue when we complete processing the target of the
 156  *  nonlocal transfer.  This allows us to modify the queue in accordance
 157  *  with the above rules when we encounter a finally clause.  The only
 158  *  exception to this [no pun intended] is that checked exceptions that
 159  *  are known to be caught or declared to be caught in the enclosing
</pre>
<hr />
<pre>
 205     private final boolean allowEffectivelyFinalInInnerClasses;
 206 
 207     public static Flow instance(Context context) {
 208         Flow instance = context.get(flowKey);
 209         if (instance == null)
 210             instance = new Flow(context);
 211         return instance;
 212     }
 213 
 214     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 215         new AliveAnalyzer().analyzeTree(env, make);
 216         new AssignAnalyzer().analyzeTree(env, make);
 217         new FlowAnalyzer().analyzeTree(env, make);
 218         new CaptureAnalyzer().analyzeTree(env, make);
 219     }
 220 
 221     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 222         Log.DiagnosticHandler diagHandler = null;
 223         //we need to disable diagnostics temporarily; the problem is that if
 224         //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified"> 225         //message will be reported and will cause compilation to skip the flow analyis</span>
 226         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 227         //related errors, which will allow for more errors to be detected
 228         if (!speculative) {
 229             diagHandler = new Log.DiscardDiagnosticHandler(log);
 230         }
 231         try {
 232             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 233         } finally {
 234             if (!speculative) {
 235                 log.popDiagnosticHandler(diagHandler);
 236             }
 237         }
 238     }
 239 
 240     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 241             JCLambda that, TreeMaker make) {
 242         //we need to disable diagnostics temporarily; the problem is that if
 243         //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified"> 244         //message will be reported and will cause compilation to skip the flow analyis</span>
 245         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 246         //related errors, which will allow for more errors to be detected
 247         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 248         try {
 249             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 250             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 251             flowAnalyzer.analyzeTree(env, that, make);
 252             return flowAnalyzer.inferredThrownTypes;
 253         } finally {
 254             log.popDiagnosticHandler(diagHandler);
 255         }
 256     }
 257 


































 258     /**
 259      * Definite assignment scan mode
 260      */
 261     enum FlowKind {
 262         /**
 263          * This is the normal DA/DU analysis mode
 264          */
 265         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 266         /**
 267          * This is the speculative DA/DU analysis mode used to speculatively
 268          * derive assertions within loop bodies
 269          */
 270         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 271 
 272         final String errKey;
 273         final boolean isFinal;
 274 
 275         FlowKind(String errKey, boolean isFinal) {
 276             this.errKey = errKey;
 277             this.isFinal = isFinal;
</pre>
<hr />
<pre>
 297     }
 298 
 299     /**
 300      * Base visitor class for all visitors implementing dataflow analysis logic.
 301      * This class define the shared logic for handling jumps (break/continue statements).
 302      */
 303     static abstract class BaseAnalyzer extends TreeScanner {
 304 
 305         enum JumpKind {
 306             BREAK(JCTree.Tag.BREAK) {
 307                 @Override
 308                 JCTree getTarget(JCTree tree) {
 309                     return ((JCBreak)tree).target;
 310                 }
 311             },
 312             CONTINUE(JCTree.Tag.CONTINUE) {
 313                 @Override
 314                 JCTree getTarget(JCTree tree) {
 315                     return ((JCContinue)tree).target;
 316                 }






 317             };
 318 
 319             final JCTree.Tag treeTag;
 320 
 321             private JumpKind(Tag treeTag) {
 322                 this.treeTag = treeTag;
 323             }
 324 
 325             abstract JCTree getTarget(JCTree tree);
 326         }
 327 
 328         /** The currently pending exits that go from current inner blocks
 329          *  to an enclosing block, in source order.
 330          */
 331         ListBuffer&lt;PendingExit&gt; pendingExits;
 332 
 333         /** A pending exit.  These are the statements return, break, and
 334          *  continue.  In addition, exception-throwing expressions or
 335          *  statements are put here when not known to be caught.  This
 336          *  will typically result in an error unless it is within a
</pre>
<hr />
<pre>
 369                         jk.getTarget(exit.tree) == tree) {
 370                     exit.resolveJump();
 371                     resolved = true;
 372                 } else {
 373                     pendingExits.append(exit);
 374                 }
 375             }
 376             return Liveness.from(resolved);
 377         }
 378 
 379         /** Resolve all continues of this statement. */
 380         Liveness resolveContinues(JCTree tree) {
 381             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 382         }
 383 
 384         /** Resolve all breaks of this statement. */
 385         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 386             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 387         }
 388 





 389         @Override
 390         public void scan(JCTree tree) {
 391             if (tree != null &amp;&amp; (
 392                     tree.type == null ||
 393                     tree.type != Type.stuckType)) {
 394                 super.scan(tree);
 395             }
 396         }
 397 
 398         public void visitPackageDef(JCPackageDecl tree) {
 399             // Do nothing for PackageDecl
 400         }
 401 
 402         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
<span class="line-modified"> 403             JCBreak brk = make.at(Position.NOPOS).Break(null);</span>
<span class="line-modified"> 404             brk.target = swtch;</span>
<span class="line-modified"> 405             scan(brk);</span>






 406         }
 407     }
 408 
 409     /**
 410      * This pass implements the first step of the dataflow analysis, namely
 411      * the liveness analysis check. This checks that every statement is reachable.
 412      * The output of this analysis pass are used by other analyzers. This analyzer
 413      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 414      */
 415     class AliveAnalyzer extends BaseAnalyzer {
 416 
 417         /** A flag that indicates whether the last statement could
 418          *  complete normally.
 419          */
 420         private Liveness alive;
 421 
 422         @Override
 423         void markDead() {
 424             alive = Liveness.DEAD;
 425         }
</pre>
<hr />
<pre>
 491                     }
 492                 }
 493             } finally {
 494                 pendingExits = pendingExitsPrev;
 495                 alive = alivePrev;
 496                 lint = lintPrev;
 497             }
 498         }
 499 
 500         public void visitMethodDef(JCMethodDecl tree) {
 501             if (tree.body == null) return;
 502             Lint lintPrev = lint;
 503 
 504             lint = lint.augment(tree.sym);
 505 
 506             Assert.check(pendingExits.isEmpty());
 507 
 508             try {
 509                 alive = Liveness.ALIVE;
 510                 scanStat(tree.body);

 511 
 512                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 513                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 514 
 515                 List&lt;PendingExit&gt; exits = pendingExits.toList();
 516                 pendingExits = new ListBuffer&lt;&gt;();
 517                 while (exits.nonEmpty()) {
 518                     PendingExit exit = exits.head;
 519                     exits = exits.tail;
<span class="line-modified"> 520                     Assert.check(exit.tree.hasTag(RETURN));</span>

 521                 }
 522             } finally {
 523                 lint = lintPrev;
 524             }
 525         }
 526 
 527         public void visitVarDef(JCVariableDecl tree) {
 528             if (tree.init != null) {
 529                 Lint lintPrev = lint;
 530                 lint = lint.augment(tree.sym);
 531                 try{
 532                     scan(tree.init);
 533                 } finally {
 534                     lint = lintPrev;
 535                 }
 536             }
 537         }
 538 
 539         public void visitBlock(JCBlock tree) {
 540             scanStats(tree.stats);
</pre>
<hr />
<pre>
 660                                 constants.remove(pat.type.constValue());
 661                         }
 662                     }
 663                 }
 664                 scanStats(c.stats);
 665                 if (alive == Liveness.ALIVE) {
 666                     if (c.caseKind == JCCase.RULE) {
 667                         log.error(TreeInfo.diagEndPos(c.body),
 668                                   Errors.RuleCompletesNormally);
 669                     } else if (l.tail.isEmpty()) {
 670                         log.error(TreeInfo.diagEndPos(tree),
 671                                   Errors.SwitchExpressionCompletesNormally);
 672                     }
 673                 }
 674                 c.completesNormally = alive != Liveness.DEAD;
 675             }
 676             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 677                 log.error(tree, Errors.NotExhaustive);
 678             }
 679             alive = prevAlive;
<span class="line-modified"> 680             alive = alive.or(resolveBreaks(tree, prevPendingExits));</span>
 681         }
 682 
 683         public void visitTry(JCTry tree) {
 684             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 685             pendingExits = new ListBuffer&lt;&gt;();
 686             for (JCTree resource : tree.resources) {
 687                 if (resource instanceof JCVariableDecl) {
 688                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 689                     visitVarDef(vdecl);
 690                 } else if (resource instanceof JCExpression) {
 691                     scan((JCExpression) resource);
 692                 } else {
 693                     throw new AssertionError(tree);  // parser error
 694                 }
 695             }
 696 
 697             scanStat(tree.body);
 698             Liveness aliveEnd = alive;
 699 
 700             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
 728                 pendingExits = prevPendingExits;
 729                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 730             }
 731         }
 732 
 733         @Override
 734         public void visitIf(JCIf tree) {
 735             scan(tree.cond);
 736             scanStat(tree.thenpart);
 737             if (tree.elsepart != null) {
 738                 Liveness aliveAfterThen = alive;
 739                 alive = Liveness.ALIVE;
 740                 scanStat(tree.elsepart);
 741                 alive = alive.or(aliveAfterThen);
 742             } else {
 743                 alive = Liveness.ALIVE;
 744             }
 745         }
 746 
 747         public void visitBreak(JCBreak tree) {
<span class="line-modified"> 748             if (tree.isValueBreak())</span>
<span class="line-modified"> 749                 scan(tree.value);</span>




 750             recordExit(new PendingExit(tree));
 751         }
 752 
 753         public void visitContinue(JCContinue tree) {
 754             recordExit(new PendingExit(tree));
 755         }
 756 
 757         public void visitReturn(JCReturn tree) {
 758             scan(tree.expr);
 759             recordExit(new PendingExit(tree));
 760         }
 761 
 762         public void visitThrow(JCThrow tree) {
 763             scan(tree.expr);
 764             markDead();
 765         }
 766 
 767         public void visitApply(JCMethodInvocation tree) {
 768             scan(tree.meth);
 769             scan(tree.args);
</pre>
<hr />
<pre>
1015             try {
1016                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1017                     JCVariableDecl def = l.head;
1018                     scan(def);
1019                 }
1020                 if (TreeInfo.isInitialConstructor(tree))
1021                     caught = chk.union(caught, mthrown);
1022                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1023                     caught = mthrown;
1024                 // else we are in an instance initializer block;
1025                 // leave caught unchanged.
1026 
1027                 scan(tree.body);
1028 
1029                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1030                 pendingExits = new ListBuffer&lt;&gt;();
1031                 while (exits.nonEmpty()) {
1032                     PendingExit exit = exits.head;
1033                     exits = exits.tail;
1034                     if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">1035                         Assert.check(exit.tree.hasTag(RETURN));</span>

1036                     } else {
1037                         // uncaught throws will be reported later
1038                         pendingExits.append(exit);
1039                     }
1040                 }
1041             } finally {
1042                 caught = caughtPrev;
1043                 lint = lintPrev;
1044             }
1045         }
1046 
1047         public void visitVarDef(JCVariableDecl tree) {
1048             if (tree.init != null) {
1049                 Lint lintPrev = lint;
1050                 lint = lint.augment(tree.sym);
1051                 try{
1052                     scan(tree.init);
1053                 } finally {
1054                     lint = lintPrev;
1055                 }
</pre>
<hr />
<pre>
1109         }
1110 
1111         public void visitSwitch(JCSwitch tree) {
1112             handleSwitch(tree, tree.selector, tree.cases);
1113         }
1114 
1115         @Override
1116         public void visitSwitchExpression(JCSwitchExpression tree) {
1117             handleSwitch(tree, tree.selector, tree.cases);
1118         }
1119 
1120         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1121             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1122             pendingExits = new ListBuffer&lt;&gt;();
1123             scan(selector);
1124             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1125                 JCCase c = l.head;
1126                 scan(c.pats);
1127                 scan(c.stats);
1128             }
<span class="line-modified">1129             resolveBreaks(tree, prevPendingExits);</span>




1130         }
1131 
1132         public void visitTry(JCTry tree) {
1133             List&lt;Type&gt; caughtPrev = caught;
1134             List&lt;Type&gt; thrownPrev = thrown;
1135             thrown = List.nil();
1136             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1137                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1138                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1139                         List.of(l.head.param.vartype);
1140                 for (JCExpression ct : subClauses) {
1141                     caught = chk.incl(ct.type, caught);
1142                 }
1143             }
1144 
1145             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1146             pendingExits = new ListBuffer&lt;&gt;();
1147             for (JCTree resource : tree.resources) {
1148                 if (resource instanceof JCVariableDecl) {
1149                     JCVariableDecl vdecl = (JCVariableDecl) resource;
</pre>
<hr />
<pre>
1230         }
1231 
1232         @Override
1233         public void visitIf(JCIf tree) {
1234             scan(tree.cond);
1235             scan(tree.thenpart);
1236             if (tree.elsepart != null) {
1237                 scan(tree.elsepart);
1238             }
1239         }
1240 
1241         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1242             if (chk.subset(exc, caughtInTry)) {
1243                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1244             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1245                     !isExceptionOrThrowable(exc) &amp;&amp;
1246                     !chk.intersects(exc, thrownInTry)) {
1247                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1248             } else {
1249                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
<span class="line-modified">1250                 // &#39;catchableThrownTypes&#39; cannnot possibly be empty - if &#39;exc&#39; was an</span>
1251                 // unchecked exception, the result list would not be empty, as the augmented
1252                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1253                 // exception, that would have been covered in the branch above
1254                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1255                         !isExceptionOrThrowable(exc)) {
1256                     Warning key = catchableThrownTypes.length() == 1 ?
1257                             Warnings.UnreachableCatch(catchableThrownTypes) :
1258                             Warnings.UnreachableCatch1(catchableThrownTypes);
1259                     log.warning(pos, key);
1260                 }
1261             }
1262         }
1263         //where
1264             private boolean isExceptionOrThrowable(Type exc) {
1265                 return exc.tsym == syms.throwableType.tsym ||
1266                     exc.tsym == syms.exceptionType.tsym;
1267             }
1268 
1269         public void visitBreak(JCBreak tree) {
<span class="line-modified">1270             if (tree.isValueBreak())</span>
<span class="line-modified">1271                 scan(tree.value);</span>



1272             recordExit(new PendingExit(tree));
1273         }
1274 
1275         public void visitContinue(JCContinue tree) {
1276             recordExit(new PendingExit(tree));
1277         }
1278 
1279         public void visitReturn(JCReturn tree) {
1280             scan(tree.expr);
1281             recordExit(new PendingExit(tree));
1282         }
1283 
1284         public void visitThrow(JCThrow tree) {
1285             scan(tree.expr);
1286             Symbol sym = TreeInfo.symbol(tree.expr);
1287             if (sym != null &amp;&amp;
1288                 sym.kind == VAR &amp;&amp;
1289                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1290                 preciseRethrowTypes.get(sym) != null) {
1291                 for (Type t : preciseRethrowTypes.get(sym)) {
</pre>
<hr />
<pre>
1340         @Override
1341         public void visitLambda(JCLambda tree) {
1342             if (tree.type != null &amp;&amp;
1343                     tree.type.isErroneous()) {
1344                 return;
1345             }
1346             List&lt;Type&gt; prevCaught = caught;
1347             List&lt;Type&gt; prevThrown = thrown;
1348             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1349             try {
1350                 pendingExits = new ListBuffer&lt;&gt;();
1351                 caught = tree.getDescriptorType(types).getThrownTypes();
1352                 thrown = List.nil();
1353                 scan(tree.body);
1354                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1355                 pendingExits = new ListBuffer&lt;&gt;();
1356                 while (exits.nonEmpty()) {
1357                     PendingExit exit = exits.head;
1358                     exits = exits.tail;
1359                     if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">1360                         Assert.check(exit.tree.hasTag(RETURN));</span>

1361                     } else {
1362                         // uncaught throws will be reported later
1363                         pendingExits.append(exit);
1364                     }
1365                 }
1366 
1367                 errorUncaught();
1368             } finally {
1369                 pendingExits = prevPending;
1370                 caught = prevCaught;
1371                 thrown = prevThrown;
1372             }
1373         }
1374 
1375         public void visitModuleDef(JCModuleDecl tree) {
1376             // Do nothing for modules
1377         }
1378 
1379     /**************************************************************************
1380      * main method
</pre>
<hr />
<pre>
1418 
1419         @Override
1420         public void visitLambda(JCLambda tree) {
1421             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1422                 return;
1423             }
1424             inLambda = true;
1425             try {
1426                 super.visitLambda(tree);
1427             } finally {
1428                 inLambda = false;
1429             }
1430         }
1431 
1432         @Override
1433         public void visitClassDef(JCClassDecl tree) {
1434             //skip
1435         }
1436     }
1437 






























































1438     /**
1439      * Specialized pass that performs DA/DU on a lambda
1440      */
1441     class LambdaAssignAnalyzer extends AssignAnalyzer {
1442         WriteableScope enclosedSymbols;
1443         boolean inLambda;
1444 
1445         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1446             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1447         }
1448 
1449         @Override
1450         public void visitLambda(JCLambda tree) {
1451             if (inLambda) {
1452                 return;
1453             }
1454             inLambda = true;
1455             try {
1456                 super.visitLambda(tree);
1457             } finally {
</pre>
<hr />
<pre>
1717         void letInit(JCTree tree) {
1718             tree = TreeInfo.skipParens(tree);
1719             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1720                 Symbol sym = TreeInfo.symbol(tree);
1721                 if (sym.kind == VAR) {
1722                     letInit(tree.pos(), (VarSymbol)sym);
1723                 }
1724             }
1725         }
1726 
1727         /** Check that trackable variable is initialized.
1728          */
1729         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1730             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1731         }
1732 
1733         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1734             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1735                 trackable(sym) &amp;&amp;
1736                 !inits.isMember(sym.adr)) {
<span class="line-modified">1737                 log.error(pos, errkey);</span>
1738                 inits.incl(sym.adr);
1739             }
1740         }
1741 
1742         /** Utility method to reset several Bits instances.
1743          */
1744         private void resetBits(Bits... bits) {
1745             for (Bits b : bits) {
1746                 b.reset();
1747             }
1748         }
1749 
1750         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1751          */
1752         void split(boolean setToNull) {
1753             initsWhenFalse.assign(inits);
1754             uninitsWhenFalse.assign(uninits);
1755             initsWhenTrue.assign(inits);
1756             uninitsWhenTrue.assign(uninits);
1757             if (setToNull) {
</pre>
<hr />
<pre>
1937                 boolean lastInitialConstructor = isInitialConstructor;
1938                 try {
1939                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
1940 
1941                     if (!isInitialConstructor) {
1942                         firstadr = nextadr;
1943                     }
1944                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1945                         JCVariableDecl def = l.head;
1946                         scan(def);
1947                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
1948                         /*  If we are executing the code from Gen, then there can be
1949                          *  synthetic or mandated variables, ignore them.
1950                          */
1951                         initParam(def);
1952                     }
1953                     // else we are in an instance initializer block;
1954                     // leave caught unchanged.
1955                     scan(tree.body);
1956 

1957                     if (isInitialConstructor) {
1958                         boolean isSynthesized = (tree.sym.flags() &amp;
1959                                                  GENERATEDCONSTR) != 0;
1960                         for (int i = firstadr; i &lt; nextadr; i++) {
1961                             JCVariableDecl vardecl = vardecls[i];
1962                             VarSymbol var = vardecl.sym;
1963                             if (var.owner == classDef.sym) {
1964                                 // choose the diagnostic position based on whether
1965                                 // the ctor is default(synthesized) or not
<span class="line-modified">1966                                 if (isSynthesized) {</span>
1967                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
<span class="line-modified">1968                                         var, Errors.VarNotInitializedInDefaultConstructor(var));</span>


















1969                                 } else {
1970                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
1971                                 }
1972                             }
1973                         }
1974                     }
1975                     List&lt;PendingExit&gt; exits = pendingExits.toList();
1976                     pendingExits = new ListBuffer&lt;&gt;();
1977                     while (exits.nonEmpty()) {
1978                         PendingExit exit = exits.head;
1979                         exits = exits.tail;
<span class="line-modified">1980                         Assert.check(exit.tree.hasTag(RETURN), exit.tree);</span>


1981                         if (isInitialConstructor) {
1982                             Assert.check(exit instanceof AssignPendingExit);
1983                             inits.assign(((AssignPendingExit) exit).exit_inits);
1984                             for (int i = firstadr; i &lt; nextadr; i++) {
1985                                 checkInit(exit.tree.pos(), vardecls[i].sym);
1986                             }
1987                         }
1988                     }
1989                 } finally {
1990                     inits.assign(initsPrev);
1991                     uninits.assign(uninitsPrev);
1992                     nextadr = nextadrPrev;
1993                     firstadr = firstadrPrev;
1994                     returnadr = returnadrPrev;
1995                     isInitialConstructor = lastInitialConstructor;
1996                 }
1997             } finally {
1998                 lint = lintPrev;
1999             }
2000         }
</pre>
<hr />
<pre>
2209                     for (JCExpression pat : c.pats) {
2210                         scanExpr(pat);
2211                     }
2212                 }
2213                 if (hasDefault) {
2214                     inits.assign(initsSwitch);
2215                     uninits.assign(uninits.andSet(uninitsSwitch));
2216                 }
2217                 scan(c.stats);
2218                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2219                     scanSyntheticBreak(make, tree);
2220                 }
2221                 addVars(c.stats, initsSwitch, uninitsSwitch);
2222                 if (!hasDefault) {
2223                     inits.assign(initsSwitch);
2224                     uninits.assign(uninits.andSet(uninitsSwitch));
2225                 }
2226                 // Warn about fall-through if lint switch fallthrough enabled.
2227             }
2228             if (!hasDefault) {
<span class="line-modified">2229                 inits.andSet(initsSwitch);</span>









2230             }
<span class="line-removed">2231             resolveBreaks(tree, prevPendingExits);</span>
2232             nextadr = nextadrPrev;
2233         }
2234         // where
2235             /** Add any variables defined in stats to inits and uninits. */
2236             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2237                                         final Bits uninits) {
2238                 for (;stats.nonEmpty(); stats = stats.tail) {
2239                     JCTree stat = stats.head;
2240                     if (stat.hasTag(VARDEF)) {
2241                         int adr = ((JCVariableDecl) stat).sym.adr;
2242                         inits.excl(adr);
2243                         uninits.incl(adr);
2244                     }
2245                 }
2246             }
2247 
2248         public void visitTry(JCTry tree) {
2249             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2250             final Bits uninitsTryPrev = new Bits(uninitsTry);
2251             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
</pre>
<hr />
<pre>
2376             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2377             inits.assign(initsWhenTrue);
2378             uninits.assign(uninitsWhenTrue);
2379             scan(tree.thenpart);
2380             if (tree.elsepart != null) {
2381                 final Bits initsAfterThen = new Bits(inits);
2382                 final Bits uninitsAfterThen = new Bits(uninits);
2383                 inits.assign(initsBeforeElse);
2384                 uninits.assign(uninitsBeforeElse);
2385                 scan(tree.elsepart);
2386                 inits.andSet(initsAfterThen);
2387                 uninits.andSet(uninitsAfterThen);
2388             } else {
2389                 inits.andSet(initsBeforeElse);
2390                 uninits.andSet(uninitsBeforeElse);
2391             }
2392         }
2393 
2394         @Override
2395         public void visitBreak(JCBreak tree) {
<span class="line-modified">2396             if (tree.isValueBreak()) {</span>
<span class="line-modified">2397                 if (tree.target.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-modified">2398                     JCSwitchExpression expr = (JCSwitchExpression) tree.target;</span>
<span class="line-modified">2399                     if (expr.type.hasTag(BOOLEAN)) {</span>
<span class="line-modified">2400                         scanCond(tree.value);</span>
<span class="line-modified">2401                         Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);</span>
<span class="line-modified">2402                         Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);</span>
<span class="line-modified">2403                         Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);</span>
<span class="line-modified">2404                         Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);</span>
<span class="line-modified">2405                         PendingExit exit = new PendingExit(tree) {</span>
<span class="line-modified">2406                             @Override</span>
<span class="line-modified">2407                             void resolveJump() {</span>
<span class="line-modified">2408                                 if (!inits.isReset()) {</span>
<span class="line-modified">2409                                     split(true);</span>
<span class="line-modified">2410                                 }</span>
<span class="line-modified">2411                                 initsWhenTrue.andSet(initsAfterBreakWhenTrue);</span>
<span class="line-modified">2412                                 initsWhenFalse.andSet(initsAfterBreakWhenFalse);</span>
<span class="line-modified">2413                                 uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);</span>
<span class="line-modified">2414                                 uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);</span>
<span class="line-modified">2415                             }</span>
<span class="line-modified">2416                         };</span>
<span class="line-modified">2417                         merge();</span>
<span class="line-removed">2418                         recordExit(exit);</span>
<span class="line-removed">2419                         return ;</span>
2420                     }
<span class="line-modified">2421                 }</span>
<span class="line-modified">2422                 scan(tree.value);</span>





2423             }
<span class="line-removed">2424             recordExit(new AssignPendingExit(tree, inits, uninits));</span>
2425         }
2426 
2427         @Override
2428         public void visitContinue(JCContinue tree) {
2429             recordExit(new AssignPendingExit(tree, inits, uninits));
2430         }
2431 
2432         @Override
2433         public void visitReturn(JCReturn tree) {
2434             scanExpr(tree.expr);
2435             recordExit(new AssignPendingExit(tree, inits, uninits));
2436         }
2437 
2438         public void visitThrow(JCThrow tree) {
2439             scanExpr(tree.expr);
2440             markDead();
2441         }
2442 
2443         public void visitApply(JCMethodInvocation tree) {
2444             scanExpr(tree.meth);
</pre>
<hr />
<pre>
2767                     letInit(tree.arg);
2768                     break;
2769                 default:
2770                     scan(tree.arg);
2771             }
2772         }
2773 
2774         public void visitTry(JCTry tree) {
2775             for (JCTree resource : tree.resources) {
2776                 if (!resource.hasTag(VARDEF)) {
2777                     Symbol var = TreeInfo.symbol(resource);
2778                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
2779                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
2780                     }
2781                 }
2782             }
2783             super.visitTry(tree);
2784         }
2785 
2786         @Override
<span class="line-modified">2787         public void visitBreak(JCBreak tree) {</span>
<span class="line-modified">2788             if (tree.isValueBreak())</span>
<span class="line-removed">2789                 scan(tree.value);</span>
2790         }
2791 
2792         public void visitModuleDef(JCModuleDecl tree) {
2793             // Do nothing for modules
2794         }
2795 
2796     /**************************************************************************
2797      * main method
2798      *************************************************************************/
2799 
2800         /** Perform definite assignment/unassignment analysis on a tree.
2801          */
2802         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
2803             analyzeTree(env, env.tree, make);
2804         }
2805         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
2806             try {
2807                 attrEnv = env;
2808                 Flow.this.make = make;
2809                 pendingExits = new ListBuffer&lt;&gt;();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
<span class="line-added">  33 import java.util.stream.Collectors;</span>
  34 
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
</pre>
<hr />
<pre>
 120  *  continue&quot; iff any intervening finally cannot complete normally or V
 121  *  is DU at the end of every intervening finally block.  This &quot;due to
 122  *  the continue&quot; concept is then used in the spec for the loops.
 123  *
 124  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 125  *  blocks.  For liveness analysis, a break statement for which any
 126  *  intervening finally cannot complete normally is not considered to
 127  *  cause the target statement to be able to complete normally. Then
 128  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 129  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 130  *  to the break&quot; iff any intervening finally cannot complete normally
 131  *  or V is DU at the break and at the end of every intervening
 132  *  finally block.  (I suspect this latter condition can be
 133  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 134  *  all statements that can be &quot;broken&quot;.
 135  *
 136  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 137  *  return statement&quot; iff V is DA before the return statement or V is
 138  *  DA at the end of any intervening finally block.  Note that we
 139  *  don&#39;t have to worry about the return expression because this
<span class="line-modified"> 140  *  concept is only used for constructors.</span>
 141  *
 142  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 143  *  assigned at the end of a constructor, which is needed for final
 144  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 145  *  of the constructor iff it is DA and the end of the body of the
 146  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 147  *
 148  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 149  *  intervening finally that cannot complete normally allows us to ignore
 150  *  an otherwise uncaught exception.
 151  *
 152  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 153  *  nonlocal transfers (break, continue, return, throw, method call that
 154  *  can throw a checked exception, and a constructor invocation that can
 155  *  thrown a checked exception) are recorded in a queue, and removed
 156  *  from the queue when we complete processing the target of the
 157  *  nonlocal transfer.  This allows us to modify the queue in accordance
 158  *  with the above rules when we encounter a finally clause.  The only
 159  *  exception to this [no pun intended] is that checked exceptions that
 160  *  are known to be caught or declared to be caught in the enclosing
</pre>
<hr />
<pre>
 206     private final boolean allowEffectivelyFinalInInnerClasses;
 207 
 208     public static Flow instance(Context context) {
 209         Flow instance = context.get(flowKey);
 210         if (instance == null)
 211             instance = new Flow(context);
 212         return instance;
 213     }
 214 
 215     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 216         new AliveAnalyzer().analyzeTree(env, make);
 217         new AssignAnalyzer().analyzeTree(env, make);
 218         new FlowAnalyzer().analyzeTree(env, make);
 219         new CaptureAnalyzer().analyzeTree(env, make);
 220     }
 221 
 222     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 223         Log.DiagnosticHandler diagHandler = null;
 224         //we need to disable diagnostics temporarily; the problem is that if
 225         //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified"> 226         //message will be reported and will cause compilation to skip the flow analysis</span>
 227         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 228         //related errors, which will allow for more errors to be detected
 229         if (!speculative) {
 230             diagHandler = new Log.DiscardDiagnosticHandler(log);
 231         }
 232         try {
 233             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 234         } finally {
 235             if (!speculative) {
 236                 log.popDiagnosticHandler(diagHandler);
 237             }
 238         }
 239     }
 240 
 241     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 242             JCLambda that, TreeMaker make) {
 243         //we need to disable diagnostics temporarily; the problem is that if
 244         //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified"> 245         //message will be reported and will cause compilation to skip the flow analysis</span>
 246         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 247         //related errors, which will allow for more errors to be detected
 248         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 249         try {
 250             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 251             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 252             flowAnalyzer.analyzeTree(env, that, make);
 253             return flowAnalyzer.inferredThrownTypes;
 254         } finally {
 255             log.popDiagnosticHandler(diagHandler);
 256         }
 257     }
 258 
<span class="line-added"> 259     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {</span>
<span class="line-added"> 260         //we need to disable diagnostics temporarily; the problem is that if</span>
<span class="line-added"> 261         //&quot;that&quot; contains e.g. an unreachable statement, an error</span>
<span class="line-added"> 262         //message will be reported and will cause compilation to skip the flow analysis</span>
<span class="line-added"> 263         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis</span>
<span class="line-added"> 264         //related errors, which will allow for more errors to be detected</span>
<span class="line-added"> 265         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);</span>
<span class="line-added"> 266         try {</span>
<span class="line-added"> 267             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();</span>
<span class="line-added"> 268 </span>
<span class="line-added"> 269             analyzer.analyzeTree(env, that, make);</span>
<span class="line-added"> 270             return analyzer.isAlive();</span>
<span class="line-added"> 271         } finally {</span>
<span class="line-added"> 272             log.popDiagnosticHandler(diagHandler);</span>
<span class="line-added"> 273         }</span>
<span class="line-added"> 274     }</span>
<span class="line-added"> 275 </span>
<span class="line-added"> 276     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {</span>
<span class="line-added"> 277         //we need to disable diagnostics temporarily; the problem is that if</span>
<span class="line-added"> 278         //&quot;that&quot; contains e.g. an unreachable statement, an error</span>
<span class="line-added"> 279         //message will be reported and will cause compilation to skip the flow analysis</span>
<span class="line-added"> 280         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis</span>
<span class="line-added"> 281         //related errors, which will allow for more errors to be detected</span>
<span class="line-added"> 282         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);</span>
<span class="line-added"> 283         try {</span>
<span class="line-added"> 284             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286             analyzer.analyzeTree(env, body, make);</span>
<span class="line-added"> 287             return analyzer.breaksOut();</span>
<span class="line-added"> 288         } finally {</span>
<span class="line-added"> 289             log.popDiagnosticHandler(diagHandler);</span>
<span class="line-added"> 290         }</span>
<span class="line-added"> 291     }</span>
<span class="line-added"> 292 </span>
 293     /**
 294      * Definite assignment scan mode
 295      */
 296     enum FlowKind {
 297         /**
 298          * This is the normal DA/DU analysis mode
 299          */
 300         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 301         /**
 302          * This is the speculative DA/DU analysis mode used to speculatively
 303          * derive assertions within loop bodies
 304          */
 305         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 306 
 307         final String errKey;
 308         final boolean isFinal;
 309 
 310         FlowKind(String errKey, boolean isFinal) {
 311             this.errKey = errKey;
 312             this.isFinal = isFinal;
</pre>
<hr />
<pre>
 332     }
 333 
 334     /**
 335      * Base visitor class for all visitors implementing dataflow analysis logic.
 336      * This class define the shared logic for handling jumps (break/continue statements).
 337      */
 338     static abstract class BaseAnalyzer extends TreeScanner {
 339 
 340         enum JumpKind {
 341             BREAK(JCTree.Tag.BREAK) {
 342                 @Override
 343                 JCTree getTarget(JCTree tree) {
 344                     return ((JCBreak)tree).target;
 345                 }
 346             },
 347             CONTINUE(JCTree.Tag.CONTINUE) {
 348                 @Override
 349                 JCTree getTarget(JCTree tree) {
 350                     return ((JCContinue)tree).target;
 351                 }
<span class="line-added"> 352             },</span>
<span class="line-added"> 353             YIELD(JCTree.Tag.YIELD) {</span>
<span class="line-added"> 354                 @Override</span>
<span class="line-added"> 355                 JCTree getTarget(JCTree tree) {</span>
<span class="line-added"> 356                     return ((JCYield)tree).target;</span>
<span class="line-added"> 357                 }</span>
 358             };
 359 
 360             final JCTree.Tag treeTag;
 361 
 362             private JumpKind(Tag treeTag) {
 363                 this.treeTag = treeTag;
 364             }
 365 
 366             abstract JCTree getTarget(JCTree tree);
 367         }
 368 
 369         /** The currently pending exits that go from current inner blocks
 370          *  to an enclosing block, in source order.
 371          */
 372         ListBuffer&lt;PendingExit&gt; pendingExits;
 373 
 374         /** A pending exit.  These are the statements return, break, and
 375          *  continue.  In addition, exception-throwing expressions or
 376          *  statements are put here when not known to be caught.  This
 377          *  will typically result in an error unless it is within a
</pre>
<hr />
<pre>
 410                         jk.getTarget(exit.tree) == tree) {
 411                     exit.resolveJump();
 412                     resolved = true;
 413                 } else {
 414                     pendingExits.append(exit);
 415                 }
 416             }
 417             return Liveness.from(resolved);
 418         }
 419 
 420         /** Resolve all continues of this statement. */
 421         Liveness resolveContinues(JCTree tree) {
 422             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 423         }
 424 
 425         /** Resolve all breaks of this statement. */
 426         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 427             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 428         }
 429 
<span class="line-added"> 430         /** Resolve all yields of this statement. */</span>
<span class="line-added"> 431         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {</span>
<span class="line-added"> 432             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);</span>
<span class="line-added"> 433         }</span>
<span class="line-added"> 434 </span>
 435         @Override
 436         public void scan(JCTree tree) {
 437             if (tree != null &amp;&amp; (
 438                     tree.type == null ||
 439                     tree.type != Type.stuckType)) {
 440                 super.scan(tree);
 441             }
 442         }
 443 
 444         public void visitPackageDef(JCPackageDecl tree) {
 445             // Do nothing for PackageDecl
 446         }
 447 
 448         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
<span class="line-modified"> 449             if (swtch.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-modified"> 450                 JCYield brk = make.at(Position.NOPOS).Yield(null);</span>
<span class="line-modified"> 451                 brk.target = swtch;</span>
<span class="line-added"> 452                 scan(brk);</span>
<span class="line-added"> 453             } else {</span>
<span class="line-added"> 454                 JCBreak brk = make.at(Position.NOPOS).Break(null);</span>
<span class="line-added"> 455                 brk.target = swtch;</span>
<span class="line-added"> 456                 scan(brk);</span>
<span class="line-added"> 457             }</span>
 458         }
 459     }
 460 
 461     /**
 462      * This pass implements the first step of the dataflow analysis, namely
 463      * the liveness analysis check. This checks that every statement is reachable.
 464      * The output of this analysis pass are used by other analyzers. This analyzer
 465      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 466      */
 467     class AliveAnalyzer extends BaseAnalyzer {
 468 
 469         /** A flag that indicates whether the last statement could
 470          *  complete normally.
 471          */
 472         private Liveness alive;
 473 
 474         @Override
 475         void markDead() {
 476             alive = Liveness.DEAD;
 477         }
</pre>
<hr />
<pre>
 543                     }
 544                 }
 545             } finally {
 546                 pendingExits = pendingExitsPrev;
 547                 alive = alivePrev;
 548                 lint = lintPrev;
 549             }
 550         }
 551 
 552         public void visitMethodDef(JCMethodDecl tree) {
 553             if (tree.body == null) return;
 554             Lint lintPrev = lint;
 555 
 556             lint = lint.augment(tree.sym);
 557 
 558             Assert.check(pendingExits.isEmpty());
 559 
 560             try {
 561                 alive = Liveness.ALIVE;
 562                 scanStat(tree.body);
<span class="line-added"> 563                 tree.completesNormally = alive != Liveness.DEAD;</span>
 564 
 565                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 566                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 567 
 568                 List&lt;PendingExit&gt; exits = pendingExits.toList();
 569                 pendingExits = new ListBuffer&lt;&gt;();
 570                 while (exits.nonEmpty()) {
 571                     PendingExit exit = exits.head;
 572                     exits = exits.tail;
<span class="line-modified"> 573                     Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added"> 574                                     log.hasErrorOn(exit.tree.pos()));</span>
 575                 }
 576             } finally {
 577                 lint = lintPrev;
 578             }
 579         }
 580 
 581         public void visitVarDef(JCVariableDecl tree) {
 582             if (tree.init != null) {
 583                 Lint lintPrev = lint;
 584                 lint = lint.augment(tree.sym);
 585                 try{
 586                     scan(tree.init);
 587                 } finally {
 588                     lint = lintPrev;
 589                 }
 590             }
 591         }
 592 
 593         public void visitBlock(JCBlock tree) {
 594             scanStats(tree.stats);
</pre>
<hr />
<pre>
 714                                 constants.remove(pat.type.constValue());
 715                         }
 716                     }
 717                 }
 718                 scanStats(c.stats);
 719                 if (alive == Liveness.ALIVE) {
 720                     if (c.caseKind == JCCase.RULE) {
 721                         log.error(TreeInfo.diagEndPos(c.body),
 722                                   Errors.RuleCompletesNormally);
 723                     } else if (l.tail.isEmpty()) {
 724                         log.error(TreeInfo.diagEndPos(tree),
 725                                   Errors.SwitchExpressionCompletesNormally);
 726                     }
 727                 }
 728                 c.completesNormally = alive != Liveness.DEAD;
 729             }
 730             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 731                 log.error(tree, Errors.NotExhaustive);
 732             }
 733             alive = prevAlive;
<span class="line-modified"> 734             alive = alive.or(resolveYields(tree, prevPendingExits));</span>
 735         }
 736 
 737         public void visitTry(JCTry tree) {
 738             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 739             pendingExits = new ListBuffer&lt;&gt;();
 740             for (JCTree resource : tree.resources) {
 741                 if (resource instanceof JCVariableDecl) {
 742                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 743                     visitVarDef(vdecl);
 744                 } else if (resource instanceof JCExpression) {
 745                     scan((JCExpression) resource);
 746                 } else {
 747                     throw new AssertionError(tree);  // parser error
 748                 }
 749             }
 750 
 751             scanStat(tree.body);
 752             Liveness aliveEnd = alive;
 753 
 754             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
 782                 pendingExits = prevPendingExits;
 783                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 784             }
 785         }
 786 
 787         @Override
 788         public void visitIf(JCIf tree) {
 789             scan(tree.cond);
 790             scanStat(tree.thenpart);
 791             if (tree.elsepart != null) {
 792                 Liveness aliveAfterThen = alive;
 793                 alive = Liveness.ALIVE;
 794                 scanStat(tree.elsepart);
 795                 alive = alive.or(aliveAfterThen);
 796             } else {
 797                 alive = Liveness.ALIVE;
 798             }
 799         }
 800 
 801         public void visitBreak(JCBreak tree) {
<span class="line-modified"> 802             recordExit(new PendingExit(tree));</span>
<span class="line-modified"> 803         }</span>
<span class="line-added"> 804 </span>
<span class="line-added"> 805         @Override</span>
<span class="line-added"> 806         public void visitYield(JCYield tree) {</span>
<span class="line-added"> 807             scan(tree.value);</span>
 808             recordExit(new PendingExit(tree));
 809         }
 810 
 811         public void visitContinue(JCContinue tree) {
 812             recordExit(new PendingExit(tree));
 813         }
 814 
 815         public void visitReturn(JCReturn tree) {
 816             scan(tree.expr);
 817             recordExit(new PendingExit(tree));
 818         }
 819 
 820         public void visitThrow(JCThrow tree) {
 821             scan(tree.expr);
 822             markDead();
 823         }
 824 
 825         public void visitApply(JCMethodInvocation tree) {
 826             scan(tree.meth);
 827             scan(tree.args);
</pre>
<hr />
<pre>
1073             try {
1074                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1075                     JCVariableDecl def = l.head;
1076                     scan(def);
1077                 }
1078                 if (TreeInfo.isInitialConstructor(tree))
1079                     caught = chk.union(caught, mthrown);
1080                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1081                     caught = mthrown;
1082                 // else we are in an instance initializer block;
1083                 // leave caught unchanged.
1084 
1085                 scan(tree.body);
1086 
1087                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1088                 pendingExits = new ListBuffer&lt;&gt;();
1089                 while (exits.nonEmpty()) {
1090                     PendingExit exit = exits.head;
1091                     exits = exits.tail;
1092                     if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">1093                         Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added">1094                                          log.hasErrorOn(exit.tree.pos()));</span>
1095                     } else {
1096                         // uncaught throws will be reported later
1097                         pendingExits.append(exit);
1098                     }
1099                 }
1100             } finally {
1101                 caught = caughtPrev;
1102                 lint = lintPrev;
1103             }
1104         }
1105 
1106         public void visitVarDef(JCVariableDecl tree) {
1107             if (tree.init != null) {
1108                 Lint lintPrev = lint;
1109                 lint = lint.augment(tree.sym);
1110                 try{
1111                     scan(tree.init);
1112                 } finally {
1113                     lint = lintPrev;
1114                 }
</pre>
<hr />
<pre>
1168         }
1169 
1170         public void visitSwitch(JCSwitch tree) {
1171             handleSwitch(tree, tree.selector, tree.cases);
1172         }
1173 
1174         @Override
1175         public void visitSwitchExpression(JCSwitchExpression tree) {
1176             handleSwitch(tree, tree.selector, tree.cases);
1177         }
1178 
1179         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1180             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1181             pendingExits = new ListBuffer&lt;&gt;();
1182             scan(selector);
1183             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1184                 JCCase c = l.head;
1185                 scan(c.pats);
1186                 scan(c.stats);
1187             }
<span class="line-modified">1188             if (tree.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-added">1189                 resolveYields(tree, prevPendingExits);</span>
<span class="line-added">1190             } else {</span>
<span class="line-added">1191                 resolveBreaks(tree, prevPendingExits);</span>
<span class="line-added">1192             }</span>
1193         }
1194 
1195         public void visitTry(JCTry tree) {
1196             List&lt;Type&gt; caughtPrev = caught;
1197             List&lt;Type&gt; thrownPrev = thrown;
1198             thrown = List.nil();
1199             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1200                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1201                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1202                         List.of(l.head.param.vartype);
1203                 for (JCExpression ct : subClauses) {
1204                     caught = chk.incl(ct.type, caught);
1205                 }
1206             }
1207 
1208             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1209             pendingExits = new ListBuffer&lt;&gt;();
1210             for (JCTree resource : tree.resources) {
1211                 if (resource instanceof JCVariableDecl) {
1212                     JCVariableDecl vdecl = (JCVariableDecl) resource;
</pre>
<hr />
<pre>
1293         }
1294 
1295         @Override
1296         public void visitIf(JCIf tree) {
1297             scan(tree.cond);
1298             scan(tree.thenpart);
1299             if (tree.elsepart != null) {
1300                 scan(tree.elsepart);
1301             }
1302         }
1303 
1304         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1305             if (chk.subset(exc, caughtInTry)) {
1306                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1307             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1308                     !isExceptionOrThrowable(exc) &amp;&amp;
1309                     !chk.intersects(exc, thrownInTry)) {
1310                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1311             } else {
1312                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
<span class="line-modified">1313                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an</span>
1314                 // unchecked exception, the result list would not be empty, as the augmented
1315                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1316                 // exception, that would have been covered in the branch above
1317                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1318                         !isExceptionOrThrowable(exc)) {
1319                     Warning key = catchableThrownTypes.length() == 1 ?
1320                             Warnings.UnreachableCatch(catchableThrownTypes) :
1321                             Warnings.UnreachableCatch1(catchableThrownTypes);
1322                     log.warning(pos, key);
1323                 }
1324             }
1325         }
1326         //where
1327             private boolean isExceptionOrThrowable(Type exc) {
1328                 return exc.tsym == syms.throwableType.tsym ||
1329                     exc.tsym == syms.exceptionType.tsym;
1330             }
1331 
1332         public void visitBreak(JCBreak tree) {
<span class="line-modified">1333             recordExit(new PendingExit(tree));</span>
<span class="line-modified">1334         }</span>
<span class="line-added">1335 </span>
<span class="line-added">1336         public void visitYield(JCYield tree) {</span>
<span class="line-added">1337             scan(tree.value);</span>
1338             recordExit(new PendingExit(tree));
1339         }
1340 
1341         public void visitContinue(JCContinue tree) {
1342             recordExit(new PendingExit(tree));
1343         }
1344 
1345         public void visitReturn(JCReturn tree) {
1346             scan(tree.expr);
1347             recordExit(new PendingExit(tree));
1348         }
1349 
1350         public void visitThrow(JCThrow tree) {
1351             scan(tree.expr);
1352             Symbol sym = TreeInfo.symbol(tree.expr);
1353             if (sym != null &amp;&amp;
1354                 sym.kind == VAR &amp;&amp;
1355                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1356                 preciseRethrowTypes.get(sym) != null) {
1357                 for (Type t : preciseRethrowTypes.get(sym)) {
</pre>
<hr />
<pre>
1406         @Override
1407         public void visitLambda(JCLambda tree) {
1408             if (tree.type != null &amp;&amp;
1409                     tree.type.isErroneous()) {
1410                 return;
1411             }
1412             List&lt;Type&gt; prevCaught = caught;
1413             List&lt;Type&gt; prevThrown = thrown;
1414             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1415             try {
1416                 pendingExits = new ListBuffer&lt;&gt;();
1417                 caught = tree.getDescriptorType(types).getThrownTypes();
1418                 thrown = List.nil();
1419                 scan(tree.body);
1420                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1421                 pendingExits = new ListBuffer&lt;&gt;();
1422                 while (exits.nonEmpty()) {
1423                     PendingExit exit = exits.head;
1424                     exits = exits.tail;
1425                     if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">1426                         Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added">1427                                         log.hasErrorOn(exit.tree.pos()));</span>
1428                     } else {
1429                         // uncaught throws will be reported later
1430                         pendingExits.append(exit);
1431                     }
1432                 }
1433 
1434                 errorUncaught();
1435             } finally {
1436                 pendingExits = prevPending;
1437                 caught = prevCaught;
1438                 thrown = prevThrown;
1439             }
1440         }
1441 
1442         public void visitModuleDef(JCModuleDecl tree) {
1443             // Do nothing for modules
1444         }
1445 
1446     /**************************************************************************
1447      * main method
</pre>
<hr />
<pre>
1485 
1486         @Override
1487         public void visitLambda(JCLambda tree) {
1488             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1489                 return;
1490             }
1491             inLambda = true;
1492             try {
1493                 super.visitLambda(tree);
1494             } finally {
1495                 inLambda = false;
1496             }
1497         }
1498 
1499         @Override
1500         public void visitClassDef(JCClassDecl tree) {
1501             //skip
1502         }
1503     }
1504 
<span class="line-added">1505     /**</span>
<span class="line-added">1506      * Determine if alive after the given tree.</span>
<span class="line-added">1507      */</span>
<span class="line-added">1508     class SnippetAliveAnalyzer extends AliveAnalyzer {</span>
<span class="line-added">1509         @Override</span>
<span class="line-added">1510         public void visitClassDef(JCClassDecl tree) {</span>
<span class="line-added">1511             //skip</span>
<span class="line-added">1512         }</span>
<span class="line-added">1513         public boolean isAlive() {</span>
<span class="line-added">1514             return super.alive != Liveness.DEAD;</span>
<span class="line-added">1515         }</span>
<span class="line-added">1516     }</span>
<span class="line-added">1517 </span>
<span class="line-added">1518     class SnippetBreakAnalyzer extends AliveAnalyzer {</span>
<span class="line-added">1519         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();</span>
<span class="line-added">1520         private boolean breaksOut;</span>
<span class="line-added">1521 </span>
<span class="line-added">1522         public SnippetBreakAnalyzer() {</span>
<span class="line-added">1523         }</span>
<span class="line-added">1524 </span>
<span class="line-added">1525         @Override</span>
<span class="line-added">1526         public void visitLabelled(JCTree.JCLabeledStatement tree) {</span>
<span class="line-added">1527             seenTrees.add(tree);</span>
<span class="line-added">1528             super.visitLabelled(tree);</span>
<span class="line-added">1529         }</span>
<span class="line-added">1530 </span>
<span class="line-added">1531         @Override</span>
<span class="line-added">1532         public void visitWhileLoop(JCTree.JCWhileLoop tree) {</span>
<span class="line-added">1533             seenTrees.add(tree);</span>
<span class="line-added">1534             super.visitWhileLoop(tree);</span>
<span class="line-added">1535         }</span>
<span class="line-added">1536 </span>
<span class="line-added">1537         @Override</span>
<span class="line-added">1538         public void visitForLoop(JCTree.JCForLoop tree) {</span>
<span class="line-added">1539             seenTrees.add(tree);</span>
<span class="line-added">1540             super.visitForLoop(tree);</span>
<span class="line-added">1541         }</span>
<span class="line-added">1542 </span>
<span class="line-added">1543         @Override</span>
<span class="line-added">1544         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {</span>
<span class="line-added">1545             seenTrees.add(tree);</span>
<span class="line-added">1546             super.visitForeachLoop(tree);</span>
<span class="line-added">1547         }</span>
<span class="line-added">1548 </span>
<span class="line-added">1549         @Override</span>
<span class="line-added">1550         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {</span>
<span class="line-added">1551             seenTrees.add(tree);</span>
<span class="line-added">1552             super.visitDoLoop(tree);</span>
<span class="line-added">1553         }</span>
<span class="line-added">1554 </span>
<span class="line-added">1555         @Override</span>
<span class="line-added">1556         public void visitBreak(JCBreak tree) {</span>
<span class="line-added">1557             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;</span>
<span class="line-added">1558                           !seenTrees.contains(tree.target));</span>
<span class="line-added">1559             super.visitBreak(tree);</span>
<span class="line-added">1560         }</span>
<span class="line-added">1561 </span>
<span class="line-added">1562         public boolean breaksOut() {</span>
<span class="line-added">1563             return breaksOut;</span>
<span class="line-added">1564         }</span>
<span class="line-added">1565     }</span>
<span class="line-added">1566 </span>
1567     /**
1568      * Specialized pass that performs DA/DU on a lambda
1569      */
1570     class LambdaAssignAnalyzer extends AssignAnalyzer {
1571         WriteableScope enclosedSymbols;
1572         boolean inLambda;
1573 
1574         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1575             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1576         }
1577 
1578         @Override
1579         public void visitLambda(JCLambda tree) {
1580             if (inLambda) {
1581                 return;
1582             }
1583             inLambda = true;
1584             try {
1585                 super.visitLambda(tree);
1586             } finally {
</pre>
<hr />
<pre>
1846         void letInit(JCTree tree) {
1847             tree = TreeInfo.skipParens(tree);
1848             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1849                 Symbol sym = TreeInfo.symbol(tree);
1850                 if (sym.kind == VAR) {
1851                     letInit(tree.pos(), (VarSymbol)sym);
1852                 }
1853             }
1854         }
1855 
1856         /** Check that trackable variable is initialized.
1857          */
1858         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1859             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1860         }
1861 
1862         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1863             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1864                 trackable(sym) &amp;&amp;
1865                 !inits.isMember(sym.adr)) {
<span class="line-modified">1866                     log.error(pos, errkey);</span>
1867                 inits.incl(sym.adr);
1868             }
1869         }
1870 
1871         /** Utility method to reset several Bits instances.
1872          */
1873         private void resetBits(Bits... bits) {
1874             for (Bits b : bits) {
1875                 b.reset();
1876             }
1877         }
1878 
1879         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1880          */
1881         void split(boolean setToNull) {
1882             initsWhenFalse.assign(inits);
1883             uninitsWhenFalse.assign(uninits);
1884             initsWhenTrue.assign(inits);
1885             uninitsWhenTrue.assign(uninits);
1886             if (setToNull) {
</pre>
<hr />
<pre>
2066                 boolean lastInitialConstructor = isInitialConstructor;
2067                 try {
2068                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2069 
2070                     if (!isInitialConstructor) {
2071                         firstadr = nextadr;
2072                     }
2073                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2074                         JCVariableDecl def = l.head;
2075                         scan(def);
2076                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2077                         /*  If we are executing the code from Gen, then there can be
2078                          *  synthetic or mandated variables, ignore them.
2079                          */
2080                         initParam(def);
2081                     }
2082                     // else we are in an instance initializer block;
2083                     // leave caught unchanged.
2084                     scan(tree.body);
2085 
<span class="line-added">2086                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;</span>
2087                     if (isInitialConstructor) {
2088                         boolean isSynthesized = (tree.sym.flags() &amp;
2089                                                  GENERATEDCONSTR) != 0;
2090                         for (int i = firstadr; i &lt; nextadr; i++) {
2091                             JCVariableDecl vardecl = vardecls[i];
2092                             VarSymbol var = vardecl.sym;
2093                             if (var.owner == classDef.sym) {
2094                                 // choose the diagnostic position based on whether
2095                                 // the ctor is default(synthesized) or not
<span class="line-modified">2096                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {</span>
2097                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
<span class="line-modified">2098                                             var, Errors.VarNotInitializedInDefaultConstructor(var));</span>
<span class="line-added">2099                                 } else if (isCompactConstructor) {</span>
<span class="line-added">2100                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;</span>
<span class="line-added">2101                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;</span>
<span class="line-added">2102                                             !var.isStatic() &amp;&amp;</span>
<span class="line-added">2103                                             var.owner.kind == TYP;</span>
<span class="line-added">2104                                     if (isInstanceRecordField) {</span>
<span class="line-added">2105                                         boolean notInitialized = !inits.isMember(var.adr);</span>
<span class="line-added">2106                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {</span>
<span class="line-added">2107                                         /*  this way we indicate Lower that it should generate an initialization for this field</span>
<span class="line-added">2108                                          *  in the compact constructor</span>
<span class="line-added">2109                                          */</span>
<span class="line-added">2110                                             var.flags_field |= UNINITIALIZED_FIELD;</span>
<span class="line-added">2111                                         } else {</span>
<span class="line-added">2112                                             checkInit(TreeInfo.diagEndPos(tree.body), var);</span>
<span class="line-added">2113                                         }</span>
<span class="line-added">2114                                     } else {</span>
<span class="line-added">2115                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);</span>
<span class="line-added">2116                                     }</span>
2117                                 } else {
2118                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2119                                 }
2120                             }
2121                         }
2122                     }
2123                     List&lt;PendingExit&gt; exits = pendingExits.toList();
2124                     pendingExits = new ListBuffer&lt;&gt;();
2125                     while (exits.nonEmpty()) {
2126                         PendingExit exit = exits.head;
2127                         exits = exits.tail;
<span class="line-modified">2128                         Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added">2129                                          log.hasErrorOn(exit.tree.pos()),</span>
<span class="line-added">2130                                      exit.tree);</span>
2131                         if (isInitialConstructor) {
2132                             Assert.check(exit instanceof AssignPendingExit);
2133                             inits.assign(((AssignPendingExit) exit).exit_inits);
2134                             for (int i = firstadr; i &lt; nextadr; i++) {
2135                                 checkInit(exit.tree.pos(), vardecls[i].sym);
2136                             }
2137                         }
2138                     }
2139                 } finally {
2140                     inits.assign(initsPrev);
2141                     uninits.assign(uninitsPrev);
2142                     nextadr = nextadrPrev;
2143                     firstadr = firstadrPrev;
2144                     returnadr = returnadrPrev;
2145                     isInitialConstructor = lastInitialConstructor;
2146                 }
2147             } finally {
2148                 lint = lintPrev;
2149             }
2150         }
</pre>
<hr />
<pre>
2359                     for (JCExpression pat : c.pats) {
2360                         scanExpr(pat);
2361                     }
2362                 }
2363                 if (hasDefault) {
2364                     inits.assign(initsSwitch);
2365                     uninits.assign(uninits.andSet(uninitsSwitch));
2366                 }
2367                 scan(c.stats);
2368                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2369                     scanSyntheticBreak(make, tree);
2370                 }
2371                 addVars(c.stats, initsSwitch, uninitsSwitch);
2372                 if (!hasDefault) {
2373                     inits.assign(initsSwitch);
2374                     uninits.assign(uninits.andSet(uninitsSwitch));
2375                 }
2376                 // Warn about fall-through if lint switch fallthrough enabled.
2377             }
2378             if (!hasDefault) {
<span class="line-modified">2379                 if (tree.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-added">2380                     markDead();</span>
<span class="line-added">2381                 } else {</span>
<span class="line-added">2382                     inits.andSet(initsSwitch);</span>
<span class="line-added">2383                 }</span>
<span class="line-added">2384             }</span>
<span class="line-added">2385             if (tree.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-added">2386                 resolveYields(tree, prevPendingExits);</span>
<span class="line-added">2387             } else {</span>
<span class="line-added">2388                 resolveBreaks(tree, prevPendingExits);</span>
2389             }

2390             nextadr = nextadrPrev;
2391         }
2392         // where
2393             /** Add any variables defined in stats to inits and uninits. */
2394             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2395                                         final Bits uninits) {
2396                 for (;stats.nonEmpty(); stats = stats.tail) {
2397                     JCTree stat = stats.head;
2398                     if (stat.hasTag(VARDEF)) {
2399                         int adr = ((JCVariableDecl) stat).sym.adr;
2400                         inits.excl(adr);
2401                         uninits.incl(adr);
2402                     }
2403                 }
2404             }
2405 
2406         public void visitTry(JCTry tree) {
2407             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2408             final Bits uninitsTryPrev = new Bits(uninitsTry);
2409             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
</pre>
<hr />
<pre>
2534             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2535             inits.assign(initsWhenTrue);
2536             uninits.assign(uninitsWhenTrue);
2537             scan(tree.thenpart);
2538             if (tree.elsepart != null) {
2539                 final Bits initsAfterThen = new Bits(inits);
2540                 final Bits uninitsAfterThen = new Bits(uninits);
2541                 inits.assign(initsBeforeElse);
2542                 uninits.assign(uninitsBeforeElse);
2543                 scan(tree.elsepart);
2544                 inits.andSet(initsAfterThen);
2545                 uninits.andSet(uninitsAfterThen);
2546             } else {
2547                 inits.andSet(initsBeforeElse);
2548                 uninits.andSet(uninitsBeforeElse);
2549             }
2550         }
2551 
2552         @Override
2553         public void visitBreak(JCBreak tree) {
<span class="line-modified">2554             recordExit(new AssignPendingExit(tree, inits, uninits));</span>
<span class="line-modified">2555         }</span>
<span class="line-modified">2556 </span>
<span class="line-modified">2557         @Override</span>
<span class="line-modified">2558         public void visitYield(JCYield tree) {</span>
<span class="line-modified">2559             JCSwitchExpression expr = (JCSwitchExpression) tree.target;</span>
<span class="line-modified">2560             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {</span>
<span class="line-modified">2561                 scanCond(tree.value);</span>
<span class="line-modified">2562                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);</span>
<span class="line-modified">2563                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);</span>
<span class="line-modified">2564                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);</span>
<span class="line-modified">2565                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);</span>
<span class="line-modified">2566                 PendingExit exit = new PendingExit(tree) {</span>
<span class="line-modified">2567                     @Override</span>
<span class="line-modified">2568                     void resolveJump() {</span>
<span class="line-modified">2569                         if (!inits.isReset()) {</span>
<span class="line-modified">2570                             split(true);</span>
<span class="line-modified">2571                         }</span>
<span class="line-modified">2572                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);</span>
<span class="line-modified">2573                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);</span>
<span class="line-modified">2574                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);</span>
<span class="line-modified">2575                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);</span>


2576                     }
<span class="line-modified">2577                 };</span>
<span class="line-modified">2578                 merge();</span>
<span class="line-added">2579                 recordExit(exit);</span>
<span class="line-added">2580                 return ;</span>
<span class="line-added">2581             } else {</span>
<span class="line-added">2582                 scanExpr(tree.value);</span>
<span class="line-added">2583                 recordExit(new AssignPendingExit(tree, inits, uninits));</span>
2584             }

2585         }
2586 
2587         @Override
2588         public void visitContinue(JCContinue tree) {
2589             recordExit(new AssignPendingExit(tree, inits, uninits));
2590         }
2591 
2592         @Override
2593         public void visitReturn(JCReturn tree) {
2594             scanExpr(tree.expr);
2595             recordExit(new AssignPendingExit(tree, inits, uninits));
2596         }
2597 
2598         public void visitThrow(JCThrow tree) {
2599             scanExpr(tree.expr);
2600             markDead();
2601         }
2602 
2603         public void visitApply(JCMethodInvocation tree) {
2604             scanExpr(tree.meth);
</pre>
<hr />
<pre>
2927                     letInit(tree.arg);
2928                     break;
2929                 default:
2930                     scan(tree.arg);
2931             }
2932         }
2933 
2934         public void visitTry(JCTry tree) {
2935             for (JCTree resource : tree.resources) {
2936                 if (!resource.hasTag(VARDEF)) {
2937                     Symbol var = TreeInfo.symbol(resource);
2938                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
2939                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
2940                     }
2941                 }
2942             }
2943             super.visitTry(tree);
2944         }
2945 
2946         @Override
<span class="line-modified">2947         public void visitYield(JCYield tree) {</span>
<span class="line-modified">2948             scan(tree.value);</span>

2949         }
2950 
2951         public void visitModuleDef(JCModuleDecl tree) {
2952             // Do nothing for modules
2953         }
2954 
2955     /**************************************************************************
2956      * main method
2957      *************************************************************************/
2958 
2959         /** Perform definite assignment/unassignment analysis on a tree.
2960          */
2961         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
2962             analyzeTree(env, env.tree, make);
2963         }
2964         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
2965             try {
2966                 attrEnv = env;
2967                 Flow.this.make = make;
2968                 pendingExits = new ListBuffer&lt;&gt;();
</pre>
</td>
</tr>
</table>
<center><a href="Enter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Infer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
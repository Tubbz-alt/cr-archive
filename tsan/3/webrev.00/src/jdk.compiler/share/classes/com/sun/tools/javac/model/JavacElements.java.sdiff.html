<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/model/JavacElements.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnnotationProxyMaker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/DocCommentParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/model/JavacElements.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
260                     name.equals(sym.getQualifiedName())) {
261                     return clazz.cast(sym);
262                 }
263             }
264             return null;
265         } catch (CompletionFailure cf) {
266             cf.dcfh.handleAPICompletionFailure(cf);
267             return null;
268         }
269     }
270 
271     /**
272      * Returns the tree for an annotation given the annotated element
273      * and the element&#39;s own tree.  Returns null if the tree cannot be found.
274      */
275     private JCTree matchAnnoToTree(AnnotationMirror findme,
276                                    Element e, JCTree tree) {
277         Symbol sym = cast(Symbol.class, e);
278         class Vis extends JCTree.Visitor {
279             List&lt;JCAnnotation&gt; result = null;



280             public void visitPackageDef(JCPackageDecl tree) {
281                 result = tree.annotations;
282             }
283             public void visitClassDef(JCClassDecl tree) {
284                 result = tree.mods.annotations;
285             }
286             public void visitMethodDef(JCMethodDecl tree) {
287                 result = tree.mods.annotations;
288             }
289             public void visitVarDef(JCVariableDecl tree) {
290                 result = tree.mods.annotations;
291             }
292             @Override
293             public void visitTypeParameter(JCTypeParameter tree) {
294                 result = tree.annotations;
295             }
296         }
297         Vis vis = new Vis();
298         tree.accept(vis);
299         if (vis.result == null)
</pre>
<hr />
<pre>
445     @DefinedBy(Api.LANGUAGE_MODEL)
446     public ModuleElement getModuleOf(Element e) {
447         Symbol sym = cast(Symbol.class, e);
448         if (modules.getDefaultModule() == syms.noModule)
449             return null;
450         return (sym.kind == MDL) ? ((ModuleElement) e) : sym.packge().modle;
451     }
452 
453     @DefinedBy(Api.LANGUAGE_MODEL)
454     public boolean isDeprecated(Element e) {
455         Symbol sym = cast(Symbol.class, e);
456         sym.apiComplete();
457         return sym.isDeprecated();
458     }
459 
460     @Override @DefinedBy(Api.LANGUAGE_MODEL)
461     public Origin getOrigin(Element e) {
462         Symbol sym = cast(Symbol.class, e);
463         if ((sym.flags() &amp; Flags.GENERATEDCONSTR) != 0)
464             return Origin.MANDATED;


465         //TypeElement.getEnclosedElements does not return synthetic elements,
466         //and most synthetic elements are not read from the classfile anyway:
467         return Origin.EXPLICIT;
468     }
469 
470     @Override @DefinedBy(Api.LANGUAGE_MODEL)
471     public Origin getOrigin(AnnotatedConstruct c, AnnotationMirror a) {
472         Compound ac = cast(Compound.class, a);
473         if (ac.isSynthesized())
474             return Origin.MANDATED;
475         return Origin.EXPLICIT;
476     }
477 
478     @Override @DefinedBy(Api.LANGUAGE_MODEL)
479     public Origin getOrigin(ModuleElement m, ModuleElement.Directive directive) {
480         switch (directive.getKind()) {
481             case REQUIRES:
482                 RequiresDirective rd = cast(RequiresDirective.class, directive);
483                 if (rd.flags.contains(RequiresFlag.MANDATED))
484                     return Origin.MANDATED;
</pre>
</td>
<td>
<hr />
<pre>
260                     name.equals(sym.getQualifiedName())) {
261                     return clazz.cast(sym);
262                 }
263             }
264             return null;
265         } catch (CompletionFailure cf) {
266             cf.dcfh.handleAPICompletionFailure(cf);
267             return null;
268         }
269     }
270 
271     /**
272      * Returns the tree for an annotation given the annotated element
273      * and the element&#39;s own tree.  Returns null if the tree cannot be found.
274      */
275     private JCTree matchAnnoToTree(AnnotationMirror findme,
276                                    Element e, JCTree tree) {
277         Symbol sym = cast(Symbol.class, e);
278         class Vis extends JCTree.Visitor {
279             List&lt;JCAnnotation&gt; result = null;
<span class="line-added">280             public void visitModuleDef(JCModuleDecl tree) {</span>
<span class="line-added">281                 result = tree.mods.annotations;</span>
<span class="line-added">282             }</span>
283             public void visitPackageDef(JCPackageDecl tree) {
284                 result = tree.annotations;
285             }
286             public void visitClassDef(JCClassDecl tree) {
287                 result = tree.mods.annotations;
288             }
289             public void visitMethodDef(JCMethodDecl tree) {
290                 result = tree.mods.annotations;
291             }
292             public void visitVarDef(JCVariableDecl tree) {
293                 result = tree.mods.annotations;
294             }
295             @Override
296             public void visitTypeParameter(JCTypeParameter tree) {
297                 result = tree.annotations;
298             }
299         }
300         Vis vis = new Vis();
301         tree.accept(vis);
302         if (vis.result == null)
</pre>
<hr />
<pre>
448     @DefinedBy(Api.LANGUAGE_MODEL)
449     public ModuleElement getModuleOf(Element e) {
450         Symbol sym = cast(Symbol.class, e);
451         if (modules.getDefaultModule() == syms.noModule)
452             return null;
453         return (sym.kind == MDL) ? ((ModuleElement) e) : sym.packge().modle;
454     }
455 
456     @DefinedBy(Api.LANGUAGE_MODEL)
457     public boolean isDeprecated(Element e) {
458         Symbol sym = cast(Symbol.class, e);
459         sym.apiComplete();
460         return sym.isDeprecated();
461     }
462 
463     @Override @DefinedBy(Api.LANGUAGE_MODEL)
464     public Origin getOrigin(Element e) {
465         Symbol sym = cast(Symbol.class, e);
466         if ((sym.flags() &amp; Flags.GENERATEDCONSTR) != 0)
467             return Origin.MANDATED;
<span class="line-added">468         if ((sym.flags() &amp; Flags.MANDATED) != 0)</span>
<span class="line-added">469             return Origin.MANDATED;</span>
470         //TypeElement.getEnclosedElements does not return synthetic elements,
471         //and most synthetic elements are not read from the classfile anyway:
472         return Origin.EXPLICIT;
473     }
474 
475     @Override @DefinedBy(Api.LANGUAGE_MODEL)
476     public Origin getOrigin(AnnotatedConstruct c, AnnotationMirror a) {
477         Compound ac = cast(Compound.class, a);
478         if (ac.isSynthesized())
479             return Origin.MANDATED;
480         return Origin.EXPLICIT;
481     }
482 
483     @Override @DefinedBy(Api.LANGUAGE_MODEL)
484     public Origin getOrigin(ModuleElement m, ModuleElement.Directive directive) {
485         switch (directive.getKind()) {
486             case REQUIRES:
487                 RequiresDirective rd = cast(RequiresDirective.class, directive);
488                 if (rd.flags.contains(RequiresFlag.MANDATED))
489                     return Origin.MANDATED;
</pre>
</td>
</tr>
</table>
<center><a href="AnnotationProxyMaker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/DocCommentParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
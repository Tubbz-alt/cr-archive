<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Symtab.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeAnnotations.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.util.ArrayDeque;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.Map;
  33 
  34 import javax.lang.model.type.*;
  35 
  36 import com.sun.tools.javac.code.Symbol.*;
  37 import com.sun.tools.javac.code.TypeMetadata.Entry;
  38 import com.sun.tools.javac.code.Types.TypeMapping;

  39 import com.sun.tools.javac.comp.Infer.IncorporationAction;


  40 import com.sun.tools.javac.util.*;
  41 import com.sun.tools.javac.util.DefinedBy.Api;
  42 
  43 import static com.sun.tools.javac.code.BoundKind.*;
  44 import static com.sun.tools.javac.code.Flags.*;
  45 import static com.sun.tools.javac.code.Kinds.Kind.*;
  46 import static com.sun.tools.javac.code.TypeTag.*;
  47 
  48 /** This class represents Java types. The class itself defines the behavior of
  49  *  the following types:
  50  *  &lt;pre&gt;
  51  *  base types (tags: BYTE, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, BOOLEAN),
  52  *  type `void&#39; (tag: VOID),
  53  *  the bottom type (tag: BOT),
  54  *  the missing type (tag: NONE).
  55  *  &lt;/pre&gt;
  56  *  &lt;p&gt;The behavior of the following types is defined in subclasses, which are
  57  *  all static inner classes of this class:
  58  *  &lt;pre&gt;
  59  *  class types (tag: CLASS, class: ClassType),
  60  *  array types (tag: ARRAY, class: ArrayType),
  61  *  method types (tag: METHOD, class: MethodType),
  62  *  package types (tag: PACKAGE, class: PackageType),
  63  *  type variables (tag: TYPEVAR, class: TypeVar),
  64  *  type arguments (tag: WILDCARD, class: WildcardType),
  65  *  generic method types (tag: FORALL, class: ForAll),
  66  *  the error type (tag: ERROR, class: ErrorType).
  67  *  &lt;/pre&gt;
  68  *
  69  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  70  *  If you write code that depends on this, you do so at your own risk.
  71  *  This code and its internal interfaces are subject to change or
  72  *  deletion without notice.&lt;/b&gt;
  73  *
  74  *  @see TypeTag
  75  */
<span class="line-modified">  76 public abstract class Type extends AnnoConstruct implements TypeMirror {</span>
  77 
  78     /**
  79      * Type metadata,  Should be {@code null} for the default value.
  80      *
  81      * Note: it is an invariant that for any {@code TypeMetadata}
  82      * class, a given {@code Type} may have at most one metadata array
  83      * entry of that class.
  84      */
  85     protected final TypeMetadata metadata;
  86 
  87     public TypeMetadata getMetadata() {
  88         return metadata;
  89     }
  90 
  91     public Entry getMetadataOfKind(final Entry.Kind kind) {
  92         return metadata != null ? metadata.get(kind) : null;
  93     }
  94 
  95     /** Constant type: no type at all. */
  96     public static final JCNoType noType = new JCNoType() {
</pre>
<hr />
<pre>
 108         }
 109     };
 110 
 111     /** Constant type: special type to be used for marking stuck trees. */
 112     public static final JCNoType stuckType = new JCNoType() {
 113         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 114         public String toString() {
 115             return &quot;stuck&quot;;
 116         }
 117     };
 118 
 119     /** If this switch is turned on, the names of type variables
 120      *  and anonymous classes are printed with hashcodes appended.
 121      */
 122     public static boolean moreInfo = false;
 123 
 124     /** The defining class / interface / package / type variable.
 125      */
 126     public TypeSymbol tsym;
 127 










 128     /**
 129      * Checks if the current type tag is equal to the given tag.
 130      * @return true if tag is equal to the current type tag.
 131      */
 132     public boolean hasTag(TypeTag tag) {
 133         return tag == getTag();
 134     }
 135 
 136     /**
 137      * Returns the current type tag.
 138      * @return the value of the current type tag.
 139      */
 140     public abstract TypeTag getTag();
 141 
 142     public boolean isNumeric() {
 143         return false;
 144     }
 145 
 146     public boolean isIntegral() {
 147         return false;
</pre>
<hr />
<pre>
 447 
 448     /** The Java source which this type represents.
 449      */
 450     @DefinedBy(Api.LANGUAGE_MODEL)
 451     public String toString() {
 452         StringBuilder sb = new StringBuilder();
 453         appendAnnotationsString(sb);
 454         if (tsym == null || tsym.name == null) {
 455             sb.append(&quot;&lt;none&gt;&quot;);
 456         } else {
 457             sb.append(tsym.name);
 458         }
 459         if (moreInfo &amp;&amp; hasTag(TYPEVAR)) {
 460             sb.append(hashCode());
 461         }
 462         return sb.toString();
 463     }
 464 
 465     /**
 466      * The Java source which this type list represents.  A List is
<span class="line-modified"> 467      * represented as a comma-spearated listing of the elements in</span>
 468      * that list.
 469      */
 470     public static String toString(List&lt;Type&gt; ts) {
 471         if (ts.isEmpty()) {
 472             return &quot;&quot;;
 473         } else {
 474             StringBuilder buf = new StringBuilder();
 475             buf.append(ts.head.toString());
 476             for (List&lt;Type&gt; l = ts.tail; l.nonEmpty(); l = l.tail)
 477                 buf.append(&quot;,&quot;).append(l.head.toString());
 478             return buf.toString();
 479         }
 480     }
 481 
 482     /**
 483      * The constant value of this type, converted to String
 484      */
 485     public String stringValue() {
 486         Object cv = Assert.checkNonNull(constValue());
 487         return cv.toString();
</pre>
<hr />
<pre>
 913 
 914         @DefinedBy(Api.LANGUAGE_MODEL)
 915         public Type getSuperBound() {
 916             if (kind == SUPER)
 917                 return type;
 918             else
 919                 return null;
 920         }
 921 
 922         @DefinedBy(Api.LANGUAGE_MODEL)
 923         public TypeKind getKind() {
 924             return TypeKind.WILDCARD;
 925         }
 926 
 927         @DefinedBy(Api.LANGUAGE_MODEL)
 928         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 929             return v.visitWildcard(this, p);
 930         }
 931     }
 932 
<span class="line-modified"> 933     public static class ClassType extends Type implements DeclaredType,</span>
 934                                                           javax.lang.model.type.ErrorType {
 935 
 936         /** The enclosing type of this type. If this is the type of an inner
 937          *  class, outer_field refers to the type of its enclosing
 938          *  instance class, in all other cases it refers to noType.
 939          */
 940         private Type outer_field;
 941 
 942         /** The type parameters of this type (to be set once class is loaded).
 943          */
 944         public List&lt;Type&gt; typarams_field;
 945 
 946         /** A cache variable for the type parameters of this type,
 947          *  appended to all parameters of its enclosing class.
 948          *  @see #allparams
 949          */
 950         public List&lt;Type&gt; allparams_field;
 951 
 952         /** The supertype of this class (to be set once class is loaded).
 953          */
</pre>
<hr />
<pre>
 958         public List&lt;Type&gt; interfaces_field;
 959 
 960         /** All the interfaces of this class, including missing ones.
 961          */
 962         public List&lt;Type&gt; all_interfaces_field;
 963 
 964         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym) {
 965             this(outer, typarams, tsym, TypeMetadata.EMPTY);
 966         }
 967 
 968         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym,
 969                          TypeMetadata metadata) {
 970             super(tsym, metadata);
 971             this.outer_field = outer;
 972             this.typarams_field = typarams;
 973             this.allparams_field = null;
 974             this.supertype_field = null;
 975             this.interfaces_field = null;
 976         }
 977 




 978         @Override
 979         public ClassType cloneWithMetadata(TypeMetadata md) {
 980             return new ClassType(outer_field, typarams_field, tsym, md) {
 981                 @Override
 982                 public Type baseType() { return ClassType.this.baseType(); }
 983             };
 984         }
 985 
 986         @Override
 987         public TypeTag getTag() {
 988             return CLASS;
 989         }
 990 
 991         @Override
 992         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
 993             return v.visitClassType(this, s);
 994         }
 995 
 996         public Type constType(Object constValue) {
 997             final Object value = constValue;
</pre>
<hr />
<pre>
1260         }
1261 
1262         public List&lt;Type&gt; getExplicitComponents() {
1263             return allInterfaces ?
1264                     interfaces_field :
1265                     getComponents();
1266         }
1267 
1268         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1269         public TypeKind getKind() {
1270             return TypeKind.INTERSECTION;
1271         }
1272 
1273         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1274         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1275             return v.visitIntersection(this, p);
1276         }
1277     }
1278 
1279     public static class ArrayType extends Type
<span class="line-modified">1280             implements javax.lang.model.type.ArrayType {</span>
1281 
1282         public Type elemtype;
1283 
1284         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
1285             this(elemtype, arrayClass, TypeMetadata.EMPTY);
1286         }
1287 
1288         public ArrayType(Type elemtype, TypeSymbol arrayClass,
1289                          TypeMetadata metadata) {
1290             super(arrayClass, metadata);
1291             this.elemtype = elemtype;
1292         }
1293 
1294         public ArrayType(ArrayType that) {
1295             //note: type metadata is deliberately shared here, as we want side-effects from annotation
1296             //processing to flow from original array to the cloned array.
1297             this(that.elemtype, that.tsym, that.getMetadata());
1298         }
1299 




1300         @Override
1301         public ArrayType cloneWithMetadata(TypeMetadata md) {
1302             return new ArrayType(elemtype, tsym, md) {
1303                 @Override
1304                 public Type baseType() { return ArrayType.this.baseType(); }
1305             };
1306         }
1307 
1308         @Override
1309         public TypeTag getTag() {
1310             return ARRAY;
1311         }
1312 
1313         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1314             return v.visitArrayType(this, s);
1315         }
1316 
1317         @DefinedBy(Api.LANGUAGE_MODEL)
1318         public String toString() {
1319             StringBuilder sb = new StringBuilder();
</pre>
<hr />
<pre>
1395         public void complete() {
1396             elemtype.complete();
1397         }
1398 
1399         @DefinedBy(Api.LANGUAGE_MODEL)
1400         public Type getComponentType() {
1401             return elemtype;
1402         }
1403 
1404         @DefinedBy(Api.LANGUAGE_MODEL)
1405         public TypeKind getKind() {
1406             return TypeKind.ARRAY;
1407         }
1408 
1409         @DefinedBy(Api.LANGUAGE_MODEL)
1410         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1411             return v.visitArray(this, p);
1412         }
1413     }
1414 
<span class="line-modified">1415     public static class MethodType extends Type implements ExecutableType {</span>
1416 
1417         public List&lt;Type&gt; argtypes;
1418         public Type restype;
1419         public List&lt;Type&gt; thrown;
1420 
1421         /** The type annotations on the method receiver.
1422          */
1423         public Type recvtype;
1424 
1425         public MethodType(List&lt;Type&gt; argtypes,
1426                           Type restype,
1427                           List&lt;Type&gt; thrown,
1428                           TypeSymbol methodClass) {
1429             // Presently no way to refer to a method type directly, so
1430             // we cannot put type annotations on it.
1431             super(methodClass, TypeMetadata.EMPTY);
1432             this.argtypes = argtypes;
1433             this.restype = restype;
1434             this.thrown = thrown;
1435         }
</pre>
<hr />
<pre>
1462             sb.append(&#39;)&#39;);
1463             sb.append(restype);
1464             return sb.toString();
1465         }
1466 
1467         @DefinedBy(Api.LANGUAGE_MODEL)
1468         public List&lt;Type&gt;        getParameterTypes() { return argtypes; }
1469         @DefinedBy(Api.LANGUAGE_MODEL)
1470         public Type              getReturnType()     { return restype; }
1471         @DefinedBy(Api.LANGUAGE_MODEL)
1472         public Type              getReceiverType()   { return recvtype; }
1473         @DefinedBy(Api.LANGUAGE_MODEL)
1474         public List&lt;Type&gt;        getThrownTypes()    { return thrown; }
1475 
1476         public boolean isErroneous() {
1477             return
1478                 isErroneous(argtypes) ||
1479                 restype != null &amp;&amp; restype.isErroneous();
1480         }
1481 





1482         public boolean contains(Type elem) {
1483             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
1484         }
1485 
1486         public MethodType asMethodType() { return this; }
1487 
1488         public void complete() {
1489             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1490                 l.head.complete();
1491             restype.complete();
1492             recvtype.complete();
1493             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1494                 l.head.complete();
1495         }
1496 
1497         @DefinedBy(Api.LANGUAGE_MODEL)
1498         public List&lt;TypeVar&gt; getTypeVariables() {
1499             return List.nil();
1500         }
1501 
</pre>
</td>
<td>
<hr />
<pre>
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.util.ArrayDeque;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.Map;
  33 
  34 import javax.lang.model.type.*;
  35 
  36 import com.sun.tools.javac.code.Symbol.*;
  37 import com.sun.tools.javac.code.TypeMetadata.Entry;
  38 import com.sun.tools.javac.code.Types.TypeMapping;
<span class="line-added">  39 import com.sun.tools.javac.code.Types.UniqueType;</span>
  40 import com.sun.tools.javac.comp.Infer.IncorporationAction;
<span class="line-added">  41 import com.sun.tools.javac.jvm.ClassFile;</span>
<span class="line-added">  42 import com.sun.tools.javac.jvm.PoolConstant;</span>
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import static com.sun.tools.javac.code.BoundKind.*;
  47 import static com.sun.tools.javac.code.Flags.*;
  48 import static com.sun.tools.javac.code.Kinds.Kind.*;
  49 import static com.sun.tools.javac.code.TypeTag.*;
  50 
  51 /** This class represents Java types. The class itself defines the behavior of
  52  *  the following types:
  53  *  &lt;pre&gt;
  54  *  base types (tags: BYTE, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, BOOLEAN),
  55  *  type `void&#39; (tag: VOID),
  56  *  the bottom type (tag: BOT),
  57  *  the missing type (tag: NONE).
  58  *  &lt;/pre&gt;
  59  *  &lt;p&gt;The behavior of the following types is defined in subclasses, which are
  60  *  all static inner classes of this class:
  61  *  &lt;pre&gt;
  62  *  class types (tag: CLASS, class: ClassType),
  63  *  array types (tag: ARRAY, class: ArrayType),
  64  *  method types (tag: METHOD, class: MethodType),
  65  *  package types (tag: PACKAGE, class: PackageType),
  66  *  type variables (tag: TYPEVAR, class: TypeVar),
  67  *  type arguments (tag: WILDCARD, class: WildcardType),
  68  *  generic method types (tag: FORALL, class: ForAll),
  69  *  the error type (tag: ERROR, class: ErrorType).
  70  *  &lt;/pre&gt;
  71  *
  72  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  73  *  If you write code that depends on this, you do so at your own risk.
  74  *  This code and its internal interfaces are subject to change or
  75  *  deletion without notice.&lt;/b&gt;
  76  *
  77  *  @see TypeTag
  78  */
<span class="line-modified">  79 public abstract class Type extends AnnoConstruct implements TypeMirror, PoolConstant {</span>
  80 
  81     /**
  82      * Type metadata,  Should be {@code null} for the default value.
  83      *
  84      * Note: it is an invariant that for any {@code TypeMetadata}
  85      * class, a given {@code Type} may have at most one metadata array
  86      * entry of that class.
  87      */
  88     protected final TypeMetadata metadata;
  89 
  90     public TypeMetadata getMetadata() {
  91         return metadata;
  92     }
  93 
  94     public Entry getMetadataOfKind(final Entry.Kind kind) {
  95         return metadata != null ? metadata.get(kind) : null;
  96     }
  97 
  98     /** Constant type: no type at all. */
  99     public static final JCNoType noType = new JCNoType() {
</pre>
<hr />
<pre>
 111         }
 112     };
 113 
 114     /** Constant type: special type to be used for marking stuck trees. */
 115     public static final JCNoType stuckType = new JCNoType() {
 116         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 117         public String toString() {
 118             return &quot;stuck&quot;;
 119         }
 120     };
 121 
 122     /** If this switch is turned on, the names of type variables
 123      *  and anonymous classes are printed with hashcodes appended.
 124      */
 125     public static boolean moreInfo = false;
 126 
 127     /** The defining class / interface / package / type variable.
 128      */
 129     public TypeSymbol tsym;
 130 
<span class="line-added"> 131     @Override</span>
<span class="line-added"> 132     public int poolTag() {</span>
<span class="line-added"> 133         throw new AssertionError(&quot;Invalid pool entry&quot;);</span>
<span class="line-added"> 134     }</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136     @Override</span>
<span class="line-added"> 137     public Object poolKey(Types types) {</span>
<span class="line-added"> 138         return new UniqueType(this, types);</span>
<span class="line-added"> 139     }</span>
<span class="line-added"> 140 </span>
 141     /**
 142      * Checks if the current type tag is equal to the given tag.
 143      * @return true if tag is equal to the current type tag.
 144      */
 145     public boolean hasTag(TypeTag tag) {
 146         return tag == getTag();
 147     }
 148 
 149     /**
 150      * Returns the current type tag.
 151      * @return the value of the current type tag.
 152      */
 153     public abstract TypeTag getTag();
 154 
 155     public boolean isNumeric() {
 156         return false;
 157     }
 158 
 159     public boolean isIntegral() {
 160         return false;
</pre>
<hr />
<pre>
 460 
 461     /** The Java source which this type represents.
 462      */
 463     @DefinedBy(Api.LANGUAGE_MODEL)
 464     public String toString() {
 465         StringBuilder sb = new StringBuilder();
 466         appendAnnotationsString(sb);
 467         if (tsym == null || tsym.name == null) {
 468             sb.append(&quot;&lt;none&gt;&quot;);
 469         } else {
 470             sb.append(tsym.name);
 471         }
 472         if (moreInfo &amp;&amp; hasTag(TYPEVAR)) {
 473             sb.append(hashCode());
 474         }
 475         return sb.toString();
 476     }
 477 
 478     /**
 479      * The Java source which this type list represents.  A List is
<span class="line-modified"> 480      * represented as a comma-separated listing of the elements in</span>
 481      * that list.
 482      */
 483     public static String toString(List&lt;Type&gt; ts) {
 484         if (ts.isEmpty()) {
 485             return &quot;&quot;;
 486         } else {
 487             StringBuilder buf = new StringBuilder();
 488             buf.append(ts.head.toString());
 489             for (List&lt;Type&gt; l = ts.tail; l.nonEmpty(); l = l.tail)
 490                 buf.append(&quot;,&quot;).append(l.head.toString());
 491             return buf.toString();
 492         }
 493     }
 494 
 495     /**
 496      * The constant value of this type, converted to String
 497      */
 498     public String stringValue() {
 499         Object cv = Assert.checkNonNull(constValue());
 500         return cv.toString();
</pre>
<hr />
<pre>
 926 
 927         @DefinedBy(Api.LANGUAGE_MODEL)
 928         public Type getSuperBound() {
 929             if (kind == SUPER)
 930                 return type;
 931             else
 932                 return null;
 933         }
 934 
 935         @DefinedBy(Api.LANGUAGE_MODEL)
 936         public TypeKind getKind() {
 937             return TypeKind.WILDCARD;
 938         }
 939 
 940         @DefinedBy(Api.LANGUAGE_MODEL)
 941         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 942             return v.visitWildcard(this, p);
 943         }
 944     }
 945 
<span class="line-modified"> 946     public static class ClassType extends Type implements DeclaredType, LoadableConstant,</span>
 947                                                           javax.lang.model.type.ErrorType {
 948 
 949         /** The enclosing type of this type. If this is the type of an inner
 950          *  class, outer_field refers to the type of its enclosing
 951          *  instance class, in all other cases it refers to noType.
 952          */
 953         private Type outer_field;
 954 
 955         /** The type parameters of this type (to be set once class is loaded).
 956          */
 957         public List&lt;Type&gt; typarams_field;
 958 
 959         /** A cache variable for the type parameters of this type,
 960          *  appended to all parameters of its enclosing class.
 961          *  @see #allparams
 962          */
 963         public List&lt;Type&gt; allparams_field;
 964 
 965         /** The supertype of this class (to be set once class is loaded).
 966          */
</pre>
<hr />
<pre>
 971         public List&lt;Type&gt; interfaces_field;
 972 
 973         /** All the interfaces of this class, including missing ones.
 974          */
 975         public List&lt;Type&gt; all_interfaces_field;
 976 
 977         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym) {
 978             this(outer, typarams, tsym, TypeMetadata.EMPTY);
 979         }
 980 
 981         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym,
 982                          TypeMetadata metadata) {
 983             super(tsym, metadata);
 984             this.outer_field = outer;
 985             this.typarams_field = typarams;
 986             this.allparams_field = null;
 987             this.supertype_field = null;
 988             this.interfaces_field = null;
 989         }
 990 
<span class="line-added"> 991         public int poolTag() {</span>
<span class="line-added"> 992             return ClassFile.CONSTANT_Class;</span>
<span class="line-added"> 993         }</span>
<span class="line-added"> 994 </span>
 995         @Override
 996         public ClassType cloneWithMetadata(TypeMetadata md) {
 997             return new ClassType(outer_field, typarams_field, tsym, md) {
 998                 @Override
 999                 public Type baseType() { return ClassType.this.baseType(); }
1000             };
1001         }
1002 
1003         @Override
1004         public TypeTag getTag() {
1005             return CLASS;
1006         }
1007 
1008         @Override
1009         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1010             return v.visitClassType(this, s);
1011         }
1012 
1013         public Type constType(Object constValue) {
1014             final Object value = constValue;
</pre>
<hr />
<pre>
1277         }
1278 
1279         public List&lt;Type&gt; getExplicitComponents() {
1280             return allInterfaces ?
1281                     interfaces_field :
1282                     getComponents();
1283         }
1284 
1285         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1286         public TypeKind getKind() {
1287             return TypeKind.INTERSECTION;
1288         }
1289 
1290         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1291         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1292             return v.visitIntersection(this, p);
1293         }
1294     }
1295 
1296     public static class ArrayType extends Type
<span class="line-modified">1297             implements LoadableConstant, javax.lang.model.type.ArrayType {</span>
1298 
1299         public Type elemtype;
1300 
1301         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
1302             this(elemtype, arrayClass, TypeMetadata.EMPTY);
1303         }
1304 
1305         public ArrayType(Type elemtype, TypeSymbol arrayClass,
1306                          TypeMetadata metadata) {
1307             super(arrayClass, metadata);
1308             this.elemtype = elemtype;
1309         }
1310 
1311         public ArrayType(ArrayType that) {
1312             //note: type metadata is deliberately shared here, as we want side-effects from annotation
1313             //processing to flow from original array to the cloned array.
1314             this(that.elemtype, that.tsym, that.getMetadata());
1315         }
1316 
<span class="line-added">1317         public int poolTag() {</span>
<span class="line-added">1318             return ClassFile.CONSTANT_Class;</span>
<span class="line-added">1319         }</span>
<span class="line-added">1320 </span>
1321         @Override
1322         public ArrayType cloneWithMetadata(TypeMetadata md) {
1323             return new ArrayType(elemtype, tsym, md) {
1324                 @Override
1325                 public Type baseType() { return ArrayType.this.baseType(); }
1326             };
1327         }
1328 
1329         @Override
1330         public TypeTag getTag() {
1331             return ARRAY;
1332         }
1333 
1334         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1335             return v.visitArrayType(this, s);
1336         }
1337 
1338         @DefinedBy(Api.LANGUAGE_MODEL)
1339         public String toString() {
1340             StringBuilder sb = new StringBuilder();
</pre>
<hr />
<pre>
1416         public void complete() {
1417             elemtype.complete();
1418         }
1419 
1420         @DefinedBy(Api.LANGUAGE_MODEL)
1421         public Type getComponentType() {
1422             return elemtype;
1423         }
1424 
1425         @DefinedBy(Api.LANGUAGE_MODEL)
1426         public TypeKind getKind() {
1427             return TypeKind.ARRAY;
1428         }
1429 
1430         @DefinedBy(Api.LANGUAGE_MODEL)
1431         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1432             return v.visitArray(this, p);
1433         }
1434     }
1435 
<span class="line-modified">1436     public static class MethodType extends Type implements ExecutableType, LoadableConstant {</span>
1437 
1438         public List&lt;Type&gt; argtypes;
1439         public Type restype;
1440         public List&lt;Type&gt; thrown;
1441 
1442         /** The type annotations on the method receiver.
1443          */
1444         public Type recvtype;
1445 
1446         public MethodType(List&lt;Type&gt; argtypes,
1447                           Type restype,
1448                           List&lt;Type&gt; thrown,
1449                           TypeSymbol methodClass) {
1450             // Presently no way to refer to a method type directly, so
1451             // we cannot put type annotations on it.
1452             super(methodClass, TypeMetadata.EMPTY);
1453             this.argtypes = argtypes;
1454             this.restype = restype;
1455             this.thrown = thrown;
1456         }
</pre>
<hr />
<pre>
1483             sb.append(&#39;)&#39;);
1484             sb.append(restype);
1485             return sb.toString();
1486         }
1487 
1488         @DefinedBy(Api.LANGUAGE_MODEL)
1489         public List&lt;Type&gt;        getParameterTypes() { return argtypes; }
1490         @DefinedBy(Api.LANGUAGE_MODEL)
1491         public Type              getReturnType()     { return restype; }
1492         @DefinedBy(Api.LANGUAGE_MODEL)
1493         public Type              getReceiverType()   { return recvtype; }
1494         @DefinedBy(Api.LANGUAGE_MODEL)
1495         public List&lt;Type&gt;        getThrownTypes()    { return thrown; }
1496 
1497         public boolean isErroneous() {
1498             return
1499                 isErroneous(argtypes) ||
1500                 restype != null &amp;&amp; restype.isErroneous();
1501         }
1502 
<span class="line-added">1503         @Override</span>
<span class="line-added">1504         public int poolTag() {</span>
<span class="line-added">1505             return ClassFile.CONSTANT_MethodType;</span>
<span class="line-added">1506         }</span>
<span class="line-added">1507 </span>
1508         public boolean contains(Type elem) {
1509             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
1510         }
1511 
1512         public MethodType asMethodType() { return this; }
1513 
1514         public void complete() {
1515             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1516                 l.head.complete();
1517             restype.complete();
1518             recvtype.complete();
1519             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1520                 l.head.complete();
1521         }
1522 
1523         @DefinedBy(Api.LANGUAGE_MODEL)
1524         public List&lt;TypeVar&gt; getTypeVariables() {
1525             return List.nil();
1526         }
1527 
</pre>
</td>
</tr>
</table>
<center><a href="Symtab.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeAnnotations.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeInfo.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeCopier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeMaker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeInfo.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  65             case APPLY:
  66                 return ((JCMethodInvocation)t).args;
  67             case NEWCLASS:
  68                 return ((JCNewClass)t).args;
  69             default:
  70                 return null;
  71         }
  72     }
  73 
  74     /** Is tree a constructor declaration?
  75      */
  76     public static boolean isConstructor(JCTree tree) {
  77         if (tree.hasTag(METHODDEF)) {
  78             Name name = ((JCMethodDecl) tree).name;
  79             return name == name.table.names.init;
  80         } else {
  81             return false;
  82         }
  83     }
  84 










  85     public static boolean isReceiverParam(JCTree tree) {
  86         if (tree.hasTag(VARDEF)) {
  87             return ((JCVariableDecl)tree).nameexpr != null;
  88         } else {
  89             return false;
  90         }
  91     }
  92 
  93     /** Is there a constructor declaration in the given list of trees?
  94      */
  95     public static boolean hasConstructors(List&lt;JCTree&gt; trees) {
  96         for (List&lt;JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
  97             if (isConstructor(l.head)) return true;
  98         return false;
  99     }
 100 



















 101     public static boolean isMultiCatch(JCCatch catchClause) {
 102         return catchClause.param.vartype.hasTag(TYPEUNION);
 103     }
 104 
 105     /** Is statement an initializer for a synthetic field?
 106      */
 107     public static boolean isSyntheticInit(JCTree stat) {
 108         if (stat.hasTag(EXEC)) {
 109             JCExpressionStatement exec = (JCExpressionStatement)stat;
 110             if (exec.expr.hasTag(ASSIGN)) {
 111                 JCAssign assign = (JCAssign)exec.expr;
 112                 if (assign.lhs.hasTag(SELECT)) {
 113                     JCFieldAccess select = (JCFieldAccess)assign.lhs;
 114                     if (select.sym != null &amp;&amp;
 115                         (select.sym.flags() &amp; SYNTHETIC) != 0) {
 116                         Name selected = name(select.selected);
 117                         if (selected != null &amp;&amp; selected == selected.table.names._this)
 118                             return true;
 119                     }
 120                 }
</pre>
<hr />
<pre>
 173                 return true;
 174             case SELECT:
 175                 return isThisQualifier(((JCFieldAccess)tree).selected);
 176             default:
 177                 return false;
 178         }
 179     }
 180 
 181     /** Is this a call to super?
 182      */
 183     public static boolean isSuperCall(JCTree tree) {
 184         Name name = calledMethodName(tree);
 185         if (name != null) {
 186             Names names = name.table.names;
 187             return name==names._super;
 188         } else {
 189             return false;
 190         }
 191     }
 192 














 193     /** Is this a constructor whose first (non-synthetic) statement is not
 194      *  of the form this(...)?
 195      */
 196     public static boolean isInitialConstructor(JCTree tree) {
 197         JCMethodInvocation app = firstConstructorCall(tree);
 198         if (app == null) return false;
 199         Name meth = name(app.meth);
 200         return meth == null || meth != meth.table.names._this;
 201     }
 202 
 203     /** Return the first call in a constructor definition. */
 204     public static JCMethodInvocation firstConstructorCall(JCTree tree) {
 205         if (!tree.hasTag(METHODDEF)) return null;
 206         JCMethodDecl md = (JCMethodDecl) tree;
 207         Names names = md.name.table.names;
 208         if (md.name != names.init) return null;
 209         if (md.body == null) return null;
 210         List&lt;JCStatement&gt; stats = md.body.stats;
 211         // Synthetic initializations can appear before the super call.
 212         while (stats.nonEmpty() &amp;&amp; isSyntheticInit(stats.head))
</pre>
<hr />
<pre>
 473             case NEWCLASS: {
 474                 JCNewClass node = (JCNewClass)tree;
 475                 if (node.encl != null)
 476                     return getStartPos(node.encl);
 477                 break;
 478             }
 479             case VARDEF: {
 480                 JCVariableDecl node = (JCVariableDecl)tree;
 481                 if (node.startPos != Position.NOPOS) {
 482                     return node.startPos;
 483                 } else if (node.mods.pos != Position.NOPOS) {
 484                     return node.mods.pos;
 485                 } else if (node.vartype == null || node.vartype.pos == Position.NOPOS) {
 486                     //if there&#39;s no type (partially typed lambda parameter)
 487                     //simply return node position
 488                     return node.pos;
 489                 } else {
 490                     return getStartPos(node.vartype);
 491                 }
 492             }




 493             case ERRONEOUS: {
 494                 JCErroneous node = (JCErroneous)tree;
 495                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 496                     return getStartPos(node.errs.head);
 497             }
 498         }
 499         return tree.pos;
 500     }
 501 
 502     /** The end position of given tree, given  a table of end positions generated by the parser
 503      */
 504     public static int getEndPos(JCTree tree, EndPosTable endPosTable) {
 505         if (tree == null)
 506             return Position.NOPOS;
 507 
 508         if (endPosTable == null) {
 509             // fall back on limited info in the tree
 510             return endPos(tree);
 511         }
 512 
</pre>
<hr />
<pre>
 557                 return getEndPos(((JCModifiers) tree).annotations.last(), endPosTable);
 558             case SYNCHRONIZED:
 559                 return getEndPos(((JCSynchronized) tree).body, endPosTable);
 560             case TOPLEVEL:
 561                 return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);
 562             case TRY: {
 563                 JCTry node = (JCTry)tree;
 564                 if (node.finalizer != null) {
 565                     return getEndPos(node.finalizer, endPosTable);
 566                 } else if (!node.catchers.isEmpty()) {
 567                     return getEndPos(node.catchers.last(), endPosTable);
 568                 } else {
 569                     return getEndPos(node.body, endPosTable);
 570                 }
 571             }
 572             case WILDCARD:
 573                 return getEndPos(((JCWildcard) tree).inner, endPosTable);
 574             case TYPECAST:
 575                 return getEndPos(((JCTypeCast) tree).expr, endPosTable);
 576             case TYPETEST:
<span class="line-modified"> 577                 return getEndPos(((JCInstanceOf) tree).clazz, endPosTable);</span>
 578             case WHILELOOP:
 579                 return getEndPos(((JCWhileLoop) tree).body, endPosTable);
 580             case ANNOTATED_TYPE:
 581                 return getEndPos(((JCAnnotatedType) tree).underlyingType, endPosTable);
 582             case ERRONEOUS: {
 583                 JCErroneous node = (JCErroneous)tree;
 584                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 585                     return getEndPos(node.errs.last(), endPosTable);
 586             }
 587         }
 588         return Position.NOPOS;
 589     }
 590 
 591 
 592     /** A DiagnosticPosition with the preferred position set to the
 593      *  end position of given tree, if it is a block with
 594      *  defined endpos.
 595      */
 596     public static DiagnosticPosition diagEndPos(final JCTree tree) {
 597         final int endPos = TreeInfo.endPos(tree);
</pre>
<hr />
<pre>
 830         case VARDEF:
 831             return ((JCVariableDecl) node).sym;
 832         case IDENT:
 833             return ((JCIdent) node).sym;
 834         case SELECT:
 835             return ((JCFieldAccess) node).sym;
 836         case REFERENCE:
 837             return ((JCMemberReference) node).sym;
 838         case NEWCLASS:
 839             return ((JCNewClass) node).constructor;
 840         case APPLY:
 841             return symbolFor(((JCMethodInvocation) node).meth);
 842         case TYPEAPPLY:
 843             return symbolFor(((JCTypeApply) node).clazz);
 844         case ANNOTATION:
 845         case TYPE_ANNOTATION:
 846         case TYPEPARAMETER:
 847             if (node.type != null)
 848                 return node.type.tsym;
 849             return null;


 850         default:
 851             return null;
 852         }
 853     }
 854 
 855     public static boolean isDeclaration(JCTree node) {
 856         node = skipParens(node);
 857         switch (node.getTag()) {
 858         case PACKAGEDEF:
 859         case CLASSDEF:
 860         case METHODDEF:
 861         case VARDEF:
 862             return true;
 863         default:
 864             return false;
 865         }
 866     }
 867 
 868     /** If this tree is an identifier or a field, return its symbol,
 869      *  otherwise return null.
 870      */
 871     public static Symbol symbol(JCTree tree) {
 872         tree = skipParens(tree);
 873         switch (tree.getTag()) {
 874         case IDENT:
 875             return ((JCIdent) tree).sym;
 876         case SELECT:
 877             return ((JCFieldAccess) tree).sym;
 878         case TYPEAPPLY:
 879             return symbol(((JCTypeApply) tree).clazz);
 880         case ANNOTATED_TYPE:
 881             return symbol(((JCAnnotatedType) tree).underlyingType);
 882         case REFERENCE:
 883             return ((JCMemberReference) tree).sym;
 884         default:
 885             return null;
 886         }
 887     }
 888 


















 889     /** Return true if this is a nonstatic selection. */
 890     public static boolean nonstaticSelect(JCTree tree) {
 891         tree = skipParens(tree);
 892         if (!tree.hasTag(SELECT)) return false;
 893         JCFieldAccess s = (JCFieldAccess) tree;
 894         Symbol e = symbol(s.selected);
 895         return e == null || (e.kind != PCK &amp;&amp; e.kind != TYP);
 896     }
 897 
 898     /** If this tree is an identifier or a field, set its symbol, otherwise skip.
 899      */
 900     public static void setSymbol(JCTree tree, Symbol sym) {
 901         tree = skipParens(tree);
 902         switch (tree.getTag()) {
 903         case IDENT:
 904             ((JCIdent) tree).sym = sym; break;
 905         case SELECT:
 906             ((JCFieldAccess) tree).sym = sym; break;
 907         default:
 908         }
</pre>
<hr />
<pre>
1208         return finder.foundTypeAnno;
1209     }
1210 
1211     public static boolean isModuleInfo(JCCompilationUnit tree) {
1212         return tree.sourcefile.isNameCompatible(&quot;module-info&quot;, JavaFileObject.Kind.SOURCE)
1213                 &amp;&amp; tree.getModuleDecl() != null;
1214     }
1215 
1216     public static JCModuleDecl getModule(JCCompilationUnit t) {
1217         if (t.defs.nonEmpty()) {
1218             JCTree def = t.defs.head;
1219             if (def.hasTag(MODULEDEF))
1220                 return (JCModuleDecl) def;
1221         }
1222         return null;
1223     }
1224 
1225     public static boolean isPackageInfo(JCCompilationUnit tree) {
1226         return tree.sourcefile.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
1227     }

1228 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  65             case APPLY:
  66                 return ((JCMethodInvocation)t).args;
  67             case NEWCLASS:
  68                 return ((JCNewClass)t).args;
  69             default:
  70                 return null;
  71         }
  72     }
  73 
  74     /** Is tree a constructor declaration?
  75      */
  76     public static boolean isConstructor(JCTree tree) {
  77         if (tree.hasTag(METHODDEF)) {
  78             Name name = ((JCMethodDecl) tree).name;
  79             return name == name.table.names.init;
  80         } else {
  81             return false;
  82         }
  83     }
  84 
<span class="line-added">  85     public static boolean isCanonicalConstructor(JCTree tree) {</span>
<span class="line-added">  86         // the record flag is only set to the canonical constructor</span>
<span class="line-added">  87         return isConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; RECORD) != 0;</span>
<span class="line-added">  88     }</span>
<span class="line-added">  89 </span>
<span class="line-added">  90     public static boolean isCompactConstructor(JCTree tree) {</span>
<span class="line-added">  91         // the record flag is only set to the canonical constructor</span>
<span class="line-added">  92         return isCanonicalConstructor(tree) &amp;&amp; (((JCMethodDecl)tree).sym.flags_field &amp; COMPACT_RECORD_CONSTRUCTOR) != 0;</span>
<span class="line-added">  93     }</span>
<span class="line-added">  94 </span>
  95     public static boolean isReceiverParam(JCTree tree) {
  96         if (tree.hasTag(VARDEF)) {
  97             return ((JCVariableDecl)tree).nameexpr != null;
  98         } else {
  99             return false;
 100         }
 101     }
 102 
 103     /** Is there a constructor declaration in the given list of trees?
 104      */
 105     public static boolean hasConstructors(List&lt;JCTree&gt; trees) {
 106         for (List&lt;JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
 107             if (isConstructor(l.head)) return true;
 108         return false;
 109     }
 110 
<span class="line-added"> 111     /** Is there a constructor invocation in the given list of trees?</span>
<span class="line-added"> 112      */</span>
<span class="line-added"> 113     public static Name getConstructorInvocationName(List&lt;? extends JCTree&gt; trees, Names names) {</span>
<span class="line-added"> 114         for (JCTree tree : trees) {</span>
<span class="line-added"> 115             if (tree.hasTag(EXEC)) {</span>
<span class="line-added"> 116                 JCExpressionStatement stat = (JCExpressionStatement)tree;</span>
<span class="line-added"> 117                 if (stat.expr.hasTag(APPLY)) {</span>
<span class="line-added"> 118                     JCMethodInvocation apply = (JCMethodInvocation)stat.expr;</span>
<span class="line-added"> 119                     Name methName = TreeInfo.name(apply.meth);</span>
<span class="line-added"> 120                     if (methName == names._this ||</span>
<span class="line-added"> 121                         methName == names._super) {</span>
<span class="line-added"> 122                         return methName;</span>
<span class="line-added"> 123                     }</span>
<span class="line-added"> 124                 }</span>
<span class="line-added"> 125             }</span>
<span class="line-added"> 126         }</span>
<span class="line-added"> 127         return names.empty;</span>
<span class="line-added"> 128     }</span>
<span class="line-added"> 129 </span>
 130     public static boolean isMultiCatch(JCCatch catchClause) {
 131         return catchClause.param.vartype.hasTag(TYPEUNION);
 132     }
 133 
 134     /** Is statement an initializer for a synthetic field?
 135      */
 136     public static boolean isSyntheticInit(JCTree stat) {
 137         if (stat.hasTag(EXEC)) {
 138             JCExpressionStatement exec = (JCExpressionStatement)stat;
 139             if (exec.expr.hasTag(ASSIGN)) {
 140                 JCAssign assign = (JCAssign)exec.expr;
 141                 if (assign.lhs.hasTag(SELECT)) {
 142                     JCFieldAccess select = (JCFieldAccess)assign.lhs;
 143                     if (select.sym != null &amp;&amp;
 144                         (select.sym.flags() &amp; SYNTHETIC) != 0) {
 145                         Name selected = name(select.selected);
 146                         if (selected != null &amp;&amp; selected == selected.table.names._this)
 147                             return true;
 148                     }
 149                 }
</pre>
<hr />
<pre>
 202                 return true;
 203             case SELECT:
 204                 return isThisQualifier(((JCFieldAccess)tree).selected);
 205             default:
 206                 return false;
 207         }
 208     }
 209 
 210     /** Is this a call to super?
 211      */
 212     public static boolean isSuperCall(JCTree tree) {
 213         Name name = calledMethodName(tree);
 214         if (name != null) {
 215             Names names = name.table.names;
 216             return name==names._super;
 217         } else {
 218             return false;
 219         }
 220     }
 221 
<span class="line-added"> 222     public static List&lt;JCVariableDecl&gt; recordFields(JCClassDecl tree) {</span>
<span class="line-added"> 223         return tree.defs.stream()</span>
<span class="line-added"> 224                 .filter(t -&gt; t.hasTag(VARDEF))</span>
<span class="line-added"> 225                 .map(t -&gt; (JCVariableDecl)t)</span>
<span class="line-added"> 226                 .filter(vd -&gt; (vd.getModifiers().flags &amp; (Flags.RECORD)) == RECORD)</span>
<span class="line-added"> 227                 .collect(List.collector());</span>
<span class="line-added"> 228     }</span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230     public static List&lt;Type&gt; recordFieldTypes(JCClassDecl tree) {</span>
<span class="line-added"> 231         return recordFields(tree).stream()</span>
<span class="line-added"> 232                 .map(vd -&gt; vd.type)</span>
<span class="line-added"> 233                 .collect(List.collector());</span>
<span class="line-added"> 234     }</span>
<span class="line-added"> 235 </span>
 236     /** Is this a constructor whose first (non-synthetic) statement is not
 237      *  of the form this(...)?
 238      */
 239     public static boolean isInitialConstructor(JCTree tree) {
 240         JCMethodInvocation app = firstConstructorCall(tree);
 241         if (app == null) return false;
 242         Name meth = name(app.meth);
 243         return meth == null || meth != meth.table.names._this;
 244     }
 245 
 246     /** Return the first call in a constructor definition. */
 247     public static JCMethodInvocation firstConstructorCall(JCTree tree) {
 248         if (!tree.hasTag(METHODDEF)) return null;
 249         JCMethodDecl md = (JCMethodDecl) tree;
 250         Names names = md.name.table.names;
 251         if (md.name != names.init) return null;
 252         if (md.body == null) return null;
 253         List&lt;JCStatement&gt; stats = md.body.stats;
 254         // Synthetic initializations can appear before the super call.
 255         while (stats.nonEmpty() &amp;&amp; isSyntheticInit(stats.head))
</pre>
<hr />
<pre>
 516             case NEWCLASS: {
 517                 JCNewClass node = (JCNewClass)tree;
 518                 if (node.encl != null)
 519                     return getStartPos(node.encl);
 520                 break;
 521             }
 522             case VARDEF: {
 523                 JCVariableDecl node = (JCVariableDecl)tree;
 524                 if (node.startPos != Position.NOPOS) {
 525                     return node.startPos;
 526                 } else if (node.mods.pos != Position.NOPOS) {
 527                     return node.mods.pos;
 528                 } else if (node.vartype == null || node.vartype.pos == Position.NOPOS) {
 529                     //if there&#39;s no type (partially typed lambda parameter)
 530                     //simply return node position
 531                     return node.pos;
 532                 } else {
 533                     return getStartPos(node.vartype);
 534                 }
 535             }
<span class="line-added"> 536             case BINDINGPATTERN: {</span>
<span class="line-added"> 537                 JCBindingPattern node = (JCBindingPattern)tree;</span>
<span class="line-added"> 538                 return getStartPos(node.vartype);</span>
<span class="line-added"> 539             }</span>
 540             case ERRONEOUS: {
 541                 JCErroneous node = (JCErroneous)tree;
 542                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 543                     return getStartPos(node.errs.head);
 544             }
 545         }
 546         return tree.pos;
 547     }
 548 
 549     /** The end position of given tree, given  a table of end positions generated by the parser
 550      */
 551     public static int getEndPos(JCTree tree, EndPosTable endPosTable) {
 552         if (tree == null)
 553             return Position.NOPOS;
 554 
 555         if (endPosTable == null) {
 556             // fall back on limited info in the tree
 557             return endPos(tree);
 558         }
 559 
</pre>
<hr />
<pre>
 604                 return getEndPos(((JCModifiers) tree).annotations.last(), endPosTable);
 605             case SYNCHRONIZED:
 606                 return getEndPos(((JCSynchronized) tree).body, endPosTable);
 607             case TOPLEVEL:
 608                 return getEndPos(((JCCompilationUnit) tree).defs.last(), endPosTable);
 609             case TRY: {
 610                 JCTry node = (JCTry)tree;
 611                 if (node.finalizer != null) {
 612                     return getEndPos(node.finalizer, endPosTable);
 613                 } else if (!node.catchers.isEmpty()) {
 614                     return getEndPos(node.catchers.last(), endPosTable);
 615                 } else {
 616                     return getEndPos(node.body, endPosTable);
 617                 }
 618             }
 619             case WILDCARD:
 620                 return getEndPos(((JCWildcard) tree).inner, endPosTable);
 621             case TYPECAST:
 622                 return getEndPos(((JCTypeCast) tree).expr, endPosTable);
 623             case TYPETEST:
<span class="line-modified"> 624                 return getEndPos(((JCInstanceOf) tree).pattern, endPosTable);</span>
 625             case WHILELOOP:
 626                 return getEndPos(((JCWhileLoop) tree).body, endPosTable);
 627             case ANNOTATED_TYPE:
 628                 return getEndPos(((JCAnnotatedType) tree).underlyingType, endPosTable);
 629             case ERRONEOUS: {
 630                 JCErroneous node = (JCErroneous)tree;
 631                 if (node.errs != null &amp;&amp; node.errs.nonEmpty())
 632                     return getEndPos(node.errs.last(), endPosTable);
 633             }
 634         }
 635         return Position.NOPOS;
 636     }
 637 
 638 
 639     /** A DiagnosticPosition with the preferred position set to the
 640      *  end position of given tree, if it is a block with
 641      *  defined endpos.
 642      */
 643     public static DiagnosticPosition diagEndPos(final JCTree tree) {
 644         final int endPos = TreeInfo.endPos(tree);
</pre>
<hr />
<pre>
 877         case VARDEF:
 878             return ((JCVariableDecl) node).sym;
 879         case IDENT:
 880             return ((JCIdent) node).sym;
 881         case SELECT:
 882             return ((JCFieldAccess) node).sym;
 883         case REFERENCE:
 884             return ((JCMemberReference) node).sym;
 885         case NEWCLASS:
 886             return ((JCNewClass) node).constructor;
 887         case APPLY:
 888             return symbolFor(((JCMethodInvocation) node).meth);
 889         case TYPEAPPLY:
 890             return symbolFor(((JCTypeApply) node).clazz);
 891         case ANNOTATION:
 892         case TYPE_ANNOTATION:
 893         case TYPEPARAMETER:
 894             if (node.type != null)
 895                 return node.type.tsym;
 896             return null;
<span class="line-added"> 897         case BINDINGPATTERN:</span>
<span class="line-added"> 898             return ((JCBindingPattern) node).symbol;</span>
 899         default:
 900             return null;
 901         }
 902     }
 903 
 904     public static boolean isDeclaration(JCTree node) {
 905         node = skipParens(node);
 906         switch (node.getTag()) {
 907         case PACKAGEDEF:
 908         case CLASSDEF:
 909         case METHODDEF:
 910         case VARDEF:
 911             return true;
 912         default:
 913             return false;
 914         }
 915     }
 916 
 917     /** If this tree is an identifier or a field, return its symbol,
 918      *  otherwise return null.
 919      */
 920     public static Symbol symbol(JCTree tree) {
 921         tree = skipParens(tree);
 922         switch (tree.getTag()) {
 923         case IDENT:
 924             return ((JCIdent) tree).sym;
 925         case SELECT:
 926             return ((JCFieldAccess) tree).sym;
 927         case TYPEAPPLY:
 928             return symbol(((JCTypeApply) tree).clazz);
 929         case ANNOTATED_TYPE:
 930             return symbol(((JCAnnotatedType) tree).underlyingType);
 931         case REFERENCE:
 932             return ((JCMemberReference) tree).sym;
 933         default:
 934             return null;
 935         }
 936     }
 937 
<span class="line-added"> 938     /** If this tree has a modifiers field, return it otherwise return null</span>
<span class="line-added"> 939      */</span>
<span class="line-added"> 940     public static JCModifiers getModifiers(JCTree tree) {</span>
<span class="line-added"> 941         tree = skipParens(tree);</span>
<span class="line-added"> 942         switch (tree.getTag()) {</span>
<span class="line-added"> 943             case VARDEF:</span>
<span class="line-added"> 944                 return ((JCVariableDecl) tree).mods;</span>
<span class="line-added"> 945             case METHODDEF:</span>
<span class="line-added"> 946                 return ((JCMethodDecl) tree).mods;</span>
<span class="line-added"> 947             case CLASSDEF:</span>
<span class="line-added"> 948                 return ((JCClassDecl) tree).mods;</span>
<span class="line-added"> 949             case MODULEDEF:</span>
<span class="line-added"> 950                 return ((JCModuleDecl) tree).mods;</span>
<span class="line-added"> 951         default:</span>
<span class="line-added"> 952             return null;</span>
<span class="line-added"> 953         }</span>
<span class="line-added"> 954     }</span>
<span class="line-added"> 955 </span>
 956     /** Return true if this is a nonstatic selection. */
 957     public static boolean nonstaticSelect(JCTree tree) {
 958         tree = skipParens(tree);
 959         if (!tree.hasTag(SELECT)) return false;
 960         JCFieldAccess s = (JCFieldAccess) tree;
 961         Symbol e = symbol(s.selected);
 962         return e == null || (e.kind != PCK &amp;&amp; e.kind != TYP);
 963     }
 964 
 965     /** If this tree is an identifier or a field, set its symbol, otherwise skip.
 966      */
 967     public static void setSymbol(JCTree tree, Symbol sym) {
 968         tree = skipParens(tree);
 969         switch (tree.getTag()) {
 970         case IDENT:
 971             ((JCIdent) tree).sym = sym; break;
 972         case SELECT:
 973             ((JCFieldAccess) tree).sym = sym; break;
 974         default:
 975         }
</pre>
<hr />
<pre>
1275         return finder.foundTypeAnno;
1276     }
1277 
1278     public static boolean isModuleInfo(JCCompilationUnit tree) {
1279         return tree.sourcefile.isNameCompatible(&quot;module-info&quot;, JavaFileObject.Kind.SOURCE)
1280                 &amp;&amp; tree.getModuleDecl() != null;
1281     }
1282 
1283     public static JCModuleDecl getModule(JCCompilationUnit t) {
1284         if (t.defs.nonEmpty()) {
1285             JCTree def = t.defs.head;
1286             if (def.hasTag(MODULEDEF))
1287                 return (JCModuleDecl) def;
1288         }
1289         return null;
1290     }
1291 
1292     public static boolean isPackageInfo(JCCompilationUnit tree) {
1293         return tree.sourcefile.isNameCompatible(&quot;package-info&quot;, JavaFileObject.Kind.SOURCE);
1294     }
<span class="line-added">1295 </span>
1296 }
</pre>
</td>
</tr>
</table>
<center><a href="TreeCopier.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeMaker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
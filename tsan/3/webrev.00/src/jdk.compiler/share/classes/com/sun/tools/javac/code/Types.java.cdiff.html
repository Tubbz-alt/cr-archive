<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeMetadata.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Analyzer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,10 ***</span>
<span class="line-new-header">--- 46,12 ---</span>
  import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  import com.sun.tools.javac.comp.AttrContext;
  import com.sun.tools.javac.comp.Check;
  import com.sun.tools.javac.comp.Enter;
  import com.sun.tools.javac.comp.Env;
<span class="line-added">+ import com.sun.tools.javac.comp.LambdaToMethod;</span>
<span class="line-added">+ import com.sun.tools.javac.jvm.ClassFile;</span>
  import com.sun.tools.javac.util.*;
  
  import static com.sun.tools.javac.code.BoundKind.*;
  import static com.sun.tools.javac.code.Flags.*;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,11 ***</span>
       * and (ii) S is an upper bound of T.
       *
       * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
       * and (ii) S is a lower bound of T.
       *
<span class="line-modified">!      * Note that projections are only allowed to touch variables in V. Theferore it is possible for</span>
       * a projection to leave its input type unchanged if it does not contain any variables in V.
       *
       * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
       * a downwards projection is not always defined.
       *
<span class="line-new-header">--- 221,11 ---</span>
       * and (ii) S is an upper bound of T.
       *
       * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
       * and (ii) S is a lower bound of T.
       *
<span class="line-modified">!      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for</span>
       * a projection to leave its input type unchanged if it does not contain any variables in V.
       *
       * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
       * a downwards projection is not always defined.
       *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 635,11 ***</span>
       * messages.
       */
      public static class FunctionDescriptorLookupError extends RuntimeException {
          private static final long serialVersionUID = 0;
  
<span class="line-modified">!         JCDiagnostic diagnostic;</span>
  
          FunctionDescriptorLookupError() {
              this.diagnostic = null;
          }
  
<span class="line-new-header">--- 637,11 ---</span>
       * messages.
       */
      public static class FunctionDescriptorLookupError extends RuntimeException {
          private static final long serialVersionUID = 0;
  
<span class="line-modified">!         transient JCDiagnostic diagnostic;</span>
  
          FunctionDescriptorLookupError() {
              this.diagnostic = null;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2729,11 ***</span>
      /**
       * Returns true iff the first signature is a &lt;em&gt;sub
       * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
       * relation.
       *
<span class="line-modified">!      * @jls section 8.4.2.</span>
       * @see #overrideEquivalent(Type t, Type s)
       * @param t first signature (possibly raw).
       * @param s second signature (could be subjected to erasure).
       * @return true if t is a sub signature of s.
       */
<span class="line-new-header">--- 2731,11 ---</span>
      /**
       * Returns true iff the first signature is a &lt;em&gt;sub
       * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
       * relation.
       *
<span class="line-modified">!      * @jls 8.4.2 Method Signature</span>
       * @see #overrideEquivalent(Type t, Type s)
       * @param t first signature (possibly raw).
       * @param s second signature (could be subjected to erasure).
       * @return true if t is a sub signature of s.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2748,11 ***</span>
      /**
       * Returns true iff these signatures are related by &lt;em&gt;override
       * equivalence&lt;/em&gt;.  This is the natural extension of
       * isSubSignature to an equivalence relation.
       *
<span class="line-modified">!      * @jls section 8.4.2.</span>
       * @see #isSubSignature(Type t, Type s)
       * @param t a signature (possible raw, could be subjected to
       * erasure).
       * @param s a signature (possible raw, could be subjected to
       * erasure).
<span class="line-new-header">--- 2750,11 ---</span>
      /**
       * Returns true iff these signatures are related by &lt;em&gt;override
       * equivalence&lt;/em&gt;.  This is the natural extension of
       * isSubSignature to an equivalence relation.
       *
<span class="line-modified">!      * @jls 8.4.2 Method Signature</span>
       * @see #isSubSignature(Type t, Type s)
       * @param t a signature (possible raw, could be subjected to
       * erasure).
       * @param s a signature (possible raw, could be subjected to
       * erasure).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3741,16 ***</span>
              return cl2;
          } else if (cl2.isEmpty()) {
              return cl1;
          } else if (shouldSkip.test(cl1.head, cl2.head)) {
              return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
<span class="line-removed">-         } else if (cl1.head.tsym.precedes(cl2.head.tsym, this)) {</span>
<span class="line-removed">-             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);</span>
          } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
              return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
          } else {
<span class="line-removed">-             // unrelated types</span>
              return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
          }
      }
  
      public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
<span class="line-new-header">--- 3743,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4210,11 ***</span>
          return covariantReturnType(tres, sres, warner);
      }
  
      /**
       * Return-Type-Substitutable.
<span class="line-modified">!      * @jls section 8.4.5</span>
       */
      public boolean returnTypeSubstitutable(Type r1, Type r2) {
          if (hasSameArgs(r1, r2))
              return resultSubtype(r1, r2, noWarnings);
          else
<span class="line-new-header">--- 4209,11 ---</span>
          return covariantReturnType(tres, sres, warner);
      }
  
      /**
       * Return-Type-Substitutable.
<span class="line-modified">!      * @jls 8.4.5 Method Result</span>
       */
      public boolean returnTypeSubstitutable(Type r1, Type r2) {
          if (hasSameArgs(r1, r2))
              return resultSubtype(r1, r2, noWarnings);
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4998,11 ***</span>
      public static abstract class SignatureGenerator {
  
          public static class InvalidSignatureException extends RuntimeException {
              private static final long serialVersionUID = 0;
  
<span class="line-modified">!             private final Type type;</span>
  
              InvalidSignatureException(Type type) {
                  this.type = type;
              }
  
<span class="line-new-header">--- 4997,11 ---</span>
      public static abstract class SignatureGenerator {
  
          public static class InvalidSignatureException extends RuntimeException {
              private static final long serialVersionUID = 0;
  
<span class="line-modified">!             private final transient Type type;</span>
  
              InvalidSignatureException(Type type) {
                  this.type = type;
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5173,16 ***</span>
                  }
              }
              append(&#39;&gt;&#39;);
          }
  
<span class="line-modified">!         private void assembleSig(List&lt;Type&gt; types) {</span>
              for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
                  assembleSig(ts.head);
              }
          }
      }
      // &lt;/editor-fold&gt;
  
      public void newRound() {
          descCache._map.clear();
          isDerivedRawCache.clear();
<span class="line-new-header">--- 5172,41 ---</span>
                  }
              }
              append(&#39;&gt;&#39;);
          }
  
<span class="line-modified">!         public void assembleSig(List&lt;Type&gt; types) {</span>
              for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
                  assembleSig(ts.head);
              }
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     public Type constantType(LoadableConstant c) {</span>
<span class="line-added">+         switch (c.poolTag()) {</span>
<span class="line-added">+             case ClassFile.CONSTANT_Class:</span>
<span class="line-added">+                 return syms.classType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_String:</span>
<span class="line-added">+                 return syms.stringType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_Integer:</span>
<span class="line-added">+                 return syms.intType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_Float:</span>
<span class="line-added">+                 return syms.floatType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_Long:</span>
<span class="line-added">+                 return syms.longType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_Double:</span>
<span class="line-added">+                 return syms.doubleType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_MethodHandle:</span>
<span class="line-added">+                 return syms.methodHandleType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_MethodType:</span>
<span class="line-added">+                 return syms.methodTypeType;</span>
<span class="line-added">+             case ClassFile.CONSTANT_Dynamic:</span>
<span class="line-added">+                 return ((DynamicVarSymbol)c).type;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
      // &lt;/editor-fold&gt;
  
      public void newRound() {
          descCache._map.clear();
          isDerivedRawCache.clear();
</pre>
<center><a href="TypeMetadata.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Analyzer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
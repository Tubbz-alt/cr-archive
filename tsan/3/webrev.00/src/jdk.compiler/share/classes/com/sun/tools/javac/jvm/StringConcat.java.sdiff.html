<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/StringConcat.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Profile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Target.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/StringConcat.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 
 28 import com.sun.tools.javac.code.*;

 29 import com.sun.tools.javac.comp.Resolve;

 30 import com.sun.tools.javac.tree.JCTree;
 31 import com.sun.tools.javac.tree.TreeInfo;
 32 import com.sun.tools.javac.tree.TreeMaker;
 33 import com.sun.tools.javac.util.*;
 34 
 35 import static com.sun.tools.javac.code.Kinds.Kind.MTH;
 36 import static com.sun.tools.javac.code.TypeTag.*;
 37 import static com.sun.tools.javac.jvm.ByteCodes.*;
 38 import static com.sun.tools.javac.tree.JCTree.Tag.PLUS;
 39 import com.sun.tools.javac.jvm.Items.*;
 40 
 41 import java.util.HashMap;
 42 import java.util.Map;
 43 
 44 /** This lowers the String concatenation to something that JVM can understand.
 45  *
 46  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 47  *  If you write code that depends on this, you do so at your own risk.
 48  *  This code and its internal interfaces are subject to change or
 49  *  deletion without notice.&lt;/b&gt;
</pre>
<hr />
<pre>
205             JCDiagnostic.DiagnosticPosition pos = tree.pos();
206 
207             // Create a string builder.
208             newStringBuilder(tree);
209 
210             // Append all strings to builder.
211             List&lt;JCTree&gt; args = collectAll(tree);
212             for (JCTree t : args) {
213                 gen.genExpr(t, t.type).load();
214                 appendString(t);
215             }
216 
217             // Convert builder to string.
218             builderToString(pos);
219 
220             return gen.getItems().makeStackItem(syms.stringType);
221         }
222 
223         private JCDiagnostic.DiagnosticPosition newStringBuilder(JCTree tree) {
224             JCDiagnostic.DiagnosticPosition pos = tree.pos();
<span class="line-modified">225             gen.getCode().emitop2(new_, gen.makeRef(pos, syms.stringBuilderType));</span>
226             gen.getCode().emitop0(dup);
227             gen.callMethod(pos, syms.stringBuilderType, names.init, List.nil(), false);
228             return pos;
229         }
230 
231         private void appendString(JCTree tree) {
232             Type t = tree.type.baseType();
233             if (!t.isPrimitive() &amp;&amp; t.tsym != syms.stringType.tsym) {
234                 t = syms.objectType;
235             }
236 
237             Assert.checkNull(t.constValue());
238             Symbol method = sbAppends.get(t);
239             if (method == null) {
240                 method = rs.resolveInternalMethod(tree.pos(), gen.getAttrEnv(), syms.stringBuilderType, names.append, List.of(t), null);
241                 sbAppends.put(t, method);
242             }
243 
244             gen.getItems().makeMemberItem(method, false).invoke();
245         }
</pre>
<hr />
<pre>
361                     List.nil(),
362                     syms.methodClass);
363 
364             int prevPos = make.pos;
365             try {
366                 make.at(pos);
367 
368                 List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
369                         syms.stringType,
370                         syms.methodTypeType);
371 
372                 Symbol bsm = rs.resolveInternalMethod(pos,
373                         gen.getAttrEnv(),
374                         syms.stringConcatFactory,
375                         names.makeConcat,
376                         bsm_staticArgs,
377                         null);
378 
379                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcat,
380                         syms.noSymbol,
<span class="line-modified">381                         ClassFile.REF_invokeStatic,</span>
<span class="line-removed">382                         (Symbol.MethodSymbol)bsm,</span>
383                         indyType,
<span class="line-modified">384                         List.nil().toArray());</span>
385 
386                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
387                 item.invoke();
388             } finally {
389                 make.at(prevPos);
390             }
391         }
392     }
393 
394     /**
395      * Emits the invokedynamic call to JDK java.lang.invoke.StringConcatFactory.
396      * This code concatenates all known constants into the recipe, possibly escaping
397      * some constants separately.
398      *
399      * We also bypass empty strings, because they have no meaning at this level. This
400      * captures the Java language trick to force String concat with e.g. (&quot;&quot; + int)-like
401      * expression. Down here, we already know we are in String concat business, and do
402      * not require these markers.
403      */
404     private static final class IndyConstants extends Indy {
405         public IndyConstants(Context context) {
406             super(context);
407         }
408 
409         @Override
410         protected void emit(JCDiagnostic.DiagnosticPosition pos, List&lt;JCTree&gt; args, boolean generateFirstArg, Type type) {
411             List&lt;List&lt;JCTree&gt;&gt; split = split(args);
412 
413             boolean first = true;
414             for (List&lt;JCTree&gt; t : split) {
415                 Assert.check(!t.isEmpty(), &quot;Arguments list is empty&quot;);
416 
417                 StringBuilder recipe = new StringBuilder(t.size());
418                 ListBuffer&lt;Type&gt; dynamicArgs = new ListBuffer&lt;&gt;();
<span class="line-modified">419                 ListBuffer&lt;Object&gt; staticArgs = new ListBuffer&lt;&gt;();</span>
420 
421                 for (JCTree arg : t) {
422                     Object constVal = arg.type.constValue();
423                     if (&quot;&quot;.equals(constVal)) continue;
424                     if (arg.type == syms.botType) {
425                         // Concat the null into the recipe right away
426                         recipe.append((String) null);
427                     } else if (constVal != null) {
428                         // Concat the String representation of the constant, except
429                         // for the case it contains special tags, which requires us
430                         // to expose it as detached constant.
431                         String a = arg.type.stringValue();
432                         if (a.indexOf(TAG_CONST) != -1 || a.indexOf(TAG_ARG) != -1) {
433                             recipe.append(TAG_CONST);
<span class="line-modified">434                             staticArgs.add(a);</span>
435                         } else {
436                             recipe.append(a);
437                         }
438                     } else {
439                         // Ordinary arguments come through the dynamic arguments.
440                         recipe.append(TAG_ARG);
441                         dynamicArgs.add(sharpestAccessible(arg.type));
442                         if (!first || generateFirstArg) {
443                             gen.genExpr(arg, arg.type).load();
444                         }
445                         first = false;
446                     }
447                 }
448 
449                 doCall(type, pos, recipe.toString(), staticArgs.toList(), dynamicArgs.toList());
450             }
451 
452             // More that one peel slice produced: concatenate the results
453             // All arguments are assumed to be non-constant Strings.
454             if (split.size() &gt; 1) {
455                 ListBuffer&lt;Type&gt; argTypes = new ListBuffer&lt;&gt;();
456                 StringBuilder recipe = new StringBuilder();
457                 for (int c = 0; c &lt; split.size(); c++) {
458                     argTypes.append(syms.stringType);
459                     recipe.append(TAG_ARG);
460                 }
461                 doCall(type, pos, recipe.toString(), List.nil(), argTypes.toList());
462             }
463         }
464 
465         /** Produce the actual invokedynamic call to StringConcatFactory */
<span class="line-modified">466         private void doCall(Type type, JCDiagnostic.DiagnosticPosition pos, String recipe, List&lt;Object&gt; staticArgs, List&lt;Type&gt; dynamicArgTypes) {</span>
467             Type.MethodType indyType = new Type.MethodType(dynamicArgTypes,
468                     type,
469                     List.nil(),
470                     syms.methodClass);
471 
472             int prevPos = make.pos;
473             try {
474                 make.at(pos);
475 
476                 ListBuffer&lt;Type&gt; constTypes = new ListBuffer&lt;&gt;();
<span class="line-modified">477                 ListBuffer&lt;Object&gt; constants = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">478                 for (Object t : staticArgs) {</span>
479                     constants.add(t);
480                     constTypes.add(syms.stringType);
481                 }
482 
483                 List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
484                         syms.stringType,
485                         syms.methodTypeType)
486                         .append(syms.stringType)
487                         .appendList(constTypes);
488 
489                 Symbol bsm = rs.resolveInternalMethod(pos,
490                         gen.getAttrEnv(),
491                         syms.stringConcatFactory,
492                         names.makeConcatWithConstants,
493                         bsm_staticArgs,
494                         null);
495 
496                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcatWithConstants,
497                         syms.noSymbol,
<span class="line-modified">498                         ClassFile.REF_invokeStatic,</span>
<span class="line-removed">499                         (Symbol.MethodSymbol)bsm,</span>
500                         indyType,
<span class="line-modified">501                         List.&lt;Object&gt;of(recipe).appendList(constants).toArray());</span>

502 
503                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
504                 item.invoke();
505             } finally {
506                 make.at(prevPos);
507             }
508         }
509     }
510 
511 }
</pre>
</td>
<td>
<hr />
<pre>
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 
 28 import com.sun.tools.javac.code.*;
<span class="line-added"> 29 import com.sun.tools.javac.code.Symbol.MethodSymbol;</span>
 30 import com.sun.tools.javac.comp.Resolve;
<span class="line-added"> 31 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
 32 import com.sun.tools.javac.tree.JCTree;
 33 import com.sun.tools.javac.tree.TreeInfo;
 34 import com.sun.tools.javac.tree.TreeMaker;
 35 import com.sun.tools.javac.util.*;
 36 
 37 import static com.sun.tools.javac.code.Kinds.Kind.MTH;
 38 import static com.sun.tools.javac.code.TypeTag.*;
 39 import static com.sun.tools.javac.jvm.ByteCodes.*;
 40 import static com.sun.tools.javac.tree.JCTree.Tag.PLUS;
 41 import com.sun.tools.javac.jvm.Items.*;
 42 
 43 import java.util.HashMap;
 44 import java.util.Map;
 45 
 46 /** This lowers the String concatenation to something that JVM can understand.
 47  *
 48  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 49  *  If you write code that depends on this, you do so at your own risk.
 50  *  This code and its internal interfaces are subject to change or
 51  *  deletion without notice.&lt;/b&gt;
</pre>
<hr />
<pre>
207             JCDiagnostic.DiagnosticPosition pos = tree.pos();
208 
209             // Create a string builder.
210             newStringBuilder(tree);
211 
212             // Append all strings to builder.
213             List&lt;JCTree&gt; args = collectAll(tree);
214             for (JCTree t : args) {
215                 gen.genExpr(t, t.type).load();
216                 appendString(t);
217             }
218 
219             // Convert builder to string.
220             builderToString(pos);
221 
222             return gen.getItems().makeStackItem(syms.stringType);
223         }
224 
225         private JCDiagnostic.DiagnosticPosition newStringBuilder(JCTree tree) {
226             JCDiagnostic.DiagnosticPosition pos = tree.pos();
<span class="line-modified">227             gen.getCode().emitop2(new_, gen.makeRef(pos, syms.stringBuilderType), syms.stringBuilderType);</span>
228             gen.getCode().emitop0(dup);
229             gen.callMethod(pos, syms.stringBuilderType, names.init, List.nil(), false);
230             return pos;
231         }
232 
233         private void appendString(JCTree tree) {
234             Type t = tree.type.baseType();
235             if (!t.isPrimitive() &amp;&amp; t.tsym != syms.stringType.tsym) {
236                 t = syms.objectType;
237             }
238 
239             Assert.checkNull(t.constValue());
240             Symbol method = sbAppends.get(t);
241             if (method == null) {
242                 method = rs.resolveInternalMethod(tree.pos(), gen.getAttrEnv(), syms.stringBuilderType, names.append, List.of(t), null);
243                 sbAppends.put(t, method);
244             }
245 
246             gen.getItems().makeMemberItem(method, false).invoke();
247         }
</pre>
<hr />
<pre>
363                     List.nil(),
364                     syms.methodClass);
365 
366             int prevPos = make.pos;
367             try {
368                 make.at(pos);
369 
370                 List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
371                         syms.stringType,
372                         syms.methodTypeType);
373 
374                 Symbol bsm = rs.resolveInternalMethod(pos,
375                         gen.getAttrEnv(),
376                         syms.stringConcatFactory,
377                         names.makeConcat,
378                         bsm_staticArgs,
379                         null);
380 
381                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcat,
382                         syms.noSymbol,
<span class="line-modified">383                         ((MethodSymbol)bsm).asHandle(),</span>

384                         indyType,
<span class="line-modified">385                         List.nil().toArray(new LoadableConstant[0]));</span>
386 
387                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
388                 item.invoke();
389             } finally {
390                 make.at(prevPos);
391             }
392         }
393     }
394 
395     /**
396      * Emits the invokedynamic call to JDK java.lang.invoke.StringConcatFactory.
397      * This code concatenates all known constants into the recipe, possibly escaping
398      * some constants separately.
399      *
400      * We also bypass empty strings, because they have no meaning at this level. This
401      * captures the Java language trick to force String concat with e.g. (&quot;&quot; + int)-like
402      * expression. Down here, we already know we are in String concat business, and do
403      * not require these markers.
404      */
405     private static final class IndyConstants extends Indy {
406         public IndyConstants(Context context) {
407             super(context);
408         }
409 
410         @Override
411         protected void emit(JCDiagnostic.DiagnosticPosition pos, List&lt;JCTree&gt; args, boolean generateFirstArg, Type type) {
412             List&lt;List&lt;JCTree&gt;&gt; split = split(args);
413 
414             boolean first = true;
415             for (List&lt;JCTree&gt; t : split) {
416                 Assert.check(!t.isEmpty(), &quot;Arguments list is empty&quot;);
417 
418                 StringBuilder recipe = new StringBuilder(t.size());
419                 ListBuffer&lt;Type&gt; dynamicArgs = new ListBuffer&lt;&gt;();
<span class="line-modified">420                 ListBuffer&lt;LoadableConstant&gt; staticArgs = new ListBuffer&lt;&gt;();</span>
421 
422                 for (JCTree arg : t) {
423                     Object constVal = arg.type.constValue();
424                     if (&quot;&quot;.equals(constVal)) continue;
425                     if (arg.type == syms.botType) {
426                         // Concat the null into the recipe right away
427                         recipe.append((String) null);
428                     } else if (constVal != null) {
429                         // Concat the String representation of the constant, except
430                         // for the case it contains special tags, which requires us
431                         // to expose it as detached constant.
432                         String a = arg.type.stringValue();
433                         if (a.indexOf(TAG_CONST) != -1 || a.indexOf(TAG_ARG) != -1) {
434                             recipe.append(TAG_CONST);
<span class="line-modified">435                             staticArgs.add(LoadableConstant.String(a));</span>
436                         } else {
437                             recipe.append(a);
438                         }
439                     } else {
440                         // Ordinary arguments come through the dynamic arguments.
441                         recipe.append(TAG_ARG);
442                         dynamicArgs.add(sharpestAccessible(arg.type));
443                         if (!first || generateFirstArg) {
444                             gen.genExpr(arg, arg.type).load();
445                         }
446                         first = false;
447                     }
448                 }
449 
450                 doCall(type, pos, recipe.toString(), staticArgs.toList(), dynamicArgs.toList());
451             }
452 
453             // More that one peel slice produced: concatenate the results
454             // All arguments are assumed to be non-constant Strings.
455             if (split.size() &gt; 1) {
456                 ListBuffer&lt;Type&gt; argTypes = new ListBuffer&lt;&gt;();
457                 StringBuilder recipe = new StringBuilder();
458                 for (int c = 0; c &lt; split.size(); c++) {
459                     argTypes.append(syms.stringType);
460                     recipe.append(TAG_ARG);
461                 }
462                 doCall(type, pos, recipe.toString(), List.nil(), argTypes.toList());
463             }
464         }
465 
466         /** Produce the actual invokedynamic call to StringConcatFactory */
<span class="line-modified">467         private void doCall(Type type, JCDiagnostic.DiagnosticPosition pos, String recipe, List&lt;LoadableConstant&gt; staticArgs, List&lt;Type&gt; dynamicArgTypes) {</span>
468             Type.MethodType indyType = new Type.MethodType(dynamicArgTypes,
469                     type,
470                     List.nil(),
471                     syms.methodClass);
472 
473             int prevPos = make.pos;
474             try {
475                 make.at(pos);
476 
477                 ListBuffer&lt;Type&gt; constTypes = new ListBuffer&lt;&gt;();
<span class="line-modified">478                 ListBuffer&lt;LoadableConstant&gt; constants = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">479                 for (LoadableConstant t : staticArgs) {</span>
480                     constants.add(t);
481                     constTypes.add(syms.stringType);
482                 }
483 
484                 List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
485                         syms.stringType,
486                         syms.methodTypeType)
487                         .append(syms.stringType)
488                         .appendList(constTypes);
489 
490                 Symbol bsm = rs.resolveInternalMethod(pos,
491                         gen.getAttrEnv(),
492                         syms.stringConcatFactory,
493                         names.makeConcatWithConstants,
494                         bsm_staticArgs,
495                         null);
496 
497                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcatWithConstants,
498                         syms.noSymbol,
<span class="line-modified">499                         ((MethodSymbol)bsm).asHandle(),</span>

500                         indyType,
<span class="line-modified">501                         List.of(LoadableConstant.String(recipe))</span>
<span class="line-added">502                                 .appendList(constants).toArray(new LoadableConstant[constants.size()]));</span>
503 
504                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
505                 item.invoke();
506             } finally {
507                 make.at(prevPos);
508             }
509         }
510     }
511 
512 }
</pre>
</td>
</tr>
</table>
<center><a href="Profile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Target.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
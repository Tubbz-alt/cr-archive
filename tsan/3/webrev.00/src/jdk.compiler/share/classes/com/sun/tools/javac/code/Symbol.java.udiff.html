<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Source.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SymbolMetadata.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,22 +27,25 @@</span>
  
  import java.lang.annotation.Annotation;
  import java.lang.annotation.Inherited;
  import java.util.Collections;
  import java.util.EnumSet;
<span class="udiff-line-added">+ import java.util.HashMap;</span>
  import java.util.Map;
  import java.util.Set;
  import java.util.concurrent.Callable;
<span class="udiff-line-added">+ import java.util.function.Supplier;</span>
  
  import javax.lang.model.element.Element;
  import javax.lang.model.element.ElementKind;
  import javax.lang.model.element.ElementVisitor;
  import javax.lang.model.element.ExecutableElement;
  import javax.lang.model.element.Modifier;
  import javax.lang.model.element.ModuleElement;
  import javax.lang.model.element.NestingKind;
  import javax.lang.model.element.PackageElement;
<span class="udiff-line-added">+ import javax.lang.model.element.RecordComponentElement;</span>
  import javax.lang.model.element.TypeElement;
  import javax.lang.model.element.TypeParameterElement;
  import javax.lang.model.element.VariableElement;
  import javax.tools.JavaFileManager;
  import javax.tools.JavaFileObject;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -52,23 +55,26 @@</span>
  import com.sun.tools.javac.code.Type.*;
  import com.sun.tools.javac.comp.Attr;
  import com.sun.tools.javac.comp.AttrContext;
  import com.sun.tools.javac.comp.Env;
  import com.sun.tools.javac.jvm.*;
<span class="udiff-line-added">+ import com.sun.tools.javac.jvm.PoolConstant;</span>
<span class="udiff-line-added">+ import com.sun.tools.javac.tree.JCTree;</span>
<span class="udiff-line-added">+ import com.sun.tools.javac.tree.JCTree.JCAnnotation;</span>
  import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
  import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  import com.sun.tools.javac.tree.JCTree.Tag;
  import com.sun.tools.javac.util.*;
  import com.sun.tools.javac.util.DefinedBy.Api;
<span class="udiff-line-added">+ import com.sun.tools.javac.util.List;</span>
  import com.sun.tools.javac.util.Name;
  
  import static com.sun.tools.javac.code.Flags.*;
  import static com.sun.tools.javac.code.Kinds.*;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
  import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  import com.sun.tools.javac.code.Scope.WriteableScope;
<span class="udiff-line-removed">- import static com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode.FIRSTASGOP;</span>
  import static com.sun.tools.javac.code.TypeTag.CLASS;
  import static com.sun.tools.javac.code.TypeTag.FORALL;
  import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  import static com.sun.tools.javac.jvm.ByteCodes.iadd;
  import static com.sun.tools.javac.jvm.ByteCodes.ishll;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -84,11 +90,11 @@</span>
   *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
   *  If you write code that depends on this, you do so at your own risk.
   *  This code and its internal interfaces are subject to change or
   *  deletion without notice.&lt;/b&gt;
   */
<span class="udiff-line-modified-removed">- public abstract class Symbol extends AnnoConstruct implements Element {</span>
<span class="udiff-line-modified-added">+ public abstract class Symbol extends AnnoConstruct implements PoolConstant, Element {</span>
  
      /** The kind of this symbol.
       *  @see Kinds
       */
      public Kind kind;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,10 +285,15 @@</span>
          this.completer = Completer.NULL_COMPLETER;
          this.erasure_field = null;
          this.name = name;
      }
  
<span class="udiff-line-added">+     @Override</span>
<span class="udiff-line-added">+     public int poolTag() {</span>
<span class="udiff-line-added">+         throw new AssertionError(&quot;Invalid pool entry&quot;);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Clone this symbol with new owner.
       *  Legal only for fields and methods.
       */
      public Symbol clone(Symbol newOwner) {
          throw new AssertionError();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -365,10 +376,14 @@</span>
  
      public boolean isDeprecatedForRemoval() {
          return (flags_field &amp; DEPRECATED_REMOVAL) != 0;
      }
  
<span class="udiff-line-added">+     public boolean isPreviewApi() {</span>
<span class="udiff-line-added">+         return (flags_field &amp; PREVIEW_API) != 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public boolean isDeprecatableViaAnnotation() {
          switch (getKind()) {
              case LOCAL_VARIABLE:
              case PACKAGE:
              case PARAMETER:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -389,19 +404,31 @@</span>
  
      public boolean isInterface() {
          return (flags() &amp; INTERFACE) != 0;
      }
  
<span class="udiff-line-added">+     public boolean isAbstract() {</span>
<span class="udiff-line-added">+         return (flags_field &amp; ABSTRACT) != 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public boolean isPrivate() {
          return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
      }
  
<span class="udiff-line-added">+     public boolean isPublic() {</span>
<span class="udiff-line-added">+         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public boolean isEnum() {
          return (flags() &amp; ENUM) != 0;
      }
  
<span class="udiff-line-modified-removed">-     /** Is this symbol declared (directly or indirectly) local</span>
<span class="udiff-line-modified-added">+     public boolean isFinal() {</span>
<span class="udiff-line-added">+         return (flags_field &amp; FINAL) != 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+    /** Is this symbol declared (directly or indirectly) local</span>
       *  to a method or variable initializer?
       *  Also includes fields of inner classes which are in
       *  turn local to a method or variable initializer.
       */
      public boolean isLocal() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -421,10 +448,14 @@</span>
       */
      public boolean isConstructor() {
          return name == name.table.names.init;
      }
  
<span class="udiff-line-added">+     public boolean isDynamic() {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** The fully qualified name of this symbol.
       *  This is the same as the symbol&#39;s name except for class symbols,
       *  which are handled separately.
       */
      public Name getQualifiedName() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -807,11 +838,11 @@</span>
              }
              return type.hasTag(TYPEVAR);
          }
  
          @Override @DefinedBy(Api.LANGUAGE_MODEL)
<span class="udiff-line-modified-removed">-         public java.util.List&lt;Symbol&gt; getEnclosedElements() {</span>
<span class="udiff-line-modified-added">+         public List&lt;Symbol&gt; getEnclosedElements() {</span>
              List&lt;Symbol&gt; list = List.nil();
              if (kind == TYP &amp;&amp; type.hasTag(TYPEVAR)) {
                  return list;
              }
              apiComplete();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -964,10 +995,15 @@</span>
              super(MDL, 0, name, null, owner);
              Assert.checkNonNull(name);
              this.type = new ModuleType(this);
          }
  
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int poolTag() {</span>
<span class="udiff-line-added">+             return ClassFile.CONSTANT_Module;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          @Override @DefinedBy(Api.LANGUAGE_MODEL)
          public Name getSimpleName() {
              return Convert.shortName(name);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1130,10 +1166,15 @@</span>
          public WriteableScope members() {
              complete();
              return members_field;
          }
  
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int poolTag() {</span>
<span class="udiff-line-added">+             return ClassFile.CONSTANT_Package;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          public long flags() {
              complete();
              return flags_field;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1186,10 +1227,20 @@</span>
              metadata = null;
          }
  
      }
  
<span class="udiff-line-added">+     public static class RootPackageSymbol extends PackageSymbol {</span>
<span class="udiff-line-added">+         public final MissingInfoHandler missingInfoHandler;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public RootPackageSymbol(Name name, Symbol owner, MissingInfoHandler missingInfoHandler) {</span>
<span class="udiff-line-added">+             super(name, owner);</span>
<span class="udiff-line-added">+             this.missingInfoHandler = missingInfoHandler;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** A class for class symbols
       */
      public static class ClassSymbol extends TypeSymbol implements TypeElement {
  
          /** a scope for all class members; variables, methods and inner classes
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1220,25 +1271,25 @@</span>
          /** the list of translated local classes (used for generating
           * InnerClasses attribute)
           */
          public List&lt;ClassSymbol&gt; trans_local;
  
<span class="udiff-line-removed">-         /** the constant pool of the class</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         public Pool pool;</span>
<span class="udiff-line-removed">- </span>
          /** the annotation metadata attached to this class */
          private AnnotationTypeMetadata annotationTypeMetadata;
  
<span class="udiff-line-added">+         /* the list of any of record components, only non empty if the class is a record</span>
<span class="udiff-line-added">+          * and it has at least one record component</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private List&lt;RecordComponent&gt; recordComponents = List.nil();</span>
<span class="udiff-line-added">+ </span>
          public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
              super(TYP, flags, name, type, owner);
              this.members_field = null;
              this.fullname = formFullName(name, owner);
              this.flatname = formFlatName(name, owner);
              this.sourcefile = null;
              this.classfile = null;
<span class="udiff-line-removed">-             this.pool = null;</span>
              this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
          }
  
          public ClassSymbol(long flags, Name name, Symbol owner) {
              this(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1296,10 +1347,22 @@</span>
          @DefinedBy(Api.LANGUAGE_MODEL)
          public Name getQualifiedName() {
              return fullname;
          }
  
<span class="udiff-line-added">+         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="udiff-line-added">+         public List&lt;Symbol&gt; getEnclosedElements() {</span>
<span class="udiff-line-added">+             List&lt;Symbol&gt; result = super.getEnclosedElements();</span>
<span class="udiff-line-added">+             if (!recordComponents.isEmpty()) {</span>
<span class="udiff-line-added">+                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();</span>
<span class="udiff-line-added">+                 for (RecordComponent rc : reversed) {</span>
<span class="udiff-line-added">+                     result = result.prepend(rc);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return result;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          public Name flatName() {
              return flatname;
          }
  
          public boolean isSubClass(Symbol base, Types types) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1388,19 +1451,22 @@</span>
                                 : sup.getAnnotationsByType(annoType);
          }
  
  
          @DefinedBy(Api.LANGUAGE_MODEL)
<span class="udiff-line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
          public ElementKind getKind() {
              apiComplete();
              long flags = flags();
              if ((flags &amp; ANNOTATION) != 0)
                  return ElementKind.ANNOTATION_TYPE;
              else if ((flags &amp; INTERFACE) != 0)
                  return ElementKind.INTERFACE;
              else if ((flags &amp; ENUM) != 0)
                  return ElementKind.ENUM;
<span class="udiff-line-added">+             else if ((flags &amp; RECORD) != 0)</span>
<span class="udiff-line-added">+                 return ElementKind.RECORD;</span>
              else
                  return ElementKind.CLASS;
          }
  
          @Override @DefinedBy(Api.LANGUAGE_MODEL)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1408,10 +1474,38 @@</span>
              apiComplete();
              long flags = flags();
              return Flags.asModifierSet(flags &amp; ~DEFAULT);
          }
  
<span class="udiff-line-added">+         public RecordComponent getRecordComponent(VarSymbol field) {</span>
<span class="udiff-line-added">+             for (RecordComponent rc : recordComponents) {</span>
<span class="udiff-line-added">+                 if (rc.name == field.name) {</span>
<span class="udiff-line-added">+                     return rc;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing) {</span>
<span class="udiff-line-added">+             for (RecordComponent rc : recordComponents) {</span>
<span class="udiff-line-added">+                 if (rc.name == var.name) {</span>
<span class="udiff-line-added">+                     return rc;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             RecordComponent rc = null;</span>
<span class="udiff-line-added">+             if (addIfMissing) {</span>
<span class="udiff-line-added">+                 recordComponents = recordComponents.append(rc = new RecordComponent(var));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return rc;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="udiff-line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="udiff-line-added">+         public List&lt;? extends RecordComponent&gt; getRecordComponents() {</span>
<span class="udiff-line-added">+             return recordComponents;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          @DefinedBy(Api.LANGUAGE_MODEL)
          public NestingKind getNestingKind() {
              apiComplete();
              if (owner.kind == PCK)
                  return NestingKind.TOP_LEVEL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1421,11 +1515,10 @@</span>
                  return NestingKind.LOCAL;
              else
                  return NestingKind.MEMBER;
          }
  
<span class="udiff-line-removed">- </span>
          @Override
          protected &lt;A extends Annotation&gt; Attribute.Compound getAttribute(final Class&lt;A&gt; annoType) {
  
              Attribute.Compound attrib = super.getAttribute(annoType);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1437,13 +1530,10 @@</span>
              ClassSymbol superType = getSuperClassToSearchForAnnotations();
              return superType == null ? null
                                       : superType.getAttribute(annoType);
          }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
          @DefinedBy(Api.LANGUAGE_MODEL)
          public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
              return v.visitType(this, p);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1498,10 +1588,14 @@</span>
          public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
              Assert.checkNonNull(a);
              Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
              this.annotationTypeMetadata = a;
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public boolean isRecord() {</span>
<span class="udiff-line-added">+             return (flags_field &amp; RECORD) != 0;</span>
<span class="udiff-line-added">+         }</span>
      }
  
  
      /** A class for variable symbols
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1526,18 +1620,32 @@</span>
           */
          public VarSymbol(long flags, Name name, Type type, Symbol owner) {
              super(VAR, flags, name, type, owner);
          }
  
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int poolTag() {</span>
<span class="udiff-line-added">+             return ClassFile.CONSTANT_Fieldref;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public MethodHandleSymbol asMethodHandle(boolean getter) {</span>
<span class="udiff-line-added">+             return new MethodHandleSymbol(this, getter);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /** Clone this symbol with new owner.
           */
          public VarSymbol clone(Symbol newOwner) {
              VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
                  @Override
                  public Symbol baseSymbol() {
                      return VarSymbol.this;
                  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 @Override</span>
<span class="udiff-line-added">+                 public Object poolKey(Types types) {</span>
<span class="udiff-line-added">+                     return new Pair&lt;&gt;(newOwner, baseSymbol());</span>
<span class="udiff-line-added">+                 }</span>
              };
              v.pos = pos;
              v.adr = adr;
              v.data = data;
  //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1564,10 +1672,14 @@</span>
                  return ElementKind.ENUM_CONSTANT;
              } else if (owner.kind == TYP || owner.kind == ERR) {
                  return ElementKind.FIELD;
              } else if (isResourceVariable()) {
                  return ElementKind.RESOURCE_VARIABLE;
<span class="udiff-line-added">+             } else if ((flags &amp; MATCH_BINDING) != 0) {</span>
<span class="udiff-line-added">+                 @SuppressWarnings(&quot;preview&quot;)</span>
<span class="udiff-line-added">+                 ElementKind kind = ElementKind.BINDING_VARIABLE;</span>
<span class="udiff-line-added">+                 return kind;</span>
              } else {
                  return ElementKind.LOCAL_VARIABLE;
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1631,10 +1743,93 @@</span>
          public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
              return v.visitVarSymbol(this, p);
          }
      }
  
<span class="udiff-line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="udiff-line-added">+     public static class RecordComponent extends VarSymbol implements RecordComponentElement {</span>
<span class="udiff-line-added">+         public MethodSymbol accessor;</span>
<span class="udiff-line-added">+         public JCTree.JCMethodDecl accessorMeth;</span>
<span class="udiff-line-added">+         private final List&lt;JCAnnotation&gt; originalAnnos;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Construct a record component, given its flags, name, type and owner.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public RecordComponent(JCVariableDecl fieldDecl) {</span>
<span class="udiff-line-added">+             super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);</span>
<span class="udiff-line-added">+             this.originalAnnos = fieldDecl.mods.annotations;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public List&lt;JCAnnotation&gt; getOriginalAnnos() { return originalAnnos; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="udiff-line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="udiff-line-added">+         public ElementKind getKind() {</span>
<span class="udiff-line-added">+             return ElementKind.RECORD_COMPONENT;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="udiff-line-added">+         public ExecutableElement getAccessor() {</span>
<span class="udiff-line-added">+             return accessor;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="udiff-line-added">+         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="udiff-line-added">+         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {</span>
<span class="udiff-line-added">+             return v.visitRecordComponent(this, p);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class ParamSymbol extends VarSymbol {</span>
<span class="udiff-line-added">+         public ParamSymbol(long flags, Name name, Type type, Symbol owner) {</span>
<span class="udiff-line-added">+             super(flags, name, type, owner);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Name getSimpleName() {</span>
<span class="udiff-line-added">+             if ((flags_field &amp; NAME_FILLED) == 0) {</span>
<span class="udiff-line-added">+                 flags_field |= NAME_FILLED;</span>
<span class="udiff-line-added">+                 Symbol rootPack = this;</span>
<span class="udiff-line-added">+                 while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {</span>
<span class="udiff-line-added">+                     rootPack = rootPack.owner;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (rootPack != null) {</span>
<span class="udiff-line-added">+                     Name inferredName =</span>
<span class="udiff-line-added">+                             ((RootPackageSymbol) rootPack).missingInfoHandler.getParameterName(this);</span>
<span class="udiff-line-added">+                     if (inferredName != null) {</span>
<span class="udiff-line-added">+                         this.name = inferredName;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             return super.getSimpleName();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public static class BindingSymbol extends VarSymbol {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public BindingSymbol(Name name, Type type, Symbol owner) {</span>
<span class="udiff-line-added">+             super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public boolean isAliasFor(BindingSymbol b) {</span>
<span class="udiff-line-added">+             return aliases().containsAll(b.aliases());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;BindingSymbol&gt; aliases() {</span>
<span class="udiff-line-added">+             return List.of(this);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public void preserveBinding() {</span>
<span class="udiff-line-added">+             flags_field |= Flags.MATCH_BINDING_TO_OUTER;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public boolean isPreserved() {</span>
<span class="udiff-line-added">+             return (flags_field &amp; Flags.MATCH_BINDING_TO_OUTER) != 0;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** A class for method symbols.
       */
      public static class MethodSymbol extends Symbol implements ExecutableElement {
  
          /** The code of the method. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1668,10 +1863,15 @@</span>
              MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
                  @Override
                  public Symbol baseSymbol() {
                      return MethodSymbol.this;
                  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 @Override</span>
<span class="udiff-line-added">+                 public Object poolKey(Types types) {</span>
<span class="udiff-line-added">+                     return new Pair&lt;&gt;(newOwner, baseSymbol());</span>
<span class="udiff-line-added">+                 }</span>
              };
              m.code = code;
              return m;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1697,14 +1897,25 @@</span>
                  }
                  return s;
              }
          }
  
<span class="udiff-line-modified-removed">-         public boolean isDynamic() {</span>
<span class="udiff-line-modified-added">+         @Override</span>
<span class="udiff-line-added">+         public int poolTag() {</span>
<span class="udiff-line-added">+             return owner.isInterface() ?</span>
<span class="udiff-line-added">+                     ClassFile.CONSTANT_InterfaceMethodref : ClassFile.CONSTANT_Methodref;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public boolean isHandle() {</span>
              return false;
          }
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public MethodHandleSymbol asHandle() {</span>
<span class="udiff-line-added">+             return new MethodHandleSymbol(this);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /** find a symbol that this (proxy method) symbol implements.
           *  @param    c       The class whose members are searched for
           *                    implementations
           */
          public Symbol implemented(TypeSymbol c, Types types) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1875,10 +2086,17 @@</span>
  
          public boolean isLambdaMethod() {
              return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
          }
  
<span class="udiff-line-added">+         /** override this method to point to the original enclosing method if this method symbol represents a synthetic</span>
<span class="udiff-line-added">+          *  lambda method</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public MethodSymbol originalEnclosingMethod() {</span>
<span class="udiff-line-added">+             return this;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          /** The implementation of this (abstract) symbol in class origin;
           *  null if none exists. Synthetic methods are not considered
           *  as possible implementations.
           */
          public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1968,11 +2186,12 @@</span>
              return v.visitMethodSymbol(this, p);
          }
  
          @DefinedBy(Api.LANGUAGE_MODEL)
          public Type getReceiverType() {
<span class="udiff-line-modified-removed">-             return asType().getReceiverType();</span>
<span class="udiff-line-modified-added">+             Type result = asType().getReceiverType();</span>
<span class="udiff-line-added">+             return (result == null) ? Type.noType : result;</span>
          }
  
          @DefinedBy(Api.LANGUAGE_MODEL)
          public Type getReturnType() {
              return asType().getReturnType();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1984,27 +2203,152 @@</span>
          }
      }
  
      /** A class for invokedynamic method calls.
       */
<span class="udiff-line-modified-removed">-     public static class DynamicMethodSymbol extends MethodSymbol {</span>
<span class="udiff-line-modified-added">+     public static class DynamicMethodSymbol extends MethodSymbol implements Dynamic {</span>
  
<span class="udiff-line-modified-removed">-         public Object[] staticArgs;</span>
<span class="udiff-line-modified-removed">-         public Symbol bsm;</span>
<span class="udiff-line-removed">-         public int bsmKind;</span>
<span class="udiff-line-modified-added">+         public LoadableConstant[] staticArgs;</span>
<span class="udiff-line-modified-added">+         public MethodHandleSymbol bsm;</span>
  
<span class="udiff-line-modified-removed">-         public DynamicMethodSymbol(Name name, Symbol owner, int bsmKind, MethodSymbol bsm, Type type, Object[] staticArgs) {</span>
<span class="udiff-line-modified-added">+         public DynamicMethodSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {</span>
              super(0, name, type, owner);
              this.bsm = bsm;
<span class="udiff-line-removed">-             this.bsmKind = bsmKind;</span>
              this.staticArgs = staticArgs;
          }
  
          @Override
          public boolean isDynamic() {
              return true;
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public LoadableConstant[] staticArgs() {</span>
<span class="udiff-line-added">+             return staticArgs;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public MethodHandleSymbol bootstrapMethod() {</span>
<span class="udiff-line-added">+             return bsm;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int poolTag() {</span>
<span class="udiff-line-added">+             return ClassFile.CONSTANT_InvokeDynamic;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Type dynamicType() {</span>
<span class="udiff-line-added">+             return type;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** A class for condy.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static class DynamicVarSymbol extends VarSymbol implements Dynamic, LoadableConstant {</span>
<span class="udiff-line-added">+         public LoadableConstant[] staticArgs;</span>
<span class="udiff-line-added">+         public MethodHandleSymbol bsm;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public DynamicVarSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {</span>
<span class="udiff-line-added">+             super(0, name, type, owner);</span>
<span class="udiff-line-added">+             this.bsm = bsm;</span>
<span class="udiff-line-added">+             this.staticArgs = staticArgs;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean isDynamic() {</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public PoolConstant dynamicType() {</span>
<span class="udiff-line-added">+             return type;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public LoadableConstant[] staticArgs() {</span>
<span class="udiff-line-added">+             return staticArgs;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public LoadableConstant bootstrapMethod() {</span>
<span class="udiff-line-added">+             return bsm;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int poolTag() {</span>
<span class="udiff-line-added">+             return ClassFile.CONSTANT_Dynamic;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** A class for method handles.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public static class MethodHandleSymbol extends MethodSymbol implements LoadableConstant {</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private Symbol refSym;</span>
<span class="udiff-line-added">+         private boolean getter;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public MethodHandleSymbol(Symbol msym) {</span>
<span class="udiff-line-added">+             this(msym, false);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public MethodHandleSymbol(Symbol msym, boolean getter) {</span>
<span class="udiff-line-added">+             super(msym.flags_field, msym.name, msym.type, msym.owner);</span>
<span class="udiff-line-added">+             this.refSym = msym;</span>
<span class="udiff-line-added">+             this.getter = getter;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Returns the kind associated with this method handle.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public int referenceKind() {</span>
<span class="udiff-line-added">+             if (refSym.kind == VAR) {</span>
<span class="udiff-line-added">+                 return getter ?</span>
<span class="udiff-line-added">+                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :</span>
<span class="udiff-line-added">+                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 if (refSym.isConstructor()) {</span>
<span class="udiff-line-added">+                     return ClassFile.REF_newInvokeSpecial;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     if (refSym.isStatic()) {</span>
<span class="udiff-line-added">+                         return ClassFile.REF_invokeStatic;</span>
<span class="udiff-line-added">+                     } else if ((refSym.flags() &amp; PRIVATE) != 0) {</span>
<span class="udiff-line-added">+                         return ClassFile.REF_invokeSpecial;</span>
<span class="udiff-line-added">+                     } else if (refSym.enclClass().isInterface()) {</span>
<span class="udiff-line-added">+                         return ClassFile.REF_invokeInterface;</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         return ClassFile.REF_invokeVirtual;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public int poolTag() {</span>
<span class="udiff-line-added">+             return ClassFile.CONSTANT_MethodHandle;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Object poolKey(Types types) {</span>
<span class="udiff-line-added">+             return new Pair&lt;&gt;(baseSymbol(), referenceKind());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public MethodHandleSymbol asHandle() {</span>
<span class="udiff-line-added">+             return this;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public Symbol baseSymbol() {</span>
<span class="udiff-line-added">+             return refSym;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         @Override</span>
<span class="udiff-line-added">+         public boolean isHandle() {</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
      }
  
      /** A class for predefined operators.
       */
      public static class OperatorSymbol extends MethodSymbol {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2124,43 +2468,53 @@</span>
          }
      }
  
      public static class CompletionFailure extends RuntimeException {
          private static final long serialVersionUID = 0;
<span class="udiff-line-modified-removed">-         public final DeferredCompletionFailureHandler dcfh;</span>
<span class="udiff-line-modified-removed">-         public Symbol sym;</span>
<span class="udiff-line-modified-added">+         public final transient DeferredCompletionFailureHandler dcfh;</span>
<span class="udiff-line-modified-added">+         public transient Symbol sym;</span>
  
          /** A diagnostic object describing the failure
           */
<span class="udiff-line-modified-removed">-         public JCDiagnostic diag;</span>
<span class="udiff-line-modified-added">+         private transient JCDiagnostic diag;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private transient Supplier&lt;JCDiagnostic&gt; diagSupplier;</span>
  
<span class="udiff-line-modified-removed">-         public CompletionFailure(Symbol sym, JCDiagnostic diag, DeferredCompletionFailureHandler dcfh) {</span>
<span class="udiff-line-modified-added">+         public CompletionFailure(Symbol sym, Supplier&lt;JCDiagnostic&gt; diagSupplier, DeferredCompletionFailureHandler dcfh) {</span>
              this.dcfh = dcfh;
              this.sym = sym;
<span class="udiff-line-modified-removed">-             this.diag = diag;</span>
<span class="udiff-line-modified-added">+             this.diagSupplier = diagSupplier;</span>
  //          this.printStackTrace();//DEBUG
          }
  
          public JCDiagnostic getDiagnostic() {
<span class="udiff-line-added">+             if (diag == null &amp;&amp; diagSupplier != null) {</span>
<span class="udiff-line-added">+                 diag = diagSupplier.get();</span>
<span class="udiff-line-added">+             }</span>
              return diag;
          }
  
          @Override
          public String getMessage() {
<span class="udiff-line-modified-removed">-             return diag.getMessage(null);</span>
<span class="udiff-line-modified-added">+             return getDiagnostic().getMessage(null);</span>
          }
  
          public JCDiagnostic getDetailValue() {
<span class="udiff-line-modified-removed">-             return diag;</span>
<span class="udiff-line-modified-added">+             return getDiagnostic();</span>
          }
  
          @Override
          public CompletionFailure initCause(Throwable cause) {
              super.initCause(cause);
              return this;
          }
  
<span class="udiff-line-added">+         public void resetDiagnostic(Supplier&lt;JCDiagnostic&gt; diagSupplier) {</span>
<span class="udiff-line-added">+             this.diagSupplier = diagSupplier;</span>
<span class="udiff-line-added">+             this.diag = null;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
      }
  
      /**
       * A visitor for symbols.  A visitor is used to implement operations
       * (or relations) on symbols.  Most common operations on types are
</pre>
<center><a href="Source.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SymbolMetadata.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
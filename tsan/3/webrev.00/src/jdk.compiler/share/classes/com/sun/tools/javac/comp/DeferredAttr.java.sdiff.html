<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompileStates.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Enter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/DeferredAttr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  29 import com.sun.source.tree.NewClassTree;
  30 import com.sun.tools.javac.code.*;
  31 import com.sun.tools.javac.code.Type.ErrorType;
  32 import com.sun.tools.javac.code.Type.MethodType;
  33 import com.sun.tools.javac.code.Type.StructuralTypeMapping;
  34 import com.sun.tools.javac.code.Types.TypeMapping;
  35 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  36 import com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph;
  37 import com.sun.tools.javac.comp.Resolve.ResolveError;
  38 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  39 import com.sun.tools.javac.tree.*;
  40 import com.sun.tools.javac.util.*;
  41 import com.sun.tools.javac.util.DefinedBy.Api;
  42 import com.sun.tools.javac.util.GraphUtils.DependencyKind;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
<span class="line-removed">  44 import com.sun.tools.javac.code.Symbol.*;</span>
  45 import com.sun.tools.javac.comp.Attr.ResultInfo;
  46 import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;
  47 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  50 import com.sun.tools.javac.util.Log.DeferredDiagnosticHandler;

  51 
  52 import java.util.ArrayList;
  53 import java.util.Collection;
  54 import java.util.Collections;
  55 import java.util.EnumSet;
  56 import java.util.HashSet;
  57 import java.util.LinkedHashSet;
  58 import java.util.Map;
  59 import java.util.Set;
  60 import java.util.WeakHashMap;
<span class="line-modified">  61 import java.util.function.Function;</span>
  62 
  63 import com.sun.source.tree.MemberReferenceTree;
  64 import com.sun.tools.javac.code.Type;
  65 import com.sun.tools.javac.tree.JCTree.JCMemberReference.OverloadKind;
  66 
  67 import static com.sun.tools.javac.code.TypeTag.*;

  68 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  69 
  70 /**
  71  * This is an helper class that is used to perform deferred type-analysis.
  72  * Each time a poly expression occurs in argument position, javac attributes it
  73  * with a temporary &#39;deferred type&#39; that is checked (possibly multiple times)
  74  * against an expected formal type.
  75  *
  76  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  77  *  If you write code that depends on this, you do so at your own risk.
  78  *  This code and its internal interfaces are subject to change or
  79  *  deletion without notice.&lt;/b&gt;
  80  */
  81 public class DeferredAttr extends JCTree.Visitor {
  82     protected static final Context.Key&lt;DeferredAttr&gt; deferredAttrKey = new Context.Key&lt;&gt;();
  83 

  84     final Attr attr;
  85     final ArgumentAttr argumentAttr;
  86     final Check chk;
  87     final JCDiagnostic.Factory diags;
  88     final Enter enter;
  89     final Infer infer;
  90     final Resolve rs;
  91     final Log log;
  92     final Symtab syms;
  93     final TreeMaker make;
  94     final TreeCopier&lt;Void&gt; treeCopier;
  95     final TypeMapping&lt;Void&gt; deferredCopier;
  96     final Types types;
  97     final Flow flow;
  98     final Names names;
  99     final TypeEnvs typeEnvs;

 100 
 101     public static DeferredAttr instance(Context context) {
 102         DeferredAttr instance = context.get(deferredAttrKey);
 103         if (instance == null)
 104             instance = new DeferredAttr(context);
 105         return instance;
 106     }
 107 
 108     protected DeferredAttr(Context context) {
 109         context.put(deferredAttrKey, this);

 110         attr = Attr.instance(context);
 111         argumentAttr = ArgumentAttr.instance(context);
 112         chk = Check.instance(context);
 113         diags = JCDiagnostic.Factory.instance(context);
 114         enter = Enter.instance(context);
 115         infer = Infer.instance(context);
 116         rs = Resolve.instance(context);
 117         log = Log.instance(context);
 118         syms = Symtab.instance(context);
 119         make = TreeMaker.instance(context);
 120         types = Types.instance(context);
 121         flow = Flow.instance(context);
 122         names = Names.instance(context);
 123         stuckTree = make.Ident(names.empty).setType(Type.stuckType);
 124         typeEnvs = TypeEnvs.instance(context);

 125         emptyDeferredAttrContext =
 126             new DeferredAttrContext(AttrMode.CHECK, null, MethodResolutionPhase.BOX, infer.emptyContext, null, null) {
 127                 @Override
 128                 void addDeferredAttrNode(DeferredType dt, ResultInfo ri, DeferredStuckPolicy deferredStuckPolicy) {
 129                     Assert.error(&quot;Empty deferred context!&quot;);
 130                 }
 131                 @Override
 132                 void complete() {
 133                     Assert.error(&quot;Empty deferred context!&quot;);
 134                 }
 135 
 136                 @Override
 137                 public String toString() {
 138                     return &quot;Empty deferred context!&quot;;
 139                 }
 140             };
 141 
 142         // For speculative attribution, skip the class definition in &lt;&gt;.
 143         treeCopier =
 144             new TreeCopier&lt;Void&gt;(make) {
</pre>
<hr />
<pre>
 465             if (lambdaBody.hasTag(Tag.RETURN)) {
 466                 lambdaBody = ((JCReturn)lambdaBody).expr;
 467             }
 468             JCLambda speculativeLambda = make.Lambda(args, lambdaBody);
 469             attr.preFlow(speculativeLambda);
 470             flow.analyzeLambda(env, speculativeLambda, make, false);
 471             return speculativeLambda;
 472         } finally {
 473             localEnv.info.scope.leave();
 474         }
 475     }
 476 
 477     /**
 478      * Routine that performs speculative type-checking; the input AST node is
 479      * cloned (to avoid side-effects cause by Attr) and compiler state is
 480      * restored after type-checking. All diagnostics (but critical ones) are
 481      * disabled during speculative type-checking.
 482      */
 483     JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 484         return attribSpeculative(tree, env, resultInfo, treeCopier,
<span class="line-modified"> 485                 (newTree)-&gt;new DeferredAttrDiagHandler(log, newTree), null);</span>
 486     }
 487 
 488     JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, LocalCacheContext localCache) {
 489         return attribSpeculative(tree, env, resultInfo, treeCopier,
<span class="line-modified"> 490                 (newTree)-&gt;new DeferredAttrDiagHandler(log, newTree), localCache);</span>
 491     }
 492 
 493     &lt;Z&gt; JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, TreeCopier&lt;Z&gt; deferredCopier,
<span class="line-modified"> 494                                  Function&lt;JCTree, DeferredDiagnosticHandler&gt; diagHandlerCreator,</span>
 495                                  LocalCacheContext localCache) {
 496         final JCTree newTree = deferredCopier.copy(tree);
<span class="line-modified"> 497         Env&lt;AttrContext&gt; speculativeEnv = env.dup(newTree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));</span>
<span class="line-modified"> 498         speculativeEnv.info.isSpeculative = true;</span>
<span class="line-modified"> 499         Log.DeferredDiagnosticHandler deferredDiagnosticHandler = diagHandlerCreator.apply(newTree);</span>
















 500         try {
<span class="line-modified"> 501             attr.attribTree(newTree, speculativeEnv, resultInfo);</span>
<span class="line-modified"> 502             return newTree;</span>
 503         } finally {
<span class="line-modified"> 504             new UnenterScanner(env.toplevel.modle).scan(newTree);</span>



 505             log.popDiagnosticHandler(deferredDiagnosticHandler);
 506             if (localCache != null) {
 507                 localCache.leave();
 508             }
 509         }
 510     }
 511     //where
<span class="line-removed"> 512 </span>
<span class="line-removed"> 513         class UnenterScanner extends TreeScanner {</span>
<span class="line-removed"> 514             private final ModuleSymbol msym;</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516             public UnenterScanner(ModuleSymbol msym) {</span>
<span class="line-removed"> 517                 this.msym = msym;</span>
<span class="line-removed"> 518             }</span>
<span class="line-removed"> 519 </span>
<span class="line-removed"> 520             @Override</span>
<span class="line-removed"> 521             public void visitClassDef(JCClassDecl tree) {</span>
<span class="line-removed"> 522                 ClassSymbol csym = tree.sym;</span>
<span class="line-removed"> 523                 //if something went wrong during method applicability check</span>
<span class="line-removed"> 524                 //it is possible that nested expressions inside argument expression</span>
<span class="line-removed"> 525                 //are left unchecked - in such cases there&#39;s nothing to clean up.</span>
<span class="line-removed"> 526                 if (csym == null) return;</span>
<span class="line-removed"> 527                 typeEnvs.remove(csym);</span>
<span class="line-removed"> 528                 chk.removeCompiled(csym);</span>
<span class="line-removed"> 529                 chk.clearLocalClassNameIndexes(csym);</span>
<span class="line-removed"> 530                 syms.removeClass(msym, csym.flatname);</span>
<span class="line-removed"> 531                 super.visitClassDef(tree);</span>
<span class="line-removed"> 532             }</span>
<span class="line-removed"> 533         }</span>
<span class="line-removed"> 534 </span>
 535         static class DeferredAttrDiagHandler extends Log.DeferredDiagnosticHandler {
 536 
 537             static class PosScanner extends TreeScanner {
 538                 DiagnosticPosition pos;
 539                 boolean found = false;
 540 
 541                 PosScanner(DiagnosticPosition pos) {
 542                     this.pos = pos;
 543                 }
 544 
 545                 @Override
 546                 public void scan(JCTree tree) {
 547                     if (tree != null &amp;&amp;
 548                             tree.pos() == pos) {
 549                         found = true;
 550                     }
 551                     super.scan(tree);
 552                 }
 553             }
 554 
</pre>
<hr />
<pre>
 630                         deferredAttrNodes.remove(deferredAttrNode);
 631                         progress = true;
 632                     }
 633                 }
 634                 if (!progress) {
 635                     if (insideOverloadPhase()) {
 636                         for (DeferredAttrNode deferredNode: deferredAttrNodes) {
 637                             deferredNode.dt.tree.type = Type.noType;
 638                         }
 639                         return;
 640                     }
 641                     //remove all variables that have already been instantiated
 642                     //from the list of stuck variables
 643                     try {
 644                         //find stuck expression to unstuck
 645                         DeferredAttrNode toUnstuck = pickDeferredNode();
 646                         inferenceContext.solveAny(List.from(toUnstuck.deferredStuckPolicy.stuckVars()), warn);
 647                         inferenceContext.notifyChange();
 648                     } catch (Infer.GraphStrategy.NodeNotFoundException ex) {
 649                         //this means that we are in speculative mode and the
<span class="line-modified"> 650                         //set of contraints are too tight for progess to be made.</span>
 651                         //Just leave the remaining expressions as stuck.
 652                         break;
 653                     }
 654                 }
 655             }
 656         }
 657 
 658         public boolean insideOverloadPhase() {
 659             DeferredAttrContext dac = this;
 660             if (dac == emptyDeferredAttrContext) {
 661                 return false;
 662             }
 663             if (dac.mode == AttrMode.SPECULATIVE) {
 664                 return true;
 665             }
 666             return dac.parent.insideOverloadPhase();
 667         }
 668 
 669         /**
 670          * Pick the deferred node to be unstuck. First, deferred nodes are organized into a graph
</pre>
<hr />
<pre>
1144     /**
1145      * A tree scanner suitable for visiting the target-type dependent nodes nested
1146      * within a lambda expression body.
1147      */
1148     static class LambdaReturnScanner extends FilterScanner {
1149 
1150         LambdaReturnScanner() {
1151             super(EnumSet.of(BLOCK, CASE, CATCH, DOLOOP, FOREACHLOOP,
1152                     FORLOOP, IF, RETURN, SYNCHRONIZED, SWITCH, TRY, WHILELOOP));
1153         }
1154     }
1155 
1156     /**
1157      * A tree scanner suitable for visiting the target-type dependent nodes nested
1158      * within a switch expression body.
1159      */
1160     static class SwitchExpressionScanner extends FilterScanner {
1161 
1162         SwitchExpressionScanner() {
1163             super(EnumSet.of(BLOCK, CASE, CATCH, DOLOOP, FOREACHLOOP,
<span class="line-modified">1164                     FORLOOP, IF, BREAK, SYNCHRONIZED, SWITCH, TRY, WHILELOOP));</span>
1165         }
1166     }
1167 
1168     /**
1169      * This visitor is used to check that structural expressions conform
1170      * to their target - this step is required as inference could end up
1171      * inferring types that make some of the nested expressions incompatible
1172      * with their corresponding instantiated target
1173      */
1174     class CheckStuckPolicy extends PolyScanner implements DeferredStuckPolicy, Infer.FreeTypeListener {
1175 
1176         Type pt;
1177         InferenceContext inferenceContext;
1178         Set&lt;Type&gt; stuckVars = new LinkedHashSet&lt;&gt;();
1179         Set&lt;Type&gt; depVars = new LinkedHashSet&lt;&gt;();
1180 
1181         @Override
1182         public boolean isStuck() {
1183             return !stuckVars.isEmpty();
1184         }
</pre>
<hr />
<pre>
1293         public OverloadStuckPolicy(ResultInfo resultInfo, DeferredType dt) {
1294             super(resultInfo, dt);
1295         }
1296 
1297         @Override
1298         public void visitLambda(JCLambda tree) {
1299             super.visitLambda(tree);
1300             if (tree.paramKind == JCLambda.ParameterKind.IMPLICIT) {
1301                 stuck = true;
1302             }
1303         }
1304 
1305         @Override
1306         public void visitReference(JCMemberReference tree) {
1307             super.visitReference(tree);
1308             if (tree.getOverloadKind() != JCMemberReference.OverloadKind.UNOVERLOADED) {
1309                 stuck = true;
1310             }
1311         }
1312     }






















1313 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  29 import com.sun.source.tree.NewClassTree;
  30 import com.sun.tools.javac.code.*;
  31 import com.sun.tools.javac.code.Type.ErrorType;
  32 import com.sun.tools.javac.code.Type.MethodType;
  33 import com.sun.tools.javac.code.Type.StructuralTypeMapping;
  34 import com.sun.tools.javac.code.Types.TypeMapping;
  35 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  36 import com.sun.tools.javac.comp.Infer.GraphSolver.InferenceGraph;
  37 import com.sun.tools.javac.comp.Resolve.ResolveError;
  38 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  39 import com.sun.tools.javac.tree.*;
  40 import com.sun.tools.javac.util.*;
  41 import com.sun.tools.javac.util.DefinedBy.Api;
  42 import com.sun.tools.javac.util.GraphUtils.DependencyKind;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;

  44 import com.sun.tools.javac.comp.Attr.ResultInfo;
  45 import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;
  46 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  47 import com.sun.tools.javac.tree.JCTree.*;
  48 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  49 import com.sun.tools.javac.util.Log.DeferredDiagnosticHandler;
<span class="line-added">  50 import com.sun.tools.javac.util.Log.DiagnosticHandler;</span>
  51 
  52 import java.util.ArrayList;
  53 import java.util.Collection;
  54 import java.util.Collections;
  55 import java.util.EnumSet;
  56 import java.util.HashSet;
  57 import java.util.LinkedHashSet;
  58 import java.util.Map;
  59 import java.util.Set;
  60 import java.util.WeakHashMap;
<span class="line-modified">  61 import java.util.function.Supplier;</span>
  62 
  63 import com.sun.source.tree.MemberReferenceTree;
  64 import com.sun.tools.javac.code.Type;
  65 import com.sun.tools.javac.tree.JCTree.JCMemberReference.OverloadKind;
  66 
  67 import static com.sun.tools.javac.code.TypeTag.*;
<span class="line-added">  68 import com.sun.tools.javac.comp.Annotate.Queues;</span>
  69 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  70 
  71 /**
  72  * This is an helper class that is used to perform deferred type-analysis.
  73  * Each time a poly expression occurs in argument position, javac attributes it
  74  * with a temporary &#39;deferred type&#39; that is checked (possibly multiple times)
  75  * against an expected formal type.
  76  *
  77  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  78  *  If you write code that depends on this, you do so at your own risk.
  79  *  This code and its internal interfaces are subject to change or
  80  *  deletion without notice.&lt;/b&gt;
  81  */
  82 public class DeferredAttr extends JCTree.Visitor {
  83     protected static final Context.Key&lt;DeferredAttr&gt; deferredAttrKey = new Context.Key&lt;&gt;();
  84 
<span class="line-added">  85     final Annotate annotate;</span>
  86     final Attr attr;
  87     final ArgumentAttr argumentAttr;
  88     final Check chk;
  89     final JCDiagnostic.Factory diags;
  90     final Enter enter;
  91     final Infer infer;
  92     final Resolve rs;
  93     final Log log;
  94     final Symtab syms;
  95     final TreeMaker make;
  96     final TreeCopier&lt;Void&gt; treeCopier;
  97     final TypeMapping&lt;Void&gt; deferredCopier;
  98     final Types types;
  99     final Flow flow;
 100     final Names names;
 101     final TypeEnvs typeEnvs;
<span class="line-added"> 102     final DeferredCompletionFailureHandler dcfh;</span>
 103 
 104     public static DeferredAttr instance(Context context) {
 105         DeferredAttr instance = context.get(deferredAttrKey);
 106         if (instance == null)
 107             instance = new DeferredAttr(context);
 108         return instance;
 109     }
 110 
 111     protected DeferredAttr(Context context) {
 112         context.put(deferredAttrKey, this);
<span class="line-added"> 113         annotate = Annotate.instance(context);</span>
 114         attr = Attr.instance(context);
 115         argumentAttr = ArgumentAttr.instance(context);
 116         chk = Check.instance(context);
 117         diags = JCDiagnostic.Factory.instance(context);
 118         enter = Enter.instance(context);
 119         infer = Infer.instance(context);
 120         rs = Resolve.instance(context);
 121         log = Log.instance(context);
 122         syms = Symtab.instance(context);
 123         make = TreeMaker.instance(context);
 124         types = Types.instance(context);
 125         flow = Flow.instance(context);
 126         names = Names.instance(context);
 127         stuckTree = make.Ident(names.empty).setType(Type.stuckType);
 128         typeEnvs = TypeEnvs.instance(context);
<span class="line-added"> 129         dcfh = DeferredCompletionFailureHandler.instance(context);</span>
 130         emptyDeferredAttrContext =
 131             new DeferredAttrContext(AttrMode.CHECK, null, MethodResolutionPhase.BOX, infer.emptyContext, null, null) {
 132                 @Override
 133                 void addDeferredAttrNode(DeferredType dt, ResultInfo ri, DeferredStuckPolicy deferredStuckPolicy) {
 134                     Assert.error(&quot;Empty deferred context!&quot;);
 135                 }
 136                 @Override
 137                 void complete() {
 138                     Assert.error(&quot;Empty deferred context!&quot;);
 139                 }
 140 
 141                 @Override
 142                 public String toString() {
 143                     return &quot;Empty deferred context!&quot;;
 144                 }
 145             };
 146 
 147         // For speculative attribution, skip the class definition in &lt;&gt;.
 148         treeCopier =
 149             new TreeCopier&lt;Void&gt;(make) {
</pre>
<hr />
<pre>
 470             if (lambdaBody.hasTag(Tag.RETURN)) {
 471                 lambdaBody = ((JCReturn)lambdaBody).expr;
 472             }
 473             JCLambda speculativeLambda = make.Lambda(args, lambdaBody);
 474             attr.preFlow(speculativeLambda);
 475             flow.analyzeLambda(env, speculativeLambda, make, false);
 476             return speculativeLambda;
 477         } finally {
 478             localEnv.info.scope.leave();
 479         }
 480     }
 481 
 482     /**
 483      * Routine that performs speculative type-checking; the input AST node is
 484      * cloned (to avoid side-effects cause by Attr) and compiler state is
 485      * restored after type-checking. All diagnostics (but critical ones) are
 486      * disabled during speculative type-checking.
 487      */
 488     JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 489         return attribSpeculative(tree, env, resultInfo, treeCopier,
<span class="line-modified"> 490                 null, AttributionMode.SPECULATIVE, null);</span>
 491     }
 492 
 493     JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, LocalCacheContext localCache) {
 494         return attribSpeculative(tree, env, resultInfo, treeCopier,
<span class="line-modified"> 495                 null, AttributionMode.SPECULATIVE, localCache);</span>
 496     }
 497 
 498     &lt;Z&gt; JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo, TreeCopier&lt;Z&gt; deferredCopier,
<span class="line-modified"> 499                                  Supplier&lt;DiagnosticHandler&gt; diagHandlerCreator, AttributionMode attributionMode,</span>
 500                                  LocalCacheContext localCache) {
 501         final JCTree newTree = deferredCopier.copy(tree);
<span class="line-modified"> 502         return attribSpeculative(newTree, env, resultInfo, diagHandlerCreator, attributionMode, localCache);</span>
<span class="line-modified"> 503     }</span>
<span class="line-modified"> 504 </span>
<span class="line-added"> 505     /**</span>
<span class="line-added"> 506      * Attribute the given tree, mostly reverting side-effects applied to shared</span>
<span class="line-added"> 507      * compiler state. Exceptions include the ArgumentAttr.argumentTypeCache,</span>
<span class="line-added"> 508      * changes to which may be preserved if localCache is null and errors reported</span>
<span class="line-added"> 509      * outside of the speculatively attributed tree.</span>
<span class="line-added"> 510      */</span>
<span class="line-added"> 511     &lt;Z&gt; JCTree attribSpeculative(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo,</span>
<span class="line-added"> 512                               Supplier&lt;DiagnosticHandler&gt; diagHandlerCreator, AttributionMode attributionMode,</span>
<span class="line-added"> 513                               LocalCacheContext localCache) {</span>
<span class="line-added"> 514         Env&lt;AttrContext&gt; speculativeEnv = env.dup(tree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));</span>
<span class="line-added"> 515         speculativeEnv.info.attributionMode = attributionMode;</span>
<span class="line-added"> 516         Log.DiagnosticHandler deferredDiagnosticHandler = diagHandlerCreator != null ? diagHandlerCreator.get() : new DeferredAttrDiagHandler(log, tree);</span>
<span class="line-added"> 517         DeferredCompletionFailureHandler.Handler prevCFHandler = dcfh.setHandler(dcfh.speculativeCodeHandler);</span>
<span class="line-added"> 518         Queues prevQueues = annotate.setQueues(new Queues());</span>
<span class="line-added"> 519         int nwarnings = log.nwarnings;</span>
<span class="line-added"> 520         log.nwarnings = 0;</span>
 521         try {
<span class="line-modified"> 522             attr.attribTree(tree, speculativeEnv, resultInfo);</span>
<span class="line-modified"> 523             return tree;</span>
 524         } finally {
<span class="line-modified"> 525             annotate.setQueues(prevQueues);</span>
<span class="line-added"> 526             dcfh.setHandler(prevCFHandler);</span>
<span class="line-added"> 527             log.nwarnings += nwarnings;</span>
<span class="line-added"> 528             enter.unenter(env.toplevel, tree);</span>
 529             log.popDiagnosticHandler(deferredDiagnosticHandler);
 530             if (localCache != null) {
 531                 localCache.leave();
 532             }
 533         }
 534     }
 535     //where























 536         static class DeferredAttrDiagHandler extends Log.DeferredDiagnosticHandler {
 537 
 538             static class PosScanner extends TreeScanner {
 539                 DiagnosticPosition pos;
 540                 boolean found = false;
 541 
 542                 PosScanner(DiagnosticPosition pos) {
 543                     this.pos = pos;
 544                 }
 545 
 546                 @Override
 547                 public void scan(JCTree tree) {
 548                     if (tree != null &amp;&amp;
 549                             tree.pos() == pos) {
 550                         found = true;
 551                     }
 552                     super.scan(tree);
 553                 }
 554             }
 555 
</pre>
<hr />
<pre>
 631                         deferredAttrNodes.remove(deferredAttrNode);
 632                         progress = true;
 633                     }
 634                 }
 635                 if (!progress) {
 636                     if (insideOverloadPhase()) {
 637                         for (DeferredAttrNode deferredNode: deferredAttrNodes) {
 638                             deferredNode.dt.tree.type = Type.noType;
 639                         }
 640                         return;
 641                     }
 642                     //remove all variables that have already been instantiated
 643                     //from the list of stuck variables
 644                     try {
 645                         //find stuck expression to unstuck
 646                         DeferredAttrNode toUnstuck = pickDeferredNode();
 647                         inferenceContext.solveAny(List.from(toUnstuck.deferredStuckPolicy.stuckVars()), warn);
 648                         inferenceContext.notifyChange();
 649                     } catch (Infer.GraphStrategy.NodeNotFoundException ex) {
 650                         //this means that we are in speculative mode and the
<span class="line-modified"> 651                         //set of constraints are too tight for progress to be made.</span>
 652                         //Just leave the remaining expressions as stuck.
 653                         break;
 654                     }
 655                 }
 656             }
 657         }
 658 
 659         public boolean insideOverloadPhase() {
 660             DeferredAttrContext dac = this;
 661             if (dac == emptyDeferredAttrContext) {
 662                 return false;
 663             }
 664             if (dac.mode == AttrMode.SPECULATIVE) {
 665                 return true;
 666             }
 667             return dac.parent.insideOverloadPhase();
 668         }
 669 
 670         /**
 671          * Pick the deferred node to be unstuck. First, deferred nodes are organized into a graph
</pre>
<hr />
<pre>
1145     /**
1146      * A tree scanner suitable for visiting the target-type dependent nodes nested
1147      * within a lambda expression body.
1148      */
1149     static class LambdaReturnScanner extends FilterScanner {
1150 
1151         LambdaReturnScanner() {
1152             super(EnumSet.of(BLOCK, CASE, CATCH, DOLOOP, FOREACHLOOP,
1153                     FORLOOP, IF, RETURN, SYNCHRONIZED, SWITCH, TRY, WHILELOOP));
1154         }
1155     }
1156 
1157     /**
1158      * A tree scanner suitable for visiting the target-type dependent nodes nested
1159      * within a switch expression body.
1160      */
1161     static class SwitchExpressionScanner extends FilterScanner {
1162 
1163         SwitchExpressionScanner() {
1164             super(EnumSet.of(BLOCK, CASE, CATCH, DOLOOP, FOREACHLOOP,
<span class="line-modified">1165                     FORLOOP, IF, SYNCHRONIZED, SWITCH, TRY, WHILELOOP, YIELD));</span>
1166         }
1167     }
1168 
1169     /**
1170      * This visitor is used to check that structural expressions conform
1171      * to their target - this step is required as inference could end up
1172      * inferring types that make some of the nested expressions incompatible
1173      * with their corresponding instantiated target
1174      */
1175     class CheckStuckPolicy extends PolyScanner implements DeferredStuckPolicy, Infer.FreeTypeListener {
1176 
1177         Type pt;
1178         InferenceContext inferenceContext;
1179         Set&lt;Type&gt; stuckVars = new LinkedHashSet&lt;&gt;();
1180         Set&lt;Type&gt; depVars = new LinkedHashSet&lt;&gt;();
1181 
1182         @Override
1183         public boolean isStuck() {
1184             return !stuckVars.isEmpty();
1185         }
</pre>
<hr />
<pre>
1294         public OverloadStuckPolicy(ResultInfo resultInfo, DeferredType dt) {
1295             super(resultInfo, dt);
1296         }
1297 
1298         @Override
1299         public void visitLambda(JCLambda tree) {
1300             super.visitLambda(tree);
1301             if (tree.paramKind == JCLambda.ParameterKind.IMPLICIT) {
1302                 stuck = true;
1303             }
1304         }
1305 
1306         @Override
1307         public void visitReference(JCMemberReference tree) {
1308             super.visitReference(tree);
1309             if (tree.getOverloadKind() != JCMemberReference.OverloadKind.UNOVERLOADED) {
1310                 stuck = true;
1311             }
1312         }
1313     }
<span class="line-added">1314 </span>
<span class="line-added">1315     /**</span>
<span class="line-added">1316      * Mode of attribution (used in AttrContext).</span>
<span class="line-added">1317      */</span>
<span class="line-added">1318     enum AttributionMode {</span>
<span class="line-added">1319         /**Normal, non-speculative, attribution.*/</span>
<span class="line-added">1320         FULL(false),</span>
<span class="line-added">1321         /**Speculative attribution on behalf of an Analyzer.*/</span>
<span class="line-added">1322         ANALYZER(true),</span>
<span class="line-added">1323         /**Speculative attribution.*/</span>
<span class="line-added">1324         SPECULATIVE(true);</span>
<span class="line-added">1325 </span>
<span class="line-added">1326         AttributionMode(boolean isSpeculative) {</span>
<span class="line-added">1327             this.isSpeculative = isSpeculative;</span>
<span class="line-added">1328         }</span>
<span class="line-added">1329 </span>
<span class="line-added">1330         boolean isSpeculative() {</span>
<span class="line-added">1331             return isSpeculative;</span>
<span class="line-added">1332         }</span>
<span class="line-added">1333 </span>
<span class="line-added">1334         final boolean isSpeculative;</span>
<span class="line-added">1335     }</span>
1336 }
</pre>
</td>
</tr>
</table>
<center><a href="CompileStates.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Enter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
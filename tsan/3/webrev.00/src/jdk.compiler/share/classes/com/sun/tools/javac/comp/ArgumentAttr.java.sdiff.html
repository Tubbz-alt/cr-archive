<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/ArgumentAttr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Annotate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Attr.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/ArgumentAttr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Symbol;
 30 import com.sun.tools.javac.code.Symtab;
 31 import com.sun.tools.javac.code.Type;
 32 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
 33 import com.sun.tools.javac.comp.Attr.ResultInfo;
 34 import com.sun.tools.javac.comp.Attr.TargetInfo;
 35 import com.sun.tools.javac.comp.Check.CheckContext;
 36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
 37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
 38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
 39 import com.sun.tools.javac.comp.DeferredAttr.DeferredTypeCompleter;
 40 import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;
 41 import com.sun.tools.javac.comp.DeferredAttr.SwitchExpressionScanner;
 42 import com.sun.tools.javac.comp.Infer.PartiallyInferredMethodType;
 43 import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;
 44 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
 45 import com.sun.tools.javac.tree.JCTree;
<span class="line-removed"> 46 import com.sun.tools.javac.tree.JCTree.JCBreak;</span>
 47 import com.sun.tools.javac.tree.JCTree.JCConditional;
 48 import com.sun.tools.javac.tree.JCTree.JCExpression;
 49 import com.sun.tools.javac.tree.JCTree.JCLambda;
 50 import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;
 51 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
 52 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 53 import com.sun.tools.javac.tree.JCTree.JCNewClass;
 54 import com.sun.tools.javac.tree.JCTree.JCParens;
 55 import com.sun.tools.javac.tree.JCTree.JCReturn;
 56 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;
 57 import com.sun.tools.javac.tree.TreeCopier;
 58 import com.sun.tools.javac.tree.TreeInfo;
 59 import com.sun.tools.javac.util.Assert;
 60 import com.sun.tools.javac.util.Context;
 61 import com.sun.tools.javac.util.DiagnosticSource;
 62 import com.sun.tools.javac.util.JCDiagnostic;
 63 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 64 import com.sun.tools.javac.util.List;
 65 import com.sun.tools.javac.util.ListBuffer;
 66 import com.sun.tools.javac.util.Log;
 67 
 68 import java.util.HashMap;
 69 import java.util.LinkedHashMap;
 70 import java.util.Map;
 71 import java.util.Optional;
 72 import java.util.function.Function;
 73 import java.util.function.Supplier;
 74 
 75 import static com.sun.tools.javac.code.TypeTag.ARRAY;
 76 import static com.sun.tools.javac.code.TypeTag.DEFERRED;
 77 import static com.sun.tools.javac.code.TypeTag.FORALL;
 78 import static com.sun.tools.javac.code.TypeTag.METHOD;
 79 import static com.sun.tools.javac.code.TypeTag.VOID;

 80 
 81 /**
 82  * This class performs attribution of method/constructor arguments when target-typing is enabled
 83  * (source &gt;= 8); for each argument that is potentially a poly expression, this class builds
 84  * a rich representation (see {@link ArgumentType} which can then be used for performing fast overload
 85  * checks without requiring multiple attribution passes over the same code.
 86  *
 87  * The attribution strategy for a given method/constructor argument A is as follows:
 88  *
 89  * - if A is potentially a poly expression (i.e. diamond instance creation expression), a speculative
 90  * pass over A is performed; the results of such speculative attribution are then saved in a special
 91  * type, so that enclosing overload resolution can be carried by simply checking compatibility against the
 92  * type determined during this speculative pass.
 93  *
<span class="line-modified"> 94  * - if A is a standalone expression, regular atributtion takes place.</span>
 95  *
 96  * To minimize the speculative work, a cache is used, so that already computed argument types
 97  * associated with a given unique source location are never recomputed multiple times.
 98  */
 99 public class ArgumentAttr extends JCTree.Visitor {
100 
101     protected static final Context.Key&lt;ArgumentAttr&gt; methodAttrKey = new Context.Key&lt;&gt;();
102 
103     private final DeferredAttr deferredAttr;
104     private final JCDiagnostic.Factory diags;
105     private final Attr attr;
106     private final Symtab syms;
107     private final Log log;
108 
109     /** Attribution environment to be used. */
110     private Env&lt;AttrContext&gt; env;
111 
112     /** Result of method attribution. */
113     Type result;
114 
<span class="line-modified">115     /** Cache for argument types; behavior is influences by the currrently selected cache policy. */</span>
116     Map&lt;UniquePos, ArgumentType&lt;?&gt;&gt; argumentTypeCache = new LinkedHashMap&lt;&gt;();
117 
118     public static ArgumentAttr instance(Context context) {
119         ArgumentAttr instance = context.get(methodAttrKey);
120         if (instance == null)
121             instance = new ArgumentAttr(context);
122         return instance;
123     }
124 
125     protected ArgumentAttr(Context context) {
126         context.put(methodAttrKey, this);
127         deferredAttr = DeferredAttr.instance(context);
128         diags = JCDiagnostic.Factory.instance(context);
129         attr = Attr.instance(context);
130         syms = Symtab.instance(context);
131         log = Log.instance(context);
132     }
133 
134     /**
135      * Set the results of method attribution.
136      */
137     void setResult(JCExpression tree, Type type) {
138         result = type;
<span class="line-modified">139         if (env.info.isSpeculative) {</span>
140             //if we are in a speculative branch we can save the type in the tree itself
141             //as there&#39;s no risk of polluting the original tree.
142             tree.type = result;
143         }
144     }
145 
146     /**
147      * Checks a type in the speculative tree against a given result; the type can be either a plain
148      * type or an argument type,in which case a more complex check is required.
149      */
150     Type checkSpeculative(JCTree expr, ResultInfo resultInfo) {
151         return checkSpeculative(expr, expr.type, resultInfo);
152     }
153 
154     /**
155      * Checks a type in the speculative tree against a given result; the type can be either a plain
156      * type or an argument type,in which case a more complex check is required.
157      */
158     Type checkSpeculative(DiagnosticPosition pos, Type t, ResultInfo resultInfo) {
159         if (t.hasTag(DEFERRED)) {
</pre>
<hr />
<pre>
348             deferredAttr.super(tree, env);
349             this.speculativeTree = speculativeTree;
350             this.speculativeTypes = speculativeTypes;
351         }
352 
353         @Override
354         final DeferredTypeCompleter completer() {
355             return this;
356         }
357 
358         @Override
359         final public Type complete(DeferredType dt, ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {
360             Assert.check(dt == this);
361             if (deferredAttrContext.mode == AttrMode.SPECULATIVE) {
362                 Type t = (resultInfo.pt == Type.recoveryType) ?
363                         deferredAttr.basicCompleter.complete(dt, resultInfo, deferredAttrContext) :
364                         overloadCheck(resultInfo, deferredAttrContext);
365                 speculativeTypes.put(resultInfo, t);
366                 return t;
367             } else {
<span class="line-modified">368                 if (!env.info.isSpeculative) {</span>
369                     argumentTypeCache.remove(new UniquePos(dt.tree));
370                 }
371                 return deferredAttr.basicCompleter.complete(dt, resultInfo, deferredAttrContext);
372             }
373         }
374 
375         @Override
376         Type speculativeType(Symbol msym, MethodResolutionPhase phase) {
377             if (notPertinentToApplicability.contains(msym)) {
378                 return super.speculativeType(msym, phase);
379             } else {
380                 for (Map.Entry&lt;ResultInfo, Type&gt; _entry : speculativeTypes.entrySet()) {
381                     DeferredAttrContext deferredAttrContext = _entry.getKey().checkContext.deferredAttrContext();
382                     if (deferredAttrContext.phase == phase &amp;&amp; deferredAttrContext.msym == msym) {
383                         return _entry.getValue();
384                     }
385                 }
386                 return Type.noType;
387             }
388         }
</pre>
<hr />
<pre>
451                 return attr.types.createErrorType(resultInfo.pt);
452             } else {
453                 //poly
454                 checkSpeculative(speculativeTree.truepart, localInfo);
455                 checkSpeculative(speculativeTree.falsepart, localInfo);
456                 return localInfo.pt;
457             }
458         }
459 
460         @Override
461         ArgumentType&lt;JCConditional&gt; dup(JCConditional tree, Env&lt;AttrContext&gt; env) {
462             return new ConditionalType(tree, env, speculativeTree, speculativeTypes);
463         }
464     }
465 
466     /**
467      * Argument type for switch expressions.
468      */
469     class SwitchExpressionType extends ArgumentType&lt;JCSwitchExpression&gt; {
470         /** List of break expressions (lazily populated). */
<span class="line-modified">471         Optional&lt;List&lt;JCBreak&gt;&gt; breakExpressions = Optional.empty();</span>
472 
473         SwitchExpressionType(JCExpression tree, Env&lt;AttrContext&gt; env, JCSwitchExpression speculativeCond) {
474             this(tree, env, speculativeCond, new HashMap&lt;&gt;());
475         }
476 
477         SwitchExpressionType(JCExpression tree, Env&lt;AttrContext&gt; env, JCSwitchExpression speculativeCond, Map&lt;ResultInfo, Type&gt; speculativeTypes) {
478            super(tree, env, speculativeCond, speculativeTypes);
479         }
480 
481         @Override
482         Type overloadCheck(ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {
483             ResultInfo localInfo = resultInfo.dup(attr.conditionalContext(resultInfo.checkContext));
484             if (resultInfo.pt.hasTag(VOID)) {
485                 //this means we are returning a poly switch expression from void-compatible lambda expression
486                 resultInfo.checkContext.report(tree, attr.diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
487                 return attr.types.createErrorType(resultInfo.pt);
488             } else {
489                 //poly
<span class="line-modified">490                 for (JCBreak brk : breakExpressions()) {</span>
491                     checkSpeculative(brk.value, brk.value.type, resultInfo);
492                 }
493                 return localInfo.pt;
494             }
495         }
496 
497         /** Compute return expressions (if needed). */
<span class="line-modified">498         List&lt;JCBreak&gt; breakExpressions() {</span>
<span class="line-modified">499             return breakExpressions.orElseGet(() -&gt; {</span>
<span class="line-modified">500                 final List&lt;JCBreak&gt; res;</span>
<span class="line-modified">501                 ListBuffer&lt;JCBreak&gt; buf = new ListBuffer&lt;&gt;();</span>
502                 new SwitchExpressionScanner() {
503                     @Override
<span class="line-modified">504                     public void visitBreak(JCBreak tree) {</span>
505                         if (tree.target == speculativeTree)
506                             buf.add(tree);

507                     }
508                 }.scan(speculativeTree.cases);
509                 res = buf.toList();
<span class="line-modified">510                 breakExpressions = Optional.of(res);</span>
511                 return res;
512             });
513         }
514 
515         @Override
516         ArgumentType&lt;JCSwitchExpression&gt; dup(JCSwitchExpression tree, Env&lt;AttrContext&gt; env) {
517             return new SwitchExpressionType(tree, env, speculativeTree, speculativeTypes);
518         }
519     }
520 
521     /**
522      * Argument type for explicit lambdas.
523      */
524     class ExplicitLambdaType extends ArgumentType&lt;JCLambda&gt; {
525 
526         /** List of argument types (lazily populated). */
527         Optional&lt;List&lt;Type&gt;&gt; argtypes = Optional.empty();
528 
529         /** List of return expressions (lazily populated). */
530         Optional&lt;List&lt;JCReturn&gt;&gt; returnExpressions = Optional.empty();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Symbol;
 30 import com.sun.tools.javac.code.Symtab;
 31 import com.sun.tools.javac.code.Type;
 32 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
 33 import com.sun.tools.javac.comp.Attr.ResultInfo;
 34 import com.sun.tools.javac.comp.Attr.TargetInfo;
 35 import com.sun.tools.javac.comp.Check.CheckContext;
 36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
 37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
 38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
 39 import com.sun.tools.javac.comp.DeferredAttr.DeferredTypeCompleter;
 40 import com.sun.tools.javac.comp.DeferredAttr.LambdaReturnScanner;
 41 import com.sun.tools.javac.comp.DeferredAttr.SwitchExpressionScanner;
 42 import com.sun.tools.javac.comp.Infer.PartiallyInferredMethodType;
 43 import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;
 44 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
 45 import com.sun.tools.javac.tree.JCTree;

 46 import com.sun.tools.javac.tree.JCTree.JCConditional;
 47 import com.sun.tools.javac.tree.JCTree.JCExpression;
 48 import com.sun.tools.javac.tree.JCTree.JCLambda;
 49 import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;
 50 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
 51 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 52 import com.sun.tools.javac.tree.JCTree.JCNewClass;
 53 import com.sun.tools.javac.tree.JCTree.JCParens;
 54 import com.sun.tools.javac.tree.JCTree.JCReturn;
 55 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;
 56 import com.sun.tools.javac.tree.TreeCopier;
 57 import com.sun.tools.javac.tree.TreeInfo;
 58 import com.sun.tools.javac.util.Assert;
 59 import com.sun.tools.javac.util.Context;
 60 import com.sun.tools.javac.util.DiagnosticSource;
 61 import com.sun.tools.javac.util.JCDiagnostic;
 62 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 63 import com.sun.tools.javac.util.List;
 64 import com.sun.tools.javac.util.ListBuffer;
 65 import com.sun.tools.javac.util.Log;
 66 
 67 import java.util.HashMap;
 68 import java.util.LinkedHashMap;
 69 import java.util.Map;
 70 import java.util.Optional;
 71 import java.util.function.Function;
 72 import java.util.function.Supplier;
 73 
 74 import static com.sun.tools.javac.code.TypeTag.ARRAY;
 75 import static com.sun.tools.javac.code.TypeTag.DEFERRED;
 76 import static com.sun.tools.javac.code.TypeTag.FORALL;
 77 import static com.sun.tools.javac.code.TypeTag.METHOD;
 78 import static com.sun.tools.javac.code.TypeTag.VOID;
<span class="line-added"> 79 import com.sun.tools.javac.tree.JCTree.JCYield;</span>
 80 
 81 /**
 82  * This class performs attribution of method/constructor arguments when target-typing is enabled
 83  * (source &gt;= 8); for each argument that is potentially a poly expression, this class builds
 84  * a rich representation (see {@link ArgumentType} which can then be used for performing fast overload
 85  * checks without requiring multiple attribution passes over the same code.
 86  *
 87  * The attribution strategy for a given method/constructor argument A is as follows:
 88  *
 89  * - if A is potentially a poly expression (i.e. diamond instance creation expression), a speculative
 90  * pass over A is performed; the results of such speculative attribution are then saved in a special
 91  * type, so that enclosing overload resolution can be carried by simply checking compatibility against the
 92  * type determined during this speculative pass.
 93  *
<span class="line-modified"> 94  * - if A is a standalone expression, regular attribution takes place.</span>
 95  *
 96  * To minimize the speculative work, a cache is used, so that already computed argument types
 97  * associated with a given unique source location are never recomputed multiple times.
 98  */
 99 public class ArgumentAttr extends JCTree.Visitor {
100 
101     protected static final Context.Key&lt;ArgumentAttr&gt; methodAttrKey = new Context.Key&lt;&gt;();
102 
103     private final DeferredAttr deferredAttr;
104     private final JCDiagnostic.Factory diags;
105     private final Attr attr;
106     private final Symtab syms;
107     private final Log log;
108 
109     /** Attribution environment to be used. */
110     private Env&lt;AttrContext&gt; env;
111 
112     /** Result of method attribution. */
113     Type result;
114 
<span class="line-modified">115     /** Cache for argument types; behavior is influenced by the currently selected cache policy. */</span>
116     Map&lt;UniquePos, ArgumentType&lt;?&gt;&gt; argumentTypeCache = new LinkedHashMap&lt;&gt;();
117 
118     public static ArgumentAttr instance(Context context) {
119         ArgumentAttr instance = context.get(methodAttrKey);
120         if (instance == null)
121             instance = new ArgumentAttr(context);
122         return instance;
123     }
124 
125     protected ArgumentAttr(Context context) {
126         context.put(methodAttrKey, this);
127         deferredAttr = DeferredAttr.instance(context);
128         diags = JCDiagnostic.Factory.instance(context);
129         attr = Attr.instance(context);
130         syms = Symtab.instance(context);
131         log = Log.instance(context);
132     }
133 
134     /**
135      * Set the results of method attribution.
136      */
137     void setResult(JCExpression tree, Type type) {
138         result = type;
<span class="line-modified">139         if (env.info.attributionMode == DeferredAttr.AttributionMode.SPECULATIVE) {</span>
140             //if we are in a speculative branch we can save the type in the tree itself
141             //as there&#39;s no risk of polluting the original tree.
142             tree.type = result;
143         }
144     }
145 
146     /**
147      * Checks a type in the speculative tree against a given result; the type can be either a plain
148      * type or an argument type,in which case a more complex check is required.
149      */
150     Type checkSpeculative(JCTree expr, ResultInfo resultInfo) {
151         return checkSpeculative(expr, expr.type, resultInfo);
152     }
153 
154     /**
155      * Checks a type in the speculative tree against a given result; the type can be either a plain
156      * type or an argument type,in which case a more complex check is required.
157      */
158     Type checkSpeculative(DiagnosticPosition pos, Type t, ResultInfo resultInfo) {
159         if (t.hasTag(DEFERRED)) {
</pre>
<hr />
<pre>
348             deferredAttr.super(tree, env);
349             this.speculativeTree = speculativeTree;
350             this.speculativeTypes = speculativeTypes;
351         }
352 
353         @Override
354         final DeferredTypeCompleter completer() {
355             return this;
356         }
357 
358         @Override
359         final public Type complete(DeferredType dt, ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {
360             Assert.check(dt == this);
361             if (deferredAttrContext.mode == AttrMode.SPECULATIVE) {
362                 Type t = (resultInfo.pt == Type.recoveryType) ?
363                         deferredAttr.basicCompleter.complete(dt, resultInfo, deferredAttrContext) :
364                         overloadCheck(resultInfo, deferredAttrContext);
365                 speculativeTypes.put(resultInfo, t);
366                 return t;
367             } else {
<span class="line-modified">368                 if (!env.info.attributionMode.isSpeculative) {</span>
369                     argumentTypeCache.remove(new UniquePos(dt.tree));
370                 }
371                 return deferredAttr.basicCompleter.complete(dt, resultInfo, deferredAttrContext);
372             }
373         }
374 
375         @Override
376         Type speculativeType(Symbol msym, MethodResolutionPhase phase) {
377             if (notPertinentToApplicability.contains(msym)) {
378                 return super.speculativeType(msym, phase);
379             } else {
380                 for (Map.Entry&lt;ResultInfo, Type&gt; _entry : speculativeTypes.entrySet()) {
381                     DeferredAttrContext deferredAttrContext = _entry.getKey().checkContext.deferredAttrContext();
382                     if (deferredAttrContext.phase == phase &amp;&amp; deferredAttrContext.msym == msym) {
383                         return _entry.getValue();
384                     }
385                 }
386                 return Type.noType;
387             }
388         }
</pre>
<hr />
<pre>
451                 return attr.types.createErrorType(resultInfo.pt);
452             } else {
453                 //poly
454                 checkSpeculative(speculativeTree.truepart, localInfo);
455                 checkSpeculative(speculativeTree.falsepart, localInfo);
456                 return localInfo.pt;
457             }
458         }
459 
460         @Override
461         ArgumentType&lt;JCConditional&gt; dup(JCConditional tree, Env&lt;AttrContext&gt; env) {
462             return new ConditionalType(tree, env, speculativeTree, speculativeTypes);
463         }
464     }
465 
466     /**
467      * Argument type for switch expressions.
468      */
469     class SwitchExpressionType extends ArgumentType&lt;JCSwitchExpression&gt; {
470         /** List of break expressions (lazily populated). */
<span class="line-modified">471         Optional&lt;List&lt;JCYield&gt;&gt; yieldExpressions = Optional.empty();</span>
472 
473         SwitchExpressionType(JCExpression tree, Env&lt;AttrContext&gt; env, JCSwitchExpression speculativeCond) {
474             this(tree, env, speculativeCond, new HashMap&lt;&gt;());
475         }
476 
477         SwitchExpressionType(JCExpression tree, Env&lt;AttrContext&gt; env, JCSwitchExpression speculativeCond, Map&lt;ResultInfo, Type&gt; speculativeTypes) {
478            super(tree, env, speculativeCond, speculativeTypes);
479         }
480 
481         @Override
482         Type overloadCheck(ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {
483             ResultInfo localInfo = resultInfo.dup(attr.conditionalContext(resultInfo.checkContext));
484             if (resultInfo.pt.hasTag(VOID)) {
485                 //this means we are returning a poly switch expression from void-compatible lambda expression
486                 resultInfo.checkContext.report(tree, attr.diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
487                 return attr.types.createErrorType(resultInfo.pt);
488             } else {
489                 //poly
<span class="line-modified">490                 for (JCYield brk : yieldExpressions()) {</span>
491                     checkSpeculative(brk.value, brk.value.type, resultInfo);
492                 }
493                 return localInfo.pt;
494             }
495         }
496 
497         /** Compute return expressions (if needed). */
<span class="line-modified">498         List&lt;JCYield&gt; yieldExpressions() {</span>
<span class="line-modified">499             return yieldExpressions.orElseGet(() -&gt; {</span>
<span class="line-modified">500                 final List&lt;JCYield&gt; res;</span>
<span class="line-modified">501                 ListBuffer&lt;JCYield&gt; buf = new ListBuffer&lt;&gt;();</span>
502                 new SwitchExpressionScanner() {
503                     @Override
<span class="line-modified">504                     public void visitYield(JCYield tree) {</span>
505                         if (tree.target == speculativeTree)
506                             buf.add(tree);
<span class="line-added">507                         super.visitYield(tree);</span>
508                     }
509                 }.scan(speculativeTree.cases);
510                 res = buf.toList();
<span class="line-modified">511                 yieldExpressions = Optional.of(res);</span>
512                 return res;
513             });
514         }
515 
516         @Override
517         ArgumentType&lt;JCSwitchExpression&gt; dup(JCSwitchExpression tree, Env&lt;AttrContext&gt; env) {
518             return new SwitchExpressionType(tree, env, speculativeTree, speculativeTypes);
519         }
520     }
521 
522     /**
523      * Argument type for explicit lambdas.
524      */
525     class ExplicitLambdaType extends ArgumentType&lt;JCLambda&gt; {
526 
527         /** List of argument types (lazily populated). */
528         Optional&lt;List&lt;Type&gt;&gt; argtypes = Optional.empty();
529 
530         /** List of return expressions (lazily populated). */
531         Optional&lt;List&lt;JCReturn&gt;&gt; returnExpressions = Optional.empty();
</pre>
</td>
</tr>
</table>
<center><a href="Annotate.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Attr.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
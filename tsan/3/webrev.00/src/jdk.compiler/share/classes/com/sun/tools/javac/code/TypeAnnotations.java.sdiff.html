<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/TypeAnnotations.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Type.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeMetadata.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/TypeAnnotations.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2015, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 183                         .reduce(AnnotationType.NONE, this::combineAnnotationType);
 184     }
 185 
 186     private AnnotationType combineAnnotationType(AnnotationType at1, AnnotationType at2) {
 187         if (at1 == AnnotationType.NONE) {
 188             return at2;
 189         } else if (at2 == AnnotationType.NONE) {
 190             return at1;
 191         } else if (at1 != at2) {
 192             return AnnotationType.BOTH;
 193         } else {
 194             return at1;
 195         }
 196     }
 197 
 198     private AnnotationType targetToAnnotationType(Attribute a, Symbol s) {
 199         Attribute.Enum e = (Attribute.Enum)a;
 200         if (e.value.name == names.TYPE) {
 201             if (s.kind == TYP)
 202                 return AnnotationType.DECLARATION;
<span class="line-modified"> 203         } else if (e.value.name == names.FIELD) {</span>
 204             if (s.kind == VAR &amp;&amp;
 205                     s.owner.kind != MTH)
 206                 return AnnotationType.DECLARATION;
 207         } else if (e.value.name == names.METHOD) {
 208             if (s.kind == MTH &amp;&amp;
 209                     !s.isConstructor())
 210                 return AnnotationType.DECLARATION;
 211         } else if (e.value.name == names.PARAMETER) {
 212             if (s.kind == VAR &amp;&amp;
 213                     s.owner.kind == MTH &amp;&amp;
 214                     (s.flags() &amp; Flags.PARAMETER) != 0)
 215                 return AnnotationType.DECLARATION;
 216         } else if (e.value.name == names.CONSTRUCTOR) {
 217             if (s.kind == MTH &amp;&amp;
 218                     s.isConstructor())
 219                 return AnnotationType.DECLARATION;
 220         } else if (e.value.name == names.LOCAL_VARIABLE) {
 221             if (s.kind == VAR &amp;&amp;
 222                     s.owner.kind == MTH &amp;&amp;
 223                     (s.flags() &amp; Flags.PARAMETER) == 0)
</pre>
<hr />
<pre>
 373                         if (params.head == sym) {
 374                             newArgs.add(type);
 375                         } else {
 376                             newArgs.add(oldArgs.head);
 377                         }
 378                         oldArgs = oldArgs.tail;
 379                         params = params.tail;
 380                     }
 381                     methType.argtypes = newArgs.toList();
 382                 }
 383             } else {
 384                 sym.type = type;
 385             }
 386 
 387             sym.appendUniqueTypeAttributes(typeAnnotations);
 388 
 389             if (sym.getKind() == ElementKind.PARAMETER ||
 390                 sym.getKind() == ElementKind.LOCAL_VARIABLE ||
 391                 sym.getKind() == ElementKind.RESOURCE_VARIABLE ||
 392                 sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {
<span class="line-modified"> 393                 // Make sure all type annotations from the symbol are also</span>
<span class="line-modified"> 394                 // on the owner. If the owner is an initializer block, propagate</span>
<span class="line-modified"> 395                 // to the type.</span>
<span class="line-modified"> 396                 final long ownerFlags = sym.owner.flags();</span>
<span class="line-modified"> 397                 if ((ownerFlags &amp; Flags.BLOCK) != 0) {</span>
<span class="line-modified"> 398                     // Store init and clinit type annotations with the ClassSymbol</span>
<span class="line-modified"> 399                     // to allow output in Gen.normalizeDefs.</span>
<span class="line-modified"> 400                     ClassSymbol cs = (ClassSymbol) sym.owner.owner;</span>
<span class="line-modified"> 401                     if ((ownerFlags &amp; Flags.STATIC) != 0) {</span>
<span class="line-modified"> 402                         cs.appendClassInitTypeAttributes(typeAnnotations);</span>
<span class="line-modified"> 403                     } else {</span>
<span class="line-modified"> 404                         cs.appendInitTypeAttributes(typeAnnotations);</span>
<span class="line-modified"> 405                     }</span>


 406                 } else {
<span class="line-modified"> 407                     sym.owner.appendUniqueTypeAttributes(sym.getRawTypeAttributes());</span>
 408                 }


 409             }
 410         }
 411 
 412         // This method has a similar purpose as
 413         // {@link com.sun.tools.javac.parser.JavacParser.insertAnnotationsToMostInner(JCExpression, List&lt;JCTypeAnnotation&gt;, boolean)}
 414         // We found a type annotation in a declaration annotation position,
 415         // for example, on the return type.
 416         // Such an annotation is _not_ part of an JCAnnotatedType tree and we therefore
 417         // need to set its position explicitly.
 418         // The method returns a copy of type that contains these annotations.
 419         //
 420         // As a side effect the method sets the type annotation position of &quot;annotations&quot;.
 421         // Note that it is assumed that all annotations share the same position.
 422         private Type typeWithAnnotations(final JCTree typetree, final Type type,
 423                 final List&lt;Attribute.TypeCompound&gt; annotations,
 424                 final List&lt;Attribute.TypeCompound&gt; onlyTypeAnnotations,
 425                 final TypeAnnotationPosition pos)
 426         {
 427             if (annotations.isEmpty()) {
 428                 return type;
</pre>
<hr />
<pre>
 749                             frameNewClass.typeargs.indexOf(tree);
 750                         return TypeAnnotationPosition
 751                             .constructorInvocationTypeArg(location.toList(),
 752                                                           currentLambda,
 753                                                           type_index,
 754                                                           frame.pos);
 755                     } else {
 756                         return TypeAnnotationPosition
 757                             .newObj(location.toList(), currentLambda,
 758                                     frame.pos);
 759                     }
 760 
 761                 case NEW_ARRAY:
 762                     return TypeAnnotationPosition
 763                         .newObj(location.toList(), currentLambda, frame.pos);
 764 
 765                 case ANNOTATION_TYPE:
 766                 case CLASS:
 767                 case ENUM:
 768                 case INTERFACE:

 769                     if (((JCClassDecl)frame).extending == tree) {
 770                         return TypeAnnotationPosition
 771                             .classExtends(location.toList(), currentLambda,
 772                                           frame.pos);
 773                     } else if (((JCClassDecl)frame).implementing.contains(tree)) {
 774                         final int type_index =
 775                             ((JCClassDecl)frame).implementing.indexOf(tree);
 776                         return TypeAnnotationPosition
 777                             .classExtends(location.toList(), currentLambda,
 778                                           type_index, frame.pos);
 779                     } else if (((JCClassDecl)frame).typarams.contains(tree)) {
 780                         final int parameter_index =
 781                             ((JCClassDecl)frame).typarams.indexOf(tree);
 782                         return TypeAnnotationPosition
 783                             .typeParameter(location.toList(), currentLambda,
 784                                            parameter_index, frame.pos);
 785                     } else {
 786                         throw new AssertionError(&quot;Could not determine position of tree &quot; +
 787                                                  tree + &quot; within frame &quot; + frame);
 788                     }
</pre>
<hr />
<pre>
 926                         final JCMethodDecl method =
 927                             (JCMethodDecl)path.tail.tail.head;
 928                         final int parameter_index =
 929                             method.typarams.indexOf(path.tail.head);
 930                         final int bound_index =
 931                             ((JCTypeParameter)frame).bounds.get(0)
 932                             .type.isInterface() ?
 933                             ((JCTypeParameter)frame).bounds.indexOf(tree) + 1:
 934                             ((JCTypeParameter)frame).bounds.indexOf(tree);
 935                         return TypeAnnotationPosition
 936                             .methodTypeParameterBound(location.toList(),
 937                                                       currentLambda,
 938                                                       parameter_index,
 939                                                       bound_index,
 940                                                       frame.pos);
 941                     } else {
 942                         throw new AssertionError(&quot;Could not determine position of tree &quot; + tree +
 943                                                  &quot; within frame &quot; + frame);
 944                     }
 945 

 946                 case VARIABLE:
<span class="line-modified"> 947                     VarSymbol v = ((JCVariableDecl)frame).sym;</span>
 948                     if (v.getKind() != ElementKind.FIELD) {
<span class="line-modified"> 949                         v.owner.appendUniqueTypeAttributes(v.getRawTypeAttributes());</span>
 950                     }
 951                     switch (v.getKind()) {

 952                         case LOCAL_VARIABLE:
 953                             return TypeAnnotationPosition
 954                                 .localVariable(location.toList(), currentLambda,
 955                                                frame.pos);
 956                         case FIELD:
 957                             return TypeAnnotationPosition.field(location.toList(),
 958                                                                 currentLambda,
 959                                                                 frame.pos);
 960                         case PARAMETER:
 961                             if (v.getQualifiedName().equals(names._this)) {
 962                                 return TypeAnnotationPosition
 963                                     .methodReceiver(location.toList(),
 964                                                     currentLambda,
 965                                                     frame.pos);
 966                             } else {
 967                                 final int parameter_index =
 968                                     methodParamIndex(path, frame);
 969                                 return TypeAnnotationPosition
 970                                     .methodParameter(location.toList(),
 971                                                      currentLambda,
</pre>
<hr />
<pre>
1105             }
1106         }
1107 
1108         // Each class (including enclosed inner classes) is visited separately.
1109         // This flag is used to prevent from visiting inner classes.
1110         private boolean isInClass = false;
1111 
1112         @Override
1113         public void visitClassDef(JCClassDecl tree) {
1114             if (isInClass)
1115                 return;
1116             isInClass = true;
1117 
1118             if (sigOnly) {
1119                 scan(tree.mods);
1120                 scan(tree.typarams);
1121                 scan(tree.extending);
1122                 scan(tree.implementing);
1123             }
1124             scan(tree.defs);



1125         }
1126 
1127         /**
1128          * Resolve declaration vs. type annotations in methods and
1129          * then determine the positions.
1130          */
1131         @Override
1132         public void visitMethodDef(final JCMethodDecl tree) {
1133             if (tree.sym == null) {
1134                 Assert.error(&quot;Visiting tree node before memberEnter&quot;);
1135             }
1136             if (sigOnly) {
1137                 if (!tree.mods.annotations.isEmpty()) {
1138                     if (tree.sym.isConstructor()) {
1139                         final TypeAnnotationPosition pos =
1140                             TypeAnnotationPosition.methodReturn(tree.pos);
1141                         // Use null to mark that the annotations go
1142                         // with the symbol.
1143                         separateAnnotationsKinds(tree, null, tree.sym, pos);
1144                     } else {
</pre>
<hr />
<pre>
1249                 final TypeAnnotationPosition pos =
1250                     TypeAnnotationPosition.localVariable(currentLambda,
1251                                                          tree.pos);
1252                 if (!tree.isImplicitlyTyped()) {
1253                     separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1254                 }
1255             } else if (tree.sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {
1256                 final TypeAnnotationPosition pos =
1257                     TypeAnnotationPosition.exceptionParameter(currentLambda,
1258                                                               tree.pos);
1259                 separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1260             } else if (tree.sym.getKind() == ElementKind.RESOURCE_VARIABLE) {
1261                 final TypeAnnotationPosition pos =
1262                     TypeAnnotationPosition.resourceVariable(currentLambda,
1263                                                             tree.pos);
1264                 separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1265             } else if (tree.sym.getKind() == ElementKind.ENUM_CONSTANT) {
1266                 // No type annotations can occur here.
1267             } else {
1268                 // There is nothing else in a variable declaration that needs separation.
<span class="line-modified">1269                 Assert.error(&quot;Unhandled variable kind&quot;);</span>
1270             }
1271 
1272             scan(tree.mods);
1273             scan(tree.vartype);
1274             if (!sigOnly) {
1275                 scan(tree.init);
1276             }
1277         }
1278 
1279         @Override
1280         public void visitBlock(JCBlock tree) {
1281             // Do not descend into top-level blocks when only interested
1282             // in the signature.
1283             if (!sigOnly) {
1284                 scan(tree.stats);
1285             }
1286         }
1287 
1288         @Override
1289         public void visitAnnotatedType(JCAnnotatedType tree) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 183                         .reduce(AnnotationType.NONE, this::combineAnnotationType);
 184     }
 185 
 186     private AnnotationType combineAnnotationType(AnnotationType at1, AnnotationType at2) {
 187         if (at1 == AnnotationType.NONE) {
 188             return at2;
 189         } else if (at2 == AnnotationType.NONE) {
 190             return at1;
 191         } else if (at1 != at2) {
 192             return AnnotationType.BOTH;
 193         } else {
 194             return at1;
 195         }
 196     }
 197 
 198     private AnnotationType targetToAnnotationType(Attribute a, Symbol s) {
 199         Attribute.Enum e = (Attribute.Enum)a;
 200         if (e.value.name == names.TYPE) {
 201             if (s.kind == TYP)
 202                 return AnnotationType.DECLARATION;
<span class="line-modified"> 203         } else if (e.value.name == names.FIELD || e.value.name == names.RECORD_COMPONENT) {</span>
 204             if (s.kind == VAR &amp;&amp;
 205                     s.owner.kind != MTH)
 206                 return AnnotationType.DECLARATION;
 207         } else if (e.value.name == names.METHOD) {
 208             if (s.kind == MTH &amp;&amp;
 209                     !s.isConstructor())
 210                 return AnnotationType.DECLARATION;
 211         } else if (e.value.name == names.PARAMETER) {
 212             if (s.kind == VAR &amp;&amp;
 213                     s.owner.kind == MTH &amp;&amp;
 214                     (s.flags() &amp; Flags.PARAMETER) != 0)
 215                 return AnnotationType.DECLARATION;
 216         } else if (e.value.name == names.CONSTRUCTOR) {
 217             if (s.kind == MTH &amp;&amp;
 218                     s.isConstructor())
 219                 return AnnotationType.DECLARATION;
 220         } else if (e.value.name == names.LOCAL_VARIABLE) {
 221             if (s.kind == VAR &amp;&amp;
 222                     s.owner.kind == MTH &amp;&amp;
 223                     (s.flags() &amp; Flags.PARAMETER) == 0)
</pre>
<hr />
<pre>
 373                         if (params.head == sym) {
 374                             newArgs.add(type);
 375                         } else {
 376                             newArgs.add(oldArgs.head);
 377                         }
 378                         oldArgs = oldArgs.tail;
 379                         params = params.tail;
 380                     }
 381                     methType.argtypes = newArgs.toList();
 382                 }
 383             } else {
 384                 sym.type = type;
 385             }
 386 
 387             sym.appendUniqueTypeAttributes(typeAnnotations);
 388 
 389             if (sym.getKind() == ElementKind.PARAMETER ||
 390                 sym.getKind() == ElementKind.LOCAL_VARIABLE ||
 391                 sym.getKind() == ElementKind.RESOURCE_VARIABLE ||
 392                 sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {
<span class="line-modified"> 393                 appendTypeAnnotationsToOwner(sym, typeAnnotations);</span>
<span class="line-modified"> 394             }</span>
<span class="line-modified"> 395         }</span>
<span class="line-modified"> 396 </span>
<span class="line-modified"> 397         private void appendTypeAnnotationsToOwner(Symbol sym, List&lt;Attribute.TypeCompound&gt; typeAnnotations) {</span>
<span class="line-modified"> 398             // Make sure all type annotations from the symbol are also</span>
<span class="line-modified"> 399             // on the owner. If the owner is an initializer block, propagate</span>
<span class="line-modified"> 400             // to the type.</span>
<span class="line-modified"> 401             final long ownerFlags = sym.owner.flags();</span>
<span class="line-modified"> 402             if ((ownerFlags &amp; Flags.BLOCK) != 0) {</span>
<span class="line-modified"> 403                 // Store init and clinit type annotations with the ClassSymbol</span>
<span class="line-modified"> 404                 // to allow output in Gen.normalizeDefs.</span>
<span class="line-modified"> 405                 ClassSymbol cs = (ClassSymbol) sym.owner.owner;</span>
<span class="line-added"> 406                 if ((ownerFlags &amp; Flags.STATIC) != 0) {</span>
<span class="line-added"> 407                     cs.appendClassInitTypeAttributes(typeAnnotations);</span>
 408                 } else {
<span class="line-modified"> 409                     cs.appendInitTypeAttributes(typeAnnotations);</span>
 410                 }
<span class="line-added"> 411             } else {</span>
<span class="line-added"> 412                 sym.owner.appendUniqueTypeAttributes(typeAnnotations);</span>
 413             }
 414         }
 415 
 416         // This method has a similar purpose as
 417         // {@link com.sun.tools.javac.parser.JavacParser.insertAnnotationsToMostInner(JCExpression, List&lt;JCTypeAnnotation&gt;, boolean)}
 418         // We found a type annotation in a declaration annotation position,
 419         // for example, on the return type.
 420         // Such an annotation is _not_ part of an JCAnnotatedType tree and we therefore
 421         // need to set its position explicitly.
 422         // The method returns a copy of type that contains these annotations.
 423         //
 424         // As a side effect the method sets the type annotation position of &quot;annotations&quot;.
 425         // Note that it is assumed that all annotations share the same position.
 426         private Type typeWithAnnotations(final JCTree typetree, final Type type,
 427                 final List&lt;Attribute.TypeCompound&gt; annotations,
 428                 final List&lt;Attribute.TypeCompound&gt; onlyTypeAnnotations,
 429                 final TypeAnnotationPosition pos)
 430         {
 431             if (annotations.isEmpty()) {
 432                 return type;
</pre>
<hr />
<pre>
 753                             frameNewClass.typeargs.indexOf(tree);
 754                         return TypeAnnotationPosition
 755                             .constructorInvocationTypeArg(location.toList(),
 756                                                           currentLambda,
 757                                                           type_index,
 758                                                           frame.pos);
 759                     } else {
 760                         return TypeAnnotationPosition
 761                             .newObj(location.toList(), currentLambda,
 762                                     frame.pos);
 763                     }
 764 
 765                 case NEW_ARRAY:
 766                     return TypeAnnotationPosition
 767                         .newObj(location.toList(), currentLambda, frame.pos);
 768 
 769                 case ANNOTATION_TYPE:
 770                 case CLASS:
 771                 case ENUM:
 772                 case INTERFACE:
<span class="line-added"> 773                 case RECORD:</span>
 774                     if (((JCClassDecl)frame).extending == tree) {
 775                         return TypeAnnotationPosition
 776                             .classExtends(location.toList(), currentLambda,
 777                                           frame.pos);
 778                     } else if (((JCClassDecl)frame).implementing.contains(tree)) {
 779                         final int type_index =
 780                             ((JCClassDecl)frame).implementing.indexOf(tree);
 781                         return TypeAnnotationPosition
 782                             .classExtends(location.toList(), currentLambda,
 783                                           type_index, frame.pos);
 784                     } else if (((JCClassDecl)frame).typarams.contains(tree)) {
 785                         final int parameter_index =
 786                             ((JCClassDecl)frame).typarams.indexOf(tree);
 787                         return TypeAnnotationPosition
 788                             .typeParameter(location.toList(), currentLambda,
 789                                            parameter_index, frame.pos);
 790                     } else {
 791                         throw new AssertionError(&quot;Could not determine position of tree &quot; +
 792                                                  tree + &quot; within frame &quot; + frame);
 793                     }
</pre>
<hr />
<pre>
 931                         final JCMethodDecl method =
 932                             (JCMethodDecl)path.tail.tail.head;
 933                         final int parameter_index =
 934                             method.typarams.indexOf(path.tail.head);
 935                         final int bound_index =
 936                             ((JCTypeParameter)frame).bounds.get(0)
 937                             .type.isInterface() ?
 938                             ((JCTypeParameter)frame).bounds.indexOf(tree) + 1:
 939                             ((JCTypeParameter)frame).bounds.indexOf(tree);
 940                         return TypeAnnotationPosition
 941                             .methodTypeParameterBound(location.toList(),
 942                                                       currentLambda,
 943                                                       parameter_index,
 944                                                       bound_index,
 945                                                       frame.pos);
 946                     } else {
 947                         throw new AssertionError(&quot;Could not determine position of tree &quot; + tree +
 948                                                  &quot; within frame &quot; + frame);
 949                     }
 950 
<span class="line-added"> 951                 case BINDING_PATTERN:</span>
 952                 case VARIABLE:
<span class="line-modified"> 953                     VarSymbol v = frame.hasTag(Tag.BINDINGPATTERN) ? ((JCBindingPattern) frame).symbol : ((JCVariableDecl) frame).sym;</span>
 954                     if (v.getKind() != ElementKind.FIELD) {
<span class="line-modified"> 955                         appendTypeAnnotationsToOwner(v, v.getRawTypeAttributes());</span>
 956                     }
 957                     switch (v.getKind()) {
<span class="line-added"> 958                         case BINDING_VARIABLE:</span>
 959                         case LOCAL_VARIABLE:
 960                             return TypeAnnotationPosition
 961                                 .localVariable(location.toList(), currentLambda,
 962                                                frame.pos);
 963                         case FIELD:
 964                             return TypeAnnotationPosition.field(location.toList(),
 965                                                                 currentLambda,
 966                                                                 frame.pos);
 967                         case PARAMETER:
 968                             if (v.getQualifiedName().equals(names._this)) {
 969                                 return TypeAnnotationPosition
 970                                     .methodReceiver(location.toList(),
 971                                                     currentLambda,
 972                                                     frame.pos);
 973                             } else {
 974                                 final int parameter_index =
 975                                     methodParamIndex(path, frame);
 976                                 return TypeAnnotationPosition
 977                                     .methodParameter(location.toList(),
 978                                                      currentLambda,
</pre>
<hr />
<pre>
1112             }
1113         }
1114 
1115         // Each class (including enclosed inner classes) is visited separately.
1116         // This flag is used to prevent from visiting inner classes.
1117         private boolean isInClass = false;
1118 
1119         @Override
1120         public void visitClassDef(JCClassDecl tree) {
1121             if (isInClass)
1122                 return;
1123             isInClass = true;
1124 
1125             if (sigOnly) {
1126                 scan(tree.mods);
1127                 scan(tree.typarams);
1128                 scan(tree.extending);
1129                 scan(tree.implementing);
1130             }
1131             scan(tree.defs);
<span class="line-added">1132             if (tree.sym.isRecord()) {</span>
<span class="line-added">1133                 tree.sym.getRecordComponents().stream().forEach(rc -&gt; scan(rc.accessorMeth));</span>
<span class="line-added">1134             }</span>
1135         }
1136 
1137         /**
1138          * Resolve declaration vs. type annotations in methods and
1139          * then determine the positions.
1140          */
1141         @Override
1142         public void visitMethodDef(final JCMethodDecl tree) {
1143             if (tree.sym == null) {
1144                 Assert.error(&quot;Visiting tree node before memberEnter&quot;);
1145             }
1146             if (sigOnly) {
1147                 if (!tree.mods.annotations.isEmpty()) {
1148                     if (tree.sym.isConstructor()) {
1149                         final TypeAnnotationPosition pos =
1150                             TypeAnnotationPosition.methodReturn(tree.pos);
1151                         // Use null to mark that the annotations go
1152                         // with the symbol.
1153                         separateAnnotationsKinds(tree, null, tree.sym, pos);
1154                     } else {
</pre>
<hr />
<pre>
1259                 final TypeAnnotationPosition pos =
1260                     TypeAnnotationPosition.localVariable(currentLambda,
1261                                                          tree.pos);
1262                 if (!tree.isImplicitlyTyped()) {
1263                     separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1264                 }
1265             } else if (tree.sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {
1266                 final TypeAnnotationPosition pos =
1267                     TypeAnnotationPosition.exceptionParameter(currentLambda,
1268                                                               tree.pos);
1269                 separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1270             } else if (tree.sym.getKind() == ElementKind.RESOURCE_VARIABLE) {
1271                 final TypeAnnotationPosition pos =
1272                     TypeAnnotationPosition.resourceVariable(currentLambda,
1273                                                             tree.pos);
1274                 separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1275             } else if (tree.sym.getKind() == ElementKind.ENUM_CONSTANT) {
1276                 // No type annotations can occur here.
1277             } else {
1278                 // There is nothing else in a variable declaration that needs separation.
<span class="line-modified">1279                 Assert.error(&quot;Unhandled variable kind: &quot; + tree.sym.getKind());</span>
1280             }
1281 
1282             scan(tree.mods);
1283             scan(tree.vartype);
1284             if (!sigOnly) {
1285                 scan(tree.init);
1286             }
1287         }
1288 
1289         @Override
1290         public void visitBlock(JCBlock tree) {
1291             // Do not descend into top-level blocks when only interested
1292             // in the signature.
1293             if (!sigOnly) {
1294                 scan(tree.stats);
1295             }
1296         }
1297 
1298         @Override
1299         public void visitAnnotatedType(JCAnnotatedType tree) {
</pre>
</td>
</tr>
</table>
<center><a href="Type.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeMetadata.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
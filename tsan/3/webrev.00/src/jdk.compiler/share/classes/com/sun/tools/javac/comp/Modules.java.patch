diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java
@@ -353,11 +353,11 @@
     }
 
     private void setCompilationUnitModules(List<JCCompilationUnit> trees, Set<ModuleSymbol> rootModules, ClassSymbol c) {
         // update the module for each compilation unit
         if (multiModuleMode) {
-            checkNoAllModulePath();
+            boolean patchesAutomaticModules = false;
             for (JCCompilationUnit tree: trees) {
                 if (tree.defs.isEmpty()) {
                     tree.modle = syms.unnamedModule;
                     continue;
                 }
@@ -373,10 +373,11 @@
                     if (plocn != null) {
                         Name name = names.fromString(fileManager.inferModuleName(plocn));
                         ModuleSymbol msym = moduleFinder.findModule(name);
                         tree.modle = msym;
                         rootModules.add(msym);
+                        patchesAutomaticModules |= (msym.flags_field & Flags.AUTOMATIC_MODULE) != 0;
 
                         if (msplocn != null) {
                             Name mspname = names.fromString(fileManager.inferModuleName(msplocn));
                             if (name != mspname) {
                                 log.error(tree.pos(), Errors.FilePatchedAndMsp(name, mspname));
@@ -436,10 +437,13 @@
                     throw new Error(e); // FIXME
                 } finally {
                     log.useSource(prev);
                 }
             }
+            if (!patchesAutomaticModules) {
+                checkNoAllModulePath();
+            }
             if (syms.unnamedModule.sourceLocation == null) {
                 syms.unnamedModule.completer = getUnnamedModuleCompleter();
                 syms.unnamedModule.sourceLocation = StandardLocation.SOURCE_PATH;
                 syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
             }
@@ -456,13 +460,15 @@
                             chk.completionError(null, cf);
                             defaultModule = syms.unnamedModule;
                         }
                         if (defaultModule == syms.unnamedModule) {
                             if (moduleOverride != null) {
-                                checkNoAllModulePath();
                                 defaultModule = moduleFinder.findModule(names.fromString(moduleOverride));
                                 defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
+                                if ((defaultModule.flags_field & Flags.AUTOMATIC_MODULE) == 0) {
+                                    checkNoAllModulePath();
+                                }
                             } else {
                                 // Question: why not do findAllModules and initVisiblePackages here?
                                 // i.e. body of unnamedModuleCompleter
                                 defaultModule.completer = getUnnamedModuleCompleter();
                                 defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
@@ -1152,11 +1158,11 @@
                     /* The implementation must be defined in the same module as the provides directive
                      * (else, error)
                      */
                     PackageSymbol implementationDefiningPackage = impl.packge();
                     if (implementationDefiningPackage.modle != msym) {
-                        // TODO: should use tree for the implentation name, not the entire provides tree
+                        // TODO: should use tree for the implementation name, not the entire provides tree
                         // TODO: should improve error message to identify the implementation type
                         log.error(tree.pos(), Errors.ServiceImplementationNotInRightModule(implementationDefiningPackage.modle));
                     }
 
                     /* There is no inherent requirement that module that provides a service should actually

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeHasher.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../file/BaseFileManager.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 53,10 ***</span>
<span class="line-new-header">--- 53,13 ---</span>
  import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
  import static com.sun.tools.javac.code.TypeTag.CLASS;
  import static com.sun.tools.javac.code.TypeTag.ERROR;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<span class="line-added">+ </span>
<span class="line-added">+ import static com.sun.tools.javac.code.TypeTag.*;</span>
<span class="line-added">+ import static com.sun.tools.javac.code.TypeTag.BOT;</span>
  import static com.sun.tools.javac.tree.JCTree.Tag.*;
  
  import com.sun.tools.javac.util.Dependencies.CompletionCause;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 431,11 ***</span>
          }
  
          Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
              Assert.check(completionEnabled);
              Lint prevLint = chk.setLint(allowDeprecationOnImport ?
<span class="line-modified">!                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL));</span>
              try {
                  // To prevent deep recursion, suppress completion of some
                  // types.
                  completionEnabled = false;
                  return attr.attribType(tree, env);
<span class="line-new-header">--- 434,11 ---</span>
          }
  
          Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
              Assert.check(completionEnabled);
              Lint prevLint = chk.setLint(allowDeprecationOnImport ?
<span class="line-modified">!                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));</span>
              try {
                  // To prevent deep recursion, suppress completion of some
                  // types.
                  completionEnabled = false;
                  return attr.attribType(tree, env);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,18 ***</span>
              JCExpression extending;
  
              if (tree.extending != null) {
                  extending = clearTypeParams(tree.extending);
                  supertype = attr.attribBase(extending, baseEnv, true, false, true);
              } else {
                  extending = null;
                  supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
                  ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
                                    true, false, false)
                  : (sym.fullname == names.java_lang_Object)
                  ? Type.noType
<span class="line-modified">!                 : syms.objectType;</span>
              }
              ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
  
              // Determine interfaces.
              ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
<span class="line-new-header">--- 679,21 ---</span>
              JCExpression extending;
  
              if (tree.extending != null) {
                  extending = clearTypeParams(tree.extending);
                  supertype = attr.attribBase(extending, baseEnv, true, false, true);
<span class="line-added">+                 if (supertype == syms.recordType) {</span>
<span class="line-added">+                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));</span>
<span class="line-added">+                 }</span>
              } else {
                  extending = null;
                  supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
                  ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
                                    true, false, false)
                  : (sym.fullname == names.java_lang_Object)
                  ? Type.noType
<span class="line-modified">!                 : sym.isRecord() ? syms.recordType : syms.objectType;</span>
              }
              ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
  
              // Determine interfaces.
              ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 799,11 ***</span>
      }
  
      private final class HeaderPhase extends AbstractHeaderPhase {
  
          public HeaderPhase() {
<span class="line-modified">!             super(CompletionCause.HEADER_PHASE, new MembersPhase());</span>
          }
  
          @Override
          protected void runPhase(Env&lt;AttrContext&gt; env) {
              JCClassDecl tree = env.enclClass;
<span class="line-new-header">--- 805,11 ---</span>
      }
  
      private final class HeaderPhase extends AbstractHeaderPhase {
  
          public HeaderPhase() {
<span class="line-modified">!             super(CompletionCause.HEADER_PHASE, new RecordPhase());</span>
          }
  
          @Override
          protected void runPhase(Env&lt;AttrContext&gt; env) {
              JCClassDecl tree = env.enclClass;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 849,16 ***</span>
                  sym.flags_field |= AUXILIARY;
              }
          }
      }
  
<span class="line-modified">!     /** Enter member fields and methods of a class</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private final class MembersPhase extends Phase {</span>
  
<span class="line-modified">!         public MembersPhase() {</span>
<span class="line-modified">!             super(CompletionCause.MEMBERS_PHASE, null);</span>
          }
  
          private boolean completing;
          private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
  
<span class="line-new-header">--- 855,14 ---</span>
                  sym.flags_field |= AUXILIARY;
              }
          }
      }
  
<span class="line-modified">!     private abstract class AbstractMembersPhase extends Phase {</span>
  
<span class="line-modified">!         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {</span>
<span class="line-modified">!             super(completionCause, next);</span>
          }
  
          private boolean completing;
          private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 879,67 ***</span>
              } finally {
                  completing = prevCompleting;
              }
          }
  
<span class="line-modified">!         @Override</span>
<span class="line-removed">-         protected void runPhase(Env&lt;AttrContext&gt; env) {</span>
<span class="line-removed">-             JCClassDecl tree = env.enclClass;</span>
<span class="line-removed">-             ClassSymbol sym = tree.sym;</span>
              ClassType ct = (ClassType)sym.type;
<span class="line-removed">- </span>
<span class="line-removed">-             // Add default constructor if needed.</span>
<span class="line-removed">-             if ((sym.flags() &amp; INTERFACE) == 0 &amp;&amp;</span>
<span class="line-removed">-                 !TreeInfo.hasConstructors(tree.defs)) {</span>
<span class="line-removed">-                 List&lt;Type&gt; argtypes = List.nil();</span>
<span class="line-removed">-                 List&lt;Type&gt; typarams = List.nil();</span>
<span class="line-removed">-                 List&lt;Type&gt; thrown = List.nil();</span>
<span class="line-removed">-                 long ctorFlags = 0;</span>
<span class="line-removed">-                 boolean based = false;</span>
<span class="line-removed">-                 boolean addConstructor = true;</span>
<span class="line-removed">-                 JCNewClass nc = null;</span>
<span class="line-removed">-                 if (sym.name.isEmpty()) {</span>
<span class="line-removed">-                     nc = (JCNewClass)env.next.tree;</span>
<span class="line-removed">-                     if (nc.constructor != null) {</span>
<span class="line-removed">-                         addConstructor = nc.constructor.kind != ERR;</span>
<span class="line-removed">-                         Type superConstrType = types.memberType(sym.type,</span>
<span class="line-removed">-                                                                 nc.constructor);</span>
<span class="line-removed">-                         argtypes = superConstrType.getParameterTypes();</span>
<span class="line-removed">-                         typarams = superConstrType.getTypeArguments();</span>
<span class="line-removed">-                         ctorFlags = nc.constructor.flags() &amp; VARARGS;</span>
<span class="line-removed">-                         if (nc.encl != null) {</span>
<span class="line-removed">-                             argtypes = argtypes.prepend(nc.encl.type);</span>
<span class="line-removed">-                             based = true;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         thrown = superConstrType.getThrownTypes();</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (addConstructor) {</span>
<span class="line-removed">-                     MethodSymbol basedConstructor = nc != null ?</span>
<span class="line-removed">-                             (MethodSymbol)nc.constructor : null;</span>
<span class="line-removed">-                     JCTree constrDef = DefaultConstructor(make.at(tree.pos), sym,</span>
<span class="line-removed">-                                                         basedConstructor,</span>
<span class="line-removed">-                                                         typarams, argtypes, thrown,</span>
<span class="line-removed">-                                                         ctorFlags, based);</span>
<span class="line-removed">-                     tree.defs = tree.defs.prepend(constrDef);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              // enter symbols for &#39;this&#39; into current scope.
              VarSymbol thisSym =
<span class="line-modified">!                 new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);</span>
              thisSym.pos = Position.FIRSTPOS;
              env.info.scope.enter(thisSym);
              // if this is a class, enter symbol for &#39;super&#39; into current scope.
              if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
                      ct.supertype_field.hasTag(CLASS)) {
                  VarSymbol superSym =
<span class="line-modified">!                     new VarSymbol(FINAL | HASINIT, names._super,</span>
<span class="line-modified">!                                   ct.supertype_field, sym);</span>
                  superSym.pos = Position.FIRSTPOS;
                  env.info.scope.enter(superSym);
              }
  
              if (!tree.typarams.isEmpty()) {
                  for (JCTypeParameter tvar : tree.typarams) {
                      chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
                  }
<span class="line-new-header">--- 883,81 ---</span>
              } finally {
                  completing = prevCompleting;
              }
          }
  
<span class="line-modified">!         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {</span>
              ClassType ct = (ClassType)sym.type;
              // enter symbols for &#39;this&#39; into current scope.
              VarSymbol thisSym =
<span class="line-modified">!                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);</span>
              thisSym.pos = Position.FIRSTPOS;
              env.info.scope.enter(thisSym);
              // if this is a class, enter symbol for &#39;super&#39; into current scope.
              if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
                      ct.supertype_field.hasTag(CLASS)) {
                  VarSymbol superSym =
<span class="line-modified">!                         new VarSymbol(FINAL | HASINIT, names._super,</span>
<span class="line-modified">!                                 ct.supertype_field, sym);</span>
                  superSym.pos = Position.FIRSTPOS;
                  env.info.scope.enter(superSym);
              }
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private final class RecordPhase extends AbstractMembersPhase {</span>
<span class="line-added">+ </span>
<span class="line-added">+         public RecordPhase() {</span>
<span class="line-added">+             super(CompletionCause.RECORD_PHASE, new MembersPhase());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected void runPhase(Env&lt;AttrContext&gt; env) {</span>
<span class="line-added">+             JCClassDecl tree = env.enclClass;</span>
<span class="line-added">+             ClassSymbol sym = tree.sym;</span>
<span class="line-added">+             if ((sym.flags_field &amp; RECORD) != 0) {</span>
<span class="line-added">+                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);</span>
<span class="line-added">+                 memberEnter.memberEnter(fields, env);</span>
<span class="line-added">+                 for (JCVariableDecl field : fields) {</span>
<span class="line-added">+                     sym.getRecordComponent(field, true);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 enterThisAndSuper(sym, env);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 // lets enter all constructors</span>
<span class="line-added">+                 for (JCTree def : tree.defs) {</span>
<span class="line-added">+                     if (TreeInfo.isConstructor(def)) {</span>
<span class="line-added">+                         memberEnter.memberEnter(def, env);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /** Enter member fields and methods of a class</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private final class MembersPhase extends AbstractMembersPhase {</span>
<span class="line-added">+ </span>
<span class="line-added">+         public MembersPhase() {</span>
<span class="line-added">+             super(CompletionCause.MEMBERS_PHASE, null);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         protected void runPhase(Env&lt;AttrContext&gt; env) {</span>
<span class="line-added">+             JCClassDecl tree = env.enclClass;</span>
<span class="line-added">+             ClassSymbol sym = tree.sym;</span>
<span class="line-added">+             ClassType ct = (ClassType)sym.type;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // Add default constructor if needed.</span>
<span class="line-added">+             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);</span>
<span class="line-added">+             if (helper != null) {</span>
<span class="line-added">+                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);</span>
<span class="line-added">+                 tree.defs = tree.defs.prepend(constrDef);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (!sym.isRecord()) {</span>
<span class="line-added">+                 enterThisAndSuper(sym, env);</span>
<span class="line-added">+             }</span>
  
              if (!tree.typarams.isEmpty()) {
                  for (JCTypeParameter tvar : tree.typarams) {
                      chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 951,190 ***</span>
                  typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
                  typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
              }
          }
  
          /** Enter members for a class.
           */
          void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
              if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
                  !tree.sym.type.hasTag(ERROR) &amp;&amp;
                  (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
                  addEnumMembers(tree, env);
              }
<span class="line-modified">!             memberEnter.memberEnter(tree.defs, env);</span>
<span class="line-modified">! </span>
              if (tree.sym.isAnnotationType()) {
                  Assert.check(tree.sym.isCompleted());
                  tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
              }
          }
  
          /** Add the implicit members for an enum type
           *  to the symbol table.
           */
          private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
              JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
  
<span class="line-removed">-             // public static T[] values() { return ???; }</span>
              JCMethodDecl values = make.
                  MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
                            names.values,
                            valuesType,
                            List.nil(),
                            List.nil(),
<span class="line-modified">!                           List.nil(), // thrown</span>
<span class="line-modified">!                           null, //make.Block(0, Tree.emptyList.prepend(make.Return(make.Ident(names._null)))),</span>
                            null);
              memberEnter.memberEnter(values, env);
  
<span class="line-removed">-             // public static T valueOf(String name) { return ???; }</span>
              JCMethodDecl valueOf = make.
                  MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
                            names.valueOf,
                            make.Type(tree.sym.type),
                            List.nil(),
                            List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
                                                               Flags.MANDATED),
                                                  names.fromString(&quot;name&quot;),
                                                  make.Type(syms.stringType), null)),
<span class="line-modified">!                           List.nil(), // thrown</span>
<span class="line-modified">!                           null, //make.Block(0, Tree.emptyList.prepend(make.Return(make.Ident(names._null)))),</span>
                            null);
              memberEnter.memberEnter(valueOf, env);
          }
  
      }
  
  /* ***************************************************************************
   * tree building
   ****************************************************************************/
  
<span class="line-modified">!     /** Generate default constructor for given class. For classes different</span>
<span class="line-modified">!      *  from java.lang.Object, this is:</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *    c(argtype_0 x_0, ..., argtype_n x_n) throws thrown {</span>
<span class="line-modified">!      *      super(x_0, ..., x_n)</span>
<span class="line-modified">!      *    }</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *  or, if based == true:</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *    c(argtype_0 x_0, ..., argtype_n x_n) throws thrown {</span>
<span class="line-modified">!      *      x_0.super(x_1, ..., x_n)</span>
<span class="line-modified">!      *    }</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *  @param make     The tree factory.</span>
<span class="line-modified">!      *  @param c        The class owning the default constructor.</span>
<span class="line-modified">!      *  @param argtypes The parameter types of the constructor.</span>
<span class="line-modified">!      *  @param thrown   The thrown exceptions of the constructor.</span>
<span class="line-modified">!      *  @param based    Is first parameter a this$n?</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     JCTree DefaultConstructor(TreeMaker make,</span>
<span class="line-modified">!                             ClassSymbol c,</span>
<span class="line-modified">!                             MethodSymbol baseInit,</span>
<span class="line-modified">!                             List&lt;Type&gt; typarams,</span>
<span class="line-modified">!                             List&lt;Type&gt; argtypes,</span>
<span class="line-modified">!                             List&lt;Type&gt; thrown,</span>
<span class="line-modified">!                             long flags,</span>
<span class="line-modified">!                             boolean based) {</span>
<span class="line-modified">!         JCTree result;</span>
<span class="line-modified">!         if ((c.flags() &amp; ENUM) != 0 &amp;&amp;</span>
<span class="line-modified">!             (types.supertype(c.type).tsym == syms.enumSym)) {</span>
<span class="line-modified">!             // constructors of true enums are private</span>
<span class="line-modified">!             flags = (flags &amp; ~AccessFlags) | PRIVATE | GENERATEDCONSTR;</span>
<span class="line-modified">!         } else</span>
<span class="line-modified">!             flags |= (c.flags() &amp; AccessFlags) | GENERATEDCONSTR;</span>
<span class="line-modified">!         if (c.name.isEmpty()) {</span>
<span class="line-modified">!             flags |= ANONCONSTR;</span>
          }
<span class="line-modified">!         if (based) {</span>
<span class="line-modified">!             flags |= ANONCONSTR_BASED;</span>
          }
<span class="line-modified">!         Type mType = new MethodType(argtypes, null, thrown, c);</span>
<span class="line-modified">!         Type initType = typarams.nonEmpty() ?</span>
<span class="line-modified">!             new ForAll(typarams, mType) :</span>
<span class="line-modified">!             mType;</span>
<span class="line-modified">!         MethodSymbol init = new MethodSymbol(flags, names.init,</span>
<span class="line-modified">!                 initType, c);</span>
<span class="line-modified">!         init.params = createDefaultConstructorParams(make, baseInit, init,</span>
<span class="line-modified">!                 argtypes, based);</span>
<span class="line-modified">!         List&lt;JCVariableDecl&gt; params = make.Params(argtypes, init);</span>
<span class="line-modified">!         List&lt;JCStatement&gt; stats = List.nil();</span>
<span class="line-modified">!         if (c.type != syms.objectType) {</span>
<span class="line-modified">!             stats = stats.prepend(SuperCall(make, typarams, params, based));</span>
          }
<span class="line-removed">-         result = make.MethodDef(init, make.Block(0, stats));</span>
<span class="line-removed">-         return result;</span>
      }
  
<span class="line-modified">!     private List&lt;VarSymbol&gt; createDefaultConstructorParams(</span>
<span class="line-modified">!             TreeMaker make,</span>
<span class="line-modified">!             MethodSymbol baseInit,</span>
<span class="line-modified">!             MethodSymbol init,</span>
<span class="line-modified">!             List&lt;Type&gt; argtypes,</span>
<span class="line-modified">!             boolean based) {</span>
<span class="line-modified">!         List&lt;VarSymbol&gt; initParams = null;</span>
<span class="line-modified">!         List&lt;Type&gt; argTypesList = argtypes;</span>
<span class="line-modified">!         if (based) {</span>
<span class="line-modified">!             /*  In this case argtypes will have an extra type, compared to baseInit,</span>
<span class="line-modified">!              *  corresponding to the type of the enclosing instance i.e.:</span>
<span class="line-modified">!              *</span>
<span class="line-modified">!              *  Inner i = outer.new Inner(1){}</span>
<span class="line-modified">!              *</span>
<span class="line-modified">!              *  in the above example argtypes will be (Outer, int) and baseInit</span>
<span class="line-modified">!              *  will have parameter&#39;s types (int). So in this case we have to add</span>
<span class="line-modified">!              *  first the extra type in argtypes and then get the names of the</span>
<span class="line-modified">!              *  parameters from baseInit.</span>
               */
<span class="line-modified">!             initParams = List.nil();</span>
<span class="line-modified">!             VarSymbol param = new VarSymbol(PARAMETER, make.paramName(0), argtypes.head, init);</span>
<span class="line-modified">!             initParams = initParams.append(param);</span>
<span class="line-modified">!             argTypesList = argTypesList.tail;</span>
          }
<span class="line-modified">!         if (baseInit != null &amp;&amp; baseInit.params != null &amp;&amp;</span>
<span class="line-modified">!             baseInit.params.nonEmpty() &amp;&amp; argTypesList.nonEmpty()) {</span>
<span class="line-modified">!             initParams = (initParams == null) ? List.nil() : initParams;</span>
<span class="line-modified">!             List&lt;VarSymbol&gt; baseInitParams = baseInit.params;</span>
<span class="line-modified">!             while (baseInitParams.nonEmpty() &amp;&amp; argTypesList.nonEmpty()) {</span>
<span class="line-modified">!                 VarSymbol param = new VarSymbol(baseInitParams.head.flags() | PARAMETER,</span>
<span class="line-modified">!                         baseInitParams.head.name, argTypesList.head, init);</span>
<span class="line-modified">!                 initParams = initParams.append(param);</span>
<span class="line-modified">!                 baseInitParams = baseInitParams.tail;</span>
<span class="line-modified">!                 argTypesList = argTypesList.tail;</span>
              }
          }
<span class="line-removed">-         return initParams;</span>
      }
  
<span class="line-modified">!     /** Generate call to superclass constructor. This is:</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *    super(id_0, ..., id_n)</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * or, if based == true</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *    id_0.super(id_1,...,id_n)</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *  where id_0, ..., id_n are the names of the given parameters.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      *  @param make    The tree factory</span>
<span class="line-modified">!      *  @param params  The parameters that need to be passed to super</span>
<span class="line-modified">!      *  @param typarams  The type parameters that need to be passed to super</span>
<span class="line-modified">!      *  @param based   Is first parameter a this$n?</span>
<span class="line-modified">!      */</span>
<span class="line-removed">-     JCExpressionStatement SuperCall(TreeMaker make,</span>
<span class="line-removed">-                    List&lt;Type&gt; typarams,</span>
<span class="line-removed">-                    List&lt;JCVariableDecl&gt; params,</span>
<span class="line-removed">-                    boolean based) {</span>
<span class="line-removed">-         JCExpression meth;</span>
<span class="line-removed">-         if (based) {</span>
<span class="line-removed">-             meth = make.Select(make.Ident(params.head), names._super);</span>
<span class="line-removed">-             params = params.tail;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             meth = make.Ident(names._super);</span>
          }
<span class="line-modified">!         List&lt;JCExpression&gt; typeargs = typarams.nonEmpty() ? make.Types(typarams) : null;</span>
<span class="line-modified">!         return make.Exec(make.Apply(typeargs, meth, make.Idents(params)));</span>
      }
  
      /**
       * Mark sym deprecated if annotations contain @Deprecated annotation.
       */
<span class="line-new-header">--- 969,416 ---</span>
                  typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
                  typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
              }
          }
  
<span class="line-added">+         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {</span>
<span class="line-added">+             JCClassDecl tree = env.enclClass;</span>
<span class="line-added">+             ClassSymbol sym = tree.sym;</span>
<span class="line-added">+             DefaultConstructorHelper helper = null;</span>
<span class="line-added">+             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);</span>
<span class="line-added">+             boolean isRecord = sym.isRecord();</span>
<span class="line-added">+             if (isClassWithoutInit &amp;&amp; !isRecord) {</span>
<span class="line-added">+                 helper = new BasicConstructorHelper(sym);</span>
<span class="line-added">+                 if (sym.name.isEmpty()) {</span>
<span class="line-added">+                     JCNewClass nc = (JCNewClass)env.next.tree;</span>
<span class="line-added">+                     if (nc.constructor != null) {</span>
<span class="line-added">+                         if (nc.constructor.kind != ERR) {</span>
<span class="line-added">+                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);</span>
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             helper = null;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (isRecord) {</span>
<span class="line-added">+                 JCMethodDecl canonicalInit = null;</span>
<span class="line-added">+                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {</span>
<span class="line-added">+                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (canonicalInit != null) {</span>
<span class="line-added">+                     canonicalInit.sym.flags_field |= Flags.RECORD;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return helper;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /** Enter members for a class.
           */
          void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
              if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
                  !tree.sym.type.hasTag(ERROR) &amp;&amp;
                  (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
                  addEnumMembers(tree, env);
              }
<span class="line-modified">!             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;</span>
<span class="line-modified">!             List&lt;JCTree&gt; alreadyEntered = null;</span>
<span class="line-added">+             if (isRecord) {</span>
<span class="line-added">+                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));</span>
<span class="line-added">+                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()</span>
<span class="line-added">+                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;</span>
<span class="line-added">+                                 ((JCMethodDecl)t).sym != null &amp;&amp;</span>
<span class="line-added">+                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             List&lt;JCTree&gt; defsToEnter = isRecord ?</span>
<span class="line-added">+                     tree.defs.diff(alreadyEntered) : tree.defs;</span>
<span class="line-added">+             memberEnter.memberEnter(defsToEnter, env);</span>
<span class="line-added">+             List&lt;JCTree&gt; defsBeforeAddingNewMembers = tree.defs;</span>
<span class="line-added">+             if (isRecord) {</span>
<span class="line-added">+                 addRecordMembersIfNeeded(tree, env);</span>
<span class="line-added">+             }</span>
              if (tree.sym.isAnnotationType()) {
                  Assert.check(tree.sym.isCompleted());
                  tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
              }
          }
  
<span class="line-added">+         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {</span>
<span class="line-added">+             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());</span>
<span class="line-added">+             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);</span>
<span class="line-added">+             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {</span>
<span class="line-added">+                 /* here we are pushing the annotations present in the corresponding field down to the accessor</span>
<span class="line-added">+                  * it could be that some of those annotations are not applicable to the accessor, they will be striped</span>
<span class="line-added">+                  * away later at Check::validateAnnotation</span>
<span class="line-added">+                  */</span>
<span class="line-added">+                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos();</span>
<span class="line-added">+                 JCMethodDecl getter = make.at(tree.pos).</span>
<span class="line-added">+                         MethodDef(</span>
<span class="line-added">+                                 make.Modifiers(Flags.PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),</span>
<span class="line-added">+                           tree.sym.name,</span>
<span class="line-added">+                           /* we need to special case for the case when the user declared the type as an ident</span>
<span class="line-added">+                            * if we don&#39;t do that then we can have issues if type annotations are applied to the</span>
<span class="line-added">+                            * return type: javac issues an error if a type annotation is applied to java.lang.String</span>
<span class="line-added">+                            * but applying a type annotation to String is kosher</span>
<span class="line-added">+                            */</span>
<span class="line-added">+                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),</span>
<span class="line-added">+                           List.nil(),</span>
<span class="line-added">+                           List.nil(),</span>
<span class="line-added">+                           List.nil(), // thrown</span>
<span class="line-added">+                           null,</span>
<span class="line-added">+                           null);</span>
<span class="line-added">+                 memberEnter.memberEnter(getter, env);</span>
<span class="line-added">+                 rec.accessor = getter.sym;</span>
<span class="line-added">+                 rec.accessorMeth = getter;</span>
<span class="line-added">+             } else if (implSym != null) {</span>
<span class="line-added">+                 rec.accessor = implSym;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /** Add the implicit members for an enum type
           *  to the symbol table.
           */
          private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
              JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
  
              JCMethodDecl values = make.
                  MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
                            names.values,
                            valuesType,
                            List.nil(),
                            List.nil(),
<span class="line-modified">!                           List.nil(),</span>
<span class="line-modified">!                           null,</span>
                            null);
              memberEnter.memberEnter(values, env);
  
              JCMethodDecl valueOf = make.
                  MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
                            names.valueOf,
                            make.Type(tree.sym.type),
                            List.nil(),
                            List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
                                                               Flags.MANDATED),
                                                  names.fromString(&quot;name&quot;),
                                                  make.Type(syms.stringType), null)),
<span class="line-modified">!                           List.nil(),</span>
<span class="line-modified">!                           null,</span>
                            null);
              memberEnter.memberEnter(valueOf, env);
          }
  
<span class="line-added">+         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {</span>
<span class="line-added">+             // let&#39;s check if there is a constructor with exactly the same arguments as the record components</span>
<span class="line-added">+             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));</span>
<span class="line-added">+             JCMethodDecl canonicalDecl = null;</span>
<span class="line-added">+             for (JCTree def : tree.defs) {</span>
<span class="line-added">+                 if (TreeInfo.isConstructor(def)) {</span>
<span class="line-added">+                     JCMethodDecl mdecl = (JCMethodDecl)def;</span>
<span class="line-added">+                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {</span>
<span class="line-added">+                         canonicalDecl = mdecl;</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return canonicalDecl;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         /** Add the implicit members for a record</span>
<span class="line-added">+          *  to the symbol table.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {</span>
<span class="line-added">+             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {</span>
<span class="line-added">+                 JCMethodDecl toString = make.</span>
<span class="line-added">+                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.GENERATED_MEMBER),</span>
<span class="line-added">+                               names.toString,</span>
<span class="line-added">+                               make.Type(syms.stringType),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               null,</span>
<span class="line-added">+                               null);</span>
<span class="line-added">+                 memberEnter.memberEnter(toString, env);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {</span>
<span class="line-added">+                 JCMethodDecl hashCode = make.</span>
<span class="line-added">+                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),</span>
<span class="line-added">+                               names.hashCode,</span>
<span class="line-added">+                               make.Type(syms.intType),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               null,</span>
<span class="line-added">+                               null);</span>
<span class="line-added">+                 memberEnter.memberEnter(hashCode, env);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {</span>
<span class="line-added">+                 JCMethodDecl equals = make.</span>
<span class="line-added">+                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),</span>
<span class="line-added">+                               names.equals,</span>
<span class="line-added">+                               make.Type(syms.booleanType),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),</span>
<span class="line-added">+                                                 names.fromString(&quot;o&quot;),</span>
<span class="line-added">+                                                 make.Type(syms.objectType), null)),</span>
<span class="line-added">+                               List.nil(),</span>
<span class="line-added">+                               null,</span>
<span class="line-added">+                               null);</span>
<span class="line-added">+                 memberEnter.memberEnter(equals, env);</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             // fields can&#39;t be varargs, lets remove the flag</span>
<span class="line-added">+             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);</span>
<span class="line-added">+             for (JCVariableDecl field: recordFields) {</span>
<span class="line-added">+                 field.mods.flags &amp;= ~Flags.VARARGS;</span>
<span class="line-added">+                 field.sym.flags_field &amp;= ~Flags.VARARGS;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // now lets add the accessors</span>
<span class="line-added">+             recordFields.stream()</span>
<span class="line-added">+                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))</span>
<span class="line-added">+                     .forEach(vd -&gt; addAccessor(vd, env));</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {</span>
<span class="line-added">+         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {</span>
<span class="line-added">+             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {</span>
<span class="line-added">+                 return (MethodSymbol) s;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return null;</span>
      }
  
  /* ***************************************************************************
   * tree building
   ****************************************************************************/
  
<span class="line-modified">!     interface DefaultConstructorHelper {</span>
<span class="line-modified">!        Type constructorType();</span>
<span class="line-modified">!        MethodSymbol constructorSymbol();</span>
<span class="line-modified">!        Type enclosingType();</span>
<span class="line-modified">!        TypeSymbol owner();</span>
<span class="line-modified">!        List&lt;Name&gt; superArgs();</span>
<span class="line-modified">!        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     class BasicConstructorHelper implements DefaultConstructorHelper {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         TypeSymbol owner;</span>
<span class="line-modified">!         Type constructorType;</span>
<span class="line-modified">!         MethodSymbol constructorSymbol;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         BasicConstructorHelper(TypeSymbol owner) {</span>
<span class="line-modified">!             this.owner = owner;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public Type constructorType() {</span>
<span class="line-modified">!             if (constructorType == null) {</span>
<span class="line-modified">!                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return constructorType;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public MethodSymbol constructorSymbol() {</span>
<span class="line-modified">!             if (constructorSymbol == null) {</span>
<span class="line-modified">!                 long flags;</span>
<span class="line-modified">!                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;</span>
<span class="line-modified">!                     (types.supertype(owner().type).tsym == syms.enumSym)) {</span>
<span class="line-modified">!                     // constructors of true enums are private</span>
<span class="line-modified">!                     flags = PRIVATE | GENERATEDCONSTR;</span>
<span class="line-modified">!                 } else if ((owner().flags_field &amp; RECORD) != 0) {</span>
<span class="line-added">+                     // record constructors are public</span>
<span class="line-added">+                     flags = PUBLIC | GENERATEDCONSTR;</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 constructorSymbol = new MethodSymbol(flags, names.init,</span>
<span class="line-added">+                     constructorType(), owner());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return constructorSymbol;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public Type enclosingType() {</span>
<span class="line-added">+             return Type.noType;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public TypeSymbol owner() {</span>
<span class="line-added">+             return owner;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public List&lt;Name&gt; superArgs() {</span>
<span class="line-added">+             return List.nil();</span>
<span class="line-added">+             }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     class AnonClassConstructorHelper extends BasicConstructorHelper {</span>
<span class="line-added">+ </span>
<span class="line-added">+         MethodSymbol constr;</span>
<span class="line-added">+         Type encl;</span>
<span class="line-added">+         boolean based = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {</span>
<span class="line-added">+             super(owner);</span>
<span class="line-added">+             this.constr = constr;</span>
<span class="line-added">+             this.encl = encl != null ? encl.type : Type.noType;</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-added">+         public Type constructorType() {</span>
<span class="line-added">+             if (constructorType == null) {</span>
<span class="line-added">+                 Type ctype = types.memberType(owner.type, constr);</span>
<span class="line-added">+                 if (!enclosingType().hasTag(NONE)) {</span>
<span class="line-added">+                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));</span>
<span class="line-added">+                     based = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 constructorType = ctype;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return constructorType;</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public MethodSymbol constructorSymbol() {</span>
<span class="line-modified">!             MethodSymbol csym = super.constructorSymbol();</span>
<span class="line-modified">!             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);</span>
<span class="line-modified">!             csym.flags_field |= based ? ANONCONSTR_BASED : 0;</span>
<span class="line-modified">!             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">!             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();</span>
<span class="line-modified">!             if (!enclosingType().hasTag(NONE)) {</span>
<span class="line-modified">!                 argtypes = argtypes.tail;</span>
<span class="line-modified">!                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));</span>
<span class="line-modified">!             }</span>
<span class="line-added">+             if (constr.params != null) {</span>
<span class="line-added">+                 for (VarSymbol p : constr.params) {</span>
<span class="line-added">+                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));</span>
<span class="line-added">+                     argtypes = argtypes.tail;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             csym.params = params.toList();</span>
<span class="line-added">+             return csym;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public Type enclosingType() {</span>
<span class="line-added">+             return encl;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public List&lt;Name&gt; superArgs() {</span>
<span class="line-added">+             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());</span>
<span class="line-added">+             if (!enclosingType().hasTag(NONE)) {</span>
<span class="line-added">+                 params = params.tail;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return params.map(vd -&gt; vd.name);</span>
          }
      }
  
<span class="line-modified">!     class RecordConstructorHelper extends BasicConstructorHelper {</span>
<span class="line-modified">! </span>
<span class="line-modified">!         List&lt;VarSymbol&gt; recordFieldSymbols;</span>
<span class="line-modified">!         List&lt;JCVariableDecl&gt; recordFieldDecls;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         RecordConstructorHelper(TypeSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {</span>
<span class="line-modified">!             super(owner);</span>
<span class="line-modified">!             this.recordFieldDecls = recordFieldDecls;</span>
<span class="line-modified">!             this.recordFieldSymbols = recordFieldDecls.map(vd -&gt; vd.sym);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public Type constructorType() {</span>
<span class="line-modified">!             if (constructorType == null) {</span>
<span class="line-modified">!                 List&lt;Type&gt; argtypes = recordFieldSymbols.map(v -&gt; (v.flags_field &amp; Flags.VARARGS) != 0 ? types.elemtype(v.type) : v.type);</span>
<span class="line-modified">!                 constructorType = new MethodType(argtypes, syms.voidType, List.nil(), syms.methodClass);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             return constructorType;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public MethodSymbol constructorSymbol() {</span>
<span class="line-added">+             MethodSymbol csym = super.constructorSymbol();</span>
<span class="line-added">+             /* if we have to generate a default constructor for records we will treat it as the compact one</span>
<span class="line-added">+              * to trigger field initialization later on</span>
               */
<span class="line-modified">!             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;</span>
<span class="line-modified">!             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">!             for (VarSymbol p : recordFieldSymbols) {</span>
<span class="line-modified">!                 params.add(new VarSymbol(GENERATED_MEMBER | PARAMETER | RECORD | ((p.flags_field &amp; Flags.VARARGS) != 0 ? Flags.VARARGS : 0), p.name, p.type, csym));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             csym.params = params.toList();</span>
<span class="line-added">+             csym.flags_field |= RECORD | PUBLIC;</span>
<span class="line-added">+             return csym;</span>
          }
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public JCMethodDecl finalAdjustment(JCMethodDecl md) {</span>
<span class="line-modified">!             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;</span>
<span class="line-modified">!             for (JCVariableDecl arg : md.params) {</span>
<span class="line-modified">!                 /* at this point we are passing all the annotations in the field to the corresponding</span>
<span class="line-modified">!                  * parameter in the constructor.</span>
<span class="line-modified">!                  */</span>
<span class="line-modified">!                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);</span>
<span class="line-modified">!                 arg.mods.annotations = rc.getOriginalAnnos();</span>
<span class="line-added">+                 arg.vartype = tmpRecordFieldDecls.head.vartype;</span>
<span class="line-added">+                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;</span>
              }
<span class="line-added">+             return md;</span>
          }
      }
  
<span class="line-modified">!     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {</span>
<span class="line-modified">!         Type initType = helper.constructorType();</span>
<span class="line-modified">!         MethodSymbol initSym = helper.constructorSymbol();</span>
<span class="line-modified">!         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">!         if (helper.owner().type != syms.objectType) {</span>
<span class="line-modified">!             JCExpression meth;</span>
<span class="line-modified">!             if (!helper.enclosingType().hasTag(NONE)) {</span>
<span class="line-modified">!                 meth = make.Select(make.Ident(initSym.params.head), names._super);</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 meth = make.Ident(names._super);</span>
<span class="line-modified">!             }</span>
<span class="line-modified">!             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?</span>
<span class="line-modified">!                     make.Types(initType.getTypeArguments()) : null;</span>
<span class="line-modified">!             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));</span>
<span class="line-modified">!             stats.add(superCall);</span>
          }
<span class="line-modified">!         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));</span>
<span class="line-modified">!         return helper.finalAdjustment(result);</span>
      }
  
      /**
       * Mark sym deprecated if annotations contain @Deprecated annotation.
       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1154,21 ***</span>
      private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
          for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
              JCAnnotation a = al.head;
              if (a.annotationType.type == syms.deprecatedType) {
                  sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
<span class="line-modified">!                 a.args.stream()</span>
<span class="line-modified">!                         .filter(e -&gt; e.hasTag(ASSIGN))</span>
<span class="line-modified">!                         .map(e -&gt; (JCAssign) e)</span>
<span class="line-modified">!                         .filter(assign -&gt; TreeInfo.name(assign.lhs) == names.forRemoval)</span>
<span class="line-removed">-                         .findFirst()</span>
<span class="line-removed">-                         .ifPresent(assign -&gt; {</span>
<span class="line-removed">-                             JCExpression rhs = TreeInfo.skipParens(assign.rhs);</span>
<span class="line-removed">-                             if (rhs.hasTag(LITERAL)</span>
<span class="line-removed">-                                     &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {</span>
<span class="line-removed">-                                 sym.flags_field |= DEPRECATED_REMOVAL;</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         });</span>
              }
          }
      }
  }
<span class="line-new-header">--- 1398,28 ---</span>
      private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
          for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
              JCAnnotation a = al.head;
              if (a.annotationType.type == syms.deprecatedType) {
                  sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
<span class="line-modified">!                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);</span>
<span class="line-modified">!             } else if (a.annotationType.type == syms.previewFeatureType) {</span>
<span class="line-modified">!                 sym.flags_field |= Flags.PREVIEW_API;</span>
<span class="line-modified">!                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);</span>
              }
          }
      }
<span class="line-added">+     //where:</span>
<span class="line-added">+         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {</span>
<span class="line-added">+             a.args.stream()</span>
<span class="line-added">+                     .filter(e -&gt; e.hasTag(ASSIGN))</span>
<span class="line-added">+                     .map(e -&gt; (JCAssign) e)</span>
<span class="line-added">+                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)</span>
<span class="line-added">+                     .findFirst()</span>
<span class="line-added">+                     .ifPresent(assign -&gt; {</span>
<span class="line-added">+                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);</span>
<span class="line-added">+                         if (rhs.hasTag(LITERAL)</span>
<span class="line-added">+                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {</span>
<span class="line-added">+                             sym.flags_field |= flag;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     });</span>
<span class="line-added">+         }</span>
  }
</pre>
<center><a href="TreeHasher.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../file/BaseFileManager.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
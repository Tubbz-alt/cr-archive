<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/CRTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 
 28 import java.util.*;
 29 
 30 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 31 import com.sun.tools.javac.tree.*;
 32 import com.sun.tools.javac.util.*;
 33 import com.sun.tools.javac.util.List;
 34 import com.sun.tools.javac.tree.JCTree.*;
 35 import com.sun.tools.javac.tree.EndPosTable;
 36 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;
 37 
 38 /** This class contains the CharacterRangeTable for some method
 39  *  and the hashtable for mapping trees or lists of trees to their
 40  *  ending positions.
 41  *
 42  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 43  *  If you write code that depends on this, you do so at your own risk.
 44  *  This code and its internal interfaces are subject to change or
 45  *  deletion without notice.&lt;/b&gt;
 46  */
 47 public class CRTable
 48 implements CRTFlags {
 49 
 50     private final boolean crtDebug = false;
 51 
 52     /** The list of CRTable entries.
 53      */
 54     private ListBuffer&lt;CRTEntry&gt; entries = new ListBuffer&lt;&gt;();
 55 
 56     /** The hashtable for source positions.
 57      */
 58     private Map&lt;Object,SourceRange&gt; positions = new HashMap&lt;&gt;();
 59 
 60     /** The object for ending positions stored in the parser.
 61      */
 62     private EndPosTable endPosTable;
 63 
 64     /** The tree of the method this table is intended for.
 65      *  We should traverse this tree to get source ranges.
 66      */
 67     JCTree.JCMethodDecl methodTree;
 68 
 69     /** Constructor
 70      */
 71     public CRTable(JCTree.JCMethodDecl tree, EndPosTable endPosTable) {
 72         this.methodTree = tree;
 73         this.endPosTable = endPosTable;
 74     }
 75 
 76     /** Create a new CRTEntry and add it to the entries.
 77      *  @param tree     The tree or the list of trees for which
 78      *                  we are storing the code pointers.
 79      *  @param flags    The set of flags designating type of the entry.
 80      *  @param startPc  The starting code position.
 81      *  @param endPc    The ending code position.
 82      */
 83     public void put(Object tree, int flags, int startPc, int endPc) {
 84         entries.append(new CRTEntry(tree, flags, startPc, endPc));
 85     }
 86 
 87     /** Compute source positions and write CRT to the databuf.
 88      *  @param databuf  The buffer to write bytecodes to.
 89      */
 90     public int writeCRT(ByteBuffer databuf, Position.LineMap lineMap, Log log) {
 91 
 92         int crtEntries = 0;
 93 
 94         // compute source positions for the method
 95         new SourceComputer().csp(methodTree);
 96 
 97         for (List&lt;CRTEntry&gt; l = entries.toList(); l.nonEmpty(); l = l.tail) {
 98 
 99             CRTEntry entry = l.head;
100 
101             // eliminate entries that do not produce bytecodes:
102             // for example, empty blocks and statements
103             if (entry.startPc == entry.endPc)
104                 continue;
105 
106             SourceRange pos = positions.get(entry.tree);
107             Assert.checkNonNull(pos, &quot;CRT: tree source positions are undefined&quot;);
108             if ((pos.startPos == Position.NOPOS) || (pos.endPos == Position.NOPOS))
109                 continue;
110 
111             if (crtDebug) {
112                 System.out.println(&quot;Tree: &quot; + entry.tree + &quot;, type:&quot; + getTypes(entry.flags));
113                 System.out.print(&quot;Start: pos = &quot; + pos.startPos + &quot;, pc = &quot; + entry.startPc);
114             }
115 
116             // encode startPos into line/column representation
117             int startPos = encodePosition(pos.startPos, lineMap, log);
118             if (startPos == Position.NOPOS)
119                 continue;
120 
121             if (crtDebug) {
122                 System.out.print(&quot;End:   pos = &quot; + pos.endPos + &quot;, pc = &quot; + (entry.endPc - 1));
123             }
124 
125             // encode endPos into line/column representation
126             int endPos = encodePosition(pos.endPos, lineMap, log);
127             if (endPos == Position.NOPOS)
128                 continue;
129 
130             // write attribute
131             databuf.appendChar(entry.startPc);
132             // &#39;endPc - 1&#39; because endPc actually points to start of the next command
133             databuf.appendChar(entry.endPc - 1);
134             databuf.appendInt(startPos);
135             databuf.appendInt(endPos);
136             databuf.appendChar(entry.flags);
137 
138             crtEntries++;
139         }
140 
141         return crtEntries;
142     }
143 
144     /** Return the number of the entries.
145      */
146     public int length() {
147         return entries.length();
148     }
149 
150     /** Return string describing flags enabled.
151      */
152     private String getTypes(int flags) {
153         String types = &quot;&quot;;
154         if ((flags &amp; CRT_STATEMENT)       != 0) types += &quot; CRT_STATEMENT&quot;;
155         if ((flags &amp; CRT_BLOCK)           != 0) types += &quot; CRT_BLOCK&quot;;
156         if ((flags &amp; CRT_ASSIGNMENT)      != 0) types += &quot; CRT_ASSIGNMENT&quot;;
157         if ((flags &amp; CRT_FLOW_CONTROLLER) != 0) types += &quot; CRT_FLOW_CONTROLLER&quot;;
158         if ((flags &amp; CRT_FLOW_TARGET)     != 0) types += &quot; CRT_FLOW_TARGET&quot;;
159         if ((flags &amp; CRT_INVOKE)          != 0) types += &quot; CRT_INVOKE&quot;;
160         if ((flags &amp; CRT_CREATE)          != 0) types += &quot; CRT_CREATE&quot;;
161         if ((flags &amp; CRT_BRANCH_TRUE)     != 0) types += &quot; CRT_BRANCH_TRUE&quot;;
162         if ((flags &amp; CRT_BRANCH_FALSE)    != 0) types += &quot; CRT_BRANCH_FALSE&quot;;
163         return types;
164     }
165 
166     /** Source file positions in CRT are integers in the format:
167      *  {@literal line-number &lt;&lt; LINESHIFT + column-number }
168      */
169      private int encodePosition(int pos, Position.LineMap lineMap, Log log) {
170          int line = lineMap.getLineNumber(pos);
171          int col = lineMap.getColumnNumber(pos);
172          int new_pos = Position.encodePosition(line, col);
173          if (crtDebug) {
174              System.out.println(&quot;, line = &quot; + line + &quot;, column = &quot; + col +
175                                 &quot;, new_pos = &quot; + new_pos);
176          }
177          if (new_pos == Position.NOPOS)
178              log.warning(pos, Warnings.PositionOverflow(line));
179 
180         return new_pos;
181      }
182 
183 /* ************************************************************************
184  * Traversal methods
185  *************************************************************************/
186 
187     /**
188      *  This class contains methods to compute source positions for trees.
189      *  Extends Tree.Visitor to traverse the abstract syntax tree.
190      */
191     class SourceComputer extends JCTree.Visitor {
192 
193         /** The result of the tree traversal methods.
194          */
195         SourceRange result;
196 
197         /** Visitor method: compute source positions for a single node.
198          */
199         public SourceRange csp(JCTree tree) {
200             if (tree == null) return null;
201             tree.accept(this);
202             if (result != null) {
203                 positions.put(tree, result);
204             }
205             return result;
206         }
207 
208         /** Visitor method: compute source positions for a list of nodes.
209          */
210         public SourceRange csp(List&lt;? extends JCTree&gt; trees) {
211             if ((trees == null) || !(trees.nonEmpty())) return null;
212             SourceRange list_sr = new SourceRange();
213             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail) {
214                 list_sr.mergeWith(csp(l.head));
215             }
216             positions.put(trees, list_sr);
217             return list_sr;
218         }
219 
220         /**  Visitor method: compute source positions for
221          *    a list of case blocks of switch statements.
222          */
223         public SourceRange cspCases(List&lt;JCCase&gt; trees) {
224             if ((trees == null) || !(trees.nonEmpty())) return null;
225             SourceRange list_sr = new SourceRange();
226             for (List&lt;JCCase&gt; l = trees; l.nonEmpty(); l = l.tail) {
227                 list_sr.mergeWith(csp(l.head));
228             }
229             positions.put(trees, list_sr);
230             return list_sr;
231         }
232 
233         /**  Visitor method: compute source positions for
234          *   a list of catch clauses in try statements.
235          */
236         public SourceRange cspCatchers(List&lt;JCCatch&gt; trees) {
237             if ((trees == null) || !(trees.nonEmpty())) return null;
238             SourceRange list_sr = new SourceRange();
239             for (List&lt;JCCatch&gt; l = trees; l.nonEmpty(); l = l.tail) {
240                 list_sr.mergeWith(csp(l.head));
241             }
242             positions.put(trees, list_sr);
243             return list_sr;
244         }
245 
246         public void visitMethodDef(JCMethodDecl tree) {
247             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
248             sr.mergeWith(csp(tree.body));
249             result = sr;
250         }
251 
252         public void visitVarDef(JCVariableDecl tree) {
253             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
254             csp(tree.vartype);
255             sr.mergeWith(csp(tree.init));
256             result = sr;
257         }
258 
259         public void visitSkip(JCSkip tree) {
260             // endPos is the same as startPos for the empty statement
261             SourceRange sr = new SourceRange(startPos(tree), startPos(tree));
262             result = sr;
263         }
264 
265         public void visitBlock(JCBlock tree) {
266             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
267             csp(tree.stats);    // doesn&#39;t compare because block&#39;s ending position is defined
268             result = sr;
269         }
270 
271         public void visitDoLoop(JCDoWhileLoop tree) {
272             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
273             sr.mergeWith(csp(tree.body));
274             sr.mergeWith(csp(tree.cond));
275             result = sr;
276         }
277 
278         public void visitWhileLoop(JCWhileLoop tree) {
279             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
280             sr.mergeWith(csp(tree.cond));
281             sr.mergeWith(csp(tree.body));
282             result = sr;
283         }
284 
285         public void visitForLoop(JCForLoop tree) {
286             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
287             sr.mergeWith(csp(tree.init));
288             sr.mergeWith(csp(tree.cond));
289             sr.mergeWith(csp(tree.step));
290             sr.mergeWith(csp(tree.body));
291             result = sr;
292         }
293 
294         public void visitForeachLoop(JCEnhancedForLoop tree) {
295             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
296             sr.mergeWith(csp(tree.var));
297             sr.mergeWith(csp(tree.expr));
298             sr.mergeWith(csp(tree.body));
299             result = sr;
300         }
301 
302         public void visitLabelled(JCLabeledStatement tree) {
303             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
304             sr.mergeWith(csp(tree.body));
305             result = sr;
306         }
307 
308         public void visitSwitch(JCSwitch tree) {
309             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
310             sr.mergeWith(csp(tree.selector));
311             sr.mergeWith(cspCases(tree.cases));
312             result = sr;
313         }
314 
315         @Override
316         public void visitSwitchExpression(JCSwitchExpression tree) {
317             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
318             sr.mergeWith(csp(tree.selector));
319             sr.mergeWith(cspCases(tree.cases));
320             result = sr;
321         }
322 
323         public void visitCase(JCCase tree) {
324             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
325             sr.mergeWith(csp(tree.pats));
326             sr.mergeWith(csp(tree.stats));
327             result = sr;
328         }
329 
330         public void visitSynchronized(JCSynchronized tree) {
331             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
332             sr.mergeWith(csp(tree.lock));
333             sr.mergeWith(csp(tree.body));
334             result = sr;
335         }
336 
337         public void visitTry(JCTry tree) {
338             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
339             sr.mergeWith(csp(tree.resources));
340             sr.mergeWith(csp(tree.body));
341             sr.mergeWith(cspCatchers(tree.catchers));
342             sr.mergeWith(csp(tree.finalizer));
343             result = sr;
344         }
345 
346         public void visitCatch(JCCatch tree) {
347             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
348             sr.mergeWith(csp(tree.param));
349             sr.mergeWith(csp(tree.body));
350             result = sr;
351         }
352 
353         public void visitConditional(JCConditional tree) {
354             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
355             sr.mergeWith(csp(tree.cond));
356             sr.mergeWith(csp(tree.truepart));
357             sr.mergeWith(csp(tree.falsepart));
358             result = sr;
359         }
360 
361         public void visitIf(JCIf tree) {
362             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
363             sr.mergeWith(csp(tree.cond));
364             sr.mergeWith(csp(tree.thenpart));
365             sr.mergeWith(csp(tree.elsepart));
366             result = sr;
367         }
368 
369         public void visitExec(JCExpressionStatement tree) {
370             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
371             sr.mergeWith(csp(tree.expr));
372             result = sr;
373         }
374 
375         public void visitBreak(JCBreak tree) {
376             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
377             result = sr;
378         }
379 
380         public void visitContinue(JCContinue tree) {
381             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
382             result = sr;
383         }
384 
385         public void visitReturn(JCReturn tree) {
386             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
387             sr.mergeWith(csp(tree.expr));
388             result = sr;
389         }
390 
391         public void visitThrow(JCThrow tree) {
392             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
393             sr.mergeWith(csp(tree.expr));
394             result = sr;
395         }
396 
397         public void visitAssert(JCAssert tree) {
398             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
399             sr.mergeWith(csp(tree.cond));
400             sr.mergeWith(csp(tree.detail));
401             result = sr;
402         }
403 
404         public void visitApply(JCMethodInvocation tree) {
405             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
406             sr.mergeWith(csp(tree.meth));
407             sr.mergeWith(csp(tree.args));
408             result = sr;
409         }
410 
411         public void visitNewClass(JCNewClass tree) {
412             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
413             sr.mergeWith(csp(tree.encl));
414             sr.mergeWith(csp(tree.clazz));
415             sr.mergeWith(csp(tree.args));
416             sr.mergeWith(csp(tree.def));
417             result = sr;
418         }
419 
420         public void visitNewArray(JCNewArray tree) {
421             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
422             sr.mergeWith(csp(tree.elemtype));
423             sr.mergeWith(csp(tree.dims));
424             sr.mergeWith(csp(tree.elems));
425             result = sr;
426         }
427 
428         public void visitParens(JCParens tree) {
429             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
430             sr.mergeWith(csp(tree.expr));
431             result = sr;
432         }
433 
434         public void visitAssign(JCAssign tree) {
435             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
436             sr.mergeWith(csp(tree.lhs));
437             sr.mergeWith(csp(tree.rhs));
438             result = sr;
439         }
440 
441         public void visitAssignop(JCAssignOp tree) {
442             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
443             sr.mergeWith(csp(tree.lhs));
444             sr.mergeWith(csp(tree.rhs));
445             result = sr;
446         }
447 
448         public void visitUnary(JCUnary tree) {
449             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
450             sr.mergeWith(csp(tree.arg));
451             result = sr;
452         }
453 
454         public void visitBinary(JCBinary tree) {
455             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
456             sr.mergeWith(csp(tree.lhs));
457             sr.mergeWith(csp(tree.rhs));
458             result = sr;
459         }
460 
461         public void visitTypeCast(JCTypeCast tree) {
462             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
463             sr.mergeWith(csp(tree.clazz));
464             sr.mergeWith(csp(tree.expr));
465             result = sr;
466         }
467 
468         public void visitTypeTest(JCInstanceOf tree) {
469             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
470             sr.mergeWith(csp(tree.expr));
471             sr.mergeWith(csp(tree.clazz));
472             result = sr;
473         }
474 
475         public void visitIndexed(JCArrayAccess tree) {
476             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
477             sr.mergeWith(csp(tree.indexed));
478             sr.mergeWith(csp(tree.index));
479             result = sr;
480         }
481 
482         public void visitSelect(JCFieldAccess tree) {
483             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
484             sr.mergeWith(csp(tree.selected));
485             result = sr;
486         }
487 
488         public void visitIdent(JCIdent tree) {
489             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
490             result = sr;
491         }
492 
493         public void visitLiteral(JCLiteral tree) {
494             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
495             result = sr;
496         }
497 
498         public void visitTypeIdent(JCPrimitiveTypeTree tree) {
499             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
500             result = sr;
501         }
502 
503         public void visitTypeArray(JCArrayTypeTree tree) {
504             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
505             sr.mergeWith(csp(tree.elemtype));
506             result = sr;
507         }
508 
509         public void visitTypeApply(JCTypeApply tree) {
510             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
511             sr.mergeWith(csp(tree.clazz));
512             sr.mergeWith(csp(tree.arguments));
513             result = sr;
514         }
515 
516         @Override
517         public void visitLetExpr(LetExpr tree) {
518             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
519             sr.mergeWith(csp(tree.defs));
520             sr.mergeWith(csp(tree.expr));
521             result = sr;
522         }
523 
524         public void visitTypeParameter(JCTypeParameter tree) {
525             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
526             sr.mergeWith(csp(tree.bounds));
527             result = sr;
528         }
529 
530         @Override
531         public void visitTypeUnion(JCTypeUnion tree) {
532             SourceRange sr = new SourceRange(startPos(tree), endPos(tree));
533             sr.mergeWith(csp(tree.alternatives));
534             result = sr;
535         }
536 
537         public void visitWildcard(JCWildcard tree) {
538             result = null;
539         }
540 
541         public void visitErroneous(JCErroneous tree) {
542             result = null;
543         }
544 
545         public void visitTree(JCTree tree) {
546             Assert.error();
547         }
548 
549         /** The start position of given tree.
550          */
551         public int startPos(JCTree tree) {
552             if (tree == null) return Position.NOPOS;
553             return TreeInfo.getStartPos(tree);
554         }
555 
556         /** The end position of given tree, if it has
557          *  defined endpos, NOPOS otherwise.
558          */
559         public int endPos(JCTree tree) {
560             if (tree == null) return Position.NOPOS;
561             return TreeInfo.getEndPos(tree, endPosTable);
562         }
563     }
564 
565     /** This class contains a CharacterRangeTableEntry.
566      */
567     static class CRTEntry {
568 
569         /** A tree or a list of trees to obtain source positions.
570          */
571         Object tree;
572 
573         /** The flags described in the CharacterRangeTable spec.
574          */
575         int flags;
576 
577         /** The starting code position of this entry.
578          */
579         int startPc;
580 
581         /** The ending code position of this entry.
582          */
583         int endPc;
584 
585         /** Constructor */
586         CRTEntry(Object tree, int flags, int startPc, int endPc) {
587             this.tree = tree;
588             this.flags = flags;
589             this.startPc = startPc;
590             this.endPc = endPc;
591         }
592     }
593 
594 
595     /** This class contains source positions
596      *  for some tree or list of trees.
597      */
598     static class SourceRange {
599 
600         /** The starting source position.
601          */
602         int startPos;
603 
604         /** The ending source position.
605          */
606         int endPos;
607 
608         /** Constructor */
609         SourceRange() {
610             startPos = Position.NOPOS;
611             endPos = Position.NOPOS;
612         }
613 
614         /** Constructor */
615         SourceRange(int startPos, int endPos) {
616             this.startPos = startPos;
617             this.endPos = endPos;
618         }
619 
620         /** Compare the starting and the ending positions
621          *  of the source range and combines them assigning
622          *  the widest range to this.
623          */
624         SourceRange mergeWith(SourceRange sr) {
625             if (sr == null) return this;
626             if (startPos == Position.NOPOS)
627                 startPos = sr.startPos;
628             else if (sr.startPos != Position.NOPOS)
629                 startPos = (startPos &lt; sr.startPos ? startPos : sr.startPos);
630             if (endPos == Position.NOPOS)
631                 endPos = sr.endPos;
632             else if (sr.endPos != Position.NOPOS)
633                 endPos = (endPos &gt; sr.endPos ? endPos : sr.endPos);
634             return this;
635         }
636     }
637 
638 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 
  50 import com.sun.source.tree.CaseTree.CaseKind;
  51 import com.sun.source.tree.ModuleTree.ModuleKind;
  52 import com.sun.tools.javac.code.Directive.ExportsDirective;
  53 import com.sun.tools.javac.code.Directive.OpensDirective;
  54 import com.sun.tools.javac.code.Type.ModuleType;
  55 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.PolyKind;
  56 
  57 /**
  58  * Root class for abstract syntax tree nodes. It provides definitions
  59  * for specific tree nodes as subclasses nested inside.
  60  *
  61  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  62  * only tree fields for the syntactic subcomponents of the node.  Some
  63  * classes that represent identifier uses or definitions also define a
  64  * Symbol field that denotes the represented identifier.  Classes for
  65  * non-local jumps also carry the jump target as a field.  The root
  66  * class Tree itself defines fields for the tree&#39;s type and position.
  67  * No other fields are kept in a tree node; instead parameters are
  68  * passed to methods accessing the node.
  69  *
  70  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  71  * method defined in subclasses is `visit&#39; which applies a given
  72  * visitor to the tree. The actual tree processing is done by visitor
  73  * classes in other packages. The abstract class Visitor, as well as
  74  * an Factory interface for trees, are defined as inner classes in
  75  * Tree.
  76  *
  77  * &lt;p&gt;To avoid ambiguities with the Tree API in com.sun.source all sub
  78  * classes should, by convention, start with JC (javac).
  79  *
  80  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  81  * If you write code that depends on this, you do so at your own risk.
  82  * This code and its internal interfaces are subject to change or
  83  * deletion without notice.&lt;/b&gt;
  84  *
  85  * @see TreeMaker
  86  * @see TreeInfo
  87  * @see TreeTranslator
  88  * @see Pretty
  89  */
  90 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
  91 
  92     /* Tree tag values, identifying kinds of trees */
  93     public enum Tag {
  94         /** For methods that return an invalid tag if a given condition is not met
  95          */
  96         NO_TAG,
  97 
  98         /** Toplevel nodes, of type TopLevel, representing entire source files.
  99         */
 100         TOPLEVEL,
 101 
 102         /** Package level definitions.
 103          */
 104         PACKAGEDEF,
 105 
 106         /** Import clauses, of type Import.
 107          */
 108         IMPORT,
 109 
 110         /** Class definitions, of type ClassDef.
 111          */
 112         CLASSDEF,
 113 
 114         /** Method definitions, of type MethodDef.
 115          */
 116         METHODDEF,
 117 
 118         /** Variable definitions, of type VarDef.
 119          */
 120         VARDEF,
 121 
 122         /** The no-op statement &quot;;&quot;, of type Skip
 123          */
 124         SKIP,
 125 
 126         /** Blocks, of type Block.
 127          */
 128         BLOCK,
 129 
 130         /** Do-while loops, of type DoLoop.
 131          */
 132         DOLOOP,
 133 
 134         /** While-loops, of type WhileLoop.
 135          */
 136         WHILELOOP,
 137 
 138         /** For-loops, of type ForLoop.
 139          */
 140         FORLOOP,
 141 
 142         /** Foreach-loops, of type ForeachLoop.
 143          */
 144         FOREACHLOOP,
 145 
 146         /** Labelled statements, of type Labelled.
 147          */
 148         LABELLED,
 149 
 150         /** Switch statements, of type Switch.
 151          */
 152         SWITCH,
 153 
 154         /** Case parts in switch statements/expressions, of type Case.
 155          */
 156         CASE,
 157 
 158         /** Switch expression statements, of type Switch.
 159          */
 160         SWITCH_EXPRESSION,
 161 
 162         /** Synchronized statements, of type Synchonized.
 163          */
 164         SYNCHRONIZED,
 165 
 166         /** Try statements, of type Try.
 167          */
 168         TRY,
 169 
 170         /** Catch clauses in try statements, of type Catch.
 171          */
 172         CATCH,
 173 
 174         /** Conditional expressions, of type Conditional.
 175          */
 176         CONDEXPR,
 177 
 178         /** Conditional statements, of type If.
 179          */
 180         IF,
 181 
 182         /** Expression statements, of type Exec.
 183          */
 184         EXEC,
 185 
 186         /** Break statements, of type Break.
 187          */
 188         BREAK,
 189 
 190         /** Continue statements, of type Continue.
 191          */
 192         CONTINUE,
 193 
 194         /** Return statements, of type Return.
 195          */
 196         RETURN,
 197 
 198         /** Throw statements, of type Throw.
 199          */
 200         THROW,
 201 
 202         /** Assert statements, of type Assert.
 203          */
 204         ASSERT,
 205 
 206         /** Method invocation expressions, of type Apply.
 207          */
 208         APPLY,
 209 
 210         /** Class instance creation expressions, of type NewClass.
 211          */
 212         NEWCLASS,
 213 
 214         /** Array creation expressions, of type NewArray.
 215          */
 216         NEWARRAY,
 217 
 218         /** Lambda expression, of type Lambda.
 219          */
 220         LAMBDA,
 221 
 222         /** Parenthesized subexpressions, of type Parens.
 223          */
 224         PARENS,
 225 
 226         /** Assignment expressions, of type Assign.
 227          */
 228         ASSIGN,
 229 
 230         /** Type cast expressions, of type TypeCast.
 231          */
 232         TYPECAST,
 233 
 234         /** Type test expressions, of type TypeTest.
 235          */
 236         TYPETEST,
 237 
 238         /** Indexed array expressions, of type Indexed.
 239          */
 240         INDEXED,
 241 
 242         /** Selections, of type Select.
 243          */
 244         SELECT,
 245 
 246         /** Member references, of type Reference.
 247          */
 248         REFERENCE,
 249 
 250         /** Simple identifiers, of type Ident.
 251          */
 252         IDENT,
 253 
 254         /** Literals, of type Literal.
 255          */
 256         LITERAL,
 257 
 258         /** Basic type identifiers, of type TypeIdent.
 259          */
 260         TYPEIDENT,
 261 
 262         /** Array types, of type TypeArray.
 263          */
 264         TYPEARRAY,
 265 
 266         /** Parameterized types, of type TypeApply.
 267          */
 268         TYPEAPPLY,
 269 
 270         /** Union types, of type TypeUnion.
 271          */
 272         TYPEUNION,
 273 
 274         /** Intersection types, of type TypeIntersection.
 275          */
 276         TYPEINTERSECTION,
 277 
 278         /** Formal type parameters, of type TypeParameter.
 279          */
 280         TYPEPARAMETER,
 281 
 282         /** Type argument.
 283          */
 284         WILDCARD,
 285 
 286         /** Bound kind: extends, super, exact, or unbound
 287          */
 288         TYPEBOUNDKIND,
 289 
 290         /** metadata: Annotation.
 291          */
 292         ANNOTATION,
 293 
 294         /** metadata: Type annotation.
 295          */
 296         TYPE_ANNOTATION,
 297 
 298         /** metadata: Modifiers
 299          */
 300         MODIFIERS,
 301 
 302         /** An annotated type tree.
 303          */
 304         ANNOTATED_TYPE,
 305 
 306         /** Error trees, of type Erroneous.
 307          */
 308         ERRONEOUS,
 309 
 310         /** Unary operators, of type Unary.
 311          */
 312         POS,                             // +
 313         NEG,                             // -
 314         NOT,                             // !
 315         COMPL,                           // ~
 316         PREINC,                          // ++ _
 317         PREDEC,                          // -- _
 318         POSTINC,                         // _ ++
 319         POSTDEC,                         // _ --
 320 
 321         /** unary operator for null reference checks, only used internally.
 322          */
 323         NULLCHK,
 324 
 325         /** Binary operators, of type Binary.
 326          */
 327         OR,                              // ||
 328         AND,                             // &amp;&amp;
 329         BITOR,                           // |
 330         BITXOR,                          // ^
 331         BITAND,                          // &amp;
 332         EQ,                              // ==
 333         NE,                              // !=
 334         LT,                              // &lt;
 335         GT,                              // &gt;
 336         LE,                              // &lt;=
 337         GE,                              // &gt;=
 338         SL,                              // &lt;&lt;
 339         SR,                              // &gt;&gt;
 340         USR,                             // &gt;&gt;&gt;
 341         PLUS,                            // +
 342         MINUS,                           // -
 343         MUL,                             // *
 344         DIV,                             // /
 345         MOD,                             // %
 346 
 347         /** Assignment operators, of type Assignop.
 348          */
 349         BITOR_ASG(BITOR),                // |=
 350         BITXOR_ASG(BITXOR),              // ^=
 351         BITAND_ASG(BITAND),              // &amp;=
 352 
 353         SL_ASG(SL),                      // &lt;&lt;=
 354         SR_ASG(SR),                      // &gt;&gt;=
 355         USR_ASG(USR),                    // &gt;&gt;&gt;=
 356         PLUS_ASG(PLUS),                  // +=
 357         MINUS_ASG(MINUS),                // -=
 358         MUL_ASG(MUL),                    // *=
 359         DIV_ASG(DIV),                    // /=
 360         MOD_ASG(MOD),                    // %=
 361 
 362         MODULEDEF,
 363         EXPORTS,
 364         OPENS,
 365         PROVIDES,
 366         REQUIRES,
 367         USES,
 368 
 369         /** A synthetic let expression, of type LetExpr.
 370          */
 371         LETEXPR;                         // ala scheme
 372 
 373         private final Tag noAssignTag;
 374 
 375         private static final int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
 376 
 377         private Tag(Tag noAssignTag) {
 378             this.noAssignTag = noAssignTag;
 379         }
 380 
 381         private Tag() {
 382             this(null);
 383         }
 384 
 385         public static int getNumberOfOperators() {
 386             return numberOfOperators;
 387         }
 388 
 389         public Tag noAssignOp() {
 390             if (noAssignTag != null)
 391                 return noAssignTag;
 392             throw new AssertionError(&quot;noAssignOp() method is not available for non assignment tags&quot;);
 393         }
 394 
 395         public boolean isPostUnaryOp() {
 396             return (this == POSTINC || this == POSTDEC);
 397         }
 398 
 399         public boolean isIncOrDecUnaryOp() {
 400             return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
 401         }
 402 
 403         public boolean isAssignop() {
 404             return noAssignTag != null;
 405         }
 406 
 407         public int operatorIndex() {
 408             return (this.ordinal() - POS.ordinal());
 409         }
 410     }
 411 
 412     /* The (encoded) position in the source file. @see util.Position.
 413      */
 414     public int pos;
 415 
 416     /* The type of this node.
 417      */
 418     public Type type;
 419 
 420     /* The tag of this node -- one of the constants declared above.
 421      */
 422     public abstract Tag getTag();
 423 
 424     /* Returns true if the tag of this node is equals to tag.
 425      */
 426     public boolean hasTag(Tag tag) {
 427         return tag == getTag();
 428     }
 429 
 430     /** Convert a tree to a pretty-printed string. */
 431     @Override
 432     public String toString() {
 433         StringWriter s = new StringWriter();
 434         try {
 435             new Pretty(s, false).printExpr(this);
 436         }
 437         catch (IOException e) {
 438             // should never happen, because StringWriter is defined
 439             // never to throw any IOExceptions
 440             throw new AssertionError(e);
 441         }
 442         return s.toString();
 443     }
 444 
 445     /** Set position field and return this tree.
 446      */
 447     public JCTree setPos(int pos) {
 448         this.pos = pos;
 449         return this;
 450     }
 451 
 452     /** Set type field and return this tree.
 453      */
 454     public JCTree setType(Type type) {
 455         this.type = type;
 456         return this;
 457     }
 458 
 459     /** Visit this tree with a given visitor.
 460      */
 461     public abstract void accept(Visitor v);
 462 
 463     @DefinedBy(Api.COMPILER_TREE)
 464     public abstract &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d);
 465 
 466     /** Return a shallow copy of this tree.
 467      */
 468     @Override
 469     public Object clone() {
 470         try {
 471             return super.clone();
 472         } catch(CloneNotSupportedException e) {
 473             throw new RuntimeException(e);
 474         }
 475     }
 476 
 477     /** Get a default position for this tree node.
 478      */
 479     public DiagnosticPosition pos() {
 480         return this;
 481     }
 482 
 483     // for default DiagnosticPosition
 484     public JCTree getTree() {
 485         return this;
 486     }
 487 
 488     // for default DiagnosticPosition
 489     public int getStartPosition() {
 490         return TreeInfo.getStartPos(this);
 491     }
 492 
 493     // for default DiagnosticPosition
 494     public int getPreferredPosition() {
 495         return pos;
 496     }
 497 
 498     // for default DiagnosticPosition
 499     public int getEndPosition(EndPosTable endPosTable) {
 500         return TreeInfo.getEndPos(this, endPosTable);
 501     }
 502 
 503     /**
 504      * Everything in one source file is kept in a {@linkplain JCCompilationUnit} structure.
 505      */
 506     public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
 507         /** All definitions in this file (ClassDef, Import, and Skip) */
 508         public List&lt;JCTree&gt; defs;
 509         /** The source file name. */
 510         public JavaFileObject sourcefile;
 511         /** The module to which this compilation unit belongs. */
 512         public ModuleSymbol modle;
 513         /** The location in which this compilation unit was found. */
 514         public Location locn;
 515         /** The package to which this compilation unit belongs. */
 516         public PackageSymbol packge;
 517         /** A scope containing top level classes. */
 518         public WriteableScope toplevelScope;
 519         /** A scope for all named imports. */
 520         public NamedImportScope namedImportScope;
 521         /** A scope for all import-on-demands. */
 522         public StarImportScope starImportScope;
 523         /** Line starting positions, defined only if option -g is set. */
 524         public Position.LineMap lineMap = null;
 525         /** A table that stores all documentation comments indexed by the tree
 526          * nodes they refer to. defined only if option -s is set. */
 527         public DocCommentTable docComments = null;
 528         /* An object encapsulating ending positions of source ranges indexed by
 529          * the tree nodes they belong to. Defined only if option -Xjcov is set. */
 530         public EndPosTable endPositions = null;
 531         protected JCCompilationUnit(List&lt;JCTree&gt; defs) {
 532             this.defs = defs;
 533         }
 534         @Override
 535         public void accept(Visitor v) { v.visitTopLevel(this); }
 536 
 537         @DefinedBy(Api.COMPILER_TREE)
 538         public Kind getKind() { return Kind.COMPILATION_UNIT; }
 539 
 540         public JCModuleDecl getModuleDecl() {
 541             for (JCTree tree : defs) {
 542                 if (tree.hasTag(MODULEDEF)) {
 543                     return (JCModuleDecl) tree;
 544                 }
 545             }
 546 
 547             return null;
 548         }
 549 
 550         @DefinedBy(Api.COMPILER_TREE)
 551         public JCPackageDecl getPackage() {
 552             // PackageDecl must be the first entry if it exists
 553             if (!defs.isEmpty() &amp;&amp; defs.head.hasTag(PACKAGEDEF))
 554                 return (JCPackageDecl)defs.head;
 555             return null;
 556         }
 557         @DefinedBy(Api.COMPILER_TREE)
 558         public List&lt;JCAnnotation&gt; getPackageAnnotations() {
 559             JCPackageDecl pd = getPackage();
 560             return pd != null ? pd.getAnnotations() : List.nil();
 561         }
 562         @DefinedBy(Api.COMPILER_TREE)
 563         public ExpressionTree getPackageName() {
 564             JCPackageDecl pd = getPackage();
 565             return pd != null ? pd.getPackageName() : null;
 566         }
 567 
 568         @DefinedBy(Api.COMPILER_TREE)
 569         public List&lt;JCImport&gt; getImports() {
 570             ListBuffer&lt;JCImport&gt; imports = new ListBuffer&lt;&gt;();
 571             for (JCTree tree : defs) {
 572                 if (tree.hasTag(IMPORT))
 573                     imports.append((JCImport)tree);
 574                 else if (!tree.hasTag(PACKAGEDEF) &amp;&amp; !tree.hasTag(SKIP))
 575                     break;
 576             }
 577             return imports.toList();
 578         }
 579         @DefinedBy(Api.COMPILER_TREE)
 580         public JavaFileObject getSourceFile() {
 581             return sourcefile;
 582         }
 583         @DefinedBy(Api.COMPILER_TREE)
 584         public Position.LineMap getLineMap() {
 585             return lineMap;
 586         }
 587         @DefinedBy(Api.COMPILER_TREE)
 588         public List&lt;JCTree&gt; getTypeDecls() {
 589             List&lt;JCTree&gt; typeDefs;
 590             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
 591                 if (!typeDefs.head.hasTag(PACKAGEDEF) &amp;&amp; !typeDefs.head.hasTag(IMPORT))
 592                     break;
 593             return typeDefs;
 594         }
 595         @Override @DefinedBy(Api.COMPILER_TREE)
 596         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 597             return v.visitCompilationUnit(this, d);
 598         }
 599 
 600         @Override
 601         public Tag getTag() {
 602             return TOPLEVEL;
 603         }
 604     }
 605 
 606     /**
 607      * Package definition.
 608      */
 609     public static class JCPackageDecl extends JCTree implements PackageTree {
 610         public List&lt;JCAnnotation&gt; annotations;
 611         /** The tree representing the package clause. */
 612         public JCExpression pid;
 613         public PackageSymbol packge;
 614         public JCPackageDecl(List&lt;JCAnnotation&gt; annotations, JCExpression pid) {
 615             this.annotations = annotations;
 616             this.pid = pid;
 617         }
 618         @Override
 619         public void accept(Visitor v) { v.visitPackageDef(this); }
 620         @DefinedBy(Api.COMPILER_TREE)
 621         public Kind getKind() {
 622             return Kind.PACKAGE;
 623         }
 624         @DefinedBy(Api.COMPILER_TREE)
 625         public List&lt;JCAnnotation&gt; getAnnotations() {
 626             return annotations;
 627         }
 628         @DefinedBy(Api.COMPILER_TREE)
 629         public JCExpression getPackageName() {
 630             return pid;
 631         }
 632         @Override @DefinedBy(Api.COMPILER_TREE)
 633         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 634             return v.visitPackage(this, d);
 635         }
 636         @Override
 637         public Tag getTag() {
 638             return PACKAGEDEF;
 639         }
 640     }
 641 
 642     /**
 643      * An import clause.
 644      */
 645     public static class JCImport extends JCTree implements ImportTree {
 646         public boolean staticImport;
 647         /** The imported class(es). */
 648         public JCTree qualid;
 649         public com.sun.tools.javac.code.Scope importScope;
 650         protected JCImport(JCTree qualid, boolean importStatic) {
 651             this.qualid = qualid;
 652             this.staticImport = importStatic;
 653         }
 654         @Override
 655         public void accept(Visitor v) { v.visitImport(this); }
 656 
 657         @DefinedBy(Api.COMPILER_TREE)
 658         public boolean isStatic() { return staticImport; }
 659         @DefinedBy(Api.COMPILER_TREE)
 660         public JCTree getQualifiedIdentifier() { return qualid; }
 661 
 662         @DefinedBy(Api.COMPILER_TREE)
 663         public Kind getKind() { return Kind.IMPORT; }
 664         @Override @DefinedBy(Api.COMPILER_TREE)
 665         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 666             return v.visitImport(this, d);
 667         }
 668 
 669         @Override
 670         public Tag getTag() {
 671             return IMPORT;
 672         }
 673     }
 674 
 675     public static abstract class JCStatement extends JCTree implements StatementTree {
 676         @Override
 677         public JCStatement setType(Type type) {
 678             super.setType(type);
 679             return this;
 680         }
 681         @Override
 682         public JCStatement setPos(int pos) {
 683             super.setPos(pos);
 684             return this;
 685         }
 686     }
 687 
 688     public static abstract class JCExpression extends JCTree implements ExpressionTree {
 689         @Override
 690         public JCExpression setType(Type type) {
 691             super.setType(type);
 692             return this;
 693         }
 694         @Override
 695         public JCExpression setPos(int pos) {
 696             super.setPos(pos);
 697             return this;
 698         }
 699 
 700         public boolean isPoly() { return false; }
 701         public boolean isStandalone() { return true; }
 702     }
 703 
 704     /**
 705      * Common supertype for all poly expression trees (lambda, method references,
 706      * conditionals, method and constructor calls)
 707      */
 708     public static abstract class JCPolyExpression extends JCExpression {
 709 
 710         /**
 711          * A poly expression can only be truly &#39;poly&#39; in certain contexts
 712          */
 713         public enum PolyKind {
 714             /** poly expression to be treated as a standalone expression */
 715             STANDALONE,
 716             /** true poly expression */
 717             POLY
 718         }
 719 
 720         /** is this poly expression a &#39;true&#39; poly expression? */
 721         public PolyKind polyKind;
 722 
 723         @Override public boolean isPoly() { return polyKind == PolyKind.POLY; }
 724         @Override public boolean isStandalone() { return polyKind == PolyKind.STANDALONE; }
 725     }
 726 
 727     /**
 728      * Common supertype for all functional expression trees (lambda and method references)
 729      */
 730     public static abstract class JCFunctionalExpression extends JCPolyExpression {
 731 
 732         public JCFunctionalExpression() {
 733             //a functional expression is always a &#39;true&#39; poly
 734             polyKind = PolyKind.POLY;
 735         }
 736 
 737         /** list of target types inferred for this functional expression. */
 738         public Type target;
 739 
 740         public Type getDescriptorType(Types types) {
 741             return target != null ? types.findDescriptorType(target) : types.createErrorType(null);
 742         }
 743     }
 744 
 745     /**
 746      * A class definition.
 747      */
 748     public static class JCClassDecl extends JCStatement implements ClassTree {
 749         /** the modifiers */
 750         public JCModifiers mods;
 751         /** the name of the class */
 752         public Name name;
 753         /** formal class parameters */
 754         public List&lt;JCTypeParameter&gt; typarams;
 755         /** the classes this class extends */
 756         public JCExpression extending;
 757         /** the interfaces implemented by this class */
 758         public List&lt;JCExpression&gt; implementing;
 759         /** all variables and methods defined in this class */
 760         public List&lt;JCTree&gt; defs;
 761         /** the symbol */
 762         public ClassSymbol sym;
 763         protected JCClassDecl(JCModifiers mods,
 764                            Name name,
 765                            List&lt;JCTypeParameter&gt; typarams,
 766                            JCExpression extending,
 767                            List&lt;JCExpression&gt; implementing,
 768                            List&lt;JCTree&gt; defs,
 769                            ClassSymbol sym)
 770         {
 771             this.mods = mods;
 772             this.name = name;
 773             this.typarams = typarams;
 774             this.extending = extending;
 775             this.implementing = implementing;
 776             this.defs = defs;
 777             this.sym = sym;
 778         }
 779         @Override
 780         public void accept(Visitor v) { v.visitClassDef(this); }
 781 
 782         @DefinedBy(Api.COMPILER_TREE)
 783         public Kind getKind() {
 784             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 785                 return Kind.ANNOTATION_TYPE;
 786             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 787                 return Kind.INTERFACE;
 788             else if ((mods.flags &amp; Flags.ENUM) != 0)
 789                 return Kind.ENUM;
 790             else
 791                 return Kind.CLASS;
 792         }
 793 
 794         @DefinedBy(Api.COMPILER_TREE)
 795         public JCModifiers getModifiers() { return mods; }
 796         @DefinedBy(Api.COMPILER_TREE)
 797         public Name getSimpleName() { return name; }
 798         @DefinedBy(Api.COMPILER_TREE)
 799         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 800             return typarams;
 801         }
 802         @DefinedBy(Api.COMPILER_TREE)
 803         public JCExpression getExtendsClause() { return extending; }
 804         @DefinedBy(Api.COMPILER_TREE)
 805         public List&lt;JCExpression&gt; getImplementsClause() {
 806             return implementing;
 807         }
 808         @DefinedBy(Api.COMPILER_TREE)
 809         public List&lt;JCTree&gt; getMembers() {
 810             return defs;
 811         }
 812         @Override @DefinedBy(Api.COMPILER_TREE)
 813         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 814             return v.visitClass(this, d);
 815         }
 816 
 817         @Override
 818         public Tag getTag() {
 819             return CLASSDEF;
 820         }
 821     }
 822 
 823     /**
 824      * A method definition.
 825      */
 826     public static class JCMethodDecl extends JCTree implements MethodTree {
 827         /** method modifiers */
 828         public JCModifiers mods;
 829         /** method name */
 830         public Name name;
 831         /** type of method return value */
 832         public JCExpression restype;
 833         /** type parameters */
 834         public List&lt;JCTypeParameter&gt; typarams;
 835         /** receiver parameter */
 836         public JCVariableDecl recvparam;
 837         /** value parameters */
 838         public List&lt;JCVariableDecl&gt; params;
 839         /** exceptions thrown by this method */
 840         public List&lt;JCExpression&gt; thrown;
 841         /** statements in the method */
 842         public JCBlock body;
 843         /** default value, for annotation types */
 844         public JCExpression defaultValue;
 845         /** method symbol */
 846         public MethodSymbol sym;
 847         protected JCMethodDecl(JCModifiers mods,
 848                             Name name,
 849                             JCExpression restype,
 850                             List&lt;JCTypeParameter&gt; typarams,
 851                             JCVariableDecl recvparam,
 852                             List&lt;JCVariableDecl&gt; params,
 853                             List&lt;JCExpression&gt; thrown,
 854                             JCBlock body,
 855                             JCExpression defaultValue,
 856                             MethodSymbol sym)
 857         {
 858             this.mods = mods;
 859             this.name = name;
 860             this.restype = restype;
 861             this.typarams = typarams;
 862             this.params = params;
 863             this.recvparam = recvparam;
 864             // TODO: do something special if the given type is null?
 865             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 866             this.thrown = thrown;
 867             this.body = body;
 868             this.defaultValue = defaultValue;
 869             this.sym = sym;
 870         }
 871         @Override
 872         public void accept(Visitor v) { v.visitMethodDef(this); }
 873 
 874         @DefinedBy(Api.COMPILER_TREE)
 875         public Kind getKind() { return Kind.METHOD; }
 876         @DefinedBy(Api.COMPILER_TREE)
 877         public JCModifiers getModifiers() { return mods; }
 878         @DefinedBy(Api.COMPILER_TREE)
 879         public Name getName() { return name; }
 880         @DefinedBy(Api.COMPILER_TREE)
 881         public JCTree getReturnType() { return restype; }
 882         @DefinedBy(Api.COMPILER_TREE)
 883         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 884             return typarams;
 885         }
 886         @DefinedBy(Api.COMPILER_TREE)
 887         public List&lt;JCVariableDecl&gt; getParameters() {
 888             return params;
 889         }
 890         @DefinedBy(Api.COMPILER_TREE)
 891         public JCVariableDecl getReceiverParameter() { return recvparam; }
 892         @DefinedBy(Api.COMPILER_TREE)
 893         public List&lt;JCExpression&gt; getThrows() {
 894             return thrown;
 895         }
 896         @DefinedBy(Api.COMPILER_TREE)
 897         public JCBlock getBody() { return body; }
 898         @DefinedBy(Api.COMPILER_TREE)
 899         public JCTree getDefaultValue() { // for annotation types
 900             return defaultValue;
 901         }
 902         @Override @DefinedBy(Api.COMPILER_TREE)
 903         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 904             return v.visitMethod(this, d);
 905         }
 906 
 907         @Override
 908         public Tag getTag() {
 909             return METHODDEF;
 910         }
 911   }
 912 
 913     /**
 914      * A variable definition.
 915      */
 916     public static class JCVariableDecl extends JCStatement implements VariableTree {
 917         /** variable modifiers */
 918         public JCModifiers mods;
 919         /** variable name */
 920         public Name name;
 921         /** variable name expression */
 922         public JCExpression nameexpr;
 923         /** type of the variable */
 924         public JCExpression vartype;
 925         /** variable&#39;s initial value */
 926         public JCExpression init;
 927         /** symbol */
 928         public VarSymbol sym;
 929         /** explicit start pos */
 930         public int startPos = Position.NOPOS;
 931 
 932         protected JCVariableDecl(JCModifiers mods,
 933                          Name name,
 934                          JCExpression vartype,
 935                          JCExpression init,
 936                          VarSymbol sym) {
 937             this.mods = mods;
 938             this.name = name;
 939             this.vartype = vartype;
 940             this.init = init;
 941             this.sym = sym;
 942         }
 943 
 944         protected JCVariableDecl(JCModifiers mods,
 945                          JCExpression nameexpr,
 946                          JCExpression vartype) {
 947             this(mods, null, vartype, null, null);
 948             this.nameexpr = nameexpr;
 949             if (nameexpr.hasTag(Tag.IDENT)) {
 950                 this.name = ((JCIdent)nameexpr).name;
 951             } else {
 952                 // Only other option is qualified name x.y.this;
 953                 this.name = ((JCFieldAccess)nameexpr).name;
 954             }
 955         }
 956 
 957         public boolean isImplicitlyTyped() {
 958             return vartype == null;
 959         }
 960 
 961         @Override
 962         public void accept(Visitor v) { v.visitVarDef(this); }
 963 
 964         @DefinedBy(Api.COMPILER_TREE)
 965         public Kind getKind() { return Kind.VARIABLE; }
 966         @DefinedBy(Api.COMPILER_TREE)
 967         public JCModifiers getModifiers() { return mods; }
 968         @DefinedBy(Api.COMPILER_TREE)
 969         public Name getName() { return name; }
 970         @DefinedBy(Api.COMPILER_TREE)
 971         public JCExpression getNameExpression() { return nameexpr; }
 972         @DefinedBy(Api.COMPILER_TREE)
 973         public JCTree getType() { return vartype; }
 974         @DefinedBy(Api.COMPILER_TREE)
 975         public JCExpression getInitializer() {
 976             return init;
 977         }
 978         @Override @DefinedBy(Api.COMPILER_TREE)
 979         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 980             return v.visitVariable(this, d);
 981         }
 982 
 983         @Override
 984         public Tag getTag() {
 985             return VARDEF;
 986         }
 987     }
 988 
 989     /**
 990      * A no-op statement &quot;;&quot;.
 991      */
 992     public static class JCSkip extends JCStatement implements EmptyStatementTree {
 993         protected JCSkip() {
 994         }
 995         @Override
 996         public void accept(Visitor v) { v.visitSkip(this); }
 997 
 998         @DefinedBy(Api.COMPILER_TREE)
 999         public Kind getKind() { return Kind.EMPTY_STATEMENT; }
1000         @Override @DefinedBy(Api.COMPILER_TREE)
1001         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1002             return v.visitEmptyStatement(this, d);
1003         }
1004 
1005         @Override
1006         public Tag getTag() {
1007             return SKIP;
1008         }
1009     }
1010 
1011     /**
1012      * A statement block.
1013      */
1014     public static class JCBlock extends JCStatement implements BlockTree {
1015         /** flags */
1016         public long flags;
1017         /** statements */
1018         public List&lt;JCStatement&gt; stats;
1019         /** Position of closing brace, optional. */
1020         public int endpos = Position.NOPOS;
1021         protected JCBlock(long flags, List&lt;JCStatement&gt; stats) {
1022             this.stats = stats;
1023             this.flags = flags;
1024         }
1025         @Override
1026         public void accept(Visitor v) { v.visitBlock(this); }
1027 
1028         @DefinedBy(Api.COMPILER_TREE)
1029         public Kind getKind() { return Kind.BLOCK; }
1030         @DefinedBy(Api.COMPILER_TREE)
1031         public List&lt;JCStatement&gt; getStatements() {
1032             return stats;
1033         }
1034         @DefinedBy(Api.COMPILER_TREE)
1035         public boolean isStatic() { return (flags &amp; Flags.STATIC) != 0; }
1036         @Override @DefinedBy(Api.COMPILER_TREE)
1037         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1038             return v.visitBlock(this, d);
1039         }
1040 
1041         @Override
1042         public Tag getTag() {
1043             return BLOCK;
1044         }
1045     }
1046 
1047     /**
1048      * A do loop
1049      */
1050     public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
1051         public JCStatement body;
1052         public JCExpression cond;
1053         protected JCDoWhileLoop(JCStatement body, JCExpression cond) {
1054             this.body = body;
1055             this.cond = cond;
1056         }
1057         @Override
1058         public void accept(Visitor v) { v.visitDoLoop(this); }
1059 
1060         @DefinedBy(Api.COMPILER_TREE)
1061         public Kind getKind() { return Kind.DO_WHILE_LOOP; }
1062         @DefinedBy(Api.COMPILER_TREE)
1063         public JCExpression getCondition() { return cond; }
1064         @DefinedBy(Api.COMPILER_TREE)
1065         public JCStatement getStatement() { return body; }
1066         @Override @DefinedBy(Api.COMPILER_TREE)
1067         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1068             return v.visitDoWhileLoop(this, d);
1069         }
1070 
1071         @Override
1072         public Tag getTag() {
1073             return DOLOOP;
1074         }
1075     }
1076 
1077     /**
1078      * A while loop
1079      */
1080     public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
1081         public JCExpression cond;
1082         public JCStatement body;
1083         protected JCWhileLoop(JCExpression cond, JCStatement body) {
1084             this.cond = cond;
1085             this.body = body;
1086         }
1087         @Override
1088         public void accept(Visitor v) { v.visitWhileLoop(this); }
1089 
1090         @DefinedBy(Api.COMPILER_TREE)
1091         public Kind getKind() { return Kind.WHILE_LOOP; }
1092         @DefinedBy(Api.COMPILER_TREE)
1093         public JCExpression getCondition() { return cond; }
1094         @DefinedBy(Api.COMPILER_TREE)
1095         public JCStatement getStatement() { return body; }
1096         @Override @DefinedBy(Api.COMPILER_TREE)
1097         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1098             return v.visitWhileLoop(this, d);
1099         }
1100 
1101         @Override
1102         public Tag getTag() {
1103             return WHILELOOP;
1104         }
1105     }
1106 
1107     /**
1108      * A for loop.
1109      */
1110     public static class JCForLoop extends JCStatement implements ForLoopTree {
1111         public List&lt;JCStatement&gt; init;
1112         public JCExpression cond;
1113         public List&lt;JCExpressionStatement&gt; step;
1114         public JCStatement body;
1115         protected JCForLoop(List&lt;JCStatement&gt; init,
1116                           JCExpression cond,
1117                           List&lt;JCExpressionStatement&gt; update,
1118                           JCStatement body)
1119         {
1120             this.init = init;
1121             this.cond = cond;
1122             this.step = update;
1123             this.body = body;
1124         }
1125         @Override
1126         public void accept(Visitor v) { v.visitForLoop(this); }
1127 
1128         @DefinedBy(Api.COMPILER_TREE)
1129         public Kind getKind() { return Kind.FOR_LOOP; }
1130         @DefinedBy(Api.COMPILER_TREE)
1131         public JCExpression getCondition() { return cond; }
1132         @DefinedBy(Api.COMPILER_TREE)
1133         public JCStatement getStatement() { return body; }
1134         @DefinedBy(Api.COMPILER_TREE)
1135         public List&lt;JCStatement&gt; getInitializer() {
1136             return init;
1137         }
1138         @DefinedBy(Api.COMPILER_TREE)
1139         public List&lt;JCExpressionStatement&gt; getUpdate() {
1140             return step;
1141         }
1142         @Override @DefinedBy(Api.COMPILER_TREE)
1143         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1144             return v.visitForLoop(this, d);
1145         }
1146 
1147         @Override
1148         public Tag getTag() {
1149             return FORLOOP;
1150         }
1151     }
1152 
1153     /**
1154      * The enhanced for loop.
1155      */
1156     public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
1157         public JCVariableDecl var;
1158         public JCExpression expr;
1159         public JCStatement body;
1160         protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
1161             this.var = var;
1162             this.expr = expr;
1163             this.body = body;
1164         }
1165         @Override
1166         public void accept(Visitor v) { v.visitForeachLoop(this); }
1167 
1168         @DefinedBy(Api.COMPILER_TREE)
1169         public Kind getKind() { return Kind.ENHANCED_FOR_LOOP; }
1170         @DefinedBy(Api.COMPILER_TREE)
1171         public JCVariableDecl getVariable() { return var; }
1172         @DefinedBy(Api.COMPILER_TREE)
1173         public JCExpression getExpression() { return expr; }
1174         @DefinedBy(Api.COMPILER_TREE)
1175         public JCStatement getStatement() { return body; }
1176         @Override @DefinedBy(Api.COMPILER_TREE)
1177         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1178             return v.visitEnhancedForLoop(this, d);
1179         }
1180         @Override
1181         public Tag getTag() {
1182             return FOREACHLOOP;
1183         }
1184     }
1185 
1186     /**
1187      * A labelled expression or statement.
1188      */
1189     public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
1190         public Name label;
1191         public JCStatement body;
1192         protected JCLabeledStatement(Name label, JCStatement body) {
1193             this.label = label;
1194             this.body = body;
1195         }
1196         @Override
1197         public void accept(Visitor v) { v.visitLabelled(this); }
1198         @DefinedBy(Api.COMPILER_TREE)
1199         public Kind getKind() { return Kind.LABELED_STATEMENT; }
1200         @DefinedBy(Api.COMPILER_TREE)
1201         public Name getLabel() { return label; }
1202         @DefinedBy(Api.COMPILER_TREE)
1203         public JCStatement getStatement() { return body; }
1204         @Override @DefinedBy(Api.COMPILER_TREE)
1205         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1206             return v.visitLabeledStatement(this, d);
1207         }
1208         @Override
1209         public Tag getTag() {
1210             return LABELLED;
1211         }
1212     }
1213 
1214     /**
1215      * A &quot;switch ( ) { }&quot; construction.
1216      */
1217     public static class JCSwitch extends JCStatement implements SwitchTree {
1218         public JCExpression selector;
1219         public List&lt;JCCase&gt; cases;
1220         protected JCSwitch(JCExpression selector, List&lt;JCCase&gt; cases) {
1221             this.selector = selector;
1222             this.cases = cases;
1223         }
1224         @Override
1225         public void accept(Visitor v) { v.visitSwitch(this); }
1226 
1227         @DefinedBy(Api.COMPILER_TREE)
1228         public Kind getKind() { return Kind.SWITCH; }
1229         @DefinedBy(Api.COMPILER_TREE)
1230         public JCExpression getExpression() { return selector; }
1231         @DefinedBy(Api.COMPILER_TREE)
1232         public List&lt;JCCase&gt; getCases() { return cases; }
1233         @Override @DefinedBy(Api.COMPILER_TREE)
1234         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1235             return v.visitSwitch(this, d);
1236         }
1237         @Override
1238         public Tag getTag() {
1239             return SWITCH;
1240         }
1241     }
1242 
1243     /**
1244      * A &quot;case  :&quot; of a switch.
1245      */
1246     public static class JCCase extends JCStatement implements CaseTree {
1247         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1248         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
1249         @SuppressWarnings(&quot;removal&quot;)
1250         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
1251         @SuppressWarnings(&quot;removal&quot;)
1252         public static final CaseKind RULE = CaseKind.RULE;
1253         @SuppressWarnings(&quot;removal&quot;)
1254         public final CaseKind caseKind;
1255         public List&lt;JCExpression&gt; pats;
1256         public List&lt;JCStatement&gt; stats;
1257         public JCTree body;
1258         public boolean completesNormally;
1259         protected JCCase(@SuppressWarnings(&quot;removal&quot;) CaseKind caseKind, List&lt;JCExpression&gt; pats,
1260                          List&lt;JCStatement&gt; stats, JCTree body) {
1261             Assert.checkNonNull(pats);
1262             Assert.check(pats.isEmpty() || pats.head != null);
1263             this.caseKind = caseKind;
1264             this.pats = pats;
1265             this.stats = stats;
1266             this.body = body;
1267         }
1268         @Override
1269         public void accept(Visitor v) { v.visitCase(this); }
1270 
1271         @Override @DefinedBy(Api.COMPILER_TREE)
1272         public Kind getKind() { return Kind.CASE; }
1273         @Override @DefinedBy(Api.COMPILER_TREE)
1274         public JCExpression getExpression() { return pats.head; }
1275         @Override @DefinedBy(Api.COMPILER_TREE)
1276         @SuppressWarnings(&quot;removal&quot;)
1277         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1278         @Override @DefinedBy(Api.COMPILER_TREE)
1279         @SuppressWarnings(&quot;removal&quot;)
1280         public List&lt;JCStatement&gt; getStatements() {
1281             return caseKind == CaseKind.STATEMENT ? stats : null;
1282         }
1283         @Override @DefinedBy(Api.COMPILER_TREE)
1284         @SuppressWarnings(&quot;removal&quot;)
1285         public JCTree getBody() { return body; }
1286         @Override @DefinedBy(Api.COMPILER_TREE)
1287         @SuppressWarnings(&quot;removal&quot;)
1288         public CaseKind getCaseKind() {
1289             return caseKind;
1290         }
1291         @Override @DefinedBy(Api.COMPILER_TREE)
1292         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1293             return v.visitCase(this, d);
1294         }
1295         @Override
1296         public Tag getTag() {
1297             return CASE;
1298         }
1299     }
1300 
1301     /**
1302      * A &quot;switch ( ) { }&quot; construction.
1303      */
1304     @SuppressWarnings(&quot;removal&quot;)
1305     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1306         public JCExpression selector;
1307         public List&lt;JCCase&gt; cases;
1308         /** Position of closing brace, optional. */
1309         public int endpos = Position.NOPOS;
1310         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1311             this.selector = selector;
1312             this.cases = cases;
1313         }
1314         @Override
1315         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1316 
1317         @DefinedBy(Api.COMPILER_TREE)
1318         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1319         @DefinedBy(Api.COMPILER_TREE)
1320         public JCExpression getExpression() { return selector; }
1321         @DefinedBy(Api.COMPILER_TREE)
1322         public List&lt;JCCase&gt; getCases() { return cases; }
1323         @Override @DefinedBy(Api.COMPILER_TREE)
1324         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1325             return v.visitSwitchExpression(this, d);
1326         }
1327         @Override
1328         public Tag getTag() {
1329             return SWITCH_EXPRESSION;
1330         }
1331     }
1332 
1333     /**
1334      * A synchronized block.
1335      */
1336     public static class JCSynchronized extends JCStatement implements SynchronizedTree {
1337         public JCExpression lock;
1338         public JCBlock body;
1339         protected JCSynchronized(JCExpression lock, JCBlock body) {
1340             this.lock = lock;
1341             this.body = body;
1342         }
1343         @Override
1344         public void accept(Visitor v) { v.visitSynchronized(this); }
1345 
1346         @DefinedBy(Api.COMPILER_TREE)
1347         public Kind getKind() { return Kind.SYNCHRONIZED; }
1348         @DefinedBy(Api.COMPILER_TREE)
1349         public JCExpression getExpression() { return lock; }
1350         @DefinedBy(Api.COMPILER_TREE)
1351         public JCBlock getBlock() { return body; }
1352         @Override @DefinedBy(Api.COMPILER_TREE)
1353         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1354             return v.visitSynchronized(this, d);
1355         }
1356         @Override
1357         public Tag getTag() {
1358             return SYNCHRONIZED;
1359         }
1360     }
1361 
1362     /**
1363      * A &quot;try { } catch ( ) { } finally { }&quot; block.
1364      */
1365     public static class JCTry extends JCStatement implements TryTree {
1366         public JCBlock body;
1367         public List&lt;JCCatch&gt; catchers;
1368         public JCBlock finalizer;
1369         public List&lt;JCTree&gt; resources;
1370         public boolean finallyCanCompleteNormally;
1371         protected JCTry(List&lt;JCTree&gt; resources,
1372                         JCBlock body,
1373                         List&lt;JCCatch&gt; catchers,
1374                         JCBlock finalizer) {
1375             this.body = body;
1376             this.catchers = catchers;
1377             this.finalizer = finalizer;
1378             this.resources = resources;
1379         }
1380         @Override
1381         public void accept(Visitor v) { v.visitTry(this); }
1382 
1383         @DefinedBy(Api.COMPILER_TREE)
1384         public Kind getKind() { return Kind.TRY; }
1385         @DefinedBy(Api.COMPILER_TREE)
1386         public JCBlock getBlock() { return body; }
1387         @DefinedBy(Api.COMPILER_TREE)
1388         public List&lt;JCCatch&gt; getCatches() {
1389             return catchers;
1390         }
1391         @DefinedBy(Api.COMPILER_TREE)
1392         public JCBlock getFinallyBlock() { return finalizer; }
1393         @Override @DefinedBy(Api.COMPILER_TREE)
1394         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1395             return v.visitTry(this, d);
1396         }
1397         @Override @DefinedBy(Api.COMPILER_TREE)
1398         public List&lt;JCTree&gt; getResources() {
1399             return resources;
1400         }
1401         @Override
1402         public Tag getTag() {
1403             return TRY;
1404         }
1405     }
1406 
1407     /**
1408      * A catch block.
1409      */
1410     public static class JCCatch extends JCTree implements CatchTree {
1411         public JCVariableDecl param;
1412         public JCBlock body;
1413         protected JCCatch(JCVariableDecl param, JCBlock body) {
1414             this.param = param;
1415             this.body = body;
1416         }
1417         @Override
1418         public void accept(Visitor v) { v.visitCatch(this); }
1419 
1420         @DefinedBy(Api.COMPILER_TREE)
1421         public Kind getKind() { return Kind.CATCH; }
1422         @DefinedBy(Api.COMPILER_TREE)
1423         public JCVariableDecl getParameter() { return param; }
1424         @DefinedBy(Api.COMPILER_TREE)
1425         public JCBlock getBlock() { return body; }
1426         @Override @DefinedBy(Api.COMPILER_TREE)
1427         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1428             return v.visitCatch(this, d);
1429         }
1430         @Override
1431         public Tag getTag() {
1432             return CATCH;
1433         }
1434     }
1435 
1436     /**
1437      * A ( ) ? ( ) : ( ) conditional expression
1438      */
1439     public static class JCConditional extends JCPolyExpression implements ConditionalExpressionTree {
1440         public JCExpression cond;
1441         public JCExpression truepart;
1442         public JCExpression falsepart;
1443         protected JCConditional(JCExpression cond,
1444                               JCExpression truepart,
1445                               JCExpression falsepart)
1446         {
1447             this.cond = cond;
1448             this.truepart = truepart;
1449             this.falsepart = falsepart;
1450         }
1451         @Override
1452         public void accept(Visitor v) { v.visitConditional(this); }
1453 
1454         @DefinedBy(Api.COMPILER_TREE)
1455         public Kind getKind() { return Kind.CONDITIONAL_EXPRESSION; }
1456         @DefinedBy(Api.COMPILER_TREE)
1457         public JCExpression getCondition() { return cond; }
1458         @DefinedBy(Api.COMPILER_TREE)
1459         public JCExpression getTrueExpression() { return truepart; }
1460         @DefinedBy(Api.COMPILER_TREE)
1461         public JCExpression getFalseExpression() { return falsepart; }
1462         @Override @DefinedBy(Api.COMPILER_TREE)
1463         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1464             return v.visitConditionalExpression(this, d);
1465         }
1466         @Override
1467         public Tag getTag() {
1468             return CONDEXPR;
1469         }
1470     }
1471 
1472     /**
1473      * An &quot;if ( ) { } else { }&quot; block
1474      */
1475     public static class JCIf extends JCStatement implements IfTree {
1476         public JCExpression cond;
1477         public JCStatement thenpart;
1478         public JCStatement elsepart;
1479         protected JCIf(JCExpression cond,
1480                      JCStatement thenpart,
1481                      JCStatement elsepart)
1482         {
1483             this.cond = cond;
1484             this.thenpart = thenpart;
1485             this.elsepart = elsepart;
1486         }
1487         @Override
1488         public void accept(Visitor v) { v.visitIf(this); }
1489 
1490         @DefinedBy(Api.COMPILER_TREE)
1491         public Kind getKind() { return Kind.IF; }
1492         @DefinedBy(Api.COMPILER_TREE)
1493         public JCExpression getCondition() { return cond; }
1494         @DefinedBy(Api.COMPILER_TREE)
1495         public JCStatement getThenStatement() { return thenpart; }
1496         @DefinedBy(Api.COMPILER_TREE)
1497         public JCStatement getElseStatement() { return elsepart; }
1498         @Override @DefinedBy(Api.COMPILER_TREE)
1499         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1500             return v.visitIf(this, d);
1501         }
1502         @Override
1503         public Tag getTag() {
1504             return IF;
1505         }
1506     }
1507 
1508     /**
1509      * an expression statement
1510      */
1511     public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
1512         /** expression structure */
1513         public JCExpression expr;
1514         protected JCExpressionStatement(JCExpression expr)
1515         {
1516             this.expr = expr;
1517         }
1518         @Override
1519         public void accept(Visitor v) { v.visitExec(this); }
1520 
1521         @DefinedBy(Api.COMPILER_TREE)
1522         public Kind getKind() { return Kind.EXPRESSION_STATEMENT; }
1523         @DefinedBy(Api.COMPILER_TREE)
1524         public JCExpression getExpression() { return expr; }
1525         @Override @DefinedBy(Api.COMPILER_TREE)
1526         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1527             return v.visitExpressionStatement(this, d);
1528         }
1529         @Override
1530         public Tag getTag() {
1531             return EXEC;
1532         }
1533 
1534         /** Convert a expression-statement tree to a pretty-printed string. */
1535         @Override
1536         public String toString() {
1537             StringWriter s = new StringWriter();
1538             try {
1539                 new Pretty(s, false).printStat(this);
1540             }
1541             catch (IOException e) {
1542                 // should never happen, because StringWriter is defined
1543                 // never to throw any IOExceptions
1544                 throw new AssertionError(e);
1545             }
1546             return s.toString();
1547         }
1548     }
1549 
1550     /**
1551      * A break from a loop or switch.
1552      */
1553     public static class JCBreak extends JCStatement implements BreakTree {
1554         public JCExpression value;
1555         public JCTree target;
1556         protected JCBreak(JCExpression value, JCTree target) {
1557             this.value = value;
1558             this.target = target;
1559         }
1560         @Override
1561         public void accept(Visitor v) { v.visitBreak(this); }
1562         public boolean isValueBreak() {
1563             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1564         }
1565 
1566         @DefinedBy(Api.COMPILER_TREE)
1567         public Kind getKind() { return Kind.BREAK; }
1568         @DefinedBy(Api.COMPILER_TREE)
1569         public Name getLabel() {
1570             return value != null &amp;&amp; value.getKind() == Kind.IDENTIFIER ? ((JCIdent) value).getName() : null;
1571         }
1572         @DefinedBy(Api.COMPILER_TREE)
1573         @SuppressWarnings(&quot;removal&quot;)
1574         public JCExpression getValue() { return value; }
1575         @Override @DefinedBy(Api.COMPILER_TREE)
1576         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1577             return v.visitBreak(this, d);
1578         }
1579         @Override
1580         public Tag getTag() {
1581             return BREAK;
1582         }
1583     }
1584 
1585     /**
1586      * A continue of a loop.
1587      */
1588     public static class JCContinue extends JCStatement implements ContinueTree {
1589         public Name label;
1590         public JCTree target;
1591         protected JCContinue(Name label, JCTree target) {
1592             this.label = label;
1593             this.target = target;
1594         }
1595         @Override
1596         public void accept(Visitor v) { v.visitContinue(this); }
1597 
1598         @DefinedBy(Api.COMPILER_TREE)
1599         public Kind getKind() { return Kind.CONTINUE; }
1600         @DefinedBy(Api.COMPILER_TREE)
1601         public Name getLabel() { return label; }
1602         @Override @DefinedBy(Api.COMPILER_TREE)
1603         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1604             return v.visitContinue(this, d);
1605         }
1606         @Override
1607         public Tag getTag() {
1608             return CONTINUE;
1609         }
1610     }
1611 
1612     /**
1613      * A return statement.
1614      */
1615     public static class JCReturn extends JCStatement implements ReturnTree {
1616         public JCExpression expr;
1617         protected JCReturn(JCExpression expr) {
1618             this.expr = expr;
1619         }
1620         @Override
1621         public void accept(Visitor v) { v.visitReturn(this); }
1622 
1623         @DefinedBy(Api.COMPILER_TREE)
1624         public Kind getKind() { return Kind.RETURN; }
1625         @DefinedBy(Api.COMPILER_TREE)
1626         public JCExpression getExpression() { return expr; }
1627         @Override @DefinedBy(Api.COMPILER_TREE)
1628         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1629             return v.visitReturn(this, d);
1630         }
1631         @Override
1632         public Tag getTag() {
1633             return RETURN;
1634         }
1635     }
1636 
1637     /**
1638      * A throw statement.
1639      */
1640     public static class JCThrow extends JCStatement implements ThrowTree {
1641         public JCExpression expr;
1642         protected JCThrow(JCExpression expr) {
1643             this.expr = expr;
1644         }
1645         @Override
1646         public void accept(Visitor v) { v.visitThrow(this); }
1647 
1648         @DefinedBy(Api.COMPILER_TREE)
1649         public Kind getKind() { return Kind.THROW; }
1650         @DefinedBy(Api.COMPILER_TREE)
1651         public JCExpression getExpression() { return expr; }
1652         @Override @DefinedBy(Api.COMPILER_TREE)
1653         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1654             return v.visitThrow(this, d);
1655         }
1656         @Override
1657         public Tag getTag() {
1658             return THROW;
1659         }
1660     }
1661 
1662     /**
1663      * An assert statement.
1664      */
1665     public static class JCAssert extends JCStatement implements AssertTree {
1666         public JCExpression cond;
1667         public JCExpression detail;
1668         protected JCAssert(JCExpression cond, JCExpression detail) {
1669             this.cond = cond;
1670             this.detail = detail;
1671         }
1672         @Override
1673         public void accept(Visitor v) { v.visitAssert(this); }
1674 
1675         @DefinedBy(Api.COMPILER_TREE)
1676         public Kind getKind() { return Kind.ASSERT; }
1677         @DefinedBy(Api.COMPILER_TREE)
1678         public JCExpression getCondition() { return cond; }
1679         @DefinedBy(Api.COMPILER_TREE)
1680         public JCExpression getDetail() { return detail; }
1681         @Override @DefinedBy(Api.COMPILER_TREE)
1682         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1683             return v.visitAssert(this, d);
1684         }
1685         @Override
1686         public Tag getTag() {
1687             return ASSERT;
1688         }
1689     }
1690 
1691     /**
1692      * A method invocation
1693      */
1694     public static class JCMethodInvocation extends JCPolyExpression implements MethodInvocationTree {
1695         public List&lt;JCExpression&gt; typeargs;
1696         public JCExpression meth;
1697         public List&lt;JCExpression&gt; args;
1698         public Type varargsElement;
1699         protected JCMethodInvocation(List&lt;JCExpression&gt; typeargs,
1700                         JCExpression meth,
1701                         List&lt;JCExpression&gt; args)
1702         {
1703             this.typeargs = (typeargs == null) ? List.nil()
1704                                                : typeargs;
1705             this.meth = meth;
1706             this.args = args;
1707         }
1708         @Override
1709         public void accept(Visitor v) { v.visitApply(this); }
1710 
1711         @DefinedBy(Api.COMPILER_TREE)
1712         public Kind getKind() { return Kind.METHOD_INVOCATION; }
1713         @DefinedBy(Api.COMPILER_TREE)
1714         public List&lt;JCExpression&gt; getTypeArguments() {
1715             return typeargs;
1716         }
1717         @DefinedBy(Api.COMPILER_TREE)
1718         public JCExpression getMethodSelect() { return meth; }
1719         @DefinedBy(Api.COMPILER_TREE)
1720         public List&lt;JCExpression&gt; getArguments() {
1721             return args;
1722         }
1723         @Override @DefinedBy(Api.COMPILER_TREE)
1724         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1725             return v.visitMethodInvocation(this, d);
1726         }
1727         @Override
1728         public JCMethodInvocation setType(Type type) {
1729             super.setType(type);
1730             return this;
1731         }
1732         @Override
1733         public Tag getTag() {
1734             return(APPLY);
1735         }
1736     }
1737 
1738     /**
1739      * A new(...) operation.
1740      */
1741     public static class JCNewClass extends JCPolyExpression implements NewClassTree {
1742         public JCExpression encl;
1743         public List&lt;JCExpression&gt; typeargs;
1744         public JCExpression clazz;
1745         public List&lt;JCExpression&gt; args;
1746         public JCClassDecl def;
1747         public Symbol constructor;
1748         public Type varargsElement;
1749         public Type constructorType;
1750         protected JCNewClass(JCExpression encl,
1751                            List&lt;JCExpression&gt; typeargs,
1752                            JCExpression clazz,
1753                            List&lt;JCExpression&gt; args,
1754                            JCClassDecl def)
1755         {
1756             this.encl = encl;
1757             this.typeargs = (typeargs == null) ? List.nil()
1758                                                : typeargs;
1759             this.clazz = clazz;
1760             this.args = args;
1761             this.def = def;
1762         }
1763         @Override
1764         public void accept(Visitor v) { v.visitNewClass(this); }
1765 
1766         @DefinedBy(Api.COMPILER_TREE)
1767         public Kind getKind() { return Kind.NEW_CLASS; }
1768         @DefinedBy(Api.COMPILER_TREE)
1769         public JCExpression getEnclosingExpression() { // expr.new C&lt; ... &gt; ( ... )
1770             return encl;
1771         }
1772         @DefinedBy(Api.COMPILER_TREE)
1773         public List&lt;JCExpression&gt; getTypeArguments() {
1774             return typeargs;
1775         }
1776         @DefinedBy(Api.COMPILER_TREE)
1777         public JCExpression getIdentifier() { return clazz; }
1778         @DefinedBy(Api.COMPILER_TREE)
1779         public List&lt;JCExpression&gt; getArguments() {
1780             return args;
1781         }
1782         @DefinedBy(Api.COMPILER_TREE)
1783         public JCClassDecl getClassBody() { return def; }
1784         @Override @DefinedBy(Api.COMPILER_TREE)
1785         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1786             return v.visitNewClass(this, d);
1787         }
1788         @Override
1789         public Tag getTag() {
1790             return NEWCLASS;
1791         }
1792 
1793         public boolean classDeclRemoved() {
1794             return false;
1795         }
1796     }
1797 
1798     /**
1799      * A new[...] operation.
1800      */
1801     public static class JCNewArray extends JCExpression implements NewArrayTree {
1802         public JCExpression elemtype;
1803         public List&lt;JCExpression&gt; dims;
1804         // type annotations on inner-most component
1805         public List&lt;JCAnnotation&gt; annotations;
1806         // type annotations on dimensions
1807         public List&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations;
1808         public List&lt;JCExpression&gt; elems;
1809         protected JCNewArray(JCExpression elemtype,
1810                            List&lt;JCExpression&gt; dims,
1811                            List&lt;JCExpression&gt; elems)
1812         {
1813             this.elemtype = elemtype;
1814             this.dims = dims;
1815             this.annotations = List.nil();
1816             this.dimAnnotations = List.nil();
1817             this.elems = elems;
1818         }
1819         @Override
1820         public void accept(Visitor v) { v.visitNewArray(this); }
1821 
1822         @DefinedBy(Api.COMPILER_TREE)
1823         public Kind getKind() { return Kind.NEW_ARRAY; }
1824         @DefinedBy(Api.COMPILER_TREE)
1825         public JCExpression getType() { return elemtype; }
1826         @DefinedBy(Api.COMPILER_TREE)
1827         public List&lt;JCExpression&gt; getDimensions() {
1828             return dims;
1829         }
1830         @DefinedBy(Api.COMPILER_TREE)
1831         public List&lt;JCExpression&gt; getInitializers() {
1832             return elems;
1833         }
1834         @Override @DefinedBy(Api.COMPILER_TREE)
1835         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1836             return v.visitNewArray(this, d);
1837         }
1838         @Override
1839         public Tag getTag() {
1840             return NEWARRAY;
1841         }
1842 
1843         @Override @DefinedBy(Api.COMPILER_TREE)
1844         public List&lt;JCAnnotation&gt; getAnnotations() {
1845             return annotations;
1846         }
1847 
1848         @Override @DefinedBy(Api.COMPILER_TREE)
1849         public List&lt;List&lt;JCAnnotation&gt;&gt; getDimAnnotations() {
1850             return dimAnnotations;
1851         }
1852     }
1853 
1854     /**
1855      * A lambda expression.
1856      */
1857     public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {
1858 
1859         public enum ParameterKind {
1860             IMPLICIT,
1861             EXPLICIT
1862         }
1863 
1864         public List&lt;JCVariableDecl&gt; params;
1865         public JCTree body;
1866         public boolean canCompleteNormally = true;
1867         public ParameterKind paramKind;
1868 
1869         public JCLambda(List&lt;JCVariableDecl&gt; params,
1870                         JCTree body) {
1871             this.params = params;
1872             this.body = body;
1873             if (params.isEmpty() ||
1874                 params.head.vartype != null) {
1875                 paramKind = ParameterKind.EXPLICIT;
1876             } else {
1877                 paramKind = ParameterKind.IMPLICIT;
1878             }
1879         }
1880         @Override
1881         public Tag getTag() {
1882             return LAMBDA;
1883         }
1884         @Override
1885         public void accept(Visitor v) {
1886             v.visitLambda(this);
1887         }
1888         @Override @DefinedBy(Api.COMPILER_TREE)
1889         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
1890             return v.visitLambdaExpression(this, d);
1891         }
1892         @DefinedBy(Api.COMPILER_TREE)
1893         public Kind getKind() {
1894             return Kind.LAMBDA_EXPRESSION;
1895         }
1896         @DefinedBy(Api.COMPILER_TREE)
1897         public JCTree getBody() {
1898             return body;
1899         }
1900         @DefinedBy(Api.COMPILER_TREE)
1901         public java.util.List&lt;? extends VariableTree&gt; getParameters() {
1902             return params;
1903         }
1904         @Override
1905         public JCLambda setType(Type type) {
1906             super.setType(type);
1907             return this;
1908         }
1909         @Override @DefinedBy(Api.COMPILER_TREE)
1910         public BodyKind getBodyKind() {
1911             return body.hasTag(BLOCK) ?
1912                     BodyKind.STATEMENT :
1913                     BodyKind.EXPRESSION;
1914         }
1915     }
1916 
1917     /**
1918      * A parenthesized subexpression ( ... )
1919      */
1920     public static class JCParens extends JCExpression implements ParenthesizedTree {
1921         public JCExpression expr;
1922         protected JCParens(JCExpression expr) {
1923             this.expr = expr;
1924         }
1925         @Override
1926         public void accept(Visitor v) { v.visitParens(this); }
1927 
1928         @DefinedBy(Api.COMPILER_TREE)
1929         public Kind getKind() { return Kind.PARENTHESIZED; }
1930         @DefinedBy(Api.COMPILER_TREE)
1931         public JCExpression getExpression() { return expr; }
1932         @Override @DefinedBy(Api.COMPILER_TREE)
1933         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1934             return v.visitParenthesized(this, d);
1935         }
1936         @Override
1937         public Tag getTag() {
1938             return PARENS;
1939         }
1940     }
1941 
1942     /**
1943      * A assignment with &quot;=&quot;.
1944      */
1945     public static class JCAssign extends JCExpression implements AssignmentTree {
1946         public JCExpression lhs;
1947         public JCExpression rhs;
1948         protected JCAssign(JCExpression lhs, JCExpression rhs) {
1949             this.lhs = lhs;
1950             this.rhs = rhs;
1951         }
1952         @Override
1953         public void accept(Visitor v) { v.visitAssign(this); }
1954 
1955         @DefinedBy(Api.COMPILER_TREE)
1956         public Kind getKind() { return Kind.ASSIGNMENT; }
1957         @DefinedBy(Api.COMPILER_TREE)
1958         public JCExpression getVariable() { return lhs; }
1959         @DefinedBy(Api.COMPILER_TREE)
1960         public JCExpression getExpression() { return rhs; }
1961         @Override @DefinedBy(Api.COMPILER_TREE)
1962         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1963             return v.visitAssignment(this, d);
1964         }
1965         @Override
1966         public Tag getTag() {
1967             return ASSIGN;
1968         }
1969     }
1970 
1971     public static abstract class JCOperatorExpression extends JCExpression {
1972         public enum OperandPos {
1973             LEFT,
1974             RIGHT
1975         }
1976 
1977         protected Tag opcode;
1978         public OperatorSymbol operator;
1979 
1980         public OperatorSymbol getOperator() {
1981             return operator;
1982         }
1983 
1984         @Override
1985         public Tag getTag() {
1986             return opcode;
1987         }
1988 
1989         public abstract JCExpression getOperand(OperandPos pos);
1990     }
1991 
1992     /**
1993      * An assignment with &quot;+=&quot;, &quot;|=&quot; ...
1994      */
1995     public static class JCAssignOp extends JCOperatorExpression implements CompoundAssignmentTree {
1996         public JCExpression lhs;
1997         public JCExpression rhs;
1998         protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, OperatorSymbol operator) {
1999             this.opcode = opcode;
2000             this.lhs = (JCExpression)lhs;
2001             this.rhs = (JCExpression)rhs;
2002             this.operator = operator;
2003         }
2004         @Override
2005         public void accept(Visitor v) { v.visitAssignop(this); }
2006 
2007         @DefinedBy(Api.COMPILER_TREE)
2008         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2009         @DefinedBy(Api.COMPILER_TREE)
2010         public JCExpression getVariable() { return lhs; }
2011         @DefinedBy(Api.COMPILER_TREE)
2012         public JCExpression getExpression() { return rhs; }
2013         @Override @DefinedBy(Api.COMPILER_TREE)
2014         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2015             return v.visitCompoundAssignment(this, d);
2016         }
2017         @Override
2018         public JCExpression getOperand(OperandPos pos) {
2019             return pos == OperandPos.LEFT ? lhs : rhs;
2020         }
2021     }
2022 
2023     /**
2024      * A unary operation.
2025      */
2026     public static class JCUnary extends JCOperatorExpression implements UnaryTree {
2027         public JCExpression arg;
2028         protected JCUnary(Tag opcode, JCExpression arg) {
2029             this.opcode = opcode;
2030             this.arg = arg;
2031         }
2032         @Override
2033         public void accept(Visitor v) { v.visitUnary(this); }
2034 
2035         @DefinedBy(Api.COMPILER_TREE)
2036         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2037         @DefinedBy(Api.COMPILER_TREE)
2038         public JCExpression getExpression() { return arg; }
2039         @Override @DefinedBy(Api.COMPILER_TREE)
2040         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2041             return v.visitUnary(this, d);
2042         }
2043         public void setTag(Tag tag) {
2044             opcode = tag;
2045         }
2046         @Override
2047         public JCExpression getOperand(OperandPos pos) {
2048             return arg;
2049         }
2050     }
2051 
2052     /**
2053      * A binary operation.
2054      */
2055     public static class JCBinary extends JCOperatorExpression implements BinaryTree {
2056         public JCExpression lhs;
2057         public JCExpression rhs;
2058         protected JCBinary(Tag opcode,
2059                          JCExpression lhs,
2060                          JCExpression rhs,
2061                          OperatorSymbol operator) {
2062             this.opcode = opcode;
2063             this.lhs = lhs;
2064             this.rhs = rhs;
2065             this.operator = operator;
2066         }
2067         @Override
2068         public void accept(Visitor v) { v.visitBinary(this); }
2069 
2070         @DefinedBy(Api.COMPILER_TREE)
2071         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2072         @DefinedBy(Api.COMPILER_TREE)
2073         public JCExpression getLeftOperand() { return lhs; }
2074         @DefinedBy(Api.COMPILER_TREE)
2075         public JCExpression getRightOperand() { return rhs; }
2076         @Override @DefinedBy(Api.COMPILER_TREE)
2077         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2078             return v.visitBinary(this, d);
2079         }
2080         @Override
2081         public JCExpression getOperand(OperandPos pos) {
2082             return pos == OperandPos.LEFT ? lhs : rhs;
2083         }
2084     }
2085 
2086     /**
2087      * A type cast.
2088      */
2089     public static class JCTypeCast extends JCExpression implements TypeCastTree {
2090         public JCTree clazz;
2091         public JCExpression expr;
2092         protected JCTypeCast(JCTree clazz, JCExpression expr) {
2093             this.clazz = clazz;
2094             this.expr = expr;
2095         }
2096         @Override
2097         public void accept(Visitor v) { v.visitTypeCast(this); }
2098 
2099         @DefinedBy(Api.COMPILER_TREE)
2100         public Kind getKind() { return Kind.TYPE_CAST; }
2101         @DefinedBy(Api.COMPILER_TREE)
2102         public JCTree getType() { return clazz; }
2103         @DefinedBy(Api.COMPILER_TREE)
2104         public JCExpression getExpression() { return expr; }
2105         @Override @DefinedBy(Api.COMPILER_TREE)
2106         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2107             return v.visitTypeCast(this, d);
2108         }
2109         @Override
2110         public Tag getTag() {
2111             return TYPECAST;
2112         }
2113     }
2114 
2115     /**
2116      * A type test.
2117      */
2118     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2119         public JCExpression expr;
2120         public JCTree clazz;
2121         protected JCInstanceOf(JCExpression expr, JCTree clazz) {
2122             this.expr = expr;
2123             this.clazz = clazz;
2124         }
2125         @Override
2126         public void accept(Visitor v) { v.visitTypeTest(this); }
2127 
2128         @DefinedBy(Api.COMPILER_TREE)
2129         public Kind getKind() { return Kind.INSTANCE_OF; }
2130         @DefinedBy(Api.COMPILER_TREE)
2131         public JCTree getType() { return clazz; }
2132         @DefinedBy(Api.COMPILER_TREE)
2133         public JCExpression getExpression() { return expr; }
2134         @Override @DefinedBy(Api.COMPILER_TREE)
2135         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2136             return v.visitInstanceOf(this, d);
2137         }
2138         @Override
2139         public Tag getTag() {
2140             return TYPETEST;
2141         }
2142     }
2143 
2144     /**
2145      * An array selection
2146      */
2147     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2148         public JCExpression indexed;
2149         public JCExpression index;
2150         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2151             this.indexed = indexed;
2152             this.index = index;
2153         }
2154         @Override
2155         public void accept(Visitor v) { v.visitIndexed(this); }
2156 
2157         @DefinedBy(Api.COMPILER_TREE)
2158         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2159         @DefinedBy(Api.COMPILER_TREE)
2160         public JCExpression getExpression() { return indexed; }
2161         @DefinedBy(Api.COMPILER_TREE)
2162         public JCExpression getIndex() { return index; }
2163         @Override @DefinedBy(Api.COMPILER_TREE)
2164         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2165             return v.visitArrayAccess(this, d);
2166         }
2167         @Override
2168         public Tag getTag() {
2169             return INDEXED;
2170         }
2171     }
2172 
2173     /**
2174      * Selects through packages and classes
2175      */
2176     public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
2177         /** selected Tree hierarchy */
2178         public JCExpression selected;
2179         /** name of field to select thru */
2180         public Name name;
2181         /** symbol of the selected class */
2182         public Symbol sym;
2183         protected JCFieldAccess(JCExpression selected, Name name, Symbol sym) {
2184             this.selected = selected;
2185             this.name = name;
2186             this.sym = sym;
2187         }
2188         @Override
2189         public void accept(Visitor v) { v.visitSelect(this); }
2190 
2191         @DefinedBy(Api.COMPILER_TREE)
2192         public Kind getKind() { return Kind.MEMBER_SELECT; }
2193         @DefinedBy(Api.COMPILER_TREE)
2194         public JCExpression getExpression() { return selected; }
2195         @Override @DefinedBy(Api.COMPILER_TREE)
2196         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2197             return v.visitMemberSelect(this, d);
2198         }
2199         @DefinedBy(Api.COMPILER_TREE)
2200         public Name getIdentifier() { return name; }
2201         @Override
2202         public Tag getTag() {
2203             return SELECT;
2204         }
2205     }
2206 
2207     /**
2208      * Selects a member expression.
2209      */
2210     public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {
2211 
2212         public ReferenceMode mode;
2213         public ReferenceKind kind;
2214         public Name name;
2215         public JCExpression expr;
2216         public List&lt;JCExpression&gt; typeargs;
2217         public Symbol sym;
2218         public Type varargsElement;
2219         public PolyKind refPolyKind;
2220         public boolean ownerAccessible;
2221         private OverloadKind overloadKind;
2222         public Type referentType;
2223 
2224         public enum OverloadKind {
2225             OVERLOADED,
2226             UNOVERLOADED,
2227             ERROR
2228         }
2229 
2230         /**
2231          * Javac-dependent classification for member references, based
2232          * on relevant properties w.r.t. code-generation
2233          */
2234         public enum ReferenceKind {
2235             /** super # instMethod */
2236             SUPER(ReferenceMode.INVOKE, false),
2237             /** Type # instMethod */
2238             UNBOUND(ReferenceMode.INVOKE, true),
2239             /** Type # staticMethod */
2240             STATIC(ReferenceMode.INVOKE, false),
2241             /** Expr # instMethod */
2242             BOUND(ReferenceMode.INVOKE, false),
2243             /** Inner # new */
2244             IMPLICIT_INNER(ReferenceMode.NEW, false),
2245             /** Toplevel # new */
2246             TOPLEVEL(ReferenceMode.NEW, false),
2247             /** ArrayType # new */
2248             ARRAY_CTOR(ReferenceMode.NEW, false);
2249 
2250             final ReferenceMode mode;
2251             final boolean unbound;
2252 
2253             private ReferenceKind(ReferenceMode mode, boolean unbound) {
2254                 this.mode = mode;
2255                 this.unbound = unbound;
2256             }
2257 
2258             public boolean isUnbound() {
2259                 return unbound;
2260             }
2261         }
2262 
2263         public JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List&lt;JCExpression&gt; typeargs) {
2264             this.mode = mode;
2265             this.name = name;
2266             this.expr = expr;
2267             this.typeargs = typeargs;
2268         }
2269         @Override
2270         public void accept(Visitor v) { v.visitReference(this); }
2271 
2272         @DefinedBy(Api.COMPILER_TREE)
2273         public Kind getKind() { return Kind.MEMBER_REFERENCE; }
2274         @Override @DefinedBy(Api.COMPILER_TREE)
2275         public ReferenceMode getMode() { return mode; }
2276         @Override @DefinedBy(Api.COMPILER_TREE)
2277         public JCExpression getQualifierExpression() { return expr; }
2278         @Override @DefinedBy(Api.COMPILER_TREE)
2279         public Name getName() { return name; }
2280         @Override @DefinedBy(Api.COMPILER_TREE)
2281         public List&lt;JCExpression&gt; getTypeArguments() { return typeargs; }
2282 
2283         @Override @DefinedBy(Api.COMPILER_TREE)
2284         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2285             return v.visitMemberReference(this, d);
2286         }
2287         @Override
2288         public Tag getTag() {
2289             return REFERENCE;
2290         }
2291         public boolean hasKind(ReferenceKind kind) {
2292             return this.kind == kind;
2293         }
2294 
2295         /**
2296          * @return the overloadKind
2297          */
2298         public OverloadKind getOverloadKind() {
2299             return overloadKind;
2300         }
2301 
2302         /**
2303          * @param overloadKind the overloadKind to set
2304          */
2305         public void setOverloadKind(OverloadKind overloadKind) {
2306             this.overloadKind = overloadKind;
2307         }
2308     }
2309 
2310     /**
2311      * An identifier
2312      */
2313     public static class JCIdent extends JCExpression implements IdentifierTree {
2314         /** the name */
2315         public Name name;
2316         /** the symbol */
2317         public Symbol sym;
2318         protected JCIdent(Name name, Symbol sym) {
2319             this.name = name;
2320             this.sym = sym;
2321         }
2322         @Override
2323         public void accept(Visitor v) { v.visitIdent(this); }
2324 
2325         @DefinedBy(Api.COMPILER_TREE)
2326         public Kind getKind() { return Kind.IDENTIFIER; }
2327         @DefinedBy(Api.COMPILER_TREE)
2328         public Name getName() { return name; }
2329         @Override @DefinedBy(Api.COMPILER_TREE)
2330         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2331             return v.visitIdentifier(this, d);
2332         }
2333         @Override
2334         public Tag getTag() {
2335             return IDENT;
2336         }
2337     }
2338 
2339     /**
2340      * A constant value given literally.
2341      */
2342     public static class JCLiteral extends JCExpression implements LiteralTree {
2343         public TypeTag typetag;
2344         /** value representation */
2345         public Object value;
2346         protected JCLiteral(TypeTag typetag, Object value) {
2347             this.typetag = typetag;
2348             this.value = value;
2349         }
2350         @Override
2351         public void accept(Visitor v) { v.visitLiteral(this); }
2352 
2353         @DefinedBy(Api.COMPILER_TREE)
2354         public Kind getKind() {
2355             return typetag.getKindLiteral();
2356         }
2357 
2358         @DefinedBy(Api.COMPILER_TREE)
2359         public Object getValue() {
2360             switch (typetag) {
2361                 case BOOLEAN:
2362                     int bi = (Integer) value;
2363                     return (bi != 0);
2364                 case CHAR:
2365                     int ci = (Integer) value;
2366                     char c = (char) ci;
2367                     if (c != ci)
2368                         throw new AssertionError(&quot;bad value for char literal&quot;);
2369                     return c;
2370                 default:
2371                     return value;
2372             }
2373         }
2374         @Override @DefinedBy(Api.COMPILER_TREE)
2375         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2376             return v.visitLiteral(this, d);
2377         }
2378         @Override
2379         public JCLiteral setType(Type type) {
2380             super.setType(type);
2381             return this;
2382         }
2383         @Override
2384         public Tag getTag() {
2385             return LITERAL;
2386         }
2387     }
2388 
2389     /**
2390      * Identifies a basic type.
2391      * @see TypeTag
2392      */
2393     public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
2394         /** the basic type id */
2395         public TypeTag typetag;
2396         protected JCPrimitiveTypeTree(TypeTag typetag) {
2397             this.typetag = typetag;
2398         }
2399         @Override
2400         public void accept(Visitor v) { v.visitTypeIdent(this); }
2401 
2402         @DefinedBy(Api.COMPILER_TREE)
2403         public Kind getKind() { return Kind.PRIMITIVE_TYPE; }
2404         @DefinedBy(Api.COMPILER_TREE)
2405         public TypeKind getPrimitiveTypeKind() {
2406             return typetag.getPrimitiveTypeKind();
2407         }
2408 
2409         @Override @DefinedBy(Api.COMPILER_TREE)
2410         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2411             return v.visitPrimitiveType(this, d);
2412         }
2413         @Override
2414         public Tag getTag() {
2415             return TYPEIDENT;
2416         }
2417     }
2418 
2419     /**
2420      * An array type, A[]
2421      */
2422     public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {
2423         public JCExpression elemtype;
2424         protected JCArrayTypeTree(JCExpression elemtype) {
2425             this.elemtype = elemtype;
2426         }
2427         @Override
2428         public void accept(Visitor v) { v.visitTypeArray(this); }
2429 
2430         @DefinedBy(Api.COMPILER_TREE)
2431         public Kind getKind() { return Kind.ARRAY_TYPE; }
2432         @DefinedBy(Api.COMPILER_TREE)
2433         public JCTree getType() { return elemtype; }
2434         @Override @DefinedBy(Api.COMPILER_TREE)
2435         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2436             return v.visitArrayType(this, d);
2437         }
2438         @Override
2439         public Tag getTag() {
2440             return TYPEARRAY;
2441         }
2442     }
2443 
2444     /**
2445      * A parameterized type, {@literal T&lt;...&gt;}
2446      */
2447     public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
2448         public JCExpression clazz;
2449         public List&lt;JCExpression&gt; arguments;
2450         protected JCTypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
2451             this.clazz = clazz;
2452             this.arguments = arguments;
2453         }
2454         @Override
2455         public void accept(Visitor v) { v.visitTypeApply(this); }
2456 
2457         @DefinedBy(Api.COMPILER_TREE)
2458         public Kind getKind() { return Kind.PARAMETERIZED_TYPE; }
2459         @DefinedBy(Api.COMPILER_TREE)
2460         public JCTree getType() { return clazz; }
2461         @DefinedBy(Api.COMPILER_TREE)
2462         public List&lt;JCExpression&gt; getTypeArguments() {
2463             return arguments;
2464         }
2465         @Override @DefinedBy(Api.COMPILER_TREE)
2466         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2467             return v.visitParameterizedType(this, d);
2468         }
2469         @Override
2470         public Tag getTag() {
2471             return TYPEAPPLY;
2472         }
2473     }
2474 
2475     /**
2476      * A union type, T1 | T2 | ... Tn (used in multicatch statements)
2477      */
2478     public static class JCTypeUnion extends JCExpression implements UnionTypeTree {
2479 
2480         public List&lt;JCExpression&gt; alternatives;
2481 
2482         protected JCTypeUnion(List&lt;JCExpression&gt; components) {
2483             this.alternatives = components;
2484         }
2485         @Override
2486         public void accept(Visitor v) { v.visitTypeUnion(this); }
2487 
2488         @DefinedBy(Api.COMPILER_TREE)
2489         public Kind getKind() { return Kind.UNION_TYPE; }
2490 
2491         @DefinedBy(Api.COMPILER_TREE)
2492         public List&lt;JCExpression&gt; getTypeAlternatives() {
2493             return alternatives;
2494         }
2495         @Override @DefinedBy(Api.COMPILER_TREE)
2496         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2497             return v.visitUnionType(this, d);
2498         }
2499         @Override
2500         public Tag getTag() {
2501             return TYPEUNION;
2502         }
2503     }
2504 
2505     /**
2506      * An intersection type, {@code T1 &amp; T2 &amp; ... Tn} (used in cast expressions)
2507      */
2508     public static class JCTypeIntersection extends JCExpression implements IntersectionTypeTree {
2509 
2510         public List&lt;JCExpression&gt; bounds;
2511 
2512         protected JCTypeIntersection(List&lt;JCExpression&gt; bounds) {
2513             this.bounds = bounds;
2514         }
2515         @Override
2516         public void accept(Visitor v) { v.visitTypeIntersection(this); }
2517 
2518         @DefinedBy(Api.COMPILER_TREE)
2519         public Kind getKind() { return Kind.INTERSECTION_TYPE; }
2520 
2521         @DefinedBy(Api.COMPILER_TREE)
2522         public List&lt;JCExpression&gt; getBounds() {
2523             return bounds;
2524         }
2525         @Override @DefinedBy(Api.COMPILER_TREE)
2526         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2527             return v.visitIntersectionType(this, d);
2528         }
2529         @Override
2530         public Tag getTag() {
2531             return TYPEINTERSECTION;
2532         }
2533     }
2534 
2535     /**
2536      * A formal class parameter.
2537      */
2538     public static class JCTypeParameter extends JCTree implements TypeParameterTree {
2539         /** name */
2540         public Name name;
2541         /** bounds */
2542         public List&lt;JCExpression&gt; bounds;
2543         /** type annotations on type parameter */
2544         public List&lt;JCAnnotation&gt; annotations;
2545         protected JCTypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annotations) {
2546             this.name = name;
2547             this.bounds = bounds;
2548             this.annotations = annotations;
2549         }
2550         @Override
2551         public void accept(Visitor v) { v.visitTypeParameter(this); }
2552 
2553         @DefinedBy(Api.COMPILER_TREE)
2554         public Kind getKind() { return Kind.TYPE_PARAMETER; }
2555         @DefinedBy(Api.COMPILER_TREE)
2556         public Name getName() { return name; }
2557         @DefinedBy(Api.COMPILER_TREE)
2558         public List&lt;JCExpression&gt; getBounds() {
2559             return bounds;
2560         }
2561         @DefinedBy(Api.COMPILER_TREE)
2562         public List&lt;JCAnnotation&gt; getAnnotations() {
2563             return annotations;
2564         }
2565         @Override @DefinedBy(Api.COMPILER_TREE)
2566         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2567             return v.visitTypeParameter(this, d);
2568         }
2569         @Override
2570         public Tag getTag() {
2571             return TYPEPARAMETER;
2572         }
2573     }
2574 
2575     public static class JCWildcard extends JCExpression implements WildcardTree {
2576         public TypeBoundKind kind;
2577         public JCTree inner;
2578         protected JCWildcard(TypeBoundKind kind, JCTree inner) {
2579             this.kind = Assert.checkNonNull(kind);
2580             this.inner = inner;
2581         }
2582         @Override
2583         public void accept(Visitor v) { v.visitWildcard(this); }
2584 
2585         @DefinedBy(Api.COMPILER_TREE)
2586         public Kind getKind() {
2587             switch (kind.kind) {
2588             case UNBOUND:
2589                 return Kind.UNBOUNDED_WILDCARD;
2590             case EXTENDS:
2591                 return Kind.EXTENDS_WILDCARD;
2592             case SUPER:
2593                 return Kind.SUPER_WILDCARD;
2594             default:
2595                 throw new AssertionError(&quot;Unknown wildcard bound &quot; + kind);
2596             }
2597         }
2598         @DefinedBy(Api.COMPILER_TREE)
2599         public JCTree getBound() { return inner; }
2600         @Override @DefinedBy(Api.COMPILER_TREE)
2601         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2602             return v.visitWildcard(this, d);
2603         }
2604         @Override
2605         public Tag getTag() {
2606             return Tag.WILDCARD;
2607         }
2608     }
2609 
2610     public static class TypeBoundKind extends JCTree {
2611         public BoundKind kind;
2612         protected TypeBoundKind(BoundKind kind) {
2613             this.kind = kind;
2614         }
2615         @Override
2616         public void accept(Visitor v) { v.visitTypeBoundKind(this); }
2617 
2618         @DefinedBy(Api.COMPILER_TREE)
2619         public Kind getKind() {
2620             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2621         }
2622         @Override @DefinedBy(Api.COMPILER_TREE)
2623         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2624             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2625         }
2626         @Override
2627         public Tag getTag() {
2628             return TYPEBOUNDKIND;
2629         }
2630     }
2631 
2632     public static class JCAnnotation extends JCExpression implements AnnotationTree {
2633         // Either Tag.ANNOTATION or Tag.TYPE_ANNOTATION
2634         private Tag tag;
2635 
2636         public JCTree annotationType;
2637         public List&lt;JCExpression&gt; args;
2638         public Attribute.Compound attribute;
2639 
2640         protected JCAnnotation(Tag tag, JCTree annotationType, List&lt;JCExpression&gt; args) {
2641             this.tag = tag;
2642             this.annotationType = annotationType;
2643             this.args = args;
2644         }
2645 
2646         @Override
2647         public void accept(Visitor v) { v.visitAnnotation(this); }
2648 
2649         @DefinedBy(Api.COMPILER_TREE)
2650         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2651 
2652         @DefinedBy(Api.COMPILER_TREE)
2653         public JCTree getAnnotationType() { return annotationType; }
2654         @DefinedBy(Api.COMPILER_TREE)
2655         public List&lt;JCExpression&gt; getArguments() {
2656             return args;
2657         }
2658         @Override @DefinedBy(Api.COMPILER_TREE)
2659         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2660             return v.visitAnnotation(this, d);
2661         }
2662         @Override
2663         public Tag getTag() {
2664             return tag;
2665         }
2666     }
2667 
2668     public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
2669         public long flags;
2670         public List&lt;JCAnnotation&gt; annotations;
2671         protected JCModifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
2672             this.flags = flags;
2673             this.annotations = annotations;
2674         }
2675         @Override
2676         public void accept(Visitor v) { v.visitModifiers(this); }
2677 
2678         @DefinedBy(Api.COMPILER_TREE)
2679         public Kind getKind() { return Kind.MODIFIERS; }
2680         @DefinedBy(Api.COMPILER_TREE)
2681         public Set&lt;Modifier&gt; getFlags() {
2682             return Flags.asModifierSet(flags);
2683         }
2684         @DefinedBy(Api.COMPILER_TREE)
2685         public List&lt;JCAnnotation&gt; getAnnotations() {
2686             return annotations;
2687         }
2688         @Override @DefinedBy(Api.COMPILER_TREE)
2689         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2690             return v.visitModifiers(this, d);
2691         }
2692         @Override
2693         public Tag getTag() {
2694             return MODIFIERS;
2695         }
2696     }
2697 
2698     public static class JCAnnotatedType extends JCExpression implements com.sun.source.tree.AnnotatedTypeTree {
2699         // type annotations
2700         public List&lt;JCAnnotation&gt; annotations;
2701         public JCExpression underlyingType;
2702 
2703         protected JCAnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
2704             Assert.check(annotations != null &amp;&amp; annotations.nonEmpty());
2705             this.annotations = annotations;
2706             this.underlyingType = underlyingType;
2707         }
2708         @Override
2709         public void accept(Visitor v) { v.visitAnnotatedType(this); }
2710 
2711         @DefinedBy(Api.COMPILER_TREE)
2712         public Kind getKind() { return Kind.ANNOTATED_TYPE; }
2713         @DefinedBy(Api.COMPILER_TREE)
2714         public List&lt;JCAnnotation&gt; getAnnotations() {
2715             return annotations;
2716         }
2717         @DefinedBy(Api.COMPILER_TREE)
2718         public JCExpression getUnderlyingType() {
2719             return underlyingType;
2720         }
2721         @Override @DefinedBy(Api.COMPILER_TREE)
2722         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2723             return v.visitAnnotatedType(this, d);
2724         }
2725         @Override
2726         public Tag getTag() {
2727             return ANNOTATED_TYPE;
2728         }
2729     }
2730 
2731     public static abstract class JCDirective extends JCTree
2732         implements DirectiveTree {
2733     }
2734 
2735     public static class JCModuleDecl extends JCTree implements ModuleTree {
2736         public JCModifiers mods;
2737         public ModuleType type;
2738         private final ModuleKind kind;
2739         public JCExpression qualId;
2740         public List&lt;JCDirective&gt; directives;
2741         public ModuleSymbol sym;
2742 
2743         protected JCModuleDecl(JCModifiers mods, ModuleKind kind,
2744                 JCExpression qualId, List&lt;JCDirective&gt; directives) {
2745             this.mods = mods;
2746             this.kind = kind;
2747             this.qualId = qualId;
2748             this.directives = directives;
2749         }
2750 
2751         @Override
2752         public void accept(Visitor v) { v.visitModuleDef(this); }
2753 
2754         @Override @DefinedBy(Api.COMPILER_TREE)
2755         public Kind getKind() {
2756             return Kind.MODULE;
2757         }
2758 
2759         @Override @DefinedBy(Api.COMPILER_TREE)
2760         public List&lt;? extends AnnotationTree&gt; getAnnotations() {
2761             return mods.annotations;
2762         }
2763 
2764         @Override @DefinedBy(Api.COMPILER_TREE)
2765         public ModuleKind getModuleType() {
2766             return kind;
2767         }
2768 
2769         @Override @DefinedBy(Api.COMPILER_TREE)
2770         public JCExpression getName() {
2771             return qualId;
2772         }
2773 
2774         @Override @DefinedBy(Api.COMPILER_TREE)
2775         public List&lt;JCDirective&gt; getDirectives() {
2776             return directives;
2777         }
2778 
2779         @Override @DefinedBy(Api.COMPILER_TREE)
2780         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2781             return v.visitModule(this, d);
2782         }
2783 
2784         @Override
2785         public Tag getTag() {
2786             return MODULEDEF;
2787         }
2788     }
2789 
2790     public static class JCExports extends JCDirective
2791             implements ExportsTree {
2792         public JCExpression qualid;
2793         public List&lt;JCExpression&gt; moduleNames;
2794         public ExportsDirective directive;
2795 
2796         protected JCExports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2797             this.qualid = qualId;
2798             this.moduleNames = moduleNames;
2799         }
2800 
2801         @Override
2802         public void accept(Visitor v) { v.visitExports(this); }
2803 
2804         @Override @DefinedBy(Api.COMPILER_TREE)
2805         public Kind getKind() {
2806             return Kind.EXPORTS;
2807         }
2808 
2809         @Override @DefinedBy(Api.COMPILER_TREE)
2810         public JCExpression getPackageName() {
2811             return qualid;
2812         }
2813 
2814         @Override @DefinedBy(Api.COMPILER_TREE)
2815         public List&lt;JCExpression&gt; getModuleNames() {
2816             return moduleNames;
2817         }
2818 
2819         @Override @DefinedBy(Api.COMPILER_TREE)
2820         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2821             return v.visitExports(this, d);
2822         }
2823 
2824         @Override
2825         public Tag getTag() {
2826             return Tag.EXPORTS;
2827         }
2828     }
2829 
2830     public static class JCOpens extends JCDirective
2831             implements OpensTree {
2832         public JCExpression qualid;
2833         public List&lt;JCExpression&gt; moduleNames;
2834         public OpensDirective directive;
2835 
2836         protected JCOpens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2837             this.qualid = qualId;
2838             this.moduleNames = moduleNames;
2839         }
2840 
2841         @Override
2842         public void accept(Visitor v) { v.visitOpens(this); }
2843 
2844         @Override @DefinedBy(Api.COMPILER_TREE)
2845         public Kind getKind() {
2846             return Kind.OPENS;
2847         }
2848 
2849         @Override @DefinedBy(Api.COMPILER_TREE)
2850         public JCExpression getPackageName() {
2851             return qualid;
2852         }
2853 
2854         @Override @DefinedBy(Api.COMPILER_TREE)
2855         public List&lt;JCExpression&gt; getModuleNames() {
2856             return moduleNames;
2857         }
2858 
2859         @Override @DefinedBy(Api.COMPILER_TREE)
2860         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2861             return v.visitOpens(this, d);
2862         }
2863 
2864         @Override
2865         public Tag getTag() {
2866             return Tag.OPENS;
2867         }
2868     }
2869 
2870     public static class JCProvides extends JCDirective
2871             implements ProvidesTree {
2872         public JCExpression serviceName;
2873         public List&lt;JCExpression&gt; implNames;
2874 
2875         protected JCProvides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
2876             this.serviceName = serviceName;
2877             this.implNames = implNames;
2878         }
2879 
2880         @Override
2881         public void accept(Visitor v) { v.visitProvides(this); }
2882 
2883         @Override @DefinedBy(Api.COMPILER_TREE)
2884         public Kind getKind() {
2885             return Kind.PROVIDES;
2886         }
2887 
2888         @Override @DefinedBy(Api.COMPILER_TREE)
2889         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2890             return v.visitProvides(this, d);
2891         }
2892 
2893         @Override @DefinedBy(Api.COMPILER_TREE)
2894         public JCExpression getServiceName() {
2895             return serviceName;
2896         }
2897 
2898         @Override @DefinedBy(Api.COMPILER_TREE)
2899         public List&lt;JCExpression&gt; getImplementationNames() {
2900             return implNames;
2901         }
2902 
2903         @Override
2904         public Tag getTag() {
2905             return PROVIDES;
2906         }
2907     }
2908 
2909     public static class JCRequires extends JCDirective
2910             implements RequiresTree {
2911         public boolean isTransitive;
2912         public boolean isStaticPhase;
2913         public JCExpression moduleName;
2914         public RequiresDirective directive;
2915 
2916         protected JCRequires(boolean isTransitive, boolean isStaticPhase, JCExpression moduleName) {
2917             this.isTransitive = isTransitive;
2918             this.isStaticPhase = isStaticPhase;
2919             this.moduleName = moduleName;
2920         }
2921 
2922         @Override
2923         public void accept(Visitor v) { v.visitRequires(this); }
2924 
2925         @Override @DefinedBy(Api.COMPILER_TREE)
2926         public Kind getKind() {
2927             return Kind.REQUIRES;
2928         }
2929 
2930         @Override @DefinedBy(Api.COMPILER_TREE)
2931         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2932             return v.visitRequires(this, d);
2933         }
2934 
2935         @Override @DefinedBy(Api.COMPILER_TREE)
2936         public boolean isTransitive() {
2937             return isTransitive;
2938         }
2939 
2940         @Override @DefinedBy(Api.COMPILER_TREE)
2941         public boolean isStatic() {
2942             return isStaticPhase;
2943         }
2944 
2945         @Override @DefinedBy(Api.COMPILER_TREE)
2946         public JCExpression getModuleName() {
2947             return moduleName;
2948         }
2949 
2950         @Override
2951         public Tag getTag() {
2952             return REQUIRES;
2953         }
2954     }
2955 
2956     public static class JCUses extends JCDirective
2957             implements UsesTree {
2958         public JCExpression qualid;
2959 
2960         protected JCUses(JCExpression qualId) {
2961             this.qualid = qualId;
2962         }
2963 
2964         @Override
2965         public void accept(Visitor v) { v.visitUses(this); }
2966 
2967         @Override @DefinedBy(Api.COMPILER_TREE)
2968         public Kind getKind() {
2969             return Kind.USES;
2970         }
2971 
2972         @Override @DefinedBy(Api.COMPILER_TREE)
2973         public JCExpression getServiceName() {
2974             return qualid;
2975         }
2976 
2977         @Override @DefinedBy(Api.COMPILER_TREE)
2978         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2979             return v.visitUses(this, d);
2980         }
2981 
2982         @Override
2983         public Tag getTag() {
2984             return USES;
2985         }
2986     }
2987 
2988     public static class JCErroneous extends JCExpression
2989             implements ErroneousTree {
2990         public List&lt;? extends JCTree&gt; errs;
2991         protected JCErroneous(List&lt;? extends JCTree&gt; errs) {
2992             this.errs = errs;
2993         }
2994         @Override
2995         public void accept(Visitor v) { v.visitErroneous(this); }
2996 
2997         @DefinedBy(Api.COMPILER_TREE)
2998         public Kind getKind() { return Kind.ERRONEOUS; }
2999 
3000         @DefinedBy(Api.COMPILER_TREE)
3001         public List&lt;? extends JCTree&gt; getErrorTrees() {
3002             return errs;
3003         }
3004 
3005         @Override @DefinedBy(Api.COMPILER_TREE)
3006         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3007             return v.visitErroneous(this, d);
3008         }
3009         @Override
3010         public Tag getTag() {
3011             return ERRONEOUS;
3012         }
3013     }
3014 
3015     /** (let int x = 3; in x+2) */
3016     public static class LetExpr extends JCExpression {
3017         public List&lt;JCStatement&gt; defs;
3018         public JCExpression expr;
3019         /**true if a expr should be run through Gen.genCond:*/
3020         public boolean needsCond;
3021         protected LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {
3022             this.defs = defs;
3023             this.expr = expr;
3024         }
3025         @Override
3026         public void accept(Visitor v) { v.visitLetExpr(this); }
3027 
3028         @DefinedBy(Api.COMPILER_TREE)
3029         public Kind getKind() {
3030             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3031         }
3032         @Override @DefinedBy(Api.COMPILER_TREE)
3033         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3034             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3035         }
3036         @Override
3037         public Tag getTag() {
3038             return LETEXPR;
3039         }
3040     }
3041 
3042     /** An interface for tree factories
3043      */
3044     public interface Factory {
3045         JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs);
3046         JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
3047                                   JCExpression pid);
3048         JCImport Import(JCTree qualid, boolean staticImport);
3049         JCClassDecl ClassDef(JCModifiers mods,
3050                           Name name,
3051                           List&lt;JCTypeParameter&gt; typarams,
3052                           JCExpression extending,
3053                           List&lt;JCExpression&gt; implementing,
3054                           List&lt;JCTree&gt; defs);
3055         JCMethodDecl MethodDef(JCModifiers mods,
3056                             Name name,
3057                             JCExpression restype,
3058                             List&lt;JCTypeParameter&gt; typarams,
3059                             JCVariableDecl recvparam,
3060                             List&lt;JCVariableDecl&gt; params,
3061                             List&lt;JCExpression&gt; thrown,
3062                             JCBlock body,
3063                             JCExpression defaultValue);
3064         JCVariableDecl VarDef(JCModifiers mods,
3065                       Name name,
3066                       JCExpression vartype,
3067                       JCExpression init);
3068         JCSkip Skip();
3069         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3070         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3071         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3072         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3073                         JCExpression cond,
3074                         List&lt;JCExpressionStatement&gt; step,
3075                         JCStatement body);
3076         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3077         JCLabeledStatement Labelled(Name label, JCStatement body);
3078         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3079         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
3080         JCCase Case(@SuppressWarnings(&quot;removal&quot;) CaseKind caseKind, List&lt;JCExpression&gt; pat,
3081                     List&lt;JCStatement&gt; stats, JCTree body);
3082         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3083         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3084         JCTry Try(List&lt;JCTree&gt; resources,
3085                   JCBlock body,
3086                   List&lt;JCCatch&gt; catchers,
3087                   JCBlock finalizer);
3088         JCCatch Catch(JCVariableDecl param, JCBlock body);
3089         JCConditional Conditional(JCExpression cond,
3090                                 JCExpression thenpart,
3091                                 JCExpression elsepart);
3092         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3093         JCExpressionStatement Exec(JCExpression expr);
3094         JCBreak Break(JCExpression value);
3095         JCContinue Continue(Name label);
3096         JCReturn Return(JCExpression expr);
3097         JCThrow Throw(JCExpression expr);
3098         JCAssert Assert(JCExpression cond, JCExpression detail);
3099         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3100                     JCExpression fn,
3101                     List&lt;JCExpression&gt; args);
3102         JCNewClass NewClass(JCExpression encl,
3103                           List&lt;JCExpression&gt; typeargs,
3104                           JCExpression clazz,
3105                           List&lt;JCExpression&gt; args,
3106                           JCClassDecl def);
3107         JCNewArray NewArray(JCExpression elemtype,
3108                           List&lt;JCExpression&gt; dims,
3109                           List&lt;JCExpression&gt; elems);
3110         JCParens Parens(JCExpression expr);
3111         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3112         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3113         JCUnary Unary(Tag opcode, JCExpression arg);
3114         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3115         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3116         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
3117         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3118         JCFieldAccess Select(JCExpression selected, Name selector);
3119         JCIdent Ident(Name idname);
3120         JCLiteral Literal(TypeTag tag, Object value);
3121         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3122         JCArrayTypeTree TypeArray(JCExpression elemtype);
3123         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3124         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3125         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3126         TypeBoundKind TypeBoundKind(BoundKind kind);
3127         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3128         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3129         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3130         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3131         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3132         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3133         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3134         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3135         JCUses Uses(JCExpression qualId);
3136         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);
3137     }
3138 
3139     /** A generic visitor class for trees.
3140      */
3141     public static abstract class Visitor {
3142         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3143         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3144         public void visitImport(JCImport that)               { visitTree(that); }
3145         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3146         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3147         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3148         public void visitSkip(JCSkip that)                   { visitTree(that); }
3149         public void visitBlock(JCBlock that)                 { visitTree(that); }
3150         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3151         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3152         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3153         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3154         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3155         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3156         public void visitCase(JCCase that)                   { visitTree(that); }
3157         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3158         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3159         public void visitTry(JCTry that)                     { visitTree(that); }
3160         public void visitCatch(JCCatch that)                 { visitTree(that); }
3161         public void visitConditional(JCConditional that)     { visitTree(that); }
3162         public void visitIf(JCIf that)                       { visitTree(that); }
3163         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3164         public void visitBreak(JCBreak that)                 { visitTree(that); }
3165         public void visitContinue(JCContinue that)           { visitTree(that); }
3166         public void visitReturn(JCReturn that)               { visitTree(that); }
3167         public void visitThrow(JCThrow that)                 { visitTree(that); }
3168         public void visitAssert(JCAssert that)               { visitTree(that); }
3169         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3170         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3171         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3172         public void visitLambda(JCLambda that)               { visitTree(that); }
3173         public void visitParens(JCParens that)               { visitTree(that); }
3174         public void visitAssign(JCAssign that)               { visitTree(that); }
3175         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3176         public void visitUnary(JCUnary that)                 { visitTree(that); }
3177         public void visitBinary(JCBinary that)               { visitTree(that); }
3178         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3179         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
3180         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3181         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3182         public void visitReference(JCMemberReference that)   { visitTree(that); }
3183         public void visitIdent(JCIdent that)                 { visitTree(that); }
3184         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3185         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3186         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3187         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3188         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3189         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3190         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3191         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3192         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3193         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3194         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3195         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3196         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3197         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3198         public void visitExports(JCExports that)             { visitTree(that); }
3199         public void visitOpens(JCOpens that)                 { visitTree(that); }
3200         public void visitProvides(JCProvides that)           { visitTree(that); }
3201         public void visitRequires(JCRequires that)           { visitTree(that); }
3202         public void visitUses(JCUses that)                   { visitTree(that); }
3203         public void visitLetExpr(LetExpr that)               { visitTree(that); }
3204 
3205         public void visitTree(JCTree that)                   { Assert.error(); }
3206     }
3207 
3208 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.HashSet;
  29 import java.util.Set;
  30 import java.util.function.BiConsumer;
  31 
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Lint.LintCategory;
  36 import com.sun.tools.javac.code.Scope.ImportFilter;
  37 import com.sun.tools.javac.code.Scope.NamedImportScope;
  38 import com.sun.tools.javac.code.Scope.StarImportScope;
  39 import com.sun.tools.javac.code.Scope.WriteableScope;
  40 import com.sun.tools.javac.code.Source.Feature;
  41 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  42 import com.sun.tools.javac.tree.*;
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import com.sun.tools.javac.code.Symbol.*;
  47 import com.sun.tools.javac.code.Type.*;
  48 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  49 import com.sun.tools.javac.tree.JCTree.*;
  50 
  51 import static com.sun.tools.javac.code.Flags.*;
  52 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  53 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  54 import static com.sun.tools.javac.code.Kinds.Kind.*;
  55 import static com.sun.tools.javac.code.TypeTag.CLASS;
  56 import static com.sun.tools.javac.code.TypeTag.ERROR;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  61 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  62 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  63 
  64 /** This is the second phase of Enter, in which classes are completed
  65  *  by resolving their headers and entering their members in the into
  66  *  the class scope. See Enter for an overall overview.
  67  *
  68  *  This class uses internal phases to process the classes. When a phase
  69  *  processes classes, the lower phases are not invoked until all classes
  70  *  pass through the current phase. Note that it is possible that upper phases
  71  *  are run due to recursive completion. The internal phases are:
  72  *  - ImportPhase: shallow pass through imports, adds information about imports
  73  *                 the NamedImportScope and StarImportScope, but avoids queries
  74  *                 about class hierarchy.
  75  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  76  *                    type parameters of the class or type argument of the supertypes.
  77  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
  78  *                 type parameters, attributing supertypes including type arguments
  79  *                 and scheduling full annotation attribution. This phase also adds
  80  *                 a synthetic default constructor if needed and synthetic &quot;this&quot; field.
  81  *  - MembersPhase: resolves headers for fields, methods and constructors in the given class.
  82  *                  Also generates synthetic enum members.
  83  *
  84  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  *  If you write code that depends on this, you do so at your own risk.
  86  *  This code and its internal interfaces are subject to change or
  87  *  deletion without notice.&lt;/b&gt;
  88  */
  89 public class TypeEnter implements Completer {
  90     protected static final Context.Key&lt;TypeEnter&gt; typeEnterKey = new Context.Key&lt;&gt;();
  91 
  92     /** A switch to determine whether we check for package/class conflicts
  93      */
  94     final static boolean checkClash = true;
  95 
  96     private final Names names;
  97     private final Enter enter;
  98     private final MemberEnter memberEnter;
  99     private final Log log;
 100     private final Check chk;
 101     private final Attr attr;
 102     private final Symtab syms;
 103     private final TreeMaker make;
 104     private final Todo todo;
 105     private final Annotate annotate;
 106     private final TypeAnnotations typeAnnotations;
 107     private final Types types;
 108     private final JCDiagnostic.Factory diags;
 109     private final DeferredLintHandler deferredLintHandler;
 110     private final Lint lint;
 111     private final TypeEnvs typeEnvs;
 112     private final Dependencies dependencies;
 113 
 114     public static TypeEnter instance(Context context) {
 115         TypeEnter instance = context.get(typeEnterKey);
 116         if (instance == null)
 117             instance = new TypeEnter(context);
 118         return instance;
 119     }
 120 
 121     protected TypeEnter(Context context) {
 122         context.put(typeEnterKey, this);
 123         names = Names.instance(context);
 124         enter = Enter.instance(context);
 125         memberEnter = MemberEnter.instance(context);
 126         log = Log.instance(context);
 127         chk = Check.instance(context);
 128         attr = Attr.instance(context);
 129         syms = Symtab.instance(context);
 130         make = TreeMaker.instance(context);
 131         todo = Todo.instance(context);
 132         annotate = Annotate.instance(context);
 133         typeAnnotations = TypeAnnotations.instance(context);
 134         types = Types.instance(context);
 135         diags = JCDiagnostic.Factory.instance(context);
 136         deferredLintHandler = DeferredLintHandler.instance(context);
 137         lint = Lint.instance(context);
 138         typeEnvs = TypeEnvs.instance(context);
 139         dependencies = Dependencies.instance(context);
 140         Source source = Source.instance(context);
 141         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 142         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
 143     }
 144 
 145     /** Switch: support type annotations.
 146      */
 147     boolean allowTypeAnnos;
 148 
 149     /**
 150      * Switch: should deprecation warnings be issued on import
 151      */
 152     boolean allowDeprecationOnImport;
 153 
 154     /** A flag to disable completion from time to time during member
 155      *  enter, as we only need to look up types.  This avoids
 156      *  unnecessarily deep recursion.
 157      */
 158     boolean completionEnabled = true;
 159 
 160     /* Verify Imports:
 161      */
 162     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 163         // if there remain any unimported toplevels (these must have
 164         // no classes at all), process their import statements as well.
 165         for (JCCompilationUnit tree : trees) {
 166             if (!tree.starImportScope.isFilled()) {
 167                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 168                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 169             }
 170         }
 171     }
 172 
 173 /* ********************************************************************
 174  * Source completer
 175  *********************************************************************/
 176 
 177     /** Complete entering a class.
 178      *  @param sym         The symbol of the class to be completed.
 179      */
 180     @Override
 181     public void complete(Symbol sym) throws CompletionFailure {
 182         // Suppress some (recursive) MemberEnter invocations
 183         if (!completionEnabled) {
 184             // Re-install same completer for next time around and return.
 185             Assert.check((sym.flags() &amp; Flags.COMPOUND) == 0);
 186             sym.completer = this;
 187             return;
 188         }
 189 
 190         try {
 191             annotate.blockAnnotations();
 192             sym.flags_field |= UNATTRIBUTED;
 193 
 194             List&lt;Env&lt;AttrContext&gt;&gt; queue;
 195 
 196             dependencies.push((ClassSymbol) sym, CompletionCause.MEMBER_ENTER);
 197             try {
 198                 queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));
 199             } finally {
 200                 dependencies.pop();
 201             }
 202 
 203             if (!queue.isEmpty()) {
 204                 Set&lt;JCCompilationUnit&gt; seen = new HashSet&lt;&gt;();
 205 
 206                 for (Env&lt;AttrContext&gt; env : queue) {
 207                     if (env.toplevel.defs.contains(env.enclClass) &amp;&amp; seen.add(env.toplevel)) {
 208                         finishImports(env.toplevel, () -&gt; {});
 209                     }
 210                 }
 211             }
 212         } finally {
 213             annotate.unblockAnnotations();
 214         }
 215     }
 216 
 217     void finishImports(JCCompilationUnit toplevel, Runnable resolve) {
 218         JavaFileObject prev = log.useSource(toplevel.sourcefile);
 219         try {
 220             resolve.run();
 221             chk.checkImportsUnique(toplevel);
 222             chk.checkImportsResolvable(toplevel);
 223             chk.checkImportedPackagesObservable(toplevel);
 224             toplevel.namedImportScope.finalizeScope();
 225             toplevel.starImportScope.finalizeScope();
 226         } catch (CompletionFailure cf) {
 227             chk.completionError(toplevel.pos(), cf);
 228         } finally {
 229             log.useSource(prev);
 230         }
 231     }
 232 
 233     abstract class Phase {
 234         private final ListBuffer&lt;Env&lt;AttrContext&gt;&gt; queue = new ListBuffer&lt;&gt;();
 235         private final Phase next;
 236         private final CompletionCause phaseName;
 237 
 238         Phase(CompletionCause phaseName, Phase next) {
 239             this.phaseName = phaseName;
 240             this.next = next;
 241         }
 242 
 243         public final List&lt;Env&lt;AttrContext&gt;&gt; completeEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 244             boolean firstToComplete = queue.isEmpty();
 245 
 246             Phase prevTopLevelPhase = topLevelPhase;
 247             boolean success = false;
 248 
 249             try {
 250                 topLevelPhase = this;
 251                 doCompleteEnvs(envs);
 252                 success = true;
 253             } finally {
 254                 topLevelPhase = prevTopLevelPhase;
 255                 if (!success &amp;&amp; firstToComplete) {
 256                     //an exception was thrown, e.g. BreakAttr:
 257                     //the queue would become stale, clear it:
 258                     queue.clear();
 259                 }
 260             }
 261 
 262             if (firstToComplete) {
 263                 List&lt;Env&lt;AttrContext&gt;&gt; out = queue.toList();
 264 
 265                 queue.clear();
 266                 return next != null ? next.completeEnvs(out) : out;
 267             } else {
 268                 return List.nil();
 269             }
 270         }
 271 
 272         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 273             for (Env&lt;AttrContext&gt; env : envs) {
 274                 JCClassDecl tree = (JCClassDecl)env.tree;
 275 
 276                 queue.add(env);
 277 
 278                 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 279                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
 280                 try {
 281                     dependencies.push(env.enclClass.sym, phaseName);
 282                     runPhase(env);
 283                 } catch (CompletionFailure ex) {
 284                     chk.completionError(tree.pos(), ex);
 285                 } finally {
 286                     dependencies.pop();
 287                     deferredLintHandler.setPos(prevLintPos);
 288                     log.useSource(prev);
 289                 }
 290             }
 291         }
 292 
 293         protected abstract void runPhase(Env&lt;AttrContext&gt; env);
 294     }
 295 
 296     private final ImportsPhase completeClass = new ImportsPhase();
 297     private Phase topLevelPhase;
 298 
 299     /**Analyze import clauses.
 300      */
 301     private final class ImportsPhase extends Phase {
 302 
 303         public ImportsPhase() {
 304             super(CompletionCause.IMPORTS_PHASE, new HierarchyPhase());
 305         }
 306 
 307         Env&lt;AttrContext&gt; env;
 308         ImportFilter staticImportFilter;
 309         ImportFilter typeImportFilter;
 310         BiConsumer&lt;JCImport, CompletionFailure&gt; cfHandler =
 311                 (imp, cf) -&gt; chk.completionError(imp.pos(), cf);
 312 
 313         @Override
 314         protected void runPhase(Env&lt;AttrContext&gt; env) {
 315             JCClassDecl tree = env.enclClass;
 316             ClassSymbol sym = tree.sym;
 317 
 318             // If sym is a toplevel-class, make sure any import
 319             // clauses in its source file have been seen.
 320             if (sym.owner.kind == PCK) {
 321                 resolveImports(env.toplevel, env.enclosing(TOPLEVEL));
 322                 todo.append(env);
 323             }
 324 
 325             if (sym.owner.kind == TYP)
 326                 sym.owner.complete();
 327         }
 328 
 329         private void resolveImports(JCCompilationUnit tree, Env&lt;AttrContext&gt; env) {
 330             if (tree.starImportScope.isFilled()) {
 331                 // we must have already processed this toplevel
 332                 return;
 333             }
 334 
 335             ImportFilter prevStaticImportFilter = staticImportFilter;
 336             ImportFilter prevTypeImportFilter = typeImportFilter;
 337             DiagnosticPosition prevLintPos = deferredLintHandler.immediate();
 338             Lint prevLint = chk.setLint(lint);
 339             Env&lt;AttrContext&gt; prevEnv = this.env;
 340             try {
 341                 this.env = env;
 342                 final PackageSymbol packge = env.toplevel.packge;
 343                 this.staticImportFilter =
 344                         (origin, sym) -&gt; sym.isStatic() &amp;&amp;
 345                                          chk.importAccessible(sym, packge) &amp;&amp;
 346                                          sym.isMemberOf((TypeSymbol) origin.owner, types);
 347                 this.typeImportFilter =
 348                         (origin, sym) -&gt; sym.kind == TYP &amp;&amp;
 349                                          chk.importAccessible(sym, packge);
 350 
 351                 // Import-on-demand java.lang.
 352                 PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);
 353                 if (javaLang.members().isEmpty() &amp;&amp; !javaLang.exists())
 354                     throw new FatalError(diags.fragment(Fragments.FatalErrNoJavaLang));
 355                 importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);
 356 
 357                 JCModuleDecl decl = tree.getModuleDecl();
 358 
 359                 // Process the package def and all import clauses.
 360                 if (tree.getPackage() != null &amp;&amp; decl == null)
 361                     checkClassPackageClash(tree.getPackage());
 362 
 363                 for (JCImport imp : tree.getImports()) {
 364                     doImport(imp);
 365                 }
 366 
 367                 if (decl != null) {
 368                     //check @Deprecated:
 369                     markDeprecated(decl.sym, decl.mods.annotations, env);
 370                     // process module annotations
 371                     annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);
 372                 }
 373             } finally {
 374                 this.env = prevEnv;
 375                 chk.setLint(prevLint);
 376                 deferredLintHandler.setPos(prevLintPos);
 377                 this.staticImportFilter = prevStaticImportFilter;
 378                 this.typeImportFilter = prevTypeImportFilter;
 379             }
 380         }
 381 
 382         private void checkClassPackageClash(JCPackageDecl tree) {
 383             // check that no class exists with same fully qualified name as
 384             // toplevel package
 385             if (checkClash &amp;&amp; tree.pid != null) {
 386                 Symbol p = env.toplevel.packge;
 387                 while (p.owner != syms.rootPackage) {
 388                     p.owner.complete(); // enter all class members of p
 389                     //need to lookup the owning module/package:
 390                     PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, p.owner.getQualifiedName());
 391                     if (syms.getClass(pack.modle, p.getQualifiedName()) != null) {
 392                         log.error(tree.pos,
 393                                   Errors.PkgClashesWithClassOfSameName(p));
 394                     }
 395                     p = p.owner;
 396                 }
 397             }
 398             // process package annotations
 399             annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);
 400         }
 401 
 402         private void doImport(JCImport tree) {
 403             JCFieldAccess imp = (JCFieldAccess)tree.qualid;
 404             Name name = TreeInfo.name(imp);
 405 
 406             // Create a local environment pointing to this tree to disable
 407             // effects of other imports in Resolve.findGlobalType
 408             Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 409 
 410             TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
 411             if (name == names.asterisk) {
 412                 // Import on demand.
 413                 chk.checkCanonical(imp.selected);
 414                 if (tree.staticImport)
 415                     importStaticAll(tree, p, env);
 416                 else
 417                     importAll(tree, p, env);
 418             } else {
 419                 // Named type import.
 420                 if (tree.staticImport) {
 421                     importNamedStatic(tree, p, name, localEnv);
 422                     chk.checkCanonical(imp.selected);
 423                 } else {
 424                     Type importedType = attribImportType(imp, localEnv);
 425                     Type originalType = importedType.getOriginalType();
 426                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 427                     chk.checkCanonical(imp);
 428                     importNamed(tree.pos(), c, env, tree);
 429                 }
 430             }
 431         }
 432 
 433         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 434             Assert.check(completionEnabled);
 435             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
 436                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL));
 437             try {
 438                 // To prevent deep recursion, suppress completion of some
 439                 // types.
 440                 completionEnabled = false;
 441                 return attr.attribType(tree, env);
 442             } finally {
 443                 completionEnabled = true;
 444                 chk.setLint(prevLint);
 445             }
 446         }
 447 
 448         /** Import all classes of a class or package on demand.
 449          *  @param imp           The import that is being handled.
 450          *  @param tsym          The class or package the members of which are imported.
 451          *  @param env           The env in which the imported classes will be entered.
 452          */
 453         private void importAll(JCImport imp,
 454                                final TypeSymbol tsym,
 455                                Env&lt;AttrContext&gt; env) {
 456             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
 457         }
 458 
 459         /** Import all static members of a class or package on demand.
 460          *  @param imp           The import that is being handled.
 461          *  @param tsym          The class or package the members of which are imported.
 462          *  @param env           The env in which the imported classes will be entered.
 463          */
 464         private void importStaticAll(JCImport imp,
 465                                      final TypeSymbol tsym,
 466                                      Env&lt;AttrContext&gt; env) {
 467             final StarImportScope toScope = env.toplevel.starImportScope;
 468             final TypeSymbol origin = tsym;
 469 
 470             toScope.importAll(types, origin.members(), staticImportFilter, imp, cfHandler);
 471         }
 472 
 473         /** Import statics types of a given name.  Non-types are handled in Attr.
 474          *  @param imp           The import that is being handled.
 475          *  @param tsym          The class from which the name is imported.
 476          *  @param name          The (simple) name being imported.
 477          *  @param env           The environment containing the named import
 478          *                  scope to add to.
 479          */
 480         private void importNamedStatic(final JCImport imp,
 481                                        final TypeSymbol tsym,
 482                                        final Name name,
 483                                        final Env&lt;AttrContext&gt; env) {
 484             if (tsym.kind != TYP) {
 485                 log.error(DiagnosticFlag.RECOVERABLE, imp.pos(), Errors.StaticImpOnlyClassesAndInterfaces);
 486                 return;
 487             }
 488 
 489             final NamedImportScope toScope = env.toplevel.namedImportScope;
 490             final Scope originMembers = tsym.members();
 491 
 492             imp.importScope = toScope.importByName(types, originMembers, name, staticImportFilter, imp, cfHandler);
 493         }
 494 
 495         /** Import given class.
 496          *  @param pos           Position to be used for error reporting.
 497          *  @param tsym          The class to be imported.
 498          *  @param env           The environment containing the named import
 499          *                  scope to add to.
 500          */
 501         private void importNamed(DiagnosticPosition pos, final Symbol tsym, Env&lt;AttrContext&gt; env, JCImport imp) {
 502             if (tsym.kind == TYP)
 503                 imp.importScope = env.toplevel.namedImportScope.importType(tsym.owner.members(), tsym.owner.members(), tsym);
 504         }
 505 
 506     }
 507 
 508     /**Defines common utility methods used by the HierarchyPhase and HeaderPhase.
 509      */
 510     private abstract class AbstractHeaderPhase extends Phase {
 511 
 512         public AbstractHeaderPhase(CompletionCause phaseName, Phase next) {
 513             super(phaseName, next);
 514         }
 515 
 516         protected Env&lt;AttrContext&gt; baseEnv(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 517             WriteableScope baseScope = WriteableScope.create(tree.sym);
 518             //import already entered local classes into base scope
 519             for (Symbol sym : env.outer.info.scope.getSymbols(NON_RECURSIVE)) {
 520                 if (sym.isLocal()) {
 521                     baseScope.enter(sym);
 522                 }
 523             }
 524             //import current type-parameters into base scope
 525             if (tree.typarams != null)
 526                 for (List&lt;JCTypeParameter&gt; typarams = tree.typarams;
 527                      typarams.nonEmpty();
 528                      typarams = typarams.tail)
 529                     baseScope.enter(typarams.head.type.tsym);
 530             Env&lt;AttrContext&gt; outer = env.outer; // the base clause can&#39;t see members of this class
 531             Env&lt;AttrContext&gt; localEnv = outer.dup(tree, outer.info.dup(baseScope));
 532             localEnv.baseClause = true;
 533             localEnv.outer = outer;
 534             localEnv.info.isSelfCall = false;
 535             return localEnv;
 536         }
 537 
 538         /** Generate a base clause for an enum type.
 539          *  @param pos              The position for trees and diagnostics, if any
 540          *  @param c                The class symbol of the enum
 541          */
 542         protected  JCExpression enumBase(int pos, ClassSymbol c) {
 543             JCExpression result = make.at(pos).
 544                 TypeApply(make.QualIdent(syms.enumSym),
 545                           List.of(make.Type(c.type)));
 546             return result;
 547         }
 548 
 549         protected Type modelMissingTypes(Env&lt;AttrContext&gt; env, Type t, final JCExpression tree, final boolean interfaceExpected) {
 550             if (!t.hasTag(ERROR))
 551                 return t;
 552 
 553             return new ErrorType(t.getOriginalType(), t.tsym) {
 554                 private Type modelType;
 555 
 556                 @Override
 557                 public Type getModelType() {
 558                     if (modelType == null)
 559                         modelType = new Synthesizer(env.toplevel.modle, getOriginalType(), interfaceExpected).visit(tree);
 560                     return modelType;
 561                 }
 562             };
 563         }
 564             // where:
 565             private class Synthesizer extends JCTree.Visitor {
 566                 ModuleSymbol msym;
 567                 Type originalType;
 568                 boolean interfaceExpected;
 569                 List&lt;ClassSymbol&gt; synthesizedSymbols = List.nil();
 570                 Type result;
 571 
 572                 Synthesizer(ModuleSymbol msym, Type originalType, boolean interfaceExpected) {
 573                     this.msym = msym;
 574                     this.originalType = originalType;
 575                     this.interfaceExpected = interfaceExpected;
 576                 }
 577 
 578                 Type visit(JCTree tree) {
 579                     tree.accept(this);
 580                     return result;
 581                 }
 582 
 583                 List&lt;Type&gt; visit(List&lt;? extends JCTree&gt; trees) {
 584                     ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 585                     for (JCTree t: trees)
 586                         lb.append(visit(t));
 587                     return lb.toList();
 588                 }
 589 
 590                 @Override
 591                 public void visitTree(JCTree tree) {
 592                     result = syms.errType;
 593                 }
 594 
 595                 @Override
 596                 public void visitIdent(JCIdent tree) {
 597                     if (!tree.type.hasTag(ERROR)) {
 598                         result = tree.type;
 599                     } else {
 600                         result = synthesizeClass(tree.name, msym.unnamedPackage).type;
 601                     }
 602                 }
 603 
 604                 @Override
 605                 public void visitSelect(JCFieldAccess tree) {
 606                     if (!tree.type.hasTag(ERROR)) {
 607                         result = tree.type;
 608                     } else {
 609                         Type selectedType;
 610                         boolean prev = interfaceExpected;
 611                         try {
 612                             interfaceExpected = false;
 613                             selectedType = visit(tree.selected);
 614                         } finally {
 615                             interfaceExpected = prev;
 616                         }
 617                         ClassSymbol c = synthesizeClass(tree.name, selectedType.tsym);
 618                         result = c.type;
 619                     }
 620                 }
 621 
 622                 @Override
 623                 public void visitTypeApply(JCTypeApply tree) {
 624                     if (!tree.type.hasTag(ERROR)) {
 625                         result = tree.type;
 626                     } else {
 627                         ClassType clazzType = (ClassType) visit(tree.clazz);
 628                         if (synthesizedSymbols.contains(clazzType.tsym))
 629                             synthesizeTyparams((ClassSymbol) clazzType.tsym, tree.arguments.size());
 630                         final List&lt;Type&gt; actuals = visit(tree.arguments);
 631                         result = new ErrorType(tree.type, clazzType.tsym) {
 632                             @Override @DefinedBy(Api.LANGUAGE_MODEL)
 633                             public List&lt;Type&gt; getTypeArguments() {
 634                                 return actuals;
 635                             }
 636                         };
 637                     }
 638                 }
 639 
 640                 ClassSymbol synthesizeClass(Name name, Symbol owner) {
 641                     int flags = interfaceExpected ? INTERFACE : 0;
 642                     ClassSymbol c = new ClassSymbol(flags, name, owner);
 643                     c.members_field = new Scope.ErrorScope(c);
 644                     c.type = new ErrorType(originalType, c) {
 645                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 646                         public List&lt;Type&gt; getTypeArguments() {
 647                             return typarams_field;
 648                         }
 649                     };
 650                     synthesizedSymbols = synthesizedSymbols.prepend(c);
 651                     return c;
 652                 }
 653 
 654                 void synthesizeTyparams(ClassSymbol sym, int n) {
 655                     ClassType ct = (ClassType) sym.type;
 656                     Assert.check(ct.typarams_field.isEmpty());
 657                     if (n == 1) {
 658                         TypeVar v = new TypeVar(names.fromString(&quot;T&quot;), sym, syms.botType);
 659                         ct.typarams_field = ct.typarams_field.prepend(v);
 660                     } else {
 661                         for (int i = n; i &gt; 0; i--) {
 662                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 663                                                     syms.botType);
 664                             ct.typarams_field = ct.typarams_field.prepend(v);
 665                         }
 666                     }
 667                 }
 668             }
 669 
 670         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 671             JCClassDecl tree = env.enclClass;
 672             ClassSymbol sym = tree.sym;
 673             ClassType ct = (ClassType)sym.type;
 674             // Determine supertype.
 675             Type supertype;
 676             JCExpression extending;
 677 
 678             if (tree.extending != null) {
 679                 extending = clearTypeParams(tree.extending);
 680                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
 681             } else {
 682                 extending = null;
 683                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 684                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 685                                   true, false, false)
 686                 : (sym.fullname == names.java_lang_Object)
 687                 ? Type.noType
 688                 : syms.objectType;
 689             }
 690             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 691 
 692             // Determine interfaces.
 693             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 694             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 695             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 696             for (JCExpression iface : interfaceTrees) {
 697                 iface = clearTypeParams(iface);
 698                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 699                 if (it.hasTag(CLASS)) {
 700                     interfaces.append(it);
 701                     if (all_interfaces != null) all_interfaces.append(it);
 702                 } else {
 703                     if (all_interfaces == null)
 704                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 705                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 706                 }
 707             }
 708 
 709             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 710                 ct.interfaces_field = List.of(syms.annotationType);
 711                 ct.all_interfaces_field = ct.interfaces_field;
 712             }  else {
 713                 ct.interfaces_field = interfaces.toList();
 714                 ct.all_interfaces_field = (all_interfaces == null)
 715                         ? ct.interfaces_field : all_interfaces.toList();
 716             }
 717         }
 718             //where:
 719             protected JCExpression clearTypeParams(JCExpression superType) {
 720                 return superType;
 721             }
 722     }
 723 
 724     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 725 
 726         public HierarchyPhase() {
 727             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 728         }
 729 
 730         @Override
 731         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 732             //The ClassSymbols in the envs list may not be in the dependency order.
 733             //To get proper results, for every class or interface C, the supertypes of
 734             //C must be processed by the HierarchyPhase phase before C.
 735             //To achieve that, the HierarchyPhase is registered as the Completer for
 736             //all the classes first, and then all the classes are completed.
 737             for (Env&lt;AttrContext&gt; env : envs) {
 738                 env.enclClass.sym.completer = this;
 739             }
 740             for (Env&lt;AttrContext&gt; env : envs) {
 741                 env.enclClass.sym.complete();
 742             }
 743         }
 744 
 745         @Override
 746         protected void runPhase(Env&lt;AttrContext&gt; env) {
 747             JCClassDecl tree = env.enclClass;
 748             ClassSymbol sym = tree.sym;
 749             ClassType ct = (ClassType)sym.type;
 750 
 751             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 752 
 753             attribSuperTypes(env, baseEnv);
 754 
 755             if (sym.fullname == names.java_lang_Object) {
 756                 if (tree.extending != null) {
 757                     chk.checkNonCyclic(tree.extending.pos(),
 758                                        ct.supertype_field);
 759                     ct.supertype_field = Type.noType;
 760                 }
 761                 else if (tree.implementing.nonEmpty()) {
 762                     chk.checkNonCyclic(tree.implementing.head.pos(),
 763                                        ct.interfaces_field.head);
 764                     ct.interfaces_field = List.nil();
 765                 }
 766             }
 767 
 768             markDeprecated(sym, tree.mods.annotations, baseEnv);
 769 
 770             chk.checkNonCyclicDecl(tree);
 771         }
 772             //where:
 773             @Override
 774             protected JCExpression clearTypeParams(JCExpression superType) {
 775                 switch (superType.getTag()) {
 776                     case TYPEAPPLY:
 777                         return ((JCTypeApply) superType).clazz;
 778                 }
 779 
 780                 return superType;
 781             }
 782 
 783         @Override
 784         public void complete(Symbol sym) throws CompletionFailure {
 785             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 786                          (topLevelPhase == this));
 787 
 788             if (topLevelPhase != this) {
 789                 //only do the processing based on dependencies in the HierarchyPhase:
 790                 sym.completer = this;
 791                 return ;
 792             }
 793 
 794             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 795 
 796             super.doCompleteEnvs(List.of(env));
 797         }
 798 
 799     }
 800 
 801     private final class HeaderPhase extends AbstractHeaderPhase {
 802 
 803         public HeaderPhase() {
 804             super(CompletionCause.HEADER_PHASE, new MembersPhase());
 805         }
 806 
 807         @Override
 808         protected void runPhase(Env&lt;AttrContext&gt; env) {
 809             JCClassDecl tree = env.enclClass;
 810             ClassSymbol sym = tree.sym;
 811             ClassType ct = (ClassType)sym.type;
 812 
 813             // create an environment for evaluating the base clauses
 814             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 815 
 816             if (tree.extending != null)
 817                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 818             for (JCExpression impl : tree.implementing)
 819                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 820             annotate.flush();
 821 
 822             attribSuperTypes(env, baseEnv);
 823 
 824             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
 825 
 826             for (JCExpression iface : tree.implementing) {
 827                 Type it = iface.type;
 828                 if (it.hasTag(CLASS))
 829                     chk.checkNotRepeated(iface.pos(), types.erasure(it), interfaceSet);
 830             }
 831 
 832             annotate.annotateLater(tree.mods.annotations, baseEnv,
 833                         sym, tree.pos());
 834             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 835 
 836             for (JCTypeParameter tp : tree.typarams)
 837                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 838 
 839             // check that no package exists with same fully qualified name,
 840             // but admit classes in the unnamed package which have the same
 841             // name as a top-level package.
 842             if (checkClash &amp;&amp;
 843                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 844                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 845                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 846             }
 847             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 848                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 849                 sym.flags_field |= AUXILIARY;
 850             }
 851         }
 852     }
 853 
 854     /** Enter member fields and methods of a class
 855      */
 856     private final class MembersPhase extends Phase {
 857 
 858         public MembersPhase() {
 859             super(CompletionCause.MEMBERS_PHASE, null);
 860         }
 861 
 862         private boolean completing;
 863         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 864 
 865         @Override
 866         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 867             todo = todo.prependList(envs);
 868             if (completing) {
 869                 return ; //the top-level invocation will handle all envs
 870             }
 871             boolean prevCompleting = completing;
 872             completing = true;
 873             try {
 874                 while (todo.nonEmpty()) {
 875                     Env&lt;AttrContext&gt; head = todo.head;
 876                     todo = todo.tail;
 877                     super.doCompleteEnvs(List.of(head));
 878                 }
 879             } finally {
 880                 completing = prevCompleting;
 881             }
 882         }
 883 
 884         @Override
 885         protected void runPhase(Env&lt;AttrContext&gt; env) {
 886             JCClassDecl tree = env.enclClass;
 887             ClassSymbol sym = tree.sym;
 888             ClassType ct = (ClassType)sym.type;
 889 
 890             // Add default constructor if needed.
 891             if ((sym.flags() &amp; INTERFACE) == 0 &amp;&amp;
 892                 !TreeInfo.hasConstructors(tree.defs)) {
 893                 List&lt;Type&gt; argtypes = List.nil();
 894                 List&lt;Type&gt; typarams = List.nil();
 895                 List&lt;Type&gt; thrown = List.nil();
 896                 long ctorFlags = 0;
 897                 boolean based = false;
 898                 boolean addConstructor = true;
 899                 JCNewClass nc = null;
 900                 if (sym.name.isEmpty()) {
 901                     nc = (JCNewClass)env.next.tree;
 902                     if (nc.constructor != null) {
 903                         addConstructor = nc.constructor.kind != ERR;
 904                         Type superConstrType = types.memberType(sym.type,
 905                                                                 nc.constructor);
 906                         argtypes = superConstrType.getParameterTypes();
 907                         typarams = superConstrType.getTypeArguments();
 908                         ctorFlags = nc.constructor.flags() &amp; VARARGS;
 909                         if (nc.encl != null) {
 910                             argtypes = argtypes.prepend(nc.encl.type);
 911                             based = true;
 912                         }
 913                         thrown = superConstrType.getThrownTypes();
 914                     }
 915                 }
 916                 if (addConstructor) {
 917                     MethodSymbol basedConstructor = nc != null ?
 918                             (MethodSymbol)nc.constructor : null;
 919                     JCTree constrDef = DefaultConstructor(make.at(tree.pos), sym,
 920                                                         basedConstructor,
 921                                                         typarams, argtypes, thrown,
 922                                                         ctorFlags, based);
 923                     tree.defs = tree.defs.prepend(constrDef);
 924                 }
 925             }
 926 
 927             // enter symbols for &#39;this&#39; into current scope.
 928             VarSymbol thisSym =
 929                 new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);
 930             thisSym.pos = Position.FIRSTPOS;
 931             env.info.scope.enter(thisSym);
 932             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 933             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 934                     ct.supertype_field.hasTag(CLASS)) {
 935                 VarSymbol superSym =
 936                     new VarSymbol(FINAL | HASINIT, names._super,
 937                                   ct.supertype_field, sym);
 938                 superSym.pos = Position.FIRSTPOS;
 939                 env.info.scope.enter(superSym);
 940             }
 941 
 942             if (!tree.typarams.isEmpty()) {
 943                 for (JCTypeParameter tvar : tree.typarams) {
 944                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
 945                 }
 946             }
 947 
 948             finishClass(tree, env);
 949 
 950             if (allowTypeAnnos) {
 951                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 952                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 953             }
 954         }
 955 
 956         /** Enter members for a class.
 957          */
 958         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 959             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
 960                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
 961                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
 962                 addEnumMembers(tree, env);
 963             }
 964             memberEnter.memberEnter(tree.defs, env);
 965 
 966             if (tree.sym.isAnnotationType()) {
 967                 Assert.check(tree.sym.isCompleted());
 968                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
 969             }
 970         }
 971 
 972         /** Add the implicit members for an enum type
 973          *  to the symbol table.
 974          */
 975         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 976             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
 977 
 978             // public static T[] values() { return ???; }
 979             JCMethodDecl values = make.
 980                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
 981                           names.values,
 982                           valuesType,
 983                           List.nil(),
 984                           List.nil(),
 985                           List.nil(), // thrown
 986                           null, //make.Block(0, Tree.emptyList.prepend(make.Return(make.Ident(names._null)))),
 987                           null);
 988             memberEnter.memberEnter(values, env);
 989 
 990             // public static T valueOf(String name) { return ???; }
 991             JCMethodDecl valueOf = make.
 992                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
 993                           names.valueOf,
 994                           make.Type(tree.sym.type),
 995                           List.nil(),
 996                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
 997                                                              Flags.MANDATED),
 998                                                 names.fromString(&quot;name&quot;),
 999                                                 make.Type(syms.stringType), null)),
1000                           List.nil(), // thrown
1001                           null, //make.Block(0, Tree.emptyList.prepend(make.Return(make.Ident(names._null)))),
1002                           null);
1003             memberEnter.memberEnter(valueOf, env);
1004         }
1005 
1006     }
1007 
1008 /* ***************************************************************************
1009  * tree building
1010  ****************************************************************************/
1011 
1012     /** Generate default constructor for given class. For classes different
1013      *  from java.lang.Object, this is:
1014      *
1015      *    c(argtype_0 x_0, ..., argtype_n x_n) throws thrown {
1016      *      super(x_0, ..., x_n)
1017      *    }
1018      *
1019      *  or, if based == true:
1020      *
1021      *    c(argtype_0 x_0, ..., argtype_n x_n) throws thrown {
1022      *      x_0.super(x_1, ..., x_n)
1023      *    }
1024      *
1025      *  @param make     The tree factory.
1026      *  @param c        The class owning the default constructor.
1027      *  @param argtypes The parameter types of the constructor.
1028      *  @param thrown   The thrown exceptions of the constructor.
1029      *  @param based    Is first parameter a this$n?
1030      */
1031     JCTree DefaultConstructor(TreeMaker make,
1032                             ClassSymbol c,
1033                             MethodSymbol baseInit,
1034                             List&lt;Type&gt; typarams,
1035                             List&lt;Type&gt; argtypes,
1036                             List&lt;Type&gt; thrown,
1037                             long flags,
1038                             boolean based) {
1039         JCTree result;
1040         if ((c.flags() &amp; ENUM) != 0 &amp;&amp;
1041             (types.supertype(c.type).tsym == syms.enumSym)) {
1042             // constructors of true enums are private
1043             flags = (flags &amp; ~AccessFlags) | PRIVATE | GENERATEDCONSTR;
1044         } else
1045             flags |= (c.flags() &amp; AccessFlags) | GENERATEDCONSTR;
1046         if (c.name.isEmpty()) {
1047             flags |= ANONCONSTR;
1048         }
1049         if (based) {
1050             flags |= ANONCONSTR_BASED;
1051         }
1052         Type mType = new MethodType(argtypes, null, thrown, c);
1053         Type initType = typarams.nonEmpty() ?
1054             new ForAll(typarams, mType) :
1055             mType;
1056         MethodSymbol init = new MethodSymbol(flags, names.init,
1057                 initType, c);
1058         init.params = createDefaultConstructorParams(make, baseInit, init,
1059                 argtypes, based);
1060         List&lt;JCVariableDecl&gt; params = make.Params(argtypes, init);
1061         List&lt;JCStatement&gt; stats = List.nil();
1062         if (c.type != syms.objectType) {
1063             stats = stats.prepend(SuperCall(make, typarams, params, based));
1064         }
1065         result = make.MethodDef(init, make.Block(0, stats));
1066         return result;
1067     }
1068 
1069     private List&lt;VarSymbol&gt; createDefaultConstructorParams(
1070             TreeMaker make,
1071             MethodSymbol baseInit,
1072             MethodSymbol init,
1073             List&lt;Type&gt; argtypes,
1074             boolean based) {
1075         List&lt;VarSymbol&gt; initParams = null;
1076         List&lt;Type&gt; argTypesList = argtypes;
1077         if (based) {
1078             /*  In this case argtypes will have an extra type, compared to baseInit,
1079              *  corresponding to the type of the enclosing instance i.e.:
1080              *
1081              *  Inner i = outer.new Inner(1){}
1082              *
1083              *  in the above example argtypes will be (Outer, int) and baseInit
1084              *  will have parameter&#39;s types (int). So in this case we have to add
1085              *  first the extra type in argtypes and then get the names of the
1086              *  parameters from baseInit.
1087              */
1088             initParams = List.nil();
1089             VarSymbol param = new VarSymbol(PARAMETER, make.paramName(0), argtypes.head, init);
1090             initParams = initParams.append(param);
1091             argTypesList = argTypesList.tail;
1092         }
1093         if (baseInit != null &amp;&amp; baseInit.params != null &amp;&amp;
1094             baseInit.params.nonEmpty() &amp;&amp; argTypesList.nonEmpty()) {
1095             initParams = (initParams == null) ? List.nil() : initParams;
1096             List&lt;VarSymbol&gt; baseInitParams = baseInit.params;
1097             while (baseInitParams.nonEmpty() &amp;&amp; argTypesList.nonEmpty()) {
1098                 VarSymbol param = new VarSymbol(baseInitParams.head.flags() | PARAMETER,
1099                         baseInitParams.head.name, argTypesList.head, init);
1100                 initParams = initParams.append(param);
1101                 baseInitParams = baseInitParams.tail;
1102                 argTypesList = argTypesList.tail;
1103             }
1104         }
1105         return initParams;
1106     }
1107 
1108     /** Generate call to superclass constructor. This is:
1109      *
1110      *    super(id_0, ..., id_n)
1111      *
1112      * or, if based == true
1113      *
1114      *    id_0.super(id_1,...,id_n)
1115      *
1116      *  where id_0, ..., id_n are the names of the given parameters.
1117      *
1118      *  @param make    The tree factory
1119      *  @param params  The parameters that need to be passed to super
1120      *  @param typarams  The type parameters that need to be passed to super
1121      *  @param based   Is first parameter a this$n?
1122      */
1123     JCExpressionStatement SuperCall(TreeMaker make,
1124                    List&lt;Type&gt; typarams,
1125                    List&lt;JCVariableDecl&gt; params,
1126                    boolean based) {
1127         JCExpression meth;
1128         if (based) {
1129             meth = make.Select(make.Ident(params.head), names._super);
1130             params = params.tail;
1131         } else {
1132             meth = make.Ident(names._super);
1133         }
1134         List&lt;JCExpression&gt; typeargs = typarams.nonEmpty() ? make.Types(typarams) : null;
1135         return make.Exec(make.Apply(typeargs, meth, make.Idents(params)));
1136     }
1137 
1138     /**
1139      * Mark sym deprecated if annotations contain @Deprecated annotation.
1140      */
1141     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1142         // In general, we cannot fully process annotations yet,  but we
1143         // can attribute the annotation types and then check to see if the
1144         // @Deprecated annotation is present.
1145         attr.attribAnnotationTypes(annotations, env);
1146         handleDeprecatedAnnotations(annotations, sym);
1147     }
1148 
1149     /**
1150      * If a list of annotations contains a reference to java.lang.Deprecated,
1151      * set the DEPRECATED flag.
1152      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1153      **/
1154     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1155         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1156             JCAnnotation a = al.head;
1157             if (a.annotationType.type == syms.deprecatedType) {
1158                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
1159                 a.args.stream()
1160                         .filter(e -&gt; e.hasTag(ASSIGN))
1161                         .map(e -&gt; (JCAssign) e)
1162                         .filter(assign -&gt; TreeInfo.name(assign.lhs) == names.forRemoval)
1163                         .findFirst()
1164                         .ifPresent(assign -&gt; {
1165                             JCExpression rhs = TreeInfo.skipParens(assign.rhs);
1166                             if (rhs.hasTag(LITERAL)
1167                                     &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {
1168                                 sym.flags_field |= DEPRECATED_REMOVAL;
1169                             }
1170                         });
1171             }
1172         }
1173     }
1174 }
    </pre>
  </body>
</html>
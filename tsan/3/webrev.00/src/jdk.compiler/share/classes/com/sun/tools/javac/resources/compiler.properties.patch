diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties b/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/resources/compiler.properties
@@ -1,7 +1,7 @@
 #
-# Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License version 2 only, as
 # published by the Free Software Foundation.  Oracle designates this
@@ -186,45 +186,48 @@
     bad initializer for {0}
 
 compiler.err.break.outside.switch.loop=\
     break outside switch or loop
 
-compiler.err.break.missing.value=\
-    missing break value
-
 compiler.err.break.outside.switch.expression=\
-    break outside of enclosing switch expression
+    attempt to break out of a switch expression
 
 compiler.err.continue.outside.switch.expression=\
-    continue outside of enclosing switch expression
+    attempt to continue out of a switch expression
 
 compiler.err.return.outside.switch.expression=\
-    return outside of enclosing switch expression
+    attempt to return out of a switch expression
 
 compiler.err.rule.completes.normally=\
     switch rule completes without providing a value\n\
     (switch rules in switch expressions must either provide a value or throw)
 
 compiler.err.switch.expression.completes.normally=\
     switch expression completes without providing a value\n\
     (switch expressions must either provide a value or throw for all possible input values)
 
-# 0: name
-compiler.err.break.ambiguous.target=\
-    ambiguous reference to ''{0}''\n\
-    (''{0}'' is both a label and an expression)
+compiler.err.no.switch.expression =\
+    yield outside of switch expression
+
+compiler.err.no.switch.expression.qualify=\
+    yield outside of switch expression\n\
+    (to invoke a method called yield, qualify the yield with a receiver or type name)
 
-# 0: tree tag
-compiler.err.break.expr.not.immediate=\
-    value break not supported in ''{0}''
+compiler.err.invalid.yield=\
+    invalid use of a restricted identifier ''yield''\n\
+    (to invoke a method called yield, qualify the yield with a receiver or type name)
 
-compiler.err.break.complex.value.no.switch.expression=\
-    unexpected value break
+compiler.warn.invalid.yield=\
+    ''yield'' may become a restricted identifier in a future release\n\
+    (to invoke a method called yield, qualify the yield with a receiver or type name)
 
 compiler.err.switch.expression.empty=\
     switch expression does not have any case clauses
 
+compiler.err.switch.expression.no.result.expressions=\
+    switch expression does not have any result expressions
+
 # 0: name
 compiler.err.call.must.be.first.stmt.in.ctor=\
     call to {0} must be first statement in constructor
 
 # 0: symbol kind, 1: name, 2: list of type or message segment, 3: list of type or message segment, 4: symbol kind, 5: type, 6: message segment
@@ -540,10 +543,14 @@
 
 # 0: symbol
 compiler.err.try.resource.may.not.be.assigned=\
     auto-closeable resource {0} may not be assigned
 
+# 0: symbol
+compiler.err.pattern.binding.may.not.be.assigned=\
+    pattern binding {0} may not be assigned
+
 # 0: symbol
 compiler.err.multicatch.parameter.may.not.be.assigned=\
     multi-catch parameter {0} may not be assigned
 
 # 0: type, 1: type
@@ -621,10 +628,19 @@
     illegal initializer for {0}
 
 compiler.err.illegal.line.end.in.char.lit=\
     illegal line end in character literal
 
+compiler.err.illegal.text.block.open=\
+    illegal text block open delimiter sequence, missing line terminator
+
+compiler.warn.inconsistent.white.space.indentation=\
+    inconsistent white space indentation
+
+compiler.warn.trailing.white.space.will.be.removed=\
+    trailing white space will be removed
+
 compiler.err.illegal.nonascii.digit=\
     illegal non-ASCII digit
 
 compiler.err.illegal.underscore=\
     illegal underscore
@@ -935,11 +951,11 @@
 
 # {0} - package in which the invisible class is declared
 # {1} - current module
 # 0: symbol, 1: symbol
 compiler.misc.not.def.access.does.not.read.unnamed=\
-    package {0} is declared in the unnamed module, but module {0} does not read it
+    package {0} is declared in the unnamed module, but module {1} does not read it
 
 # {0} - package in which the invisible class is declared
 # {1} - module in which {0} is declared
 # 0: symbol, 1: symbol
 compiler.misc.not.def.access.not.exported=\
@@ -1049,10 +1065,14 @@
 
 # 0: string
 compiler.err.proc.cant.find.class=\
     Could not find class file for ''{0}''.
 
+# 0: string
+compiler.err.proc.cant.load.class=\
+    Could not load processor class file due to ''{0}''.
+
 # Print a client-generated error message; assumed to be localized, no translation required
 # 0: string
 compiler.err.proc.messager=\
     {0}
 
@@ -1238,10 +1258,13 @@
     unclosed comment
 
 compiler.err.unclosed.str.lit=\
     unclosed string literal
 
+compiler.err.unclosed.text.block=\
+    unclosed text block
+
 # 0: string
 compiler.err.unsupported.encoding=\
     unsupported encoding: {0}
 
 compiler.err.io.exception=\
@@ -1249,33 +1272,47 @@
 
 # 0: name
 compiler.err.undef.label=\
     undefined label: {0}
 
-compiler.err.illegal.ref.to.var.type=\
-    illegal reference to restricted type ''var''
+# 0: name
+compiler.err.illegal.ref.to.restricted.type=\
+    illegal reference to restricted type ''{0}''
+
+# 0: name
+compiler.warn.illegal.ref.to.restricted.type=\
+    illegal reference to restricted type ''{0}''
+
+# 0: name, 1: source
+compiler.err.restricted.type.not.allowed=\
+    ''{0}'' not allowed here\n\
+    as of release {1}, ''{0}'' is a restricted type name and cannot be used for type declarations
 
-compiler.err.var.not.allowed=\
-    ''var'' not allowed here\n\
-    as of release 10, ''var'' is a restricted local variable type and cannot be used for type declarations
+# 0: name, 1: source
+compiler.warn.restricted.type.not.allowed=\
+    as of release {1}, ''{0}'' is a restricted type name and cannot be used for type declarations or as the element type of an array
 
-compiler.warn.var.not.allowed=\
-    as of release 10, ''var'' is a restricted local variable type and cannot be used for type declarations or as the element type of an array
+# 0: name, 1: source
+compiler.warn.restricted.type.not.allowed.preview=\
+    ''{0}'' may become a restricted type name in a future release and may be unusable for type declarations or as the element type of an array
 
 # 0: name (variable), 1: message segment
 compiler.err.cant.infer.local.var.type=\
     cannot infer type for local variable {0}\n\
     ({1})
 
-compiler.err.var.not.allowed.here=\
-    ''var'' is not allowed here
+# 0: name
+compiler.err.restricted.type.not.allowed.here=\
+    ''{0}'' is not allowed here
 
-compiler.err.var.not.allowed.array=\
-    ''var'' is not allowed as an element type of an array
+# 0: name
+compiler.err.restricted.type.not.allowed.array=\
+    ''{0}'' is not allowed as an element type of an array
 
-compiler.err.var.not.allowed.compound=\
-    ''var'' is not allowed in a compound declaration
+# 0: name
+compiler.err.restricted.type.not.allowed.compound=\
+    ''{0}'' is not allowed in a compound declaration
 
 # 0: fragment
 compiler.err.invalid.lambda.parameter.declaration=\
     invalid lambda parameter declaration\n\
     ({0})
@@ -1381,10 +1418,14 @@
 
 # 0: type
 compiler.misc.varargs.trustme.on.reifiable.varargs=\
     Varargs element type {0} is reifiable.
 
+# 0: type, 1: type
+compiler.err.instanceof.reifiable.not.safe=\
+    {0} cannot be safely cast to {1}
+
 # 0: symbol
 compiler.misc.varargs.trustme.on.non.varargs.meth=\
     Method {0} is not a varargs method.
 
 # 0: symbol
@@ -1634,10 +1675,18 @@
 
 # 0: number
 compiler.misc.count.error.plural=\
     {0} errors
 
+# 0: number, 1: number
+compiler.misc.count.error.recompile=\
+    only showing the first {0} errors, of {1} total; use -Xmaxerrs if you would like to see more
+
+# 0: number, 1: number
+compiler.misc.count.warn.recompile=\
+    only showing the first {0} warnings, of {1} total; use -Xmaxwarns if you would like to see more
+
 # 0: number
 compiler.misc.count.warn=\
     {0} warning
 
 # 0: number
@@ -1731,10 +1780,18 @@
 
 # 0: symbol, 1: symbol
 compiler.warn.has.been.deprecated.for.removal=\
     {0} in {1} has been deprecated and marked for removal
 
+# 0: symbol
+compiler.warn.is.preview=\
+    {0} is an API that is part of a preview feature
+
+# 0: symbol
+compiler.err.is.preview=\
+    {0} is an API that is part of a preview feature
+
 # 0: symbol
 compiler.warn.has.been.deprecated.module=\
     module {0} has been deprecated
 
 # 0: symbol
@@ -1822,10 +1879,14 @@
 
 # 0: string
 compiler.warn.source.no.bootclasspath=\
     bootstrap class path not set in conjunction with -source {0}
 
+# 0: string
+compiler.warn.source.no.system.modules.path=\
+    system modules path not set in conjunction with -source {0}
+
 # 0: string
 compiler.warn.option.obsolete.source=\
     source value {0} is obsolete and will be removed in a future release
 
 # 0: target
@@ -1897,10 +1958,22 @@
 
 # 0: source version, 1: string, 2: string
 compiler.warn.proc.processor.incompatible.source.version=\
     Supported source version ''{0}'' from annotation processor ''{1}'' less than -source ''{2}''
 
+# 0: string, 1: string
+compiler.warn.proc.duplicate.option.name=\
+    Duplicate supported option ''{0}'' returned by annotation processor ''{1}''
+
+# 0: string, 1: string
+compiler.warn.proc.duplicate.supported.annotation=\
+    Duplicate supported annotation type ''{0}'' returned by annotation processor ''{1}''
+
+# 0: string
+compiler.warn.proc.redundant.types.with.wildcard=\
+    Annotation processor ''{0}'' redundantly supports both ''*'' and other annotation types
+
 compiler.warn.proc.proc-only.requested.no.procs=\
     Annotation processing without compilation requested but no processors were found.
 
 compiler.warn.proc.use.implicit=\
     Implicitly compiled files were not subject to annotation processing.\n\
@@ -2100,13 +2173,23 @@
 
 # 0: token, 1: token, 2: token
 compiler.err.expected3=\
     {0}, {1}, or {2} expected
 
+# 0: token, 1: token, 2: token, 3: string
+compiler.err.expected4=\
+    {0}, {1}, {2}, or {3} expected
+
 compiler.err.premature.eof=\
     reached end of file while parsing
 
+compiler.err.enum.constant.expected=\
+    enum constant expected here
+
+compiler.err.enum.constant.not.expected=\
+    enum constant not expected here
+
 ## The following are related in form, but do not easily fit the above paradigm.
 compiler.err.expected.module=\
     ''module'' expected
 
 compiler.err.expected.module.or.open=\
@@ -2154,10 +2237,15 @@
 # 0: file name, 1: string (expected constant pool entry type), 2: number (constant pool index)
 compiler.misc.bad.const.pool.entry=\
     bad constant pool entry in {0}\n\
     expected {1} at index {2}
 
+# 0: file name, 1: number (constant pool index), 2: number (constant pool size)
+compiler.misc.bad.const.pool.index=\
+    bad constant pool index in {0}\n\
+    index {1} is not within pool size {2}.
+
 # 0: file name, 1: message segment
 compiler.misc.bad.class.file.header=\
     bad class file: {0}\n\
     {1}\n\
     Please remove or make sure it appears in the correct subdirectory of the classpath.
@@ -2215,10 +2303,14 @@
 
 # 0: string (constant value), 1: symbol (constant field), 2: string (expected class)
 compiler.misc.bad.constant.value=\
     bad constant value ''{0}'' for {1}, expected {2}
 
+# 0: type (field type)
+compiler.misc.bad.constant.value.type=\
+    variable of type ''{0}'' cannot have a constant value, but has one specified
+
 # 0: string (classfile major version), 1: string (classfile minor version)
 compiler.misc.invalid.default.interface=\
     default method found in version {0}.{1} classfile
 
 # 0: string (classfile major version), 1: string (classfile minor version)
@@ -2623,25 +2715,15 @@
     static initializer
 
 compiler.misc.kindname.instance.init=\
     instance initializer
 
-# the following are names of tree kinds:
-compiler.misc.tree.tag.forloop=\
-    for
-
-compiler.misc.tree.tag.foreachloop=\
-    for
+compiler.misc.kindname.record.component=\
+    record component
 
-compiler.misc.tree.tag.whileloop=\
-    while
-
-compiler.misc.tree.tag.doloop=\
-    do
-
-compiler.misc.tree.tag.switch=\
-    switch
+compiler.misc.kindname.record=\
+    record
 
 #####
 
 compiler.misc.no.args=\
     no arguments
@@ -2828,10 +2910,13 @@
     static interface method invocations
 
 compiler.misc.feature.private.intf.methods=\
     private interface methods
 
+compiler.misc.feature.text.blocks=\
+    text blocks
+
 compiler.misc.feature.multiple.case.labels=\
     multiple case labels
 
 compiler.misc.feature.switch.rules=\
     switch rules
@@ -2840,10 +2925,19 @@
     switch expressions
 
 compiler.misc.feature.var.syntax.in.implicit.lambda=\
     var syntax in implicit lambdas
 
+compiler.misc.feature.pattern.matching.instanceof=\
+    pattern matching in instanceof
+
+compiler.misc.feature.reifiable.types.instanceof=\
+    reifiable types in instanceof
+
+compiler.misc.feature.records=\
+    records
+
 compiler.warn.underscore.as.identifier=\
     as of release 9, ''_'' is a keyword, and may not be used as an identifier
 
 compiler.err.underscore.as.identifier=\
     as of release 9, ''_'' is a keyword, and may not be used as an identifier
@@ -3270,11 +3364,12 @@
 # 0: option name, 1: symbol
 compiler.warn.module.for.option.not.found=\
     module name in {0} option not found: {1}
 
 compiler.err.addmods.all.module.path.invalid=\
-    --add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module
+    --add-modules ALL-MODULE-PATH can only be used when compiling the unnamed module or \
+    when compiling in the context of an automatic module
 
 # 0: symbol
 compiler.err.add.exports.with.release=\
     exporting a package from system module {0} is not allowed with --release
 
@@ -3329,21 +3424,112 @@
 
 # 0: string, 1: string
 compiler.err.illegal.argument.for.option=\
     illegal argument for {0}: {1}
 
+compiler.err.match.binding.exists=\
+    illegal attempt to redefine an existing match binding
+
 compiler.err.switch.null.not.allowed=\
     null label in case is not allowed
 
 compiler.err.switch.case.unexpected.statement=\
     unexpected statement in case, expected is an expression, a block or a throw statement
 
 compiler.err.switch.mixing.case.types=\
     different case kinds used in the switch
 
+###
+# errors related to records
+
+# record components
+compiler.err.record.cant.declare.field.modifiers=\
+    record components cannot have modifiers
+
+# 0: symbol
+compiler.err.illegal.record.component.name=\
+    illegal record component name {0}
+
+# accessor methods
+# 0: symbol, 1: fragment
+compiler.err.invalid.accessor.method.in.record=\
+    invalid accessor method in record {0}\n\
+    ({1})
+
+compiler.misc.method.must.be.public=\
+    accessor method must be public
+
+# 0: symbol, 1: symbol
+compiler.misc.accessor.return.type.doesnt.match=\
+    return type of accessor method {0} must match the type of record component {1}
+
+compiler.misc.accessor.method.cant.throw.exception=\
+    throws clause not allowed for accessor method
+
+compiler.misc.accessor.method.must.not.be.generic=\
+    accessor method must not be generic
+
+compiler.misc.accessor.method.must.not.be.static=\
+    accessor method must not be static
+
+# canonical constructors
+# 0: fragment, 1: name, 2: fragment
+compiler.err.invalid.canonical.constructor.in.record=\
+    invalid {0} constructor in record {1}\n\
+    ({2})
+
+compiler.misc.canonical=\
+    canonical
+
+compiler.misc.compact=\
+    compact
+
+compiler.misc.canonical.constructor.must.be.public=\
+    canonical constructor must be public
+
+# 0: fragment
+compiler.misc.throws.clause.not.allowed.for.canonical.constructor=\
+    throws clause not allowed for {0} constructor
+
+compiler.misc.canonical.with.name.mismatch=\
+    invalid parameter names in canonical constructor
+
+compiler.misc.canonical.cant.have.return.statement=\
+    compact constructor must not have return statements
+
+compiler.misc.canonical.must.not.declare.type.variables=\
+    canonical constructor must not declare type variables
+
+compiler.misc.type.must.be.identical.to.corresponding.record.component.type=\
+    type must match that of the corresponding record component\
+
+compiler.misc.canonical.must.not.contain.explicit.constructor.invocation=\
+    canonical constructor must not contain explicit constructor invocation
+
+# other
+compiler.err.record.cannot.declare.instance.fields=\
+    field declaration must be static\n\
+    (consider replacing field with record component)
+
+# 0: symbol
+compiler.err.invalid.supertype.record=\
+    classes cannot directly extend {0}
+
+compiler.err.first.statement.must.be.call.to.another.constructor=\
+    constructor is not canonical, so its first statement must invoke another constructor
+
+compiler.err.instance.initializer.not.allowed.in.records=\
+    instance initializers not allowed in records
+
+compiler.err.record.declaration.not.allowed.in.inner.classes=\
+    record declarations not allowed in inner classes
+
+compiler.err.record.header.expected=\
+    record header expected
+
 ############################################
-# messages previouly at javac.properties
+# messages previously at javac.properties
 
 compiler.err.empty.A.argument=\
     -A requires an argument; use ''-Akey'' or ''-Akey=value''
 
 # 0: string

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;

  39 
  40 import javax.lang.model.element.Modifier;
  41 import javax.lang.model.element.NestingKind;
  42 import javax.tools.JavaFileManager;
  43 import javax.tools.JavaFileObject;
  44 
  45 import com.sun.tools.javac.code.Source.Feature;
  46 import com.sun.tools.javac.comp.Annotate;
  47 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  48 import com.sun.tools.javac.code.*;
  49 import com.sun.tools.javac.code.Directive.*;
  50 import com.sun.tools.javac.code.Lint.LintCategory;
  51 import com.sun.tools.javac.code.Scope.WriteableScope;
  52 import com.sun.tools.javac.code.Symbol.*;
  53 import com.sun.tools.javac.code.Symtab;
  54 import com.sun.tools.javac.code.Type.*;
  55 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  56 import com.sun.tools.javac.file.BaseFileManager;
  57 import com.sun.tools.javac.file.PathFileObject;
<span class="line-removed">  58 import com.sun.tools.javac.jvm.ClassFile.NameAndType;</span>
  59 import com.sun.tools.javac.jvm.ClassFile.Version;

  60 import com.sun.tools.javac.main.Option;
  61 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  62 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  63 import com.sun.tools.javac.util.*;
  64 import com.sun.tools.javac.util.DefinedBy.Api;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  66 
  67 import static com.sun.tools.javac.code.Flags.*;
  68 import static com.sun.tools.javac.code.Kinds.Kind.*;
  69 
  70 import com.sun.tools.javac.code.Scope.LookupKind;
  71 
  72 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  73 import static com.sun.tools.javac.code.TypeTag.CLASS;
  74 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  75 import static com.sun.tools.javac.jvm.ClassFile.*;
  76 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  77 
  78 import static com.sun.tools.javac.main.Option.PARAMETERS;
  79 
</pre>
<hr />
<pre>
  83  *  for all other definitions in the classfile. Top-level Classes themselves
  84  *  appear as members of the scopes of PackageSymbols.
  85  *
  86  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  87  *  If you write code that depends on this, you do so at your own risk.
  88  *  This code and its internal interfaces are subject to change or
  89  *  deletion without notice.&lt;/b&gt;
  90  */
  91 public class ClassReader {
  92     /** The context key for the class reader. */
  93     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  94 
  95     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  96 
  97     private final Annotate annotate;
  98 
  99     /** Switch: verbose output.
 100      */
 101     boolean verbose;
 102 
<span class="line-removed"> 103     /** Switch: read constant pool and code sections. This switch is initially</span>
<span class="line-removed"> 104      *  set to false but can be turned on from outside.</span>
<span class="line-removed"> 105      */</span>
<span class="line-removed"> 106     public boolean readAllOfClassFile = false;</span>
<span class="line-removed"> 107 </span>
 108     /** Switch: allow modules.
 109      */
 110     boolean allowModules;
 111 




 112    /** Lint option: warn about classfile issues
 113      */
 114     boolean lintClassfile;
 115 
 116     /** Switch: preserve parameter names from the variable table.
 117      */
 118     public boolean saveParameterNames;
 119 
 120     /**
 121      * The currently selected profile.
 122      */
 123     public final Profile profile;
 124 
 125     /** The log to use for verbose output
 126      */
 127     final Log log;
 128 
 129     /** The symbol table. */
 130     Symtab syms;
 131 
</pre>
<hr />
<pre>
 153      */
 154     protected WriteableScope typevars;
 155 
 156     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 157     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 158 
 159     /** The path name of the class file currently being read.
 160      */
 161     protected JavaFileObject currentClassFile = null;
 162 
 163     /** The class or method currently being read.
 164      */
 165     protected Symbol currentOwner = null;
 166 
 167     /** The module containing the class currently being read.
 168      */
 169     protected ModuleSymbol currentModule = null;
 170 
 171     /** The buffer containing the currently read class file.
 172      */
<span class="line-modified"> 173     byte[] buf = new byte[INITIAL_BUFFER_SIZE];</span>
 174 
 175     /** The current input pointer.
 176      */
 177     protected int bp;
 178 
<span class="line-modified"> 179     /** The objects of the constant pool.</span>
 180      */
<span class="line-modified"> 181     Object[] poolObj;</span>
<span class="line-removed"> 182 </span>
<span class="line-removed"> 183     /** For every constant pool entry, an index into buf where the</span>
<span class="line-removed"> 184      *  defining section of the entry is found.</span>
<span class="line-removed"> 185      */</span>
<span class="line-removed"> 186     int[] poolIdx;</span>
 187 
 188     /** The major version number of the class file being read. */
 189     int majorVersion;
 190     /** The minor version number of the class file being read. */
 191     int minorVersion;
 192 
 193     /** A table to hold the constant pool indices for method parameter
 194      * names, as given in LocalVariableTable attributes.
 195      */
 196     int[] parameterNameIndices;
 197 
 198     /**
 199      * A table to hold annotations for method parameters.
 200      */
 201     ParameterAnnotations[] parameterAnnotations;
 202 
 203     /**
 204      * A holder for parameter annotations.
 205      */
 206     static class ParameterAnnotations {
</pre>
<hr />
<pre>
 222 
 223     /** Set this to false every time we start reading a method
 224      * and are saving parameter names.  Set it to true when we see
 225      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 226      * then we ignore the parameter names from the LVT.
 227      */
 228     boolean sawMethodParameters;
 229 
 230     /**
 231      * The set of attribute names for which warnings have been generated for the current class
 232      */
 233     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 234 
 235     /**
 236      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 237      * @Target
 238      */
 239     CompoundAnnotationProxy target;
 240 
 241     /**
<span class="line-modified"> 242      * The prototype @Repetable Attribute.Compound if this class is an annotation annotated with</span>
 243      * @Repeatable
 244      */
 245     CompoundAnnotationProxy repeatable;
 246 
 247     /** Get the ClassReader instance for this invocation. */
 248     public static ClassReader instance(Context context) {
 249         ClassReader instance = context.get(classReaderKey);
 250         if (instance == null)
 251             instance = new ClassReader(context);
 252         return instance;
 253     }
 254 
 255     /** Construct a new class reader. */
 256     protected ClassReader(Context context) {
 257         context.put(classReaderKey, this);
 258         annotate = Annotate.instance(context);
 259         names = Names.instance(context);
 260         syms = Symtab.instance(context);
 261         types = Types.instance(context);
 262         fileManager = context.get(JavaFileManager.class);
 263         if (fileManager == null)
 264             throw new AssertionError(&quot;FileManager initialization error&quot;);
 265         diagFactory = JCDiagnostic.Factory.instance(context);
 266         dcfh = DeferredCompletionFailureHandler.instance(context);
 267 
 268         log = Log.instance(context);
 269 
 270         Options options = Options.instance(context);
 271         verbose         = options.isSet(Option.VERBOSE);
 272 
 273         Source source = Source.instance(context);
 274         preview = Preview.instance(context);
 275         allowModules     = Feature.MODULES.allowedInSource(source);


 276 
 277         saveParameterNames = options.isSet(PARAMETERS);
 278 
 279         profile = Profile.instance(context);
 280 
 281         typevars = WriteableScope.create(syms.noSymbol);
 282 
 283         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 284 
 285         initAttributeReaders();
 286     }
 287 
 288     /** Add member to class unless it is synthetic.
 289      */
 290     private void enterMember(ClassSymbol c, Symbol sym) {
 291         // Synthetic members are not entered -- reason lost to history (optimization?).
 292         // Lambda methods must be entered because they may have inner classes (which reference them)
 293         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 294             c.members_field.enter(sym);
 295     }
</pre>
<hr />
<pre>
 306             diagFactory,
 307             dcfh);
 308     }
 309 
 310     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 311         return new ClassFinder.BadEnclosingMethodAttr (
 312             currentOwner.enclClass(),
 313             currentClassFile,
 314             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 315             diagFactory,
 316             dcfh);
 317     }
 318 
 319 /************************************************************************
 320  * Buffer Access
 321  ***********************************************************************/
 322 
 323     /** Read a character.
 324      */
 325     char nextChar() {
<span class="line-modified"> 326         return (char)(((buf[bp++] &amp; 0xFF) &lt;&lt; 8) + (buf[bp++] &amp; 0xFF));</span>


 327     }
 328 
 329     /** Read a byte.
 330      */
 331     int nextByte() {
<span class="line-modified"> 332         return buf[bp++] &amp; 0xFF;</span>
 333     }
 334 
 335     /** Read an integer.
 336      */
 337     int nextInt() {
<span class="line-modified"> 338         return</span>
<span class="line-modified"> 339             ((buf[bp++] &amp; 0xFF) &lt;&lt; 24) +</span>
<span class="line-modified"> 340             ((buf[bp++] &amp; 0xFF) &lt;&lt; 16) +</span>
<span class="line-removed"> 341             ((buf[bp++] &amp; 0xFF) &lt;&lt; 8) +</span>
<span class="line-removed"> 342             (buf[bp++] &amp; 0xFF);</span>
<span class="line-removed"> 343     }</span>
<span class="line-removed"> 344 </span>
<span class="line-removed"> 345     /** Extract a character at position bp from buf.</span>
<span class="line-removed"> 346      */</span>
<span class="line-removed"> 347     char getChar(int bp) {</span>
<span class="line-removed"> 348         return</span>
<span class="line-removed"> 349             (char)(((buf[bp] &amp; 0xFF) &lt;&lt; 8) + (buf[bp+1] &amp; 0xFF));</span>
<span class="line-removed"> 350     }</span>
<span class="line-removed"> 351 </span>
<span class="line-removed"> 352     /** Extract an integer at position bp from buf.</span>
<span class="line-removed"> 353      */</span>
<span class="line-removed"> 354     int getInt(int bp) {</span>
<span class="line-removed"> 355         return</span>
<span class="line-removed"> 356             ((buf[bp] &amp; 0xFF) &lt;&lt; 24) +</span>
<span class="line-removed"> 357             ((buf[bp+1] &amp; 0xFF) &lt;&lt; 16) +</span>
<span class="line-removed"> 358             ((buf[bp+2] &amp; 0xFF) &lt;&lt; 8) +</span>
<span class="line-removed"> 359             (buf[bp+3] &amp; 0xFF);</span>
<span class="line-removed"> 360     }</span>
<span class="line-removed"> 361 </span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363     /** Extract a long integer at position bp from buf.</span>
<span class="line-removed"> 364      */</span>
<span class="line-removed"> 365     long getLong(int bp) {</span>
<span class="line-removed"> 366         DataInputStream bufin =</span>
<span class="line-removed"> 367             new DataInputStream(new ByteArrayInputStream(buf, bp, 8));</span>
<span class="line-removed"> 368         try {</span>
<span class="line-removed"> 369             return bufin.readLong();</span>
<span class="line-removed"> 370         } catch (IOException e) {</span>
<span class="line-removed"> 371             throw new AssertionError(e);</span>
<span class="line-removed"> 372         }</span>
<span class="line-removed"> 373     }</span>
<span class="line-removed"> 374 </span>
<span class="line-removed"> 375     /** Extract a float at position bp from buf.</span>
<span class="line-removed"> 376      */</span>
<span class="line-removed"> 377     float getFloat(int bp) {</span>
<span class="line-removed"> 378         DataInputStream bufin =</span>
<span class="line-removed"> 379             new DataInputStream(new ByteArrayInputStream(buf, bp, 4));</span>
<span class="line-removed"> 380         try {</span>
<span class="line-removed"> 381             return bufin.readFloat();</span>
<span class="line-removed"> 382         } catch (IOException e) {</span>
<span class="line-removed"> 383             throw new AssertionError(e);</span>
<span class="line-removed"> 384         }</span>
<span class="line-removed"> 385     }</span>
<span class="line-removed"> 386 </span>
<span class="line-removed"> 387     /** Extract a double at position bp from buf.</span>
<span class="line-removed"> 388      */</span>
<span class="line-removed"> 389     double getDouble(int bp) {</span>
<span class="line-removed"> 390         DataInputStream bufin =</span>
<span class="line-removed"> 391             new DataInputStream(new ByteArrayInputStream(buf, bp, 8));</span>
<span class="line-removed"> 392         try {</span>
<span class="line-removed"> 393             return bufin.readDouble();</span>
<span class="line-removed"> 394         } catch (IOException e) {</span>
<span class="line-removed"> 395             throw new AssertionError(e);</span>
<span class="line-removed"> 396         }</span>
 397     }
 398 
 399 /************************************************************************
 400  * Constant Pool Access
 401  ***********************************************************************/
 402 
<span class="line-removed"> 403     /** Index all constant pool entries, writing their start addresses into</span>
<span class="line-removed"> 404      *  poolIdx.</span>
<span class="line-removed"> 405      */</span>
<span class="line-removed"> 406     void indexPool() {</span>
<span class="line-removed"> 407         poolIdx = new int[nextChar()];</span>
<span class="line-removed"> 408         poolObj = new Object[poolIdx.length];</span>
<span class="line-removed"> 409         int i = 1;</span>
<span class="line-removed"> 410         while (i &lt; poolIdx.length) {</span>
<span class="line-removed"> 411             poolIdx[i++] = bp;</span>
<span class="line-removed"> 412             byte tag = buf[bp++];</span>
<span class="line-removed"> 413             switch (tag) {</span>
<span class="line-removed"> 414             case CONSTANT_Utf8: case CONSTANT_Unicode: {</span>
<span class="line-removed"> 415                 int len = nextChar();</span>
<span class="line-removed"> 416                 bp = bp + len;</span>
<span class="line-removed"> 417                 break;</span>
<span class="line-removed"> 418             }</span>
<span class="line-removed"> 419             case CONSTANT_Class:</span>
<span class="line-removed"> 420             case CONSTANT_String:</span>
<span class="line-removed"> 421             case CONSTANT_MethodType:</span>
<span class="line-removed"> 422             case CONSTANT_Module:</span>
<span class="line-removed"> 423             case CONSTANT_Package:</span>
<span class="line-removed"> 424                 bp = bp + 2;</span>
<span class="line-removed"> 425                 break;</span>
<span class="line-removed"> 426             case CONSTANT_MethodHandle:</span>
<span class="line-removed"> 427                 bp = bp + 3;</span>
<span class="line-removed"> 428                 break;</span>
<span class="line-removed"> 429             case CONSTANT_Fieldref:</span>
<span class="line-removed"> 430             case CONSTANT_Methodref:</span>
<span class="line-removed"> 431             case CONSTANT_InterfaceMethodref:</span>
<span class="line-removed"> 432             case CONSTANT_NameandType:</span>
<span class="line-removed"> 433             case CONSTANT_Integer:</span>
<span class="line-removed"> 434             case CONSTANT_Float:</span>
<span class="line-removed"> 435             case CONSTANT_Dynamic:</span>
<span class="line-removed"> 436             case CONSTANT_InvokeDynamic:</span>
<span class="line-removed"> 437                 bp = bp + 4;</span>
<span class="line-removed"> 438                 break;</span>
<span class="line-removed"> 439             case CONSTANT_Long:</span>
<span class="line-removed"> 440             case CONSTANT_Double:</span>
<span class="line-removed"> 441                 bp = bp + 8;</span>
<span class="line-removed"> 442                 i++;</span>
<span class="line-removed"> 443                 break;</span>
<span class="line-removed"> 444             default:</span>
<span class="line-removed"> 445                 throw badClassFile(&quot;bad.const.pool.tag.at&quot;,</span>
<span class="line-removed"> 446                                    Byte.toString(tag),</span>
<span class="line-removed"> 447                                    Integer.toString(bp -1));</span>
<span class="line-removed"> 448             }</span>
<span class="line-removed"> 449         }</span>
<span class="line-removed"> 450     }</span>
<span class="line-removed"> 451 </span>
<span class="line-removed"> 452     /** Read constant pool entry at start address i, use pool as a cache.</span>
<span class="line-removed"> 453      */</span>
<span class="line-removed"> 454     Object readPool(int i) {</span>
<span class="line-removed"> 455         Object result = poolObj[i];</span>
<span class="line-removed"> 456         if (result != null) return result;</span>
<span class="line-removed"> 457 </span>
<span class="line-removed"> 458         int index = poolIdx[i];</span>
<span class="line-removed"> 459         if (index == 0) return null;</span>
<span class="line-removed"> 460 </span>
<span class="line-removed"> 461         byte tag = buf[index];</span>
<span class="line-removed"> 462         switch (tag) {</span>
<span class="line-removed"> 463         case CONSTANT_Utf8:</span>
<span class="line-removed"> 464             poolObj[i] = names.fromUtf(buf, index + 3, getChar(index + 1));</span>
<span class="line-removed"> 465             break;</span>
<span class="line-removed"> 466         case CONSTANT_Unicode:</span>
<span class="line-removed"> 467             throw badClassFile(&quot;unicode.str.not.supported&quot;);</span>
<span class="line-removed"> 468         case CONSTANT_Class:</span>
<span class="line-removed"> 469             poolObj[i] = readClassOrType(getChar(index + 1));</span>
<span class="line-removed"> 470             break;</span>
<span class="line-removed"> 471         case CONSTANT_String:</span>
<span class="line-removed"> 472             // FIXME: (footprint) do not use toString here</span>
<span class="line-removed"> 473             poolObj[i] = readName(getChar(index + 1)).toString();</span>
<span class="line-removed"> 474             break;</span>
<span class="line-removed"> 475         case CONSTANT_Fieldref: {</span>
<span class="line-removed"> 476             ClassSymbol owner = readClassSymbol(getChar(index + 1));</span>
<span class="line-removed"> 477             NameAndType nt = readNameAndType(getChar(index + 3));</span>
<span class="line-removed"> 478             poolObj[i] = new VarSymbol(0, nt.name, nt.uniqueType.type, owner);</span>
<span class="line-removed"> 479             break;</span>
<span class="line-removed"> 480         }</span>
<span class="line-removed"> 481         case CONSTANT_Methodref:</span>
<span class="line-removed"> 482         case CONSTANT_InterfaceMethodref: {</span>
<span class="line-removed"> 483             ClassSymbol owner = readClassSymbol(getChar(index + 1));</span>
<span class="line-removed"> 484             NameAndType nt = readNameAndType(getChar(index + 3));</span>
<span class="line-removed"> 485             poolObj[i] = new MethodSymbol(0, nt.name, nt.uniqueType.type, owner);</span>
<span class="line-removed"> 486             break;</span>
<span class="line-removed"> 487         }</span>
<span class="line-removed"> 488         case CONSTANT_NameandType:</span>
<span class="line-removed"> 489             poolObj[i] = new NameAndType(</span>
<span class="line-removed"> 490                 readName(getChar(index + 1)),</span>
<span class="line-removed"> 491                 readType(getChar(index + 3)), types);</span>
<span class="line-removed"> 492             break;</span>
<span class="line-removed"> 493         case CONSTANT_Integer:</span>
<span class="line-removed"> 494             poolObj[i] = getInt(index + 1);</span>
<span class="line-removed"> 495             break;</span>
<span class="line-removed"> 496         case CONSTANT_Float:</span>
<span class="line-removed"> 497             poolObj[i] = Float.valueOf(getFloat(index + 1));</span>
<span class="line-removed"> 498             break;</span>
<span class="line-removed"> 499         case CONSTANT_Long:</span>
<span class="line-removed"> 500             poolObj[i] = Long.valueOf(getLong(index + 1));</span>
<span class="line-removed"> 501             break;</span>
<span class="line-removed"> 502         case CONSTANT_Double:</span>
<span class="line-removed"> 503             poolObj[i] = Double.valueOf(getDouble(index + 1));</span>
<span class="line-removed"> 504             break;</span>
<span class="line-removed"> 505         case CONSTANT_MethodHandle:</span>
<span class="line-removed"> 506             skipBytes(4);</span>
<span class="line-removed"> 507             break;</span>
<span class="line-removed"> 508         case CONSTANT_MethodType:</span>
<span class="line-removed"> 509             skipBytes(3);</span>
<span class="line-removed"> 510             break;</span>
<span class="line-removed"> 511         case CONSTANT_Dynamic:</span>
<span class="line-removed"> 512         case CONSTANT_InvokeDynamic:</span>
<span class="line-removed"> 513             skipBytes(5);</span>
<span class="line-removed"> 514             break;</span>
<span class="line-removed"> 515         case CONSTANT_Module:</span>
<span class="line-removed"> 516         case CONSTANT_Package:</span>
<span class="line-removed"> 517             // this is temporary for now: treat as a simple reference to the underlying Utf8.</span>
<span class="line-removed"> 518             poolObj[i] = readName(getChar(index + 1));</span>
<span class="line-removed"> 519             break;</span>
<span class="line-removed"> 520         default:</span>
<span class="line-removed"> 521             throw badClassFile(&quot;bad.const.pool.tag&quot;, Byte.toString(tag));</span>
<span class="line-removed"> 522         }</span>
<span class="line-removed"> 523         return poolObj[i];</span>
<span class="line-removed"> 524     }</span>
<span class="line-removed"> 525 </span>
<span class="line-removed"> 526     /** Read signature and convert to type.</span>
<span class="line-removed"> 527      */</span>
<span class="line-removed"> 528     Type readType(int i) {</span>
<span class="line-removed"> 529         int index = poolIdx[i];</span>
<span class="line-removed"> 530         return sigToType(buf, index + 3, getChar(index + 1));</span>
<span class="line-removed"> 531     }</span>
<span class="line-removed"> 532 </span>
<span class="line-removed"> 533     /** If name is an array type or class signature, return the</span>
<span class="line-removed"> 534      *  corresponding type; otherwise return a ClassSymbol with given name.</span>
<span class="line-removed"> 535      */</span>
<span class="line-removed"> 536     Object readClassOrType(int i) {</span>
<span class="line-removed"> 537         int index =  poolIdx[i];</span>
<span class="line-removed"> 538         int len = getChar(index + 1);</span>
<span class="line-removed"> 539         int start = index + 3;</span>
<span class="line-removed"> 540         Assert.check(buf[start] == &#39;[&#39; || buf[start + len - 1] != &#39;;&#39;);</span>
<span class="line-removed"> 541         // by the above assertion, the following test can be</span>
<span class="line-removed"> 542         // simplified to (buf[start] == &#39;[&#39;)</span>
<span class="line-removed"> 543         return (buf[start] == &#39;[&#39; || buf[start + len - 1] == &#39;;&#39;)</span>
<span class="line-removed"> 544             ? (Object)sigToType(buf, start, len)</span>
<span class="line-removed"> 545             : (Object)enterClass(names.fromUtf(internalize(buf, start,</span>
<span class="line-removed"> 546                                                            len)));</span>
<span class="line-removed"> 547     }</span>
<span class="line-removed"> 548 </span>
<span class="line-removed"> 549     /** Read signature and convert to type parameters.</span>
<span class="line-removed"> 550      */</span>
<span class="line-removed"> 551     List&lt;Type&gt; readTypeParams(int i) {</span>
<span class="line-removed"> 552         int index = poolIdx[i];</span>
<span class="line-removed"> 553         return sigToTypeParams(buf, index + 3, getChar(index + 1));</span>
<span class="line-removed"> 554     }</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556     /** Read class entry.</span>
<span class="line-removed"> 557      */</span>
<span class="line-removed"> 558     ClassSymbol readClassSymbol(int i) {</span>
<span class="line-removed"> 559         Object obj = readPool(i);</span>
<span class="line-removed"> 560         if (obj != null &amp;&amp; !(obj instanceof ClassSymbol))</span>
<span class="line-removed"> 561             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed"> 562                                currentClassFile.toString(),</span>
<span class="line-removed"> 563                                &quot;CONSTANT_Class_info&quot;, i);</span>
<span class="line-removed"> 564         return (ClassSymbol)obj;</span>
<span class="line-removed"> 565     }</span>
<span class="line-removed"> 566 </span>
<span class="line-removed"> 567     Name readClassName(int i) {</span>
<span class="line-removed"> 568         int index = poolIdx[i];</span>
<span class="line-removed"> 569         if (index == 0) return null;</span>
<span class="line-removed"> 570         byte tag = buf[index];</span>
<span class="line-removed"> 571         if (tag != CONSTANT_Class) {</span>
<span class="line-removed"> 572             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed"> 573                                currentClassFile.toString(),</span>
<span class="line-removed"> 574                                &quot;CONSTANT_Class_info&quot;, i);</span>
<span class="line-removed"> 575         }</span>
<span class="line-removed"> 576         int nameIndex =  poolIdx[getChar(index + 1)];</span>
<span class="line-removed"> 577         int len = getChar(nameIndex + 1);</span>
<span class="line-removed"> 578         int start = nameIndex + 3;</span>
<span class="line-removed"> 579         if (buf[start] == &#39;[&#39; || buf[start + len - 1] == &#39;;&#39;)</span>
<span class="line-removed"> 580             throw badClassFile(&quot;wrong class name&quot;); //TODO: proper diagnostics</span>
<span class="line-removed"> 581         return names.fromUtf(internalize(buf, start, len));</span>
<span class="line-removed"> 582     }</span>
<span class="line-removed"> 583 </span>
<span class="line-removed"> 584     /** Read name.</span>
<span class="line-removed"> 585      */</span>
<span class="line-removed"> 586     Name readName(int i) {</span>
<span class="line-removed"> 587         Object obj = readPool(i);</span>
<span class="line-removed"> 588         if (obj != null &amp;&amp; !(obj instanceof Name))</span>
<span class="line-removed"> 589             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed"> 590                                currentClassFile.toString(),</span>
<span class="line-removed"> 591                                &quot;CONSTANT_Utf8_info or CONSTANT_String_info&quot;, i);</span>
<span class="line-removed"> 592         return (Name)obj;</span>
<span class="line-removed"> 593     }</span>
<span class="line-removed"> 594 </span>
<span class="line-removed"> 595     /** Read name and type.</span>
<span class="line-removed"> 596      */</span>
<span class="line-removed"> 597     NameAndType readNameAndType(int i) {</span>
<span class="line-removed"> 598         Object obj = readPool(i);</span>
<span class="line-removed"> 599         if (obj != null &amp;&amp; !(obj instanceof NameAndType))</span>
<span class="line-removed"> 600             throw badClassFile(&quot;bad.const.pool.entry&quot;,</span>
<span class="line-removed"> 601                                currentClassFile.toString(),</span>
<span class="line-removed"> 602                                &quot;CONSTANT_NameAndType_info&quot;, i);</span>
<span class="line-removed"> 603         return (NameAndType)obj;</span>
<span class="line-removed"> 604     }</span>
<span class="line-removed"> 605 </span>
<span class="line-removed"> 606     /** Read the name of a module.</span>
<span class="line-removed"> 607      * The name is stored in a CONSTANT_Module entry, in</span>
<span class="line-removed"> 608      * JVMS 4.2 binary form (using &quot;.&quot;, not &quot;/&quot;)</span>
<span class="line-removed"> 609      */</span>
<span class="line-removed"> 610     Name readModuleName(int i) {</span>
<span class="line-removed"> 611         return readName(i);</span>
<span class="line-removed"> 612     }</span>
<span class="line-removed"> 613 </span>
 614     /** Read module_flags.
 615      */
 616     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 617         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 618         for (ModuleFlags f : ModuleFlags.values()) {
 619             if ((flags &amp; f.value) != 0)
 620                 set.add(f);
 621         }
 622         return set;
 623     }
 624 
 625     /** Read resolution_flags.
 626      */
 627     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 628         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 629         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 630             if ((flags &amp; f.value) != 0)
 631                 set.add(f);
 632         }
 633         return set;
</pre>
<hr />
<pre>
 745                 */
 746                 return t;
 747             }
 748         case &#39;S&#39;:
 749             sigp++;
 750             return syms.shortType;
 751         case &#39;V&#39;:
 752             sigp++;
 753             return syms.voidType;
 754         case &#39;Z&#39;:
 755             sigp++;
 756             return syms.booleanType;
 757         case &#39;[&#39;:
 758             sigp++;
 759             return new ArrayType(sigToType(), syms.arrayClass);
 760         case &#39;(&#39;:
 761             sigp++;
 762             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 763             Type restype = sigToType();
 764             List&lt;Type&gt; thrown = List.nil();
<span class="line-modified"> 765             while (signature[sigp] == &#39;^&#39;) {</span>
 766                 sigp++;
 767                 thrown = thrown.prepend(sigToType());
 768             }
 769             // if there is a typevar in the throws clause we should state it.
 770             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 771                 if (l.head.hasTag(TYPEVAR)) {
 772                     l.head.tsym.flags_field |= THROWS;
 773                 }
 774             }
 775             return new MethodType(argtypes,
 776                                   restype,
 777                                   thrown.reverse(),
 778                                   syms.methodClass);
 779         case &#39;&lt;&#39;:
 780             typevars = typevars.dup(currentOwner);
 781             Type poly = new ForAll(sigToTypeParams(), sigToType());
 782             typevars = typevars.leave();
 783             return poly;
 784         default:
 785             throw badClassFile(&quot;bad.signature&quot;,
</pre>
<hr />
<pre>
 838                                         // no &quot;rare&quot; types
 839                                         super.setEnclosingType(types.erasure(enclosingType));
 840                                     } else {
 841                                         super.setEnclosingType(types.subst(enclosingType,
 842                                                                            typeParams,
 843                                                                            typeArgs));
 844                                     }
 845                                 } else {
 846                                     super.setEnclosingType(Type.noType);
 847                                 }
 848                             }
 849                             return super.getEnclosingType();
 850                         }
 851                         @Override
 852                         public void setEnclosingType(Type outer) {
 853                             throw new UnsupportedOperationException();
 854                         }
 855                     };
 856                 switch (signature[sigp++]) {
 857                 case &#39;;&#39;:
<span class="line-modified"> 858                     if (sigp &lt; signature.length &amp;&amp; signature[sigp] == &#39;.&#39;) {</span>
 859                         // support old-style GJC signatures
 860                         // The signature produced was
 861                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 862                         // rather than say
 863                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 864                         // so we skip past &quot;.Lfoo/Outer$&quot;
 865                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 866                             3;  // &quot;.L&quot; and &quot;$&quot;
 867                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 868                         break;
 869                     } else {
 870                         sbp = startSbp;
 871                         return outer;
 872                     }
 873                 case &#39;.&#39;:
 874                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 875                     break;
 876                 default:
 877                     throw new AssertionError(signature[sigp-1]);
 878                 }
</pre>
<hr />
<pre>
1032         protected final Name name;
1033         protected final ClassFile.Version version;
1034         protected final Set&lt;AttributeKind&gt; kinds;
1035     }
1036 
1037     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
1038             EnumSet.of(AttributeKind.CLASS);
1039     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
1040             EnumSet.of(AttributeKind.MEMBER);
1041     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
1042             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
1043 
1044     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
1045 
1046     private void initAttributeReaders() {
1047         AttributeReader[] readers = {
1048             // v45.3 attributes
1049 
1050             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
1051                 protected void read(Symbol sym, int attrLen) {
<span class="line-modified">1052                     if (readAllOfClassFile || saveParameterNames)</span>
1053                         ((MethodSymbol)sym).code = readCode(sym);
1054                     else
1055                         bp = bp + attrLen;
1056                 }
1057             },
1058 
1059             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
1060                 protected void read(Symbol sym, int attrLen) {
<span class="line-modified">1061                     Object v = readPool(nextChar());</span>
1062                     // Ignore ConstantValue attribute if field not final.
1063                     if ((sym.flags() &amp; FINAL) == 0) {
1064                         return;
1065                     }
1066                     VarSymbol var = (VarSymbol) sym;
1067                     switch (var.type.getTag()) {
1068                        case BOOLEAN:
1069                        case BYTE:
1070                        case CHAR:
1071                        case SHORT:
1072                        case INT:
1073                            checkType(var, Integer.class, v);
1074                            break;
1075                        case LONG:
1076                            checkType(var, Long.class, v);
1077                            break;
1078                        case FLOAT:
1079                            checkType(var, Float.class, v);
1080                            break;
1081                        case DOUBLE:
1082                            checkType(var, Double.class, v);
1083                            break;
1084                        case CLASS:
<span class="line-modified">1085                            Assert.check(var.type.tsym == syms.stringType.tsym);</span>
<span class="line-modified">1086                            checkType(var, String.class, v);</span>



1087                            break;
1088                        default:
1089                            // ignore ConstantValue attribute if type is not primitive or String
1090                            return;
1091                     }
1092                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
1093                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
1094                     }
1095                     var.setData(v);
1096                 }
1097 
1098                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
1099                     if (!clazz.isInstance(value)) {
1100                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
1101                     }
1102                 }
1103             },
1104 
1105             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
1106                 protected void read(Symbol sym, int attrLen) {
1107                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
1108 
1109                     s.flags_field |= DEPRECATED;
1110                 }
1111             },
1112 
1113             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
1114                 protected void read(Symbol sym, int attrLen) {
1115                     int nexceptions = nextChar();
1116                     List&lt;Type&gt; thrown = List.nil();
1117                     for (int j = 0; j &lt; nexceptions; j++)
<span class="line-modified">1118                         thrown = thrown.prepend(readClassSymbol(nextChar()).type);</span>
1119                     if (sym.type.getThrownTypes().isEmpty())
1120                         sym.type.asMethodType().thrown = thrown.reverse();
1121                 }
1122             },
1123 
1124             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
1125                 protected void read(Symbol sym, int attrLen) {
1126                     ClassSymbol c = (ClassSymbol) sym;
1127                     if (currentModule.module_info == c) {
1128                         //prevent entering the classes too soon:
1129                         skipInnerClasses();
1130                     } else {
1131                         readInnerClasses(c);
1132                     }
1133                 }
1134             },
1135 
1136             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
1137                 protected void read(Symbol sym, int attrLen) {
1138                     int newbp = bp + attrLen;
1139                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
1140                         // Pick up parameter names from the variable table.
1141                         // Parameter names are not explicitly identified as such,
1142                         // but all parameter name entries in the LocalVariableTable
1143                         // have a start_pc of 0.  Therefore, we record the name
<span class="line-modified">1144                         // indicies of all slots with a start_pc of zero in the</span>
<span class="line-modified">1145                         // parameterNameIndicies array.</span>
1146                         // Note that this implicitly honors the JVMS spec that
1147                         // there may be more than one LocalVariableTable, and that
1148                         // there is no specified ordering for the entries.
1149                         int numEntries = nextChar();
1150                         for (int i = 0; i &lt; numEntries; i++) {
1151                             int start_pc = nextChar();
1152                             int length = nextChar();
1153                             int nameIndex = nextChar();
1154                             int sigIndex = nextChar();
1155                             int register = nextChar();
1156                             if (start_pc == 0) {
1157                                 // ensure array large enough
1158                                 if (register &gt;= parameterNameIndices.length) {
1159                                     int newSize =
1160                                             Math.max(register + 1, parameterNameIndices.length + 8);
1161                                     parameterNameIndices =
1162                                             Arrays.copyOf(parameterNameIndices, newSize);
1163                                 }
1164                                 parameterNameIndices[register] = nameIndex;
1165                                 haveParameterNameIndices = true;
1166                             }
1167                         }
1168                     }
1169                     bp = newbp;
1170                 }
1171             },
1172 
1173             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
1174                 protected void read(Symbol sym, int attrLen) {
1175                     ClassSymbol c = (ClassSymbol) sym;
<span class="line-modified">1176                     Name n = readName(nextChar());</span>
1177                     c.sourcefile = new SourceFileObject(n);
1178                     // If the class is a toplevel class, originating from a Java source file,
1179                     // but the class name does not match the file name, then it is
1180                     // an auxiliary class.
1181                     String sn = n.toString();
1182                     if (c.owner.kind == PCK &amp;&amp;
1183                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
1184                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
1185                         c.flags_field |= AUXILIARY;
1186                     }
1187                 }
1188             },
1189 
1190             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
1191                 protected void read(Symbol sym, int attrLen) {
1192                     sym.flags_field |= SYNTHETIC;
1193                 }
1194             },
1195 
1196             // standard v49 attributes
1197 
1198             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
1199                 protected void read(Symbol sym, int attrLen) {
1200                     int newbp = bp + attrLen;
1201                     readEnclosingMethodAttr(sym);
1202                     bp = newbp;
1203                 }
1204             },
1205 
1206             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1207                 protected void read(Symbol sym, int attrLen) {
1208                     if (sym.kind == TYP) {
1209                         ClassSymbol c = (ClassSymbol) sym;
1210                         readingClassAttr = true;
1211                         try {
1212                             ClassType ct1 = (ClassType)c.type;
1213                             Assert.check(c == currentOwner);
<span class="line-modified">1214                             ct1.typarams_field = readTypeParams(nextChar());</span>

1215                             ct1.supertype_field = sigToType();
1216                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
1217                             while (sigp != siglimit) is.append(sigToType());
1218                             ct1.interfaces_field = is.toList();
1219                         } finally {
1220                             readingClassAttr = false;
1221                         }
1222                     } else {
1223                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
<span class="line-modified">1224                         sym.type = readType(nextChar());</span>
1225                         //- System.err.println(&quot; # &quot; + sym.type);
1226                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
1227                             sym.type.asMethodType().thrown = thrown;
1228 
1229                     }
1230                 }
1231             },
1232 
1233             // v49 annotation attributes
1234 
1235             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1236                 protected void read(Symbol sym, int attrLen) {
1237                     attachAnnotationDefault(sym);
1238                 }
1239             },
1240 
1241             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1242                 protected void read(Symbol sym, int attrLen) {
1243                     attachAnnotations(sym);
1244                 }
1245             },
1246 
1247             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1248                 protected void read(Symbol sym, int attrLen) {
1249                     readParameterAnnotations(sym);
1250                 }
1251             },
1252 
1253             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1254                 protected void read(Symbol sym, int attrLen) {
1255                     attachAnnotations(sym);
1256                 }
1257             },
1258 
1259             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1260                 protected void read(Symbol sym, int attrLen) {
1261                     readParameterAnnotations(sym);
1262                 }
1263             },
1264 
<span class="line-modified">1265             // additional &quot;legacy&quot; v49 attributes, superceded by flags</span>
1266 
1267             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1268                 protected void read(Symbol sym, int attrLen) {
1269                     sym.flags_field |= ANNOTATION;
1270                 }
1271             },
1272 
1273             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1274                 protected void read(Symbol sym, int attrLen) {
1275                     sym.flags_field |= BRIDGE;
1276                 }
1277             },
1278 
1279             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1280                 protected void read(Symbol sym, int attrLen) {
1281                     sym.flags_field |= ENUM;
1282                 }
1283             },
1284 
1285             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
</pre>
<hr />
<pre>
1325                             }
1326                             parameterNameIndices[index++] = nameIndex;
1327                         }
1328                     }
1329                     bp = newbp;
1330                 }
1331             },
1332 
1333             // standard v53 attributes
1334 
1335             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1336                 @Override
1337                 protected boolean accepts(AttributeKind kind) {
1338                     return super.accepts(kind) &amp;&amp; allowModules;
1339                 }
1340                 protected void read(Symbol sym, int attrLen) {
1341                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1342                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1343                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1344 
<span class="line-modified">1345                         Name moduleName = readModuleName(nextChar());</span>
1346                         if (currentModule.name != moduleName) {
1347                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1348                         }
1349 
1350                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1351                         msym.flags.addAll(moduleFlags);
<span class="line-modified">1352                         msym.version = readName(nextChar());</span>
1353 
1354                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1355                         int nrequires = nextChar();
1356                         for (int i = 0; i &lt; nrequires; i++) {
<span class="line-modified">1357                             ModuleSymbol rsym = syms.enterModule(readModuleName(nextChar()));</span>
1358                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1359                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1360                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1361                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1362                                 }
1363                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1364                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1365                                 }
1366                             }
1367                             nextChar(); // skip compiled version
1368                             requires.add(new RequiresDirective(rsym, flags));
1369                         }
1370                         msym.requires = requires.toList();
1371                         directives.addAll(msym.requires);
1372 
1373                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1374                         int nexports = nextChar();
1375                         for (int i = 0; i &lt; nexports; i++) {
<span class="line-modified">1376                             Name n = readName(nextChar());</span>
<span class="line-removed">1377                             PackageSymbol p = syms.enterPackage(currentModule, names.fromUtf(internalize(n)));</span>
1378                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1379                             int nto = nextChar();
1380                             List&lt;ModuleSymbol&gt; to;
1381                             if (nto == 0) {
1382                                 to = null;
1383                             } else {
1384                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1385                                 for (int t = 0; t &lt; nto; t++)
<span class="line-modified">1386                                     lb.append(syms.enterModule(readModuleName(nextChar())));</span>
1387                                 to = lb.toList();
1388                             }
1389                             exports.add(new ExportsDirective(p, to, flags));
1390                         }
1391                         msym.exports = exports.toList();
1392                         directives.addAll(msym.exports);
1393                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1394                         int nopens = nextChar();
1395                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1396                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1397                         }
1398                         for (int i = 0; i &lt; nopens; i++) {
<span class="line-modified">1399                             Name n = readName(nextChar());</span>
<span class="line-removed">1400                             PackageSymbol p = syms.enterPackage(currentModule, names.fromUtf(internalize(n)));</span>
1401                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1402                             int nto = nextChar();
1403                             List&lt;ModuleSymbol&gt; to;
1404                             if (nto == 0) {
1405                                 to = null;
1406                             } else {
1407                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1408                                 for (int t = 0; t &lt; nto; t++)
<span class="line-modified">1409                                     lb.append(syms.enterModule(readModuleName(nextChar())));</span>
1410                                 to = lb.toList();
1411                             }
1412                             opens.add(new OpensDirective(p, to, flags));
1413                         }
1414                         msym.opens = opens.toList();
1415                         directives.addAll(msym.opens);
1416 
1417                         msym.directives = directives.toList();
1418 
1419                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1420                         int nuses = nextChar();
1421                         for (int i = 0; i &lt; nuses; i++) {
<span class="line-modified">1422                             Name srvc = readClassName(nextChar());</span>
1423                             uses.add(new InterimUsesDirective(srvc));
1424                         }
1425                         interimUses = uses.toList();
1426 
1427                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1428                         int nprovides = nextChar();
1429                         for (int p = 0; p &lt; nprovides; p++) {
<span class="line-modified">1430                             Name srvc = readClassName(nextChar());</span>
1431                             int nimpls = nextChar();
1432                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1433                             for (int i = 0; i &lt; nimpls; i++) {
<span class="line-modified">1434                                 impls.append(readClassName(nextChar()));</span>
1435                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1436                             }
1437                         }
1438                         interimProvides = provides.toList();
1439                     }
1440                 }




1441             },
1442 
1443             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1444                 @Override
1445                 protected boolean accepts(AttributeKind kind) {
1446                     return super.accepts(kind) &amp;&amp; allowModules;
1447                 }
1448                 protected void read(Symbol sym, int attrLen) {
1449                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1450                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1451                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1452                     }
1453                 }
1454             },













1455         };
1456 
1457         for (AttributeReader r: readers)
1458             attributeReaders.put(r.name, r);
1459     }
1460 
1461     protected void readEnclosingMethodAttr(Symbol sym) {
1462         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1463         // remove sym from it&#39;s current owners scope and place it in
1464         // the scope specified by the attribute
1465         sym.owner.members().remove(sym);
1466         ClassSymbol self = (ClassSymbol)sym;
<span class="line-modified">1467         ClassSymbol c = readClassSymbol(nextChar());</span>
<span class="line-modified">1468         NameAndType nt = readNameAndType(nextChar());</span>
1469 
1470         if (c.members_field == null || c.kind != TYP)
1471             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1472 
1473         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1474         if (nt != null &amp;&amp; m == null)
1475             throw badEnclosingMethod(self);
1476 
1477         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1478         self.owner = m != null ? m : c;
1479         if (self.name.isEmpty())
1480             self.fullname = names.empty;
1481         else
1482             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1483 
1484         if (m != null) {
1485             ((ClassType)sym.type).setEnclosingType(m.type);
1486         } else if ((self.flags_field &amp; STATIC) == 0) {
1487             ((ClassType)sym.type).setEnclosingType(c.type);
1488         } else {
1489             ((ClassType)sym.type).setEnclosingType(Type.noType);
1490         }
1491         enterTypevars(self, self.type);
1492         if (!missingTypeVariables.isEmpty()) {
1493             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1494             for (Type typevar : missingTypeVariables) {
1495                 typeVars.append(findTypeVar(typevar.tsym.name));
1496             }
1497             foundTypeVariables = typeVars.toList();
1498         } else {
1499             foundTypeVariables = List.nil();
1500         }
1501     }
1502 
1503     // See java.lang.Class
1504     private Name simpleBinaryName(Name self, Name enclosing) {




1505         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1506         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1507             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1508         int index = 1;
1509         while (index &lt; simpleBinaryName.length() &amp;&amp;
1510                isAsciiDigit(simpleBinaryName.charAt(index)))
1511             index++;
1512         return names.fromString(simpleBinaryName.substring(index));
1513     }
1514 
1515     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1516         if (nt == null)
1517             return null;
1518 
<span class="line-modified">1519         MethodType type = nt.uniqueType.type.asMethodType();</span>
1520 
1521         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1522             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1523                 return (MethodSymbol)sym;
1524         }
1525 
1526         if (nt.name != names.init)
1527             // not a constructor
1528             return null;
1529         if ((flags &amp; INTERFACE) != 0)
1530             // no enclosing instance
1531             return null;
<span class="line-modified">1532         if (nt.uniqueType.type.getParameterTypes().isEmpty())</span>
1533             // no parameters
1534             return null;
1535 
1536         // A constructor of an inner class.
1537         // Remove the first argument (the enclosing instance)
<span class="line-modified">1538         nt.setType(new MethodType(nt.uniqueType.type.getParameterTypes().tail,</span>
<span class="line-modified">1539                                  nt.uniqueType.type.getReturnType(),</span>
<span class="line-modified">1540                                  nt.uniqueType.type.getThrownTypes(),</span>
1541                                  syms.methodClass));
1542         // Try searching again
1543         return findMethod(nt, scope, flags);
1544     }
1545 
1546     /** Similar to Types.isSameType but avoids completion */
1547     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1548         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1549             .prepend(types.erasure(mt1.getReturnType()));
1550         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1551         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1552             if (types1.head.tsym != types2.head.tsym)
1553                 return false;
1554             types1 = types1.tail;
1555             types2 = types2.tail;
1556         }
1557         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1558     }
1559 
1560     /**
1561      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1562      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1563      */
1564     private static boolean isAsciiDigit(char c) {
1565         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1566     }
1567 
1568     /** Read member attributes.
1569      */
1570     void readMemberAttrs(Symbol sym) {
1571         readAttrs(sym, AttributeKind.MEMBER);
1572     }
1573 
1574     void readAttrs(Symbol sym, AttributeKind kind) {
1575         char ac = nextChar();
1576         for (int i = 0; i &lt; ac; i++) {
<span class="line-modified">1577             Name attrName = readName(nextChar());</span>
1578             int attrLen = nextInt();
1579             AttributeReader r = attributeReaders.get(attrName);
1580             if (r != null &amp;&amp; r.accepts(kind))
1581                 r.read(sym, attrLen);
1582             else  {
1583                 bp = bp + attrLen;
1584             }
1585         }
1586     }
1587 
1588     private boolean readingClassAttr = false;
1589     private List&lt;Type&gt; missingTypeVariables = List.nil();
1590     private List&lt;Type&gt; foundTypeVariables = List.nil();
1591 
1592     /** Read class attributes.
1593      */
1594     void readClassAttrs(ClassSymbol c) {
1595         readAttrs(c, AttributeKind.CLASS);
1596     }
1597 
</pre>
<hr />
<pre>
1642             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1643                 sym.flags_field |= PROPRIETARY;
1644             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1645                 if (profile != Profile.DEFAULT) {
1646                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1647                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1648                             Attribute.Constant c = (Attribute.Constant)v.snd;
1649                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1650                                 sym.flags_field |= NOT_IN_PROFILE;
1651                             }
1652                         }
1653                     }
1654                 }
1655             } else {
1656                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1657                     target = proxy;
1658                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1659                     repeatable = proxy;
1660                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1661                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
<span class="line-modified">1662                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {</span>
<span class="line-modified">1663                         if (v.fst == names.forRemoval &amp;&amp; v.snd instanceof Attribute.Constant) {</span>
<span class="line-modified">1664                             Attribute.Constant c = (Attribute.Constant)v.snd;</span>
<span class="line-modified">1665                             if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {</span>
<span class="line-removed">1666                                 sym.flags_field |= DEPRECATED_REMOVAL;</span>
<span class="line-removed">1667                             }</span>
<span class="line-removed">1668                         }</span>
<span class="line-removed">1669                     }</span>
1670                 }
1671                 proxies.append(proxy);
1672             }
1673         }
1674         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1675     }











1676 
1677     /** Read parameter annotations.
1678      */
1679     void readParameterAnnotations(Symbol meth) {
<span class="line-modified">1680         int numParameters = buf[bp++] &amp; 0xFF;</span>
1681         if (parameterAnnotations == null) {
1682             parameterAnnotations = new ParameterAnnotations[numParameters];
1683         } else if (parameterAnnotations.length != numParameters) {
1684             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1685         }
1686         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1687             if (parameterAnnotations[pnum] == null) {
1688                 parameterAnnotations[pnum] = new ParameterAnnotations();
1689             }
1690             parameterAnnotations[pnum].add(readAnnotations());
1691         }
1692     }
1693 
1694     void attachTypeAnnotations(final Symbol sym) {
1695         int numAttributes = nextChar();
1696         if (numAttributes != 0) {
1697             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1698             for (int i = 0; i &lt; numAttributes; i++)
1699                 proxies.append(readTypeAnnotation());
1700             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
</pre>
<hr />
<pre>
1704     /** Attach the default value for an annotation element.
1705      */
1706     void attachAnnotationDefault(final Symbol sym) {
1707         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1708         final Attribute value = readAttributeValue();
1709 
1710         // The default value is set later during annotation. It might
1711         // be the case that the Symbol sym is annotated _after_ the
1712         // repeating instances that depend on this default value,
1713         // because of this we set an interim value that tells us this
1714         // element (most likely) has a default.
1715         //
1716         // Set interim value for now, reset just before we do this
1717         // properly at annotate time.
1718         meth.defaultValue = value;
1719         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1720     }
1721 
1722     Type readTypeOrClassSymbol(int i) {
1723         // support preliminary jsr175-format class files
<span class="line-modified">1724         if (buf[poolIdx[i]] == CONSTANT_Class)</span>
<span class="line-modified">1725             return readClassSymbol(i).type;</span>
<span class="line-removed">1726         return readTypeToProxy(i);</span>
<span class="line-removed">1727     }</span>
<span class="line-removed">1728     Type readEnumType(int i) {</span>
<span class="line-removed">1729         // support preliminary jsr175-format class files</span>
<span class="line-removed">1730         int index = poolIdx[i];</span>
<span class="line-removed">1731         int length = getChar(index + 1);</span>
<span class="line-removed">1732         if (buf[index + length + 2] != &#39;;&#39;)</span>
<span class="line-removed">1733             return enterClass(readName(i)).type;</span>
1734         return readTypeToProxy(i);
1735     }
1736     Type readTypeToProxy(int i) {
1737         if (currentModule.module_info == currentOwner) {
<span class="line-modified">1738             int index = poolIdx[i];</span>
<span class="line-removed">1739             return new ProxyType(Arrays.copyOfRange(buf, index + 3, index + 3 + getChar(index + 1)));</span>
1740         } else {
<span class="line-modified">1741             return readType(i);</span>
1742         }
1743     }
1744 
1745     CompoundAnnotationProxy readCompoundAnnotation() {
1746         Type t;
1747         if (currentModule.module_info == currentOwner) {
<span class="line-modified">1748             int index = poolIdx[nextChar()];</span>
<span class="line-modified">1749             t = new ProxyType(Arrays.copyOfRange(buf, index + 3, index + 3 + getChar(index + 1)));</span>
1750         } else {
1751             t = readTypeOrClassSymbol(nextChar());
1752         }
1753         int numFields = nextChar();
1754         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1755         for (int i=0; i&lt;numFields; i++) {
<span class="line-modified">1756             Name name = readName(nextChar());</span>
1757             Attribute value = readAttributeValue();
1758             pairs.append(new Pair&lt;&gt;(name, value));
1759         }
1760         return new CompoundAnnotationProxy(t, pairs.toList());
1761     }
1762 
1763     TypeAnnotationProxy readTypeAnnotation() {
1764         TypeAnnotationPosition position = readPosition();
1765         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1766 
1767         return new TypeAnnotationProxy(proxy, position);
1768     }
1769 
1770     TypeAnnotationPosition readPosition() {
1771         int tag = nextByte(); // TargetType tag is a byte
1772 
1773         if (!TargetType.isValidTargetTypeValue(tag))
1774             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1775 
1776         TargetType type = TargetType.fromTargetTypeValue(tag);
</pre>
<hr />
<pre>
1949             return TypeAnnotationPosition.methodReturn(readTypePath());
1950         case FIELD:
1951             return TypeAnnotationPosition.field(readTypePath());
1952         case UNKNOWN:
1953             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1954         default:
1955             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1956         }
1957     }
1958 
1959     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1960         int len = nextByte();
1961         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1962         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1963             loc = loc.append(nextByte());
1964 
1965         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1966 
1967     }
1968 











1969     Attribute readAttributeValue() {
<span class="line-modified">1970         char c = (char) buf[bp++];</span>
1971         switch (c) {
1972         case &#39;B&#39;:
<span class="line-modified">1973             return new Attribute.Constant(syms.byteType, readPool(nextChar()));</span>
1974         case &#39;C&#39;:
<span class="line-modified">1975             return new Attribute.Constant(syms.charType, readPool(nextChar()));</span>
1976         case &#39;D&#39;:
<span class="line-modified">1977             return new Attribute.Constant(syms.doubleType, readPool(nextChar()));</span>
1978         case &#39;F&#39;:
<span class="line-modified">1979             return new Attribute.Constant(syms.floatType, readPool(nextChar()));</span>
1980         case &#39;I&#39;:
<span class="line-modified">1981             return new Attribute.Constant(syms.intType, readPool(nextChar()));</span>
1982         case &#39;J&#39;:
<span class="line-modified">1983             return new Attribute.Constant(syms.longType, readPool(nextChar()));</span>
1984         case &#39;S&#39;:
<span class="line-modified">1985             return new Attribute.Constant(syms.shortType, readPool(nextChar()));</span>
1986         case &#39;Z&#39;:
<span class="line-modified">1987             return new Attribute.Constant(syms.booleanType, readPool(nextChar()));</span>
1988         case &#39;s&#39;:
<span class="line-modified">1989             return new Attribute.Constant(syms.stringType, readPool(nextChar()).toString());</span>
1990         case &#39;e&#39;:
<span class="line-modified">1991             return new EnumAttributeProxy(readEnumType(nextChar()), readName(nextChar()));</span>
1992         case &#39;c&#39;:
1993             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1994         case &#39;[&#39;: {
1995             int n = nextChar();
1996             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1997             for (int i=0; i&lt;n; i++)
1998                 l.append(readAttributeValue());
1999             return new ArrayAttributeProxy(l.toList());
2000         }
2001         case &#39;@&#39;:
2002             return readCompoundAnnotation();
2003         default:
2004             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
2005         }
2006     }
2007 
2008     interface ProxyVisitor extends Attribute.Visitor {
2009         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
2010         void visitClassAttributeProxy(ClassAttributeProxy proxy);
2011         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
</pre>
<hr />
<pre>
2380             JavaFileObject previousClassFile = currentClassFile;
2381             try {
2382                 currentClassFile = classFile;
2383                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2384                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2385             } finally {
2386                 currentClassFile = previousClassFile;
2387             }
2388         }
2389     }
2390 
2391 
2392 /************************************************************************
2393  * Reading Symbols
2394  ***********************************************************************/
2395 
2396     /** Read a field.
2397      */
2398     VarSymbol readField() {
2399         long flags = adjustFieldFlags(nextChar());
<span class="line-modified">2400         Name name = readName(nextChar());</span>
<span class="line-modified">2401         Type type = readType(nextChar());</span>
2402         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2403         readMemberAttrs(v);
2404         return v;
2405     }
2406 
2407     /** Read a method.
2408      */
2409     MethodSymbol readMethod() {
2410         long flags = adjustMethodFlags(nextChar());
<span class="line-modified">2411         Name name = readName(nextChar());</span>
<span class="line-modified">2412         Type type = readType(nextChar());</span>
2413         if (currentOwner.isInterface() &amp;&amp;
2414                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2415             if (majorVersion &gt; Version.V52.major ||
2416                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2417                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2418                     currentOwner.flags_field |= DEFAULT;
2419                     flags |= DEFAULT | ABSTRACT;
2420                 }
2421             } else {
2422                 //protect against ill-formed classfiles
2423                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2424                                    Integer.toString(majorVersion),
2425                                    Integer.toString(minorVersion));
2426             }
2427         }
2428         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2429             // Sometimes anonymous classes don&#39;t have an outer
2430             // instance, however, there is no reliable way to tell so
2431             // we never strip this$n
2432             // ditto for local classes. Local classes that have an enclosing method set
</pre>
<hr />
<pre>
2536                 // we never strip this$n
2537                 if (!currentOwner.name.isEmpty())
2538                     firstParam += 1;
2539             }
2540 
2541             if (sym.type != jvmType) {
2542                 // reading the method attributes has caused the
2543                 // symbol&#39;s type to be changed. (i.e. the Signature
2544                 // attribute.)  This may happen if there are hidden
2545                 // (synthetic) parameters in the descriptor, but not
2546                 // in the Signature.  The position of these hidden
2547                 // parameters is unspecified; for now, assume they are
2548                 // at the beginning, and so skip over them. The
2549                 // primary case for this is two hidden parameters
2550                 // passed into Enum constructors.
2551                 int skip = Code.width(jvmType.getParameterTypes())
2552                         - Code.width(sym.type.getParameterTypes());
2553                 firstParam += skip;
2554             }
2555         }
<span class="line-modified">2556         List&lt;Name&gt; paramNames = List.nil();</span>
2557         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2558         int nameIndex = firstParam;
2559         int annotationIndex = 0;
2560         for (Type t: sym.type.getParameterTypes()) {
<span class="line-modified">2561             Name name = parameterName(nameIndex, paramNames);</span>
<span class="line-removed">2562             paramNames = paramNames.prepend(name);</span>
<span class="line-removed">2563             VarSymbol param = new VarSymbol(PARAMETER, name, t, sym);</span>
2564             params.append(param);
2565             if (parameterAnnotations != null) {
2566                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2567                 if (annotations != null &amp;&amp; annotations.proxies != null
2568                         &amp;&amp; !annotations.proxies.isEmpty()) {
2569                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2570                 }
2571             }
2572             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2573             annotationIndex++;
2574         }
2575         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2576             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2577         }
2578         Assert.checkNull(sym.params);
2579         sym.params = params.toList();
2580         parameterAnnotations = null;
2581         parameterNameIndices = null;
2582     }
2583 
2584 
2585     // Returns the name for the parameter at position &#39;index&#39;, either using
2586     // names read from the MethodParameters, or by synthesizing a name that
2587     // is not on the &#39;exclude&#39; list.
<span class="line-modified">2588     private Name parameterName(int index, List&lt;Name&gt; exclude) {</span>


2589         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2590                 &amp;&amp; parameterNameIndices[index] != 0) {
<span class="line-modified">2591             return readName(parameterNameIndices[index]);</span>
<span class="line-modified">2592         }</span>
<span class="line-modified">2593         String prefix = &quot;arg&quot;;</span>
<span class="line-modified">2594         while (true) {</span>
<span class="line-modified">2595             Name argName = names.fromString(prefix + exclude.size());</span>
<span class="line-modified">2596             if (!exclude.contains(argName))</span>
<span class="line-modified">2597                 return argName;</span>
<span class="line-modified">2598             prefix += &quot;$&quot;;</span>


2599         }


2600     }
2601 
2602     /**
2603      * skip n bytes
2604      */
2605     void skipBytes(int n) {
2606         bp = bp + n;
2607     }
2608 
2609     /** Skip a field or method
2610      */
2611     void skipMember() {
2612         bp = bp + 6;
2613         char ac = nextChar();
2614         for (int i = 0; i &lt; ac; i++) {
2615             bp = bp + 2;
2616             int attrLen = nextInt();
2617             bp = bp + attrLen;
2618         }
2619     }
</pre>
<hr />
<pre>
2656      *  versions of an inner class are read.
2657      */
2658     void readClass(ClassSymbol c) {
2659         ClassType ct = (ClassType)c.type;
2660 
2661         // allocate scope for members
2662         c.members_field = WriteableScope.create(c);
2663 
2664         // prepare type variable table
2665         typevars = typevars.dup(currentOwner);
2666         if (ct.getEnclosingType().hasTag(CLASS))
2667             enterTypevars(c.owner, ct.getEnclosingType());
2668 
2669         // read flags, or skip if this is an inner class
2670         long f = nextChar();
2671         long flags = adjustClassFlags(f);
2672         if ((flags &amp; MODULE) == 0) {
2673             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2674             // read own class name and check that it matches
2675             currentModule = c.packge().modle;
<span class="line-modified">2676             ClassSymbol self = readClassSymbol(nextChar());</span>
2677             if (c != self) {
2678                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2679                                    self.flatname);
2680             }
2681         } else {
2682             if (majorVersion &lt; Version.V53.major) {
2683                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2684                         Integer.toString(majorVersion),
2685                         Integer.toString(minorVersion));
2686             }
2687             c.flags_field = flags;
2688             currentModule = (ModuleSymbol) c.owner;
2689             int this_class = nextChar();
2690             // temp, no check on this_class
2691         }
2692 
2693         // class attributes must be read before class
2694         // skip ahead to read class attributes
2695         int startbp = bp;
2696         nextChar();
2697         char interfaceCount = nextChar();
2698         bp += interfaceCount * 2;
2699         char fieldCount = nextChar();
2700         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2701         char methodCount = nextChar();
2702         for (int i = 0; i &lt; methodCount; i++) skipMember();
2703         readClassAttrs(c);
2704 
<span class="line-removed">2705         if (readAllOfClassFile) {</span>
<span class="line-removed">2706             for (int i = 1; i &lt; poolObj.length; i++) readPool(i);</span>
<span class="line-removed">2707             c.pool = new Pool(poolObj.length, poolObj, types);</span>
<span class="line-removed">2708         }</span>
<span class="line-removed">2709 </span>
2710         // reset and read rest of classinfo
2711         bp = startbp;
2712         int n = nextChar();
2713         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2714             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2715         }
2716         if (ct.supertype_field == null)
<span class="line-modified">2717             ct.supertype_field = (n == 0)</span>
<span class="line-modified">2718                 ? Type.noType</span>
<span class="line-removed">2719                 : readClassSymbol(n).erasure(types);</span>
2720         n = nextChar();
2721         List&lt;Type&gt; is = List.nil();
2722         for (int i = 0; i &lt; n; i++) {
<span class="line-modified">2723             Type _inter = readClassSymbol(nextChar()).erasure(types);</span>
2724             is = is.prepend(_inter);
2725         }
2726         if (ct.interfaces_field == null)
2727             ct.interfaces_field = is.reverse();
2728 
2729         Assert.check(fieldCount == nextChar());
2730         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2731         Assert.check(methodCount == nextChar());
2732         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2733 
2734         typevars = typevars.leave();
2735     }
2736 
2737     /** Read inner class info. For each inner/outer pair allocate a
2738      *  member class.
2739      */
2740     void readInnerClasses(ClassSymbol c) {
2741         int n = nextChar();
2742         for (int i = 0; i &lt; n; i++) {
2743             nextChar(); // skip inner class symbol
<span class="line-modified">2744             ClassSymbol outer = readClassSymbol(nextChar());</span>
<span class="line-modified">2745             Name name = readName(nextChar());</span>


2746             if (name == null) name = names.empty;
2747             long flags = adjustClassFlags(nextChar());
2748             if (outer != null) { // we have a member class
2749                 if (name == names.empty)
2750                     name = names.one;
2751                 ClassSymbol member = enterClass(name, outer);
2752                 if ((flags &amp; STATIC) == 0) {
2753                     ((ClassType)member.type).setEnclosingType(outer.type);
2754                     if (member.erasure_field != null)
2755                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2756                 }
2757                 if (c == outer) {
2758                     member.flags_field = flags;
2759                     enterMember(c, member);
2760                 }
2761             }
2762         }
2763     }
2764 
2765     /** Read a class definition from the bytes in buf.
</pre>
<hr />
<pre>
2779             if (majorVersion == (maxMajor + 1))
2780                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2781                                                      majorVersion,
2782                                                      maxMajor));
2783             else
2784                 throw badClassFile(&quot;wrong.version&quot;,
2785                                    Integer.toString(majorVersion),
2786                                    Integer.toString(minorVersion),
2787                                    Integer.toString(maxMajor),
2788                                    Integer.toString(maxMinor));
2789         }
2790 
2791         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2792             if (!preview.isEnabled()) {
2793                 log.error(preview.disabledError(currentClassFile, majorVersion));
2794             } else {
2795                 preview.warnPreview(c.classfile, majorVersion);
2796             }
2797         }
2798 
<span class="line-modified">2799         indexPool();</span>

2800         if (signatureBuffer.length &lt; bp) {
2801             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2802             signatureBuffer = new byte[ns];
2803         }
2804         readClass(c);
2805     }
2806 
2807     public void readClassFile(ClassSymbol c) {
2808         currentOwner = c;
2809         currentClassFile = c.classfile;
2810         warnedAttrs.clear();
2811         filling = true;
2812         target = null;
2813         repeatable = null;
2814         try {
2815             bp = 0;
<span class="line-modified">2816             buf = readInputStream(buf, c.classfile.openInputStream());</span>

2817             readClassBuffer(c);
2818             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2819                 List&lt;Type&gt; missing = missingTypeVariables;
2820                 List&lt;Type&gt; found = foundTypeVariables;
2821                 missingTypeVariables = List.nil();
2822                 foundTypeVariables = List.nil();
2823                 interimUses = List.nil();
2824                 interimProvides = List.nil();
2825                 filling = false;
2826                 ClassType ct = (ClassType)currentOwner.type;
2827                 ct.supertype_field =
2828                     types.subst(ct.supertype_field, missing, found);
2829                 ct.interfaces_field =
2830                     types.subst(ct.interfaces_field, missing, found);
2831                 ct.typarams_field =
2832                     types.substBounds(ct.typarams_field, missing, found);
2833                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2834                     types.head.tsym.type = types.head;
2835                 }
2836             } else if (missingTypeVariables.isEmpty() !=
</pre>
<hr />
<pre>
2850                     Assert.check(currentModule.isCompleted());
2851                     currentModule.usesProvidesCompleter =
2852                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2853                 } else {
2854                     currentModule.uses = List.nil();
2855                     currentModule.provides = List.nil();
2856                 }
2857             }
2858         } catch (IOException | ClosedFileSystemException ex) {
2859             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2860         } catch (ArrayIndexOutOfBoundsException ex) {
2861             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2862         } finally {
2863             interimUses = List.nil();
2864             interimProvides = List.nil();
2865             missingTypeVariables = List.nil();
2866             foundTypeVariables = List.nil();
2867             filling = false;
2868         }
2869     }
<span class="line-removed">2870     // where</span>
<span class="line-removed">2871         private static byte[] readInputStream(byte[] buf, InputStream s) throws IOException {</span>
<span class="line-removed">2872             try {</span>
<span class="line-removed">2873                 buf = ensureCapacity(buf, s.available());</span>
<span class="line-removed">2874                 int r = s.read(buf);</span>
<span class="line-removed">2875                 int bp = 0;</span>
<span class="line-removed">2876                 while (r != -1) {</span>
<span class="line-removed">2877                     bp += r;</span>
<span class="line-removed">2878                     buf = ensureCapacity(buf, bp);</span>
<span class="line-removed">2879                     r = s.read(buf, bp, buf.length - bp);</span>
<span class="line-removed">2880                 }</span>
<span class="line-removed">2881                 return buf;</span>
<span class="line-removed">2882             } finally {</span>
<span class="line-removed">2883                 try {</span>
<span class="line-removed">2884                     s.close();</span>
<span class="line-removed">2885                 } catch (IOException e) {</span>
<span class="line-removed">2886                     /* Ignore any errors, as this stream may have already</span>
<span class="line-removed">2887                      * thrown a related exception which is the one that</span>
<span class="line-removed">2888                      * should be reported.</span>
<span class="line-removed">2889                      */</span>
<span class="line-removed">2890                 }</span>
<span class="line-removed">2891             }</span>
<span class="line-removed">2892         }</span>
<span class="line-removed">2893         /*</span>
<span class="line-removed">2894          * ensureCapacity will increase the buffer as needed, taking note that</span>
<span class="line-removed">2895          * the new buffer will always be greater than the needed and never</span>
<span class="line-removed">2896          * exactly equal to the needed size or bp. If equal then the read (above)</span>
<span class="line-removed">2897          * will infinitely loop as buf.length - bp == 0.</span>
<span class="line-removed">2898          */</span>
<span class="line-removed">2899         private static byte[] ensureCapacity(byte[] buf, int needed) {</span>
<span class="line-removed">2900             if (buf.length &lt;= needed) {</span>
<span class="line-removed">2901                 byte[] old = buf;</span>
<span class="line-removed">2902                 buf = new byte[Integer.highestOneBit(needed) &lt;&lt; 1];</span>
<span class="line-removed">2903                 System.arraycopy(old, 0, buf, 0, old.length);</span>
<span class="line-removed">2904             }</span>
<span class="line-removed">2905             return buf;</span>
<span class="line-removed">2906         }</span>
2907 
2908     /** We can only read a single class file at a time; this
2909      *  flag keeps track of when we are currently reading a class
2910      *  file.
2911      */
2912     public boolean filling = false;
2913 
2914 /************************************************************************
2915  * Adjusting flags
2916  ***********************************************************************/
2917 
2918     long adjustFieldFlags(long flags) {
2919         return flags;
2920     }
2921 
2922     long adjustMethodFlags(long flags) {
2923         if ((flags &amp; ACC_BRIDGE) != 0) {
2924             flags &amp;= ~ACC_BRIDGE;
2925             flags |= BRIDGE;
2926         }
</pre>
<hr />
<pre>
3062         }
3063 
3064         @Override
3065         public void complete(ClassSymbol sym) {
3066             Assert.check(proxyOn == sym);
3067             Attribute.Compound theTarget = null, theRepeatable = null;
3068             AnnotationDeproxy deproxy;
3069 
3070             try {
3071                 if (target != null) {
3072                     deproxy = new AnnotationDeproxy(proxyOn);
3073                     theTarget = deproxy.deproxyCompound(target);
3074                 }
3075 
3076                 if (repeatable != null) {
3077                     deproxy = new AnnotationDeproxy(proxyOn);
3078                     theRepeatable = deproxy.deproxyCompound(repeatable);
3079                 }
3080             } catch (Exception e) {
3081                 throw new CompletionFailure(sym,
<span class="line-modified">3082                                             ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),</span>
3083                                             dcfh);
3084             }
3085 
3086             sym.getAnnotationTypeMetadata().setTarget(theTarget);
3087             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
3088         }
3089     }
3090 
3091     private class ProxyType extends Type {
3092 
<span class="line-modified">3093         private final byte[] content;</span>
3094 
<span class="line-modified">3095         public ProxyType(byte[] content) {</span>
3096             super(syms.noSymbol, TypeMetadata.EMPTY);
<span class="line-modified">3097             this.content = content;</span>
3098         }
3099 
3100         @Override
3101         public TypeTag getTag() {
3102             return TypeTag.NONE;
3103         }
3104 
3105         @Override
3106         public Type cloneWithMetadata(TypeMetadata metadata) {
3107             throw new UnsupportedOperationException();
3108         }
3109 
3110         public Type resolve() {
<span class="line-modified">3111             return sigToType(content, 0, content.length);</span>
3112         }
3113 
3114         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3115         public String toString() {
3116             return &quot;&lt;ProxyType&gt;&quot;;
3117         }
3118 
3119     }
3120 
3121     private static final class InterimUsesDirective {
3122         public final Name service;
3123 
3124         public InterimUsesDirective(Name service) {
3125             this.service = service;
3126         }
3127 
3128     }
3129 
3130     private static final class InterimProvidesDirective {
3131         public final Name service;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.net.URI;
  30 import java.net.URISyntaxException;
  31 import java.nio.CharBuffer;
  32 import java.nio.file.ClosedFileSystemException;
  33 import java.util.Arrays;
  34 import java.util.EnumSet;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Map;
  38 import java.util.Set;
<span class="line-added">  39 import java.util.function.IntFunction;</span>
  40 
  41 import javax.lang.model.element.Modifier;
  42 import javax.lang.model.element.NestingKind;
  43 import javax.tools.JavaFileManager;
  44 import javax.tools.JavaFileObject;
  45 
  46 import com.sun.tools.javac.code.Source.Feature;
  47 import com.sun.tools.javac.comp.Annotate;
  48 import com.sun.tools.javac.comp.Annotate.AnnotationTypeCompleter;
  49 import com.sun.tools.javac.code.*;
  50 import com.sun.tools.javac.code.Directive.*;
  51 import com.sun.tools.javac.code.Lint.LintCategory;
  52 import com.sun.tools.javac.code.Scope.WriteableScope;
  53 import com.sun.tools.javac.code.Symbol.*;
  54 import com.sun.tools.javac.code.Symtab;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  57 import com.sun.tools.javac.file.BaseFileManager;
  58 import com.sun.tools.javac.file.PathFileObject;

  59 import com.sun.tools.javac.jvm.ClassFile.Version;
<span class="line-added">  60 import com.sun.tools.javac.jvm.PoolConstant.NameAndType;</span>
  61 import com.sun.tools.javac.main.Option;
  62 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  63 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  64 import com.sun.tools.javac.util.*;
  65 import com.sun.tools.javac.util.DefinedBy.Api;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 import static com.sun.tools.javac.code.Flags.*;
  69 import static com.sun.tools.javac.code.Kinds.Kind.*;
  70 
  71 import com.sun.tools.javac.code.Scope.LookupKind;
  72 
  73 import static com.sun.tools.javac.code.TypeTag.ARRAY;
  74 import static com.sun.tools.javac.code.TypeTag.CLASS;
  75 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  76 import static com.sun.tools.javac.jvm.ClassFile.*;
  77 import static com.sun.tools.javac.jvm.ClassFile.Version.*;
  78 
  79 import static com.sun.tools.javac.main.Option.PARAMETERS;
  80 
</pre>
<hr />
<pre>
  84  *  for all other definitions in the classfile. Top-level Classes themselves
  85  *  appear as members of the scopes of PackageSymbols.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class ClassReader {
  93     /** The context key for the class reader. */
  94     protected static final Context.Key&lt;ClassReader&gt; classReaderKey = new Context.Key&lt;&gt;();
  95 
  96     public static final int INITIAL_BUFFER_SIZE = 0x0fff0;
  97 
  98     private final Annotate annotate;
  99 
 100     /** Switch: verbose output.
 101      */
 102     boolean verbose;
 103 





 104     /** Switch: allow modules.
 105      */
 106     boolean allowModules;
 107 
<span class="line-added"> 108     /** Switch: allow records</span>
<span class="line-added"> 109      */</span>
<span class="line-added"> 110     boolean allowRecords;</span>
<span class="line-added"> 111 </span>
 112    /** Lint option: warn about classfile issues
 113      */
 114     boolean lintClassfile;
 115 
 116     /** Switch: preserve parameter names from the variable table.
 117      */
 118     public boolean saveParameterNames;
 119 
 120     /**
 121      * The currently selected profile.
 122      */
 123     public final Profile profile;
 124 
 125     /** The log to use for verbose output
 126      */
 127     final Log log;
 128 
 129     /** The symbol table. */
 130     Symtab syms;
 131 
</pre>
<hr />
<pre>
 153      */
 154     protected WriteableScope typevars;
 155 
 156     private List&lt;InterimUsesDirective&gt; interimUses = List.nil();
 157     private List&lt;InterimProvidesDirective&gt; interimProvides = List.nil();
 158 
 159     /** The path name of the class file currently being read.
 160      */
 161     protected JavaFileObject currentClassFile = null;
 162 
 163     /** The class or method currently being read.
 164      */
 165     protected Symbol currentOwner = null;
 166 
 167     /** The module containing the class currently being read.
 168      */
 169     protected ModuleSymbol currentModule = null;
 170 
 171     /** The buffer containing the currently read class file.
 172      */
<span class="line-modified"> 173     ByteBuffer buf = new ByteBuffer(INITIAL_BUFFER_SIZE);</span>
 174 
 175     /** The current input pointer.
 176      */
 177     protected int bp;
 178 
<span class="line-modified"> 179     /** The pool reader.</span>
 180      */
<span class="line-modified"> 181     PoolReader poolReader;</span>





 182 
 183     /** The major version number of the class file being read. */
 184     int majorVersion;
 185     /** The minor version number of the class file being read. */
 186     int minorVersion;
 187 
 188     /** A table to hold the constant pool indices for method parameter
 189      * names, as given in LocalVariableTable attributes.
 190      */
 191     int[] parameterNameIndices;
 192 
 193     /**
 194      * A table to hold annotations for method parameters.
 195      */
 196     ParameterAnnotations[] parameterAnnotations;
 197 
 198     /**
 199      * A holder for parameter annotations.
 200      */
 201     static class ParameterAnnotations {
</pre>
<hr />
<pre>
 217 
 218     /** Set this to false every time we start reading a method
 219      * and are saving parameter names.  Set it to true when we see
 220      * MethodParameters, if it&#39;s set when we see a LocalVariableTable,
 221      * then we ignore the parameter names from the LVT.
 222      */
 223     boolean sawMethodParameters;
 224 
 225     /**
 226      * The set of attribute names for which warnings have been generated for the current class
 227      */
 228     Set&lt;Name&gt; warnedAttrs = new HashSet&lt;&gt;();
 229 
 230     /**
 231      * The prototype @Target Attribute.Compound if this class is an annotation annotated with
 232      * @Target
 233      */
 234     CompoundAnnotationProxy target;
 235 
 236     /**
<span class="line-modified"> 237      * The prototype @Repeatable Attribute.Compound if this class is an annotation annotated with</span>
 238      * @Repeatable
 239      */
 240     CompoundAnnotationProxy repeatable;
 241 
 242     /** Get the ClassReader instance for this invocation. */
 243     public static ClassReader instance(Context context) {
 244         ClassReader instance = context.get(classReaderKey);
 245         if (instance == null)
 246             instance = new ClassReader(context);
 247         return instance;
 248     }
 249 
 250     /** Construct a new class reader. */
 251     protected ClassReader(Context context) {
 252         context.put(classReaderKey, this);
 253         annotate = Annotate.instance(context);
 254         names = Names.instance(context);
 255         syms = Symtab.instance(context);
 256         types = Types.instance(context);
 257         fileManager = context.get(JavaFileManager.class);
 258         if (fileManager == null)
 259             throw new AssertionError(&quot;FileManager initialization error&quot;);
 260         diagFactory = JCDiagnostic.Factory.instance(context);
 261         dcfh = DeferredCompletionFailureHandler.instance(context);
 262 
 263         log = Log.instance(context);
 264 
 265         Options options = Options.instance(context);
 266         verbose         = options.isSet(Option.VERBOSE);
 267 
 268         Source source = Source.instance(context);
 269         preview = Preview.instance(context);
 270         allowModules     = Feature.MODULES.allowedInSource(source);
<span class="line-added"> 271         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 272                 Feature.RECORDS.allowedInSource(source);</span>
 273 
 274         saveParameterNames = options.isSet(PARAMETERS);
 275 
 276         profile = Profile.instance(context);
 277 
 278         typevars = WriteableScope.create(syms.noSymbol);
 279 
 280         lintClassfile = Lint.instance(context).isEnabled(LintCategory.CLASSFILE);
 281 
 282         initAttributeReaders();
 283     }
 284 
 285     /** Add member to class unless it is synthetic.
 286      */
 287     private void enterMember(ClassSymbol c, Symbol sym) {
 288         // Synthetic members are not entered -- reason lost to history (optimization?).
 289         // Lambda methods must be entered because they may have inner classes (which reference them)
 290         if ((sym.flags_field &amp; (SYNTHETIC|BRIDGE)) != SYNTHETIC || sym.name.startsWith(names.lambda))
 291             c.members_field.enter(sym);
 292     }
</pre>
<hr />
<pre>
 303             diagFactory,
 304             dcfh);
 305     }
 306 
 307     public ClassFinder.BadEnclosingMethodAttr badEnclosingMethod(Symbol sym) {
 308         return new ClassFinder.BadEnclosingMethodAttr (
 309             currentOwner.enclClass(),
 310             currentClassFile,
 311             diagFactory.fragment(Fragments.BadEnclosingMethod(sym)),
 312             diagFactory,
 313             dcfh);
 314     }
 315 
 316 /************************************************************************
 317  * Buffer Access
 318  ***********************************************************************/
 319 
 320     /** Read a character.
 321      */
 322     char nextChar() {
<span class="line-modified"> 323         char res = buf.getChar(bp);</span>
<span class="line-added"> 324         bp += 2;</span>
<span class="line-added"> 325         return res;</span>
 326     }
 327 
 328     /** Read a byte.
 329      */
 330     int nextByte() {
<span class="line-modified"> 331         return buf.getByte(bp++) &amp; 0xFF;</span>
 332     }
 333 
 334     /** Read an integer.
 335      */
 336     int nextInt() {
<span class="line-modified"> 337         int res = buf.getInt(bp);</span>
<span class="line-modified"> 338         bp += 4;</span>
<span class="line-modified"> 339         return res;</span>
























































 340     }
 341 
 342 /************************************************************************
 343  * Constant Pool Access
 344  ***********************************************************************/
 345 



















































































































































































































 346     /** Read module_flags.
 347      */
 348     Set&lt;ModuleFlags&gt; readModuleFlags(int flags) {
 349         Set&lt;ModuleFlags&gt; set = EnumSet.noneOf(ModuleFlags.class);
 350         for (ModuleFlags f : ModuleFlags.values()) {
 351             if ((flags &amp; f.value) != 0)
 352                 set.add(f);
 353         }
 354         return set;
 355     }
 356 
 357     /** Read resolution_flags.
 358      */
 359     Set&lt;ModuleResolutionFlags&gt; readModuleResolutionFlags(int flags) {
 360         Set&lt;ModuleResolutionFlags&gt; set = EnumSet.noneOf(ModuleResolutionFlags.class);
 361         for (ModuleResolutionFlags f : ModuleResolutionFlags.values()) {
 362             if ((flags &amp; f.value) != 0)
 363                 set.add(f);
 364         }
 365         return set;
</pre>
<hr />
<pre>
 477                 */
 478                 return t;
 479             }
 480         case &#39;S&#39;:
 481             sigp++;
 482             return syms.shortType;
 483         case &#39;V&#39;:
 484             sigp++;
 485             return syms.voidType;
 486         case &#39;Z&#39;:
 487             sigp++;
 488             return syms.booleanType;
 489         case &#39;[&#39;:
 490             sigp++;
 491             return new ArrayType(sigToType(), syms.arrayClass);
 492         case &#39;(&#39;:
 493             sigp++;
 494             List&lt;Type&gt; argtypes = sigToTypes(&#39;)&#39;);
 495             Type restype = sigToType();
 496             List&lt;Type&gt; thrown = List.nil();
<span class="line-modified"> 497             while (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;^&#39;) {</span>
 498                 sigp++;
 499                 thrown = thrown.prepend(sigToType());
 500             }
 501             // if there is a typevar in the throws clause we should state it.
 502             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail) {
 503                 if (l.head.hasTag(TYPEVAR)) {
 504                     l.head.tsym.flags_field |= THROWS;
 505                 }
 506             }
 507             return new MethodType(argtypes,
 508                                   restype,
 509                                   thrown.reverse(),
 510                                   syms.methodClass);
 511         case &#39;&lt;&#39;:
 512             typevars = typevars.dup(currentOwner);
 513             Type poly = new ForAll(sigToTypeParams(), sigToType());
 514             typevars = typevars.leave();
 515             return poly;
 516         default:
 517             throw badClassFile(&quot;bad.signature&quot;,
</pre>
<hr />
<pre>
 570                                         // no &quot;rare&quot; types
 571                                         super.setEnclosingType(types.erasure(enclosingType));
 572                                     } else {
 573                                         super.setEnclosingType(types.subst(enclosingType,
 574                                                                            typeParams,
 575                                                                            typeArgs));
 576                                     }
 577                                 } else {
 578                                     super.setEnclosingType(Type.noType);
 579                                 }
 580                             }
 581                             return super.getEnclosingType();
 582                         }
 583                         @Override
 584                         public void setEnclosingType(Type outer) {
 585                             throw new UnsupportedOperationException();
 586                         }
 587                     };
 588                 switch (signature[sigp++]) {
 589                 case &#39;;&#39;:
<span class="line-modified"> 590                     if (sigp &lt; siglimit &amp;&amp; signature[sigp] == &#39;.&#39;) {</span>
 591                         // support old-style GJC signatures
 592                         // The signature produced was
 593                         // Lfoo/Outer&lt;Lfoo/X;&gt;;.Lfoo/Outer$Inner&lt;Lfoo/Y;&gt;;
 594                         // rather than say
 595                         // Lfoo/Outer&lt;Lfoo/X;&gt;.Inner&lt;Lfoo/Y;&gt;;
 596                         // so we skip past &quot;.Lfoo/Outer$&quot;
 597                         sigp += (sbp - startSbp) + // &quot;foo/Outer&quot;
 598                             3;  // &quot;.L&quot; and &quot;$&quot;
 599                         signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 600                         break;
 601                     } else {
 602                         sbp = startSbp;
 603                         return outer;
 604                     }
 605                 case &#39;.&#39;:
 606                     signatureBuffer[sbp++] = (byte)&#39;$&#39;;
 607                     break;
 608                 default:
 609                     throw new AssertionError(signature[sigp-1]);
 610                 }
</pre>
<hr />
<pre>
 764         protected final Name name;
 765         protected final ClassFile.Version version;
 766         protected final Set&lt;AttributeKind&gt; kinds;
 767     }
 768 
 769     protected Set&lt;AttributeKind&gt; CLASS_ATTRIBUTE =
 770             EnumSet.of(AttributeKind.CLASS);
 771     protected Set&lt;AttributeKind&gt; MEMBER_ATTRIBUTE =
 772             EnumSet.of(AttributeKind.MEMBER);
 773     protected Set&lt;AttributeKind&gt; CLASS_OR_MEMBER_ATTRIBUTE =
 774             EnumSet.of(AttributeKind.CLASS, AttributeKind.MEMBER);
 775 
 776     protected Map&lt;Name, AttributeReader&gt; attributeReaders = new HashMap&lt;&gt;();
 777 
 778     private void initAttributeReaders() {
 779         AttributeReader[] readers = {
 780             // v45.3 attributes
 781 
 782             new AttributeReader(names.Code, V45_3, MEMBER_ATTRIBUTE) {
 783                 protected void read(Symbol sym, int attrLen) {
<span class="line-modified"> 784                     if (saveParameterNames)</span>
 785                         ((MethodSymbol)sym).code = readCode(sym);
 786                     else
 787                         bp = bp + attrLen;
 788                 }
 789             },
 790 
 791             new AttributeReader(names.ConstantValue, V45_3, MEMBER_ATTRIBUTE) {
 792                 protected void read(Symbol sym, int attrLen) {
<span class="line-modified"> 793                     Object v = poolReader.getConstant(nextChar());</span>
 794                     // Ignore ConstantValue attribute if field not final.
 795                     if ((sym.flags() &amp; FINAL) == 0) {
 796                         return;
 797                     }
 798                     VarSymbol var = (VarSymbol) sym;
 799                     switch (var.type.getTag()) {
 800                        case BOOLEAN:
 801                        case BYTE:
 802                        case CHAR:
 803                        case SHORT:
 804                        case INT:
 805                            checkType(var, Integer.class, v);
 806                            break;
 807                        case LONG:
 808                            checkType(var, Long.class, v);
 809                            break;
 810                        case FLOAT:
 811                            checkType(var, Float.class, v);
 812                            break;
 813                        case DOUBLE:
 814                            checkType(var, Double.class, v);
 815                            break;
 816                        case CLASS:
<span class="line-modified"> 817                            if (var.type.tsym == syms.stringType.tsym) {</span>
<span class="line-modified"> 818                                checkType(var, String.class, v);</span>
<span class="line-added"> 819                            } else {</span>
<span class="line-added"> 820                                throw badClassFile(&quot;bad.constant.value.type&quot;, var.type);</span>
<span class="line-added"> 821                            }</span>
 822                            break;
 823                        default:
 824                            // ignore ConstantValue attribute if type is not primitive or String
 825                            return;
 826                     }
 827                     if (v instanceof Integer &amp;&amp; !var.type.getTag().checkRange((Integer) v)) {
 828                         throw badClassFile(&quot;bad.constant.range&quot;, v, var, var.type);
 829                     }
 830                     var.setData(v);
 831                 }
 832 
 833                 void checkType(Symbol var, Class&lt;?&gt; clazz, Object value) {
 834                     if (!clazz.isInstance(value)) {
 835                         throw badClassFile(&quot;bad.constant.value&quot;, value, var, clazz.getSimpleName());
 836                     }
 837                 }
 838             },
 839 
 840             new AttributeReader(names.Deprecated, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 841                 protected void read(Symbol sym, int attrLen) {
 842                     Symbol s = sym.owner.kind == MDL ? sym.owner : sym;
 843 
 844                     s.flags_field |= DEPRECATED;
 845                 }
 846             },
 847 
 848             new AttributeReader(names.Exceptions, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 849                 protected void read(Symbol sym, int attrLen) {
 850                     int nexceptions = nextChar();
 851                     List&lt;Type&gt; thrown = List.nil();
 852                     for (int j = 0; j &lt; nexceptions; j++)
<span class="line-modified"> 853                         thrown = thrown.prepend(poolReader.getClass(nextChar()).type);</span>
 854                     if (sym.type.getThrownTypes().isEmpty())
 855                         sym.type.asMethodType().thrown = thrown.reverse();
 856                 }
 857             },
 858 
 859             new AttributeReader(names.InnerClasses, V45_3, CLASS_ATTRIBUTE) {
 860                 protected void read(Symbol sym, int attrLen) {
 861                     ClassSymbol c = (ClassSymbol) sym;
 862                     if (currentModule.module_info == c) {
 863                         //prevent entering the classes too soon:
 864                         skipInnerClasses();
 865                     } else {
 866                         readInnerClasses(c);
 867                     }
 868                 }
 869             },
 870 
 871             new AttributeReader(names.LocalVariableTable, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 872                 protected void read(Symbol sym, int attrLen) {
 873                     int newbp = bp + attrLen;
 874                     if (saveParameterNames &amp;&amp; !sawMethodParameters) {
 875                         // Pick up parameter names from the variable table.
 876                         // Parameter names are not explicitly identified as such,
 877                         // but all parameter name entries in the LocalVariableTable
 878                         // have a start_pc of 0.  Therefore, we record the name
<span class="line-modified"> 879                         // indices of all slots with a start_pc of zero in the</span>
<span class="line-modified"> 880                         // parameterNameIndices array.</span>
 881                         // Note that this implicitly honors the JVMS spec that
 882                         // there may be more than one LocalVariableTable, and that
 883                         // there is no specified ordering for the entries.
 884                         int numEntries = nextChar();
 885                         for (int i = 0; i &lt; numEntries; i++) {
 886                             int start_pc = nextChar();
 887                             int length = nextChar();
 888                             int nameIndex = nextChar();
 889                             int sigIndex = nextChar();
 890                             int register = nextChar();
 891                             if (start_pc == 0) {
 892                                 // ensure array large enough
 893                                 if (register &gt;= parameterNameIndices.length) {
 894                                     int newSize =
 895                                             Math.max(register + 1, parameterNameIndices.length + 8);
 896                                     parameterNameIndices =
 897                                             Arrays.copyOf(parameterNameIndices, newSize);
 898                                 }
 899                                 parameterNameIndices[register] = nameIndex;
 900                                 haveParameterNameIndices = true;
 901                             }
 902                         }
 903                     }
 904                     bp = newbp;
 905                 }
 906             },
 907 
 908             new AttributeReader(names.SourceFile, V45_3, CLASS_ATTRIBUTE) {
 909                 protected void read(Symbol sym, int attrLen) {
 910                     ClassSymbol c = (ClassSymbol) sym;
<span class="line-modified"> 911                     Name n = poolReader.getName(nextChar());</span>
 912                     c.sourcefile = new SourceFileObject(n);
 913                     // If the class is a toplevel class, originating from a Java source file,
 914                     // but the class name does not match the file name, then it is
 915                     // an auxiliary class.
 916                     String sn = n.toString();
 917                     if (c.owner.kind == PCK &amp;&amp;
 918                         sn.endsWith(&quot;.java&quot;) &amp;&amp;
 919                         !sn.equals(c.name.toString()+&quot;.java&quot;)) {
 920                         c.flags_field |= AUXILIARY;
 921                     }
 922                 }
 923             },
 924 
 925             new AttributeReader(names.Synthetic, V45_3, CLASS_OR_MEMBER_ATTRIBUTE) {
 926                 protected void read(Symbol sym, int attrLen) {
 927                     sym.flags_field |= SYNTHETIC;
 928                 }
 929             },
 930 
 931             // standard v49 attributes
 932 
 933             new AttributeReader(names.EnclosingMethod, V49, CLASS_ATTRIBUTE) {
 934                 protected void read(Symbol sym, int attrLen) {
 935                     int newbp = bp + attrLen;
 936                     readEnclosingMethodAttr(sym);
 937                     bp = newbp;
 938                 }
 939             },
 940 
 941             new AttributeReader(names.Signature, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 942                 protected void read(Symbol sym, int attrLen) {
 943                     if (sym.kind == TYP) {
 944                         ClassSymbol c = (ClassSymbol) sym;
 945                         readingClassAttr = true;
 946                         try {
 947                             ClassType ct1 = (ClassType)c.type;
 948                             Assert.check(c == currentOwner);
<span class="line-modified"> 949                             ct1.typarams_field = poolReader.getName(nextChar())</span>
<span class="line-added"> 950                                     .map(ClassReader.this::sigToTypeParams);</span>
 951                             ct1.supertype_field = sigToType();
 952                             ListBuffer&lt;Type&gt; is = new ListBuffer&lt;&gt;();
 953                             while (sigp != siglimit) is.append(sigToType());
 954                             ct1.interfaces_field = is.toList();
 955                         } finally {
 956                             readingClassAttr = false;
 957                         }
 958                     } else {
 959                         List&lt;Type&gt; thrown = sym.type.getThrownTypes();
<span class="line-modified"> 960                         sym.type = poolReader.getType(nextChar());</span>
 961                         //- System.err.println(&quot; # &quot; + sym.type);
 962                         if (sym.kind == MTH &amp;&amp; sym.type.getThrownTypes().isEmpty())
 963                             sym.type.asMethodType().thrown = thrown;
 964 
 965                     }
 966                 }
 967             },
 968 
 969             // v49 annotation attributes
 970 
 971             new AttributeReader(names.AnnotationDefault, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 972                 protected void read(Symbol sym, int attrLen) {
 973                     attachAnnotationDefault(sym);
 974                 }
 975             },
 976 
 977             new AttributeReader(names.RuntimeInvisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 978                 protected void read(Symbol sym, int attrLen) {
 979                     attachAnnotations(sym);
 980                 }
 981             },
 982 
 983             new AttributeReader(names.RuntimeInvisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 984                 protected void read(Symbol sym, int attrLen) {
 985                     readParameterAnnotations(sym);
 986                 }
 987             },
 988 
 989             new AttributeReader(names.RuntimeVisibleAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 990                 protected void read(Symbol sym, int attrLen) {
 991                     attachAnnotations(sym);
 992                 }
 993             },
 994 
 995             new AttributeReader(names.RuntimeVisibleParameterAnnotations, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
 996                 protected void read(Symbol sym, int attrLen) {
 997                     readParameterAnnotations(sym);
 998                 }
 999             },
1000 
<span class="line-modified">1001             // additional &quot;legacy&quot; v49 attributes, superseded by flags</span>
1002 
1003             new AttributeReader(names.Annotation, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1004                 protected void read(Symbol sym, int attrLen) {
1005                     sym.flags_field |= ANNOTATION;
1006                 }
1007             },
1008 
1009             new AttributeReader(names.Bridge, V49, MEMBER_ATTRIBUTE) {
1010                 protected void read(Symbol sym, int attrLen) {
1011                     sym.flags_field |= BRIDGE;
1012                 }
1013             },
1014 
1015             new AttributeReader(names.Enum, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
1016                 protected void read(Symbol sym, int attrLen) {
1017                     sym.flags_field |= ENUM;
1018                 }
1019             },
1020 
1021             new AttributeReader(names.Varargs, V49, CLASS_OR_MEMBER_ATTRIBUTE) {
</pre>
<hr />
<pre>
1061                             }
1062                             parameterNameIndices[index++] = nameIndex;
1063                         }
1064                     }
1065                     bp = newbp;
1066                 }
1067             },
1068 
1069             // standard v53 attributes
1070 
1071             new AttributeReader(names.Module, V53, CLASS_ATTRIBUTE) {
1072                 @Override
1073                 protected boolean accepts(AttributeKind kind) {
1074                     return super.accepts(kind) &amp;&amp; allowModules;
1075                 }
1076                 protected void read(Symbol sym, int attrLen) {
1077                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1078                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1079                         ListBuffer&lt;Directive&gt; directives = new ListBuffer&lt;&gt;();
1080 
<span class="line-modified">1081                         Name moduleName = poolReader.peekModuleName(nextChar(), names::fromUtf);</span>
1082                         if (currentModule.name != moduleName) {
1083                             throw badClassFile(&quot;module.name.mismatch&quot;, moduleName, currentModule.name);
1084                         }
1085 
1086                         Set&lt;ModuleFlags&gt; moduleFlags = readModuleFlags(nextChar());
1087                         msym.flags.addAll(moduleFlags);
<span class="line-modified">1088                         msym.version = optPoolEntry(nextChar(), poolReader::getName, null);</span>
1089 
1090                         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
1091                         int nrequires = nextChar();
1092                         for (int i = 0; i &lt; nrequires; i++) {
<span class="line-modified">1093                             ModuleSymbol rsym = poolReader.getModule(nextChar());</span>
1094                             Set&lt;RequiresFlag&gt; flags = readRequiresFlags(nextChar());
1095                             if (rsym == syms.java_base &amp;&amp; majorVersion &gt;= V54.major) {
1096                                 if (flags.contains(RequiresFlag.TRANSITIVE)) {
1097                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.TRANSITIVE);
1098                                 }
1099                                 if (flags.contains(RequiresFlag.STATIC_PHASE)) {
1100                                     throw badClassFile(&quot;bad.requires.flag&quot;, RequiresFlag.STATIC_PHASE);
1101                                 }
1102                             }
1103                             nextChar(); // skip compiled version
1104                             requires.add(new RequiresDirective(rsym, flags));
1105                         }
1106                         msym.requires = requires.toList();
1107                         directives.addAll(msym.requires);
1108 
1109                         ListBuffer&lt;ExportsDirective&gt; exports = new ListBuffer&lt;&gt;();
1110                         int nexports = nextChar();
1111                         for (int i = 0; i &lt; nexports; i++) {
<span class="line-modified">1112                             PackageSymbol p = poolReader.getPackage(nextChar());</span>

1113                             Set&lt;ExportsFlag&gt; flags = readExportsFlags(nextChar());
1114                             int nto = nextChar();
1115                             List&lt;ModuleSymbol&gt; to;
1116                             if (nto == 0) {
1117                                 to = null;
1118                             } else {
1119                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1120                                 for (int t = 0; t &lt; nto; t++)
<span class="line-modified">1121                                     lb.append(poolReader.getModule(nextChar()));</span>
1122                                 to = lb.toList();
1123                             }
1124                             exports.add(new ExportsDirective(p, to, flags));
1125                         }
1126                         msym.exports = exports.toList();
1127                         directives.addAll(msym.exports);
1128                         ListBuffer&lt;OpensDirective&gt; opens = new ListBuffer&lt;&gt;();
1129                         int nopens = nextChar();
1130                         if (nopens != 0 &amp;&amp; msym.flags.contains(ModuleFlags.OPEN)) {
1131                             throw badClassFile(&quot;module.non.zero.opens&quot;, currentModule.name);
1132                         }
1133                         for (int i = 0; i &lt; nopens; i++) {
<span class="line-modified">1134                             PackageSymbol p = poolReader.getPackage(nextChar());</span>

1135                             Set&lt;OpensFlag&gt; flags = readOpensFlags(nextChar());
1136                             int nto = nextChar();
1137                             List&lt;ModuleSymbol&gt; to;
1138                             if (nto == 0) {
1139                                 to = null;
1140                             } else {
1141                                 ListBuffer&lt;ModuleSymbol&gt; lb = new ListBuffer&lt;&gt;();
1142                                 for (int t = 0; t &lt; nto; t++)
<span class="line-modified">1143                                     lb.append(poolReader.getModule(nextChar()));</span>
1144                                 to = lb.toList();
1145                             }
1146                             opens.add(new OpensDirective(p, to, flags));
1147                         }
1148                         msym.opens = opens.toList();
1149                         directives.addAll(msym.opens);
1150 
1151                         msym.directives = directives.toList();
1152 
1153                         ListBuffer&lt;InterimUsesDirective&gt; uses = new ListBuffer&lt;&gt;();
1154                         int nuses = nextChar();
1155                         for (int i = 0; i &lt; nuses; i++) {
<span class="line-modified">1156                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);</span>
1157                             uses.add(new InterimUsesDirective(srvc));
1158                         }
1159                         interimUses = uses.toList();
1160 
1161                         ListBuffer&lt;InterimProvidesDirective&gt; provides = new ListBuffer&lt;&gt;();
1162                         int nprovides = nextChar();
1163                         for (int p = 0; p &lt; nprovides; p++) {
<span class="line-modified">1164                             Name srvc = poolReader.peekClassName(nextChar(), this::classNameMapper);</span>
1165                             int nimpls = nextChar();
1166                             ListBuffer&lt;Name&gt; impls = new ListBuffer&lt;&gt;();
1167                             for (int i = 0; i &lt; nimpls; i++) {
<span class="line-modified">1168                                 impls.append(poolReader.peekClassName(nextChar(), this::classNameMapper));</span>
1169                             provides.add(new InterimProvidesDirective(srvc, impls.toList()));
1170                             }
1171                         }
1172                         interimProvides = provides.toList();
1173                     }
1174                 }
<span class="line-added">1175 </span>
<span class="line-added">1176                 private Name classNameMapper(byte[] arr, int offset, int length) {</span>
<span class="line-added">1177                     return names.fromUtf(ClassFile.internalize(arr, offset, length));</span>
<span class="line-added">1178                 }</span>
1179             },
1180 
1181             new AttributeReader(names.ModuleResolution, V53, CLASS_ATTRIBUTE) {
1182                 @Override
1183                 protected boolean accepts(AttributeKind kind) {
1184                     return super.accepts(kind) &amp;&amp; allowModules;
1185                 }
1186                 protected void read(Symbol sym, int attrLen) {
1187                     if (sym.kind == TYP &amp;&amp; sym.owner.kind == MDL) {
1188                         ModuleSymbol msym = (ModuleSymbol) sym.owner;
1189                         msym.resolutionFlags.addAll(readModuleResolutionFlags(nextChar()));
1190                     }
1191                 }
1192             },
<span class="line-added">1193 </span>
<span class="line-added">1194             new AttributeReader(names.Record, V58, CLASS_ATTRIBUTE) {</span>
<span class="line-added">1195                 @Override</span>
<span class="line-added">1196                 protected boolean accepts(AttributeKind kind) {</span>
<span class="line-added">1197                     return super.accepts(kind) &amp;&amp; allowRecords;</span>
<span class="line-added">1198                 }</span>
<span class="line-added">1199                 protected void read(Symbol sym, int attrLen) {</span>
<span class="line-added">1200                     if (sym.kind == TYP) {</span>
<span class="line-added">1201                         sym.flags_field |= RECORD;</span>
<span class="line-added">1202                     }</span>
<span class="line-added">1203                     bp = bp + attrLen;</span>
<span class="line-added">1204                 }</span>
<span class="line-added">1205             }</span>
1206         };
1207 
1208         for (AttributeReader r: readers)
1209             attributeReaders.put(r.name, r);
1210     }
1211 
1212     protected void readEnclosingMethodAttr(Symbol sym) {
1213         // sym is a nested class with an &quot;Enclosing Method&quot; attribute
1214         // remove sym from it&#39;s current owners scope and place it in
1215         // the scope specified by the attribute
1216         sym.owner.members().remove(sym);
1217         ClassSymbol self = (ClassSymbol)sym;
<span class="line-modified">1218         ClassSymbol c = poolReader.getClass(nextChar());</span>
<span class="line-modified">1219         NameAndType nt = optPoolEntry(nextChar(), poolReader::getNameAndType, null);</span>
1220 
1221         if (c.members_field == null || c.kind != TYP)
1222             throw badClassFile(&quot;bad.enclosing.class&quot;, self, c);
1223 
1224         MethodSymbol m = findMethod(nt, c.members_field, self.flags());
1225         if (nt != null &amp;&amp; m == null)
1226             throw badEnclosingMethod(self);
1227 
1228         self.name = simpleBinaryName(self.flatname, c.flatname) ;
1229         self.owner = m != null ? m : c;
1230         if (self.name.isEmpty())
1231             self.fullname = names.empty;
1232         else
1233             self.fullname = ClassSymbol.formFullName(self.name, self.owner);
1234 
1235         if (m != null) {
1236             ((ClassType)sym.type).setEnclosingType(m.type);
1237         } else if ((self.flags_field &amp; STATIC) == 0) {
1238             ((ClassType)sym.type).setEnclosingType(c.type);
1239         } else {
1240             ((ClassType)sym.type).setEnclosingType(Type.noType);
1241         }
1242         enterTypevars(self, self.type);
1243         if (!missingTypeVariables.isEmpty()) {
1244             ListBuffer&lt;Type&gt; typeVars =  new ListBuffer&lt;&gt;();
1245             for (Type typevar : missingTypeVariables) {
1246                 typeVars.append(findTypeVar(typevar.tsym.name));
1247             }
1248             foundTypeVariables = typeVars.toList();
1249         } else {
1250             foundTypeVariables = List.nil();
1251         }
1252     }
1253 
1254     // See java.lang.Class
1255     private Name simpleBinaryName(Name self, Name enclosing) {
<span class="line-added">1256         if (!self.startsWith(enclosing)) {</span>
<span class="line-added">1257             throw badClassFile(&quot;bad.enclosing.method&quot;, self);</span>
<span class="line-added">1258         }</span>
<span class="line-added">1259 </span>
1260         String simpleBinaryName = self.toString().substring(enclosing.toString().length());
1261         if (simpleBinaryName.length() &lt; 1 || simpleBinaryName.charAt(0) != &#39;$&#39;)
1262             throw badClassFile(&quot;bad.enclosing.method&quot;, self);
1263         int index = 1;
1264         while (index &lt; simpleBinaryName.length() &amp;&amp;
1265                isAsciiDigit(simpleBinaryName.charAt(index)))
1266             index++;
1267         return names.fromString(simpleBinaryName.substring(index));
1268     }
1269 
1270     private MethodSymbol findMethod(NameAndType nt, Scope scope, long flags) {
1271         if (nt == null)
1272             return null;
1273 
<span class="line-modified">1274         MethodType type = nt.type.asMethodType();</span>
1275 
1276         for (Symbol sym : scope.getSymbolsByName(nt.name)) {
1277             if (sym.kind == MTH &amp;&amp; isSameBinaryType(sym.type.asMethodType(), type))
1278                 return (MethodSymbol)sym;
1279         }
1280 
1281         if (nt.name != names.init)
1282             // not a constructor
1283             return null;
1284         if ((flags &amp; INTERFACE) != 0)
1285             // no enclosing instance
1286             return null;
<span class="line-modified">1287         if (nt.type.getParameterTypes().isEmpty())</span>
1288             // no parameters
1289             return null;
1290 
1291         // A constructor of an inner class.
1292         // Remove the first argument (the enclosing instance)
<span class="line-modified">1293         nt = new NameAndType(nt.name, new MethodType(nt.type.getParameterTypes().tail,</span>
<span class="line-modified">1294                                  nt.type.getReturnType(),</span>
<span class="line-modified">1295                                  nt.type.getThrownTypes(),</span>
1296                                  syms.methodClass));
1297         // Try searching again
1298         return findMethod(nt, scope, flags);
1299     }
1300 
1301     /** Similar to Types.isSameType but avoids completion */
1302     private boolean isSameBinaryType(MethodType mt1, MethodType mt2) {
1303         List&lt;Type&gt; types1 = types.erasure(mt1.getParameterTypes())
1304             .prepend(types.erasure(mt1.getReturnType()));
1305         List&lt;Type&gt; types2 = mt2.getParameterTypes().prepend(mt2.getReturnType());
1306         while (!types1.isEmpty() &amp;&amp; !types2.isEmpty()) {
1307             if (types1.head.tsym != types2.head.tsym)
1308                 return false;
1309             types1 = types1.tail;
1310             types2 = types2.tail;
1311         }
1312         return types1.isEmpty() &amp;&amp; types2.isEmpty();
1313     }
1314 
1315     /**
1316      * Character.isDigit answers &lt;tt&gt;true&lt;/tt&gt; to some non-ascii
1317      * digits.  This one does not.  &lt;b&gt;copied from java.lang.Class&lt;/b&gt;
1318      */
1319     private static boolean isAsciiDigit(char c) {
1320         return &#39;0&#39; &lt;= c &amp;&amp; c &lt;= &#39;9&#39;;
1321     }
1322 
1323     /** Read member attributes.
1324      */
1325     void readMemberAttrs(Symbol sym) {
1326         readAttrs(sym, AttributeKind.MEMBER);
1327     }
1328 
1329     void readAttrs(Symbol sym, AttributeKind kind) {
1330         char ac = nextChar();
1331         for (int i = 0; i &lt; ac; i++) {
<span class="line-modified">1332             Name attrName = poolReader.getName(nextChar());</span>
1333             int attrLen = nextInt();
1334             AttributeReader r = attributeReaders.get(attrName);
1335             if (r != null &amp;&amp; r.accepts(kind))
1336                 r.read(sym, attrLen);
1337             else  {
1338                 bp = bp + attrLen;
1339             }
1340         }
1341     }
1342 
1343     private boolean readingClassAttr = false;
1344     private List&lt;Type&gt; missingTypeVariables = List.nil();
1345     private List&lt;Type&gt; foundTypeVariables = List.nil();
1346 
1347     /** Read class attributes.
1348      */
1349     void readClassAttrs(ClassSymbol c) {
1350         readAttrs(c, AttributeKind.CLASS);
1351     }
1352 
</pre>
<hr />
<pre>
1397             if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())
1398                 sym.flags_field |= PROPRIETARY;
1399             else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {
1400                 if (profile != Profile.DEFAULT) {
1401                     for (Pair&lt;Name, Attribute&gt; v : proxy.values) {
1402                         if (v.fst == names.value &amp;&amp; v.snd instanceof Attribute.Constant) {
1403                             Attribute.Constant c = (Attribute.Constant)v.snd;
1404                             if (c.type == syms.intType &amp;&amp; ((Integer)c.value) &gt; profile.value) {
1405                                 sym.flags_field |= NOT_IN_PROFILE;
1406                             }
1407                         }
1408                     }
1409                 }
1410             } else {
1411                 if (proxy.type.tsym == syms.annotationTargetType.tsym) {
1412                     target = proxy;
1413                 } else if (proxy.type.tsym == syms.repeatableType.tsym) {
1414                     repeatable = proxy;
1415                 } else if (proxy.type.tsym == syms.deprecatedType.tsym) {
1416                     sym.flags_field |= (DEPRECATED | DEPRECATED_ANNOTATION);
<span class="line-modified">1417                     setFlagIfAttributeTrue(proxy, sym, names.forRemoval, DEPRECATED_REMOVAL);</span>
<span class="line-modified">1418                 }  else if (proxy.type.tsym == syms.previewFeatureType.tsym) {</span>
<span class="line-modified">1419                     sym.flags_field |= PREVIEW_API;</span>
<span class="line-modified">1420                     setFlagIfAttributeTrue(proxy, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);</span>




1421                 }
1422                 proxies.append(proxy);
1423             }
1424         }
1425         annotate.normal(new AnnotationCompleter(sym, proxies.toList()));
1426     }
<span class="line-added">1427     //where:</span>
<span class="line-added">1428         private void setFlagIfAttributeTrue(CompoundAnnotationProxy proxy, Symbol sym, Name attribute, long flag) {</span>
<span class="line-added">1429             for (Pair&lt;Name, Attribute&gt; v : proxy.values) {</span>
<span class="line-added">1430                 if (v.fst == attribute &amp;&amp; v.snd instanceof Attribute.Constant) {</span>
<span class="line-added">1431                     Attribute.Constant c = (Attribute.Constant)v.snd;</span>
<span class="line-added">1432                     if (c.type == syms.booleanType &amp;&amp; ((Integer)c.value) != 0) {</span>
<span class="line-added">1433                         sym.flags_field |= flag;</span>
<span class="line-added">1434                     }</span>
<span class="line-added">1435                 }</span>
<span class="line-added">1436             }</span>
<span class="line-added">1437         }</span>
1438 
1439     /** Read parameter annotations.
1440      */
1441     void readParameterAnnotations(Symbol meth) {
<span class="line-modified">1442         int numParameters = buf.getByte(bp++) &amp; 0xFF;</span>
1443         if (parameterAnnotations == null) {
1444             parameterAnnotations = new ParameterAnnotations[numParameters];
1445         } else if (parameterAnnotations.length != numParameters) {
1446             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, meth);
1447         }
1448         for (int pnum = 0; pnum &lt; numParameters; pnum++) {
1449             if (parameterAnnotations[pnum] == null) {
1450                 parameterAnnotations[pnum] = new ParameterAnnotations();
1451             }
1452             parameterAnnotations[pnum].add(readAnnotations());
1453         }
1454     }
1455 
1456     void attachTypeAnnotations(final Symbol sym) {
1457         int numAttributes = nextChar();
1458         if (numAttributes != 0) {
1459             ListBuffer&lt;TypeAnnotationProxy&gt; proxies = new ListBuffer&lt;&gt;();
1460             for (int i = 0; i &lt; numAttributes; i++)
1461                 proxies.append(readTypeAnnotation());
1462             annotate.normal(new TypeAnnotationCompleter(sym, proxies.toList()));
</pre>
<hr />
<pre>
1466     /** Attach the default value for an annotation element.
1467      */
1468     void attachAnnotationDefault(final Symbol sym) {
1469         final MethodSymbol meth = (MethodSymbol)sym; // only on methods
1470         final Attribute value = readAttributeValue();
1471 
1472         // The default value is set later during annotation. It might
1473         // be the case that the Symbol sym is annotated _after_ the
1474         // repeating instances that depend on this default value,
1475         // because of this we set an interim value that tells us this
1476         // element (most likely) has a default.
1477         //
1478         // Set interim value for now, reset just before we do this
1479         // properly at annotate time.
1480         meth.defaultValue = value;
1481         annotate.normal(new AnnotationDefaultCompleter(meth, value));
1482     }
1483 
1484     Type readTypeOrClassSymbol(int i) {
1485         // support preliminary jsr175-format class files
<span class="line-modified">1486         if (poolReader.hasTag(i, CONSTANT_Class))</span>
<span class="line-modified">1487             return poolReader.getClass(i).type;</span>








1488         return readTypeToProxy(i);
1489     }
1490     Type readTypeToProxy(int i) {
1491         if (currentModule.module_info == currentOwner) {
<span class="line-modified">1492             return new ProxyType(i);</span>

1493         } else {
<span class="line-modified">1494             return poolReader.getType(i);</span>
1495         }
1496     }
1497 
1498     CompoundAnnotationProxy readCompoundAnnotation() {
1499         Type t;
1500         if (currentModule.module_info == currentOwner) {
<span class="line-modified">1501             int cpIndex = nextChar();</span>
<span class="line-modified">1502             t = new ProxyType(cpIndex);</span>
1503         } else {
1504             t = readTypeOrClassSymbol(nextChar());
1505         }
1506         int numFields = nextChar();
1507         ListBuffer&lt;Pair&lt;Name,Attribute&gt;&gt; pairs = new ListBuffer&lt;&gt;();
1508         for (int i=0; i&lt;numFields; i++) {
<span class="line-modified">1509             Name name = poolReader.getName(nextChar());</span>
1510             Attribute value = readAttributeValue();
1511             pairs.append(new Pair&lt;&gt;(name, value));
1512         }
1513         return new CompoundAnnotationProxy(t, pairs.toList());
1514     }
1515 
1516     TypeAnnotationProxy readTypeAnnotation() {
1517         TypeAnnotationPosition position = readPosition();
1518         CompoundAnnotationProxy proxy = readCompoundAnnotation();
1519 
1520         return new TypeAnnotationProxy(proxy, position);
1521     }
1522 
1523     TypeAnnotationPosition readPosition() {
1524         int tag = nextByte(); // TargetType tag is a byte
1525 
1526         if (!TargetType.isValidTargetTypeValue(tag))
1527             throw badClassFile(&quot;bad.type.annotation.value&quot;, String.format(&quot;0x%02X&quot;, tag));
1528 
1529         TargetType type = TargetType.fromTargetTypeValue(tag);
</pre>
<hr />
<pre>
1702             return TypeAnnotationPosition.methodReturn(readTypePath());
1703         case FIELD:
1704             return TypeAnnotationPosition.field(readTypePath());
1705         case UNKNOWN:
1706             throw new AssertionError(&quot;jvm.ClassReader: UNKNOWN target type should never occur!&quot;);
1707         default:
1708             throw new AssertionError(&quot;jvm.ClassReader: Unknown target type for position: &quot; + type);
1709         }
1710     }
1711 
1712     List&lt;TypeAnnotationPosition.TypePathEntry&gt; readTypePath() {
1713         int len = nextByte();
1714         ListBuffer&lt;Integer&gt; loc = new ListBuffer&lt;&gt;();
1715         for (int i = 0; i &lt; len * TypeAnnotationPosition.TypePathEntry.bytesPerEntry; ++i)
1716             loc = loc.append(nextByte());
1717 
1718         return TypeAnnotationPosition.getTypePathFromBinary(loc.toList());
1719 
1720     }
1721 
<span class="line-added">1722     /**</span>
<span class="line-added">1723      * Helper function to read an optional pool entry (with given function); this is used while parsing</span>
<span class="line-added">1724      * InnerClasses and EnclosingMethod attributes, as well as when parsing supertype descriptor,</span>
<span class="line-added">1725      * as per JVMS.</span>
<span class="line-added">1726      */</span>
<span class="line-added">1727     &lt;Z&gt; Z optPoolEntry(int index, IntFunction&lt;Z&gt; poolFunc, Z defaultValue) {</span>
<span class="line-added">1728         return (index == 0) ?</span>
<span class="line-added">1729                 defaultValue :</span>
<span class="line-added">1730                 poolFunc.apply(index);</span>
<span class="line-added">1731     }</span>
<span class="line-added">1732 </span>
1733     Attribute readAttributeValue() {
<span class="line-modified">1734         char c = (char) buf.getByte(bp++);</span>
1735         switch (c) {
1736         case &#39;B&#39;:
<span class="line-modified">1737             return new Attribute.Constant(syms.byteType, poolReader.getConstant(nextChar()));</span>
1738         case &#39;C&#39;:
<span class="line-modified">1739             return new Attribute.Constant(syms.charType, poolReader.getConstant(nextChar()));</span>
1740         case &#39;D&#39;:
<span class="line-modified">1741             return new Attribute.Constant(syms.doubleType, poolReader.getConstant(nextChar()));</span>
1742         case &#39;F&#39;:
<span class="line-modified">1743             return new Attribute.Constant(syms.floatType, poolReader.getConstant(nextChar()));</span>
1744         case &#39;I&#39;:
<span class="line-modified">1745             return new Attribute.Constant(syms.intType, poolReader.getConstant(nextChar()));</span>
1746         case &#39;J&#39;:
<span class="line-modified">1747             return new Attribute.Constant(syms.longType, poolReader.getConstant(nextChar()));</span>
1748         case &#39;S&#39;:
<span class="line-modified">1749             return new Attribute.Constant(syms.shortType, poolReader.getConstant(nextChar()));</span>
1750         case &#39;Z&#39;:
<span class="line-modified">1751             return new Attribute.Constant(syms.booleanType, poolReader.getConstant(nextChar()));</span>
1752         case &#39;s&#39;:
<span class="line-modified">1753             return new Attribute.Constant(syms.stringType, poolReader.getName(nextChar()).toString());</span>
1754         case &#39;e&#39;:
<span class="line-modified">1755             return new EnumAttributeProxy(readTypeToProxy(nextChar()), poolReader.getName(nextChar()));</span>
1756         case &#39;c&#39;:
1757             return new ClassAttributeProxy(readTypeOrClassSymbol(nextChar()));
1758         case &#39;[&#39;: {
1759             int n = nextChar();
1760             ListBuffer&lt;Attribute&gt; l = new ListBuffer&lt;&gt;();
1761             for (int i=0; i&lt;n; i++)
1762                 l.append(readAttributeValue());
1763             return new ArrayAttributeProxy(l.toList());
1764         }
1765         case &#39;@&#39;:
1766             return readCompoundAnnotation();
1767         default:
1768             throw new AssertionError(&quot;unknown annotation tag &#39;&quot; + c + &quot;&#39;&quot;);
1769         }
1770     }
1771 
1772     interface ProxyVisitor extends Attribute.Visitor {
1773         void visitEnumAttributeProxy(EnumAttributeProxy proxy);
1774         void visitClassAttributeProxy(ClassAttributeProxy proxy);
1775         void visitArrayAttributeProxy(ArrayAttributeProxy proxy);
</pre>
<hr />
<pre>
2144             JavaFileObject previousClassFile = currentClassFile;
2145             try {
2146                 currentClassFile = classFile;
2147                 List&lt;Attribute.TypeCompound&gt; newList = deproxyTypeCompoundList(proxies);
2148                 sym.setTypeAttributes(newList.prependList(sym.getRawTypeAttributes()));
2149             } finally {
2150                 currentClassFile = previousClassFile;
2151             }
2152         }
2153     }
2154 
2155 
2156 /************************************************************************
2157  * Reading Symbols
2158  ***********************************************************************/
2159 
2160     /** Read a field.
2161      */
2162     VarSymbol readField() {
2163         long flags = adjustFieldFlags(nextChar());
<span class="line-modified">2164         Name name = poolReader.getName(nextChar());</span>
<span class="line-modified">2165         Type type = poolReader.getType(nextChar());</span>
2166         VarSymbol v = new VarSymbol(flags, name, type, currentOwner);
2167         readMemberAttrs(v);
2168         return v;
2169     }
2170 
2171     /** Read a method.
2172      */
2173     MethodSymbol readMethod() {
2174         long flags = adjustMethodFlags(nextChar());
<span class="line-modified">2175         Name name = poolReader.getName(nextChar());</span>
<span class="line-modified">2176         Type type = poolReader.getType(nextChar());</span>
2177         if (currentOwner.isInterface() &amp;&amp;
2178                 (flags &amp; ABSTRACT) == 0 &amp;&amp; !name.equals(names.clinit)) {
2179             if (majorVersion &gt; Version.V52.major ||
2180                     (majorVersion == Version.V52.major &amp;&amp; minorVersion &gt;= Version.V52.minor)) {
2181                 if ((flags &amp; (STATIC | PRIVATE)) == 0) {
2182                     currentOwner.flags_field |= DEFAULT;
2183                     flags |= DEFAULT | ABSTRACT;
2184                 }
2185             } else {
2186                 //protect against ill-formed classfiles
2187                 throw badClassFile((flags &amp; STATIC) == 0 ? &quot;invalid.default.interface&quot; : &quot;invalid.static.interface&quot;,
2188                                    Integer.toString(majorVersion),
2189                                    Integer.toString(minorVersion));
2190             }
2191         }
2192         if (name == names.init &amp;&amp; currentOwner.hasOuterInstance()) {
2193             // Sometimes anonymous classes don&#39;t have an outer
2194             // instance, however, there is no reliable way to tell so
2195             // we never strip this$n
2196             // ditto for local classes. Local classes that have an enclosing method set
</pre>
<hr />
<pre>
2300                 // we never strip this$n
2301                 if (!currentOwner.name.isEmpty())
2302                     firstParam += 1;
2303             }
2304 
2305             if (sym.type != jvmType) {
2306                 // reading the method attributes has caused the
2307                 // symbol&#39;s type to be changed. (i.e. the Signature
2308                 // attribute.)  This may happen if there are hidden
2309                 // (synthetic) parameters in the descriptor, but not
2310                 // in the Signature.  The position of these hidden
2311                 // parameters is unspecified; for now, assume they are
2312                 // at the beginning, and so skip over them. The
2313                 // primary case for this is two hidden parameters
2314                 // passed into Enum constructors.
2315                 int skip = Code.width(jvmType.getParameterTypes())
2316                         - Code.width(sym.type.getParameterTypes());
2317                 firstParam += skip;
2318             }
2319         }
<span class="line-modified">2320         Set&lt;Name&gt; paramNames = new HashSet&lt;&gt;();</span>
2321         ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
2322         int nameIndex = firstParam;
2323         int annotationIndex = 0;
2324         for (Type t: sym.type.getParameterTypes()) {
<span class="line-modified">2325             VarSymbol param = parameter(nameIndex, t, sym, paramNames);</span>


2326             params.append(param);
2327             if (parameterAnnotations != null) {
2328                 ParameterAnnotations annotations = parameterAnnotations[annotationIndex];
2329                 if (annotations != null &amp;&amp; annotations.proxies != null
2330                         &amp;&amp; !annotations.proxies.isEmpty()) {
2331                     annotate.normal(new AnnotationCompleter(param, annotations.proxies));
2332                 }
2333             }
2334             nameIndex += sawMethodParameters ? 1 : Code.width(t);
2335             annotationIndex++;
2336         }
2337         if (parameterAnnotations != null &amp;&amp; parameterAnnotations.length != annotationIndex) {
2338             throw badClassFile(&quot;bad.runtime.invisible.param.annotations&quot;, sym);
2339         }
2340         Assert.checkNull(sym.params);
2341         sym.params = params.toList();
2342         parameterAnnotations = null;
2343         parameterNameIndices = null;
2344     }
2345 
2346 
2347     // Returns the name for the parameter at position &#39;index&#39;, either using
2348     // names read from the MethodParameters, or by synthesizing a name that
2349     // is not on the &#39;exclude&#39; list.
<span class="line-modified">2350     private VarSymbol parameter(int index, Type t, MethodSymbol owner, Set&lt;Name&gt; exclude) {</span>
<span class="line-added">2351         long flags = PARAMETER;</span>
<span class="line-added">2352         Name argName;</span>
2353         if (parameterNameIndices != null &amp;&amp; index &lt; parameterNameIndices.length
2354                 &amp;&amp; parameterNameIndices[index] != 0) {
<span class="line-modified">2355             argName = optPoolEntry(parameterNameIndices[index], poolReader::getName, names.empty);</span>
<span class="line-modified">2356             flags |= NAME_FILLED;</span>
<span class="line-modified">2357         } else {</span>
<span class="line-modified">2358             String prefix = &quot;arg&quot;;</span>
<span class="line-modified">2359             while (true) {</span>
<span class="line-modified">2360                 argName = names.fromString(prefix + exclude.size());</span>
<span class="line-modified">2361                 if (!exclude.contains(argName))</span>
<span class="line-modified">2362                     break;</span>
<span class="line-added">2363                 prefix += &quot;$&quot;;</span>
<span class="line-added">2364             }</span>
2365         }
<span class="line-added">2366         exclude.add(argName);</span>
<span class="line-added">2367         return new ParamSymbol(flags, argName, t, owner);</span>
2368     }
2369 
2370     /**
2371      * skip n bytes
2372      */
2373     void skipBytes(int n) {
2374         bp = bp + n;
2375     }
2376 
2377     /** Skip a field or method
2378      */
2379     void skipMember() {
2380         bp = bp + 6;
2381         char ac = nextChar();
2382         for (int i = 0; i &lt; ac; i++) {
2383             bp = bp + 2;
2384             int attrLen = nextInt();
2385             bp = bp + attrLen;
2386         }
2387     }
</pre>
<hr />
<pre>
2424      *  versions of an inner class are read.
2425      */
2426     void readClass(ClassSymbol c) {
2427         ClassType ct = (ClassType)c.type;
2428 
2429         // allocate scope for members
2430         c.members_field = WriteableScope.create(c);
2431 
2432         // prepare type variable table
2433         typevars = typevars.dup(currentOwner);
2434         if (ct.getEnclosingType().hasTag(CLASS))
2435             enterTypevars(c.owner, ct.getEnclosingType());
2436 
2437         // read flags, or skip if this is an inner class
2438         long f = nextChar();
2439         long flags = adjustClassFlags(f);
2440         if ((flags &amp; MODULE) == 0) {
2441             if (c.owner.kind == PCK || c.owner.kind == ERR) c.flags_field = flags;
2442             // read own class name and check that it matches
2443             currentModule = c.packge().modle;
<span class="line-modified">2444             ClassSymbol self = poolReader.getClass(nextChar());</span>
2445             if (c != self) {
2446                 throw badClassFile(&quot;class.file.wrong.class&quot;,
2447                                    self.flatname);
2448             }
2449         } else {
2450             if (majorVersion &lt; Version.V53.major) {
2451                 throw badClassFile(&quot;anachronistic.module.info&quot;,
2452                         Integer.toString(majorVersion),
2453                         Integer.toString(minorVersion));
2454             }
2455             c.flags_field = flags;
2456             currentModule = (ModuleSymbol) c.owner;
2457             int this_class = nextChar();
2458             // temp, no check on this_class
2459         }
2460 
2461         // class attributes must be read before class
2462         // skip ahead to read class attributes
2463         int startbp = bp;
2464         nextChar();
2465         char interfaceCount = nextChar();
2466         bp += interfaceCount * 2;
2467         char fieldCount = nextChar();
2468         for (int i = 0; i &lt; fieldCount; i++) skipMember();
2469         char methodCount = nextChar();
2470         for (int i = 0; i &lt; methodCount; i++) skipMember();
2471         readClassAttrs(c);
2472 





2473         // reset and read rest of classinfo
2474         bp = startbp;
2475         int n = nextChar();
2476         if ((flags &amp; MODULE) != 0 &amp;&amp; n &gt; 0) {
2477             throw badClassFile(&quot;module.info.invalid.super.class&quot;);
2478         }
2479         if (ct.supertype_field == null)
<span class="line-modified">2480             ct.supertype_field =</span>
<span class="line-modified">2481                     optPoolEntry(n, idx -&gt; poolReader.getClass(idx).erasure(types), Type.noType);</span>

2482         n = nextChar();
2483         List&lt;Type&gt; is = List.nil();
2484         for (int i = 0; i &lt; n; i++) {
<span class="line-modified">2485             Type _inter = poolReader.getClass(nextChar()).erasure(types);</span>
2486             is = is.prepend(_inter);
2487         }
2488         if (ct.interfaces_field == null)
2489             ct.interfaces_field = is.reverse();
2490 
2491         Assert.check(fieldCount == nextChar());
2492         for (int i = 0; i &lt; fieldCount; i++) enterMember(c, readField());
2493         Assert.check(methodCount == nextChar());
2494         for (int i = 0; i &lt; methodCount; i++) enterMember(c, readMethod());
2495 
2496         typevars = typevars.leave();
2497     }
2498 
2499     /** Read inner class info. For each inner/outer pair allocate a
2500      *  member class.
2501      */
2502     void readInnerClasses(ClassSymbol c) {
2503         int n = nextChar();
2504         for (int i = 0; i &lt; n; i++) {
2505             nextChar(); // skip inner class symbol
<span class="line-modified">2506             int outerIdx = nextChar();</span>
<span class="line-modified">2507             int nameIdx = nextChar();</span>
<span class="line-added">2508             ClassSymbol outer = optPoolEntry(outerIdx, poolReader::getClass, null);</span>
<span class="line-added">2509             Name name = optPoolEntry(nameIdx, poolReader::getName, names.empty);</span>
2510             if (name == null) name = names.empty;
2511             long flags = adjustClassFlags(nextChar());
2512             if (outer != null) { // we have a member class
2513                 if (name == names.empty)
2514                     name = names.one;
2515                 ClassSymbol member = enterClass(name, outer);
2516                 if ((flags &amp; STATIC) == 0) {
2517                     ((ClassType)member.type).setEnclosingType(outer.type);
2518                     if (member.erasure_field != null)
2519                         ((ClassType)member.erasure_field).setEnclosingType(types.erasure(outer.type));
2520                 }
2521                 if (c == outer) {
2522                     member.flags_field = flags;
2523                     enterMember(c, member);
2524                 }
2525             }
2526         }
2527     }
2528 
2529     /** Read a class definition from the bytes in buf.
</pre>
<hr />
<pre>
2543             if (majorVersion == (maxMajor + 1))
2544                 log.warning(Warnings.BigMajorVersion(currentClassFile,
2545                                                      majorVersion,
2546                                                      maxMajor));
2547             else
2548                 throw badClassFile(&quot;wrong.version&quot;,
2549                                    Integer.toString(majorVersion),
2550                                    Integer.toString(minorVersion),
2551                                    Integer.toString(maxMajor),
2552                                    Integer.toString(maxMinor));
2553         }
2554 
2555         if (minorVersion == ClassFile.PREVIEW_MINOR_VERSION) {
2556             if (!preview.isEnabled()) {
2557                 log.error(preview.disabledError(currentClassFile, majorVersion));
2558             } else {
2559                 preview.warnPreview(c.classfile, majorVersion);
2560             }
2561         }
2562 
<span class="line-modified">2563         poolReader = new PoolReader(this, names, syms);</span>
<span class="line-added">2564         bp = poolReader.readPool(buf, bp);</span>
2565         if (signatureBuffer.length &lt; bp) {
2566             int ns = Integer.highestOneBit(bp) &lt;&lt; 1;
2567             signatureBuffer = new byte[ns];
2568         }
2569         readClass(c);
2570     }
2571 
2572     public void readClassFile(ClassSymbol c) {
2573         currentOwner = c;
2574         currentClassFile = c.classfile;
2575         warnedAttrs.clear();
2576         filling = true;
2577         target = null;
2578         repeatable = null;
2579         try {
2580             bp = 0;
<span class="line-modified">2581             buf.reset();</span>
<span class="line-added">2582             buf.appendStream(c.classfile.openInputStream());</span>
2583             readClassBuffer(c);
2584             if (!missingTypeVariables.isEmpty() &amp;&amp; !foundTypeVariables.isEmpty()) {
2585                 List&lt;Type&gt; missing = missingTypeVariables;
2586                 List&lt;Type&gt; found = foundTypeVariables;
2587                 missingTypeVariables = List.nil();
2588                 foundTypeVariables = List.nil();
2589                 interimUses = List.nil();
2590                 interimProvides = List.nil();
2591                 filling = false;
2592                 ClassType ct = (ClassType)currentOwner.type;
2593                 ct.supertype_field =
2594                     types.subst(ct.supertype_field, missing, found);
2595                 ct.interfaces_field =
2596                     types.subst(ct.interfaces_field, missing, found);
2597                 ct.typarams_field =
2598                     types.substBounds(ct.typarams_field, missing, found);
2599                 for (List&lt;Type&gt; types = ct.typarams_field; types.nonEmpty(); types = types.tail) {
2600                     types.head.tsym.type = types.head;
2601                 }
2602             } else if (missingTypeVariables.isEmpty() !=
</pre>
<hr />
<pre>
2616                     Assert.check(currentModule.isCompleted());
2617                     currentModule.usesProvidesCompleter =
2618                             new UsesProvidesCompleter(currentModule, interimUses, interimProvides);
2619                 } else {
2620                     currentModule.uses = List.nil();
2621                     currentModule.provides = List.nil();
2622                 }
2623             }
2624         } catch (IOException | ClosedFileSystemException ex) {
2625             throw badClassFile(&quot;unable.to.access.file&quot;, ex.toString());
2626         } catch (ArrayIndexOutOfBoundsException ex) {
2627             throw badClassFile(&quot;bad.class.file&quot;, c.flatname);
2628         } finally {
2629             interimUses = List.nil();
2630             interimProvides = List.nil();
2631             missingTypeVariables = List.nil();
2632             foundTypeVariables = List.nil();
2633             filling = false;
2634         }
2635     }





































2636 
2637     /** We can only read a single class file at a time; this
2638      *  flag keeps track of when we are currently reading a class
2639      *  file.
2640      */
2641     public boolean filling = false;
2642 
2643 /************************************************************************
2644  * Adjusting flags
2645  ***********************************************************************/
2646 
2647     long adjustFieldFlags(long flags) {
2648         return flags;
2649     }
2650 
2651     long adjustMethodFlags(long flags) {
2652         if ((flags &amp; ACC_BRIDGE) != 0) {
2653             flags &amp;= ~ACC_BRIDGE;
2654             flags |= BRIDGE;
2655         }
</pre>
<hr />
<pre>
2791         }
2792 
2793         @Override
2794         public void complete(ClassSymbol sym) {
2795             Assert.check(proxyOn == sym);
2796             Attribute.Compound theTarget = null, theRepeatable = null;
2797             AnnotationDeproxy deproxy;
2798 
2799             try {
2800                 if (target != null) {
2801                     deproxy = new AnnotationDeproxy(proxyOn);
2802                     theTarget = deproxy.deproxyCompound(target);
2803                 }
2804 
2805                 if (repeatable != null) {
2806                     deproxy = new AnnotationDeproxy(proxyOn);
2807                     theRepeatable = deproxy.deproxyCompound(repeatable);
2808                 }
2809             } catch (Exception e) {
2810                 throw new CompletionFailure(sym,
<span class="line-modified">2811                                             () -&gt; ClassReader.this.diagFactory.fragment(Fragments.ExceptionMessage(e.getMessage())),</span>
2812                                             dcfh);
2813             }
2814 
2815             sym.getAnnotationTypeMetadata().setTarget(theTarget);
2816             sym.getAnnotationTypeMetadata().setRepeatable(theRepeatable);
2817         }
2818     }
2819 
2820     private class ProxyType extends Type {
2821 
<span class="line-modified">2822         private final Name name;</span>
2823 
<span class="line-modified">2824         public ProxyType(int index) {</span>
2825             super(syms.noSymbol, TypeMetadata.EMPTY);
<span class="line-modified">2826             this.name = poolReader.getName(index);</span>
2827         }
2828 
2829         @Override
2830         public TypeTag getTag() {
2831             return TypeTag.NONE;
2832         }
2833 
2834         @Override
2835         public Type cloneWithMetadata(TypeMetadata metadata) {
2836             throw new UnsupportedOperationException();
2837         }
2838 
2839         public Type resolve() {
<span class="line-modified">2840             return name.map(ClassReader.this::sigToType);</span>
2841         }
2842 
2843         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2844         public String toString() {
2845             return &quot;&lt;ProxyType&gt;&quot;;
2846         }
2847 
2848     }
2849 
2850     private static final class InterimUsesDirective {
2851         public final Name service;
2852 
2853         public InterimUsesDirective(Name service) {
2854             this.service = service;
2855         }
2856 
2857     }
2858 
2859     private static final class InterimProvidesDirective {
2860         public final Name service;
</pre>
</td>
</tr>
</table>
<center><a href="ClassFile.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ClassWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
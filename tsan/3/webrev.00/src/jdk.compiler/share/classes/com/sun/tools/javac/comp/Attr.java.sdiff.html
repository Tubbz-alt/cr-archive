<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArgumentAttr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttrContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
  30 import java.util.stream.Collectors;
  31 
  32 import javax.lang.model.element.ElementKind;
  33 import javax.tools.JavaFileObject;
  34 
<span class="line-modified">  35 import com.sun.source.tree.CaseTree.CaseKind;</span>
  36 import com.sun.source.tree.IdentifierTree;
  37 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  38 import com.sun.source.tree.MemberSelectTree;
  39 import com.sun.source.tree.TreeVisitor;
  40 import com.sun.source.util.SimpleTreeVisitor;
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Lint.LintCategory;
  43 import com.sun.tools.javac.code.Scope.WriteableScope;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Type.*;
  47 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  48 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  49 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  50 import com.sun.tools.javac.comp.Check.CheckContext;
  51 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;

  52 import com.sun.tools.javac.jvm.*;
  53 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  54 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  55 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  56 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  58 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  59 import com.sun.tools.javac.tree.*;
  60 import com.sun.tools.javac.tree.JCTree.*;
  61 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  62 import com.sun.tools.javac.util.*;
  63 import com.sun.tools.javac.util.DefinedBy.Api;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  65 import com.sun.tools.javac.util.JCDiagnostic.Error;
  66 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  67 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  68 import com.sun.tools.javac.util.List;
  69 
  70 import static com.sun.tools.javac.code.Flags.*;
  71 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  72 import static com.sun.tools.javac.code.Flags.BLOCK;
  73 import static com.sun.tools.javac.code.Kinds.*;
  74 import static com.sun.tools.javac.code.Kinds.Kind.*;
  75 import static com.sun.tools.javac.code.TypeTag.*;
  76 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
<span class="line-removed">  77 import com.sun.tools.javac.comp.Analyzer.AnalyzerMode;</span>
  78 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  79 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  80 
  81 /** This is the main context-dependent analysis phase in GJC. It
  82  *  encompasses name resolution, type checking and constant folding as
  83  *  subtasks. Some subtasks involve auxiliary classes.
  84  *  @see Check
  85  *  @see Resolve
  86  *  @see ConstFold
  87  *  @see Infer
  88  *
  89  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  90  *  If you write code that depends on this, you do so at your own risk.
  91  *  This code and its internal interfaces are subject to change or
  92  *  deletion without notice.&lt;/b&gt;
  93  */
  94 public class Attr extends JCTree.Visitor {
  95     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  96 
  97     final Names names;
  98     final Log log;
  99     final Symtab syms;
 100     final Resolve rs;
 101     final Operators operators;
 102     final Infer infer;
 103     final Analyzer analyzer;
 104     final DeferredAttr deferredAttr;
 105     final Check chk;
 106     final Flow flow;
 107     final MemberEnter memberEnter;
 108     final TypeEnter typeEnter;
 109     final TreeMaker make;
 110     final ConstFold cfolder;
 111     final Enter enter;
 112     final Target target;
 113     final Types types;

 114     final JCDiagnostic.Factory diags;
 115     final TypeAnnotations typeAnnotations;
 116     final DeferredLintHandler deferredLintHandler;
 117     final TypeEnvs typeEnvs;
 118     final Dependencies dependencies;
 119     final Annotate annotate;
 120     final ArgumentAttr argumentAttr;

 121 
 122     public static Attr instance(Context context) {
 123         Attr instance = context.get(attrKey);
 124         if (instance == null)
 125             instance = new Attr(context);
 126         return instance;
 127     }
 128 
 129     protected Attr(Context context) {
 130         context.put(attrKey, this);
 131 
 132         names = Names.instance(context);
 133         log = Log.instance(context);
 134         syms = Symtab.instance(context);
 135         rs = Resolve.instance(context);
 136         operators = Operators.instance(context);
 137         chk = Check.instance(context);
 138         flow = Flow.instance(context);
 139         memberEnter = MemberEnter.instance(context);
 140         typeEnter = TypeEnter.instance(context);
 141         make = TreeMaker.instance(context);
 142         enter = Enter.instance(context);
 143         infer = Infer.instance(context);
 144         analyzer = Analyzer.instance(context);
 145         deferredAttr = DeferredAttr.instance(context);
 146         cfolder = ConstFold.instance(context);
 147         target = Target.instance(context);
 148         types = Types.instance(context);

 149         diags = JCDiagnostic.Factory.instance(context);
 150         annotate = Annotate.instance(context);
 151         typeAnnotations = TypeAnnotations.instance(context);
 152         deferredLintHandler = DeferredLintHandler.instance(context);
 153         typeEnvs = TypeEnvs.instance(context);
 154         dependencies = Dependencies.instance(context);
 155         argumentAttr = ArgumentAttr.instance(context);

 156 
 157         Options options = Options.instance(context);
 158 
 159         Source source = Source.instance(context);
 160         allowPoly = Feature.POLY.allowedInSource(source);
 161         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 162         allowLambda = Feature.LAMBDA.allowedInSource(source);
 163         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 164         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);



 165         sourceName = source.name;
 166         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
 167 
 168         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 169         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 170         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 171         methodAttrInfo = new MethodAttrInfo();
 172         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 173         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 174         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 175     }
 176 
 177     /** Switch: support target-typing inference
 178      */
 179     boolean allowPoly;
 180 
 181     /** Switch: support type annotations.
 182      */
 183     boolean allowTypeAnnos;
 184 
 185     /** Switch: support lambda expressions ?
 186      */
 187     boolean allowLambda;
 188 
 189     /** Switch: support default methods ?
 190      */
 191     boolean allowDefaultMethods;
 192 
 193     /** Switch: static interface methods enabled?
 194      */
 195     boolean allowStaticInterfaceMethods;
 196 




 197     /**
 198      * Switch: warn about use of variable before declaration?
 199      * RFE: 6425594
 200      */
 201     boolean useBeforeDeclarationWarning;
 202 
 203     /**
 204      * Switch: name of source level; used for error reporting.
 205      */
 206     String sourceName;
 207 
 208     /** Check kind and type of given tree against protokind and prototype.
 209      *  If check succeeds, store type in tree and return it.
 210      *  If check fails, store errType in tree and return it.
 211      *  No checks are performed if the prototype is a method type.
 212      *  It is not necessary in this case since we know that kind and type
 213      *  are correct.
 214      *
 215      *  @param tree     The tree whose kind and type is checked
 216      *  @param found    The computed type of the tree
</pre>
<hr />
<pre>
 276     }
 277 
 278     /** Check that variable can be assigned to.
 279      *  @param pos    The current source code position.
 280      *  @param v      The assigned variable
 281      *  @param base   If the variable is referred to in a Select, the part
 282      *                to the left of the `.&#39;, null otherwise.
 283      *  @param env    The current environment.
 284      */
 285     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 286         if (v.name == names._this) {
 287             log.error(pos, Errors.CantAssignValToThis);
 288         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 289             ((v.flags() &amp; HASINIT) != 0
 290              ||
 291              !((base == null ||
 292                TreeInfo.isThisQualifier(base)) &amp;&amp;
 293                isAssignableAsBlankFinal(v, env)))) {
 294             if (v.isResourceVariable()) { //TWR resource
 295                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));


 296             } else {
 297                 log.error(pos, Errors.CantAssignValToFinalVar(v));
 298             }
 299         }
 300     }
 301 
 302     /** Does tree represent a static reference to an identifier?
 303      *  It is assumed that tree is either a SELECT or an IDENT.
 304      *  We have to weed out selects from non-type names here.
 305      *  @param tree    The candidate tree.
 306      */
 307     boolean isStaticReference(JCTree tree) {
 308         if (tree.hasTag(SELECT)) {
 309             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 310             if (lsym == null || lsym.kind != TYP) {
 311                 return false;
 312             }
 313         }
 314         return true;
 315     }
</pre>
<hr />
<pre>
 341     }
 342 
 343     /** Attribute a parsed identifier.
 344      * @param tree Parsed identifier name
 345      * @param env The env to use
 346      */
 347     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 348         return tree.accept(identAttributer, env);
 349     }
 350     // where
 351         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 352         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 353             @Override @DefinedBy(Api.COMPILER_TREE)
 354             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 355                 Symbol site = visit(node.getExpression(), env);
 356                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 357                     return site;
 358                 Name name = (Name)node.getIdentifier();
 359                 if (site.kind == PCK) {
 360                     env.toplevel.packge = (PackageSymbol)site;
<span class="line-modified"> 361                     return rs.findIdentInPackage(env, (TypeSymbol)site, name,</span>
 362                             KindSelector.TYP_PCK);
 363                 } else {
 364                     env.enclClass.sym = (ClassSymbol)site;
 365                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 366                 }
 367             }
 368 
 369             @Override @DefinedBy(Api.COMPILER_TREE)
 370             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
<span class="line-modified"> 371                 return rs.findIdent(env, (Name)node.getName(), KindSelector.TYP_PCK);</span>
 372             }
 373         }
 374 
 375     public Type coerce(Type etype, Type ttype) {
 376         return cfolder.coerce(etype, ttype);
 377     }
 378 
 379     public Type attribType(JCTree node, TypeSymbol sym) {
 380         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 381         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 382         return attribTree(node, localEnv, unknownTypeInfo);
 383     }
 384 
 385     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 386         // Attribute qualifying package or class.
 387         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 388         return attribTree(s.selected, env,
 389                           new ResultInfo(tree.staticImport ?
 390                                          KindSelector.TYP : KindSelector.TYP_PCK,
 391                        Type.noType));
 392     }
 393 
 394     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
<span class="line-modified"> 395         breakTree = tree;</span>
<span class="line-removed"> 396         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</span>
<span class="line-removed"> 397         EnumSet&lt;AnalyzerMode&gt; analyzerModes = EnumSet.copyOf(analyzer.analyzerModes);</span>
<span class="line-removed"> 398         try {</span>
<span class="line-removed"> 399             analyzer.analyzerModes.clear();</span>
<span class="line-removed"> 400             attribExpr(expr, env);</span>
<span class="line-removed"> 401         } catch (BreakAttr b) {</span>
<span class="line-removed"> 402             return b.env;</span>
<span class="line-removed"> 403         } catch (AssertionError ae) {</span>
<span class="line-removed"> 404             if (ae.getCause() instanceof BreakAttr) {</span>
<span class="line-removed"> 405                 return ((BreakAttr)(ae.getCause())).env;</span>
<span class="line-removed"> 406             } else {</span>
<span class="line-removed"> 407                 throw ae;</span>
<span class="line-removed"> 408             }</span>
<span class="line-removed"> 409         } finally {</span>
<span class="line-removed"> 410             breakTree = null;</span>
<span class="line-removed"> 411             log.useSource(prev);</span>
<span class="line-removed"> 412             analyzer.analyzerModes.addAll(analyzerModes);</span>
<span class="line-removed"> 413         }</span>
<span class="line-removed"> 414         return env;</span>
 415     }
 416 
 417     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {




 418         breakTree = tree;
 419         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
<span class="line-removed"> 420         EnumSet&lt;AnalyzerMode&gt; analyzerModes = EnumSet.copyOf(analyzer.analyzerModes);</span>
 421         try {
<span class="line-modified"> 422             analyzer.analyzerModes.clear();</span>
<span class="line-modified"> 423             attribStat(stmt, env);</span>

 424         } catch (BreakAttr b) {
 425             return b.env;
 426         } catch (AssertionError ae) {
 427             if (ae.getCause() instanceof BreakAttr) {
 428                 return ((BreakAttr)(ae.getCause())).env;
 429             } else {
 430                 throw ae;
 431             }
 432         } finally {
 433             breakTree = null;
 434             log.useSource(prev);
<span class="line-removed"> 435             analyzer.analyzerModes.addAll(analyzerModes);</span>
 436         }
 437         return env;
 438     }
 439 
 440     private JCTree breakTree = null;
 441 
 442     private static class BreakAttr extends RuntimeException {
 443         static final long serialVersionUID = -6924771130405446405L;
<span class="line-modified"> 444         private Env&lt;AttrContext&gt; env;</span>
 445         private BreakAttr(Env&lt;AttrContext&gt; env) {
 446             this.env = env;
 447         }
 448     }
 449 
 450     /**
 451      * Mode controlling behavior of Attr.Check
 452      */
 453     enum CheckMode {
 454 
 455         NORMAL,
 456 
 457         /**
 458          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 459          * that the captured var cache in {@code InferenceContext} will be used in read-only
 460          * mode when performing inference checks.
 461          */
 462         NO_TREE_UPDATE {
 463             @Override
 464             public boolean updateTreeType() {
</pre>
<hr />
<pre>
 628     KindSelector pkind() {
 629         return resultInfo.pkind;
 630     }
 631 
 632 /* ************************************************************************
 633  * Visitor methods
 634  *************************************************************************/
 635 
 636     /** Visitor argument: the current environment.
 637      */
 638     Env&lt;AttrContext&gt; env;
 639 
 640     /** Visitor argument: the currently expected attribution result.
 641      */
 642     ResultInfo resultInfo;
 643 
 644     /** Visitor result: the computed type.
 645      */
 646     Type result;
 647 


 648     /** Visitor method: attribute a tree, catching any completion failure
 649      *  exceptions. Return the tree&#39;s type.
 650      *
 651      *  @param tree    The tree to be visited.
 652      *  @param env     The environment visitor argument.
 653      *  @param resultInfo   The result info visitor argument.
 654      */
 655     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 656         Env&lt;AttrContext&gt; prevEnv = this.env;
 657         ResultInfo prevResult = this.resultInfo;
 658         try {
 659             this.env = env;
 660             this.resultInfo = resultInfo;
 661             if (resultInfo.needsArgumentAttr(tree)) {
 662                 result = argumentAttr.attribArg(tree, env);
 663             } else {
 664                 tree.accept(this);
 665             }


 666             if (tree == breakTree &amp;&amp;
 667                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 668                 breakTreeFound(copyEnv(env));
 669             }
 670             return result;
 671         } catch (CompletionFailure ex) {
 672             tree.type = syms.errType;
 673             return chk.completionError(tree.pos(), ex);
 674         } finally {
 675             this.env = prevEnv;
 676             this.resultInfo = prevResult;
 677         }
 678     }
 679 
 680     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 681         throw new BreakAttr(env);
 682     }
 683 
 684     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 685         Env&lt;AttrContext&gt; newEnv =
</pre>
<hr />
<pre>
 716     }
 717 
 718     /** Derived visitor method: attribute a type tree.
 719      */
 720     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 721         Type result = attribType(tree, env, Type.noType);
 722         return result;
 723     }
 724 
 725     /** Derived visitor method: attribute a type tree.
 726      */
 727     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 728         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 729         return result;
 730     }
 731 
 732     /** Derived visitor method: attribute a statement or definition tree.
 733      */
 734     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 735         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
<span class="line-modified"> 736         try {</span>
<span class="line-modified"> 737             return attribTree(tree, env, statInfo);</span>
<span class="line-modified"> 738         } finally {</span>
<span class="line-removed"> 739             analyzer.analyzeIfNeeded(tree, analyzeEnv);</span>
<span class="line-removed"> 740         }</span>
 741     }
 742 
 743     /** Attribute a list of expressions, returning a list of types.
 744      */
 745     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 746         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 747         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 748             ts.append(attribExpr(l.head, env, pt));
 749         return ts.toList();
 750     }
 751 
 752     /** Attribute a list of statements, returning nothing.
 753      */
 754     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 755         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 756             attribStat(l.head, env);
 757     }
 758 
 759     /** Attribute the arguments in a method call, returning the method kind.
 760      */
</pre>
<hr />
<pre>
 914             return types.createErrorType(t);
 915         }
 916         if (checkExtensible &amp;&amp;
 917             ((t.tsym.flags() &amp; FINAL) != 0)) {
 918             log.error(pos,
 919                       Errors.CantInheritFromFinal(t.tsym));
 920         }
 921         chk.checkNonCyclic(pos, t);
 922         return t;
 923     }
 924 
 925     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 926         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 927         id.type = env.info.scope.owner.enclClass().type;
 928         id.sym = env.info.scope.owner.enclClass();
 929         return id.type;
 930     }
 931 
 932     public void visitClassDef(JCClassDecl tree) {
 933         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
<span class="line-modified"> 934                 Optional.ofNullable(env.info.isSpeculative ?</span>
 935                         argumentAttr.withLocalCacheContext() : null);
 936         try {
 937             // Local and anonymous classes have not been entered yet, so we need to
 938             // do it now.
 939             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 940                 enter.classEnter(tree, env);
 941             } else {
 942                 // If this class declaration is part of a class level annotation,
 943                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 944                 // order to simplify later steps and allow for sensible error
 945                 // messages.
 946                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 947                     enter.classEnter(tree, env);
 948             }
 949 
 950             ClassSymbol c = tree.sym;
 951             if (c == null) {
 952                 // exit in case something drastic went wrong during enter.
 953                 result = null;
 954             } else {
</pre>
<hr />
<pre>
1023 
1024             chk.checkVarargsMethodDecl(localEnv, tree);
1025 
1026             // Check that type parameters are well-formed.
1027             chk.validate(tree.typarams, localEnv);
1028 
1029             // Check that result type is well-formed.
1030             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1031                 chk.validate(tree.restype, localEnv);
1032 
1033             // Check that receiver type is well-formed.
1034             if (tree.recvparam != null) {
1035                 // Use a new environment to check the receiver parameter.
1036                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1037                 // Is there a better way?
1038                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1039                 attribType(tree.recvparam, newEnv);
1040                 chk.validate(tree.recvparam, newEnv);
1041             }
1042 









































































1043             // annotation method checks
1044             if ((owner.flags() &amp; ANNOTATION) != 0) {
1045                 // annotation method cannot have throws clause
1046                 if (tree.thrown.nonEmpty()) {
1047                     log.error(tree.thrown.head.pos(),
1048                               Errors.ThrowsNotAllowedInIntfAnnotation);
1049                 }
1050                 // annotation method cannot declare type-parameters
1051                 if (tree.typarams.nonEmpty()) {
1052                     log.error(tree.typarams.head.pos(),
1053                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1054                 }
1055                 // validate annotation method&#39;s return type (could be an annotation type)
1056                 chk.validateAnnotationType(tree.restype);
1057                 // ensure that annotation method does not clash with members of Object/Annotation
1058                 chk.validateAnnotationMethod(tree.pos(), m);
1059             }
1060 
1061             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1062                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
</pre>
<hr />
<pre>
1070                         log.error(tree.pos(),
1071                                   Errors.DefaultAllowedInIntfAnnotationMember);
1072                 }
1073                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1074                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1075             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1076                 if ((owner.flags() &amp; INTERFACE) != 0) {
1077                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1078                 } else {
1079                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1080                 }
1081             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1082                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1083             } else {
1084                 // Add an implicit super() call unless an explicit call to
1085                 // super(...) or this(...) is given
1086                 // or we are compiling class java.lang.Object.
1087                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1088                     JCBlock body = tree.body;
1089                     if (body.stats.isEmpty() ||
<span class="line-modified">1090                             !TreeInfo.isSelfCall(body.stats.head)) {</span>
<span class="line-modified">1091                         body.stats = body.stats.</span>
<span class="line-modified">1092                                 prepend(typeEnter.SuperCall(make.at(body.pos),</span>
<span class="line-modified">1093                                         List.nil(),</span>
<span class="line-removed">1094                                         List.nil(),</span>
<span class="line-removed">1095                                         false));</span>
1096                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1097                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1098                             TreeInfo.isSuperCall(body.stats.head)) {
1099                         // enum constructors are not allowed to call super
1100                         // directly, so make sure there aren&#39;t any super calls
1101                         // in enum constructors, except in the compiler
1102                         // generated one.
1103                         log.error(tree.body.stats.head.pos(),
1104                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1105                     }





















1106                 }
1107 
1108                 // Attribute all type annotations in the body
1109                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1110                 annotate.flush();
1111 
1112                 // Attribute method body.
1113                 attribStat(tree.body, localEnv);
1114             }
1115 
1116             localEnv.info.scope.leave();
1117             result = tree.type = m.type;
1118         } finally {
1119             chk.setLint(prevLint);
1120             chk.setMethod(prevMethod);
1121         }
1122     }
1123 
1124     public void visitVarDef(JCVariableDecl tree) {
1125         // Local variables have not been entered yet, so we need to do it now:
</pre>
<hr />
<pre>
1180                     // Attribute initializer in a new environment
1181                     // with the declared variable as owner.
1182                     // Check that initializer conforms to variable&#39;s declared type.
1183                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1184                     initEnv.info.lint = lint;
1185                     // In order to catch self-references, we set the variable&#39;s
1186                     // declaration position to maximal possible value, effectively
1187                     // marking the variable as undefined.
1188                     initEnv.info.enclVar = v;
1189                     attribExpr(tree.init, initEnv, v.type);
1190                     if (tree.isImplicitlyTyped()) {
1191                         //fixup local variable type
1192                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1193                     }
1194                 }
1195                 if (tree.isImplicitlyTyped()) {
1196                     setSyntheticVariableType(tree, v.type);
1197                 }
1198             }
1199             result = tree.type = v.type;





1200         }
1201         finally {
1202             chk.setLint(prevLint);
1203         }
1204     }
1205 









1206     Fragment canInferLocalVarType(JCVariableDecl tree) {
1207         LocalInitScanner lis = new LocalInitScanner();
1208         lis.scan(tree.init);
1209         return lis.badInferenceMsg;
1210     }
1211 
1212     static class LocalInitScanner extends TreeScanner {
1213         Fragment badInferenceMsg = null;
1214         boolean needsTarget = true;
1215 
1216         @Override
1217         public void visitNewArray(JCNewArray tree) {
1218             if (tree.elemtype == null &amp;&amp; needsTarget) {
1219                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1220             }
1221         }
1222 
1223         @Override
1224         public void visitLambda(JCLambda tree) {
1225             if (needsTarget) {
</pre>
<hr />
<pre>
1256             }
1257         }
1258 
1259         @Override
1260         public void visitApply(JCMethodInvocation tree) {
1261             boolean prevNeedsTarget = needsTarget;
1262             try {
1263                 needsTarget = false;
1264                 super.visitApply(tree);
1265             } finally {
1266                 needsTarget = prevNeedsTarget;
1267             }
1268         }
1269     }
1270 
1271     public void visitSkip(JCSkip tree) {
1272         result = null;
1273     }
1274 
1275     public void visitBlock(JCBlock tree) {
<span class="line-modified">1276         if (env.info.scope.owner.kind == TYP) {</span>
1277             // Block is a static or instance initializer;
1278             // let the owner of the environment be a freshly
1279             // created BLOCK-method.
1280             Symbol fakeOwner =
1281                 new MethodSymbol(tree.flags | BLOCK |
1282                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1283                     env.info.scope.owner);
1284             final Env&lt;AttrContext&gt; localEnv =
1285                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1286 
1287             if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
1288             // Attribute all type annotations in the block
1289             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1290             annotate.flush();
1291             attribStats(tree.stats, localEnv);
1292 
1293             {
1294                 // Store init and clinit type annotations with the ClassSymbol
1295                 // to allow output in Gen.normalizeDefs.
1296                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
</pre>
<hr />
<pre>
1300                 } else {
1301                     cs.appendInitTypeAttributes(tas);
1302                 }
1303             }
1304         } else {
1305             // Create a new local environment with a local scope.
1306             Env&lt;AttrContext&gt; localEnv =
1307                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1308             try {
1309                 attribStats(tree.stats, localEnv);
1310             } finally {
1311                 localEnv.info.scope.leave();
1312             }
1313         }
1314         result = null;
1315     }
1316 
1317     public void visitDoLoop(JCDoWhileLoop tree) {
1318         attribStat(tree.body, env.dup(tree));
1319         attribExpr(tree.cond, env, syms.booleanType);






1320         result = null;
1321     }
1322 
1323     public void visitWhileLoop(JCWhileLoop tree) {
1324         attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">1325         attribStat(tree.body, env.dup(tree));</span>












1326         result = null;
1327     }
1328 





1329     public void visitForLoop(JCForLoop tree) {
1330         Env&lt;AttrContext&gt; loopEnv =
1331             env.dup(env.tree, env.info.dup(env.info.scope.dup()));

1332         try {
1333             attribStats(tree.init, loopEnv);
<span class="line-modified">1334             if (tree.cond != null) attribExpr(tree.cond, loopEnv, syms.booleanType);</span>
<span class="line-modified">1335             loopEnv.tree = tree; // before, we were not in loop!</span>
<span class="line-modified">1336             attribStats(tree.step, loopEnv);</span>
<span class="line-modified">1337             attribStat(tree.body, loopEnv);</span>









1338             result = null;
1339         }
1340         finally {
1341             loopEnv.info.scope.leave();
1342         }





1343     }
1344 
1345     public void visitForeachLoop(JCEnhancedForLoop tree) {
1346         Env&lt;AttrContext&gt; loopEnv =
1347             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1348         try {
1349             //the Formal Parameter of a for-each loop is not in the scope when
<span class="line-modified">1350             //attributing the for-each expression; we mimick this by attributing</span>
1351             //the for-each expression first (against original scope).
1352             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1353             chk.checkNonVoid(tree.pos(), exprType);
1354             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1355             if (elemtype == null) {
1356                 // or perhaps expr implements Iterable&lt;T&gt;?
1357                 Type base = types.asSuper(exprType, syms.iterableType.tsym);
1358                 if (base == null) {
1359                     log.error(tree.expr.pos(),
1360                               Errors.ForeachNotApplicableToType(exprType,
1361                                                                 Fragments.TypeReqArrayOrIterable));
1362                     elemtype = types.createErrorType(exprType);
1363                 } else {
1364                     List&lt;Type&gt; iterableParams = base.allparams();
1365                     elemtype = iterableParams.isEmpty()
1366                         ? syms.objectType
1367                         : types.wildUpperBound(iterableParams.head);
1368                 }
1369             }
1370             if (tree.var.isImplicitlyTyped()) {
</pre>
<hr />
<pre>
1408 
1409     public void visitSwitchExpression(JCSwitchExpression tree) {
1410         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1411                 PolyKind.STANDALONE : PolyKind.POLY;
1412 
1413         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1414             //this means we are returning a poly conditional from void-compatible lambda expression
1415             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1416             result = tree.type = types.createErrorType(resultInfo.pt);
1417             return;
1418         }
1419 
1420         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1421                 unknownExprInfo :
1422                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1423 
1424         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1425         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1426 
1427         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
<span class="line-modified">1428             caseEnv.info.breakResult = condInfo;</span>
1429             attribStats(c.stats, caseEnv);
1430             new TreeScanner() {
1431                 @Override
<span class="line-modified">1432                 public void visitBreak(JCBreak brk) {</span>
1433                     if (brk.target == tree) {
1434                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1435                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1436                     }
<span class="line-modified">1437                     super.visitBreak(brk);</span>
1438                 }
1439 
1440                 @Override public void visitClassDef(JCClassDecl tree) {}
1441                 @Override public void visitLambda(JCLambda tree) {}
1442             }.scan(c.stats);
1443         });
1444 
1445         if (tree.cases.isEmpty()) {
1446             log.error(tree.pos(),
1447                       Errors.SwitchExpressionEmpty);



1448         }
1449 
1450         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1451 
1452         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1453     }
1454     //where:
1455         CheckContext switchExpressionContext(CheckContext checkContext) {
1456             return new Check.NestedCheckContext(checkContext) {
1457                 //this will use enclosing check context to check compatibility of
1458                 //subexpression against target type; if we are in a method check context,
1459                 //depending on whether boxing is allowed, we could have incompatibilities
1460                 @Override
1461                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1462                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1463                 }
1464             };
1465         }
1466 
1467     private void handleSwitch(JCTree switchTree,
1468                               JCExpression selector,
1469                               List&lt;JCCase&gt; cases,
1470                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1471         Type seltype = attribExpr(selector, env);
1472 
1473         Env&lt;AttrContext&gt; switchEnv =
1474             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1475 
1476         try {
1477             boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;
1478             boolean stringSwitch = types.isSameType(seltype, syms.stringType);
1479             if (!enumSwitch &amp;&amp; !stringSwitch)
1480                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1481 
1482             // Attribute all cases and
1483             // check that there are no duplicate case labels or default clauses.
1484             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1485             boolean hasDefault = false;      // Is there a default label?
<span class="line-modified">1486             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">1487             CaseKind caseKind = null;</span>
1488             boolean wasError = false;
1489             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1490                 JCCase c = l.head;
1491                 if (caseKind == null) {
1492                     caseKind = c.caseKind;
1493                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1494                     log.error(c.pos(),
1495                               Errors.SwitchMixingCaseTypes);
1496                     wasError = true;
1497                 }
1498                 if (c.getExpressions().nonEmpty()) {
1499                     for (JCExpression pat : c.getExpressions()) {
1500                         if (TreeInfo.isNull(pat)) {
1501                             log.error(pat.pos(),
1502                                       Errors.SwitchNullNotAllowed);
1503                         } else if (enumSwitch) {
1504                             Symbol sym = enumConstant(pat, seltype);
1505                             if (sym == null) {
1506                                 log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1507                             } else if (!labels.add(sym)) {
</pre>
<hr />
<pre>
1513                                 if (pattype.constValue() == null) {
1514                                     log.error(pat.pos(),
1515                                               (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));
1516                                 } else if (!labels.add(pattype.constValue())) {
1517                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1518                                 }
1519                             }
1520                         }
1521                     }
1522                 } else if (hasDefault) {
1523                     log.error(c.pos(), Errors.DuplicateDefaultLabel);
1524                 } else {
1525                     hasDefault = true;
1526                 }
1527                 Env&lt;AttrContext&gt; caseEnv =
1528                     switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
1529                 try {
1530                     attribCase.accept(c, caseEnv);
1531                 } finally {
1532                     caseEnv.info.scope.leave();
<span class="line-removed">1533                     addVars(c.stats, switchEnv.info.scope);</span>
1534                 }

1535             }
1536         } finally {
1537             switchEnv.info.scope.leave();
1538         }
1539     }
1540     // where
1541         /** Add any variables defined in stats to the switch scope. */
1542         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1543             for (;stats.nonEmpty(); stats = stats.tail) {
1544                 JCTree stat = stats.head;
1545                 if (stat.hasTag(VARDEF))
1546                     switchScope.enter(((JCVariableDecl) stat).sym);
1547             }
1548         }
1549     // where
1550     /** Return the selected enumeration constant symbol, or null. */
1551     private Symbol enumConstant(JCTree tree, Type enumType) {
1552         if (tree.hasTag(IDENT)) {
1553             JCIdent ident = (JCIdent)tree;
1554             Name name = ident.name;
</pre>
<hr />
<pre>
1656                         env,
1657                         types.skipTypeVars(resource, false),
1658                         names.close,
1659                         List.nil(),
1660                         List.nil());
1661             }
1662             finally {
1663                 log.popDiagnosticHandler(discardHandler);
1664             }
1665             if (close.kind == MTH &amp;&amp;
1666                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1667                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1668                     env.info.lint.isEnabled(LintCategory.TRY)) {
1669                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1670             }
1671         }
1672     }
1673 
1674     public void visitConditional(JCConditional tree) {
1675         Type condtype = attribExpr(tree.cond, env, syms.booleanType);

1676 
1677         tree.polyKind = (!allowPoly ||
1678                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1679                 isBooleanOrNumeric(env, tree)) ?
1680                 PolyKind.STANDALONE : PolyKind.POLY;
1681 
1682         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1683             //this means we are returning a poly conditional from void-compatible lambda expression
1684             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1685             result = tree.type = types.createErrorType(resultInfo.pt);
1686             return;
1687         }
1688 
1689         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1690                 unknownExprInfo :
1691                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1692 
<span class="line-modified">1693         Type truetype = attribTree(tree.truepart, env, condInfo);</span>
<span class="line-modified">1694         Type falsetype = attribTree(tree.falsepart, env, condInfo);</span>






















1695 
1696         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1697                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1698                          List.of(truetype, falsetype)) : pt();
1699         if (condtype.constValue() != null &amp;&amp;
1700                 truetype.constValue() != null &amp;&amp;
1701                 falsetype.constValue() != null &amp;&amp;
1702                 !owntype.hasTag(NONE)) {
1703             //constant folding
1704             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1705         }
1706         result = check(tree, owntype, KindSelector.VAL, resultInfo);

1707     }
1708     //where
1709         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1710             switch (tree.getTag()) {
1711                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1712                               ((JCLiteral)tree).typetag == BOOLEAN ||
1713                               ((JCLiteral)tree).typetag == BOT;
1714                 case LAMBDA: case REFERENCE: return false;
1715                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1716                 case CONDEXPR:
1717                     JCConditional condTree = (JCConditional)tree;
1718                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1719                             isBooleanOrNumeric(env, condTree.falsepart);
1720                 case APPLY:
1721                     JCMethodInvocation speculativeMethodTree =
1722                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1723                                     tree, env, unknownExprInfo,
1724                                     argumentAttr.withLocalCacheContext());
1725                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1726                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
</pre>
<hr />
<pre>
1829                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t))
1830                                  .collect(List.collector());
1831 
1832             // both are known to be reference types.  The result is
1833             // lub(thentype,elsetype). This cannot fail, as it will
1834             // always be possible to infer &quot;Object&quot; if nothing better.
1835             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
1836         }
1837 
1838     final static TypeTag[] primitiveTags = new TypeTag[]{
1839         BYTE,
1840         CHAR,
1841         SHORT,
1842         INT,
1843         LONG,
1844         FLOAT,
1845         DOUBLE,
1846         BOOLEAN,
1847     };
1848 






1849     public void visitIf(JCIf tree) {
1850         attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">1851         attribStat(tree.thenpart, env);</span>
<span class="line-modified">1852         if (tree.elsepart != null)</span>
<span class="line-modified">1853             attribStat(tree.elsepart, env);</span>




























1854         chk.checkEmptyIf(tree);












1855         result = null;
1856     }
1857 















1858     public void visitExec(JCExpressionStatement tree) {
1859         //a fresh environment is required for 292 inference to work properly ---
1860         //see Infer.instantiatePolymorphicSignatureInstance()
1861         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
1862         attribExpr(tree.expr, localEnv);
1863         result = null;
1864     }
1865 
1866     public void visitBreak(JCBreak tree) {
<span class="line-modified">1867         if (env.info.breakResult != null) {</span>
<span class="line-modified">1868             if (tree.value == null) {</span>
<span class="line-modified">1869                 tree.target = findJumpTarget(tree.pos(), tree.getTag(), null, env);</span>
<span class="line-modified">1870                 if (tree.target.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-modified">1871                     log.error(tree.pos(), Errors.BreakMissingValue);</span>
<span class="line-modified">1872                 }</span>
<span class="line-modified">1873             } else {</span>
<span class="line-modified">1874                 if (env.info.breakResult.pt.hasTag(VOID)) {</span>
<span class="line-removed">1875                     //can happen?</span>
<span class="line-removed">1876                     env.info.breakResult.checkContext.report(tree.value.pos(),</span>
<span class="line-removed">1877                               diags.fragment(Fragments.UnexpectedRetVal));</span>
<span class="line-removed">1878                 }</span>
<span class="line-removed">1879                 boolean attribute = true;</span>
<span class="line-removed">1880                 if (tree.value.hasTag(IDENT)) {</span>
<span class="line-removed">1881                     //disambiguate break &lt;LABEL&gt; and break &lt;ident-as-an-expression&gt;:</span>
<span class="line-removed">1882                     Name label = ((JCIdent) tree.value).name;</span>
<span class="line-removed">1883                     Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tree.getTag(), label, env);</span>
<span class="line-removed">1884 </span>
<span class="line-removed">1885                     if (jumpTarget.fst != null) {</span>
<span class="line-removed">1886                         JCTree speculative = deferredAttr.attribSpeculative(tree.value, env, unknownExprInfo);</span>
<span class="line-removed">1887                         if (!speculative.type.hasTag(ERROR)) {</span>
<span class="line-removed">1888                             log.error(tree.pos(), Errors.BreakAmbiguousTarget(label));</span>
<span class="line-removed">1889                             if (jumpTarget.snd == null) {</span>
<span class="line-removed">1890                                 tree.target = jumpTarget.fst;</span>
<span class="line-removed">1891                                 attribute = false;</span>
<span class="line-removed">1892                             } else {</span>
<span class="line-removed">1893                                 //nothing</span>
<span class="line-removed">1894                             }</span>
<span class="line-removed">1895                         } else {</span>
<span class="line-removed">1896                             if (jumpTarget.snd != null) {</span>
<span class="line-removed">1897                                 log.error(tree.pos(), jumpTarget.snd);</span>
<span class="line-removed">1898                             }</span>
<span class="line-removed">1899                             tree.target = jumpTarget.fst;</span>
<span class="line-removed">1900                             attribute = false;</span>
<span class="line-removed">1901                         }</span>
<span class="line-removed">1902                     }</span>
<span class="line-removed">1903                 }</span>
<span class="line-removed">1904                 if (attribute) {</span>
<span class="line-removed">1905                     attribTree(tree.value, env, env.info.breakResult);</span>
<span class="line-removed">1906                     JCTree immediateTarget = findJumpTarget(tree.pos(), tree.getTag(), null, env);</span>
<span class="line-removed">1907                     if (immediateTarget.getTag() != SWITCH_EXPRESSION) {</span>
<span class="line-removed">1908                         log.error(tree.pos(), Errors.BreakExprNotImmediate(immediateTarget.getTag()));</span>
<span class="line-removed">1909                         Env&lt;AttrContext&gt; env1 = env;</span>
<span class="line-removed">1910                         while (env1 != null &amp;&amp; env1.tree.getTag() != SWITCH_EXPRESSION) {</span>
<span class="line-removed">1911                             env1 = env1.next;</span>
<span class="line-removed">1912                         }</span>
<span class="line-removed">1913                         Assert.checkNonNull(env1);</span>
<span class="line-removed">1914                         tree.target = env1.tree;</span>
<span class="line-removed">1915                     } else {</span>
<span class="line-removed">1916                         tree.target = immediateTarget;</span>
<span class="line-removed">1917                     }</span>
<span class="line-removed">1918                 }</span>
<span class="line-removed">1919             }</span>
1920         } else {
<span class="line-modified">1921             if (tree.value == null || tree.value.hasTag(IDENT)) {</span>
<span class="line-modified">1922                 Name label = tree.value != null ? ((JCIdent) tree.value).name : null;</span>
<span class="line-modified">1923                 tree.target = findJumpTarget(tree.pos(), tree.getTag(), label, env);</span>
<span class="line-modified">1924             } else {</span>
<span class="line-removed">1925                 log.error(tree.pos(), Errors.BreakComplexValueNoSwitchExpression);</span>
<span class="line-removed">1926                 attribTree(tree.value, env, unknownExprInfo);</span>
<span class="line-removed">1927             }</span>
1928         }
1929         result = null;
1930     }
1931 
1932     public void visitContinue(JCContinue tree) {
1933         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
1934         result = null;
1935     }
1936     //where
<span class="line-modified">1937         /** Return the target of a break or continue statement, if it exists,</span>
<span class="line-modified">1938          *  report an error if not.</span>
1939          *  Note: The target of a labelled break or continue is the
1940          *  (non-labelled) statement tree referred to by the label,
1941          *  not the tree representing the labelled statement itself.
1942          *
1943          *  @param pos     The position to be used for error diagnostics
1944          *  @param tag     The tag of the jump statement. This is either
1945          *                 Tree.BREAK or Tree.CONTINUE.
1946          *  @param label   The label of the jump statement, or null if no
1947          *                 label is given.
1948          *  @param env     The environment current at the jump statement.
1949          */
1950         private JCTree findJumpTarget(DiagnosticPosition pos,
1951                                                    JCTree.Tag tag,
1952                                                    Name label,
1953                                                    Env&lt;AttrContext&gt; env) {
1954             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
1955 
1956             if (jumpTarget.snd != null) {
1957                 log.error(pos, jumpTarget.snd);
1958             }
</pre>
<hr />
<pre>
1992                                     pendingError = Errors.NotLoopLabel(label);
1993                                 }
1994                                 // Found labelled statement target, now go inwards
1995                                 // to next non-labelled tree.
1996                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
1997                             } else {
1998                                 return Pair.of(labelled, pendingError);
1999                             }
2000                         }
2001                         break;
2002                     case DOLOOP:
2003                     case WHILELOOP:
2004                     case FORLOOP:
2005                     case FOREACHLOOP:
2006                         if (label == null) return Pair.of(env1.tree, pendingError);
2007                         break;
2008                     case SWITCH:
2009                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2010                         break;
2011                     case SWITCH_EXPRESSION:
<span class="line-modified">2012                         if (tag == BREAK) {</span>
<span class="line-modified">2013                             if (label == null) {</span>
<span class="line-modified">2014                                 return Pair.of(env1.tree, null);</span>
<span class="line-modified">2015                             } else {</span>
<span class="line-removed">2016                                 pendingError = Errors.BreakOutsideSwitchExpression;</span>
<span class="line-removed">2017                             }</span>
2018                         } else {
2019                             pendingError = Errors.ContinueOutsideSwitchExpression;
2020                         }
2021                         break;
2022                     case LAMBDA:
2023                     case METHODDEF:
2024                     case CLASSDEF:
2025                         break LOOP;
2026                     default:
2027                 }
2028                 env1 = env1.next;
2029             }
2030             if (label != null)
2031                 return Pair.of(null, Errors.UndefLabel(label));


2032             else if (tag == CONTINUE)
2033                 return Pair.of(null, Errors.ContOutsideLoop);
2034             else
2035                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2036         }
2037 
2038     public void visitReturn(JCReturn tree) {
2039         // Check that there is an enclosing method which is
2040         // nested within than the enclosing class.
2041         if (env.info.returnResult == null) {
2042             log.error(tree.pos(), Errors.RetOutsideMeth);
<span class="line-modified">2043         } else if (env.info.breakResult != null) {</span>
2044             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);






2045         } else {
2046             // Attribute return expression, if it exists, and check that
2047             // it conforms to result type of enclosing method.
2048             if (tree.expr != null) {
2049                 if (env.info.returnResult.pt.hasTag(VOID)) {
2050                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2051                               diags.fragment(Fragments.UnexpectedRetVal));
2052                 }
2053                 attribTree(tree.expr, env, env.info.returnResult);
2054             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2055                     !env.info.returnResult.pt.hasTag(NONE)) {
2056                 env.info.returnResult.checkContext.report(tree.pos(),
2057                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2058             }
2059         }
2060         result = null;
2061     }
2062 
2063     public void visitThrow(JCThrow tree) {
2064         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
</pre>
<hr />
<pre>
2083     public void visitApply(JCMethodInvocation tree) {
2084         // The local environment of a method application is
2085         // a new environment nested in the current one.
2086         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2087 
2088         // The types of the actual method arguments.
2089         List&lt;Type&gt; argtypes;
2090 
2091         // The types of the actual method type arguments.
2092         List&lt;Type&gt; typeargtypes = null;
2093 
2094         Name methName = TreeInfo.name(tree.meth);
2095 
2096         boolean isConstructorCall =
2097             methName == names._this || methName == names._super;
2098 
2099         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2100         if (isConstructorCall) {
2101             // We are seeing a ...this(...) or ...super(...) call.
2102             // Check that this is the first statement in a constructor.
<span class="line-modified">2103             if (checkFirstConstructorStat(tree, env)) {</span>
2104 
2105                 // Record the fact
2106                 // that this is a constructor call (using isSelfCall).
2107                 localEnv.info.isSelfCall = true;
2108 
2109                 // Attribute arguments, yielding list of argument types.
2110                 KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2111                 argtypes = argtypesBuf.toList();
2112                 typeargtypes = attribTypes(tree.typeargs, localEnv);
2113 
2114                 // Variable `site&#39; points to the class in which the called
2115                 // constructor is defined.
2116                 Type site = env.enclClass.sym.type;
2117                 if (methName == names._super) {
2118                     if (site == syms.objectType) {
2119                         log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2120                         site = types.createErrorType(syms.objectType);
2121                     } else {
2122                         site = types.supertype(site);
2123                     }
</pre>
<hr />
<pre>
2222                 return new ClassType(restype.getEnclosingType(),
2223                         List.of(new WildcardType(types.erasure(qualifierType),
2224                                 BoundKind.EXTENDS,
2225                                 syms.boundClass)),
2226                         restype.tsym,
2227                         restype.getMetadata());
2228             } else if (msym != null &amp;&amp;
2229                     msym.owner == syms.arrayClass &amp;&amp;
2230                     methodName == names.clone &amp;&amp;
2231                     types.isArray(qualifierType)) {
2232                 // as a special case, array.clone() has a result that is
2233                 // the same as static type of the array being cloned
2234                 return qualifierType;
2235             } else {
2236                 return restype;
2237             }
2238         }
2239 
2240         /** Check that given application node appears as first statement
2241          *  in a constructor call.
<span class="line-modified">2242          *  @param tree   The application node</span>
<span class="line-modified">2243          *  @param env    The environment current at the application.</span>

2244          */
<span class="line-modified">2245         boolean checkFirstConstructorStat(JCMethodInvocation tree, Env&lt;AttrContext&gt; env) {</span>
<span class="line-removed">2246             JCMethodDecl enclMethod = env.enclMethod;</span>
2247             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2248                 JCBlock body = enclMethod.body;
2249                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2250                     ((JCExpressionStatement) body.stats.head).expr == tree)
2251                     return true;
2252             }
<span class="line-modified">2253             log.error(tree.pos(),</span>
<span class="line-modified">2254                       Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));</span>


2255             return false;
2256         }
2257 
2258         /** Obtain a method type with given argument types.
2259          */
2260         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2261             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2262             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2263         }
2264 
2265     public void visitNewClass(final JCNewClass tree) {
2266         Type owntype = types.createErrorType(tree.type);
2267 
2268         // The local environment of a class creation is
2269         // a new environment nested in the current one.
2270         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2271 
2272         // The anonymous inner class definition of the new expression,
2273         // if one is defined by it.
2274         JCClassDecl cdef = tree.def;
</pre>
<hr />
<pre>
2687      * is &#39;stuck&#39; (see DeferredAttr).
2688      */
2689     @Override
2690     public void visitLambda(final JCLambda that) {
2691         boolean wrongContext = false;
2692         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
2693             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2694                 //lambda only allowed in assignment or method invocation/cast context
2695                 log.error(that.pos(), Errors.UnexpectedLambda);
2696             }
2697             resultInfo = recoveryInfo;
2698             wrongContext = true;
2699         }
2700         //create an environment for attribution of the lambda expression
2701         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
2702         boolean needsRecovery =
2703                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
2704         try {
2705             if (needsRecovery &amp;&amp; isSerializable(pt())) {
2706                 localEnv.info.isSerializable = true;
<span class="line-modified">2707                 localEnv.info.isLambda = true;</span>
2708             }

2709             List&lt;Type&gt; explicitParamTypes = null;
2710             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
2711                 //attribute lambda parameters
2712                 attribStats(that.params, localEnv);
2713                 explicitParamTypes = TreeInfo.types(that.params);
2714             }
2715 
2716             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
2717             Type currentTarget = targetInfo.target;
2718             Type lambdaType = targetInfo.descriptor;
2719 
2720             if (currentTarget.isErroneous()) {
2721                 result = that.type = currentTarget;
2722                 return;
2723             }
2724 
2725             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
2726 
2727             if (lambdaType.hasTag(FORALL)) {
2728                 //lambda expression target desc cannot be a generic method
</pre>
<hr />
<pre>
2802             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
2803 
2804             if (!isSpeculativeRound) {
2805                 //add thrown types as bounds to the thrown types free variables if needed:
2806                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
2807                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
2808                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
2809                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
2810                     }
2811                 }
2812 
2813                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
2814             }
2815             result = wrongContext ? that.type = types.createErrorType(pt())
2816                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
2817         } catch (Types.FunctionDescriptorLookupError ex) {
2818             JCDiagnostic cause = ex.getDiagnostic();
2819             resultInfo.checkContext.report(that, cause);
2820             result = that.type = types.createErrorType(pt());
2821             return;


2822         } catch (Throwable t) {
2823             //when an unexpected exception happens, avoid attempts to attribute the same tree again
2824             //as that would likely cause the same exception again.
2825             needsRecovery = false;
2826             throw t;
2827         } finally {
2828             localEnv.info.scope.leave();
2829             if (needsRecovery) {
2830                 attribTree(that, env, recoveryInfo);
2831             }
2832         }
2833     }
2834     //where
2835         class TargetInfo {
2836             Type target;
2837             Type descriptor;
2838 
2839             public TargetInfo(Type target, Type descriptor) {
2840                 this.target = target;
2841                 this.descriptor = descriptor;
</pre>
<hr />
<pre>
2897             new PostAttrAnalyzer() {
2898                 @Override
2899                 public void scan(JCTree tree) {
2900                     if (tree == null ||
2901                             (tree.type != null &amp;&amp;
2902                             tree.type == Type.stuckType)) {
2903                         //don&#39;t touch stuck expressions!
2904                         return;
2905                     }
2906                     super.scan(tree);
2907                 }
2908 
2909                 @Override
2910                 public void visitClassDef(JCClassDecl that) {
2911                     // or class declaration trees!
2912                 }
2913 
2914                 public void visitLambda(JCLambda that) {
2915                     // or lambda expressions!
2916                 }
<span class="line-modified">2917             }.scan(tree);</span>
2918         }
2919 
2920         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
2921 
2922             @Override
2923             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
2924                 return t.isIntersection() ?
2925                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
2926             }
2927 
2928             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
2929                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
2930                 return ict;
2931             }
2932 
2933             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
2934                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
2935                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
2936                 for (Type i : ict.interfaces_field) {
2937                     if (i.isParameterized()) {
</pre>
<hr />
<pre>
3119                     }
3120                 } else {
3121                     /* if the field is static then we need to create a fake clinit
3122                      * method, this method can later be reused by LTM.
3123                      */
3124                     MethodSymbol clinit = clinits.get(enclClass);
3125                     if (clinit == null) {
3126                         Type clinitType = new MethodType(List.nil(),
3127                                 syms.voidType, List.nil(), syms.methodClass);
3128                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3129                                 names.clinit, clinitType, enclClass);
3130                         clinit.params = List.nil();
3131                         clinits.put(enclClass, clinit);
3132                     }
3133                     newScopeOwner = clinit;
3134                 }
3135                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3136             } else {
3137                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3138             }
<span class="line-modified">3139             lambdaEnv.info.breakResult = null;</span>
3140             return lambdaEnv;
3141         }
3142 
3143     @Override
3144     public void visitReference(final JCMemberReference that) {
3145         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3146             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3147                 //method reference only allowed in assignment or method invocation/cast context
3148                 log.error(that.pos(), Errors.UnexpectedMref);
3149             }
3150             result = that.type = types.createErrorType(pt());
3151             return;
3152         }
3153         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3154         try {
3155             //attribute member reference qualifier - if this is a constructor
3156             //reference, the expected kind must be a type
3157             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3158 
3159             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
</pre>
<hr />
<pre>
3258                     if (targetError) {
3259                         resultInfo.checkContext.report(that, diag);
3260                     } else {
3261                         log.report(diag);
3262                     }
3263                     result = that.type = types.createErrorType(currentTarget);
3264                     return;
3265                 }
3266             }
3267 
3268             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3269             that.kind = lookupHelper.referenceKind(that.sym);
3270             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3271 
3272             if (desc.getReturnType() == Type.recoveryType) {
3273                 // stop here
3274                 result = that.type = currentTarget;
3275                 return;
3276             }
3277 
<span class="line-modified">3278             if (!env.info.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {</span>
3279                 Type enclosingType = exprType.getEnclosingType();
3280                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
<span class="line-modified">3281                     // Check for the existence of an apropriate outer instance</span>
3282                     rs.resolveImplicitThis(that.pos(), env, exprType);
3283                 }
3284             }
3285 
3286             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3287 
3288                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3289                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3290                         that.kind.isUnbound() &amp;&amp;
3291                         lookupHelper.site.isRaw()) {
3292                     chk.checkRaw(that.expr, localEnv);
3293                 }
3294 
3295                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3296                         exprType.getTypeArguments().nonEmpty()) {
3297                     //static ref with class type-args
3298                     log.error(that.expr.pos(),
3299                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3300                                                  Fragments.StaticMrefWithTargs));
3301                     result = that.type = types.createErrorType(currentTarget);
</pre>
<hr />
<pre>
3562 
3563         // Find operator.
3564         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3565         Type owntype = types.createErrorType(tree.type);
3566         if (operator != operators.noOpSymbol &amp;&amp;
3567                 !argtype.isErroneous()) {
3568             owntype = (tree.getTag().isIncOrDecUnaryOp())
3569                 ? tree.arg.type
3570                 : operator.type.getReturnType();
3571             int opc = ((OperatorSymbol)operator).opcode;
3572 
3573             // If the argument is constant, fold it.
3574             if (argtype.constValue() != null) {
3575                 Type ctype = cfolder.fold1(opc, argtype);
3576                 if (ctype != null) {
3577                     owntype = cfolder.coerce(ctype, owntype);
3578                 }
3579             }
3580         }
3581         result = check(tree, owntype, KindSelector.VAL, resultInfo);

3582     }
3583 
3584     public void visitBinary(JCBinary tree) {
3585         // Attribute arguments.
3586         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
<span class="line-modified">3587         Type right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, env));</span>




























3588         // Find operator.
3589         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3590         Type owntype = types.createErrorType(tree.type);
3591         if (operator != operators.noOpSymbol &amp;&amp;
3592                 !left.isErroneous() &amp;&amp;
3593                 !right.isErroneous()) {
3594             owntype = operator.type.getReturnType();
3595             int opc = ((OperatorSymbol)operator).opcode;
3596             // If both arguments are constants, fold them.
3597             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3598                 Type ctype = cfolder.fold2(opc, left, right);
3599                 if (ctype != null) {
3600                     owntype = cfolder.coerce(ctype, owntype);
3601                 }
3602             }
3603 
3604             // Check that argument types of a reference ==, != are
3605             // castable to each other, (JLS 15.21).  Note: unboxing
3606             // comparisons will not have an acmp* opc at this point.
3607             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
</pre>
<hr />
<pre>
3633                 public boolean compatible(Type found, Type req, Warner warn) {
3634                     return types.isCastable(found, req, warn);
3635                 }
3636             });
3637         } else {
3638             //standalone cast - target-type info is not propagated
3639             castInfo = unknownExprInfo;
3640         }
3641         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
3642         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3643         if (exprtype.constValue() != null)
3644             owntype = cfolder.coerce(exprtype, owntype);
3645         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
3646         if (!isPoly)
3647             chk.checkRedundantCast(localEnv, tree);
3648     }
3649 
3650     public void visitTypeTest(JCInstanceOf tree) {
3651         Type exprtype = chk.checkNullOrRefType(
3652                 tree.expr.pos(), attribExpr(tree.expr, env));
<span class="line-modified">3653         Type clazztype = attribType(tree.clazz, env);</span>













3654         if (!clazztype.hasTag(TYPEVAR)) {
<span class="line-modified">3655             clazztype = chk.checkClassOrArrayType(tree.clazz.pos(), clazztype);</span>
3656         }
3657         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
<span class="line-modified">3658             log.error(tree.clazz.pos(), Errors.IllegalGenericTypeForInstof);</span>
<span class="line-modified">3659             clazztype = types.createErrorType(clazztype);</span>



















3660         }
<span class="line-modified">3661         chk.validate(tree.clazz, env, false);</span>
3662         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3663         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
3664     }
3665 













3666     public void visitIndexed(JCArrayAccess tree) {
3667         Type owntype = types.createErrorType(tree.type);
3668         Type atype = attribExpr(tree.indexed, env);
3669         attribExpr(tree.index, env, syms.intType);
3670         if (types.isArray(atype))
3671             owntype = types.elemtype(atype);
3672         else if (!atype.hasTag(ERROR))
3673             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
3674         if (!pkind().contains(KindSelector.VAL))
3675             owntype = capture(owntype);
3676         result = check(tree, owntype, KindSelector.VAR, resultInfo);
3677     }
3678 
3679     public void visitIdent(JCIdent tree) {
3680         Symbol sym;
3681 
3682         // Find symbol
3683         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
3684             // If we are looking for a method, the prototype `pt&#39; will be a
3685             // method type with the type of the call&#39;s arguments as parameters.
</pre>
<hr />
<pre>
3733         // if symbol is a field or instance method, check that it is
3734         // not accessed before the supertype constructor is called.
3735         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
3736             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
3737             sym.owner.kind == TYP &amp;&amp;
3738             (sym.flags() &amp; STATIC) == 0) {
3739             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
3740                                           sym : thisSym(tree.pos(), env));
3741         }
3742         Env&lt;AttrContext&gt; env1 = env;
3743         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
3744             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
3745             // If the found symbol is inaccessible, then it is
3746             // accessed through an enclosing instance.  Locate this
3747             // enclosing instance:
3748             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
3749                 env1 = env1.outer;
3750         }
3751 
3752         if (env.info.isSerializable) {
<span class="line-modified">3753             chk.checkAccessFromSerializableElement(tree, env.info.isLambda);</span>
3754         }
3755 
3756         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
3757     }
3758 
3759     public void visitSelect(JCFieldAccess tree) {
3760         // Determine the expected kind of the qualifier expression.
3761         KindSelector skind = KindSelector.NIL;
3762         if (tree.name == names._this || tree.name == names._super ||
3763                 tree.name == names._class)
3764         {
3765             skind = KindSelector.TYP;
3766         } else {
3767             if (pkind().contains(KindSelector.PCK))
3768                 skind = KindSelector.of(skind, KindSelector.PCK);
3769             if (pkind().contains(KindSelector.TYP))
3770                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
3771             if (pkind().contains(KindSelector.VAL_MTH))
3772                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
3773         }
</pre>
<hr />
<pre>
3875                    sym.name != names._class) {
3876             // If the qualified item is not a type and the selected item is static, report
3877             // a warning. Make allowance for the class of an array type e.g. Object[].class)
3878             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
3879         }
3880 
3881         // If we are selecting an instance member via a `super&#39;, ...
3882         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
3883 
3884             // Check that super-qualified symbols are not abstract (JLS)
3885             rs.checkNonAbstract(tree.pos(), sym);
3886 
3887             if (site.isRaw()) {
3888                 // Determine argument types for site.
3889                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
3890                 if (site1 != null) site = site1;
3891             }
3892         }
3893 
3894         if (env.info.isSerializable) {
<span class="line-modified">3895             chk.checkAccessFromSerializableElement(tree, env.info.isLambda);</span>
3896         }
3897 
3898         env.info.selectSuper = selectSuperPrev;
3899         result = checkId(tree, site, sym, env, resultInfo);
3900     }
3901     //where
3902         /** Determine symbol referenced by a Select expression,
3903          *
3904          *  @param tree   The select tree.
3905          *  @param site   The type of the selected expression,
3906          *  @param env    The current environment.
3907          *  @param resultInfo The current result.
3908          */
3909         private Symbol selectSym(JCFieldAccess tree,
3910                                  Symbol location,
3911                                  Type site,
3912                                  Env&lt;AttrContext&gt; env,
3913                                  ResultInfo resultInfo) {
3914             DiagnosticPosition pos = tree.pos();
3915             Name name = tree.name;
3916             switch (site.getTag()) {
3917             case PACKAGE:
3918                 return rs.accessBase(
<span class="line-modified">3919                     rs.findIdentInPackage(env, site.tsym, name, resultInfo.pkind),</span>
3920                     pos, location, site, name, true);
3921             case ARRAY:
3922             case CLASS:
3923                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
3924                     return rs.resolveQualifiedMethod(
3925                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
3926                 } else if (name == names._this || name == names._super) {
3927                     return rs.resolveSelf(pos, env, site.tsym, name);
3928                 } else if (name == names._class) {
3929                     // In this case, we have already made sure in
3930                     // visitSelect that qualifier expression is a type.
3931                     return syms.getClassField(site, types);
3932                 } else {
3933                     // We are seeing a plain identifier as selector.
<span class="line-modified">3934                     Symbol sym = rs.findIdentInType(env, site, name, resultInfo.pkind);</span>
3935                         sym = rs.accessBase(sym, pos, location, site, name, true);
3936                     return sym;
3937                 }
3938             case WILDCARD:
3939                 throw new AssertionError(tree);
3940             case TYPEVAR:
3941                 // Normally, site.getUpperBound() shouldn&#39;t be null.
3942                 // It should only happen during memberEnter/attribBase
<span class="line-modified">3943                 // when determining the super type which *must* beac</span>
3944                 // done before attributing the type variables.  In
3945                 // other words, we are seeing this illegal program:
3946                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
3947                 Symbol sym = (site.getUpperBound() != null)
3948                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
3949                     : null;
3950                 if (sym == null) {
3951                     log.error(pos, Errors.TypeVarCantBeDeref);
3952                     return syms.errSymbol;
3953                 } else {
3954                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
3955                         rs.new AccessError(env, site, sym) :
3956                                 sym;
3957                     rs.accessBase(sym2, pos, location, site, name, true);
3958                     return sym;
3959                 }
3960             case ERROR:
3961                 // preserve identifier names through errors
3962                 return types.createErrorType(name, site.tsym, site).tsym;
3963             default:
</pre>
<hr />
<pre>
4118                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4119                         resultInfo.pt.getTypeArguments());
4120                 break;
4121             }
4122             case PCK: case ERR:
4123                 owntype = sym.type;
4124                 break;
4125             default:
4126                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4127                                          &quot; in tree &quot; + tree);
4128             }
4129 
4130             // Emit a `deprecation&#39; warning if symbol is deprecated.
4131             // (for constructors (but not for constructor references), the error
4132             // was given when the constructor was resolved)
4133 
4134             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4135                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4136                 chk.checkSunAPI(tree.pos(), sym);
4137                 chk.checkProfile(tree.pos(), sym);

4138             }
4139 
4140             // If symbol is a variable, check that its type and
4141             // kind are compatible with the prototype and protokind.
4142             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4143         }
4144 
4145         /** Check that variable is initialized and evaluate the variable&#39;s
4146          *  initializer, if not yet done. Also check that variable is not
4147          *  referenced before it is defined.
4148          *  @param tree    The tree making up the variable reference.
4149          *  @param env     The current environment.
4150          *  @param v       The variable&#39;s symbol.
4151          */
4152         private void checkInit(JCTree tree,
4153                                Env&lt;AttrContext&gt; env,
4154                                VarSymbol v,
4155                                boolean onlyWarning) {
4156             // A forward reference is diagnosed if the declaration position
4157             // of the variable is greater than the current tree position
</pre>
<hr />
<pre>
4205                         }
4206                         break;
4207                     case METHODDEF:
4208                     case CLASSDEF:
4209                     case TOPLEVEL:
4210                         return null;
4211                 }
4212                 Assert.checkNonNull(env.next);
4213                 env = env.next;
4214             }
4215         }
4216 
4217         /**
4218          * Check for illegal references to static members of enum.  In
4219          * an enum type, constructors and initializers may not
4220          * reference its static members unless they are constant.
4221          *
4222          * @param tree    The tree making up the variable reference.
4223          * @param env     The current environment.
4224          * @param v       The variable&#39;s symbol.
<span class="line-modified">4225          * @jls  section 8.9 Enums</span>
4226          */
4227         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4228             // JLS:
4229             //
4230             // &quot;It is a compile-time error to reference a static field
4231             // of an enum type that is not a compile-time constant
4232             // (15.28) from constructors, instance initializer blocks,
4233             // or instance variable initializer expressions of that
4234             // type. It is a compile-time error for the constructors,
4235             // instance initializer blocks, or instance variable
4236             // initializer expressions of an enum constant e to refer
4237             // to itself or to an enum constant of the same type that
4238             // is declared to the right of e.&quot;
4239             if (isStaticEnumField(v)) {
4240                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4241 
4242                 if (enclClass == null || enclClass.owner == null)
4243                     return;
4244 
4245                 // See if the enclosing class is the enum (or a
</pre>
<hr />
<pre>
4895                     sym.kind != VAR ||
4896                     ((VarSymbol) sym).getConstValue() == null)
4897                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
4898             }
4899         }
4900 
4901         // Check for cycles among non-initial constructors.
4902         chk.checkCyclicConstructors(tree);
4903 
4904         // Check for cycles among annotation elements.
4905         chk.checkNonCyclicElements(tree);
4906 
4907         // Check for proper use of serialVersionUID
4908         if (env.info.lint.isEnabled(LintCategory.SERIAL)
4909                 &amp;&amp; isSerializable(c.type)
4910                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
4911                 &amp;&amp; !c.isAnonymous()) {
4912             checkSerialVersionUID(tree, c);
4913         }
4914         if (allowTypeAnnos) {
<span class="line-modified">4915             // Correctly organize the postions of the type annotations</span>
4916             typeAnnotations.organizeTypeAnnotationsBodies(tree);
4917 
4918             // Check type annotations applicability rules
4919             validateTypeAnnotations(tree, false);
4920         }
4921     }
4922         // where
4923         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
4924         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
4925             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
4926                 if (types.isSameType(al.head.annotationType.type, t))
4927                     return al.head.pos();
4928             }
4929 
4930             return null;
4931         }
4932 
4933         /** check if a type is a subtype of Serializable, if that is available. */
4934         boolean isSerializable(Type t) {
4935             try {
</pre>
<hr />
<pre>
5036                 scan(tree.defaultValue);
5037                 scan(tree.body);
5038             }
5039         }
5040         public void visitVarDef(final JCVariableDecl tree) {
5041             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5042             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5043                 validateAnnotatedType(tree.vartype, tree.sym.type);
5044             scan(tree.mods);
5045             scan(tree.vartype);
5046             if (!sigOnly) {
5047                 scan(tree.init);
5048             }
5049         }
5050         public void visitTypeCast(JCTypeCast tree) {
5051             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5052                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5053             super.visitTypeCast(tree);
5054         }
5055         public void visitTypeTest(JCInstanceOf tree) {
<span class="line-modified">5056             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)</span>
<span class="line-modified">5057                 validateAnnotatedType(tree.clazz, tree.clazz.type);</span>
5058             super.visitTypeTest(tree);
5059         }
5060         public void visitNewClass(JCNewClass tree) {
5061             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5062                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5063                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5064                             tree.clazz.type.tsym);
5065                 }
5066                 if (tree.def != null) {
5067                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5068                 }
5069 
5070                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5071             }
5072             super.visitNewClass(tree);
5073         }
5074         public void visitNewArray(JCNewArray tree) {
5075             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5076                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5077                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
</pre>
<hr />
<pre>
5205             // Ensure that no declaration annotations are present.
5206             // Note that a tree type might be an AnnotatedType with
5207             // empty annotations, if only declaration annotations were given.
5208             // This method will raise an error for such a type.
5209             for (JCAnnotation ai : annotations) {
5210                 if (!ai.type.isErroneous() &amp;&amp;
5211                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5212                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5213                 }
5214             }
5215         }
5216     }
5217 
5218     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5219 
5220     /**
5221      * Handle missing types/symbols in an AST. This routine is useful when
5222      * the compiler has encountered some errors (which might have ended up
5223      * terminating attribution abruptly); if the compiler is used in fail-over
5224      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
<span class="line-modified">5225      * prevents NPE to be progagated during subsequent compilation steps.</span>
5226      */
5227     public void postAttr(JCTree tree) {
5228         new PostAttrAnalyzer().scan(tree);
5229     }
5230 
5231     class PostAttrAnalyzer extends TreeScanner {
5232 
5233         private void initTypeIfNeeded(JCTree that) {
5234             if (that.type == null) {
5235                 if (that.hasTag(METHODDEF)) {
5236                     that.type = dummyMethodType((JCMethodDecl)that);
5237                 } else {
5238                     that.type = syms.unknownType;
5239                 }
5240             }
5241         }
5242 
5243         /* Construct a dummy method type. If we have a method declaration,
5244          * and the declared return type is void, then use that return type
5245          * instead of UNKNOWN to avoid spurious error messages in lambda
</pre>
<hr />
<pre>
5297             initTypeIfNeeded(that);
5298             if (that.sym == null) {
5299                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5300             }
5301             super.visitMethodDef(that);
5302         }
5303 
5304         @Override
5305         public void visitVarDef(JCVariableDecl that) {
5306             initTypeIfNeeded(that);
5307             if (that.sym == null) {
5308                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5309                 that.sym.adr = 0;
5310             }
5311             if (that.vartype == null) {
5312                 that.vartype = make.at(Position.NOPOS).Erroneous();
5313             }
5314             super.visitVarDef(that);
5315         }
5316 









5317         @Override
5318         public void visitNewClass(JCNewClass that) {
5319             if (that.constructor == null) {
5320                 that.constructor = new MethodSymbol(0, names.init,
5321                         dummyMethodType(), syms.noSymbol);
5322             }
5323             if (that.constructorType == null) {
5324                 that.constructorType = syms.unknownType;
5325             }
5326             super.visitNewClass(that);
5327         }
5328 
5329         @Override
5330         public void visitAssignop(JCAssignOp that) {
5331             if (that.operator == null) {
5332                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5333                         -1, syms.noSymbol);
5334             }
5335             super.visitAssignop(that);
5336         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
  30 import java.util.stream.Collectors;
  31 
  32 import javax.lang.model.element.ElementKind;
  33 import javax.tools.JavaFileObject;
  34 
<span class="line-modified">  35 import com.sun.source.tree.CaseTree;</span>
  36 import com.sun.source.tree.IdentifierTree;
  37 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  38 import com.sun.source.tree.MemberSelectTree;
  39 import com.sun.source.tree.TreeVisitor;
  40 import com.sun.source.util.SimpleTreeVisitor;
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Lint.LintCategory;
  43 import com.sun.tools.javac.code.Scope.WriteableScope;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Type.*;
  47 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  48 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  49 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  50 import com.sun.tools.javac.comp.Check.CheckContext;
  51 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
<span class="line-added">  52 import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;</span>
  53 import com.sun.tools.javac.jvm.*;
  54 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  55 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  56 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  57 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  58 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  59 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  60 import com.sun.tools.javac.tree.*;
  61 import com.sun.tools.javac.tree.JCTree.*;
  62 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  63 import com.sun.tools.javac.util.*;
  64 import com.sun.tools.javac.util.DefinedBy.Api;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  66 import com.sun.tools.javac.util.JCDiagnostic.Error;
  67 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  68 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  69 import com.sun.tools.javac.util.List;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  73 import static com.sun.tools.javac.code.Flags.BLOCK;
  74 import static com.sun.tools.javac.code.Kinds.*;
  75 import static com.sun.tools.javac.code.Kinds.Kind.*;
  76 import static com.sun.tools.javac.code.TypeTag.*;
  77 import static com.sun.tools.javac.code.TypeTag.WILDCARD;

  78 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  79 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  80 
  81 /** This is the main context-dependent analysis phase in GJC. It
  82  *  encompasses name resolution, type checking and constant folding as
  83  *  subtasks. Some subtasks involve auxiliary classes.
  84  *  @see Check
  85  *  @see Resolve
  86  *  @see ConstFold
  87  *  @see Infer
  88  *
  89  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  90  *  If you write code that depends on this, you do so at your own risk.
  91  *  This code and its internal interfaces are subject to change or
  92  *  deletion without notice.&lt;/b&gt;
  93  */
  94 public class Attr extends JCTree.Visitor {
  95     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  96 
  97     final Names names;
  98     final Log log;
  99     final Symtab syms;
 100     final Resolve rs;
 101     final Operators operators;
 102     final Infer infer;
 103     final Analyzer analyzer;
 104     final DeferredAttr deferredAttr;
 105     final Check chk;
 106     final Flow flow;
 107     final MemberEnter memberEnter;
 108     final TypeEnter typeEnter;
 109     final TreeMaker make;
 110     final ConstFold cfolder;
 111     final Enter enter;
 112     final Target target;
 113     final Types types;
<span class="line-added"> 114     final Preview preview;</span>
 115     final JCDiagnostic.Factory diags;
 116     final TypeAnnotations typeAnnotations;
 117     final DeferredLintHandler deferredLintHandler;
 118     final TypeEnvs typeEnvs;
 119     final Dependencies dependencies;
 120     final Annotate annotate;
 121     final ArgumentAttr argumentAttr;
<span class="line-added"> 122     final MatchBindingsComputer matchBindingsComputer;</span>
 123 
 124     public static Attr instance(Context context) {
 125         Attr instance = context.get(attrKey);
 126         if (instance == null)
 127             instance = new Attr(context);
 128         return instance;
 129     }
 130 
 131     protected Attr(Context context) {
 132         context.put(attrKey, this);
 133 
 134         names = Names.instance(context);
 135         log = Log.instance(context);
 136         syms = Symtab.instance(context);
 137         rs = Resolve.instance(context);
 138         operators = Operators.instance(context);
 139         chk = Check.instance(context);
 140         flow = Flow.instance(context);
 141         memberEnter = MemberEnter.instance(context);
 142         typeEnter = TypeEnter.instance(context);
 143         make = TreeMaker.instance(context);
 144         enter = Enter.instance(context);
 145         infer = Infer.instance(context);
 146         analyzer = Analyzer.instance(context);
 147         deferredAttr = DeferredAttr.instance(context);
 148         cfolder = ConstFold.instance(context);
 149         target = Target.instance(context);
 150         types = Types.instance(context);
<span class="line-added"> 151         preview = Preview.instance(context);</span>
 152         diags = JCDiagnostic.Factory.instance(context);
 153         annotate = Annotate.instance(context);
 154         typeAnnotations = TypeAnnotations.instance(context);
 155         deferredLintHandler = DeferredLintHandler.instance(context);
 156         typeEnvs = TypeEnvs.instance(context);
 157         dependencies = Dependencies.instance(context);
 158         argumentAttr = ArgumentAttr.instance(context);
<span class="line-added"> 159         matchBindingsComputer = MatchBindingsComputer.instance(context);</span>
 160 
 161         Options options = Options.instance(context);
 162 
 163         Source source = Source.instance(context);
 164         allowPoly = Feature.POLY.allowedInSource(source);
 165         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 166         allowLambda = Feature.LAMBDA.allowedInSource(source);
 167         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 168         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
<span class="line-added"> 169         allowReifiableTypesInInstanceof =</span>
<span class="line-added"> 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;</span>
<span class="line-added"> 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());</span>
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
 174 
 175         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 176         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 177         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 178         methodAttrInfo = new MethodAttrInfo();
 179         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 180         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 181         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 182     }
 183 
 184     /** Switch: support target-typing inference
 185      */
 186     boolean allowPoly;
 187 
 188     /** Switch: support type annotations.
 189      */
 190     boolean allowTypeAnnos;
 191 
 192     /** Switch: support lambda expressions ?
 193      */
 194     boolean allowLambda;
 195 
 196     /** Switch: support default methods ?
 197      */
 198     boolean allowDefaultMethods;
 199 
 200     /** Switch: static interface methods enabled?
 201      */
 202     boolean allowStaticInterfaceMethods;
 203 
<span class="line-added"> 204     /** Switch: reifiable types in instanceof enabled?</span>
<span class="line-added"> 205      */</span>
<span class="line-added"> 206     boolean allowReifiableTypesInInstanceof;</span>
<span class="line-added"> 207 </span>
 208     /**
 209      * Switch: warn about use of variable before declaration?
 210      * RFE: 6425594
 211      */
 212     boolean useBeforeDeclarationWarning;
 213 
 214     /**
 215      * Switch: name of source level; used for error reporting.
 216      */
 217     String sourceName;
 218 
 219     /** Check kind and type of given tree against protokind and prototype.
 220      *  If check succeeds, store type in tree and return it.
 221      *  If check fails, store errType in tree and return it.
 222      *  No checks are performed if the prototype is a method type.
 223      *  It is not necessary in this case since we know that kind and type
 224      *  are correct.
 225      *
 226      *  @param tree     The tree whose kind and type is checked
 227      *  @param found    The computed type of the tree
</pre>
<hr />
<pre>
 287     }
 288 
 289     /** Check that variable can be assigned to.
 290      *  @param pos    The current source code position.
 291      *  @param v      The assigned variable
 292      *  @param base   If the variable is referred to in a Select, the part
 293      *                to the left of the `.&#39;, null otherwise.
 294      *  @param env    The current environment.
 295      */
 296     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 297         if (v.name == names._this) {
 298             log.error(pos, Errors.CantAssignValToThis);
 299         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 300             ((v.flags() &amp; HASINIT) != 0
 301              ||
 302              !((base == null ||
 303                TreeInfo.isThisQualifier(base)) &amp;&amp;
 304                isAssignableAsBlankFinal(v, env)))) {
 305             if (v.isResourceVariable()) { //TWR resource
 306                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
<span class="line-added"> 307             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {</span>
<span class="line-added"> 308                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));</span>
 309             } else {
 310                 log.error(pos, Errors.CantAssignValToFinalVar(v));
 311             }
 312         }
 313     }
 314 
 315     /** Does tree represent a static reference to an identifier?
 316      *  It is assumed that tree is either a SELECT or an IDENT.
 317      *  We have to weed out selects from non-type names here.
 318      *  @param tree    The candidate tree.
 319      */
 320     boolean isStaticReference(JCTree tree) {
 321         if (tree.hasTag(SELECT)) {
 322             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 323             if (lsym == null || lsym.kind != TYP) {
 324                 return false;
 325             }
 326         }
 327         return true;
 328     }
</pre>
<hr />
<pre>
 354     }
 355 
 356     /** Attribute a parsed identifier.
 357      * @param tree Parsed identifier name
 358      * @param env The env to use
 359      */
 360     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 361         return tree.accept(identAttributer, env);
 362     }
 363     // where
 364         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 365         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 366             @Override @DefinedBy(Api.COMPILER_TREE)
 367             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 368                 Symbol site = visit(node.getExpression(), env);
 369                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 370                     return site;
 371                 Name name = (Name)node.getIdentifier();
 372                 if (site.kind == PCK) {
 373                     env.toplevel.packge = (PackageSymbol)site;
<span class="line-modified"> 374                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,</span>
 375                             KindSelector.TYP_PCK);
 376                 } else {
 377                     env.enclClass.sym = (ClassSymbol)site;
 378                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 379                 }
 380             }
 381 
 382             @Override @DefinedBy(Api.COMPILER_TREE)
 383             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
<span class="line-modified"> 384                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);</span>
 385             }
 386         }
 387 
 388     public Type coerce(Type etype, Type ttype) {
 389         return cfolder.coerce(etype, ttype);
 390     }
 391 
 392     public Type attribType(JCTree node, TypeSymbol sym) {
 393         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 394         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 395         return attribTree(node, localEnv, unknownTypeInfo);
 396     }
 397 
 398     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 399         // Attribute qualifying package or class.
 400         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 401         return attribTree(s.selected, env,
 402                           new ResultInfo(tree.staticImport ?
 403                                          KindSelector.TYP : KindSelector.TYP_PCK,
 404                        Type.noType));
 405     }
 406 
 407     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
<span class="line-modified"> 408         return attribToTree(expr, env, tree, unknownExprInfo);</span>



















 409     }
 410 
 411     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
<span class="line-added"> 412         return attribToTree(stmt, env, tree, statInfo);</span>
<span class="line-added"> 413     }</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {</span>
 416         breakTree = tree;
 417         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);

 418         try {
<span class="line-modified"> 419             deferredAttr.attribSpeculative(root, env, resultInfo,</span>
<span class="line-modified"> 420                     null, DeferredAttr.AttributionMode.ANALYZER,</span>
<span class="line-added"> 421                     argumentAttr.withLocalCacheContext());</span>
 422         } catch (BreakAttr b) {
 423             return b.env;
 424         } catch (AssertionError ae) {
 425             if (ae.getCause() instanceof BreakAttr) {
 426                 return ((BreakAttr)(ae.getCause())).env;
 427             } else {
 428                 throw ae;
 429             }
 430         } finally {
 431             breakTree = null;
 432             log.useSource(prev);

 433         }
 434         return env;
 435     }
 436 
 437     private JCTree breakTree = null;
 438 
 439     private static class BreakAttr extends RuntimeException {
 440         static final long serialVersionUID = -6924771130405446405L;
<span class="line-modified"> 441         private transient Env&lt;AttrContext&gt; env;</span>
 442         private BreakAttr(Env&lt;AttrContext&gt; env) {
 443             this.env = env;
 444         }
 445     }
 446 
 447     /**
 448      * Mode controlling behavior of Attr.Check
 449      */
 450     enum CheckMode {
 451 
 452         NORMAL,
 453 
 454         /**
 455          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 456          * that the captured var cache in {@code InferenceContext} will be used in read-only
 457          * mode when performing inference checks.
 458          */
 459         NO_TREE_UPDATE {
 460             @Override
 461             public boolean updateTreeType() {
</pre>
<hr />
<pre>
 625     KindSelector pkind() {
 626         return resultInfo.pkind;
 627     }
 628 
 629 /* ************************************************************************
 630  * Visitor methods
 631  *************************************************************************/
 632 
 633     /** Visitor argument: the current environment.
 634      */
 635     Env&lt;AttrContext&gt; env;
 636 
 637     /** Visitor argument: the currently expected attribution result.
 638      */
 639     ResultInfo resultInfo;
 640 
 641     /** Visitor result: the computed type.
 642      */
 643     Type result;
 644 
<span class="line-added"> 645     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;</span>
<span class="line-added"> 646 </span>
 647     /** Visitor method: attribute a tree, catching any completion failure
 648      *  exceptions. Return the tree&#39;s type.
 649      *
 650      *  @param tree    The tree to be visited.
 651      *  @param env     The environment visitor argument.
 652      *  @param resultInfo   The result info visitor argument.
 653      */
 654     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 655         Env&lt;AttrContext&gt; prevEnv = this.env;
 656         ResultInfo prevResult = this.resultInfo;
 657         try {
 658             this.env = env;
 659             this.resultInfo = resultInfo;
 660             if (resultInfo.needsArgumentAttr(tree)) {
 661                 result = argumentAttr.attribArg(tree, env);
 662             } else {
 663                 tree.accept(this);
 664             }
<span class="line-added"> 665             matchBindings = matchBindingsComputer.finishBindings(tree,</span>
<span class="line-added"> 666                                                                  matchBindings);</span>
 667             if (tree == breakTree &amp;&amp;
 668                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 669                 breakTreeFound(copyEnv(env));
 670             }
 671             return result;
 672         } catch (CompletionFailure ex) {
 673             tree.type = syms.errType;
 674             return chk.completionError(tree.pos(), ex);
 675         } finally {
 676             this.env = prevEnv;
 677             this.resultInfo = prevResult;
 678         }
 679     }
 680 
 681     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 682         throw new BreakAttr(env);
 683     }
 684 
 685     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 686         Env&lt;AttrContext&gt; newEnv =
</pre>
<hr />
<pre>
 717     }
 718 
 719     /** Derived visitor method: attribute a type tree.
 720      */
 721     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 722         Type result = attribType(tree, env, Type.noType);
 723         return result;
 724     }
 725 
 726     /** Derived visitor method: attribute a type tree.
 727      */
 728     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 729         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 730         return result;
 731     }
 732 
 733     /** Derived visitor method: attribute a statement or definition tree.
 734      */
 735     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 736         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
<span class="line-modified"> 737         Type result = attribTree(tree, env, statInfo);</span>
<span class="line-modified"> 738         analyzer.analyzeIfNeeded(tree, analyzeEnv);</span>
<span class="line-modified"> 739         return result;</span>


 740     }
 741 
 742     /** Attribute a list of expressions, returning a list of types.
 743      */
 744     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 745         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 746         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 747             ts.append(attribExpr(l.head, env, pt));
 748         return ts.toList();
 749     }
 750 
 751     /** Attribute a list of statements, returning nothing.
 752      */
 753     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 754         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 755             attribStat(l.head, env);
 756     }
 757 
 758     /** Attribute the arguments in a method call, returning the method kind.
 759      */
</pre>
<hr />
<pre>
 913             return types.createErrorType(t);
 914         }
 915         if (checkExtensible &amp;&amp;
 916             ((t.tsym.flags() &amp; FINAL) != 0)) {
 917             log.error(pos,
 918                       Errors.CantInheritFromFinal(t.tsym));
 919         }
 920         chk.checkNonCyclic(pos, t);
 921         return t;
 922     }
 923 
 924     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 925         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 926         id.type = env.info.scope.owner.enclClass().type;
 927         id.sym = env.info.scope.owner.enclClass();
 928         return id.type;
 929     }
 930 
 931     public void visitClassDef(JCClassDecl tree) {
 932         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
<span class="line-modified"> 933                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?</span>
 934                         argumentAttr.withLocalCacheContext() : null);
 935         try {
 936             // Local and anonymous classes have not been entered yet, so we need to
 937             // do it now.
 938             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 939                 enter.classEnter(tree, env);
 940             } else {
 941                 // If this class declaration is part of a class level annotation,
 942                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 943                 // order to simplify later steps and allow for sensible error
 944                 // messages.
 945                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 946                     enter.classEnter(tree, env);
 947             }
 948 
 949             ClassSymbol c = tree.sym;
 950             if (c == null) {
 951                 // exit in case something drastic went wrong during enter.
 952                 result = null;
 953             } else {
</pre>
<hr />
<pre>
1022 
1023             chk.checkVarargsMethodDecl(localEnv, tree);
1024 
1025             // Check that type parameters are well-formed.
1026             chk.validate(tree.typarams, localEnv);
1027 
1028             // Check that result type is well-formed.
1029             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1030                 chk.validate(tree.restype, localEnv);
1031 
1032             // Check that receiver type is well-formed.
1033             if (tree.recvparam != null) {
1034                 // Use a new environment to check the receiver parameter.
1035                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1036                 // Is there a better way?
1037                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1038                 attribType(tree.recvparam, newEnv);
1039                 chk.validate(tree.recvparam, newEnv);
1040             }
1041 
<span class="line-added">1042             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {</span>
<span class="line-added">1043                 // lets find if this method is an accessor</span>
<span class="line-added">1044                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()</span>
<span class="line-added">1045                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();</span>
<span class="line-added">1046                 if (recordComponent.isPresent()) {</span>
<span class="line-added">1047                     // the method is a user defined accessor lets check that everything is fine</span>
<span class="line-added">1048                     if (!tree.sym.isPublic()) {</span>
<span class="line-added">1049                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));</span>
<span class="line-added">1050                     }</span>
<span class="line-added">1051                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {</span>
<span class="line-added">1052                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,</span>
<span class="line-added">1053                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));</span>
<span class="line-added">1054                     }</span>
<span class="line-added">1055                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {</span>
<span class="line-added">1056                         log.error(tree,</span>
<span class="line-added">1057                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));</span>
<span class="line-added">1058                     }</span>
<span class="line-added">1059                     if (!tree.typarams.isEmpty()) {</span>
<span class="line-added">1060                         log.error(tree,</span>
<span class="line-added">1061                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));</span>
<span class="line-added">1062                     }</span>
<span class="line-added">1063                     if (tree.sym.isStatic()) {</span>
<span class="line-added">1064                         log.error(tree,</span>
<span class="line-added">1065                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));</span>
<span class="line-added">1066                     }</span>
<span class="line-added">1067                 }</span>
<span class="line-added">1068 </span>
<span class="line-added">1069                 if (tree.name == names.init) {</span>
<span class="line-added">1070                     // if this a constructor other than the canonical one</span>
<span class="line-added">1071                     if ((tree.sym.flags_field &amp; RECORD) == 0) {</span>
<span class="line-added">1072                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);</span>
<span class="line-added">1073                         if (app == null ||</span>
<span class="line-added">1074                                 TreeInfo.name(app.meth) != names._this ||</span>
<span class="line-added">1075                                 !checkFirstConstructorStat(app, tree, false)) {</span>
<span class="line-added">1076                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);</span>
<span class="line-added">1077                         }</span>
<span class="line-added">1078                     } else {</span>
<span class="line-added">1079                         // but if it is the canonical:</span>
<span class="line-added">1080 </span>
<span class="line-added">1081                         // if user generated, then it shouldn&#39;t explicitly invoke any other constructor</span>
<span class="line-added">1082                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {</span>
<span class="line-added">1083                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);</span>
<span class="line-added">1084                             if (app != null &amp;&amp;</span>
<span class="line-added">1085                                     (TreeInfo.name(app.meth) == names._this ||</span>
<span class="line-added">1086                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;</span>
<span class="line-added">1087                                     checkFirstConstructorStat(app, tree, false)) {</span>
<span class="line-added">1088                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1089                                         Fragments.Canonical, tree.sym.name,</span>
<span class="line-added">1090                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));</span>
<span class="line-added">1091                             }</span>
<span class="line-added">1092                         }</span>
<span class="line-added">1093 </span>
<span class="line-added">1094                         // also we want to check that no type variables have been defined</span>
<span class="line-added">1095                         if (!tree.typarams.isEmpty()) {</span>
<span class="line-added">1096                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1097                                     Fragments.Canonical, tree.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));</span>
<span class="line-added">1098                         }</span>
<span class="line-added">1099 </span>
<span class="line-added">1100                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the</span>
<span class="line-added">1101                          * record components</span>
<span class="line-added">1102                          */</span>
<span class="line-added">1103                         List&lt;Type&gt; recordComponentTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);</span>
<span class="line-added">1104                         for (JCVariableDecl param: tree.params) {</span>
<span class="line-added">1105                             if (!types.isSameType(param.type, recordComponentTypes.head)) {</span>
<span class="line-added">1106                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1107                                         Fragments.Canonical, tree.sym.name, Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));</span>
<span class="line-added">1108                             }</span>
<span class="line-added">1109                             recordComponentTypes = recordComponentTypes.tail;</span>
<span class="line-added">1110                         }</span>
<span class="line-added">1111                     }</span>
<span class="line-added">1112                 }</span>
<span class="line-added">1113             }</span>
<span class="line-added">1114 </span>
1115             // annotation method checks
1116             if ((owner.flags() &amp; ANNOTATION) != 0) {
1117                 // annotation method cannot have throws clause
1118                 if (tree.thrown.nonEmpty()) {
1119                     log.error(tree.thrown.head.pos(),
1120                               Errors.ThrowsNotAllowedInIntfAnnotation);
1121                 }
1122                 // annotation method cannot declare type-parameters
1123                 if (tree.typarams.nonEmpty()) {
1124                     log.error(tree.typarams.head.pos(),
1125                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1126                 }
1127                 // validate annotation method&#39;s return type (could be an annotation type)
1128                 chk.validateAnnotationType(tree.restype);
1129                 // ensure that annotation method does not clash with members of Object/Annotation
1130                 chk.validateAnnotationMethod(tree.pos(), m);
1131             }
1132 
1133             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1134                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
</pre>
<hr />
<pre>
1142                         log.error(tree.pos(),
1143                                   Errors.DefaultAllowedInIntfAnnotationMember);
1144                 }
1145                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1146                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1147             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1148                 if ((owner.flags() &amp; INTERFACE) != 0) {
1149                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1150                 } else {
1151                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1152                 }
1153             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1154                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1155             } else {
1156                 // Add an implicit super() call unless an explicit call to
1157                 // super(...) or this(...) is given
1158                 // or we are compiling class java.lang.Object.
1159                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1160                     JCBlock body = tree.body;
1161                     if (body.stats.isEmpty() ||
<span class="line-modified">1162                             TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {</span>
<span class="line-modified">1163                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),</span>
<span class="line-modified">1164                                 make.Ident(names._super), make.Idents(List.nil())));</span>
<span class="line-modified">1165                         body.stats = body.stats.prepend(supCall);</span>


1166                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1167                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1168                             TreeInfo.isSuperCall(body.stats.head)) {
1169                         // enum constructors are not allowed to call super
1170                         // directly, so make sure there aren&#39;t any super calls
1171                         // in enum constructors, except in the compiler
1172                         // generated one.
1173                         log.error(tree.body.stats.head.pos(),
1174                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1175                     }
<span class="line-added">1176                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor</span>
<span class="line-added">1177                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);</span>
<span class="line-added">1178                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);</span>
<span class="line-added">1179                         if (!initParamNames.equals(recordComponentNames)) {</span>
<span class="line-added">1180                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1181                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));</span>
<span class="line-added">1182                         }</span>
<span class="line-added">1183                         if (!tree.sym.isPublic()) {</span>
<span class="line-added">1184                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1185                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,</span>
<span class="line-added">1186                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));</span>
<span class="line-added">1187                         }</span>
<span class="line-added">1188                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {</span>
<span class="line-added">1189                             log.error(tree,</span>
<span class="line-added">1190                                     Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">1191                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,</span>
<span class="line-added">1192                                             env.enclClass.sym.name,</span>
<span class="line-added">1193                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(</span>
<span class="line-added">1194                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));</span>
<span class="line-added">1195                         }</span>
<span class="line-added">1196                     }</span>
1197                 }
1198 
1199                 // Attribute all type annotations in the body
1200                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1201                 annotate.flush();
1202 
1203                 // Attribute method body.
1204                 attribStat(tree.body, localEnv);
1205             }
1206 
1207             localEnv.info.scope.leave();
1208             result = tree.type = m.type;
1209         } finally {
1210             chk.setLint(prevLint);
1211             chk.setMethod(prevMethod);
1212         }
1213     }
1214 
1215     public void visitVarDef(JCVariableDecl tree) {
1216         // Local variables have not been entered yet, so we need to do it now:
</pre>
<hr />
<pre>
1271                     // Attribute initializer in a new environment
1272                     // with the declared variable as owner.
1273                     // Check that initializer conforms to variable&#39;s declared type.
1274                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1275                     initEnv.info.lint = lint;
1276                     // In order to catch self-references, we set the variable&#39;s
1277                     // declaration position to maximal possible value, effectively
1278                     // marking the variable as undefined.
1279                     initEnv.info.enclVar = v;
1280                     attribExpr(tree.init, initEnv, v.type);
1281                     if (tree.isImplicitlyTyped()) {
1282                         //fixup local variable type
1283                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1284                     }
1285                 }
1286                 if (tree.isImplicitlyTyped()) {
1287                     setSyntheticVariableType(tree, v.type);
1288                 }
1289             }
1290             result = tree.type = v.type;
<span class="line-added">1291             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {</span>
<span class="line-added">1292                 if (isNonArgsMethodInObject(v.name)) {</span>
<span class="line-added">1293                     log.error(tree, Errors.IllegalRecordComponentName(v));</span>
<span class="line-added">1294                 }</span>
<span class="line-added">1295             }</span>
1296         }
1297         finally {
1298             chk.setLint(prevLint);
1299         }
1300     }
1301 
<span class="line-added">1302     private boolean isNonArgsMethodInObject(Name name) {</span>
<span class="line-added">1303         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {</span>
<span class="line-added">1304             if (s.type.getParameterTypes().isEmpty()) {</span>
<span class="line-added">1305                 return true;</span>
<span class="line-added">1306             }</span>
<span class="line-added">1307         }</span>
<span class="line-added">1308         return false;</span>
<span class="line-added">1309     }</span>
<span class="line-added">1310 </span>
1311     Fragment canInferLocalVarType(JCVariableDecl tree) {
1312         LocalInitScanner lis = new LocalInitScanner();
1313         lis.scan(tree.init);
1314         return lis.badInferenceMsg;
1315     }
1316 
1317     static class LocalInitScanner extends TreeScanner {
1318         Fragment badInferenceMsg = null;
1319         boolean needsTarget = true;
1320 
1321         @Override
1322         public void visitNewArray(JCNewArray tree) {
1323             if (tree.elemtype == null &amp;&amp; needsTarget) {
1324                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1325             }
1326         }
1327 
1328         @Override
1329         public void visitLambda(JCLambda tree) {
1330             if (needsTarget) {
</pre>
<hr />
<pre>
1361             }
1362         }
1363 
1364         @Override
1365         public void visitApply(JCMethodInvocation tree) {
1366             boolean prevNeedsTarget = needsTarget;
1367             try {
1368                 needsTarget = false;
1369                 super.visitApply(tree);
1370             } finally {
1371                 needsTarget = prevNeedsTarget;
1372             }
1373         }
1374     }
1375 
1376     public void visitSkip(JCSkip tree) {
1377         result = null;
1378     }
1379 
1380     public void visitBlock(JCBlock tree) {
<span class="line-modified">1381         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {</span>
1382             // Block is a static or instance initializer;
1383             // let the owner of the environment be a freshly
1384             // created BLOCK-method.
1385             Symbol fakeOwner =
1386                 new MethodSymbol(tree.flags | BLOCK |
1387                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1388                     env.info.scope.owner);
1389             final Env&lt;AttrContext&gt; localEnv =
1390                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1391 
1392             if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
1393             // Attribute all type annotations in the block
1394             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1395             annotate.flush();
1396             attribStats(tree.stats, localEnv);
1397 
1398             {
1399                 // Store init and clinit type annotations with the ClassSymbol
1400                 // to allow output in Gen.normalizeDefs.
1401                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
</pre>
<hr />
<pre>
1405                 } else {
1406                     cs.appendInitTypeAttributes(tas);
1407                 }
1408             }
1409         } else {
1410             // Create a new local environment with a local scope.
1411             Env&lt;AttrContext&gt; localEnv =
1412                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1413             try {
1414                 attribStats(tree.stats, localEnv);
1415             } finally {
1416                 localEnv.info.scope.leave();
1417             }
1418         }
1419         result = null;
1420     }
1421 
1422     public void visitDoLoop(JCDoWhileLoop tree) {
1423         attribStat(tree.body, env.dup(tree));
1424         attribExpr(tree.cond, env, syms.booleanType);
<span class="line-added">1425         if (!breaksOutOf(tree, tree.body)) {</span>
<span class="line-added">1426             //include condition&#39;s body when false after the while, if cannot get out of the loop</span>
<span class="line-added">1427             MatchBindings condBindings = matchBindings;</span>
<span class="line-added">1428             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);</span>
<span class="line-added">1429             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">1430         }</span>
1431         result = null;
1432     }
1433 
1434     public void visitWhileLoop(JCWhileLoop tree) {
1435         attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">1436         MatchBindings condBindings = matchBindings;</span>
<span class="line-added">1437         // include condition&#39;s bindings when true in the body:</span>
<span class="line-added">1438         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);</span>
<span class="line-added">1439         try {</span>
<span class="line-added">1440             attribStat(tree.body, whileEnv.dup(tree));</span>
<span class="line-added">1441         } finally {</span>
<span class="line-added">1442             whileEnv.info.scope.leave();</span>
<span class="line-added">1443         }</span>
<span class="line-added">1444         if (!breaksOutOf(tree, tree.body)) {</span>
<span class="line-added">1445             //include condition&#39;s bindings when false after the while, if cannot get out of the loop</span>
<span class="line-added">1446             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);</span>
<span class="line-added">1447             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">1448         }</span>
1449         result = null;
1450     }
1451 
<span class="line-added">1452     private boolean breaksOutOf(JCTree loop, JCTree body) {</span>
<span class="line-added">1453         preFlow(body);</span>
<span class="line-added">1454         return flow.breaksOutOf(env, loop, body, make);</span>
<span class="line-added">1455     }</span>
<span class="line-added">1456 </span>
1457     public void visitForLoop(JCForLoop tree) {
1458         Env&lt;AttrContext&gt; loopEnv =
1459             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
<span class="line-added">1460         MatchBindings condBindings = MatchBindingsComputer.EMPTY;</span>
1461         try {
1462             attribStats(tree.init, loopEnv);
<span class="line-modified">1463             if (tree.cond != null) {</span>
<span class="line-modified">1464                 attribExpr(tree.cond, loopEnv, syms.booleanType);</span>
<span class="line-modified">1465                 // include condition&#39;s bindings when true in the body and step:</span>
<span class="line-modified">1466                 condBindings = matchBindings;</span>
<span class="line-added">1467             }</span>
<span class="line-added">1468             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);</span>
<span class="line-added">1469             try {</span>
<span class="line-added">1470                 bodyEnv.tree = tree; // before, we were not in loop!</span>
<span class="line-added">1471                 attribStats(tree.step, bodyEnv);</span>
<span class="line-added">1472                 attribStat(tree.body, bodyEnv);</span>
<span class="line-added">1473             } finally {</span>
<span class="line-added">1474                 bodyEnv.info.scope.leave();</span>
<span class="line-added">1475             }</span>
1476             result = null;
1477         }
1478         finally {
1479             loopEnv.info.scope.leave();
1480         }
<span class="line-added">1481         if (!breaksOutOf(tree, tree.body)) {</span>
<span class="line-added">1482             //include condition&#39;s body when false after the while, if cannot get out of the loop</span>
<span class="line-added">1483             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);</span>
<span class="line-added">1484             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">1485         }</span>
1486     }
1487 
1488     public void visitForeachLoop(JCEnhancedForLoop tree) {
1489         Env&lt;AttrContext&gt; loopEnv =
1490             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1491         try {
1492             //the Formal Parameter of a for-each loop is not in the scope when
<span class="line-modified">1493             //attributing the for-each expression; we mimic this by attributing</span>
1494             //the for-each expression first (against original scope).
1495             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1496             chk.checkNonVoid(tree.pos(), exprType);
1497             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1498             if (elemtype == null) {
1499                 // or perhaps expr implements Iterable&lt;T&gt;?
1500                 Type base = types.asSuper(exprType, syms.iterableType.tsym);
1501                 if (base == null) {
1502                     log.error(tree.expr.pos(),
1503                               Errors.ForeachNotApplicableToType(exprType,
1504                                                                 Fragments.TypeReqArrayOrIterable));
1505                     elemtype = types.createErrorType(exprType);
1506                 } else {
1507                     List&lt;Type&gt; iterableParams = base.allparams();
1508                     elemtype = iterableParams.isEmpty()
1509                         ? syms.objectType
1510                         : types.wildUpperBound(iterableParams.head);
1511                 }
1512             }
1513             if (tree.var.isImplicitlyTyped()) {
</pre>
<hr />
<pre>
1551 
1552     public void visitSwitchExpression(JCSwitchExpression tree) {
1553         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1554                 PolyKind.STANDALONE : PolyKind.POLY;
1555 
1556         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1557             //this means we are returning a poly conditional from void-compatible lambda expression
1558             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1559             result = tree.type = types.createErrorType(resultInfo.pt);
1560             return;
1561         }
1562 
1563         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1564                 unknownExprInfo :
1565                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1566 
1567         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1568         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1569 
1570         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
<span class="line-modified">1571             caseEnv.info.yieldResult = condInfo;</span>
1572             attribStats(c.stats, caseEnv);
1573             new TreeScanner() {
1574                 @Override
<span class="line-modified">1575                 public void visitYield(JCYield brk) {</span>
1576                     if (brk.target == tree) {
1577                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1578                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1579                     }
<span class="line-modified">1580                     super.visitYield(brk);</span>
1581                 }
1582 
1583                 @Override public void visitClassDef(JCClassDecl tree) {}
1584                 @Override public void visitLambda(JCLambda tree) {}
1585             }.scan(c.stats);
1586         });
1587 
1588         if (tree.cases.isEmpty()) {
1589             log.error(tree.pos(),
1590                       Errors.SwitchExpressionEmpty);
<span class="line-added">1591         } else if (caseTypes.isEmpty()) {</span>
<span class="line-added">1592             log.error(tree.pos(),</span>
<span class="line-added">1593                       Errors.SwitchExpressionNoResultExpressions);</span>
1594         }
1595 
1596         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1597 
1598         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1599     }
1600     //where:
1601         CheckContext switchExpressionContext(CheckContext checkContext) {
1602             return new Check.NestedCheckContext(checkContext) {
1603                 //this will use enclosing check context to check compatibility of
1604                 //subexpression against target type; if we are in a method check context,
1605                 //depending on whether boxing is allowed, we could have incompatibilities
1606                 @Override
1607                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1608                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1609                 }
1610             };
1611         }
1612 
1613     private void handleSwitch(JCTree switchTree,
1614                               JCExpression selector,
1615                               List&lt;JCCase&gt; cases,
1616                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1617         Type seltype = attribExpr(selector, env);
1618 
1619         Env&lt;AttrContext&gt; switchEnv =
1620             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1621 
1622         try {
1623             boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;
1624             boolean stringSwitch = types.isSameType(seltype, syms.stringType);
1625             if (!enumSwitch &amp;&amp; !stringSwitch)
1626                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1627 
1628             // Attribute all cases and
1629             // check that there are no duplicate case labels or default clauses.
1630             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1631             boolean hasDefault = false;      // Is there a default label?
<span class="line-modified">1632             CaseTree.CaseKind caseKind = null;</span>

1633             boolean wasError = false;
1634             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1635                 JCCase c = l.head;
1636                 if (caseKind == null) {
1637                     caseKind = c.caseKind;
1638                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1639                     log.error(c.pos(),
1640                               Errors.SwitchMixingCaseTypes);
1641                     wasError = true;
1642                 }
1643                 if (c.getExpressions().nonEmpty()) {
1644                     for (JCExpression pat : c.getExpressions()) {
1645                         if (TreeInfo.isNull(pat)) {
1646                             log.error(pat.pos(),
1647                                       Errors.SwitchNullNotAllowed);
1648                         } else if (enumSwitch) {
1649                             Symbol sym = enumConstant(pat, seltype);
1650                             if (sym == null) {
1651                                 log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1652                             } else if (!labels.add(sym)) {
</pre>
<hr />
<pre>
1658                                 if (pattype.constValue() == null) {
1659                                     log.error(pat.pos(),
1660                                               (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));
1661                                 } else if (!labels.add(pattype.constValue())) {
1662                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1663                                 }
1664                             }
1665                         }
1666                     }
1667                 } else if (hasDefault) {
1668                     log.error(c.pos(), Errors.DuplicateDefaultLabel);
1669                 } else {
1670                     hasDefault = true;
1671                 }
1672                 Env&lt;AttrContext&gt; caseEnv =
1673                     switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
1674                 try {
1675                     attribCase.accept(c, caseEnv);
1676                 } finally {
1677                     caseEnv.info.scope.leave();

1678                 }
<span class="line-added">1679                 addVars(c.stats, switchEnv.info.scope);</span>
1680             }
1681         } finally {
1682             switchEnv.info.scope.leave();
1683         }
1684     }
1685     // where
1686         /** Add any variables defined in stats to the switch scope. */
1687         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1688             for (;stats.nonEmpty(); stats = stats.tail) {
1689                 JCTree stat = stats.head;
1690                 if (stat.hasTag(VARDEF))
1691                     switchScope.enter(((JCVariableDecl) stat).sym);
1692             }
1693         }
1694     // where
1695     /** Return the selected enumeration constant symbol, or null. */
1696     private Symbol enumConstant(JCTree tree, Type enumType) {
1697         if (tree.hasTag(IDENT)) {
1698             JCIdent ident = (JCIdent)tree;
1699             Name name = ident.name;
</pre>
<hr />
<pre>
1801                         env,
1802                         types.skipTypeVars(resource, false),
1803                         names.close,
1804                         List.nil(),
1805                         List.nil());
1806             }
1807             finally {
1808                 log.popDiagnosticHandler(discardHandler);
1809             }
1810             if (close.kind == MTH &amp;&amp;
1811                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1812                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1813                     env.info.lint.isEnabled(LintCategory.TRY)) {
1814                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1815             }
1816         }
1817     }
1818 
1819     public void visitConditional(JCConditional tree) {
1820         Type condtype = attribExpr(tree.cond, env, syms.booleanType);
<span class="line-added">1821         MatchBindings condBindings = matchBindings;</span>
1822 
1823         tree.polyKind = (!allowPoly ||
1824                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1825                 isBooleanOrNumeric(env, tree)) ?
1826                 PolyKind.STANDALONE : PolyKind.POLY;
1827 
1828         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1829             //this means we are returning a poly conditional from void-compatible lambda expression
1830             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1831             result = tree.type = types.createErrorType(resultInfo.pt);
1832             return;
1833         }
1834 
1835         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1836                 unknownExprInfo :
1837                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1838 
<span class="line-modified">1839 </span>
<span class="line-modified">1840         // x ? y : z</span>
<span class="line-added">1841         // include x&#39;s bindings when true in y</span>
<span class="line-added">1842         // include x&#39;s bindings when false in z</span>
<span class="line-added">1843 </span>
<span class="line-added">1844         Type truetype;</span>
<span class="line-added">1845         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);</span>
<span class="line-added">1846         try {</span>
<span class="line-added">1847             truetype = attribTree(tree.truepart, trueEnv, condInfo);</span>
<span class="line-added">1848         } finally {</span>
<span class="line-added">1849             trueEnv.info.scope.leave();</span>
<span class="line-added">1850         }</span>
<span class="line-added">1851 </span>
<span class="line-added">1852         MatchBindings trueBindings = matchBindings;</span>
<span class="line-added">1853 </span>
<span class="line-added">1854         Type falsetype;</span>
<span class="line-added">1855         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);</span>
<span class="line-added">1856         try {</span>
<span class="line-added">1857             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);</span>
<span class="line-added">1858         } finally {</span>
<span class="line-added">1859             falseEnv.info.scope.leave();</span>
<span class="line-added">1860         }</span>
<span class="line-added">1861 </span>
<span class="line-added">1862         MatchBindings falseBindings = matchBindings;</span>
1863 
1864         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1865                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1866                          List.of(truetype, falsetype)) : pt();
1867         if (condtype.constValue() != null &amp;&amp;
1868                 truetype.constValue() != null &amp;&amp;
1869                 falsetype.constValue() != null &amp;&amp;
1870                 !owntype.hasTag(NONE)) {
1871             //constant folding
1872             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1873         }
1874         result = check(tree, owntype, KindSelector.VAL, resultInfo);
<span class="line-added">1875         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);</span>
1876     }
1877     //where
1878         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1879             switch (tree.getTag()) {
1880                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1881                               ((JCLiteral)tree).typetag == BOOLEAN ||
1882                               ((JCLiteral)tree).typetag == BOT;
1883                 case LAMBDA: case REFERENCE: return false;
1884                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1885                 case CONDEXPR:
1886                     JCConditional condTree = (JCConditional)tree;
1887                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1888                             isBooleanOrNumeric(env, condTree.falsepart);
1889                 case APPLY:
1890                     JCMethodInvocation speculativeMethodTree =
1891                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1892                                     tree, env, unknownExprInfo,
1893                                     argumentAttr.withLocalCacheContext());
1894                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1895                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
</pre>
<hr />
<pre>
1998                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t))
1999                                  .collect(List.collector());
2000 
2001             // both are known to be reference types.  The result is
2002             // lub(thentype,elsetype). This cannot fail, as it will
2003             // always be possible to infer &quot;Object&quot; if nothing better.
2004             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
2005         }
2006 
2007     final static TypeTag[] primitiveTags = new TypeTag[]{
2008         BYTE,
2009         CHAR,
2010         SHORT,
2011         INT,
2012         LONG,
2013         FLOAT,
2014         DOUBLE,
2015         BOOLEAN,
2016     };
2017 
<span class="line-added">2018     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {</span>
<span class="line-added">2019         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));</span>
<span class="line-added">2020         bindings.forEach(env1.info.scope::enter);</span>
<span class="line-added">2021         return env1;</span>
<span class="line-added">2022     }</span>
<span class="line-added">2023 </span>
2024     public void visitIf(JCIf tree) {
2025         attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">2026 </span>
<span class="line-modified">2027         // if (x) { y } [ else z ]</span>
<span class="line-modified">2028         // include x&#39;s bindings when true in y</span>
<span class="line-added">2029         // include x&#39;s bindings when false in z</span>
<span class="line-added">2030 </span>
<span class="line-added">2031         MatchBindings condBindings = matchBindings;</span>
<span class="line-added">2032         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);</span>
<span class="line-added">2033 </span>
<span class="line-added">2034         try {</span>
<span class="line-added">2035             attribStat(tree.thenpart, thenEnv);</span>
<span class="line-added">2036         } finally {</span>
<span class="line-added">2037             thenEnv.info.scope.leave();</span>
<span class="line-added">2038         }</span>
<span class="line-added">2039 </span>
<span class="line-added">2040         preFlow(tree.thenpart);</span>
<span class="line-added">2041         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);</span>
<span class="line-added">2042         boolean aliveAfterElse;</span>
<span class="line-added">2043 </span>
<span class="line-added">2044         if (tree.elsepart != null) {</span>
<span class="line-added">2045             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);</span>
<span class="line-added">2046             try {</span>
<span class="line-added">2047                 attribStat(tree.elsepart, elseEnv);</span>
<span class="line-added">2048             } finally {</span>
<span class="line-added">2049                 elseEnv.info.scope.leave();</span>
<span class="line-added">2050             }</span>
<span class="line-added">2051             preFlow(tree.elsepart);</span>
<span class="line-added">2052             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);</span>
<span class="line-added">2053         } else {</span>
<span class="line-added">2054             aliveAfterElse = true;</span>
<span class="line-added">2055         }</span>
<span class="line-added">2056 </span>
2057         chk.checkEmptyIf(tree);
<span class="line-added">2058 </span>
<span class="line-added">2059         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();</span>
<span class="line-added">2060 </span>
<span class="line-added">2061         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {</span>
<span class="line-added">2062             afterIfBindings = condBindings.bindingsWhenTrue;</span>
<span class="line-added">2063         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {</span>
<span class="line-added">2064             afterIfBindings = condBindings.bindingsWhenFalse;</span>
<span class="line-added">2065         }</span>
<span class="line-added">2066 </span>
<span class="line-added">2067         afterIfBindings.forEach(env.info.scope::enter);</span>
<span class="line-added">2068         afterIfBindings.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">2069 </span>
2070         result = null;
2071     }
2072 
<span class="line-added">2073         void preFlow(JCTree tree) {</span>
<span class="line-added">2074             new PostAttrAnalyzer() {</span>
<span class="line-added">2075                 @Override</span>
<span class="line-added">2076                 public void scan(JCTree tree) {</span>
<span class="line-added">2077                     if (tree == null ||</span>
<span class="line-added">2078                             (tree.type != null &amp;&amp;</span>
<span class="line-added">2079                             tree.type == Type.stuckType)) {</span>
<span class="line-added">2080                         //don&#39;t touch stuck expressions!</span>
<span class="line-added">2081                         return;</span>
<span class="line-added">2082                     }</span>
<span class="line-added">2083                     super.scan(tree);</span>
<span class="line-added">2084                 }</span>
<span class="line-added">2085             }.scan(tree);</span>
<span class="line-added">2086         }</span>
<span class="line-added">2087 </span>
2088     public void visitExec(JCExpressionStatement tree) {
2089         //a fresh environment is required for 292 inference to work properly ---
2090         //see Infer.instantiatePolymorphicSignatureInstance()
2091         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2092         attribExpr(tree.expr, localEnv);
2093         result = null;
2094     }
2095 
2096     public void visitBreak(JCBreak tree) {
<span class="line-modified">2097         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);</span>
<span class="line-modified">2098         result = null;</span>
<span class="line-modified">2099     }</span>
<span class="line-modified">2100 </span>
<span class="line-modified">2101     public void visitYield(JCYield tree) {</span>
<span class="line-modified">2102         if (env.info.yieldResult != null) {</span>
<span class="line-modified">2103             attribTree(tree.value, env, env.info.yieldResult);</span>
<span class="line-modified">2104             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);</span>













































2105         } else {
<span class="line-modified">2106             log.error(tree.pos(), tree.value.hasTag(PARENS)</span>
<span class="line-modified">2107                     ? Errors.NoSwitchExpressionQualify</span>
<span class="line-modified">2108                     : Errors.NoSwitchExpression);</span>
<span class="line-modified">2109             attribTree(tree.value, env, unknownExprInfo);</span>



2110         }
2111         result = null;
2112     }
2113 
2114     public void visitContinue(JCContinue tree) {
2115         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2116         result = null;
2117     }
2118     //where
<span class="line-modified">2119         /** Return the target of a break, continue or yield statement,</span>
<span class="line-modified">2120          *  if it exists, report an error if not.</span>
2121          *  Note: The target of a labelled break or continue is the
2122          *  (non-labelled) statement tree referred to by the label,
2123          *  not the tree representing the labelled statement itself.
2124          *
2125          *  @param pos     The position to be used for error diagnostics
2126          *  @param tag     The tag of the jump statement. This is either
2127          *                 Tree.BREAK or Tree.CONTINUE.
2128          *  @param label   The label of the jump statement, or null if no
2129          *                 label is given.
2130          *  @param env     The environment current at the jump statement.
2131          */
2132         private JCTree findJumpTarget(DiagnosticPosition pos,
2133                                                    JCTree.Tag tag,
2134                                                    Name label,
2135                                                    Env&lt;AttrContext&gt; env) {
2136             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
2137 
2138             if (jumpTarget.snd != null) {
2139                 log.error(pos, jumpTarget.snd);
2140             }
</pre>
<hr />
<pre>
2174                                     pendingError = Errors.NotLoopLabel(label);
2175                                 }
2176                                 // Found labelled statement target, now go inwards
2177                                 // to next non-labelled tree.
2178                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
2179                             } else {
2180                                 return Pair.of(labelled, pendingError);
2181                             }
2182                         }
2183                         break;
2184                     case DOLOOP:
2185                     case WHILELOOP:
2186                     case FORLOOP:
2187                     case FOREACHLOOP:
2188                         if (label == null) return Pair.of(env1.tree, pendingError);
2189                         break;
2190                     case SWITCH:
2191                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2192                         break;
2193                     case SWITCH_EXPRESSION:
<span class="line-modified">2194                         if (tag == YIELD) {</span>
<span class="line-modified">2195                             return Pair.of(env1.tree, null);</span>
<span class="line-modified">2196                         } else if (tag == BREAK) {</span>
<span class="line-modified">2197                             pendingError = Errors.BreakOutsideSwitchExpression;</span>


2198                         } else {
2199                             pendingError = Errors.ContinueOutsideSwitchExpression;
2200                         }
2201                         break;
2202                     case LAMBDA:
2203                     case METHODDEF:
2204                     case CLASSDEF:
2205                         break LOOP;
2206                     default:
2207                 }
2208                 env1 = env1.next;
2209             }
2210             if (label != null)
2211                 return Pair.of(null, Errors.UndefLabel(label));
<span class="line-added">2212             else if (pendingError != null)</span>
<span class="line-added">2213                 return Pair.of(null, pendingError);</span>
2214             else if (tag == CONTINUE)
2215                 return Pair.of(null, Errors.ContOutsideLoop);
2216             else
2217                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2218         }
2219 
2220     public void visitReturn(JCReturn tree) {
2221         // Check that there is an enclosing method which is
2222         // nested within than the enclosing class.
2223         if (env.info.returnResult == null) {
2224             log.error(tree.pos(), Errors.RetOutsideMeth);
<span class="line-modified">2225         } else if (env.info.yieldResult != null) {</span>
2226             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
<span class="line-added">2227         } else if (!env.info.isLambda &amp;&amp;</span>
<span class="line-added">2228                 !env.info.isNewClass &amp;&amp;</span>
<span class="line-added">2229                 env.enclMethod != null &amp;&amp;</span>
<span class="line-added">2230                 TreeInfo.isCompactConstructor(env.enclMethod)) {</span>
<span class="line-added">2231             log.error(env.enclMethod,</span>
<span class="line-added">2232                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));</span>
2233         } else {
2234             // Attribute return expression, if it exists, and check that
2235             // it conforms to result type of enclosing method.
2236             if (tree.expr != null) {
2237                 if (env.info.returnResult.pt.hasTag(VOID)) {
2238                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2239                               diags.fragment(Fragments.UnexpectedRetVal));
2240                 }
2241                 attribTree(tree.expr, env, env.info.returnResult);
2242             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2243                     !env.info.returnResult.pt.hasTag(NONE)) {
2244                 env.info.returnResult.checkContext.report(tree.pos(),
2245                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2246             }
2247         }
2248         result = null;
2249     }
2250 
2251     public void visitThrow(JCThrow tree) {
2252         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
</pre>
<hr />
<pre>
2271     public void visitApply(JCMethodInvocation tree) {
2272         // The local environment of a method application is
2273         // a new environment nested in the current one.
2274         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2275 
2276         // The types of the actual method arguments.
2277         List&lt;Type&gt; argtypes;
2278 
2279         // The types of the actual method type arguments.
2280         List&lt;Type&gt; typeargtypes = null;
2281 
2282         Name methName = TreeInfo.name(tree.meth);
2283 
2284         boolean isConstructorCall =
2285             methName == names._this || methName == names._super;
2286 
2287         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2288         if (isConstructorCall) {
2289             // We are seeing a ...this(...) or ...super(...) call.
2290             // Check that this is the first statement in a constructor.
<span class="line-modified">2291             if (checkFirstConstructorStat(tree, env.enclMethod, true)) {</span>
2292 
2293                 // Record the fact
2294                 // that this is a constructor call (using isSelfCall).
2295                 localEnv.info.isSelfCall = true;
2296 
2297                 // Attribute arguments, yielding list of argument types.
2298                 KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2299                 argtypes = argtypesBuf.toList();
2300                 typeargtypes = attribTypes(tree.typeargs, localEnv);
2301 
2302                 // Variable `site&#39; points to the class in which the called
2303                 // constructor is defined.
2304                 Type site = env.enclClass.sym.type;
2305                 if (methName == names._super) {
2306                     if (site == syms.objectType) {
2307                         log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2308                         site = types.createErrorType(syms.objectType);
2309                     } else {
2310                         site = types.supertype(site);
2311                     }
</pre>
<hr />
<pre>
2410                 return new ClassType(restype.getEnclosingType(),
2411                         List.of(new WildcardType(types.erasure(qualifierType),
2412                                 BoundKind.EXTENDS,
2413                                 syms.boundClass)),
2414                         restype.tsym,
2415                         restype.getMetadata());
2416             } else if (msym != null &amp;&amp;
2417                     msym.owner == syms.arrayClass &amp;&amp;
2418                     methodName == names.clone &amp;&amp;
2419                     types.isArray(qualifierType)) {
2420                 // as a special case, array.clone() has a result that is
2421                 // the same as static type of the array being cloned
2422                 return qualifierType;
2423             } else {
2424                 return restype;
2425             }
2426         }
2427 
2428         /** Check that given application node appears as first statement
2429          *  in a constructor call.
<span class="line-modified">2430          *  @param tree          The application node</span>
<span class="line-modified">2431          *  @param enclMethod    The enclosing method of the application.</span>
<span class="line-added">2432          *  @param error         Should an error be issued?</span>
2433          */
<span class="line-modified">2434         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {</span>

2435             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2436                 JCBlock body = enclMethod.body;
2437                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2438                     ((JCExpressionStatement) body.stats.head).expr == tree)
2439                     return true;
2440             }
<span class="line-modified">2441             if (error) {</span>
<span class="line-modified">2442                 log.error(tree.pos(),</span>
<span class="line-added">2443                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));</span>
<span class="line-added">2444             }</span>
2445             return false;
2446         }
2447 
2448         /** Obtain a method type with given argument types.
2449          */
2450         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2451             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2452             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2453         }
2454 
2455     public void visitNewClass(final JCNewClass tree) {
2456         Type owntype = types.createErrorType(tree.type);
2457 
2458         // The local environment of a class creation is
2459         // a new environment nested in the current one.
2460         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2461 
2462         // The anonymous inner class definition of the new expression,
2463         // if one is defined by it.
2464         JCClassDecl cdef = tree.def;
</pre>
<hr />
<pre>
2877      * is &#39;stuck&#39; (see DeferredAttr).
2878      */
2879     @Override
2880     public void visitLambda(final JCLambda that) {
2881         boolean wrongContext = false;
2882         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
2883             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2884                 //lambda only allowed in assignment or method invocation/cast context
2885                 log.error(that.pos(), Errors.UnexpectedLambda);
2886             }
2887             resultInfo = recoveryInfo;
2888             wrongContext = true;
2889         }
2890         //create an environment for attribution of the lambda expression
2891         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
2892         boolean needsRecovery =
2893                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
2894         try {
2895             if (needsRecovery &amp;&amp; isSerializable(pt())) {
2896                 localEnv.info.isSerializable = true;
<span class="line-modified">2897                 localEnv.info.isSerializableLambda = true;</span>
2898             }
<span class="line-added">2899             localEnv.info.isLambda = true;</span>
2900             List&lt;Type&gt; explicitParamTypes = null;
2901             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
2902                 //attribute lambda parameters
2903                 attribStats(that.params, localEnv);
2904                 explicitParamTypes = TreeInfo.types(that.params);
2905             }
2906 
2907             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
2908             Type currentTarget = targetInfo.target;
2909             Type lambdaType = targetInfo.descriptor;
2910 
2911             if (currentTarget.isErroneous()) {
2912                 result = that.type = currentTarget;
2913                 return;
2914             }
2915 
2916             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
2917 
2918             if (lambdaType.hasTag(FORALL)) {
2919                 //lambda expression target desc cannot be a generic method
</pre>
<hr />
<pre>
2993             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
2994 
2995             if (!isSpeculativeRound) {
2996                 //add thrown types as bounds to the thrown types free variables if needed:
2997                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
2998                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
2999                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
3000                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
3001                     }
3002                 }
3003 
3004                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
3005             }
3006             result = wrongContext ? that.type = types.createErrorType(pt())
3007                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
3008         } catch (Types.FunctionDescriptorLookupError ex) {
3009             JCDiagnostic cause = ex.getDiagnostic();
3010             resultInfo.checkContext.report(that, cause);
3011             result = that.type = types.createErrorType(pt());
3012             return;
<span class="line-added">3013         } catch (CompletionFailure cf) {</span>
<span class="line-added">3014             chk.completionError(that.pos(), cf);</span>
3015         } catch (Throwable t) {
3016             //when an unexpected exception happens, avoid attempts to attribute the same tree again
3017             //as that would likely cause the same exception again.
3018             needsRecovery = false;
3019             throw t;
3020         } finally {
3021             localEnv.info.scope.leave();
3022             if (needsRecovery) {
3023                 attribTree(that, env, recoveryInfo);
3024             }
3025         }
3026     }
3027     //where
3028         class TargetInfo {
3029             Type target;
3030             Type descriptor;
3031 
3032             public TargetInfo(Type target, Type descriptor) {
3033                 this.target = target;
3034                 this.descriptor = descriptor;
</pre>
<hr />
<pre>
3090             new PostAttrAnalyzer() {
3091                 @Override
3092                 public void scan(JCTree tree) {
3093                     if (tree == null ||
3094                             (tree.type != null &amp;&amp;
3095                             tree.type == Type.stuckType)) {
3096                         //don&#39;t touch stuck expressions!
3097                         return;
3098                     }
3099                     super.scan(tree);
3100                 }
3101 
3102                 @Override
3103                 public void visitClassDef(JCClassDecl that) {
3104                     // or class declaration trees!
3105                 }
3106 
3107                 public void visitLambda(JCLambda that) {
3108                     // or lambda expressions!
3109                 }
<span class="line-modified">3110             }.scan(tree.body);</span>
3111         }
3112 
3113         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
3114 
3115             @Override
3116             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
3117                 return t.isIntersection() ?
3118                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
3119             }
3120 
3121             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
3122                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
3123                 return ict;
3124             }
3125 
3126             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
3127                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
3128                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
3129                 for (Type i : ict.interfaces_field) {
3130                     if (i.isParameterized()) {
</pre>
<hr />
<pre>
3312                     }
3313                 } else {
3314                     /* if the field is static then we need to create a fake clinit
3315                      * method, this method can later be reused by LTM.
3316                      */
3317                     MethodSymbol clinit = clinits.get(enclClass);
3318                     if (clinit == null) {
3319                         Type clinitType = new MethodType(List.nil(),
3320                                 syms.voidType, List.nil(), syms.methodClass);
3321                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3322                                 names.clinit, clinitType, enclClass);
3323                         clinit.params = List.nil();
3324                         clinits.put(enclClass, clinit);
3325                     }
3326                     newScopeOwner = clinit;
3327                 }
3328                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3329             } else {
3330                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3331             }
<span class="line-modified">3332             lambdaEnv.info.yieldResult = null;</span>
3333             return lambdaEnv;
3334         }
3335 
3336     @Override
3337     public void visitReference(final JCMemberReference that) {
3338         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3339             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3340                 //method reference only allowed in assignment or method invocation/cast context
3341                 log.error(that.pos(), Errors.UnexpectedMref);
3342             }
3343             result = that.type = types.createErrorType(pt());
3344             return;
3345         }
3346         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3347         try {
3348             //attribute member reference qualifier - if this is a constructor
3349             //reference, the expected kind must be a type
3350             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3351 
3352             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
</pre>
<hr />
<pre>
3451                     if (targetError) {
3452                         resultInfo.checkContext.report(that, diag);
3453                     } else {
3454                         log.report(diag);
3455                     }
3456                     result = that.type = types.createErrorType(currentTarget);
3457                     return;
3458                 }
3459             }
3460 
3461             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3462             that.kind = lookupHelper.referenceKind(that.sym);
3463             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3464 
3465             if (desc.getReturnType() == Type.recoveryType) {
3466                 // stop here
3467                 result = that.type = currentTarget;
3468                 return;
3469             }
3470 
<span class="line-modified">3471             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {</span>
3472                 Type enclosingType = exprType.getEnclosingType();
3473                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
<span class="line-modified">3474                     // Check for the existence of an appropriate outer instance</span>
3475                     rs.resolveImplicitThis(that.pos(), env, exprType);
3476                 }
3477             }
3478 
3479             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3480 
3481                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3482                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3483                         that.kind.isUnbound() &amp;&amp;
3484                         lookupHelper.site.isRaw()) {
3485                     chk.checkRaw(that.expr, localEnv);
3486                 }
3487 
3488                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3489                         exprType.getTypeArguments().nonEmpty()) {
3490                     //static ref with class type-args
3491                     log.error(that.expr.pos(),
3492                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3493                                                  Fragments.StaticMrefWithTargs));
3494                     result = that.type = types.createErrorType(currentTarget);
</pre>
<hr />
<pre>
3755 
3756         // Find operator.
3757         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3758         Type owntype = types.createErrorType(tree.type);
3759         if (operator != operators.noOpSymbol &amp;&amp;
3760                 !argtype.isErroneous()) {
3761             owntype = (tree.getTag().isIncOrDecUnaryOp())
3762                 ? tree.arg.type
3763                 : operator.type.getReturnType();
3764             int opc = ((OperatorSymbol)operator).opcode;
3765 
3766             // If the argument is constant, fold it.
3767             if (argtype.constValue() != null) {
3768                 Type ctype = cfolder.fold1(opc, argtype);
3769                 if (ctype != null) {
3770                     owntype = cfolder.coerce(ctype, owntype);
3771                 }
3772             }
3773         }
3774         result = check(tree, owntype, KindSelector.VAL, resultInfo);
<span class="line-added">3775         matchBindings = matchBindingsComputer.unary(tree, matchBindings);</span>
3776     }
3777 
3778     public void visitBinary(JCBinary tree) {
3779         // Attribute arguments.
3780         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
<span class="line-modified">3781         // x &amp;&amp; y</span>
<span class="line-added">3782         // include x&#39;s bindings when true in y</span>
<span class="line-added">3783 </span>
<span class="line-added">3784         // x || y</span>
<span class="line-added">3785         // include x&#39;s bindings when false in y</span>
<span class="line-added">3786 </span>
<span class="line-added">3787         MatchBindings lhsBindings = matchBindings;</span>
<span class="line-added">3788         List&lt;BindingSymbol&gt; propagatedBindings;</span>
<span class="line-added">3789         switch (tree.getTag()) {</span>
<span class="line-added">3790             case AND:</span>
<span class="line-added">3791                 propagatedBindings = lhsBindings.bindingsWhenTrue;</span>
<span class="line-added">3792                 break;</span>
<span class="line-added">3793             case OR:</span>
<span class="line-added">3794                 propagatedBindings = lhsBindings.bindingsWhenFalse;</span>
<span class="line-added">3795                 break;</span>
<span class="line-added">3796             default:</span>
<span class="line-added">3797                 propagatedBindings = List.nil();</span>
<span class="line-added">3798                 break;</span>
<span class="line-added">3799         }</span>
<span class="line-added">3800         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);</span>
<span class="line-added">3801         Type right;</span>
<span class="line-added">3802         try {</span>
<span class="line-added">3803             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));</span>
<span class="line-added">3804         } finally {</span>
<span class="line-added">3805             rhsEnv.info.scope.leave();</span>
<span class="line-added">3806         }</span>
<span class="line-added">3807 </span>
<span class="line-added">3808         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);</span>
<span class="line-added">3809 </span>
3810         // Find operator.
3811         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3812         Type owntype = types.createErrorType(tree.type);
3813         if (operator != operators.noOpSymbol &amp;&amp;
3814                 !left.isErroneous() &amp;&amp;
3815                 !right.isErroneous()) {
3816             owntype = operator.type.getReturnType();
3817             int opc = ((OperatorSymbol)operator).opcode;
3818             // If both arguments are constants, fold them.
3819             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3820                 Type ctype = cfolder.fold2(opc, left, right);
3821                 if (ctype != null) {
3822                     owntype = cfolder.coerce(ctype, owntype);
3823                 }
3824             }
3825 
3826             // Check that argument types of a reference ==, != are
3827             // castable to each other, (JLS 15.21).  Note: unboxing
3828             // comparisons will not have an acmp* opc at this point.
3829             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
</pre>
<hr />
<pre>
3855                 public boolean compatible(Type found, Type req, Warner warn) {
3856                     return types.isCastable(found, req, warn);
3857                 }
3858             });
3859         } else {
3860             //standalone cast - target-type info is not propagated
3861             castInfo = unknownExprInfo;
3862         }
3863         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
3864         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3865         if (exprtype.constValue() != null)
3866             owntype = cfolder.coerce(exprtype, owntype);
3867         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
3868         if (!isPoly)
3869             chk.checkRedundantCast(localEnv, tree);
3870     }
3871 
3872     public void visitTypeTest(JCInstanceOf tree) {
3873         Type exprtype = chk.checkNullOrRefType(
3874                 tree.expr.pos(), attribExpr(tree.expr, env));
<span class="line-modified">3875         Type clazztype;</span>
<span class="line-added">3876         JCTree typeTree;</span>
<span class="line-added">3877         if (tree.pattern.getTag() == BINDINGPATTERN) {</span>
<span class="line-added">3878             attribTree(tree.pattern, env, unknownExprInfo);</span>
<span class="line-added">3879             clazztype = tree.pattern.type;</span>
<span class="line-added">3880             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;</span>
<span class="line-added">3881             typeTree = pattern.vartype;</span>
<span class="line-added">3882             if (!clazztype.hasTag(TYPEVAR)) {</span>
<span class="line-added">3883                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);</span>
<span class="line-added">3884             }</span>
<span class="line-added">3885         } else {</span>
<span class="line-added">3886             clazztype = attribType(tree.pattern, env);</span>
<span class="line-added">3887             typeTree = tree.pattern;</span>
<span class="line-added">3888         }</span>
3889         if (!clazztype.hasTag(TYPEVAR)) {
<span class="line-modified">3890             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);</span>
3891         }
3892         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
<span class="line-modified">3893             boolean valid = false;</span>
<span class="line-modified">3894             if (allowReifiableTypesInInstanceof) {</span>
<span class="line-added">3895                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {</span>
<span class="line-added">3896                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);</span>
<span class="line-added">3897                 }</span>
<span class="line-added">3898                 Warner warner = new Warner();</span>
<span class="line-added">3899                 if (!types.isCastable(exprtype, clazztype, warner)) {</span>
<span class="line-added">3900                     chk.basicHandler.report(tree.expr.pos(),</span>
<span class="line-added">3901                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));</span>
<span class="line-added">3902                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {</span>
<span class="line-added">3903                     log.error(tree.expr.pos(),</span>
<span class="line-added">3904                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));</span>
<span class="line-added">3905                 } else {</span>
<span class="line-added">3906                     valid = true;</span>
<span class="line-added">3907                 }</span>
<span class="line-added">3908             } else {</span>
<span class="line-added">3909                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);</span>
<span class="line-added">3910             }</span>
<span class="line-added">3911             if (!valid) {</span>
<span class="line-added">3912                 clazztype = types.createErrorType(clazztype);</span>
<span class="line-added">3913             }</span>
3914         }
<span class="line-modified">3915         chk.validate(typeTree, env, false);</span>
3916         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3917         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
3918     }
3919 
<span class="line-added">3920     public void visitBindingPattern(JCBindingPattern tree) {</span>
<span class="line-added">3921         ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);</span>
<span class="line-added">3922         tree.type = attribTree(tree.vartype, env, varInfo);</span>
<span class="line-added">3923         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);</span>
<span class="line-added">3924         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {</span>
<span class="line-added">3925             chk.checkTransparentVar(tree.pos(), v, env.info.scope);</span>
<span class="line-added">3926         }</span>
<span class="line-added">3927         annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());</span>
<span class="line-added">3928         annotate.flush();</span>
<span class="line-added">3929         result = tree.type;</span>
<span class="line-added">3930         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());</span>
<span class="line-added">3931     }</span>
<span class="line-added">3932 </span>
3933     public void visitIndexed(JCArrayAccess tree) {
3934         Type owntype = types.createErrorType(tree.type);
3935         Type atype = attribExpr(tree.indexed, env);
3936         attribExpr(tree.index, env, syms.intType);
3937         if (types.isArray(atype))
3938             owntype = types.elemtype(atype);
3939         else if (!atype.hasTag(ERROR))
3940             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
3941         if (!pkind().contains(KindSelector.VAL))
3942             owntype = capture(owntype);
3943         result = check(tree, owntype, KindSelector.VAR, resultInfo);
3944     }
3945 
3946     public void visitIdent(JCIdent tree) {
3947         Symbol sym;
3948 
3949         // Find symbol
3950         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
3951             // If we are looking for a method, the prototype `pt&#39; will be a
3952             // method type with the type of the call&#39;s arguments as parameters.
</pre>
<hr />
<pre>
4000         // if symbol is a field or instance method, check that it is
4001         // not accessed before the supertype constructor is called.
4002         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
4003             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4004             sym.owner.kind == TYP &amp;&amp;
4005             (sym.flags() &amp; STATIC) == 0) {
4006             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
4007                                           sym : thisSym(tree.pos(), env));
4008         }
4009         Env&lt;AttrContext&gt; env1 = env;
4010         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4011             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4012             // If the found symbol is inaccessible, then it is
4013             // accessed through an enclosing instance.  Locate this
4014             // enclosing instance:
4015             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4016                 env1 = env1.outer;
4017         }
4018 
4019         if (env.info.isSerializable) {
<span class="line-modified">4020             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);</span>
4021         }
4022 
4023         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4024     }
4025 
4026     public void visitSelect(JCFieldAccess tree) {
4027         // Determine the expected kind of the qualifier expression.
4028         KindSelector skind = KindSelector.NIL;
4029         if (tree.name == names._this || tree.name == names._super ||
4030                 tree.name == names._class)
4031         {
4032             skind = KindSelector.TYP;
4033         } else {
4034             if (pkind().contains(KindSelector.PCK))
4035                 skind = KindSelector.of(skind, KindSelector.PCK);
4036             if (pkind().contains(KindSelector.TYP))
4037                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4038             if (pkind().contains(KindSelector.VAL_MTH))
4039                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4040         }
</pre>
<hr />
<pre>
4142                    sym.name != names._class) {
4143             // If the qualified item is not a type and the selected item is static, report
4144             // a warning. Make allowance for the class of an array type e.g. Object[].class)
4145             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
4146         }
4147 
4148         // If we are selecting an instance member via a `super&#39;, ...
4149         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
4150 
4151             // Check that super-qualified symbols are not abstract (JLS)
4152             rs.checkNonAbstract(tree.pos(), sym);
4153 
4154             if (site.isRaw()) {
4155                 // Determine argument types for site.
4156                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
4157                 if (site1 != null) site = site1;
4158             }
4159         }
4160 
4161         if (env.info.isSerializable) {
<span class="line-modified">4162             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);</span>
4163         }
4164 
4165         env.info.selectSuper = selectSuperPrev;
4166         result = checkId(tree, site, sym, env, resultInfo);
4167     }
4168     //where
4169         /** Determine symbol referenced by a Select expression,
4170          *
4171          *  @param tree   The select tree.
4172          *  @param site   The type of the selected expression,
4173          *  @param env    The current environment.
4174          *  @param resultInfo The current result.
4175          */
4176         private Symbol selectSym(JCFieldAccess tree,
4177                                  Symbol location,
4178                                  Type site,
4179                                  Env&lt;AttrContext&gt; env,
4180                                  ResultInfo resultInfo) {
4181             DiagnosticPosition pos = tree.pos();
4182             Name name = tree.name;
4183             switch (site.getTag()) {
4184             case PACKAGE:
4185                 return rs.accessBase(
<span class="line-modified">4186                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),</span>
4187                     pos, location, site, name, true);
4188             case ARRAY:
4189             case CLASS:
4190                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4191                     return rs.resolveQualifiedMethod(
4192                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4193                 } else if (name == names._this || name == names._super) {
4194                     return rs.resolveSelf(pos, env, site.tsym, name);
4195                 } else if (name == names._class) {
4196                     // In this case, we have already made sure in
4197                     // visitSelect that qualifier expression is a type.
4198                     return syms.getClassField(site, types);
4199                 } else {
4200                     // We are seeing a plain identifier as selector.
<span class="line-modified">4201                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);</span>
4202                         sym = rs.accessBase(sym, pos, location, site, name, true);
4203                     return sym;
4204                 }
4205             case WILDCARD:
4206                 throw new AssertionError(tree);
4207             case TYPEVAR:
4208                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4209                 // It should only happen during memberEnter/attribBase
<span class="line-modified">4210                 // when determining the super type which *must* be</span>
4211                 // done before attributing the type variables.  In
4212                 // other words, we are seeing this illegal program:
4213                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4214                 Symbol sym = (site.getUpperBound() != null)
4215                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4216                     : null;
4217                 if (sym == null) {
4218                     log.error(pos, Errors.TypeVarCantBeDeref);
4219                     return syms.errSymbol;
4220                 } else {
4221                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4222                         rs.new AccessError(env, site, sym) :
4223                                 sym;
4224                     rs.accessBase(sym2, pos, location, site, name, true);
4225                     return sym;
4226                 }
4227             case ERROR:
4228                 // preserve identifier names through errors
4229                 return types.createErrorType(name, site.tsym, site).tsym;
4230             default:
</pre>
<hr />
<pre>
4385                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4386                         resultInfo.pt.getTypeArguments());
4387                 break;
4388             }
4389             case PCK: case ERR:
4390                 owntype = sym.type;
4391                 break;
4392             default:
4393                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4394                                          &quot; in tree &quot; + tree);
4395             }
4396 
4397             // Emit a `deprecation&#39; warning if symbol is deprecated.
4398             // (for constructors (but not for constructor references), the error
4399             // was given when the constructor was resolved)
4400 
4401             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4402                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4403                 chk.checkSunAPI(tree.pos(), sym);
4404                 chk.checkProfile(tree.pos(), sym);
<span class="line-added">4405                 chk.checkPreview(tree.pos(), sym);</span>
4406             }
4407 
4408             // If symbol is a variable, check that its type and
4409             // kind are compatible with the prototype and protokind.
4410             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4411         }
4412 
4413         /** Check that variable is initialized and evaluate the variable&#39;s
4414          *  initializer, if not yet done. Also check that variable is not
4415          *  referenced before it is defined.
4416          *  @param tree    The tree making up the variable reference.
4417          *  @param env     The current environment.
4418          *  @param v       The variable&#39;s symbol.
4419          */
4420         private void checkInit(JCTree tree,
4421                                Env&lt;AttrContext&gt; env,
4422                                VarSymbol v,
4423                                boolean onlyWarning) {
4424             // A forward reference is diagnosed if the declaration position
4425             // of the variable is greater than the current tree position
</pre>
<hr />
<pre>
4473                         }
4474                         break;
4475                     case METHODDEF:
4476                     case CLASSDEF:
4477                     case TOPLEVEL:
4478                         return null;
4479                 }
4480                 Assert.checkNonNull(env.next);
4481                 env = env.next;
4482             }
4483         }
4484 
4485         /**
4486          * Check for illegal references to static members of enum.  In
4487          * an enum type, constructors and initializers may not
4488          * reference its static members unless they are constant.
4489          *
4490          * @param tree    The tree making up the variable reference.
4491          * @param env     The current environment.
4492          * @param v       The variable&#39;s symbol.
<span class="line-modified">4493          * @jls 8.9 Enum Types</span>
4494          */
4495         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4496             // JLS:
4497             //
4498             // &quot;It is a compile-time error to reference a static field
4499             // of an enum type that is not a compile-time constant
4500             // (15.28) from constructors, instance initializer blocks,
4501             // or instance variable initializer expressions of that
4502             // type. It is a compile-time error for the constructors,
4503             // instance initializer blocks, or instance variable
4504             // initializer expressions of an enum constant e to refer
4505             // to itself or to an enum constant of the same type that
4506             // is declared to the right of e.&quot;
4507             if (isStaticEnumField(v)) {
4508                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4509 
4510                 if (enclClass == null || enclClass.owner == null)
4511                     return;
4512 
4513                 // See if the enclosing class is the enum (or a
</pre>
<hr />
<pre>
5163                     sym.kind != VAR ||
5164                     ((VarSymbol) sym).getConstValue() == null)
5165                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5166             }
5167         }
5168 
5169         // Check for cycles among non-initial constructors.
5170         chk.checkCyclicConstructors(tree);
5171 
5172         // Check for cycles among annotation elements.
5173         chk.checkNonCyclicElements(tree);
5174 
5175         // Check for proper use of serialVersionUID
5176         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5177                 &amp;&amp; isSerializable(c.type)
5178                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5179                 &amp;&amp; !c.isAnonymous()) {
5180             checkSerialVersionUID(tree, c);
5181         }
5182         if (allowTypeAnnos) {
<span class="line-modified">5183             // Correctly organize the positions of the type annotations</span>
5184             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5185 
5186             // Check type annotations applicability rules
5187             validateTypeAnnotations(tree, false);
5188         }
5189     }
5190         // where
5191         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
5192         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
5193             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
5194                 if (types.isSameType(al.head.annotationType.type, t))
5195                     return al.head.pos();
5196             }
5197 
5198             return null;
5199         }
5200 
5201         /** check if a type is a subtype of Serializable, if that is available. */
5202         boolean isSerializable(Type t) {
5203             try {
</pre>
<hr />
<pre>
5304                 scan(tree.defaultValue);
5305                 scan(tree.body);
5306             }
5307         }
5308         public void visitVarDef(final JCVariableDecl tree) {
5309             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5310             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5311                 validateAnnotatedType(tree.vartype, tree.sym.type);
5312             scan(tree.mods);
5313             scan(tree.vartype);
5314             if (!sigOnly) {
5315                 scan(tree.init);
5316             }
5317         }
5318         public void visitTypeCast(JCTypeCast tree) {
5319             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5320                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5321             super.visitTypeCast(tree);
5322         }
5323         public void visitTypeTest(JCInstanceOf tree) {
<span class="line-modified">5324             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)</span>
<span class="line-modified">5325                 validateAnnotatedType(tree.pattern, tree.pattern.type);</span>
5326             super.visitTypeTest(tree);
5327         }
5328         public void visitNewClass(JCNewClass tree) {
5329             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5330                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5331                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5332                             tree.clazz.type.tsym);
5333                 }
5334                 if (tree.def != null) {
5335                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5336                 }
5337 
5338                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5339             }
5340             super.visitNewClass(tree);
5341         }
5342         public void visitNewArray(JCNewArray tree) {
5343             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5344                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5345                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
</pre>
<hr />
<pre>
5473             // Ensure that no declaration annotations are present.
5474             // Note that a tree type might be an AnnotatedType with
5475             // empty annotations, if only declaration annotations were given.
5476             // This method will raise an error for such a type.
5477             for (JCAnnotation ai : annotations) {
5478                 if (!ai.type.isErroneous() &amp;&amp;
5479                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5480                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5481                 }
5482             }
5483         }
5484     }
5485 
5486     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5487 
5488     /**
5489      * Handle missing types/symbols in an AST. This routine is useful when
5490      * the compiler has encountered some errors (which might have ended up
5491      * terminating attribution abruptly); if the compiler is used in fail-over
5492      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
<span class="line-modified">5493      * prevents NPE to be propagated during subsequent compilation steps.</span>
5494      */
5495     public void postAttr(JCTree tree) {
5496         new PostAttrAnalyzer().scan(tree);
5497     }
5498 
5499     class PostAttrAnalyzer extends TreeScanner {
5500 
5501         private void initTypeIfNeeded(JCTree that) {
5502             if (that.type == null) {
5503                 if (that.hasTag(METHODDEF)) {
5504                     that.type = dummyMethodType((JCMethodDecl)that);
5505                 } else {
5506                     that.type = syms.unknownType;
5507                 }
5508             }
5509         }
5510 
5511         /* Construct a dummy method type. If we have a method declaration,
5512          * and the declared return type is void, then use that return type
5513          * instead of UNKNOWN to avoid spurious error messages in lambda
</pre>
<hr />
<pre>
5565             initTypeIfNeeded(that);
5566             if (that.sym == null) {
5567                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5568             }
5569             super.visitMethodDef(that);
5570         }
5571 
5572         @Override
5573         public void visitVarDef(JCVariableDecl that) {
5574             initTypeIfNeeded(that);
5575             if (that.sym == null) {
5576                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5577                 that.sym.adr = 0;
5578             }
5579             if (that.vartype == null) {
5580                 that.vartype = make.at(Position.NOPOS).Erroneous();
5581             }
5582             super.visitVarDef(that);
5583         }
5584 
<span class="line-added">5585         @Override</span>
<span class="line-added">5586         public void visitBindingPattern(JCBindingPattern that) {</span>
<span class="line-added">5587             if (that.symbol == null) {</span>
<span class="line-added">5588                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);</span>
<span class="line-added">5589                 that.symbol.adr = 0;</span>
<span class="line-added">5590             }</span>
<span class="line-added">5591             super.visitBindingPattern(that);</span>
<span class="line-added">5592         }</span>
<span class="line-added">5593 </span>
5594         @Override
5595         public void visitNewClass(JCNewClass that) {
5596             if (that.constructor == null) {
5597                 that.constructor = new MethodSymbol(0, names.init,
5598                         dummyMethodType(), syms.noSymbol);
5599             }
5600             if (that.constructorType == null) {
5601                 that.constructorType = syms.unknownType;
5602             }
5603             super.visitNewClass(that);
5604         }
5605 
5606         @Override
5607         public void visitAssignop(JCAssignOp that) {
5608             if (that.operator == null) {
5609                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5610                         -1, syms.noSymbol);
5611             }
5612             super.visitAssignop(that);
5613         }
</pre>
</td>
</tr>
</table>
<center><a href="ArgumentAttr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttrContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
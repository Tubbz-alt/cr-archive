<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/sjavac/CompileJavaPackages.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../javac/util/RichDiagnosticFormatter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavacState.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/sjavac/CompileJavaPackages.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
162                 sourcesPerCompile = numSources;
163                 Log.debug(&quot;Compiling as a single source code chunk to stay within heap size limitations!&quot;);
164             } else if (sourcesPerCompile &gt; 500) {
165                 // This number is very low, and tuned to dealing with the OpenJDK
166                 // where the source is &gt;very&lt; circular! In normal application,
167                 // with less circularity the number could perhaps be increased.
168                 numCompiles = numSources / 500;
169                 sourcesPerCompile = numSources/numCompiles;
170                 Log.debug(&quot;Compiling source as &quot;+numCompiles+&quot; code chunks serially to stay within heap size limitations!&quot;);
171             }
172         } else {
173             if (numCompiles &gt; 1) {
174                 // Ok, we can fit at least one full compilation on the heap.
175                 float usagePerCompile = (float)numRequiredMBytes / ((float)numCompiles * (float)0.7);
176                 int usage = (int)(usagePerCompile * (float)numCompiles);
177                 Log.debug(&quot;Heuristics say that for &quot;+numCompiles+&quot; concurrent compiles we need &quot;+usage+&quot;MiB&quot;);
178                 if (usage &gt; numMBytes) {
179                     // Ouch it does not fit. Reduce to a single chunk.
180                     numCompiles = 1;
181                     sourcesPerCompile = numSources;
<span class="line-modified">182                     // What if the relationship betweem number of compile_chunks and num_required_mbytes</span>
183                     // is not linear? Then perhaps 2 chunks would fit where 3 does not. Well, this is
184                     // something to experiment upon in the future.
185                     Log.debug(&quot;Limiting compile to a single thread to stay within heap size limitations!&quot;);
186                 }
187             }
188         }
189 
190         Log.debug(&quot;Compiling sources in &quot;+numCompiles+&quot; chunk(s)&quot;);
191 
192         // Create the chunks to be compiled.
193         final CompileChunk[] compileChunks = createCompileChunks(pkgSrcs, oldPackageDependents,
194                 numCompiles, sourcesPerCompile);
195 
196         if (Log.isDebugging()) {
197             int cn = 1;
198             for (CompileChunk cc : compileChunks) {
199                 Log.debug(&quot;Chunk &quot;+cn+&quot; for &quot;+id+&quot; ---------------&quot;);
200                 cn++;
201                 for (URI u : cc.srcs) {
202                     Log.debug(&quot;&quot;+u);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
162                 sourcesPerCompile = numSources;
163                 Log.debug(&quot;Compiling as a single source code chunk to stay within heap size limitations!&quot;);
164             } else if (sourcesPerCompile &gt; 500) {
165                 // This number is very low, and tuned to dealing with the OpenJDK
166                 // where the source is &gt;very&lt; circular! In normal application,
167                 // with less circularity the number could perhaps be increased.
168                 numCompiles = numSources / 500;
169                 sourcesPerCompile = numSources/numCompiles;
170                 Log.debug(&quot;Compiling source as &quot;+numCompiles+&quot; code chunks serially to stay within heap size limitations!&quot;);
171             }
172         } else {
173             if (numCompiles &gt; 1) {
174                 // Ok, we can fit at least one full compilation on the heap.
175                 float usagePerCompile = (float)numRequiredMBytes / ((float)numCompiles * (float)0.7);
176                 int usage = (int)(usagePerCompile * (float)numCompiles);
177                 Log.debug(&quot;Heuristics say that for &quot;+numCompiles+&quot; concurrent compiles we need &quot;+usage+&quot;MiB&quot;);
178                 if (usage &gt; numMBytes) {
179                     // Ouch it does not fit. Reduce to a single chunk.
180                     numCompiles = 1;
181                     sourcesPerCompile = numSources;
<span class="line-modified">182                     // What if the relationship between number of compile_chunks and num_required_mbytes</span>
183                     // is not linear? Then perhaps 2 chunks would fit where 3 does not. Well, this is
184                     // something to experiment upon in the future.
185                     Log.debug(&quot;Limiting compile to a single thread to stay within heap size limitations!&quot;);
186                 }
187             }
188         }
189 
190         Log.debug(&quot;Compiling sources in &quot;+numCompiles+&quot; chunk(s)&quot;);
191 
192         // Create the chunks to be compiled.
193         final CompileChunk[] compileChunks = createCompileChunks(pkgSrcs, oldPackageDependents,
194                 numCompiles, sourcesPerCompile);
195 
196         if (Log.isDebugging()) {
197             int cn = 1;
198             for (CompileChunk cc : compileChunks) {
199                 Log.debug(&quot;Chunk &quot;+cn+&quot; for &quot;+id+&quot; ---------------&quot;);
200                 cn++;
201                 for (URI u : cc.srcs) {
202                     Log.debug(&quot;&quot;+u);
</pre>
</td>
</tr>
</table>
<center><a href="../javac/util/RichDiagnosticFormatter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JavacState.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
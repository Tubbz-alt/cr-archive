<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/main/Arguments.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.main;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Files;
 30 import java.nio.file.Path;
 31 import java.nio.file.Paths;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.EnumSet;
 35 import java.util.HashSet;
 36 import java.util.Iterator;
 37 import java.util.LinkedHashMap;
 38 import java.util.LinkedHashSet;
 39 import java.util.Map;
 40 import java.util.Set;
 41 import java.util.function.Predicate;
 42 import java.util.regex.Matcher;
 43 import java.util.regex.Pattern;
 44 import java.util.stream.Stream;
 45 
 46 import javax.lang.model.SourceVersion;
 47 import javax.tools.JavaFileManager;
 48 import javax.tools.JavaFileManager.Location;
 49 import javax.tools.JavaFileObject;
 50 import javax.tools.JavaFileObject.Kind;
 51 import javax.tools.StandardJavaFileManager;
 52 import javax.tools.StandardLocation;
 53 
 54 import com.sun.tools.doclint.DocLint;
 55 import com.sun.tools.javac.code.Lint.LintCategory;
 56 import com.sun.tools.javac.code.Source;
 57 import com.sun.tools.javac.file.BaseFileManager;
 58 import com.sun.tools.javac.file.JavacFileManager;
 59 import com.sun.tools.javac.jvm.Profile;
 60 import com.sun.tools.javac.jvm.Target;
 61 import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
 62 import com.sun.tools.javac.platform.PlatformDescription;
 63 import com.sun.tools.javac.platform.PlatformUtils;
 64 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 65 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 66 import com.sun.tools.javac.util.Context;
 67 import com.sun.tools.javac.util.JCDiagnostic;
 68 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticInfo;
 69 import com.sun.tools.javac.util.List;
 70 import com.sun.tools.javac.util.ListBuffer;
 71 import com.sun.tools.javac.util.Log;
 72 import com.sun.tools.javac.util.Log.PrefixKind;
 73 import com.sun.tools.javac.util.Log.WriterKind;
 74 import com.sun.tools.javac.util.Options;
 75 import com.sun.tools.javac.util.PropagatedException;
 76 
 77 /**
 78  * Shared option and argument handling for command line and API usage of javac.
 79  */
 80 public class Arguments {
 81 
 82     /**
 83      * The context key for the arguments.
 84      */
 85     public static final Context.Key&lt;Arguments&gt; argsKey = new Context.Key&lt;&gt;();
 86 
 87     private String ownName;
 88     private Set&lt;String&gt; classNames;
 89     private Set&lt;Path&gt; files;
 90     private Map&lt;Option, String&gt; deferredFileManagerOptions;
 91     private Set&lt;JavaFileObject&gt; fileObjects;
 92     private boolean emptyAllowed;
 93     private final Options options;
 94 
 95     private JavaFileManager fileManager;
 96     private final Log log;
 97     private final Context context;
 98 
 99     private enum ErrorMode { ILLEGAL_ARGUMENT, ILLEGAL_STATE, LOG };
100     private ErrorMode errorMode;
101     private boolean errors;
102 
103     /**
104      * Gets the Arguments instance for this context.
105      *
106      * @param context the content
107      * @return the Arguments instance for this context.
108      */
109     public static Arguments instance(Context context) {
110         Arguments instance = context.get(argsKey);
111         if (instance == null) {
112             instance = new Arguments(context);
113         }
114         return instance;
115     }
116 
117     protected Arguments(Context context) {
118         context.put(argsKey, this);
119         options = Options.instance(context);
120         log = Log.instance(context);
121         this.context = context;
122 
123         // Ideally, we could init this here and update/configure it as
124         // needed, but right now, initializing a file manager triggers
125         // initialization of other items in the context, such as Lint
126         // and FSInfo, which should not be initialized until after
127         // processArgs
128         //        fileManager = context.get(JavaFileManager.class);
129     }
130 
131     private final OptionHelper cmdLineHelper = new OptionHelper() {
132         @Override
133         public String get(Option option) {
134             return options.get(option);
135         }
136 
137         @Override
138         public void put(String name, String value) {
139             options.put(name, value);
140         }
141 
142         @Override
143         public void remove(String name) {
144             options.remove(name);
145         }
146 
147         @Override
148         public boolean handleFileManagerOption(Option option, String value) {
149             options.put(option, value);
150             deferredFileManagerOptions.put(option, value);
151             return true;
152         }
153 
154         @Override
155         public Log getLog() {
156             return log;
157         }
158 
159         @Override
160         public String getOwnName() {
161             return ownName;
162         }
163 
164         @Override
165         public void addFile(Path p) {
166             files.add(p);
167         }
168 
169         @Override
170         public void addClassName(String s) {
171             classNames.add(s);
172         }
173 
174     };
175 
176     /**
177      * Initializes this Args instance with a set of command line args.
178      * The args will be processed in conjunction with the full set of
179      * command line options, including -help, -version etc.
180      * The args may also contain class names and filenames.
181      * Any errors during this call, and later during validate, will be reported
182      * to the log.
183      * @param ownName the name of this tool; used to prefix messages
184      * @param args the args to be processed
185      */
186     public void init(String ownName, String... args) {
187         this.ownName = ownName;
188         errorMode = ErrorMode.LOG;
189         files = new LinkedHashSet&lt;&gt;();
190         deferredFileManagerOptions = new LinkedHashMap&lt;&gt;();
191         fileObjects = null;
192         classNames = new LinkedHashSet&lt;&gt;();
193         processArgs(List.from(args), Option.getJavaCompilerOptions(), cmdLineHelper, true, false);
194         if (errors) {
195             log.printLines(PrefixKind.JAVAC, &quot;msg.usage&quot;, ownName);
196         }
197     }
198 
199     private final OptionHelper apiHelper = new GrumpyHelper(null) {
200         @Override
201         public String get(Option option) {
202             return options.get(option);
203         }
204 
205         @Override
206         public void put(String name, String value) {
207             options.put(name, value);
208         }
209 
210         @Override
211         public void remove(String name) {
212             options.remove(name);
213         }
214 
215         @Override
216         public Log getLog() {
217             return Arguments.this.log;
218         }
219     };
220 
221     /**
222      * Initializes this Args instance with the parameters for a JavacTask.
223      * The options will be processed in conjunction with the restricted set
224      * of tool options, which does not include -help, -version, etc,
225      * nor does it include classes and filenames, which should be specified
226      * separately.
227      * File manager options are handled directly by the file manager.
228      * Any errors found while processing individual args will be reported
229      * via IllegalArgumentException.
230      * Any subsequent errors during validate will be reported via IllegalStateException.
231      * @param ownName the name of this tool; used to prefix messages
232      * @param options the options to be processed
233      * @param classNames the classes to be subject to annotation processing
234      * @param files the files to be compiled
235      */
236     public void init(String ownName,
237             Iterable&lt;String&gt; options,
238             Iterable&lt;String&gt; classNames,
239             Iterable&lt;? extends JavaFileObject&gt; files) {
240         this.ownName = ownName;
241         this.classNames = toSet(classNames);
242         this.fileObjects = toSet(files);
243         this.files = null;
244         errorMode = ErrorMode.ILLEGAL_ARGUMENT;
245         if (options != null) {
246             processArgs(toList(options), Option.getJavacToolOptions(), apiHelper, false, true);
247         }
248         errorMode = ErrorMode.ILLEGAL_STATE;
249     }
250 
251     /**
252      * Minimal initialization for tools, like javadoc,
253      * to be able to process javac options for themselves,
254      * and then call validate.
255      * @param ownName  the name of this tool; used to prefix messages
256      */
257     public void init(String ownName) {
258         this.ownName = ownName;
259         errorMode = ErrorMode.LOG;
260     }
261 
262     /**
263      * Gets the files to be compiled.
264      * @return the files to be compiled
265      */
266     public Set&lt;JavaFileObject&gt; getFileObjects() {
267         if (fileObjects == null) {
268             fileObjects = new LinkedHashSet&lt;&gt;();
269         }
270         if (files != null) {
271             JavacFileManager jfm = (JavacFileManager) getFileManager();
272             for (JavaFileObject fo: jfm.getJavaFileObjectsFromPaths(files))
273                 fileObjects.add(fo);
274         }
275         return fileObjects;
276     }
277 
278     /**
279      * Gets the classes to be subject to annotation processing.
280      * @return the classes to be subject to annotation processing
281      */
282     public Set&lt;String&gt; getClassNames() {
283         return classNames;
284     }
285 
286     /**
287      * Handles the {@code --release} option.
288      *
289      * @param additionalOptions a predicate to handle additional options implied by the
290      * {@code --release} option. The predicate should return true if all the additional
291      * options were processed successfully.
292      * @return true if successful, false otherwise
293      */
294     public boolean handleReleaseOptions(Predicate&lt;Iterable&lt;String&gt;&gt; additionalOptions) {
295         String platformString = options.get(Option.RELEASE);
296 
297         checkOptionAllowed(platformString == null,
298                 option -&gt; reportDiag(Errors.ReleaseBootclasspathConflict(option)),
299                 Option.BOOT_CLASS_PATH, Option.XBOOTCLASSPATH, Option.XBOOTCLASSPATH_APPEND,
300                 Option.XBOOTCLASSPATH_PREPEND,
301                 Option.ENDORSEDDIRS, Option.DJAVA_ENDORSED_DIRS,
302                 Option.EXTDIRS, Option.DJAVA_EXT_DIRS,
303                 Option.SOURCE, Option.TARGET,
304                 Option.SYSTEM, Option.UPGRADE_MODULE_PATH);
305 
306         if (platformString != null) {
307             PlatformDescription platformDescription =
308                     PlatformUtils.lookupPlatformDescription(platformString);
309 
310             if (platformDescription == null) {
311                 reportDiag(Errors.UnsupportedReleaseVersion(platformString));
312                 return false;
313             }
314 
315             options.put(Option.SOURCE, platformDescription.getSourceVersion());
316             options.put(Option.TARGET, platformDescription.getTargetVersion());
317 
318             context.put(PlatformDescription.class, platformDescription);
319 
320             if (!additionalOptions.test(platformDescription.getAdditionalOptions()))
321                 return false;
322 
323             JavaFileManager platformFM = platformDescription.getFileManager();
324             DelegatingJavaFileManager.installReleaseFileManager(context,
325                                                                 platformFM,
326                                                                 getFileManager());
327         }
328 
329         return true;
330     }
331 
332     /**
333      * Processes strings containing options and operands.
334      * @param args the strings to be processed
335      * @param allowableOpts the set of option declarations that are applicable
336      * @param helper a help for use by Option.process
337      * @param allowOperands whether or not to check for files and classes
338      * @param checkFileManager whether or not to check if the file manager can handle
339      *      options which are not recognized by any of allowableOpts
340      * @return true if all the strings were successfully processed; false otherwise
341      * @throws IllegalArgumentException if a problem occurs and errorMode is set to
342      *      ILLEGAL_ARGUMENT
343      */
344     private boolean processArgs(Iterable&lt;String&gt; args,
345             Set&lt;Option&gt; allowableOpts, OptionHelper helper,
346             boolean allowOperands, boolean checkFileManager) {
347         if (!doProcessArgs(args, allowableOpts, helper, allowOperands, checkFileManager))
348             return false;
349 
350         if (!handleReleaseOptions(extra -&gt; doProcessArgs(extra, allowableOpts, helper, allowOperands, checkFileManager)))
351             return false;
352 
353         options.notifyListeners();
354 
355         return true;
356     }
357 
358     private boolean doProcessArgs(Iterable&lt;String&gt; args,
359             Set&lt;Option&gt; allowableOpts, OptionHelper helper,
360             boolean allowOperands, boolean checkFileManager) {
361         JavaFileManager fm = checkFileManager ? getFileManager() : null;
362         Iterator&lt;String&gt; argIter = args.iterator();
363         while (argIter.hasNext()) {
364             String arg = argIter.next();
365             if (arg.isEmpty()) {
366                 reportDiag(Errors.InvalidFlag(arg));
367                 return false;
368             }
369 
370             Option option = null;
371 
372             // first, check the provided set of javac options
373             if (arg.startsWith(&quot;-&quot;)) {
374                 option = Option.lookup(arg, allowableOpts);
375             } else if (allowOperands &amp;&amp; Option.SOURCEFILE.matches(arg)) {
376                 option = Option.SOURCEFILE;
377             }
378 
379             if (option != null) {
380                 try {
381                     option.handleOption(helper, arg, argIter);
382                 } catch (Option.InvalidValueException e) {
383                     error(e);
384                     return false;
385                 }
386                 continue;
387             }
388 
389             // check file manager option
390             if (fm != null &amp;&amp; fm.handleOption(arg, argIter)) {
391                 continue;
392             }
393 
394             // none of the above
395             reportDiag(Errors.InvalidFlag(arg));
396             return false;
397         }
398 
399         return true;
400     }
401 
402     /**
403      * Validates the overall consistency of the options and operands
404      * processed by processOptions.
405      * @return true if all args are successfully validated; false otherwise.
406      * @throws IllegalStateException if a problem is found and errorMode is set to
407      *      ILLEGAL_STATE
408      */
409     public boolean validate() {
410         JavaFileManager fm = getFileManager();
411         if (options.isSet(Option.MODULE)) {
412             if (!fm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
413                 log.error(Errors.OutputDirMustBeSpecifiedWithDashMOption);
414             } else if (!fm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
415                 log.error(Errors.ModulesourcepathMustBeSpecifiedWithDashMOption);
416             } else {
417                 java.util.List&lt;String&gt; modules = Arrays.asList(options.get(Option.MODULE).split(&quot;,&quot;));
418                 try {
419                     for (String module : modules) {
420                         Location sourceLoc = fm.getLocationForModule(StandardLocation.MODULE_SOURCE_PATH, module);
421                         if (sourceLoc == null) {
422                             log.error(Errors.ModuleNotFoundInModuleSourcePath(module));
423                         } else {
424                             Location classLoc = fm.getLocationForModule(StandardLocation.CLASS_OUTPUT, module);
425 
426                             for (JavaFileObject file : fm.list(sourceLoc, &quot;&quot;, EnumSet.of(JavaFileObject.Kind.SOURCE), true)) {
427                                 String className = fm.inferBinaryName(sourceLoc, file);
428                                 JavaFileObject classFile = fm.getJavaFileForInput(classLoc, className, Kind.CLASS);
429 
430                                 if (classFile == null || classFile.getLastModified() &lt; file.getLastModified()) {
431                                     if (fileObjects == null)
432                                         fileObjects = new HashSet&lt;&gt;();
433                                     fileObjects.add(file);
434                                 }
435                             }
436                         }
437                     }
438                 } catch (IOException ex) {
439                     log.printLines(PrefixKind.JAVAC, &quot;msg.io&quot;);
440                     ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
441                     return false;
442                 }
443             }
444         }
445 
446         if (isEmpty()) {
447             // It is allowed to compile nothing if just asking for help or version info.
448             // But also note that none of these options are supported in API mode.
449             if (options.isSet(Option.HELP)
450                     || options.isSet(Option.X)
451                     || options.isSet(Option.VERSION)
452                     || options.isSet(Option.FULLVERSION)
453                     || options.isSet(Option.MODULE)) {
454                 return true;
455             }
456 
457             if (!emptyAllowed) {
458                 if (!errors) {
459                     if (JavaCompiler.explicitAnnotationProcessingRequested(options)) {
460                         reportDiag(Errors.NoSourceFilesClasses);
461                     } else {
462                         reportDiag(Errors.NoSourceFiles);
463                     }
464                 }
465                 return false;
466             }
467         }
468 
469         if (!checkDirectory(Option.D)) {
470             return false;
471         }
472         if (!checkDirectory(Option.S)) {
473             return false;
474         }
475         if (!checkDirectory(Option.H)) {
476             return false;
477         }
478 
479         // The following checks are to help avoid accidental confusion between
480         // directories of modules and exploded module directories.
481         if (fm instanceof StandardJavaFileManager) {
482             StandardJavaFileManager sfm = (StandardJavaFileManager) fileManager;
483             if (sfm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
484                 Path outDir = sfm.getLocationAsPaths(StandardLocation.CLASS_OUTPUT).iterator().next();
485                 if (sfm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
486                     // multi-module mode
487                     if (Files.exists(outDir.resolve(&quot;module-info.class&quot;))) {
488                         log.error(Errors.MultiModuleOutdirCannotBeExplodedModule(outDir));
489                     }
490                 } else {
491                     // single-module or legacy mode
492                     boolean lintPaths = options.isUnset(Option.XLINT_CUSTOM,
493                             &quot;-&quot; + LintCategory.PATH.option);
494                     if (lintPaths) {
495                         Path outDirParent = outDir.getParent();
496                         if (outDirParent != null &amp;&amp; Files.exists(outDirParent.resolve(&quot;module-info.class&quot;))) {
497                             log.warning(LintCategory.PATH, Warnings.OutdirIsInExplodedModule(outDir));
498                         }
499                     }
500                 }
501             }
502         }
503 
504 
505         String sourceString = options.get(Option.SOURCE);
506         Source source = (sourceString != null)
507                 ? Source.lookup(sourceString)
508                 : Source.DEFAULT;
509         String targetString = options.get(Option.TARGET);
510         Target target = (targetString != null)
511                 ? Target.lookup(targetString)
512                 : Target.DEFAULT;
513 
514         // We don&#39;t check source/target consistency for CLDC, as J2ME
515         // profiles are not aligned with J2SE targets; moreover, a
516         // single CLDC target may have many profiles.  In addition,
517         // this is needed for the continued functioning of the JSR14
518         // prototype.
519         if (Character.isDigit(target.name.charAt(0))) {
520             if (target.compareTo(source.requiredTarget()) &lt; 0) {
521                 if (targetString != null) {
522                     if (sourceString == null) {
523                         reportDiag(Warnings.TargetDefaultSourceConflict(targetString, source.requiredTarget()));
524                     } else {
525                         reportDiag(Warnings.SourceTargetConflict(sourceString, source.requiredTarget()));
526                     }
527                     return false;
528                 } else {
529                     target = source.requiredTarget();
530                     options.put(&quot;-target&quot;, target.name);
531                 }
532             }
533         }
534 
535         if (options.isSet(Option.PREVIEW)) {
536             if (sourceString == null) {
537                 //enable-preview must be used with explicit -source or --release
538                 report(Errors.PreviewWithoutSourceOrRelease);
539                 return false;
540             } else if (source != Source.DEFAULT) {
541                 //enable-preview must be used with latest source version
542                 report(Errors.PreviewNotLatest(sourceString, Source.DEFAULT));
543                 return false;
544             }
545         }
546 
547         String profileString = options.get(Option.PROFILE);
548         if (profileString != null) {
549             Profile profile = Profile.lookup(profileString);
550             if (!profile.isValid(target)) {
551                 reportDiag(Warnings.ProfileTargetConflict(profile, target));
552             }
553 
554             // This check is only effective in command line mode,
555             // where the file manager options are added to options
556             if (options.get(Option.BOOT_CLASS_PATH) != null) {
557                 reportDiag(Errors.ProfileBootclasspathConflict);
558             }
559         }
560 
561         if (options.isSet(Option.SOURCE_PATH) &amp;&amp; options.isSet(Option.MODULE_SOURCE_PATH)) {
562             reportDiag(Errors.SourcepathModulesourcepathConflict);
563         }
564 
565         boolean lintOptions = options.isUnset(Option.XLINT_CUSTOM, &quot;-&quot; + LintCategory.OPTIONS.option);
566         if (lintOptions &amp;&amp; source.compareTo(Source.DEFAULT) &lt; 0 &amp;&amp; !options.isSet(Option.RELEASE)) {
567             if (fm instanceof BaseFileManager) {
<a name="1" id="anc1"></a><span class="line-modified">568                 if (((BaseFileManager) fm).isDefaultBootClassPath())</span>
<span class="line-modified">569                     log.warning(LintCategory.OPTIONS, Warnings.SourceNoBootclasspath(source.name));</span>





570             }
571         }
572 
573         boolean obsoleteOptionFound = false;
574 
575         if (source.compareTo(Source.MIN) &lt; 0) {
576             log.error(Errors.OptionRemovedSource(source.name, Source.MIN.name));
577         } else if (source == Source.MIN &amp;&amp; lintOptions) {
578             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSource(source.name));
579             obsoleteOptionFound = true;
580         }
581 
582         if (target.compareTo(Target.MIN) &lt; 0) {
583             log.error(Errors.OptionRemovedTarget(target, Target.MIN));
584         } else if (target == Target.MIN &amp;&amp; lintOptions) {
585             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteTarget(target));
586             obsoleteOptionFound = true;
587         }
588 
589         final Target t = target;
590         checkOptionAllowed(t.compareTo(Target.JDK1_8) &lt;= 0,
591                 option -&gt; reportDiag(Errors.OptionNotAllowedWithTarget(option, t)),
592                 Option.BOOT_CLASS_PATH,
593                 Option.XBOOTCLASSPATH_PREPEND, Option.XBOOTCLASSPATH, Option.XBOOTCLASSPATH_APPEND,
594                 Option.ENDORSEDDIRS, Option.DJAVA_ENDORSED_DIRS,
595                 Option.EXTDIRS, Option.DJAVA_EXT_DIRS,
596                 Option.PROFILE);
597 
598         checkOptionAllowed(t.compareTo(Target.JDK1_9) &gt;= 0,
599                 option -&gt; reportDiag(Errors.OptionNotAllowedWithTarget(option, t)),
600                 Option.MODULE_SOURCE_PATH, Option.UPGRADE_MODULE_PATH,
601                 Option.SYSTEM, Option.MODULE_PATH, Option.ADD_MODULES,
602                 Option.ADD_EXPORTS, Option.ADD_OPENS, Option.ADD_READS,
603                 Option.LIMIT_MODULES,
604                 Option.PATCH_MODULE);
605 
606         if (lintOptions &amp;&amp; options.isSet(Option.PARAMETERS) &amp;&amp; !target.hasMethodParameters()) {
607             log.warning(Warnings.OptionParametersUnsupported(target, Target.JDK1_8));
608         }
609 
610         if (fm.hasLocation(StandardLocation.MODULE_SOURCE_PATH)) {
611             if (!options.isSet(Option.PROC, &quot;only&quot;)
612                     &amp;&amp; !fm.hasLocation(StandardLocation.CLASS_OUTPUT)) {
613                 log.error(Errors.NoOutputDir);
614             }
615         }
616 
617         if (fm.hasLocation(StandardLocation.ANNOTATION_PROCESSOR_MODULE_PATH) &amp;&amp;
618             fm.hasLocation(StandardLocation.ANNOTATION_PROCESSOR_PATH)) {
619             log.error(Errors.ProcessorpathNoProcessormodulepath);
620         }
621 
622         if (obsoleteOptionFound &amp;&amp; lintOptions) {
623             log.warning(LintCategory.OPTIONS, Warnings.OptionObsoleteSuppression);
624         }
625 
626         SourceVersion sv = Source.toSourceVersion(source);
627         validateAddExports(sv);
628         validateAddModules(sv);
629         validateAddReads(sv);
630         validateLimitModules(sv);
631         validateDefaultModuleForCreatedFiles(sv);
632 
633         if (lintOptions &amp;&amp; options.isSet(Option.ADD_OPENS)) {
634             log.warning(LintCategory.OPTIONS, Warnings.AddopensIgnored);
635         }
636 
637         return !errors &amp;&amp; (log.nerrors == 0);
638     }
639 
640     private void validateAddExports(SourceVersion sv) {
641         String addExports = options.get(Option.ADD_EXPORTS);
642         if (addExports != null) {
643             // Each entry must be of the form sourceModule/sourcePackage=target-list where
644             // target-list is a comma separated list of module or ALL-UNNAMED.
645             // Empty items in the target-list are ignored.
646             // There must be at least one item in the list; this is handled in Option.ADD_EXPORTS.
647             Pattern p = Option.ADD_EXPORTS.getPattern();
648             for (String e : addExports.split(&quot;\0&quot;)) {
649                 Matcher m = p.matcher(e);
650                 if (m.matches()) {
651                     String sourceModuleName = m.group(1);
652                     if (!SourceVersion.isName(sourceModuleName, sv)) {
653                         // syntactically invalid source name:  e.g. --add-exports m!/p1=m2
654                         log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, sourceModuleName));
655                     }
656                     String sourcePackageName = m.group(2);
657                     if (!SourceVersion.isName(sourcePackageName, sv)) {
658                         // syntactically invalid source name:  e.g. --add-exports m1/p!=m2
659                         log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, sourcePackageName));
660                     }
661 
662                     String targetNames = m.group(3);
663                     for (String targetName : targetNames.split(&quot;,&quot;)) {
664                         switch (targetName) {
665                             case &quot;&quot;:
666                             case &quot;ALL-UNNAMED&quot;:
667                                 break;
668 
669                             default:
670                                 if (!SourceVersion.isName(targetName, sv)) {
671                                     // syntactically invalid target name:  e.g. --add-exports m1/p1=m!
672                                     log.warning(Warnings.BadNameForOption(Option.ADD_EXPORTS, targetName));
673                                 }
674                                 break;
675                         }
676                     }
677                 }
678             }
679         }
680     }
681 
682     private void validateAddReads(SourceVersion sv) {
683         String addReads = options.get(Option.ADD_READS);
684         if (addReads != null) {
685             // Each entry must be of the form source=target-list where target-list is a
686             // comma-separated list of module or ALL-UNNAMED.
687             // Empty items in the target list are ignored.
688             // There must be at least one item in the list; this is handled in Option.ADD_READS.
689             Pattern p = Option.ADD_READS.getPattern();
690             for (String e : addReads.split(&quot;\0&quot;)) {
691                 Matcher m = p.matcher(e);
692                 if (m.matches()) {
693                     String sourceName = m.group(1);
694                     if (!SourceVersion.isName(sourceName, sv)) {
695                         // syntactically invalid source name:  e.g. --add-reads m!=m2
696                         log.warning(Warnings.BadNameForOption(Option.ADD_READS, sourceName));
697                     }
698 
699                     String targetNames = m.group(2);
700                     for (String targetName : targetNames.split(&quot;,&quot;, -1)) {
701                         switch (targetName) {
702                             case &quot;&quot;:
703                             case &quot;ALL-UNNAMED&quot;:
704                                 break;
705 
706                             default:
707                                 if (!SourceVersion.isName(targetName, sv)) {
708                                     // syntactically invalid target name:  e.g. --add-reads m1=m!
709                                     log.warning(Warnings.BadNameForOption(Option.ADD_READS, targetName));
710                                 }
711                                 break;
712                         }
713                     }
714                 }
715             }
716         }
717     }
718 
719     private void validateAddModules(SourceVersion sv) {
720         String addModules = options.get(Option.ADD_MODULES);
721         if (addModules != null) {
722             // Each entry must be of the form target-list where target-list is a
723             // comma separated list of module names, or ALL-DEFAULT, ALL-SYSTEM,
724             // or ALL-MODULE_PATH.
725             // Empty items in the target list are ignored.
726             // There must be at least one item in the list; this is handled in Option.ADD_MODULES.
727             for (String moduleName : addModules.split(&quot;,&quot;)) {
728                 switch (moduleName) {
729                     case &quot;&quot;:
730                     case &quot;ALL-SYSTEM&quot;:
731                     case &quot;ALL-MODULE-PATH&quot;:
732                         break;
733 
734                     default:
735                         if (!SourceVersion.isName(moduleName, sv)) {
736                             // syntactically invalid module name:  e.g. --add-modules m1,m!
737                             log.error(Errors.BadNameForOption(Option.ADD_MODULES, moduleName));
738                         }
739                         break;
740                 }
741             }
742         }
743     }
744 
745     private void validateLimitModules(SourceVersion sv) {
746         String limitModules = options.get(Option.LIMIT_MODULES);
747         if (limitModules != null) {
748             // Each entry must be of the form target-list where target-list is a
749             // comma separated list of module names, or ALL-DEFAULT, ALL-SYSTEM,
750             // or ALL-MODULE_PATH.
751             // Empty items in the target list are ignored.
752             // There must be at least one item in the list; this is handled in Option.LIMIT_EXPORTS.
753             for (String moduleName : limitModules.split(&quot;,&quot;)) {
754                 switch (moduleName) {
755                     case &quot;&quot;:
756                         break;
757 
758                     default:
759                         if (!SourceVersion.isName(moduleName, sv)) {
760                             // syntactically invalid module name:  e.g. --limit-modules m1,m!
761                             log.error(Errors.BadNameForOption(Option.LIMIT_MODULES, moduleName));
762                         }
763                         break;
764                 }
765             }
766         }
767     }
768 
769     private void validateDefaultModuleForCreatedFiles(SourceVersion sv) {
770         String moduleName = options.get(Option.DEFAULT_MODULE_FOR_CREATED_FILES);
771         if (moduleName != null) {
772             if (!SourceVersion.isName(moduleName, sv)) {
773                 // syntactically invalid module name:  e.g. --default-module-for-created-files m!
774                 log.error(Errors.BadNameForOption(Option.DEFAULT_MODULE_FOR_CREATED_FILES,
775                                                   moduleName));
776             }
777         }
778     }
779 
780     /**
781      * Returns true if there are no files or classes specified for use.
782      * @return true if there are no files or classes specified for use
783      */
784     public boolean isEmpty() {
785         return ((files == null) || files.isEmpty())
786                 &amp;&amp; ((fileObjects == null) || fileObjects.isEmpty())
787                 &amp;&amp; (classNames == null || classNames.isEmpty());
788     }
789 
790     public void allowEmpty() {
791         this.emptyAllowed = true;
792     }
793 
794     /**
795      * Gets the file manager options which may have been deferred
796      * during processArgs.
797      * @return the deferred file manager options
798      */
799     public Map&lt;Option, String&gt; getDeferredFileManagerOptions() {
800         return deferredFileManagerOptions;
801     }
802 
803     /**
804      * Gets any options specifying plugins to be run.
805      * @return options for plugins
806      */
807     public Set&lt;List&lt;String&gt;&gt; getPluginOpts() {
808         String plugins = options.get(Option.PLUGIN);
809         if (plugins == null)
810             return Collections.emptySet();
811 
812         Set&lt;List&lt;String&gt;&gt; pluginOpts = new LinkedHashSet&lt;&gt;();
813         for (String plugin: plugins.split(&quot;\\x00&quot;)) {
814             pluginOpts.add(List.from(plugin.split(&quot;\\s+&quot;)));
815         }
816         return Collections.unmodifiableSet(pluginOpts);
817     }
818 
819     /**
820      * Gets any options specifying how doclint should be run.
821      * An empty list is returned if no doclint options are specified
822      * or if the only doclint option is -Xdoclint:none.
823      * @return options for doclint
824      */
825     public List&lt;String&gt; getDocLintOpts() {
826         String xdoclint = options.get(Option.XDOCLINT);
827         String xdoclintCustom = options.get(Option.XDOCLINT_CUSTOM);
828         if (xdoclint == null &amp;&amp; xdoclintCustom == null)
829             return List.nil();
830 
831         Set&lt;String&gt; doclintOpts = new LinkedHashSet&lt;&gt;();
832         if (xdoclint != null)
833             doclintOpts.add(DocLint.XMSGS_OPTION);
834         if (xdoclintCustom != null) {
835             for (String s: xdoclintCustom.split(&quot;\\s+&quot;)) {
836                 if (s.isEmpty())
837                     continue;
838                 doclintOpts.add(DocLint.XMSGS_CUSTOM_PREFIX + s);
839             }
840         }
841 
842         if (doclintOpts.equals(Collections.singleton(DocLint.XMSGS_CUSTOM_PREFIX + &quot;none&quot;)))
843             return List.nil();
844 
845         String checkPackages = options.get(Option.XDOCLINT_PACKAGE);
846         if (checkPackages != null) {
847             doclintOpts.add(DocLint.XCHECK_PACKAGE + checkPackages);
848         }
849 
850         String format = options.get(Option.DOCLINT_FORMAT);
851         if (format != null) {
852             doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + format);
853         }
854 
855         return List.from(doclintOpts.toArray(new String[doclintOpts.size()]));
856     }
857 
858     private boolean checkDirectory(Option option) {
859         String value = options.get(option);
860         if (value == null) {
861             return true;
862         }
863         Path file = Paths.get(value);
864         if (Files.exists(file) &amp;&amp; !Files.isDirectory(file)) {
865             reportDiag(Errors.FileNotDirectory(value));
866             return false;
867         }
868         return true;
869     }
870 
871     private interface ErrorReporter {
872         void report(Option o);
873     }
874 
875     void checkOptionAllowed(boolean allowed, ErrorReporter r, Option... opts) {
876         if (!allowed) {
877             Stream.of(opts)
878                   .filter(options :: isSet)
879                   .forEach(r :: report);
880         }
881     }
882 
883     void reportDiag(DiagnosticInfo diag) {
884         errors = true;
885         switch (errorMode) {
886             case ILLEGAL_ARGUMENT: {
887                 String msg = log.localize(diag);
888                 throw new PropagatedException(new IllegalArgumentException(msg));
889             }
890             case ILLEGAL_STATE: {
891                 String msg = log.localize(diag);
892                 throw new PropagatedException(new IllegalStateException(msg));
893             }
894             case LOG:
895                 report(diag);
896         }
897     }
898 
899     void error(Option.InvalidValueException f) {
900         String msg = f.getMessage();
901         errors = true;
902         switch (errorMode) {
903             case ILLEGAL_ARGUMENT: {
904                 throw new PropagatedException(new IllegalArgumentException(msg, f.getCause()));
905             }
906             case ILLEGAL_STATE: {
907                 throw new PropagatedException(new IllegalStateException(msg, f.getCause()));
908             }
909             case LOG:
910                 log.printRawLines(msg);
911         }
912     }
913 
914     private void report(DiagnosticInfo diag) {
915         // Would be good to have support for -XDrawDiagnostics here
916         if (diag instanceof JCDiagnostic.Error) {
917             log.error((JCDiagnostic.Error)diag);
918         } else if (diag instanceof JCDiagnostic.Warning){
919             log.warning((JCDiagnostic.Warning)diag);
920         }
921     }
922 
923     private JavaFileManager getFileManager() {
924         if (fileManager == null)
925             fileManager = context.get(JavaFileManager.class);
926         return fileManager;
927     }
928 
929     &lt;T&gt; ListBuffer&lt;T&gt; toList(Iterable&lt;? extends T&gt; items) {
930         ListBuffer&lt;T&gt; list = new ListBuffer&lt;&gt;();
931         if (items != null) {
932             for (T item : items) {
933                 list.add(item);
934             }
935         }
936         return list;
937     }
938 
939     &lt;T&gt; Set&lt;T&gt; toSet(Iterable&lt;? extends T&gt; items) {
940         Set&lt;T&gt; set = new LinkedHashSet&lt;&gt;();
941         if (items != null) {
942             for (T item : items) {
943                 set.add(item);
944             }
945         }
946         return set;
947     }
948 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -26,17 +26,16 @@
 package com.sun.tools.javac.api;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.text.BreakIterator;
-import java.util.Collections;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.WeakHashMap;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.AnnotationValue;
 import javax.lang.model.element.Element;
@@ -58,28 +57,25 @@
 import javax.tools.JavaFileObject.Kind;
 import javax.tools.StandardLocation;
 
 import com.sun.source.doctree.DocCommentTree;
 import com.sun.source.doctree.DocTree;
-import com.sun.source.doctree.EndElementTree;
-import com.sun.source.doctree.StartElementTree;
 import com.sun.source.tree.CatchTree;
+import com.sun.source.tree.ClassTree;
 import com.sun.source.tree.CompilationUnitTree;
 import com.sun.source.tree.Scope;
 import com.sun.source.tree.Tree;
 import com.sun.source.util.DocSourcePositions;
 import com.sun.source.util.DocTreePath;
 import com.sun.source.util.DocTreeScanner;
 import com.sun.source.util.DocTrees;
 import com.sun.source.util.JavacTask;
-import com.sun.source.util.SimpleDocTreeVisitor;
 import com.sun.source.util.TreePath;
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.code.Scope.NamedImportScope;
 import com.sun.tools.javac.code.Scope.StarImportScope;
 import com.sun.tools.javac.code.Scope.WriteableScope;
-import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 import com.sun.tools.javac.code.Symbol.TypeSymbol;
@@ -92,15 +88,17 @@
 import com.sun.tools.javac.code.Type.UnionClassType;
 import com.sun.tools.javac.code.Types;
 import com.sun.tools.javac.code.Types.TypeRelation;
 import com.sun.tools.javac.comp.Attr;
 import com.sun.tools.javac.comp.AttrContext;
+import com.sun.tools.javac.comp.Check;
 import com.sun.tools.javac.comp.Enter;
 import com.sun.tools.javac.comp.Env;
 import com.sun.tools.javac.comp.MemberEnter;
 import com.sun.tools.javac.comp.Modules;
 import com.sun.tools.javac.comp.Resolve;
+import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.file.BaseFileManager;
 import com.sun.tools.javac.model.JavacElements;
 import com.sun.tools.javac.parser.DocCommentParser;
 import com.sun.tools.javac.parser.ParserFactory;
 import com.sun.tools.javac.parser.Tokens.Comment;
@@ -109,12 +107,14 @@
 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 import com.sun.tools.javac.resources.CompilerProperties.Notes;
 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 import com.sun.tools.javac.tree.DCTree;
 import com.sun.tools.javac.tree.DCTree.DCBlockTag;
+import com.sun.tools.javac.tree.DCTree.DCComment;
 import com.sun.tools.javac.tree.DCTree.DCDocComment;
 import com.sun.tools.javac.tree.DCTree.DCEndPosTree;
+import com.sun.tools.javac.tree.DCTree.DCEntity;
 import com.sun.tools.javac.tree.DCTree.DCErroneous;
 import com.sun.tools.javac.tree.DCTree.DCIdentifier;
 import com.sun.tools.javac.tree.DCTree.DCParam;
 import com.sun.tools.javac.tree.DCTree.DCReference;
 import com.sun.tools.javac.tree.DCTree.DCText;
@@ -131,10 +131,11 @@
 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 import com.sun.tools.javac.tree.TreeCopier;
 import com.sun.tools.javac.tree.TreeInfo;
 import com.sun.tools.javac.tree.TreeMaker;
+import com.sun.tools.javac.tree.TreeScanner;
 import com.sun.tools.javac.util.Abort;
 import com.sun.tools.javac.util.Assert;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.DefinedBy;
 import com.sun.tools.javac.util.DefinedBy.Api;
@@ -169,10 +170,11 @@
     private Resolve resolve;
     private Enter enter;
     private Log log;
     private MemberEnter memberEnter;
     private Attr attr;
+    private Check chk;
     private TreeMaker treeMaker;
     private JavacElements elements;
     private JavacTaskImpl javacTaskImpl;
     private Names names;
     private Types types;
@@ -216,10 +218,11 @@
     }
 
     private void init(Context context) {
         modules = Modules.instance(context);
         attr = Attr.instance(context);
+        chk = Check.instance(context);
         enter = Enter.instance(context);
         elements = JavacElements.instance(context);
         log = Log.instance(context);
         resolve = Resolve.instance(context);
         treeMaker = TreeMaker.instance(context);
@@ -299,10 +302,18 @@
 
                             DCBlockTag block = (DCBlockTag) tree;
 
                             return dcComment.comment.getSourcePos(block.pos + block.getTagName().length() + 1);
                         }
+                        case ENTITY: {
+                            DCEntity endEl = (DCEntity) tree;
+                            return dcComment.comment.getSourcePos(endEl.pos + (endEl.name != names.error ? endEl.name.length() : 0) + 2);
+                        }
+                        case COMMENT: {
+                            DCComment endEl = (DCComment) tree;
+                            return dcComment.comment.getSourcePos(endEl.pos + endEl.body.length());
+                        }
                         default:
                             DocTree last = getLastChild(tree);
 
                             if (last != null) {
                                 return getEndPosition(file, comment, last);
@@ -407,14 +418,14 @@
         return sym;
     }
 
     @Override @DefinedBy(Api.COMPILER_TREE)
     public Element getElement(DocTreePath path) {
-        DocTree forTree = path.getLeaf();
-        if (forTree instanceof DCReference)
-            return attributeDocReference(path.getTreePath(), ((DCReference) forTree));
-        if (forTree instanceof DCIdentifier) {
+        DocTree tree = path.getLeaf();
+        if (tree instanceof DCReference)
+            return attributeDocReference(path.getTreePath(), ((DCReference) tree));
+        if (tree instanceof DCIdentifier) {
             if (path.getParentPath().getLeaf() instanceof DCParam) {
                 return attributeParamIdentifier(path.getTreePath(), (DCParam) path.getParentPath().getLeaf());
             }
         }
         return null;
@@ -523,28 +534,30 @@
         } finally {
             log.popDiagnosticHandler(deferredDiagnosticHandler);
         }
     }
 
-    private Symbol attributeParamIdentifier(TreePath path, DCParam ptag) {
+    private Symbol attributeParamIdentifier(TreePath path, DCParam paramTag) {
         Symbol javadocSymbol = getElement(path);
         if (javadocSymbol == null)
             return null;
         ElementKind kind = javadocSymbol.getKind();
         List<? extends Symbol> params = List.nil();
         if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {
             MethodSymbol ee = (MethodSymbol) javadocSymbol;
-            params = ptag.isTypeParameter()
+            params = paramTag.isTypeParameter()
                     ? ee.getTypeParameters()
                     : ee.getParameters();
         } else if (kind.isClass() || kind.isInterface()) {
             ClassSymbol te = (ClassSymbol) javadocSymbol;
-            params = te.getTypeParameters();
+            params = paramTag.isTypeParameter()
+                    ? te.getTypeParameters()
+                    : te.getRecordComponents();
         }
 
         for (Symbol param : params) {
-            if (param.getSimpleName() == ptag.getName().getName()) {
+            if (param.getSimpleName() == paramTag.getName().getName()) {
                 return param;
             }
         }
         return null;
     }
@@ -913,49 +926,148 @@
 //                    System.err.println("BLOCK: ");
                     if (method != null) {
                         try {
                             Assert.check(method.body == tree);
                             method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
-                            env = attribStatToTree(method.body, env, copier.leafCopy);
+                            env = attribStatToTree(method.body, env, copier.leafCopy, copier.copiedClasses);
                         } finally {
                             method.body = (JCBlock) tree;
                         }
                     } else {
                         JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
-                        env = attribStatToTree(body, env, copier.leafCopy);
+                        env = attribStatToTree(body, env, copier.leafCopy, copier.copiedClasses);
                     }
                     return env;
                 }
                 default:
 //                    System.err.println("DEFAULT: " + tree.getKind());
                     if (field != null && field.getInitializer() == tree) {
                         env = memberEnter.getInitEnv(field, env);
                         JCExpression expr = copier.copy((JCExpression)tree, (JCTree) path.getLeaf());
-                        env = attribExprToTree(expr, env, copier.leafCopy);
+                        env = attribExprToTree(expr, env, copier.leafCopy, copier.copiedClasses);
                         return env;
                     }
             }
         }
         return (field != null) ? memberEnter.getInitEnv(field, env) : env;
     }
 
-    private Env<AttrContext> attribStatToTree(JCTree stat, Env<AttrContext>env, JCTree tree) {
-        JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
-        try {
-            return attr.attribStatToTree(stat, env, tree);
-        } finally {
-            log.useSource(prev);
+    private Env<AttrContext> attribStatToTree(JCTree stat, Env<AttrContext>env,
+                                              JCTree tree, Map<JCClassDecl, JCClassDecl> copiedClasses) {
+        Env<AttrContext> result = attr.attribStatToTree(stat, env, tree);
+
+        fixLocalClassNames(copiedClasses, env);
+
+        return result;
+    }
+
+    private Env<AttrContext> attribExprToTree(JCExpression expr, Env<AttrContext>env,
+                                              JCTree tree, Map<JCClassDecl, JCClassDecl> copiedClasses) {
+        Env<AttrContext> result = attr.attribExprToTree(expr, env, tree);
+
+        fixLocalClassNames(copiedClasses, env);
+
+        return result;
+    }
+
+    /* Change the flatnames of the local and anonymous classes in the Scope to
+     * the names they would have if the whole file was attributed normally.
+     */
+    private void fixLocalClassNames(Map<JCClassDecl, JCClassDecl> copiedClasses,
+                                    Env<AttrContext> lastEnv) {
+        Map<JCClassDecl, Name> flatnameForClass = null;
+
+        for (Entry<JCClassDecl, JCClassDecl> e : copiedClasses.entrySet()) {
+            if (e.getKey().sym != null) {
+                Name origName;
+                if (e.getValue().sym != null) {
+                    //if the source tree was already attributed, use the flatname
+                    //from the source tree's Symbol:
+                    origName = e.getValue().sym.flatname;
+                } else {
+                    //otherwise, compute the flatnames (for source trees) as
+                    //if the full source code would be attributed:
+                    if (flatnameForClass == null) {
+                        flatnameForClass = prepareFlatnameForClass(lastEnv);
+                    }
+                    origName = flatnameForClass.get(e.getValue());
+                }
+                if (origName != null) {
+                    e.getKey().sym.flatname = origName;
+                }
+            }
         }
     }
 
-    private Env<AttrContext> attribExprToTree(JCExpression expr, Env<AttrContext>env, JCTree tree) {
-        JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
-        try {
-            return attr.attribExprToTree(expr, env, tree);
-        } finally {
-            log.useSource(prev);
+    /* This method computes and assigns flatnames to trees, as if they would be
+     * normally assigned during attribution of the full source code.
+     */
+    private Map<JCTree.JCClassDecl, Name> prepareFlatnameForClass(Env<AttrContext> env) {
+        Map<JCClassDecl, Name> flatNameForClass = new HashMap<>();
+        Symbol enclClass = env.enclClass.sym;
+
+        if (enclClass != null && (enclClass.flags_field & Flags.UNATTRIBUTED) != 0) {
+            ListBuffer<ClassSymbol> toClear = new ListBuffer<>();
+            new TreeScanner() {
+                Symbol owner;
+                boolean localContext;
+                @Override
+                public void visitClassDef(JCClassDecl tree) {
+                    //compute the name (and ClassSymbol) which would be used
+                    //for this class for full attribution
+                    Symbol prevOwner = owner;
+                    try {
+                        ClassSymbol c;
+                        if (tree.sym != null) {
+                            //already entered:
+                            c = tree.sym;
+                        } else {
+                            c = syms.defineClass(tree.name, owner);
+                            if (owner.kind != TYP) {
+                                //for local classes, assign the flatname
+                                c.flatname = chk.localClassName(c);
+                                chk.putCompiled(c);
+                                toClear.add(c);
+                            }
+                            flatNameForClass.put(tree, c.flatname);
+                        }
+                        owner = c;
+                        super.visitClassDef(tree);
+                    } finally {
+                        owner = prevOwner;
+                    }
+                }
+
+                @Override
+                public void visitBlock(JCBlock tree) {
+                    Symbol prevOwner = owner;
+                    try {
+                        owner = new MethodSymbol(0, names.empty, Type.noType, owner);
+                        super.visitBlock(tree);
+                    } finally {
+                        owner = prevOwner;
+                    }
+                }
+                @Override
+                public void visitVarDef(JCVariableDecl tree) {
+                    Symbol prevOwner = owner;
+                    try {
+                        owner = new MethodSymbol(0, names.empty, Type.noType, owner);
+                        super.visitVarDef(tree);
+                    } finally {
+                        owner = prevOwner;
+                    }
+                }
+            }.scan(env.enclClass);
+            //revert changes done by the visitor:
+            toClear.stream().forEach(c -> {
+                chk.clearLocalClassNameIndexes(c);
+                chk.removeCompiled(c);
+            });
         }
+
+        return flatNameForClass;
     }
 
     static JavaFileObject asJavaFileObject(FileObject fileObject) {
         JavaFileObject jfo = null;
 
@@ -1063,10 +1175,11 @@
     /**
      * Makes a copy of a tree, noting the value resulting from copying a particular leaf.
      **/
     protected static class Copier extends TreeCopier<JCTree> {
         JCTree leafCopy = null;
+        private Map<JCClassDecl, JCClassDecl> copiedClasses = new HashMap<>();
 
         protected Copier(TreeMaker M) {
             super(M);
         }
 
@@ -1075,10 +1188,18 @@
             T t2 = super.copy(t, leaf);
             if (t == leaf)
                 leafCopy = t2;
             return t2;
         }
+
+        @Override
+        public JCTree visitClass(ClassTree node, JCTree p) {
+            JCTree nue = super.visitClass(node, p);
+            copiedClasses.put((JCClassDecl) nue, (JCClassDecl) node);
+            return nue;
+        }
+
     }
 
     protected Copier createCopier(TreeMaker maker) {
         return new Copier(maker);
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/source/util/TreeScanner.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimpleTreeVisitor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../tools/doclint/Checker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/source/util/TreeScanner.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.source.util;
 27 
 28 import com.sun.source.tree.*;
<span class="line-removed"> 29 import com.sun.source.tree.CaseTree.CaseKind;</span>
 30 
 31 /**
 32  * A TreeVisitor that visits all the child tree nodes.
 33  * To visit nodes of a particular type, just override the
 34  * corresponding visitXYZ method.
 35  * Inside your method, call super.visitXYZ to visit descendant
 36  * nodes.
 37  *
 38  * &lt;p&gt;The default implementation of the visitXYZ methods will determine
 39  * a result as follows:
 40  * &lt;ul&gt;
 41  * &lt;li&gt;If the node being visited has no children, the result will be {@code null}.
 42  * &lt;li&gt;If the node being visited has one child, the result will be the
 43  * result of calling {@code scan} on that child. The child may be a simple node
 44  * or itself a list of nodes.
 45  * &lt;li&gt; If the node being visited has more than one child, the result will
 46  * be determined by calling {@code scan} each child in turn, and then combining the
 47  * result of each scan after the first with the cumulative result
 48  * so far, as determined by the {@link #reduce} method. Each child may be either
 49  * a simple node of a list of nodes. The default behavior of the {@code reduce}
</pre>
<hr />
<pre>
323     /**
324      * {@inheritDoc} This implementation scans the children in left to right order.
325      *
326      * @param node  {@inheritDoc}
327      * @param p  {@inheritDoc}
328      * @return the result of scanning
329      */
330     @Override
331     public R visitSwitch(SwitchTree node, P p) {
332         R r = scan(node.getExpression(), p);
333         r = scanAndReduce(node.getCases(), p, r);
334         return r;
335     }
336 
337     /**
338      * {@inheritDoc} This implementation scans the children in left to right order.
339      *
340      * @param node  {@inheritDoc}
341      * @param p  {@inheritDoc}
342      * @return the result of scanning
<span class="line-removed">343      *</span>
<span class="line-removed">344      * @deprecated</span>
<span class="line-removed">345      * This method is modeling switch expressions,</span>
<span class="line-removed">346      * which are part of a preview feature and may be removed</span>
<span class="line-removed">347      * if the preview feature is removed.</span>
348      */
349     @Override
<span class="line-removed">350     @Deprecated(forRemoval=true, since=&quot;12&quot;)</span>
<span class="line-removed">351     @SuppressWarnings(&quot;removal&quot;)</span>
352     public R visitSwitchExpression(SwitchExpressionTree node, P p) {
353         R r = scan(node.getExpression(), p);
354         r = scanAndReduce(node.getCases(), p, r);
355         return r;
356     }
357 
358     /**
359      * {@inheritDoc} This implementation scans the children in left to right order.
360      *
361      * @param node  {@inheritDoc}
362      * @param p  {@inheritDoc}
363      * @return the result of scanning
364      */
365     @Override
<span class="line-removed">366     @SuppressWarnings(&quot;removal&quot;)</span>
367     public R visitCase(CaseTree node, P p) {
368         R r = scan(node.getExpressions(), p);
<span class="line-modified">369         if (node.getCaseKind() == CaseKind.RULE)</span>
370             r = scanAndReduce(node.getBody(), p, r);
371         else
372             r = scanAndReduce(node.getStatements(), p, r);
373         return r;
374     }
375 
376     /**
377      * {@inheritDoc} This implementation scans the children in left to right order.
378      *
379      * @param node  {@inheritDoc}
380      * @param p  {@inheritDoc}
381      * @return the result of scanning
382      */
383     @Override
384     public R visitSynchronized(SynchronizedTree node, P p) {
385         R r = scan(node.getExpression(), p);
386         r = scanAndReduce(node.getBlock(), p, r);
387         return r;
388     }
389 
</pre>
<hr />
<pre>
450     /**
451      * {@inheritDoc} This implementation scans the children in left to right order.
452      *
453      * @param node  {@inheritDoc}
454      * @param p  {@inheritDoc}
455      * @return the result of scanning
456      */
457     @Override
458     public R visitExpressionStatement(ExpressionStatementTree node, P p) {
459         return scan(node.getExpression(), p);
460     }
461 
462     /**
463      * {@inheritDoc} This implementation returns {@code null}.
464      *
465      * @param node  {@inheritDoc}
466      * @param p  {@inheritDoc}
467      * @return the result of scanning
468      */
469     @Override
<span class="line-removed">470     @SuppressWarnings(&quot;removal&quot;)</span>
471     public R visitBreak(BreakTree node, P p) {
<span class="line-modified">472         return scan(node.getValue(), p);</span>
473     }
474 
475     /**
476      * {@inheritDoc} This implementation returns {@code null}.
477      *
478      * @param node  {@inheritDoc}
479      * @param p  {@inheritDoc}
480      * @return the result of scanning
481      */
482     @Override
483     public R visitContinue(ContinueTree node, P p) {
484         return null;
485     }
486 
487     /**
488      * {@inheritDoc} This implementation scans the children in left to right order.
489      *
490      * @param node  {@inheritDoc}
491      * @param p  {@inheritDoc}
492      * @return the result of scanning
</pre>
<hr />
<pre>
660      * @param p  {@inheritDoc}
661      * @return the result of scanning
662      */
663     @Override
664     public R visitTypeCast(TypeCastTree node, P p) {
665         R r = scan(node.getType(), p);
666         r = scanAndReduce(node.getExpression(), p, r);
667         return r;
668     }
669 
670     /**
671      * {@inheritDoc} This implementation scans the children in left to right order.
672      *
673      * @param node  {@inheritDoc}
674      * @param p  {@inheritDoc}
675      * @return the result of scanning
676      */
677     @Override
678     public R visitInstanceOf(InstanceOfTree node, P p) {
679         R r = scan(node.getExpression(), p);
<span class="line-modified">680         r = scanAndReduce(node.getType(), p, r);</span>




681         return r;
682     }
683 













684     /**
685      * {@inheritDoc} This implementation scans the children in left to right order.
686      *
687      * @param node  {@inheritDoc}
688      * @param p  {@inheritDoc}
689      * @return the result of scanning
690      */
691     @Override
692     public R visitArrayAccess(ArrayAccessTree node, P p) {
693         R r = scan(node.getExpression(), p);
694         r = scanAndReduce(node.getIndex(), p, r);
695         return r;
696     }
697 
698     /**
699      * {@inheritDoc} This implementation scans the children in left to right order.
700      *
701      * @param node  {@inheritDoc}
702      * @param p  {@inheritDoc}
703      * @return the result of scanning
</pre>
<hr />
<pre>
918      * @param node  {@inheritDoc}
919      * @param p  {@inheritDoc}
920      * @return the result of scanning
921      */
922     @Override
923     public R visitOther(Tree node, P p) {
924         return null;
925     }
926 
927     /**
928      * {@inheritDoc} This implementation returns {@code null}.
929      *
930      * @param node  {@inheritDoc}
931      * @param p  {@inheritDoc}
932      * @return the result of scanning
933      */
934     @Override
935     public R visitErroneous(ErroneousTree node, P p) {
936         return null;
937     }












938 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.source.util;
 27 
 28 import com.sun.source.tree.*;

 29 
 30 /**
 31  * A TreeVisitor that visits all the child tree nodes.
 32  * To visit nodes of a particular type, just override the
 33  * corresponding visitXYZ method.
 34  * Inside your method, call super.visitXYZ to visit descendant
 35  * nodes.
 36  *
 37  * &lt;p&gt;The default implementation of the visitXYZ methods will determine
 38  * a result as follows:
 39  * &lt;ul&gt;
 40  * &lt;li&gt;If the node being visited has no children, the result will be {@code null}.
 41  * &lt;li&gt;If the node being visited has one child, the result will be the
 42  * result of calling {@code scan} on that child. The child may be a simple node
 43  * or itself a list of nodes.
 44  * &lt;li&gt; If the node being visited has more than one child, the result will
 45  * be determined by calling {@code scan} each child in turn, and then combining the
 46  * result of each scan after the first with the cumulative result
 47  * so far, as determined by the {@link #reduce} method. Each child may be either
 48  * a simple node of a list of nodes. The default behavior of the {@code reduce}
</pre>
<hr />
<pre>
322     /**
323      * {@inheritDoc} This implementation scans the children in left to right order.
324      *
325      * @param node  {@inheritDoc}
326      * @param p  {@inheritDoc}
327      * @return the result of scanning
328      */
329     @Override
330     public R visitSwitch(SwitchTree node, P p) {
331         R r = scan(node.getExpression(), p);
332         r = scanAndReduce(node.getCases(), p, r);
333         return r;
334     }
335 
336     /**
337      * {@inheritDoc} This implementation scans the children in left to right order.
338      *
339      * @param node  {@inheritDoc}
340      * @param p  {@inheritDoc}
341      * @return the result of scanning





342      */
343     @Override


344     public R visitSwitchExpression(SwitchExpressionTree node, P p) {
345         R r = scan(node.getExpression(), p);
346         r = scanAndReduce(node.getCases(), p, r);
347         return r;
348     }
349 
350     /**
351      * {@inheritDoc} This implementation scans the children in left to right order.
352      *
353      * @param node  {@inheritDoc}
354      * @param p  {@inheritDoc}
355      * @return the result of scanning
356      */
357     @Override

358     public R visitCase(CaseTree node, P p) {
359         R r = scan(node.getExpressions(), p);
<span class="line-modified">360         if (node.getCaseKind() == CaseTree.CaseKind.RULE)</span>
361             r = scanAndReduce(node.getBody(), p, r);
362         else
363             r = scanAndReduce(node.getStatements(), p, r);
364         return r;
365     }
366 
367     /**
368      * {@inheritDoc} This implementation scans the children in left to right order.
369      *
370      * @param node  {@inheritDoc}
371      * @param p  {@inheritDoc}
372      * @return the result of scanning
373      */
374     @Override
375     public R visitSynchronized(SynchronizedTree node, P p) {
376         R r = scan(node.getExpression(), p);
377         r = scanAndReduce(node.getBlock(), p, r);
378         return r;
379     }
380 
</pre>
<hr />
<pre>
441     /**
442      * {@inheritDoc} This implementation scans the children in left to right order.
443      *
444      * @param node  {@inheritDoc}
445      * @param p  {@inheritDoc}
446      * @return the result of scanning
447      */
448     @Override
449     public R visitExpressionStatement(ExpressionStatementTree node, P p) {
450         return scan(node.getExpression(), p);
451     }
452 
453     /**
454      * {@inheritDoc} This implementation returns {@code null}.
455      *
456      * @param node  {@inheritDoc}
457      * @param p  {@inheritDoc}
458      * @return the result of scanning
459      */
460     @Override

461     public R visitBreak(BreakTree node, P p) {
<span class="line-modified">462         return null;</span>
463     }
464 
465     /**
466      * {@inheritDoc} This implementation returns {@code null}.
467      *
468      * @param node  {@inheritDoc}
469      * @param p  {@inheritDoc}
470      * @return the result of scanning
471      */
472     @Override
473     public R visitContinue(ContinueTree node, P p) {
474         return null;
475     }
476 
477     /**
478      * {@inheritDoc} This implementation scans the children in left to right order.
479      *
480      * @param node  {@inheritDoc}
481      * @param p  {@inheritDoc}
482      * @return the result of scanning
</pre>
<hr />
<pre>
650      * @param p  {@inheritDoc}
651      * @return the result of scanning
652      */
653     @Override
654     public R visitTypeCast(TypeCastTree node, P p) {
655         R r = scan(node.getType(), p);
656         r = scanAndReduce(node.getExpression(), p, r);
657         return r;
658     }
659 
660     /**
661      * {@inheritDoc} This implementation scans the children in left to right order.
662      *
663      * @param node  {@inheritDoc}
664      * @param p  {@inheritDoc}
665      * @return the result of scanning
666      */
667     @Override
668     public R visitInstanceOf(InstanceOfTree node, P p) {
669         R r = scan(node.getExpression(), p);
<span class="line-modified">670         if (node.getPattern() != null) {</span>
<span class="line-added">671             r = scanAndReduce(node.getPattern(), p, r);</span>
<span class="line-added">672         } else {</span>
<span class="line-added">673             r = scanAndReduce(node.getType(), p, r);</span>
<span class="line-added">674         }</span>
675         return r;
676     }
677 
<span class="line-added">678     /**</span>
<span class="line-added">679      * {@inheritDoc} This implementation scans the children in left to right order.</span>
<span class="line-added">680      *</span>
<span class="line-added">681      * @param node  {@inheritDoc}</span>
<span class="line-added">682      * @param p  {@inheritDoc}</span>
<span class="line-added">683      * @return the result of scanning</span>
<span class="line-added">684      * @since 14</span>
<span class="line-added">685      */</span>
<span class="line-added">686     @Override</span>
<span class="line-added">687     public R visitBindingPattern(BindingPatternTree node, P p) {</span>
<span class="line-added">688         return scan(node.getType(), p);</span>
<span class="line-added">689     }</span>
<span class="line-added">690 </span>
691     /**
692      * {@inheritDoc} This implementation scans the children in left to right order.
693      *
694      * @param node  {@inheritDoc}
695      * @param p  {@inheritDoc}
696      * @return the result of scanning
697      */
698     @Override
699     public R visitArrayAccess(ArrayAccessTree node, P p) {
700         R r = scan(node.getExpression(), p);
701         r = scanAndReduce(node.getIndex(), p, r);
702         return r;
703     }
704 
705     /**
706      * {@inheritDoc} This implementation scans the children in left to right order.
707      *
708      * @param node  {@inheritDoc}
709      * @param p  {@inheritDoc}
710      * @return the result of scanning
</pre>
<hr />
<pre>
925      * @param node  {@inheritDoc}
926      * @param p  {@inheritDoc}
927      * @return the result of scanning
928      */
929     @Override
930     public R visitOther(Tree node, P p) {
931         return null;
932     }
933 
934     /**
935      * {@inheritDoc} This implementation returns {@code null}.
936      *
937      * @param node  {@inheritDoc}
938      * @param p  {@inheritDoc}
939      * @return the result of scanning
940      */
941     @Override
942     public R visitErroneous(ErroneousTree node, P p) {
943         return null;
944     }
<span class="line-added">945 </span>
<span class="line-added">946     /**</span>
<span class="line-added">947      * {@inheritDoc} This implementation returns {@code null}.</span>
<span class="line-added">948      *</span>
<span class="line-added">949      * @param node  {@inheritDoc}</span>
<span class="line-added">950      * @param p  {@inheritDoc}</span>
<span class="line-added">951      * @return the result of scanning</span>
<span class="line-added">952      */</span>
<span class="line-added">953     @Override</span>
<span class="line-added">954     public R visitYield(YieldTree node, P p) {</span>
<span class="line-added">955         return scan(node.getValue(), p);</span>
<span class="line-added">956     }</span>
957 }
</pre>
</td>
</tr>
</table>
<center><a href="SimpleTreeVisitor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../../tools/doclint/Checker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
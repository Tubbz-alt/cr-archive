<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.processing;
 27 
 28 import javax.annotation.processing.*;
 29 import javax.lang.model.*;
 30 import javax.lang.model.element.*;
 31 import static javax.lang.model.element.ElementKind.*;
 32 import static javax.lang.model.element.NestingKind.*;
 33 import static javax.lang.model.element.ModuleElement.DirectiveKind.*;
 34 import static javax.lang.model.element.ModuleElement.*;
 35 import javax.lang.model.type.*;
 36 import javax.lang.model.util.*;
 37 
 38 import java.io.PrintWriter;
 39 import java.io.Writer;
 40 import java.util.*;
 41 import java.util.stream.Collectors;
<a name="2" id="anc2"></a>

 42 
 43 import com.sun.tools.javac.util.DefinedBy;
 44 import com.sun.tools.javac.util.DefinedBy.Api;
 45 import com.sun.tools.javac.util.StringUtils;
 46 
 47 /**
 48  * A processor which prints out elements.  Used to implement the
 49  * -Xprint option; the included visitor class is used to implement
 50  * Elements.printElements.
 51  *
 52  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 53  * If you write code that depends on this, you do so at your own risk.
 54  * This code and its internal interfaces are subject to change or
 55  * deletion without notice.&lt;/b&gt;
 56  */
 57 @SupportedAnnotationTypes(&quot;*&quot;)
<a name="3" id="anc3"></a><span class="line-modified"> 58 @SupportedSourceVersion(SourceVersion.RELEASE_13)</span>
 59 public class PrintingProcessor extends AbstractProcessor {
 60     PrintWriter writer;
 61 
 62     public PrintingProcessor() {
 63         super();
 64         writer = new PrintWriter(System.out);
 65     }
 66 
 67     public void setWriter(Writer w) {
 68         writer = new PrintWriter(w);
 69     }
 70 
 71     @Override @DefinedBy(Api.ANNOTATION_PROCESSING)
 72     public boolean process(Set&lt;? extends TypeElement&gt; tes,
 73                            RoundEnvironment renv) {
 74 
 75         for(Element element : renv.getRootElements()) {
 76             print(element);
 77         }
 78 
 79         // Just print the elements, nothing more to do.
 80         return true;
 81     }
 82 
 83     void print(Element element) {
 84         new PrintingElementVisitor(writer, processingEnv.getElementUtils()).
 85             visit(element).flush();
 86     }
 87 
 88     /**
 89      * Used for the -Xprint option and called by Elements.printElements
 90      */
<a name="4" id="anc4"></a>
 91     public static class PrintingElementVisitor
<a name="5" id="anc5"></a><span class="line-modified"> 92         extends SimpleElementVisitor9&lt;PrintingElementVisitor, Boolean&gt; {</span>
 93         int indentation; // Indentation level;
 94         final PrintWriter writer;
 95         final Elements elementUtils;
 96 
 97         public PrintingElementVisitor(Writer w, Elements elementUtils) {
 98             super();
 99             this.writer = new PrintWriter(w);
100             this.elementUtils = elementUtils;
101             indentation = 0;
102         }
103 
104         @Override @DefinedBy(Api.LANGUAGE_MODEL)
105         protected PrintingElementVisitor defaultAction(Element e, Boolean newLine) {
106             if (newLine != null &amp;&amp; newLine)
107                 writer.println();
108             printDocComment(e);
109             printModifiers(e);
110             return this;
111         }
112 
<a name="6" id="anc6"></a>






113         @Override @DefinedBy(Api.LANGUAGE_MODEL)
114         public PrintingElementVisitor visitExecutable(ExecutableElement e, Boolean p) {
115             ElementKind kind = e.getKind();
116 
117             if (kind != STATIC_INIT &amp;&amp;
118                 kind != INSTANCE_INIT) {
119                 Element enclosing = e.getEnclosingElement();
120 
121                 // Don&#39;t print out the constructor of an anonymous class
122                 if (kind == CONSTRUCTOR &amp;&amp;
123                     enclosing != null &amp;&amp;
124                     NestingKind.ANONYMOUS ==
125                     // Use an anonymous class to determine anonymity!
<a name="7" id="anc7"></a><span class="line-modified">126                     (new SimpleElementVisitor9&lt;NestingKind, Void&gt;() {</span>
127                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
128                         public NestingKind visitType(TypeElement e, Void p) {
129                             return e.getNestingKind();
130                         }
131                     }).visit(enclosing))
132                     return this;
133 
134                 defaultAction(e, true);
135                 printFormalTypeParameters(e, true);
136 
137                 switch(kind) {
138                     case CONSTRUCTOR:
139                     // Print out simple name of the class
140                     writer.print(e.getEnclosingElement().getSimpleName());
141                     break;
142 
143                     case METHOD:
144                     writer.print(e.getReturnType().toString());
145                     writer.print(&quot; &quot;);
146                     writer.print(e.getSimpleName().toString());
147                     break;
148                 }
149 
150                 writer.print(&quot;(&quot;);
151                 printParameters(e);
152                 writer.print(&quot;)&quot;);
153                 AnnotationValue defaultValue = e.getDefaultValue();
154                 if (defaultValue != null)
155                     writer.print(&quot; default &quot; + defaultValue);
156 
157                 printThrows(e);
158                 writer.println(&quot;;&quot;);
159             }
160             return this;
161         }
162 
163 
164         @Override @DefinedBy(Api.LANGUAGE_MODEL)
165         public PrintingElementVisitor visitType(TypeElement e, Boolean p) {
166             ElementKind kind = e.getKind();
167             NestingKind nestingKind = e.getNestingKind();
168 
169             if (NestingKind.ANONYMOUS == nestingKind) {
170                 // Print out an anonymous class in the style of a
171                 // class instance creation expression rather than a
172                 // class declaration.
173                 writer.print(&quot;new &quot;);
174 
175                 // If the anonymous class implements an interface
176                 // print that name, otherwise print the superclass.
177                 List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
178                 if (!interfaces.isEmpty())
179                     writer.print(interfaces.get(0));
180                 else
181                     writer.print(e.getSuperclass());
182 
183                 writer.print(&quot;(&quot;);
184                 // Anonymous classes that implement an interface can&#39;t
185                 // have any constructor arguments.
186                 if (interfaces.isEmpty()) {
187                     // Print out the parameter list from the sole
188                     // constructor.  For now, don&#39;t try to elide any
189                     // synthetic parameters by determining if the
190                     // anonymous class is in a static context, etc.
191                     List&lt;? extends ExecutableElement&gt; constructors =
192                         ElementFilter.constructorsIn(e.getEnclosedElements());
193 
194                     if (!constructors.isEmpty())
195                         printParameters(constructors.get(0));
196                 }
197                 writer.print(&quot;)&quot;);
198             } else {
199                 if (nestingKind == TOP_LEVEL) {
200                     PackageElement pkg = elementUtils.getPackageOf(e);
201                     if (!pkg.isUnnamed())
202                         writer.print(&quot;package &quot; + pkg.getQualifiedName() + &quot;;\n&quot;);
203                 }
204 
205                 defaultAction(e, true);
206 
207                 switch(kind) {
208                 case ANNOTATION_TYPE:
209                     writer.print(&quot;@interface&quot;);
210                     break;
211                 default:
212                     writer.print(StringUtils.toLowerCase(kind.toString()));
213                 }
214                 writer.print(&quot; &quot;);
215                 writer.print(e.getSimpleName());
216 
217                 printFormalTypeParameters(e, false);
218 
<a name="8" id="anc8"></a>









219                 // Print superclass information if informative
220                 if (kind == CLASS) {
221                     TypeMirror supertype = e.getSuperclass();
222                     if (supertype.getKind() != TypeKind.NONE) {
223                         TypeElement e2 = (TypeElement)
224                             ((DeclaredType) supertype).asElement();
225                         if (e2.getSuperclass().getKind() != TypeKind.NONE)
226                             writer.print(&quot; extends &quot; + supertype);
227                     }
228                 }
229 
230                 printInterfaces(e);
231             }
232             writer.println(&quot; {&quot;);
233             indentation++;
234 
235             if (kind == ENUM) {
236                 List&lt;Element&gt; enclosedElements = new ArrayList&lt;&gt;(e.getEnclosedElements());
237                 // Handle any enum constants specially before other entities.
238                 List&lt;Element&gt; enumConstants = new ArrayList&lt;&gt;();
239                 for(Element element : enclosedElements) {
240                     if (element.getKind() == ENUM_CONSTANT)
241                         enumConstants.add(element);
242                 }
243                 if (!enumConstants.isEmpty()) {
244                     int i;
245                     for(i = 0; i &lt; enumConstants.size()-1; i++) {
246                         this.visit(enumConstants.get(i), true);
247                         writer.print(&quot;,&quot;);
248                     }
249                     this.visit(enumConstants.get(i), true);
250                     writer.println(&quot;;\n&quot;);
251 
252                     enclosedElements.removeAll(enumConstants);
253                 }
254 
255                 for(Element element : enclosedElements)
256                     this.visit(element);
257             } else {
<a name="9" id="anc9"></a><span class="line-modified">258                 for(Element element : e.getEnclosedElements())</span>






259                     this.visit(element);
260             }
261 
262             indentation--;
263             indent();
264             writer.println(&quot;}&quot;);
265             return this;
266         }
267 
268         @Override @DefinedBy(Api.LANGUAGE_MODEL)
269         public PrintingElementVisitor visitVariable(VariableElement e, Boolean newLine) {
270             ElementKind kind = e.getKind();
271             defaultAction(e, newLine);
272 
273             if (kind == ENUM_CONSTANT)
274                 writer.print(e.getSimpleName());
275             else {
276                 writer.print(e.asType().toString() + &quot; &quot; + e.getSimpleName() );
277                 Object constantValue  = e.getConstantValue();
278                 if (constantValue != null) {
279                     writer.print(&quot; = &quot;);
280                     writer.print(elementUtils.getConstantExpression(constantValue));
281                 }
282                 writer.println(&quot;;&quot;);
283             }
284             return this;
285         }
286 
287         @Override @DefinedBy(Api.LANGUAGE_MODEL)
288         public PrintingElementVisitor visitTypeParameter(TypeParameterElement e, Boolean p) {
289             writer.print(e.getSimpleName());
290             return this;
291         }
292 
293         // Should we do more here?
294         @Override @DefinedBy(Api.LANGUAGE_MODEL)
295         public PrintingElementVisitor visitPackage(PackageElement e, Boolean p) {
296             defaultAction(e, false);
297             if (!e.isUnnamed())
298                 writer.println(&quot;package &quot; + e.getQualifiedName() + &quot;;&quot;);
299             else
300                 writer.println(&quot;// Unnamed package&quot;);
301             return this;
302         }
303 
304         @Override @DefinedBy(Api.LANGUAGE_MODEL)
305         public PrintingElementVisitor visitModule(ModuleElement e, Boolean p) {
306             defaultAction(e, false);
307 
308             if (!e.isUnnamed()) {
309                 if (e.isOpen()) {
310                     writer.print(&quot;open &quot;);
311                 }
312                 writer.println(&quot;module &quot; + e.getQualifiedName() + &quot; {&quot;);
313                 indentation++;
314                 for (ModuleElement.Directive directive : e.getDirectives()) {
315                     printDirective(directive);
316                 }
317                 indentation--;
318                 writer.println(&quot;}&quot;);
319             } else
320                 writer.println(&quot;// Unnamed module&quot;); // Should we do more here?
321             return this;
322         }
323 
324         private void printDirective(ModuleElement.Directive directive) {
325             indent();
326             (new PrintDirective(writer)).visit(directive);
327             writer.println(&quot;;&quot;);
328         }
329 
330         private static class PrintDirective implements ModuleElement.DirectiveVisitor&lt;Void, Void&gt; {
331             private final PrintWriter writer;
332 
333             PrintDirective(PrintWriter writer) {
334                 this.writer = writer;
335             }
336 
337             @Override @DefinedBy(Api.LANGUAGE_MODEL)
338             public Void visitExports(ExportsDirective d, Void p) {
339                 // &quot;exports package-name [to module-name-list]&quot;
340                 writer.print(&quot;exports &quot;);
341                 writer.print(d.getPackage().getQualifiedName());
342                 printModuleList(d.getTargetModules());
343                 return null;
344             }
345 
346             @Override @DefinedBy(Api.LANGUAGE_MODEL)
347             public Void visitOpens(OpensDirective d, Void p) {
348                 // opens package-name [to module-name-list]
349                 writer.print(&quot;opens &quot;);
350                 writer.print(d.getPackage().getQualifiedName());
351                 printModuleList(d.getTargetModules());
352                 return null;
353             }
354 
355             @Override @DefinedBy(Api.LANGUAGE_MODEL)
356             public Void visitProvides(ProvidesDirective d, Void p) {
357                 // provides service-name with implementation-name
358                 writer.print(&quot;provides &quot;);
359                 writer.print(d.getService().getQualifiedName());
360                 writer.print(&quot; with &quot;);
361                 printNameableList(d.getImplementations());
362                 return null;
363             }
364 
365             @Override @DefinedBy(Api.LANGUAGE_MODEL)
366             public Void visitRequires(RequiresDirective d, Void p) {
367                 // requires (static|transitive)* module-name
368                 writer.print(&quot;requires &quot;);
369                 if (d.isStatic())
370                     writer.print(&quot;static &quot;);
371                 if (d.isTransitive())
372                     writer.print(&quot;transitive &quot;);
373                 writer.print(d.getDependency().getQualifiedName());
374                 return null;
375             }
376 
377             @Override @DefinedBy(Api.LANGUAGE_MODEL)
378             public Void visitUses(UsesDirective d, Void p) {
379                 // uses service-name
380                 writer.print(&quot;uses &quot;);
381                 writer.print(d.getService().getQualifiedName());
382                 return null;
383             }
384 
385             private void printModuleList(List&lt;? extends ModuleElement&gt; modules) {
386                 if (modules != null) {
387                     writer.print(&quot; to &quot;);
388                     printNameableList(modules);
389                 }
390             }
391 
392             private void printNameableList(List&lt;? extends QualifiedNameable&gt; nameables) {
393                 writer.print(nameables.stream().
394                              map(QualifiedNameable::getQualifiedName).
395                              collect(Collectors.joining(&quot;, &quot;)));
396             }
397         }
398 
399         public void flush() {
400             writer.flush();
401         }
402 
403         private void printDocComment(Element e) {
404             String docComment = elementUtils.getDocComment(e);
405 
406             if (docComment != null) {
407                 // Break comment into lines
408                 java.util.StringTokenizer st = new StringTokenizer(docComment,
409                                                                   &quot;\n\r&quot;);
410                 indent();
411                 writer.println(&quot;/**&quot;);
412 
413                 while(st.hasMoreTokens()) {
414                     indent();
415                     writer.print(&quot; *&quot;);
416                     writer.println(st.nextToken());
417                 }
418 
419                 indent();
420                 writer.println(&quot; */&quot;);
421             }
422         }
423 
424         private void printModifiers(Element e) {
425             ElementKind kind = e.getKind();
426             if (kind == PARAMETER) {
<a name="10" id="anc10"></a><span class="line-modified">427                 printAnnotationsInline(e);</span>

428             } else {
429                 printAnnotations(e);
430                 indent();
431             }
432 
433             if (kind == ENUM_CONSTANT)
434                 return;
435 
436             Set&lt;Modifier&gt; modifiers = new LinkedHashSet&lt;&gt;();
437             modifiers.addAll(e.getModifiers());
438 
439             switch (kind) {
440             case ANNOTATION_TYPE:
441             case INTERFACE:
442                 modifiers.remove(Modifier.ABSTRACT);
443                 break;
444 
445             case ENUM:
446                 modifiers.remove(Modifier.FINAL);
447                 modifiers.remove(Modifier.ABSTRACT);
448                 break;
449 
<a name="11" id="anc11"></a>



450             case METHOD:
451             case FIELD:
452                 Element enclosingElement = e.getEnclosingElement();
453                 if (enclosingElement != null &amp;&amp;
454                     enclosingElement.getKind().isInterface()) {
455                     modifiers.remove(Modifier.PUBLIC);
456                     modifiers.remove(Modifier.ABSTRACT); // only for methods
457                     modifiers.remove(Modifier.STATIC);   // only for fields
458                     modifiers.remove(Modifier.FINAL);    // only for fields
459                 }
460                 break;
461 
462             }
<a name="12" id="anc12"></a><span class="line-modified">463 </span>
<span class="line-modified">464             for(Modifier m: modifiers) {</span>
<span class="line-modified">465                 writer.print(m.toString() + &quot; &quot;);</span>

466             }
467         }
468 
469         private void printFormalTypeParameters(Parameterizable e,
470                                                boolean pad) {
471             List&lt;? extends TypeParameterElement&gt; typeParams = e.getTypeParameters();
<a name="13" id="anc13"></a><span class="line-modified">472             if (typeParams.size() &gt; 0) {</span>
<span class="line-modified">473                 writer.print(&quot;&lt;&quot;);</span>
<span class="line-modified">474 </span>
<span class="line-modified">475                 boolean first = true;</span>
<span class="line-removed">476                 for(TypeParameterElement tpe: typeParams) {</span>
<span class="line-removed">477                     if (!first)</span>
<span class="line-removed">478                         writer.print(&quot;, &quot;);</span>
<span class="line-removed">479                     printAnnotationsInline(tpe);</span>
<span class="line-removed">480                     writer.print(tpe.toString());</span>
<span class="line-removed">481                     first = false;</span>
<span class="line-removed">482                 }</span>
<span class="line-removed">483 </span>
<span class="line-removed">484                 writer.print(&quot;&gt;&quot;);</span>
485                 if (pad)
486                     writer.print(&quot; &quot;);
487             }
488         }
489 
<a name="14" id="anc14"></a><span class="line-modified">490         private void printAnnotationsInline(Element e) {</span>
<span class="line-modified">491             List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();</span>
<span class="line-modified">492             for(AnnotationMirror annotationMirror : annots) {</span>
<span class="line-modified">493                 writer.print(annotationMirror);</span>
<span class="line-modified">494                 writer.print(&quot; &quot;);</span>
<span class="line-modified">495             }</span>

496         }
497 
498         private void printAnnotations(Element e) {
499             List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();
500             for(AnnotationMirror annotationMirror : annots) {
501                 indent();
502                 writer.println(annotationMirror);
503             }
504         }
505 
506         // TODO: Refactor
507         private void printParameters(ExecutableElement e) {
508             List&lt;? extends VariableElement&gt; parameters = e.getParameters();
509             int size = parameters.size();
510 
511             switch (size) {
512             case 0:
513                 break;
514 
515             case 1:
516                 for(VariableElement parameter: parameters) {
517                     printModifiers(parameter);
518 
519                     if (e.isVarArgs() ) {
520                         TypeMirror tm = parameter.asType();
521                         if (tm.getKind() != TypeKind.ARRAY)
522                             throw new AssertionError(&quot;Var-args parameter is not an array type: &quot; + tm);
523                         writer.print((ArrayType.class.cast(tm)).getComponentType() );
524                         writer.print(&quot;...&quot;);
525                     } else
526                         writer.print(parameter.asType());
527                     writer.print(&quot; &quot; + parameter.getSimpleName());
528                 }
529                 break;
530 
531             default:
532                 {
533                     int i = 1;
534                     for(VariableElement parameter: parameters) {
535                         if (i == 2)
536                             indentation++;
537 
538                         if (i &gt; 1)
539                             indent();
540 
541                         printModifiers(parameter);
542 
543                         if (i == size &amp;&amp; e.isVarArgs() ) {
544                             TypeMirror tm = parameter.asType();
545                             if (tm.getKind() != TypeKind.ARRAY)
546                                 throw new AssertionError(&quot;Var-args parameter is not an array type: &quot; + tm);
547                                     writer.print((ArrayType.class.cast(tm)).getComponentType() );
548 
549                             writer.print(&quot;...&quot;);
550                         } else
551                             writer.print(parameter.asType());
552                         writer.print(&quot; &quot; + parameter.getSimpleName());
553 
554                         if (i &lt; size)
555                             writer.println(&quot;,&quot;);
556 
557                         i++;
558                     }
559 
560                     if (parameters.size() &gt;= 2)
561                         indentation--;
562                 }
563                 break;
564             }
565         }
566 
567         private void printInterfaces(TypeElement e) {
568             ElementKind kind = e.getKind();
569 
570             if(kind != ANNOTATION_TYPE) {
571                 List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
<a name="15" id="anc15"></a><span class="line-modified">572                 if (interfaces.size() &gt; 0) {</span>
<span class="line-modified">573                     writer.print((kind.isClass() ? &quot; implements&quot; : &quot; extends&quot;));</span>
<span class="line-modified">574 </span>
<span class="line-modified">575                     boolean first = true;</span>
<span class="line-modified">576                     for(TypeMirror interf: interfaces) {</span>
<span class="line-removed">577                         if (!first)</span>
<span class="line-removed">578                             writer.print(&quot;,&quot;);</span>
<span class="line-removed">579                         writer.print(&quot; &quot;);</span>
<span class="line-removed">580                         writer.print(interf.toString());</span>
<span class="line-removed">581                         first = false;</span>
<span class="line-removed">582                     }</span>
583                 }
584             }
585         }
586 
587         private void printThrows(ExecutableElement e) {
588             List&lt;? extends TypeMirror&gt; thrownTypes = e.getThrownTypes();
589             final int size = thrownTypes.size();
590             if (size != 0) {
591                 writer.print(&quot; throws&quot;);
592 
593                 int i = 1;
594                 for(TypeMirror thrownType: thrownTypes) {
595                     if (i == 1)
596                         writer.print(&quot; &quot;);
597 
598                     if (i == 2)
599                         indentation++;
600 
601                     if (i &gt;= 2)
602                         indent();
603 
604                     writer.print(thrownType);
605 
606                     if (i != size)
607                         writer.println(&quot;, &quot;);
608 
609                     i++;
610                 }
611 
612                 if (size &gt;= 2)
613                     indentation--;
614             }
615         }
616 
617         private static final String [] spaces = {
618             &quot;&quot;,
619             &quot;  &quot;,
620             &quot;    &quot;,
621             &quot;      &quot;,
622             &quot;        &quot;,
623             &quot;          &quot;,
624             &quot;            &quot;,
625             &quot;              &quot;,
626             &quot;                &quot;,
627             &quot;                  &quot;,
628             &quot;                    &quot;
629         };
630 
631         private void indent() {
632             int indentation = this.indentation;
633             if (indentation &lt; 0)
634                 return;
635             final int maxIndex = spaces.length - 1;
636 
637             while (indentation &gt; maxIndex) {
638                 writer.print(spaces[maxIndex]);
639                 indentation -= maxIndex;
640             }
641             writer.print(spaces[indentation]);
642         }
643 
644     }
645 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,10 +25,11 @@
 
 package com.sun.tools.javac.file;
 
 import java.io.File;
 import java.io.IOException;
+import java.io.UncheckedIOException;
 import java.lang.module.Configuration;
 import java.lang.module.ModuleFinder;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -69,10 +70,11 @@
 import javax.tools.JavaFileObject;
 import javax.tools.StandardJavaFileManager;
 
 import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
 import com.sun.tools.javac.file.RelativePath.RelativeFile;
+import com.sun.tools.javac.main.Option;
 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 import com.sun.tools.javac.util.Assert;
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.Context.Factory;
 import com.sun.tools.javac.util.DefinedBy;
@@ -126,10 +128,23 @@
         }
     }
 
     protected SortFiles sortFiles;
 
+    /**
+     * We use a two-layered map instead of a map with a complex key because we don't want to reindex
+     * the values for every Location+RelativeDirectory pair. Once the PathsAndContainers are needed
+     * for a single Location, we should know all valid RelativeDirectory mappings. Because the
+     * indexing is costly for very large classpaths, this can result in a significant savings.
+     */
+    private Map<Location, Map<RelativeDirectory, java.util.List<PathAndContainer>>>
+        pathsAndContainersByLocationAndRelativeDirectory = new HashMap<>();
+
+    /** Containers that have no indexing by {@link RelativeDirectory}, keyed by {@link Location}. */
+    private Map<Location, java.util.List<PathAndContainer>> nonIndexingContainersByLocation =
+        new HashMap<>();
+
     /**
      * Register a Context.Factory to create a JavacFileManager.
      */
     public static void preRegister(Context context) {
         context.put(JavaFileManager.class,
@@ -336,10 +351,17 @@
                                   Set<JavaFileObject.Kind> fileKinds,
                                   boolean recurse,
                                   ListBuffer<JavaFileObject> resultList) throws IOException;
         public abstract JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException;
         public abstract void close() throws IOException;
+        public abstract boolean maintainsDirectoryIndex();
+
+        /**
+         * The directories this container indexes if {@link #maintainsDirectoryIndex()}, otherwise
+         * an empty iterable.
+         */
+        public abstract Iterable<RelativeDirectory> indexedDirectories();
     }
 
     private static final Container MISSING_CONTAINER =  new Container() {
         @Override
         public void list(Path userPath,
@@ -352,10 +374,18 @@
         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
             return null;
         }
         @Override
         public void close() throws IOException {}
+        @Override
+        public boolean maintainsDirectoryIndex() {
+            return false;
+        }
+        @Override
+        public Iterable<RelativeDirectory> indexedDirectories() {
+            return List.nil();
+        }
     };
 
     private final class JRTImageContainer implements Container {
 
         /**
@@ -405,10 +435,20 @@
         }
 
         @Override
         public void close() throws IOException {
         }
+
+        @Override
+        public boolean maintainsDirectoryIndex() {
+            return false;
+        }
+
+        @Override
+        public Iterable<RelativeDirectory> indexedDirectories() {
+            return List.nil();
+        }
     }
 
     private synchronized JRTIndex getJRTIndex() {
         if (jrtIndex == null)
             jrtIndex = JRTIndex.getSharedInstance();
@@ -496,29 +536,39 @@
         }
 
         @Override
         public void close() throws IOException {
         }
+
+        @Override
+        public boolean maintainsDirectoryIndex() {
+            return false;
+        }
+
+        @Override
+        public Iterable<RelativeDirectory> indexedDirectories() {
+            return List.nil();
+        }
     }
 
     private static final Set<FileVisitOption> NO_FILE_VISIT_OPTIONS = Set.of();
     private static final Set<FileVisitOption> FOLLOW_LINKS_OPTIONS = Set.of(FOLLOW_LINKS);
 
     private final class ArchiveContainer implements Container {
         private final Path archivePath;
         private final FileSystem fileSystem;
-        private final Map<RelativePath, Path> packages;
+        private final Map<RelativeDirectory, Path> packages;
 
         public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {
             this.archivePath = archivePath;
             if (multiReleaseValue != null && archivePath.toString().endsWith(".jar")) {
                 Map<String,String> env = Collections.singletonMap("multi-release", multiReleaseValue);
                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();
                 Assert.checkNonNull(jarFSProvider, "should have been caught before!");
                 this.fileSystem = jarFSProvider.newFileSystem(archivePath, env);
             } else {
-                this.fileSystem = FileSystems.newFileSystem(archivePath, null);
+                this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);
             }
             packages = new HashMap<>();
             for (Path root : fileSystem.getRootDirectories()) {
                 Files.walkFileTree(root, NO_FILE_VISIT_OPTIONS, Integer.MAX_VALUE,
                         new SimpleFileVisitor<Path>() {
@@ -602,10 +652,20 @@
 
         @Override
         public void close() throws IOException {
             fileSystem.close();
         }
+
+        @Override
+        public boolean maintainsDirectoryIndex() {
+            return true;
+        }
+
+        @Override
+        public Iterable<RelativeDirectory> indexedDirectories() {
+            return packages.keySet();
+        }
     }
 
     /**
      * container is a directory, a zip file, or a non-existent path.
      */
@@ -652,10 +712,12 @@
     /** Flush any output resources.
      */
     @Override @DefinedBy(Api.COMPILER)
     public void flush() {
         contentCache.clear();
+        pathsAndContainersByLocationAndRelativeDirectory.clear();
+        nonIndexingContainersByLocation.clear();
     }
 
     /**
      * Close the JavaFileManager, releasing resources.
      */
@@ -669,10 +731,12 @@
         locations.close();
         for (Container container: containers.values()) {
             container.close();
         }
         containers.clear();
+        pathsAndContainersByLocationAndRelativeDirectory.clear();
+        nonIndexingContainersByLocation.clear();
         contentCache.clear();
     }
 
     @Override @DefinedBy(Api.COMPILER)
     public ClassLoader getClassLoader(Location location) {
@@ -702,19 +766,16 @@
         checkNotModuleOrientedLocation(location);
         // validatePackageName(packageName);
         nullCheck(packageName);
         nullCheck(kinds);
 
-        Iterable<? extends Path> path = getLocationAsPaths(location);
-        if (path == null)
-            return List.nil();
         RelativeDirectory subdirectory = RelativeDirectory.forPackage(packageName);
         ListBuffer<JavaFileObject> results = new ListBuffer<>();
 
-        for (Path directory : path) {
-            Container container = getContainer(directory);
-
+        for (PathAndContainer pathAndContainer : pathsAndContainers(location, subdirectory)) {
+            Path directory = pathAndContainer.path;
+            Container container = pathAndContainer.container;
             container.list(directory, subdirectory, kinds, recurse, results);
         }
 
         return results.toList();
     }
@@ -895,11 +956,11 @@
         return result;
     }
 
     @Override @DefinedBy(Api.COMPILER)
     public Iterable<? extends JavaFileObject> getJavaFileObjectsFromPaths(
-        Iterable<? extends Path> paths)
+        Collection<? extends Path> paths)
     {
         ArrayList<PathFileObject> result;
         if (paths instanceof Collection<?>)
             result = new ArrayList<>(((Collection<?>)paths).size());
         else
@@ -925,33 +986,137 @@
                             Iterable<? extends File> searchpath)
         throws IOException
     {
         nullCheck(location);
         locations.setLocation(location, asPaths(searchpath));
+        clearCachesForLocation(location);
     }
 
     @Override @DefinedBy(Api.COMPILER)
     public void setLocationFromPaths(Location location,
                             Collection<? extends Path> searchpath)
         throws IOException
     {
         nullCheck(location);
         locations.setLocation(location, nullCheck(searchpath));
+        clearCachesForLocation(location);
     }
 
     @Override @DefinedBy(Api.COMPILER)
     public Iterable<? extends File> getLocation(Location location) {
         nullCheck(location);
         return asFiles(locations.getLocation(location));
     }
 
     @Override @DefinedBy(Api.COMPILER)
-    public Iterable<? extends Path> getLocationAsPaths(Location location) {
+    public Collection<? extends Path> getLocationAsPaths(Location location) {
         nullCheck(location);
         return locations.getLocation(location);
     }
 
+    private java.util.List<PathAndContainer> pathsAndContainers(
+            Location location, RelativeDirectory relativeDirectory) throws IOException {
+        try {
+            return pathsAndContainersByLocationAndRelativeDirectory.computeIfAbsent(
+                    location, this::indexPathsAndContainersByRelativeDirectory)
+                .computeIfAbsent(
+                    relativeDirectory, d -> nonIndexingContainersByLocation.get(location));
+        } catch (UncheckedIOException e) {
+            throw e.getCause();
+        }
+    }
+
+    private Map<RelativeDirectory, java.util.List<PathAndContainer>> indexPathsAndContainersByRelativeDirectory(
+            Location location) {
+        Map<RelativeDirectory, java.util.List<PathAndContainer>> result = new HashMap<>();
+        java.util.List<PathAndContainer> allPathsAndContainers = pathsAndContainers(location);
+
+        // First collect all of the containers that don't maintain their own index on
+        // RelativeDirectory. These need to always be included for all mappings
+        java.util.List<PathAndContainer> nonIndexingContainers = new ArrayList<>();
+        for (PathAndContainer pathAndContainer : allPathsAndContainers) {
+            if (!pathAndContainer.container.maintainsDirectoryIndex()) {
+                nonIndexingContainers.add(pathAndContainer);
+            }
+        }
+
+        // Next, use the container that do maintain their own RelativeDirectory index to create a
+        // single master index.
+        for (PathAndContainer pathAndContainer : allPathsAndContainers) {
+            Container container = pathAndContainer.container;
+            if (container.maintainsDirectoryIndex()) {
+                for (RelativeDirectory directory : container.indexedDirectories()) {
+                    result.computeIfAbsent(directory, d -> new ArrayList<>(nonIndexingContainers))
+                          .add(pathAndContainer);
+                }
+            }
+        }
+        nonIndexingContainersByLocation.put(location, nonIndexingContainers);
+
+        // Sorting preserves the search order used in the uncached Location path, which has
+        // maintains consistency with the classpath order
+        result.values().forEach(pathAndContainerList -> Collections.sort(pathAndContainerList));
+
+        return result;
+    }
+
+    /**
+     * For each {@linkplain #getLocationAsPaths(Location) path of the location}, compute the
+     * corresponding {@link Container}.
+     */
+    private java.util.List<PathAndContainer> pathsAndContainers(Location location) {
+        Collection<? extends Path> paths = getLocationAsPaths(location);
+        if (paths == null) {
+            return List.nil();
+        }
+        java.util.List<PathAndContainer> pathsAndContainers =
+            new ArrayList<>(paths.size());
+        for (Path path : paths) {
+            Container container;
+            try {
+                container = getContainer(path);
+            } catch (IOException e) {
+                throw new UncheckedIOException(e);
+            }
+            pathsAndContainers.add(new PathAndContainer(path, container, pathsAndContainers.size()));
+        }
+        return pathsAndContainers;
+    }
+
+    private static class PathAndContainer implements Comparable<PathAndContainer> {
+        private final Path path;
+        private final Container container;
+        private final int index;
+
+        PathAndContainer(Path path, Container container, int index) {
+            this.path = path;
+            this.container = container;
+            this.index = index;
+        }
+
+        @Override
+        public int compareTo(PathAndContainer other) {
+            return index - other.index;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+          if (o == null || !(o instanceof PathAndContainer)) {
+            return false;
+          }
+          PathAndContainer that = (PathAndContainer) o;
+          return path.equals(that.path)
+              && container.equals(that.container)
+              && index == this.index;
+        }
+
+        @Override
+        public int hashCode() {
+          return Objects.hash(path, container, index);
+        }
+    }
+
     @Override @DefinedBy(Api.COMPILER)
     public boolean contains(Location location, FileObject fo) throws IOException {
         nullCheck(location);
         nullCheck(fo);
         Path p = asPath(fo);
@@ -1006,10 +1171,11 @@
     public void setLocationForModule(Location location, String moduleName, Collection<? extends Path> paths)
             throws IOException {
         nullCheck(location);
         checkModuleOrientedOrOutputLocation(location);
         locations.setLocationForModule(location, nullCheck(moduleName), nullCheck(paths));
+        clearCachesForLocation(location);
     }
 
     @Override @DefinedBy(Api.COMPILER)
     public String inferModuleName(Location location) {
         checkNotModuleOrientedLocation(location);
@@ -1081,11 +1247,11 @@
 
     /**
      * Get a detail message from an IOException.
      * Most, but not all, instances of IOException provide a non-null result
      * for getLocalizedMessage().  But some instances return null: in these
-     * cases, fallover to getMessage(), and if even that is null, return the
+     * cases, fall back to getMessage(), and if even that is null, return the
      * name of the exception itself.
      * @param e an IOException
      * @return a string to include in a compiler diagnostic
      */
     public static String getMessage(IOException e) {
@@ -1161,6 +1327,21 @@
                     throw new IllegalStateException(e);
                 }
             }
         };
     }
+
+    @Override
+    public boolean handleOption(Option option, String value) {
+        if (javacFileManagerOptions.contains(option)) {
+            pathsAndContainersByLocationAndRelativeDirectory.clear();
+            nonIndexingContainersByLocation.clear();
+        }
+        return super.handleOption(option, value);
+    }
+
+    private void clearCachesForLocation(Location location) {
+        nullCheck(location);
+        pathsAndContainersByLocationAndRelativeDirectory.remove(location);
+        nonIndexingContainersByLocation.remove(location);
+    }
 }

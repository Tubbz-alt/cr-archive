<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SymbolMetadata.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.util.Collection;
 29 import java.util.Collections;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.LinkedHashMap;
 33 import java.util.Map;
 34 
 35 import javax.lang.model.element.ElementVisitor;
 36 
 37 import com.sun.tools.javac.code.Scope.WriteableScope;
 38 import com.sun.tools.javac.code.Source.Feature;
 39 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 40 import com.sun.tools.javac.code.Symbol.Completer;
 41 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 42 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 43 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 44 import com.sun.tools.javac.code.Symbol.PackageSymbol;

 45 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 46 import com.sun.tools.javac.code.Symbol.VarSymbol;
 47 import com.sun.tools.javac.code.Type.BottomType;
 48 import com.sun.tools.javac.code.Type.ClassType;
 49 import com.sun.tools.javac.code.Type.ErrorType;
 50 import com.sun.tools.javac.code.Type.JCPrimitiveType;
 51 import com.sun.tools.javac.code.Type.JCVoidType;
 52 import com.sun.tools.javac.code.Type.MethodType;
 53 import com.sun.tools.javac.code.Type.UnknownType;
 54 import com.sun.tools.javac.code.Types.UniqueType;
 55 import com.sun.tools.javac.comp.Modules;
 56 import com.sun.tools.javac.util.Assert;
 57 import com.sun.tools.javac.util.Context;
 58 import com.sun.tools.javac.util.Convert;
 59 import com.sun.tools.javac.util.DefinedBy;
 60 import com.sun.tools.javac.util.DefinedBy.Api;
 61 import com.sun.tools.javac.util.Iterators;
 62 import com.sun.tools.javac.util.JavacMessages;
 63 import com.sun.tools.javac.util.List;
 64 import com.sun.tools.javac.util.Name;
</pre>
<hr />
<pre>
143     /** A value for the unknown type. */
144     public final Type unknownType;
145 
146     /** The builtin type of all arrays. */
147     public final ClassSymbol arrayClass;
148     public final MethodSymbol arrayCloneMethod;
149 
150     /** VGJ: The (singleton) type of all bound types. */
151     public final ClassSymbol boundClass;
152 
153     /** The builtin type of all methods. */
154     public final ClassSymbol methodClass;
155 
156     /** A symbol for the java.base module.
157      */
158     public final ModuleSymbol java_base;
159 
160     /** Predefined types.
161      */
162     public final Type objectType;

163     public final Type objectsType;
164     public final Type classType;
165     public final Type classLoaderType;
166     public final Type stringType;
167     public final Type stringBufferType;
168     public final Type stringBuilderType;
169     public final Type cloneableType;
170     public final Type serializableType;
171     public final Type serializedLambdaType;
172     public final Type varHandleType;
173     public final Type methodHandleType;
174     public final Type methodHandleLookupType;
175     public final Type methodTypeType;
176     public final Type nativeHeaderType;
177     public final Type throwableType;
178     public final Type errorType;
179     public final Type interruptedExceptionType;
180     public final Type illegalArgumentExceptionType;
181     public final Type exceptionType;
182     public final Type runtimeExceptionType;
</pre>
<hr />
<pre>
196     public final Type iterableType;
197     public final Type iteratorType;
198     public final Type annotationTargetType;
199     public final Type overrideType;
200     public final Type retentionType;
201     public final Type deprecatedType;
202     public final Type suppressWarningsType;
203     public final Type supplierType;
204     public final Type inheritedType;
205     public final Type profileType;
206     public final Type proprietaryType;
207     public final Type systemType;
208     public final Type autoCloseableType;
209     public final Type trustMeType;
210     public final Type lambdaMetafactory;
211     public final Type stringConcatFactory;
212     public final Type repeatableType;
213     public final Type documentedType;
214     public final Type elementTypeType;
215     public final Type functionalInterfaceType;



216 
217     /** The symbol representing the length field of an array.
218      */
219     public final VarSymbol lengthVar;
220 
221     /** The symbol representing the final finalize method on enums */
222     public final MethodSymbol enumFinalFinalize;
223 
224     /** The symbol representing the close method on TWR AutoCloseable type */
225     public final MethodSymbol autoCloseableClose;
226 
227     /** The predefined type that belongs to a tag.
228      */
229     public final Type[] typeOfTag = new Type[TypeTag.getTypeTagCount()];
230 
231     /** The name of the class that belongs to a basic type tag.
232      */
233     public final Name[] boxedName = new Name[TypeTag.getTypeTagCount()];
234 
235     /** A hashtable containing the encountered top-level and member classes,
</pre>
<hr />
<pre>
365         type.typarams_field = List.nil();
366         type.allparams_field = List.nil();
367         type.supertype_field = annotationType;
368         type.interfaces_field = List.nil();
369         return type;
370     }
371 
372     /** Constructor; enters all predefined identifiers and operators
373      *  into symbol table.
374      */
375     protected Symtab(Context context) throws CompletionFailure {
376         context.put(symtabKey, this);
377 
378         names = Names.instance(context);
379 
380         // Create the unknown type
381         unknownType = new UnknownType();
382 
383         messages = JavacMessages.instance(context);
384 
<span class="line-modified">385         rootPackage = new PackageSymbol(names.empty, null);</span>


386 
387         // create the basic builtin symbols
388         unnamedModule = new ModuleSymbol(names.empty, null) {
389                 {
390                     directives = List.nil();
391                     exports = List.nil();
392                     provides = List.nil();
393                     uses = List.nil();
394                     ModuleSymbol java_base = enterModule(names.java_base);
395                     com.sun.tools.javac.code.Directive.RequiresDirective d =
396                             new com.sun.tools.javac.code.Directive.RequiresDirective(java_base,
397                                     EnumSet.of(com.sun.tools.javac.code.Directive.RequiresFlag.MANDATED));
398                     requires = List.of(d);
399                 }
400                 @Override
401                 public String toString() {
402                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.module&quot;);
403                 }
404             };
405         addRootPackageFor(unnamedModule);
</pre>
<hr />
<pre>
488         scope.enter(errType.tsym);
489 
490         // Enter symbol for the errSymbol
491         scope.enter(errSymbol);
492 
493         Source source = Source.instance(context);
494         if (Feature.MODULES.allowedInSource(source)) {
495             java_base = enterModule(names.java_base);
496             //avoid completing java.base during the Symtab initialization
497             java_base.completer = Completer.NULL_COMPLETER;
498             java_base.visiblePackages = Collections.emptyMap();
499         } else {
500             java_base = noModule;
501         }
502 
503         // Get the initial completer for ModuleSymbols from Modules
504         moduleCompleter = Modules.instance(context).getCompleter();
505 
506         // Enter predefined classes. All are assumed to be in the java.base module.
507         objectType = enterClass(&quot;java.lang.Object&quot;);

508         objectsType = enterClass(&quot;java.util.Objects&quot;);
509         classType = enterClass(&quot;java.lang.Class&quot;);
510         stringType = enterClass(&quot;java.lang.String&quot;);
511         stringBufferType = enterClass(&quot;java.lang.StringBuffer&quot;);
512         stringBuilderType = enterClass(&quot;java.lang.StringBuilder&quot;);
513         cloneableType = enterClass(&quot;java.lang.Cloneable&quot;);
514         throwableType = enterClass(&quot;java.lang.Throwable&quot;);
515         serializableType = enterClass(&quot;java.io.Serializable&quot;);
516         serializedLambdaType = enterClass(&quot;java.lang.invoke.SerializedLambda&quot;);
517         varHandleType = enterClass(&quot;java.lang.invoke.VarHandle&quot;);
518         methodHandleType = enterClass(&quot;java.lang.invoke.MethodHandle&quot;);
519         methodHandleLookupType = enterClass(&quot;java.lang.invoke.MethodHandles$Lookup&quot;);
520         methodTypeType = enterClass(&quot;java.lang.invoke.MethodType&quot;);
521         errorType = enterClass(&quot;java.lang.Error&quot;);
522         illegalArgumentExceptionType = enterClass(&quot;java.lang.IllegalArgumentException&quot;);
523         interruptedExceptionType = enterClass(&quot;java.lang.InterruptedException&quot;);
524         exceptionType = enterClass(&quot;java.lang.Exception&quot;);
525         runtimeExceptionType = enterClass(&quot;java.lang.RuntimeException&quot;);
526         classNotFoundExceptionType = enterClass(&quot;java.lang.ClassNotFoundException&quot;);
527         noClassDefFoundErrorType = enterClass(&quot;java.lang.NoClassDefFoundError&quot;);
</pre>
<hr />
<pre>
550         retentionType = enterClass(&quot;java.lang.annotation.Retention&quot;);
551         deprecatedType = enterClass(&quot;java.lang.Deprecated&quot;);
552         suppressWarningsType = enterClass(&quot;java.lang.SuppressWarnings&quot;);
553         supplierType = enterClass(&quot;java.util.function.Supplier&quot;);
554         inheritedType = enterClass(&quot;java.lang.annotation.Inherited&quot;);
555         repeatableType = enterClass(&quot;java.lang.annotation.Repeatable&quot;);
556         documentedType = enterClass(&quot;java.lang.annotation.Documented&quot;);
557         elementTypeType = enterClass(&quot;java.lang.annotation.ElementType&quot;);
558         systemType = enterClass(&quot;java.lang.System&quot;);
559         autoCloseableType = enterClass(&quot;java.lang.AutoCloseable&quot;);
560         autoCloseableClose = new MethodSymbol(PUBLIC,
561                              names.close,
562                              new MethodType(List.nil(), voidType,
563                                             List.of(exceptionType), methodClass),
564                              autoCloseableType.tsym);
565         trustMeType = enterClass(&quot;java.lang.SafeVarargs&quot;);
566         nativeHeaderType = enterClass(&quot;java.lang.annotation.Native&quot;);
567         lambdaMetafactory = enterClass(&quot;java.lang.invoke.LambdaMetafactory&quot;);
568         stringConcatFactory = enterClass(&quot;java.lang.invoke.StringConcatFactory&quot;);
569         functionalInterfaceType = enterClass(&quot;java.lang.FunctionalInterface&quot;);



570 
571         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
572         synthesizeEmptyInterfaceIfMissing(cloneableType);
573         synthesizeEmptyInterfaceIfMissing(serializableType);
574         synthesizeEmptyInterfaceIfMissing(lambdaMetafactory);
575         synthesizeEmptyInterfaceIfMissing(serializedLambdaType);
576         synthesizeEmptyInterfaceIfMissing(stringConcatFactory);
577         synthesizeBoxTypeIfMissing(doubleType);
578         synthesizeBoxTypeIfMissing(floatType);
579         synthesizeBoxTypeIfMissing(voidType);
580 
581         // Enter a synthetic class that is used to mark internal
582         // proprietary classes in ct.sym.  This class does not have a
583         // class file.
584         proprietaryType = enterSyntheticAnnotation(&quot;sun.Proprietary+Annotation&quot;);
585 
586         // Enter a synthetic class that is used to provide profile info for
587         // classes in ct.sym.  This class does not have a class file.
588         profileType = enterSyntheticAnnotation(&quot;jdk.Profile+Annotation&quot;);
589         MethodSymbol m = new MethodSymbol(PUBLIC | ABSTRACT, names.value, intType, profileType.tsym);
</pre>
<hr />
<pre>
763         }
764         return p;
765     }
766 
767     private void doEnterPackage(ModuleSymbol msym, PackageSymbol pack) {
768         packages.computeIfAbsent(pack.fullname, n -&gt; new HashMap&lt;&gt;()).put(msym, pack);
769         msym.enclosedPackages = msym.enclosedPackages.prepend(pack);
770     }
771 
772     private void addRootPackageFor(ModuleSymbol module) {
773         doEnterPackage(module, rootPackage);
774         PackageSymbol unnamedPackage = new PackageSymbol(names.empty, rootPackage) {
775                 @Override
776                 public String toString() {
777                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.package&quot;);
778                 }
779             };
780         unnamedPackage.modle = module;
781         //we cannot use a method reference below, as initialCompleter might be null now
782         unnamedPackage.completer = s -&gt; initialCompleter.complete(s);

783         module.unnamedPackage = unnamedPackage;
784     }
785 
786     public PackageSymbol getPackage(ModuleSymbol module, Name fullname) {
787         return packages.getOrDefault(fullname, Collections.emptyMap()).get(module);
788     }
789 
790     public ModuleSymbol enterModule(Name name) {
791         ModuleSymbol msym = modules.get(name);
792         if (msym == null) {
793             msym = ModuleSymbol.create(name, names.module_info);
794             addRootPackageFor(msym);
795             msym.completer = s -&gt; moduleCompleter.complete(s); //bootstrap issues
796             modules.put(name, msym);
797         }
798         return msym;
799     }
800 
801     public ModuleSymbol getModule(Name name) {
802         return modules.get(name);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.util.Collection;
 29 import java.util.Collections;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.LinkedHashMap;
 33 import java.util.Map;
 34 
 35 import javax.lang.model.element.ElementVisitor;
 36 
 37 import com.sun.tools.javac.code.Scope.WriteableScope;
 38 import com.sun.tools.javac.code.Source.Feature;
 39 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 40 import com.sun.tools.javac.code.Symbol.Completer;
 41 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 42 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 43 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 44 import com.sun.tools.javac.code.Symbol.PackageSymbol;
<span class="line-added"> 45 import com.sun.tools.javac.code.Symbol.RootPackageSymbol;</span>
 46 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 47 import com.sun.tools.javac.code.Symbol.VarSymbol;
 48 import com.sun.tools.javac.code.Type.BottomType;
 49 import com.sun.tools.javac.code.Type.ClassType;
 50 import com.sun.tools.javac.code.Type.ErrorType;
 51 import com.sun.tools.javac.code.Type.JCPrimitiveType;
 52 import com.sun.tools.javac.code.Type.JCVoidType;
 53 import com.sun.tools.javac.code.Type.MethodType;
 54 import com.sun.tools.javac.code.Type.UnknownType;
 55 import com.sun.tools.javac.code.Types.UniqueType;
 56 import com.sun.tools.javac.comp.Modules;
 57 import com.sun.tools.javac.util.Assert;
 58 import com.sun.tools.javac.util.Context;
 59 import com.sun.tools.javac.util.Convert;
 60 import com.sun.tools.javac.util.DefinedBy;
 61 import com.sun.tools.javac.util.DefinedBy.Api;
 62 import com.sun.tools.javac.util.Iterators;
 63 import com.sun.tools.javac.util.JavacMessages;
 64 import com.sun.tools.javac.util.List;
 65 import com.sun.tools.javac.util.Name;
</pre>
<hr />
<pre>
144     /** A value for the unknown type. */
145     public final Type unknownType;
146 
147     /** The builtin type of all arrays. */
148     public final ClassSymbol arrayClass;
149     public final MethodSymbol arrayCloneMethod;
150 
151     /** VGJ: The (singleton) type of all bound types. */
152     public final ClassSymbol boundClass;
153 
154     /** The builtin type of all methods. */
155     public final ClassSymbol methodClass;
156 
157     /** A symbol for the java.base module.
158      */
159     public final ModuleSymbol java_base;
160 
161     /** Predefined types.
162      */
163     public final Type objectType;
<span class="line-added">164     public final Type objectMethodsType;</span>
165     public final Type objectsType;
166     public final Type classType;
167     public final Type classLoaderType;
168     public final Type stringType;
169     public final Type stringBufferType;
170     public final Type stringBuilderType;
171     public final Type cloneableType;
172     public final Type serializableType;
173     public final Type serializedLambdaType;
174     public final Type varHandleType;
175     public final Type methodHandleType;
176     public final Type methodHandleLookupType;
177     public final Type methodTypeType;
178     public final Type nativeHeaderType;
179     public final Type throwableType;
180     public final Type errorType;
181     public final Type interruptedExceptionType;
182     public final Type illegalArgumentExceptionType;
183     public final Type exceptionType;
184     public final Type runtimeExceptionType;
</pre>
<hr />
<pre>
198     public final Type iterableType;
199     public final Type iteratorType;
200     public final Type annotationTargetType;
201     public final Type overrideType;
202     public final Type retentionType;
203     public final Type deprecatedType;
204     public final Type suppressWarningsType;
205     public final Type supplierType;
206     public final Type inheritedType;
207     public final Type profileType;
208     public final Type proprietaryType;
209     public final Type systemType;
210     public final Type autoCloseableType;
211     public final Type trustMeType;
212     public final Type lambdaMetafactory;
213     public final Type stringConcatFactory;
214     public final Type repeatableType;
215     public final Type documentedType;
216     public final Type elementTypeType;
217     public final Type functionalInterfaceType;
<span class="line-added">218     public final Type previewFeatureType;</span>
<span class="line-added">219     public final Type typeDescriptorType;</span>
<span class="line-added">220     public final Type recordType;</span>
221 
222     /** The symbol representing the length field of an array.
223      */
224     public final VarSymbol lengthVar;
225 
226     /** The symbol representing the final finalize method on enums */
227     public final MethodSymbol enumFinalFinalize;
228 
229     /** The symbol representing the close method on TWR AutoCloseable type */
230     public final MethodSymbol autoCloseableClose;
231 
232     /** The predefined type that belongs to a tag.
233      */
234     public final Type[] typeOfTag = new Type[TypeTag.getTypeTagCount()];
235 
236     /** The name of the class that belongs to a basic type tag.
237      */
238     public final Name[] boxedName = new Name[TypeTag.getTypeTagCount()];
239 
240     /** A hashtable containing the encountered top-level and member classes,
</pre>
<hr />
<pre>
370         type.typarams_field = List.nil();
371         type.allparams_field = List.nil();
372         type.supertype_field = annotationType;
373         type.interfaces_field = List.nil();
374         return type;
375     }
376 
377     /** Constructor; enters all predefined identifiers and operators
378      *  into symbol table.
379      */
380     protected Symtab(Context context) throws CompletionFailure {
381         context.put(symtabKey, this);
382 
383         names = Names.instance(context);
384 
385         // Create the unknown type
386         unknownType = new UnknownType();
387 
388         messages = JavacMessages.instance(context);
389 
<span class="line-modified">390         MissingInfoHandler missingInfoHandler = MissingInfoHandler.instance(context);</span>
<span class="line-added">391 </span>
<span class="line-added">392         rootPackage = new RootPackageSymbol(names.empty, null, missingInfoHandler);</span>
393 
394         // create the basic builtin symbols
395         unnamedModule = new ModuleSymbol(names.empty, null) {
396                 {
397                     directives = List.nil();
398                     exports = List.nil();
399                     provides = List.nil();
400                     uses = List.nil();
401                     ModuleSymbol java_base = enterModule(names.java_base);
402                     com.sun.tools.javac.code.Directive.RequiresDirective d =
403                             new com.sun.tools.javac.code.Directive.RequiresDirective(java_base,
404                                     EnumSet.of(com.sun.tools.javac.code.Directive.RequiresFlag.MANDATED));
405                     requires = List.of(d);
406                 }
407                 @Override
408                 public String toString() {
409                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.module&quot;);
410                 }
411             };
412         addRootPackageFor(unnamedModule);
</pre>
<hr />
<pre>
495         scope.enter(errType.tsym);
496 
497         // Enter symbol for the errSymbol
498         scope.enter(errSymbol);
499 
500         Source source = Source.instance(context);
501         if (Feature.MODULES.allowedInSource(source)) {
502             java_base = enterModule(names.java_base);
503             //avoid completing java.base during the Symtab initialization
504             java_base.completer = Completer.NULL_COMPLETER;
505             java_base.visiblePackages = Collections.emptyMap();
506         } else {
507             java_base = noModule;
508         }
509 
510         // Get the initial completer for ModuleSymbols from Modules
511         moduleCompleter = Modules.instance(context).getCompleter();
512 
513         // Enter predefined classes. All are assumed to be in the java.base module.
514         objectType = enterClass(&quot;java.lang.Object&quot;);
<span class="line-added">515         objectMethodsType = enterClass(&quot;java.lang.runtime.ObjectMethods&quot;);</span>
516         objectsType = enterClass(&quot;java.util.Objects&quot;);
517         classType = enterClass(&quot;java.lang.Class&quot;);
518         stringType = enterClass(&quot;java.lang.String&quot;);
519         stringBufferType = enterClass(&quot;java.lang.StringBuffer&quot;);
520         stringBuilderType = enterClass(&quot;java.lang.StringBuilder&quot;);
521         cloneableType = enterClass(&quot;java.lang.Cloneable&quot;);
522         throwableType = enterClass(&quot;java.lang.Throwable&quot;);
523         serializableType = enterClass(&quot;java.io.Serializable&quot;);
524         serializedLambdaType = enterClass(&quot;java.lang.invoke.SerializedLambda&quot;);
525         varHandleType = enterClass(&quot;java.lang.invoke.VarHandle&quot;);
526         methodHandleType = enterClass(&quot;java.lang.invoke.MethodHandle&quot;);
527         methodHandleLookupType = enterClass(&quot;java.lang.invoke.MethodHandles$Lookup&quot;);
528         methodTypeType = enterClass(&quot;java.lang.invoke.MethodType&quot;);
529         errorType = enterClass(&quot;java.lang.Error&quot;);
530         illegalArgumentExceptionType = enterClass(&quot;java.lang.IllegalArgumentException&quot;);
531         interruptedExceptionType = enterClass(&quot;java.lang.InterruptedException&quot;);
532         exceptionType = enterClass(&quot;java.lang.Exception&quot;);
533         runtimeExceptionType = enterClass(&quot;java.lang.RuntimeException&quot;);
534         classNotFoundExceptionType = enterClass(&quot;java.lang.ClassNotFoundException&quot;);
535         noClassDefFoundErrorType = enterClass(&quot;java.lang.NoClassDefFoundError&quot;);
</pre>
<hr />
<pre>
558         retentionType = enterClass(&quot;java.lang.annotation.Retention&quot;);
559         deprecatedType = enterClass(&quot;java.lang.Deprecated&quot;);
560         suppressWarningsType = enterClass(&quot;java.lang.SuppressWarnings&quot;);
561         supplierType = enterClass(&quot;java.util.function.Supplier&quot;);
562         inheritedType = enterClass(&quot;java.lang.annotation.Inherited&quot;);
563         repeatableType = enterClass(&quot;java.lang.annotation.Repeatable&quot;);
564         documentedType = enterClass(&quot;java.lang.annotation.Documented&quot;);
565         elementTypeType = enterClass(&quot;java.lang.annotation.ElementType&quot;);
566         systemType = enterClass(&quot;java.lang.System&quot;);
567         autoCloseableType = enterClass(&quot;java.lang.AutoCloseable&quot;);
568         autoCloseableClose = new MethodSymbol(PUBLIC,
569                              names.close,
570                              new MethodType(List.nil(), voidType,
571                                             List.of(exceptionType), methodClass),
572                              autoCloseableType.tsym);
573         trustMeType = enterClass(&quot;java.lang.SafeVarargs&quot;);
574         nativeHeaderType = enterClass(&quot;java.lang.annotation.Native&quot;);
575         lambdaMetafactory = enterClass(&quot;java.lang.invoke.LambdaMetafactory&quot;);
576         stringConcatFactory = enterClass(&quot;java.lang.invoke.StringConcatFactory&quot;);
577         functionalInterfaceType = enterClass(&quot;java.lang.FunctionalInterface&quot;);
<span class="line-added">578         previewFeatureType = enterClass(&quot;jdk.internal.PreviewFeature&quot;);</span>
<span class="line-added">579         typeDescriptorType = enterClass(&quot;java.lang.invoke.TypeDescriptor&quot;);</span>
<span class="line-added">580         recordType = enterClass(&quot;java.lang.Record&quot;);</span>
581 
582         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
583         synthesizeEmptyInterfaceIfMissing(cloneableType);
584         synthesizeEmptyInterfaceIfMissing(serializableType);
585         synthesizeEmptyInterfaceIfMissing(lambdaMetafactory);
586         synthesizeEmptyInterfaceIfMissing(serializedLambdaType);
587         synthesizeEmptyInterfaceIfMissing(stringConcatFactory);
588         synthesizeBoxTypeIfMissing(doubleType);
589         synthesizeBoxTypeIfMissing(floatType);
590         synthesizeBoxTypeIfMissing(voidType);
591 
592         // Enter a synthetic class that is used to mark internal
593         // proprietary classes in ct.sym.  This class does not have a
594         // class file.
595         proprietaryType = enterSyntheticAnnotation(&quot;sun.Proprietary+Annotation&quot;);
596 
597         // Enter a synthetic class that is used to provide profile info for
598         // classes in ct.sym.  This class does not have a class file.
599         profileType = enterSyntheticAnnotation(&quot;jdk.Profile+Annotation&quot;);
600         MethodSymbol m = new MethodSymbol(PUBLIC | ABSTRACT, names.value, intType, profileType.tsym);
</pre>
<hr />
<pre>
774         }
775         return p;
776     }
777 
778     private void doEnterPackage(ModuleSymbol msym, PackageSymbol pack) {
779         packages.computeIfAbsent(pack.fullname, n -&gt; new HashMap&lt;&gt;()).put(msym, pack);
780         msym.enclosedPackages = msym.enclosedPackages.prepend(pack);
781     }
782 
783     private void addRootPackageFor(ModuleSymbol module) {
784         doEnterPackage(module, rootPackage);
785         PackageSymbol unnamedPackage = new PackageSymbol(names.empty, rootPackage) {
786                 @Override
787                 public String toString() {
788                     return messages.getLocalizedString(&quot;compiler.misc.unnamed.package&quot;);
789                 }
790             };
791         unnamedPackage.modle = module;
792         //we cannot use a method reference below, as initialCompleter might be null now
793         unnamedPackage.completer = s -&gt; initialCompleter.complete(s);
<span class="line-added">794         unnamedPackage.flags_field |= EXISTS;</span>
795         module.unnamedPackage = unnamedPackage;
796     }
797 
798     public PackageSymbol getPackage(ModuleSymbol module, Name fullname) {
799         return packages.getOrDefault(fullname, Collections.emptyMap()).get(module);
800     }
801 
802     public ModuleSymbol enterModule(Name name) {
803         ModuleSymbol msym = modules.get(name);
804         if (msym == null) {
805             msym = ModuleSymbol.create(name, names.module_info);
806             addRootPackageFor(msym);
807             msym.completer = s -&gt; moduleCompleter.complete(s); //bootstrap issues
808             modules.put(name, msym);
809         }
810         return msym;
811     }
812 
813     public ModuleSymbol getModule(Name name) {
814         return modules.get(name);
</pre>
</td>
</tr>
</table>
<center><a href="SymbolMetadata.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
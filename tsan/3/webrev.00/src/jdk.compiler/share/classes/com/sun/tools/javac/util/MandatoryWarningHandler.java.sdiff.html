<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/util/MandatoryWarningHandler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Log.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Name.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/util/MandatoryWarningHandler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.util;
 27 
 28 import java.util.HashSet;

 29 import java.util.Set;
 30 import javax.tools.JavaFileObject;
 31 
 32 import com.sun.tools.javac.code.Lint.LintCategory;
 33 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 34 import com.sun.tools.javac.util.JCDiagnostic.Note;
 35 import com.sun.tools.javac.util.JCDiagnostic.Warning;
 36 
 37 
 38 /**
 39  * A handler to process mandatory warnings, setting up a deferred diagnostic
 40  * to be printed at the end of the compilation if some warnings get suppressed
 41  * because too many warnings have already been generated.
 42  *
 43  * Note that the SuppressWarnings annotation can be used to suppress warnings
 44  * about conditions that would otherwise merit a warning. Such processing
 45  * is done when the condition is detected, and in those cases, no call is
 46  * made on any API to generate a warning at all. In consequence, this handler only
 47  * Returns to handle those warnings that JLS says must be generated.
 48  *
</pre>
<hr />
<pre>
130             if (sourcesWithReportedWarnings == null)
131                 sourcesWithReportedWarnings = new HashSet&lt;&gt;();
132 
133             if (log.nwarnings &lt; log.MaxWarnings) {
134                 // generate message and remember the source file
135                 logMandatoryWarning(pos, warnKey);
136                 sourcesWithReportedWarnings.add(currentSource);
137             } else if (deferredDiagnosticKind == null) {
138                 // set up deferred message
139                 if (sourcesWithReportedWarnings.contains(currentSource)) {
140                     // more errors in a file that already has reported warnings
141                     deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;
142                 } else {
143                     // warnings in a new source file
144                     deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;
145                 }
146                 deferredDiagnosticSource = currentSource;
147                 deferredDiagnosticArg = currentSource;
148             } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE
149                         || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)
<span class="line-modified">150                        &amp;&amp; !equal(deferredDiagnosticSource, currentSource)) {</span>
151                 // additional errors in more than one source file
152                 deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;
153                 deferredDiagnosticArg = null;
154             }
155         } else {
156             if (deferredDiagnosticKind == null) {
157                 // warnings in a single source
158                 deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;
159                 deferredDiagnosticSource = currentSource;
160                 deferredDiagnosticArg = currentSource;
161             }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &amp;&amp;
<span class="line-modified">162                         !equal(deferredDiagnosticSource, currentSource)) {</span>
163                 // warnings in multiple source files
164                 deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;
165                 deferredDiagnosticArg = null;
166             }
167         }
168     }
169 
170     /**
171      * Report any diagnostic that might have been deferred by previous calls of report().
172      */
173     public void reportDeferredDiagnostic() {
174         if (deferredDiagnosticKind != null) {
175             if (deferredDiagnosticArg == null)
176                 logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));
177             else
178                 logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);
179 
180             if (!verbose)
181                 logMandatoryNote(deferredDiagnosticSource, prefix + &quot;.recompile&quot;);
182         }
183     }
184 
<span class="line-removed">185     /**</span>
<span class="line-removed">186      * Check two objects, each possibly null, are either both null or are equal.</span>
<span class="line-removed">187      */</span>
<span class="line-removed">188     private static boolean equal(Object o1, Object o2) {</span>
<span class="line-removed">189         return ((o1 == null || o2 == null) ? (o1 == o2) : o1.equals(o2));</span>
<span class="line-removed">190     }</span>
<span class="line-removed">191 </span>
192     /**
193      * The log to which to report warnings.
194      */
<span class="line-modified">195     private Log log;</span>
196 
197     /**
198      * Whether or not to report individual warnings, or simply to report a
199      * single aggregate warning at the end of the compilation.
200      */
<span class="line-modified">201     private boolean verbose;</span>
202 
203     /**
204      * The common prefix for all I18N message keys generated by this handler.
205      */
<span class="line-modified">206     private String prefix;</span>
207 
208     /**
209      * A set containing the names of the source files for which specific
210      * warnings have been generated -- i.e. in verbose mode.  If a source name
211      * appears in this list, then deferred diagnostics will be phrased to
212      * include &quot;additionally&quot;...
213      */
214     private Set&lt;JavaFileObject&gt; sourcesWithReportedWarnings;
215 
216     /**
217      * A variable indicating the latest best guess at what the final
218      * deferred diagnostic will be. Initially as specific and helpful
219      * as possible, as more warnings are reported, the scope of the
220      * diagnostic will be broadened.
221      */
222     private DeferredDiagnosticKind deferredDiagnosticKind;
223 
224     /**
225      * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable
226      * gives the value of log.currentSource() for the file in question.
</pre>
<hr />
<pre>
251      * are not being enforced, treat this as an ordinary warning.
252      */
253     private void logMandatoryWarning(DiagnosticPosition pos, Warning warnKey) {
254         // Note: the following log methods are safe if lintCategory is null.
255         if (enforceMandatory)
256             log.mandatoryWarning(lintCategory, pos, warnKey);
257         else
258             log.warning(lintCategory, pos, warnKey);
259     }
260 
261     /**
262      * Reports a mandatory note to the log.  If mandatory notes are
263      * not being enforced, treat this as an ordinary note.
264      */
265     private void logMandatoryNote(JavaFileObject file, String msg, Object... args) {
266         if (enforceMandatory)
267             log.mandatoryNote(file, new Note(&quot;compiler&quot;, msg, args));
268         else
269             log.note(file, new Note(&quot;compiler&quot;, msg, args));
270     }







271 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.util;
 27 
 28 import java.util.HashSet;
<span class="line-added"> 29 import java.util.Objects;</span>
 30 import java.util.Set;
 31 import javax.tools.JavaFileObject;
 32 
 33 import com.sun.tools.javac.code.Lint.LintCategory;
 34 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 35 import com.sun.tools.javac.util.JCDiagnostic.Note;
 36 import com.sun.tools.javac.util.JCDiagnostic.Warning;
 37 
 38 
 39 /**
 40  * A handler to process mandatory warnings, setting up a deferred diagnostic
 41  * to be printed at the end of the compilation if some warnings get suppressed
 42  * because too many warnings have already been generated.
 43  *
 44  * Note that the SuppressWarnings annotation can be used to suppress warnings
 45  * about conditions that would otherwise merit a warning. Such processing
 46  * is done when the condition is detected, and in those cases, no call is
 47  * made on any API to generate a warning at all. In consequence, this handler only
 48  * Returns to handle those warnings that JLS says must be generated.
 49  *
</pre>
<hr />
<pre>
131             if (sourcesWithReportedWarnings == null)
132                 sourcesWithReportedWarnings = new HashSet&lt;&gt;();
133 
134             if (log.nwarnings &lt; log.MaxWarnings) {
135                 // generate message and remember the source file
136                 logMandatoryWarning(pos, warnKey);
137                 sourcesWithReportedWarnings.add(currentSource);
138             } else if (deferredDiagnosticKind == null) {
139                 // set up deferred message
140                 if (sourcesWithReportedWarnings.contains(currentSource)) {
141                     // more errors in a file that already has reported warnings
142                     deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILE;
143                 } else {
144                     // warnings in a new source file
145                     deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;
146                 }
147                 deferredDiagnosticSource = currentSource;
148                 deferredDiagnosticArg = currentSource;
149             } else if ((deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE
150                         || deferredDiagnosticKind == DeferredDiagnosticKind.ADDITIONAL_IN_FILE)
<span class="line-modified">151                        &amp;&amp; !Objects.equals(deferredDiagnosticSource, currentSource)) {</span>
152                 // additional errors in more than one source file
153                 deferredDiagnosticKind = DeferredDiagnosticKind.ADDITIONAL_IN_FILES;
154                 deferredDiagnosticArg = null;
155             }
156         } else {
157             if (deferredDiagnosticKind == null) {
158                 // warnings in a single source
159                 deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILE;
160                 deferredDiagnosticSource = currentSource;
161                 deferredDiagnosticArg = currentSource;
162             }  else if (deferredDiagnosticKind == DeferredDiagnosticKind.IN_FILE &amp;&amp;
<span class="line-modified">163                         !Objects.equals(deferredDiagnosticSource, currentSource)) {</span>
164                 // warnings in multiple source files
165                 deferredDiagnosticKind = DeferredDiagnosticKind.IN_FILES;
166                 deferredDiagnosticArg = null;
167             }
168         }
169     }
170 
171     /**
172      * Report any diagnostic that might have been deferred by previous calls of report().
173      */
174     public void reportDeferredDiagnostic() {
175         if (deferredDiagnosticKind != null) {
176             if (deferredDiagnosticArg == null)
177                 logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix));
178             else
179                 logMandatoryNote(deferredDiagnosticSource, deferredDiagnosticKind.getKey(prefix), deferredDiagnosticArg);
180 
181             if (!verbose)
182                 logMandatoryNote(deferredDiagnosticSource, prefix + &quot;.recompile&quot;);
183         }
184     }
185 







186     /**
187      * The log to which to report warnings.
188      */
<span class="line-modified">189     private final Log log;</span>
190 
191     /**
192      * Whether or not to report individual warnings, or simply to report a
193      * single aggregate warning at the end of the compilation.
194      */
<span class="line-modified">195     private final boolean verbose;</span>
196 
197     /**
198      * The common prefix for all I18N message keys generated by this handler.
199      */
<span class="line-modified">200     private final String prefix;</span>
201 
202     /**
203      * A set containing the names of the source files for which specific
204      * warnings have been generated -- i.e. in verbose mode.  If a source name
205      * appears in this list, then deferred diagnostics will be phrased to
206      * include &quot;additionally&quot;...
207      */
208     private Set&lt;JavaFileObject&gt; sourcesWithReportedWarnings;
209 
210     /**
211      * A variable indicating the latest best guess at what the final
212      * deferred diagnostic will be. Initially as specific and helpful
213      * as possible, as more warnings are reported, the scope of the
214      * diagnostic will be broadened.
215      */
216     private DeferredDiagnosticKind deferredDiagnosticKind;
217 
218     /**
219      * If deferredDiagnosticKind is IN_FILE or ADDITIONAL_IN_FILE, this variable
220      * gives the value of log.currentSource() for the file in question.
</pre>
<hr />
<pre>
245      * are not being enforced, treat this as an ordinary warning.
246      */
247     private void logMandatoryWarning(DiagnosticPosition pos, Warning warnKey) {
248         // Note: the following log methods are safe if lintCategory is null.
249         if (enforceMandatory)
250             log.mandatoryWarning(lintCategory, pos, warnKey);
251         else
252             log.warning(lintCategory, pos, warnKey);
253     }
254 
255     /**
256      * Reports a mandatory note to the log.  If mandatory notes are
257      * not being enforced, treat this as an ordinary note.
258      */
259     private void logMandatoryNote(JavaFileObject file, String msg, Object... args) {
260         if (enforceMandatory)
261             log.mandatoryNote(file, new Note(&quot;compiler&quot;, msg, args));
262         else
263             log.note(file, new Note(&quot;compiler&quot;, msg, args));
264     }
<span class="line-added">265 </span>
<span class="line-added">266     public void clear() {</span>
<span class="line-added">267         sourcesWithReportedWarnings = null;</span>
<span class="line-added">268         deferredDiagnosticKind = null;</span>
<span class="line-added">269         deferredDiagnosticSource = null;</span>
<span class="line-added">270         deferredDiagnosticArg = null;</span>
<span class="line-added">271     }</span>
272 }
</pre>
</td>
</tr>
</table>
<center><a href="Log.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Name.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
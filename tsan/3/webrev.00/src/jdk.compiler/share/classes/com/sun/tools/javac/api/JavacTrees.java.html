<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.api;
  27 
  28 import java.io.FileNotFoundException;
  29 import java.io.IOException;
  30 import java.text.BreakIterator;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.Map;
  34 import java.util.Map.Entry;
  35 import java.util.Set;
  36 import java.util.WeakHashMap;
  37 
  38 import javax.annotation.processing.ProcessingEnvironment;
  39 import javax.lang.model.element.AnnotationMirror;
  40 import javax.lang.model.element.AnnotationValue;
  41 import javax.lang.model.element.Element;
  42 import javax.lang.model.element.ElementKind;
  43 import javax.lang.model.element.ExecutableElement;
  44 import javax.lang.model.element.Modifier;
  45 import javax.lang.model.element.NestingKind;
  46 import javax.lang.model.element.PackageElement;
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.type.DeclaredType;
  49 import javax.lang.model.type.TypeKind;
  50 import javax.lang.model.type.TypeMirror;
  51 import javax.tools.Diagnostic;
  52 import javax.tools.FileObject;
  53 import javax.tools.ForwardingFileObject;
  54 import javax.tools.JavaCompiler;
  55 import javax.tools.JavaFileManager;
  56 import javax.tools.JavaFileObject;
  57 import javax.tools.JavaFileObject.Kind;
  58 import javax.tools.StandardLocation;
  59 
  60 import com.sun.source.doctree.DocCommentTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.tree.CatchTree;
  63 import com.sun.source.tree.ClassTree;
  64 import com.sun.source.tree.CompilationUnitTree;
  65 import com.sun.source.tree.Scope;
  66 import com.sun.source.tree.Tree;
  67 import com.sun.source.util.DocSourcePositions;
  68 import com.sun.source.util.DocTreePath;
  69 import com.sun.source.util.DocTreeScanner;
  70 import com.sun.source.util.DocTrees;
  71 import com.sun.source.util.JavacTask;
  72 import com.sun.source.util.TreePath;
  73 import com.sun.tools.javac.code.Flags;
  74 import com.sun.tools.javac.code.Scope.NamedImportScope;
  75 import com.sun.tools.javac.code.Scope.StarImportScope;
  76 import com.sun.tools.javac.code.Scope.WriteableScope;
  77 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  78 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  79 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  80 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  81 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  82 import com.sun.tools.javac.code.Symbol.VarSymbol;
  83 import com.sun.tools.javac.code.Symtab;
  84 import com.sun.tools.javac.code.Type;
  85 import com.sun.tools.javac.code.Type.ArrayType;
  86 import com.sun.tools.javac.code.Type.ClassType;
  87 import com.sun.tools.javac.code.Type.ErrorType;
  88 import com.sun.tools.javac.code.Type.UnionClassType;
  89 import com.sun.tools.javac.code.Types;
  90 import com.sun.tools.javac.code.Types.TypeRelation;
  91 import com.sun.tools.javac.comp.Attr;
  92 import com.sun.tools.javac.comp.AttrContext;
  93 import com.sun.tools.javac.comp.Check;
  94 import com.sun.tools.javac.comp.Enter;
  95 import com.sun.tools.javac.comp.Env;
  96 import com.sun.tools.javac.comp.MemberEnter;
  97 import com.sun.tools.javac.comp.Modules;
  98 import com.sun.tools.javac.comp.Resolve;
  99 import com.sun.tools.javac.code.Symbol;
 100 import com.sun.tools.javac.file.BaseFileManager;
 101 import com.sun.tools.javac.model.JavacElements;
 102 import com.sun.tools.javac.parser.DocCommentParser;
 103 import com.sun.tools.javac.parser.ParserFactory;
 104 import com.sun.tools.javac.parser.Tokens.Comment;
 105 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
 106 import com.sun.tools.javac.processing.JavacProcessingEnvironment;
 107 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 108 import com.sun.tools.javac.resources.CompilerProperties.Notes;
 109 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 110 import com.sun.tools.javac.tree.DCTree;
 111 import com.sun.tools.javac.tree.DCTree.DCBlockTag;
 112 import com.sun.tools.javac.tree.DCTree.DCComment;
 113 import com.sun.tools.javac.tree.DCTree.DCDocComment;
 114 import com.sun.tools.javac.tree.DCTree.DCEndPosTree;
 115 import com.sun.tools.javac.tree.DCTree.DCEntity;
 116 import com.sun.tools.javac.tree.DCTree.DCErroneous;
 117 import com.sun.tools.javac.tree.DCTree.DCIdentifier;
 118 import com.sun.tools.javac.tree.DCTree.DCParam;
 119 import com.sun.tools.javac.tree.DCTree.DCReference;
 120 import com.sun.tools.javac.tree.DCTree.DCText;
 121 import com.sun.tools.javac.tree.DocCommentTable;
 122 import com.sun.tools.javac.tree.DocTreeMaker;
 123 import com.sun.tools.javac.tree.EndPosTable;
 124 import com.sun.tools.javac.tree.JCTree;
 125 import com.sun.tools.javac.tree.JCTree.JCBlock;
 126 import com.sun.tools.javac.tree.JCTree.JCCatch;
 127 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 128 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 129 import com.sun.tools.javac.tree.JCTree.JCExpression;
 130 import com.sun.tools.javac.tree.JCTree.JCIdent;
 131 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 132 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 133 import com.sun.tools.javac.tree.TreeCopier;
 134 import com.sun.tools.javac.tree.TreeInfo;
 135 import com.sun.tools.javac.tree.TreeMaker;
 136 import com.sun.tools.javac.tree.TreeScanner;
 137 import com.sun.tools.javac.util.Abort;
 138 import com.sun.tools.javac.util.Assert;
 139 import com.sun.tools.javac.util.Context;
 140 import com.sun.tools.javac.util.DefinedBy;
 141 import com.sun.tools.javac.util.DefinedBy.Api;
 142 import com.sun.tools.javac.util.DiagnosticSource;
 143 import com.sun.tools.javac.util.JCDiagnostic;
 144 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 145 import com.sun.tools.javac.util.List;
 146 import com.sun.tools.javac.util.ListBuffer;
 147 import com.sun.tools.javac.util.Log;
 148 import com.sun.tools.javac.util.Name;
 149 import com.sun.tools.javac.util.Names;
 150 import com.sun.tools.javac.util.Pair;
 151 import com.sun.tools.javac.util.Position;
 152 
 153 import static com.sun.tools.javac.code.Kinds.Kind.*;
 154 import static com.sun.tools.javac.code.TypeTag.*;
 155 
 156 /**
 157  * Provides an implementation of Trees.
 158  *
 159  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 160  * If you write code that depends on this, you do so at your own
 161  * risk.  This code and its internal interfaces are subject to change
 162  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 163  *
 164  * @author Peter von der Ah&amp;eacute;
 165  */
 166 public class JavacTrees extends DocTrees {
 167 
 168     // in a world of a single context per compilation, these would all be final
 169     private Modules modules;
 170     private Resolve resolve;
 171     private Enter enter;
 172     private Log log;
 173     private MemberEnter memberEnter;
 174     private Attr attr;
 175     private Check chk;
 176     private TreeMaker treeMaker;
 177     private JavacElements elements;
 178     private JavacTaskImpl javacTaskImpl;
 179     private Names names;
 180     private Types types;
 181     private DocTreeMaker docTreeMaker;
 182     private BreakIterator breakIterator;
 183     private JavaFileManager fileManager;
 184     private ParserFactory parser;
 185     private Symtab syms;
 186 
 187     private final Map&lt;Type, Type&gt; extraType2OriginalMap = new WeakHashMap&lt;&gt;();
 188 
 189     // called reflectively from Trees.instance(CompilationTask task)
 190     public static JavacTrees instance(JavaCompiler.CompilationTask task) {
 191         if (!(task instanceof BasicJavacTask))
 192             throw new IllegalArgumentException();
 193         return instance(((BasicJavacTask)task).getContext());
 194     }
 195 
 196     // called reflectively from Trees.instance(ProcessingEnvironment env)
 197     public static JavacTrees instance(ProcessingEnvironment env) {
 198         if (!(env instanceof JavacProcessingEnvironment))
 199             throw new IllegalArgumentException();
 200         return instance(((JavacProcessingEnvironment)env).getContext());
 201     }
 202 
 203     public static JavacTrees instance(Context context) {
 204         JavacTrees instance = context.get(JavacTrees.class);
 205         if (instance == null)
 206             instance = new JavacTrees(context);
 207         return instance;
 208     }
 209 
 210     protected JavacTrees(Context context) {
 211         this.breakIterator = null;
 212         context.put(JavacTrees.class, this);
 213         init(context);
 214     }
 215 
 216     public void updateContext(Context context) {
 217         init(context);
 218     }
 219 
 220     private void init(Context context) {
 221         modules = Modules.instance(context);
 222         attr = Attr.instance(context);
 223         chk = Check.instance(context);
 224         enter = Enter.instance(context);
 225         elements = JavacElements.instance(context);
 226         log = Log.instance(context);
 227         resolve = Resolve.instance(context);
 228         treeMaker = TreeMaker.instance(context);
 229         memberEnter = MemberEnter.instance(context);
 230         names = Names.instance(context);
 231         types = Types.instance(context);
 232         docTreeMaker = DocTreeMaker.instance(context);
 233         parser = ParserFactory.instance(context);
 234         syms = Symtab.instance(context);
 235         fileManager = context.get(JavaFileManager.class);
 236         JavacTask t = context.get(JavacTask.class);
 237         if (t instanceof JavacTaskImpl)
 238             javacTaskImpl = (JavacTaskImpl) t;
 239     }
 240 
 241     @Override @DefinedBy(Api.COMPILER_TREE)
 242     public BreakIterator getBreakIterator() {
 243         return breakIterator;
 244     }
 245 
 246     @Override @DefinedBy(Api.COMPILER_TREE)
 247     public DocSourcePositions getSourcePositions() {
 248         return new DocSourcePositions() {
 249                 @Override @DefinedBy(Api.COMPILER_TREE)
 250                 public long getStartPosition(CompilationUnitTree file, Tree tree) {
 251                     return TreeInfo.getStartPos((JCTree) tree);
 252                 }
 253 
 254                 @Override @DefinedBy(Api.COMPILER_TREE)
 255                 public long getEndPosition(CompilationUnitTree file, Tree tree) {
 256                     EndPosTable endPosTable = ((JCCompilationUnit) file).endPositions;
 257                     return TreeInfo.getEndPos((JCTree) tree, endPosTable);
 258                 }
 259 
 260                 @Override @DefinedBy(Api.COMPILER_TREE)
 261                 public long getStartPosition(CompilationUnitTree file, DocCommentTree comment, DocTree tree) {
 262                     return ((DCTree) tree).getSourcePosition((DCDocComment) comment);
 263                 }
 264                 @Override  @DefinedBy(Api.COMPILER_TREE) @SuppressWarnings(&quot;fallthrough&quot;)
 265                 public long getEndPosition(CompilationUnitTree file, DocCommentTree comment, DocTree tree) {
 266                     DCDocComment dcComment = (DCDocComment) comment;
 267                     if (tree instanceof DCEndPosTree) {
 268                         int endPos = ((DCEndPosTree) tree).getEndPos(dcComment);
 269 
 270                         if (endPos != Position.NOPOS) {
 271                             return endPos;
 272                         }
 273                     }
 274                     int correction = 0;
 275                     switch (tree.getKind()) {
 276                         case TEXT:
 277                             DCText text = (DCText) tree;
 278 
 279                             return dcComment.comment.getSourcePos(text.pos + text.text.length());
 280                         case ERRONEOUS:
 281                             DCErroneous err = (DCErroneous) tree;
 282 
 283                             return dcComment.comment.getSourcePos(err.pos + err.body.length());
 284                         case IDENTIFIER:
 285                             DCIdentifier ident = (DCIdentifier) tree;
 286 
 287                             return dcComment.comment.getSourcePos(ident.pos + (ident.name != names.error ? ident.name.length() : 0));
 288                         case PARAM:
 289                             DCParam param = (DCParam) tree;
 290 
 291                             if (param.isTypeParameter &amp;&amp; param.getDescription().isEmpty()) {
 292                                 correction = 1;
 293                             }
 294                         case AUTHOR: case DEPRECATED: case RETURN: case SEE:
 295                         case SERIAL: case SERIAL_DATA: case SERIAL_FIELD: case SINCE:
 296                         case THROWS: case UNKNOWN_BLOCK_TAG: case VERSION: {
 297                             DocTree last = getLastChild(tree);
 298 
 299                             if (last != null) {
 300                                 return getEndPosition(file, comment, last) + correction;
 301                             }
 302 
 303                             DCBlockTag block = (DCBlockTag) tree;
 304 
 305                             return dcComment.comment.getSourcePos(block.pos + block.getTagName().length() + 1);
 306                         }
 307                         case ENTITY: {
 308                             DCEntity endEl = (DCEntity) tree;
 309                             return dcComment.comment.getSourcePos(endEl.pos + (endEl.name != names.error ? endEl.name.length() : 0) + 2);
 310                         }
 311                         case COMMENT: {
 312                             DCComment endEl = (DCComment) tree;
 313                             return dcComment.comment.getSourcePos(endEl.pos + endEl.body.length());
 314                         }
 315                         default:
 316                             DocTree last = getLastChild(tree);
 317 
 318                             if (last != null) {
 319                                 return getEndPosition(file, comment, last);
 320                             }
 321                             break;
 322                     }
 323 
 324                     return Position.NOPOS;
 325                 }
 326             };
 327     }
 328 
 329     @Override @DefinedBy(Api.COMPILER_TREE)
 330     public DocTreeMaker getDocTreeFactory() {
 331         return docTreeMaker;
 332     }
 333 
 334     private DocTree getLastChild(DocTree tree) {
 335         final DocTree[] last = new DocTree[] {null};
 336 
 337         tree.accept(new DocTreeScanner&lt;Void, Void&gt;() {
 338             @Override @DefinedBy(Api.COMPILER_TREE)
 339             public Void scan(DocTree node, Void p) {
 340                 if (node != null) last[0] = node;
 341                 return null;
 342             }
 343         }, null);
 344 
 345         return last[0];
 346     }
 347 
 348     @Override @DefinedBy(Api.COMPILER_TREE)
 349     public JCClassDecl getTree(TypeElement element) {
 350         return (JCClassDecl) getTree((Element) element);
 351     }
 352 
 353     @Override @DefinedBy(Api.COMPILER_TREE)
 354     public JCMethodDecl getTree(ExecutableElement method) {
 355         return (JCMethodDecl) getTree((Element) method);
 356     }
 357 
 358     @Override @DefinedBy(Api.COMPILER_TREE)
 359     public JCTree getTree(Element element) {
 360         return getTree(element, null);
 361     }
 362 
 363     @Override @DefinedBy(Api.COMPILER_TREE)
 364     public JCTree getTree(Element e, AnnotationMirror a) {
 365         return getTree(e, a, null);
 366     }
 367 
 368     @Override @DefinedBy(Api.COMPILER_TREE)
 369     public JCTree getTree(Element e, AnnotationMirror a, AnnotationValue v) {
 370         Pair&lt;JCTree, JCCompilationUnit&gt; treeTopLevel = elements.getTreeAndTopLevel(e, a, v);
 371         if (treeTopLevel == null)
 372             return null;
 373         return treeTopLevel.fst;
 374     }
 375 
 376     @Override @DefinedBy(Api.COMPILER_TREE)
 377     public TreePath getPath(CompilationUnitTree unit, Tree node) {
 378         return TreePath.getPath(unit, node);
 379     }
 380 
 381     @Override @DefinedBy(Api.COMPILER_TREE)
 382     public TreePath getPath(Element e) {
 383         return getPath(e, null, null);
 384     }
 385 
 386     @Override @DefinedBy(Api.COMPILER_TREE)
 387     public TreePath getPath(Element e, AnnotationMirror a) {
 388         return getPath(e, a, null);
 389     }
 390 
 391     @Override @DefinedBy(Api.COMPILER_TREE)
 392     public TreePath getPath(Element e, AnnotationMirror a, AnnotationValue v) {
 393         final Pair&lt;JCTree, JCCompilationUnit&gt; treeTopLevel = elements.getTreeAndTopLevel(e, a, v);
 394         if (treeTopLevel == null)
 395             return null;
 396         return TreePath.getPath(treeTopLevel.snd, treeTopLevel.fst);
 397     }
 398 
 399     @Override @DefinedBy(Api.COMPILER_TREE)
 400     public Symbol getElement(TreePath path) {
 401         JCTree tree = (JCTree) path.getLeaf();
 402         Symbol sym = TreeInfo.symbolFor(tree);
 403         if (sym == null) {
 404             for (TreePath p = path; p != null; p = p.getParentPath()) {
 405                 JCTree t = (JCTree) p.getLeaf();
 406                 if (t.hasTag(JCTree.Tag.CLASSDEF)) {
 407                     JCClassDecl ct = (JCClassDecl) t;
 408                     if (ct.sym != null) {
 409                         if ((ct.sym.flags_field &amp; Flags.UNATTRIBUTED) != 0) {
 410                             attr.attribClass(ct.pos(), ct.sym);
 411                             sym = TreeInfo.symbolFor(tree);
 412                         }
 413                         break;
 414                     }
 415                 }
 416             }
 417         }
 418         return sym;
 419     }
 420 
 421     @Override @DefinedBy(Api.COMPILER_TREE)
 422     public Element getElement(DocTreePath path) {
 423         DocTree tree = path.getLeaf();
 424         if (tree instanceof DCReference)
 425             return attributeDocReference(path.getTreePath(), ((DCReference) tree));
 426         if (tree instanceof DCIdentifier) {
 427             if (path.getParentPath().getLeaf() instanceof DCParam) {
 428                 return attributeParamIdentifier(path.getTreePath(), (DCParam) path.getParentPath().getLeaf());
 429             }
 430         }
 431         return null;
 432     }
 433 
 434     @Override @DefinedBy(Api.COMPILER_TREE)
 435     public java.util.List&lt;DocTree&gt; getFirstSentence(java.util.List&lt;? extends DocTree&gt; list) {
 436         return docTreeMaker.getFirstSentence(list);
 437     }
 438 
 439     private Symbol attributeDocReference(TreePath path, DCReference ref) {
 440         Env&lt;AttrContext&gt; env = getAttrContext(path);
 441         if (env == null) return null;
 442 
 443         Log.DeferredDiagnosticHandler deferredDiagnosticHandler =
 444                 new Log.DeferredDiagnosticHandler(log);
 445         try {
 446             final TypeSymbol tsym;
 447             final Name memberName;
 448             if (ref.qualifierExpression == null) {
 449                 tsym = env.enclClass.sym;
 450                 memberName = (Name) ref.memberName;
 451             } else {
 452                 // newSeeTree if the qualifierExpression is a type or package name.
 453                 // javac does not provide the exact method required, so
 454                 // we first check if qualifierExpression identifies a type,
 455                 // and if not, then we check to see if it identifies a package.
 456                 Type t = attr.attribType(ref.qualifierExpression, env);
 457                 if (t.isErroneous()) {
 458                     JCCompilationUnit toplevel =
 459                         treeMaker.TopLevel(List.nil());
 460                     final ModuleSymbol msym = modules.getDefaultModule();
 461                     toplevel.modle = msym;
 462                     toplevel.packge = msym.unnamedPackage;
 463                     Symbol sym = attr.attribIdent(ref.qualifierExpression, toplevel);
 464 
 465                     if (sym == null)
 466                         return null;
 467 
 468                     sym.complete();
 469 
 470                     if ((sym.kind == PCK || sym.kind == TYP) &amp;&amp; sym.exists()) {
 471                         tsym = (TypeSymbol) sym;
 472                         memberName = (Name) ref.memberName;
 473                         if (sym.kind == PCK &amp;&amp; memberName != null) {
 474                             //cannot refer to a package &quot;member&quot;
 475                             return null;
 476                         }
 477                     } else {
 478                         if (ref.qualifierExpression.hasTag(JCTree.Tag.IDENT)) {
 479                             // fixup:  allow &quot;identifier&quot; instead of &quot;#identifier&quot;
 480                             // for compatibility with javadoc
 481                             tsym = env.enclClass.sym;
 482                             memberName = ((JCIdent) ref.qualifierExpression).name;
 483                         } else {
 484                             return null;
 485                         }
 486                     }
 487                 } else {
 488                     Type e = t;
 489                     // If this is an array type convert to element type
 490                     while (e instanceof ArrayType)
 491                         e = ((ArrayType)e).elemtype;
 492                     tsym = e.tsym;
 493                     memberName = (Name) ref.memberName;
 494                 }
 495             }
 496 
 497             if (memberName == null)
 498                 return tsym;
 499 
 500             final List&lt;Type&gt; paramTypes;
 501             if (ref.paramTypes == null)
 502                 paramTypes = null;
 503             else {
 504                 ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 505                 for (List&lt;JCTree&gt; l = (List&lt;JCTree&gt;) ref.paramTypes; l.nonEmpty(); l = l.tail) {
 506                     JCTree tree = l.head;
 507                     Type t = attr.attribType(tree, env);
 508                     lb.add(t);
 509                 }
 510                 paramTypes = lb.toList();
 511             }
 512 
 513             ClassSymbol sym = (ClassSymbol) types.skipTypeVars(tsym.type, false).tsym;
 514 
 515             Symbol msym = (memberName == sym.name)
 516                     ? findConstructor(sym, paramTypes)
 517                     : findMethod(sym, memberName, paramTypes);
 518             if (paramTypes != null) {
 519                 // explicit (possibly empty) arg list given, so cannot be a field
 520                 return msym;
 521             }
 522 
 523             VarSymbol vsym = (ref.paramTypes != null) ? null : findField(sym, memberName);
 524             // prefer a field over a method with no parameters
 525             if (vsym != null &amp;&amp;
 526                     (msym == null ||
 527                         types.isSubtypeUnchecked(vsym.enclClass().asType(), msym.enclClass().asType()))) {
 528                 return vsym;
 529             } else {
 530                 return msym;
 531             }
 532         } catch (Abort e) { // may be thrown by Check.completionError in case of bad class file
 533             return null;
 534         } finally {
 535             log.popDiagnosticHandler(deferredDiagnosticHandler);
 536         }
 537     }
 538 
 539     private Symbol attributeParamIdentifier(TreePath path, DCParam paramTag) {
 540         Symbol javadocSymbol = getElement(path);
 541         if (javadocSymbol == null)
 542             return null;
 543         ElementKind kind = javadocSymbol.getKind();
 544         List&lt;? extends Symbol&gt; params = List.nil();
 545         if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {
 546             MethodSymbol ee = (MethodSymbol) javadocSymbol;
 547             params = paramTag.isTypeParameter()
 548                     ? ee.getTypeParameters()
 549                     : ee.getParameters();
 550         } else if (kind.isClass() || kind.isInterface()) {
 551             ClassSymbol te = (ClassSymbol) javadocSymbol;
 552             params = paramTag.isTypeParameter()
 553                     ? te.getTypeParameters()
 554                     : te.getRecordComponents();
 555         }
 556 
 557         for (Symbol param : params) {
 558             if (param.getSimpleName() == paramTag.getName().getName()) {
 559                 return param;
 560             }
 561         }
 562         return null;
 563     }
 564 
 565     /** @see com.sun.tools.javadoc.ClassDocImpl#findField */
 566     private VarSymbol findField(ClassSymbol tsym, Name fieldName) {
 567         return searchField(tsym, fieldName, new HashSet&lt;&gt;());
 568     }
 569 
 570     /** @see com.sun.tools.javadoc.ClassDocImpl#searchField */
 571     private VarSymbol searchField(ClassSymbol tsym, Name fieldName, Set&lt;ClassSymbol&gt; searched) {
 572         if (searched.contains(tsym)) {
 573             return null;
 574         }
 575         searched.add(tsym);
 576 
 577         for (Symbol sym : tsym.members().getSymbolsByName(fieldName)) {
 578             if (sym.kind == VAR) {
 579                 return (VarSymbol)sym;
 580             }
 581         }
 582 
 583         //### If we found a VarSymbol above, but which did not pass
 584         //### the modifier filter, we should return failure here!
 585 
 586         ClassSymbol encl = tsym.owner.enclClass();
 587         if (encl != null) {
 588             VarSymbol vsym = searchField(encl, fieldName, searched);
 589             if (vsym != null) {
 590                 return vsym;
 591             }
 592         }
 593 
 594         // search superclass
 595         Type superclass = tsym.getSuperclass();
 596         if (superclass.tsym != null) {
 597             VarSymbol vsym = searchField((ClassSymbol) superclass.tsym, fieldName, searched);
 598             if (vsym != null) {
 599                 return vsym;
 600             }
 601         }
 602 
 603         // search interfaces
 604         List&lt;Type&gt; intfs = tsym.getInterfaces();
 605         for (List&lt;Type&gt; l = intfs; l.nonEmpty(); l = l.tail) {
 606             Type intf = l.head;
 607             if (intf.isErroneous()) continue;
 608             VarSymbol vsym = searchField((ClassSymbol) intf.tsym, fieldName, searched);
 609             if (vsym != null) {
 610                 return vsym;
 611             }
 612         }
 613 
 614         return null;
 615     }
 616 
 617     /** @see com.sun.tools.javadoc.ClassDocImpl#findConstructor */
 618     MethodSymbol findConstructor(ClassSymbol tsym, List&lt;Type&gt; paramTypes) {
 619         for (Symbol sym : tsym.members().getSymbolsByName(names.init)) {
 620             if (sym.kind == MTH) {
 621                 if (hasParameterTypes((MethodSymbol) sym, paramTypes)) {
 622                     return (MethodSymbol) sym;
 623                 }
 624             }
 625         }
 626         return null;
 627     }
 628 
 629     /** @see com.sun.tools.javadoc.ClassDocImpl#findMethod */
 630     private MethodSymbol findMethod(ClassSymbol tsym, Name methodName, List&lt;Type&gt; paramTypes) {
 631         return searchMethod(tsym, methodName, paramTypes, new HashSet&lt;&gt;());
 632     }
 633 
 634     /** @see com.sun.tools.javadoc.ClassDocImpl#searchMethod */
 635     private MethodSymbol searchMethod(ClassSymbol tsym, Name methodName,
 636                                        List&lt;Type&gt; paramTypes, Set&lt;ClassSymbol&gt; searched) {
 637         //### Note that this search is not necessarily what the compiler would do!
 638 
 639         // do not match constructors
 640         if (methodName == names.init)
 641             return null;
 642 
 643         if (searched.contains(tsym))
 644             return null;
 645         searched.add(tsym);
 646 
 647         // search current class
 648 
 649         //### Using modifier filter here isn&#39;t really correct,
 650         //### but emulates the old behavior.  Instead, we should
 651         //### apply the normal rules of visibility and inheritance.
 652 
 653         if (paramTypes == null) {
 654             // If no parameters specified, we are allowed to return
 655             // any method with a matching name.  In practice, the old
 656             // code returned the first method, which is now the last!
 657             // In order to provide textually identical results, we
 658             // attempt to emulate the old behavior.
 659             MethodSymbol lastFound = null;
 660             for (Symbol sym : tsym.members().getSymbolsByName(methodName)) {
 661                 if (sym.kind == MTH) {
 662                     if (sym.name == methodName) {
 663                         lastFound = (MethodSymbol)sym;
 664                     }
 665                 }
 666             }
 667             if (lastFound != null) {
 668                 return lastFound;
 669             }
 670         } else {
 671             for (Symbol sym : tsym.members().getSymbolsByName(methodName)) {
 672                 if (sym != null &amp;&amp;
 673                     sym.kind == MTH) {
 674                     if (hasParameterTypes((MethodSymbol) sym, paramTypes)) {
 675                         return (MethodSymbol) sym;
 676                     }
 677                 }
 678             }
 679         }
 680 
 681         //### If we found a MethodSymbol above, but which did not pass
 682         //### the modifier filter, we should return failure here!
 683 
 684         // search superclass
 685         Type superclass = tsym.getSuperclass();
 686         if (superclass.tsym != null) {
 687             MethodSymbol msym = searchMethod((ClassSymbol) superclass.tsym, methodName, paramTypes, searched);
 688             if (msym != null) {
 689                 return msym;
 690             }
 691         }
 692 
 693         // search interfaces
 694         List&lt;Type&gt; intfs = tsym.getInterfaces();
 695         for (List&lt;Type&gt; l = intfs; l.nonEmpty(); l = l.tail) {
 696             Type intf = l.head;
 697             if (intf.isErroneous()) continue;
 698             MethodSymbol msym = searchMethod((ClassSymbol) intf.tsym, methodName, paramTypes, searched);
 699             if (msym != null) {
 700                 return msym;
 701             }
 702         }
 703 
 704         // search enclosing class
 705         ClassSymbol encl = tsym.owner.enclClass();
 706         if (encl != null) {
 707             MethodSymbol msym = searchMethod(encl, methodName, paramTypes, searched);
 708             if (msym != null) {
 709                 return msym;
 710             }
 711         }
 712 
 713         return null;
 714     }
 715 
 716     /** @see com.sun.tools.javadoc.ClassDocImpl */
 717     private boolean hasParameterTypes(MethodSymbol method, List&lt;Type&gt; paramTypes) {
 718         if (paramTypes == null)
 719             return true;
 720 
 721         if (method.params().size() != paramTypes.size())
 722             return false;
 723 
 724         List&lt;Type&gt; methodParamTypes = types.erasureRecursive(method.asType()).getParameterTypes();
 725 
 726         return (Type.isErroneous(paramTypes))
 727             ? fuzzyMatch(paramTypes, methodParamTypes)
 728             : types.isSameTypes(paramTypes, methodParamTypes);
 729     }
 730 
 731     boolean fuzzyMatch(List&lt;Type&gt; paramTypes, List&lt;Type&gt; methodParamTypes) {
 732         List&lt;Type&gt; l1 = paramTypes;
 733         List&lt;Type&gt; l2 = methodParamTypes;
 734         while (l1.nonEmpty()) {
 735             if (!fuzzyMatch(l1.head, l2.head))
 736                 return false;
 737             l1 = l1.tail;
 738             l2 = l2.tail;
 739         }
 740         return true;
 741     }
 742 
 743     boolean fuzzyMatch(Type paramType, Type methodParamType) {
 744         Boolean b = fuzzyMatcher.visit(paramType, methodParamType);
 745         return (b == Boolean.TRUE);
 746     }
 747 
 748     TypeRelation fuzzyMatcher = new TypeRelation() {
 749         @Override
 750         public Boolean visitType(Type t, Type s) {
 751             if (t == s)
 752                 return true;
 753 
 754             if (s.isPartial())
 755                 return visit(s, t);
 756 
 757             switch (t.getTag()) {
 758             case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
 759             case DOUBLE: case BOOLEAN: case VOID: case BOT: case NONE:
 760                 return t.hasTag(s.getTag());
 761             default:
 762                 throw new AssertionError(&quot;fuzzyMatcher &quot; + t.getTag());
 763             }
 764         }
 765 
 766         @Override
 767         public Boolean visitArrayType(ArrayType t, Type s) {
 768             if (t == s)
 769                 return true;
 770 
 771             if (s.isPartial())
 772                 return visit(s, t);
 773 
 774             return s.hasTag(ARRAY)
 775                 &amp;&amp; visit(t.elemtype, types.elemtype(s));
 776         }
 777 
 778         @Override
 779         public Boolean visitClassType(ClassType t, Type s) {
 780             if (t == s)
 781                 return true;
 782 
 783             if (s.isPartial())
 784                 return visit(s, t);
 785 
 786             return t.tsym == s.tsym;
 787         }
 788 
 789         @Override
 790         public Boolean visitErrorType(ErrorType t, Type s) {
 791             return s.hasTag(CLASS)
 792                     &amp;&amp; t.tsym.name == ((ClassType) s).tsym.name;
 793         }
 794     };
 795 
 796     @Override @DefinedBy(Api.COMPILER_TREE)
 797     public TypeMirror getTypeMirror(TreePath path) {
 798         Tree t = path.getLeaf();
 799         Type ty = ((JCTree)t).type;
 800         return ty == null ? null : ty.stripMetadataIfNeeded();
 801     }
 802 
 803     @Override @DefinedBy(Api.COMPILER_TREE)
 804     public JavacScope getScope(TreePath path) {
 805         return JavacScope.create(getAttrContext(path));
 806     }
 807 
 808     @Override @DefinedBy(Api.COMPILER_TREE)
 809     public String getDocComment(TreePath path) {
 810         CompilationUnitTree t = path.getCompilationUnit();
 811         Tree leaf = path.getLeaf();
 812         if (t instanceof JCTree.JCCompilationUnit &amp;&amp; leaf instanceof JCTree) {
 813             JCCompilationUnit cu = (JCCompilationUnit) t;
 814             if (cu.docComments != null) {
 815                 return cu.docComments.getCommentText((JCTree) leaf);
 816             }
 817         }
 818         return null;
 819     }
 820 
 821     @Override @DefinedBy(Api.COMPILER_TREE)
 822     public DocCommentTree getDocCommentTree(TreePath path) {
 823         CompilationUnitTree t = path.getCompilationUnit();
 824         Tree leaf = path.getLeaf();
 825         if (t instanceof JCTree.JCCompilationUnit &amp;&amp; leaf instanceof JCTree) {
 826             JCCompilationUnit cu = (JCCompilationUnit) t;
 827             if (cu.docComments != null) {
 828                 return cu.docComments.getCommentTree((JCTree) leaf);
 829             }
 830         }
 831         return null;
 832     }
 833 
 834     @Override @DefinedBy(Api.COMPILER_TREE)
 835     public DocCommentTree getDocCommentTree(Element e) {
 836         TreePath path = getPath(e);
 837         if (path == null) {
 838             return null;
 839         }
 840         return getDocCommentTree(path);
 841     }
 842 
 843     @Override @DefinedBy(Api.COMPILER_TREE)
 844     public DocCommentTree getDocCommentTree(Element e, String relativeFileName) throws IOException {
 845         PackageElement pkg = elements.getPackageOf(e);
 846         FileObject fileForInput = fileManager.getFileForInput(StandardLocation.SOURCE_PATH,
 847                 pkg.getQualifiedName().toString(), relativeFileName);
 848 
 849         if (fileForInput == null) {
 850             throw new FileNotFoundException(relativeFileName);
 851         }
 852         return getDocCommentTree(fileForInput);
 853     }
 854 
 855     @Override @DefinedBy(Api.COMPILER_TREE)
 856     public boolean isAccessible(Scope scope, TypeElement type) {
 857         if (scope instanceof JavacScope &amp;&amp; type instanceof ClassSymbol) {
 858             Env&lt;AttrContext&gt; env = ((JavacScope) scope).env;
 859             return resolve.isAccessible(env, (ClassSymbol)type, true);
 860         } else
 861             return false;
 862     }
 863 
 864     @Override @DefinedBy(Api.COMPILER_TREE)
 865     public boolean isAccessible(Scope scope, Element member, DeclaredType type) {
 866         if (scope instanceof JavacScope
 867                 &amp;&amp; member instanceof Symbol
 868                 &amp;&amp; type instanceof com.sun.tools.javac.code.Type) {
 869             Env&lt;AttrContext&gt; env = ((JavacScope) scope).env;
 870             return resolve.isAccessible(env, (com.sun.tools.javac.code.Type)type, (Symbol)member, true);
 871         } else
 872             return false;
 873     }
 874 
 875     private Env&lt;AttrContext&gt; getAttrContext(TreePath path) {
 876         if (!(path.getLeaf() instanceof JCTree))  // implicit null-check
 877             throw new IllegalArgumentException();
 878 
 879         // if we&#39;re being invoked from a Tree API client via parse/enter/analyze,
 880         // we need to make sure all the classes have been entered;
 881         // if we&#39;re being invoked from JSR 199 or JSR 269, then the classes
 882         // will already have been entered.
 883         if (javacTaskImpl != null) {
 884             javacTaskImpl.enter(null);
 885         }
 886 
 887         JCCompilationUnit unit = (JCCompilationUnit) path.getCompilationUnit();
 888         Copier copier = createCopier(treeMaker.forToplevel(unit));
 889 
 890         Env&lt;AttrContext&gt; env = null;
 891         JCMethodDecl method = null;
 892         JCVariableDecl field = null;
 893 
 894         List&lt;Tree&gt; l = List.nil();
 895         TreePath p = path;
 896         while (p != null) {
 897             l = l.prepend(p.getLeaf());
 898             p = p.getParentPath();
 899         }
 900 
 901         for ( ; l.nonEmpty(); l = l.tail) {
 902             Tree tree = l.head;
 903             switch (tree.getKind()) {
 904                 case COMPILATION_UNIT:
 905 //                    System.err.println(&quot;COMP: &quot; + ((JCCompilationUnit)tree).sourcefile);
 906                     env = enter.getTopLevelEnv((JCCompilationUnit)tree);
 907                     break;
 908                 case ANNOTATION_TYPE:
 909                 case CLASS:
 910                 case ENUM:
 911                 case INTERFACE:
 912 //                    System.err.println(&quot;CLASS: &quot; + ((JCClassDecl)tree).sym.getSimpleName());
 913                     env = enter.getClassEnv(((JCClassDecl)tree).sym);
 914                     if (env == null) return null;
 915                     break;
 916                 case METHOD:
 917 //                    System.err.println(&quot;METHOD: &quot; + ((JCMethodDecl)tree).sym.getSimpleName());
 918                     method = (JCMethodDecl)tree;
 919                     env = memberEnter.getMethodEnv(method, env);
 920                     break;
 921                 case VARIABLE:
 922 //                    System.err.println(&quot;FIELD: &quot; + ((JCVariableDecl)tree).sym.getSimpleName());
 923                     field = (JCVariableDecl)tree;
 924                     break;
 925                 case BLOCK: {
 926 //                    System.err.println(&quot;BLOCK: &quot;);
 927                     if (method != null) {
 928                         try {
 929                             Assert.check(method.body == tree);
 930                             method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
 931                             env = attribStatToTree(method.body, env, copier.leafCopy, copier.copiedClasses);
 932                         } finally {
 933                             method.body = (JCBlock) tree;
 934                         }
 935                     } else {
 936                         JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
 937                         env = attribStatToTree(body, env, copier.leafCopy, copier.copiedClasses);
 938                     }
 939                     return env;
 940                 }
 941                 default:
 942 //                    System.err.println(&quot;DEFAULT: &quot; + tree.getKind());
 943                     if (field != null &amp;&amp; field.getInitializer() == tree) {
 944                         env = memberEnter.getInitEnv(field, env);
 945                         JCExpression expr = copier.copy((JCExpression)tree, (JCTree) path.getLeaf());
 946                         env = attribExprToTree(expr, env, copier.leafCopy, copier.copiedClasses);
 947                         return env;
 948                     }
 949             }
 950         }
 951         return (field != null) ? memberEnter.getInitEnv(field, env) : env;
 952     }
 953 
 954     private Env&lt;AttrContext&gt; attribStatToTree(JCTree stat, Env&lt;AttrContext&gt;env,
 955                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {
 956         Env&lt;AttrContext&gt; result = attr.attribStatToTree(stat, env, tree);
 957 
 958         fixLocalClassNames(copiedClasses, env);
 959 
 960         return result;
 961     }
 962 
 963     private Env&lt;AttrContext&gt; attribExprToTree(JCExpression expr, Env&lt;AttrContext&gt;env,
 964                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {
 965         Env&lt;AttrContext&gt; result = attr.attribExprToTree(expr, env, tree);
 966 
 967         fixLocalClassNames(copiedClasses, env);
 968 
 969         return result;
 970     }
 971 
 972     /* Change the flatnames of the local and anonymous classes in the Scope to
 973      * the names they would have if the whole file was attributed normally.
 974      */
 975     private void fixLocalClassNames(Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses,
 976                                     Env&lt;AttrContext&gt; lastEnv) {
 977         Map&lt;JCClassDecl, Name&gt; flatnameForClass = null;
 978 
 979         for (Entry&lt;JCClassDecl, JCClassDecl&gt; e : copiedClasses.entrySet()) {
 980             if (e.getKey().sym != null) {
 981                 Name origName;
 982                 if (e.getValue().sym != null) {
 983                     //if the source tree was already attributed, use the flatname
 984                     //from the source tree&#39;s Symbol:
 985                     origName = e.getValue().sym.flatname;
 986                 } else {
 987                     //otherwise, compute the flatnames (for source trees) as
 988                     //if the full source code would be attributed:
 989                     if (flatnameForClass == null) {
 990                         flatnameForClass = prepareFlatnameForClass(lastEnv);
 991                     }
 992                     origName = flatnameForClass.get(e.getValue());
 993                 }
 994                 if (origName != null) {
 995                     e.getKey().sym.flatname = origName;
 996                 }
 997             }
 998         }
 999     }
1000 
1001     /* This method computes and assigns flatnames to trees, as if they would be
1002      * normally assigned during attribution of the full source code.
1003      */
1004     private Map&lt;JCTree.JCClassDecl, Name&gt; prepareFlatnameForClass(Env&lt;AttrContext&gt; env) {
1005         Map&lt;JCClassDecl, Name&gt; flatNameForClass = new HashMap&lt;&gt;();
1006         Symbol enclClass = env.enclClass.sym;
1007 
1008         if (enclClass != null &amp;&amp; (enclClass.flags_field &amp; Flags.UNATTRIBUTED) != 0) {
1009             ListBuffer&lt;ClassSymbol&gt; toClear = new ListBuffer&lt;&gt;();
1010             new TreeScanner() {
1011                 Symbol owner;
1012                 boolean localContext;
1013                 @Override
1014                 public void visitClassDef(JCClassDecl tree) {
1015                     //compute the name (and ClassSymbol) which would be used
1016                     //for this class for full attribution
1017                     Symbol prevOwner = owner;
1018                     try {
1019                         ClassSymbol c;
1020                         if (tree.sym != null) {
1021                             //already entered:
1022                             c = tree.sym;
1023                         } else {
1024                             c = syms.defineClass(tree.name, owner);
1025                             if (owner.kind != TYP) {
1026                                 //for local classes, assign the flatname
1027                                 c.flatname = chk.localClassName(c);
1028                                 chk.putCompiled(c);
1029                                 toClear.add(c);
1030                             }
1031                             flatNameForClass.put(tree, c.flatname);
1032                         }
1033                         owner = c;
1034                         super.visitClassDef(tree);
1035                     } finally {
1036                         owner = prevOwner;
1037                     }
1038                 }
1039 
1040                 @Override
1041                 public void visitBlock(JCBlock tree) {
1042                     Symbol prevOwner = owner;
1043                     try {
1044                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);
1045                         super.visitBlock(tree);
1046                     } finally {
1047                         owner = prevOwner;
1048                     }
1049                 }
1050                 @Override
1051                 public void visitVarDef(JCVariableDecl tree) {
1052                     Symbol prevOwner = owner;
1053                     try {
1054                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);
1055                         super.visitVarDef(tree);
1056                     } finally {
1057                         owner = prevOwner;
1058                     }
1059                 }
1060             }.scan(env.enclClass);
1061             //revert changes done by the visitor:
1062             toClear.stream().forEach(c -&gt; {
1063                 chk.clearLocalClassNameIndexes(c);
1064                 chk.removeCompiled(c);
1065             });
1066         }
1067 
1068         return flatNameForClass;
1069     }
1070 
1071     static JavaFileObject asJavaFileObject(FileObject fileObject) {
1072         JavaFileObject jfo = null;
1073 
1074         if (fileObject instanceof JavaFileObject) {
1075             jfo = (JavaFileObject) fileObject;
1076             checkHtmlKind(fileObject, Kind.HTML);
1077             return jfo;
1078         }
1079 
1080         checkHtmlKind(fileObject);
1081         jfo = new HtmlFileObject(fileObject);
1082         return jfo;
1083     }
1084 
1085     private static void checkHtmlKind(FileObject fileObject) {
1086         checkHtmlKind(fileObject, BaseFileManager.getKind(fileObject.getName()));
1087     }
1088 
1089     private static void checkHtmlKind(FileObject fileObject, JavaFileObject.Kind kind) {
1090         if (kind != JavaFileObject.Kind.HTML) {
1091             throw new IllegalArgumentException(&quot;HTML file expected:&quot; + fileObject.getName());
1092         }
1093     }
1094 
1095     private static class HtmlFileObject extends ForwardingFileObject&lt;FileObject&gt;
1096             implements JavaFileObject {
1097 
1098         public HtmlFileObject(FileObject fileObject) {
1099             super(fileObject);
1100         }
1101 
1102         @Override @DefinedBy(Api.COMPILER)
1103         public Kind getKind() {
1104             return BaseFileManager.getKind(fileObject.getName());
1105         }
1106 
1107         @Override @DefinedBy(Api.COMPILER)
1108         public boolean isNameCompatible(String simpleName, Kind kind) {
1109             return false;
1110         }
1111 
1112         @Override @DefinedBy(Api.COMPILER)
1113         public NestingKind getNestingKind() {
1114             return null;
1115         }
1116 
1117         @Override @DefinedBy(Api.COMPILER)
1118         public Modifier getAccessLevel() {
1119             return null;
1120         }
1121     }
1122 
1123     @Override @DefinedBy(Api.COMPILER_TREE)
1124     public DocCommentTree getDocCommentTree(FileObject fileObject) {
1125         JavaFileObject jfo = asJavaFileObject(fileObject);
1126         DiagnosticSource diagSource = new DiagnosticSource(jfo, log);
1127 
1128         final Comment comment = new Comment() {
1129             int offset = 0;
1130             @Override
1131             public String getText() {
1132                 try {
1133                     CharSequence rawDoc = fileObject.getCharContent(true);
1134                     return rawDoc.toString();
1135                 } catch (IOException ignore) {
1136                     // do nothing
1137                 }
1138                 return &quot;&quot;;
1139             }
1140 
1141             @Override
1142             public int getSourcePos(int index) {
1143                 return offset + index;
1144             }
1145 
1146             @Override
1147             public CommentStyle getStyle() {
1148                 throw new UnsupportedOperationException();
1149             }
1150 
1151             @Override
1152             public boolean isDeprecated() {
1153                 throw new UnsupportedOperationException();
1154             }
1155         };
1156 
1157         return new DocCommentParser(parser, diagSource, comment, true).parse();
1158     }
1159 
1160     @Override @DefinedBy(Api.COMPILER_TREE)
1161     public DocTreePath getDocTreePath(FileObject fileObject, PackageElement packageElement) {
1162         JavaFileObject jfo = asJavaFileObject(fileObject);
1163         DocCommentTree docCommentTree = getDocCommentTree(jfo);
1164         if (docCommentTree == null)
1165             return null;
1166         TreePath treePath = makeTreePath((PackageSymbol)packageElement, jfo, docCommentTree);
1167         return new DocTreePath(treePath, docCommentTree);
1168     }
1169 
1170     @Override @DefinedBy(Api.COMPILER_TREE)
1171     public void setBreakIterator(BreakIterator breakiterator) {
1172         this.breakIterator = breakiterator;
1173     }
1174 
1175     /**
1176      * Makes a copy of a tree, noting the value resulting from copying a particular leaf.
1177      **/
1178     protected static class Copier extends TreeCopier&lt;JCTree&gt; {
1179         JCTree leafCopy = null;
1180         private Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses = new HashMap&lt;&gt;();
1181 
1182         protected Copier(TreeMaker M) {
1183             super(M);
1184         }
1185 
1186         @Override
1187         public &lt;T extends JCTree&gt; T copy(T t, JCTree leaf) {
1188             T t2 = super.copy(t, leaf);
1189             if (t == leaf)
1190                 leafCopy = t2;
1191             return t2;
1192         }
1193 
1194         @Override
1195         public JCTree visitClass(ClassTree node, JCTree p) {
1196             JCTree nue = super.visitClass(node, p);
1197             copiedClasses.put((JCClassDecl) nue, (JCClassDecl) node);
1198             return nue;
1199         }
1200 
1201     }
1202 
1203     protected Copier createCopier(TreeMaker maker) {
1204         return new Copier(maker);
1205     }
1206 
1207     /**
1208      * Returns the original type from the ErrorType object.
1209      * @param errorType The errorType for which we want to get the original type.
1210      * @return TypeMirror corresponding to the original type, replaced by the ErrorType.
1211      *         noType (type.tag == NONE) is returned if there is no original type.
1212      */
1213     @Override @DefinedBy(Api.COMPILER_TREE)
1214     public TypeMirror getOriginalType(javax.lang.model.type.ErrorType errorType) {
1215         if (errorType instanceof com.sun.tools.javac.code.Type.ErrorType) {
1216             return ((com.sun.tools.javac.code.Type.ErrorType)errorType).getOriginalType();
1217         }
1218         if (errorType instanceof com.sun.tools.javac.code.Type.ClassType &amp;&amp;
1219             errorType.getKind() == TypeKind.ERROR) {
1220             ClassType ct = (ClassType) errorType;
1221             return extraType2OriginalMap.computeIfAbsent(ct, tt -&gt;
1222                     new ClassType(ct.getEnclosingType(), ct.typarams_field,
1223                                   ct.tsym, ct.getMetadata()) {
1224                         @Override
1225                         public Type baseType() { return ct; }
1226                         @Override
1227                         public TypeKind getKind() {
1228                             return TypeKind.DECLARED;
1229                         }
1230                     });
1231         }
1232 
1233         return com.sun.tools.javac.code.Type.noType;
1234     }
1235 
1236     /**
1237      * Prints a message of the specified kind at the location of the
1238      * tree within the provided compilation unit
1239      *
1240      * @param kind the kind of message
1241      * @param msg  the message, or an empty string if none
1242      * @param t    the tree to use as a position hint
1243      * @param root the compilation unit that contains tree
1244      */
1245     @Override @DefinedBy(Api.COMPILER_TREE)
1246     public void printMessage(Diagnostic.Kind kind, CharSequence msg,
1247             com.sun.source.tree.Tree t,
1248             com.sun.source.tree.CompilationUnitTree root) {
1249         printMessage(kind, msg, ((JCTree) t).pos(), root);
1250     }
1251 
1252     @Override @DefinedBy(Api.COMPILER_TREE)
1253     public void printMessage(Diagnostic.Kind kind, CharSequence msg,
1254             com.sun.source.doctree.DocTree t,
1255             com.sun.source.doctree.DocCommentTree c,
1256             com.sun.source.tree.CompilationUnitTree root) {
1257         printMessage(kind, msg, ((DCTree) t).pos((DCDocComment) c), root);
1258     }
1259 
1260     private void printMessage(Diagnostic.Kind kind, CharSequence msg,
1261             JCDiagnostic.DiagnosticPosition pos,
1262             com.sun.source.tree.CompilationUnitTree root) {
1263         JavaFileObject oldSource = null;
1264         JavaFileObject newSource = null;
1265 
1266         newSource = root.getSourceFile();
1267         if (newSource == null) {
1268             pos = null;
1269         } else {
1270             oldSource = log.useSource(newSource);
1271         }
1272 
1273         try {
1274             switch (kind) {
1275             case ERROR:
1276                 log.error(DiagnosticFlag.API, pos, Errors.ProcMessager(msg.toString()));
1277                 break;
1278 
1279             case WARNING:
1280                 log.warning(pos, Warnings.ProcMessager(msg.toString()));
1281                 break;
1282 
1283             case MANDATORY_WARNING:
1284                 log.mandatoryWarning(pos, Warnings.ProcMessager(msg.toString()));
1285                 break;
1286 
1287             default:
1288                 log.note(pos, Notes.ProcMessager(msg.toString()));
1289             }
1290         } finally {
1291             if (oldSource != null)
1292                 log.useSource(oldSource);
1293         }
1294     }
1295 
1296     @Override @DefinedBy(Api.COMPILER_TREE)
1297     public TypeMirror getLub(CatchTree tree) {
1298         JCCatch ct = (JCCatch) tree;
1299         JCVariableDecl v = ct.param;
1300         if (v.type != null &amp;&amp; v.type.getKind() == TypeKind.UNION) {
1301             UnionClassType ut = (UnionClassType) v.type;
1302             return ut.getLub();
1303         } else {
1304             return v.type;
1305         }
1306     }
1307 
1308     private TreePath makeTreePath(final PackageSymbol psym, final JavaFileObject jfo,
1309             DocCommentTree dcTree) {
1310         JCCompilationUnit jcCompilationUnit = new JCCompilationUnit(List.nil()) {
1311             public int getPos() {
1312                 return Position.FIRSTPOS;
1313             }
1314 
1315             public JavaFileObject getSourcefile() {
1316                 return jfo;
1317             }
1318 
1319             @Override @DefinedBy(Api.COMPILER_TREE)
1320             public Position.LineMap getLineMap() {
1321                 try {
1322                     CharSequence content = jfo.getCharContent(true);
1323                     String s = content.toString();
1324                     return Position.makeLineMap(s.toCharArray(), s.length(), true);
1325                 } catch (IOException ignore) {}
1326                 return null;
1327             }
1328         };
1329 
1330         jcCompilationUnit.docComments = new DocCommentTable() {
1331             @Override
1332             public boolean hasComment(JCTree tree) {
1333                 return false;
1334             }
1335 
1336             @Override
1337             public Comment getComment(JCTree tree) {
1338                 throw new UnsupportedOperationException();
1339             }
1340 
1341             @Override
1342             public String getCommentText(JCTree tree) {
1343                 throw new UnsupportedOperationException();
1344             }
1345 
1346             @Override
1347             public DCDocComment getCommentTree(JCTree tree) {
1348                 return (DCDocComment)dcTree;
1349             }
1350 
1351             @Override
1352             public void putComment(JCTree tree, Comment c) {
1353                 throw new UnsupportedOperationException();
1354             }
1355 
1356         };
1357         jcCompilationUnit.lineMap = jcCompilationUnit.getLineMap();
1358         jcCompilationUnit.modle = psym.modle;
1359         jcCompilationUnit.sourcefile = jfo;
1360         jcCompilationUnit.namedImportScope = new NamedImportScope(psym);
1361         jcCompilationUnit.packge = psym;
1362         jcCompilationUnit.starImportScope = new StarImportScope(psym);
1363         jcCompilationUnit.toplevelScope = WriteableScope.create(psym);
1364         return new TreePath(jcCompilationUnit);
1365     }
1366 }
    </pre>
  </body>
</html>
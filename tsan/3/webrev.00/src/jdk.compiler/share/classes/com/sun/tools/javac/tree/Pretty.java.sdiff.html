<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JCTree.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeCopier.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.*;
  29 
<span class="line-removed">  30 import com.sun.source.tree.CaseTree.CaseKind;</span>
  31 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  32 import com.sun.source.tree.ModuleTree.ModuleKind;
  33 import com.sun.tools.javac.code.*;
  34 import com.sun.tools.javac.tree.JCTree.*;
  35 import com.sun.tools.javac.util.*;
  36 import com.sun.tools.javac.util.List;
  37 import static com.sun.tools.javac.code.Flags.*;
  38 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  39 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  40 
  41 /** Prints out a tree as an indented Java source program.
  42  *
  43  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  44  *  If you write code that depends on this, you do so at your own risk.
  45  *  This code and its internal interfaces are subject to change or
  46  *  deletion without notice.&lt;/b&gt;
  47  */
  48 public class Pretty extends JCTree.Visitor {
  49 
  50     public Pretty(Writer out, boolean sourceOutput) {
</pre>
<hr />
<pre>
 154             throw new AssertionError(e);
 155         }
 156         //we need to (i) replace all line terminators with a space and (ii) remove
 157         //occurrences of &#39;missing&#39; in the Pretty output (generated when types are missing)
 158         String res = s.toString().trim().replaceAll(&quot;\\s+&quot;, &quot; &quot;).replaceAll(&quot;/\\*missing\\*/&quot;, &quot;&quot;);
 159         if (res.length() &lt; maxLength) {
 160             return res;
 161         } else {
 162             int head = (maxLength - trimSequence.length()) * 2 / 3;
 163             int tail = maxLength - trimSequence.length() - head;
 164             return res.substring(0, head) + trimSequence + res.substring(res.length() - tail);
 165         }
 166     }
 167 
 168     String lineSep = System.getProperty(&quot;line.separator&quot;);
 169 
 170     /**************************************************************************
 171      * Traversal methods
 172      *************************************************************************/
 173 
<span class="line-modified"> 174     /** Exception to propogate IOException through visitXXX methods */</span>
 175     private static class UncheckedIOException extends Error {
 176         static final long serialVersionUID = -4032692679158424751L;
 177         UncheckedIOException(IOException e) {
 178             super(e.getMessage(), e);
 179         }
 180     }
 181 
 182     /** Visitor argument: the current precedence level.
 183      */
 184     int prec;
 185 
 186     /** Visitor method: print expression tree.
 187      *  @param prec  The current precedence level.
 188      */
 189     public void printExpr(JCTree tree, int prec) throws IOException {
 190         int prevPrec = this.prec;
 191         try {
 192             this.prec = prec;
 193             if (tree == null) print(&quot;/*missing*/&quot;);
 194             else {
</pre>
<hr />
<pre>
 218 
 219     /** Derived visitor method: print list of expression trees, separated by given string.
 220      *  @param sep the separator string
 221      */
 222     public &lt;T extends JCTree&gt; void printExprs(List&lt;T&gt; trees, String sep) throws IOException {
 223         if (trees.nonEmpty()) {
 224             printExpr(trees.head);
 225             for (List&lt;T&gt; l = trees.tail; l.nonEmpty(); l = l.tail) {
 226                 print(sep);
 227                 printExpr(l.head);
 228             }
 229         }
 230     }
 231 
 232     /** Derived visitor method: print list of expression trees, separated by commas.
 233      */
 234     public &lt;T extends JCTree&gt; void printExprs(List&lt;T&gt; trees) throws IOException {
 235         printExprs(trees, &quot;, &quot;);
 236     }
 237 








 238     /** Derived visitor method: print list of statements, each on a separate line.
 239      */
 240     public void printStats(List&lt;? extends JCTree&gt; trees) throws IOException {
 241         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail) {
 242             align();
 243             printStat(l.head);
 244             println();
 245         }
 246     }
 247 
 248     /** Print a set of modifiers.
 249      */
 250     public void printFlags(long flags) throws IOException {
 251         if ((flags &amp; SYNTHETIC) != 0) print(&quot;/*synthetic*/ &quot;);
 252         print(TreeInfo.flagNames(flags));
 253         if ((flags &amp; ExtendedStandardFlags) != 0) print(&quot; &quot;);
 254         if ((flags &amp; ANNOTATION) != 0) print(&quot;@&quot;);
 255     }
 256 
 257     public void printAnnotations(List&lt;JCAnnotation&gt; trees) throws IOException {
</pre>
<hr />
<pre>
 861     public void visitSwitchExpression(JCSwitchExpression tree) {
 862         try {
 863             print(&quot;switch &quot;);
 864             if (tree.selector.hasTag(PARENS)) {
 865                 printExpr(tree.selector);
 866             } else {
 867                 print(&quot;(&quot;);
 868                 printExpr(tree.selector);
 869                 print(&quot;)&quot;);
 870             }
 871             print(&quot; {&quot;);
 872             println();
 873             printStats(tree.cases);
 874             align();
 875             print(&quot;}&quot;);
 876         } catch (IOException e) {
 877             throw new UncheckedIOException(e);
 878         }
 879     }
 880 










 881     public void visitSynchronized(JCSynchronized tree) {
 882         try {
 883             print(&quot;synchronized &quot;);
 884             if (tree.lock.hasTag(PARENS)) {
 885                 printExpr(tree.lock);
 886             } else {
 887                 print(&quot;(&quot;);
 888                 printExpr(tree.lock);
 889                 print(&quot;)&quot;);
 890             }
 891             print(&quot; &quot;);
 892             printStat(tree.body);
 893         } catch (IOException e) {
 894             throw new UncheckedIOException(e);
 895         }
 896     }
 897 
 898     public void visitTry(JCTry tree) {
 899         try {
 900             print(&quot;try &quot;);
</pre>
<hr />
<pre>
 965                 print(&quot; else &quot;);
 966                 printStat(tree.elsepart);
 967             }
 968         } catch (IOException e) {
 969             throw new UncheckedIOException(e);
 970         }
 971     }
 972 
 973     public void visitExec(JCExpressionStatement tree) {
 974         try {
 975             printExpr(tree.expr);
 976             if (prec == TreeInfo.notExpression) print(&quot;;&quot;);
 977         } catch (IOException e) {
 978             throw new UncheckedIOException(e);
 979         }
 980     }
 981 
 982     public void visitBreak(JCBreak tree) {
 983         try {
 984             print(&quot;break&quot;);
<span class="line-modified"> 985             if (tree.value != null) print(&quot; &quot; + tree.value);</span>











 986             print(&quot;;&quot;);
 987         } catch (IOException e) {
 988             throw new UncheckedIOException(e);
 989         }
 990     }
 991 
 992     public void visitContinue(JCContinue tree) {
 993         try {
 994             print(&quot;continue&quot;);
 995             if (tree.label != null) print(&quot; &quot; + tree.label);
 996             print(&quot;;&quot;);
 997         } catch (IOException e) {
 998             throw new UncheckedIOException(e);
 999         }
1000     }
1001 
1002     public void visitReturn(JCReturn tree) {
1003         try {
1004             print(&quot;return&quot;);
1005             if (tree.expr != null) {
</pre>
<hr />
<pre>
1256     }
1257 
1258     public void visitTypeCast(JCTypeCast tree) {
1259         try {
1260             open(prec, TreeInfo.prefixPrec);
1261             print(&quot;(&quot;);
1262             printExpr(tree.clazz);
1263             print(&quot;)&quot;);
1264             printExpr(tree.expr, TreeInfo.prefixPrec);
1265             close(prec, TreeInfo.prefixPrec);
1266         } catch (IOException e) {
1267             throw new UncheckedIOException(e);
1268         }
1269     }
1270 
1271     public void visitTypeTest(JCInstanceOf tree) {
1272         try {
1273             open(prec, TreeInfo.ordPrec);
1274             printExpr(tree.expr, TreeInfo.ordPrec);
1275             print(&quot; instanceof &quot;);
<span class="line-modified">1276             printExpr(tree.clazz, TreeInfo.ordPrec + 1);</span>




1277             close(prec, TreeInfo.ordPrec);
1278         } catch (IOException e) {
1279             throw new UncheckedIOException(e);
1280         }
1281     }
1282 
1283     public void visitIndexed(JCArrayAccess tree) {
1284         try {
1285             printExpr(tree.indexed, TreeInfo.postfixPrec);
1286             print(&quot;[&quot;);
1287             printExpr(tree.index);
1288             print(&quot;]&quot;);
1289         } catch (IOException e) {
1290             throw new UncheckedIOException(e);
1291         }
1292     }
1293 
1294     public void visitSelect(JCFieldAccess tree) {
1295         try {
1296             printExpr(tree.selected, TreeInfo.postfixPrec);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.*;
  29 

  30 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  31 import com.sun.source.tree.ModuleTree.ModuleKind;
  32 import com.sun.tools.javac.code.*;
  33 import com.sun.tools.javac.tree.JCTree.*;
  34 import com.sun.tools.javac.util.*;
  35 import com.sun.tools.javac.util.List;
  36 import static com.sun.tools.javac.code.Flags.*;
  37 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  38 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  39 
  40 /** Prints out a tree as an indented Java source program.
  41  *
  42  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  43  *  If you write code that depends on this, you do so at your own risk.
  44  *  This code and its internal interfaces are subject to change or
  45  *  deletion without notice.&lt;/b&gt;
  46  */
  47 public class Pretty extends JCTree.Visitor {
  48 
  49     public Pretty(Writer out, boolean sourceOutput) {
</pre>
<hr />
<pre>
 153             throw new AssertionError(e);
 154         }
 155         //we need to (i) replace all line terminators with a space and (ii) remove
 156         //occurrences of &#39;missing&#39; in the Pretty output (generated when types are missing)
 157         String res = s.toString().trim().replaceAll(&quot;\\s+&quot;, &quot; &quot;).replaceAll(&quot;/\\*missing\\*/&quot;, &quot;&quot;);
 158         if (res.length() &lt; maxLength) {
 159             return res;
 160         } else {
 161             int head = (maxLength - trimSequence.length()) * 2 / 3;
 162             int tail = maxLength - trimSequence.length() - head;
 163             return res.substring(0, head) + trimSequence + res.substring(res.length() - tail);
 164         }
 165     }
 166 
 167     String lineSep = System.getProperty(&quot;line.separator&quot;);
 168 
 169     /**************************************************************************
 170      * Traversal methods
 171      *************************************************************************/
 172 
<span class="line-modified"> 173     /** Exception to propagate IOException through visitXXX methods */</span>
 174     private static class UncheckedIOException extends Error {
 175         static final long serialVersionUID = -4032692679158424751L;
 176         UncheckedIOException(IOException e) {
 177             super(e.getMessage(), e);
 178         }
 179     }
 180 
 181     /** Visitor argument: the current precedence level.
 182      */
 183     int prec;
 184 
 185     /** Visitor method: print expression tree.
 186      *  @param prec  The current precedence level.
 187      */
 188     public void printExpr(JCTree tree, int prec) throws IOException {
 189         int prevPrec = this.prec;
 190         try {
 191             this.prec = prec;
 192             if (tree == null) print(&quot;/*missing*/&quot;);
 193             else {
</pre>
<hr />
<pre>
 217 
 218     /** Derived visitor method: print list of expression trees, separated by given string.
 219      *  @param sep the separator string
 220      */
 221     public &lt;T extends JCTree&gt; void printExprs(List&lt;T&gt; trees, String sep) throws IOException {
 222         if (trees.nonEmpty()) {
 223             printExpr(trees.head);
 224             for (List&lt;T&gt; l = trees.tail; l.nonEmpty(); l = l.tail) {
 225                 print(sep);
 226                 printExpr(l.head);
 227             }
 228         }
 229     }
 230 
 231     /** Derived visitor method: print list of expression trees, separated by commas.
 232      */
 233     public &lt;T extends JCTree&gt; void printExprs(List&lt;T&gt; trees) throws IOException {
 234         printExprs(trees, &quot;, &quot;);
 235     }
 236 
<span class="line-added"> 237 </span>
<span class="line-added"> 238     /** Derived visitor method: print pattern.</span>
<span class="line-added"> 239      */</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241     public void printPattern(JCTree tree) throws IOException {</span>
<span class="line-added"> 242         printExpr(tree);</span>
<span class="line-added"> 243     }</span>
<span class="line-added"> 244 </span>
 245     /** Derived visitor method: print list of statements, each on a separate line.
 246      */
 247     public void printStats(List&lt;? extends JCTree&gt; trees) throws IOException {
 248         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail) {
 249             align();
 250             printStat(l.head);
 251             println();
 252         }
 253     }
 254 
 255     /** Print a set of modifiers.
 256      */
 257     public void printFlags(long flags) throws IOException {
 258         if ((flags &amp; SYNTHETIC) != 0) print(&quot;/*synthetic*/ &quot;);
 259         print(TreeInfo.flagNames(flags));
 260         if ((flags &amp; ExtendedStandardFlags) != 0) print(&quot; &quot;);
 261         if ((flags &amp; ANNOTATION) != 0) print(&quot;@&quot;);
 262     }
 263 
 264     public void printAnnotations(List&lt;JCAnnotation&gt; trees) throws IOException {
</pre>
<hr />
<pre>
 868     public void visitSwitchExpression(JCSwitchExpression tree) {
 869         try {
 870             print(&quot;switch &quot;);
 871             if (tree.selector.hasTag(PARENS)) {
 872                 printExpr(tree.selector);
 873             } else {
 874                 print(&quot;(&quot;);
 875                 printExpr(tree.selector);
 876                 print(&quot;)&quot;);
 877             }
 878             print(&quot; {&quot;);
 879             println();
 880             printStats(tree.cases);
 881             align();
 882             print(&quot;}&quot;);
 883         } catch (IOException e) {
 884             throw new UncheckedIOException(e);
 885         }
 886     }
 887 
<span class="line-added"> 888     public void visitBindingPattern(JCBindingPattern patt) {</span>
<span class="line-added"> 889         try {</span>
<span class="line-added"> 890             printExpr(patt.vartype);</span>
<span class="line-added"> 891             print(&quot; &quot;);</span>
<span class="line-added"> 892             print(patt.name);</span>
<span class="line-added"> 893         } catch (IOException e) {</span>
<span class="line-added"> 894             throw new UncheckedIOException(e);</span>
<span class="line-added"> 895         }</span>
<span class="line-added"> 896     }</span>
<span class="line-added"> 897 </span>
 898     public void visitSynchronized(JCSynchronized tree) {
 899         try {
 900             print(&quot;synchronized &quot;);
 901             if (tree.lock.hasTag(PARENS)) {
 902                 printExpr(tree.lock);
 903             } else {
 904                 print(&quot;(&quot;);
 905                 printExpr(tree.lock);
 906                 print(&quot;)&quot;);
 907             }
 908             print(&quot; &quot;);
 909             printStat(tree.body);
 910         } catch (IOException e) {
 911             throw new UncheckedIOException(e);
 912         }
 913     }
 914 
 915     public void visitTry(JCTry tree) {
 916         try {
 917             print(&quot;try &quot;);
</pre>
<hr />
<pre>
 982                 print(&quot; else &quot;);
 983                 printStat(tree.elsepart);
 984             }
 985         } catch (IOException e) {
 986             throw new UncheckedIOException(e);
 987         }
 988     }
 989 
 990     public void visitExec(JCExpressionStatement tree) {
 991         try {
 992             printExpr(tree.expr);
 993             if (prec == TreeInfo.notExpression) print(&quot;;&quot;);
 994         } catch (IOException e) {
 995             throw new UncheckedIOException(e);
 996         }
 997     }
 998 
 999     public void visitBreak(JCBreak tree) {
1000         try {
1001             print(&quot;break&quot;);
<span class="line-modified">1002             if (tree.label != null) print(&quot; &quot; + tree.label);</span>
<span class="line-added">1003             print(&quot;;&quot;);</span>
<span class="line-added">1004         } catch (IOException e) {</span>
<span class="line-added">1005             throw new UncheckedIOException(e);</span>
<span class="line-added">1006         }</span>
<span class="line-added">1007     }</span>
<span class="line-added">1008 </span>
<span class="line-added">1009     public void visitYield(JCYield tree) {</span>
<span class="line-added">1010         try {</span>
<span class="line-added">1011             print(&quot;yield&quot;);</span>
<span class="line-added">1012             print(&quot; &quot;);</span>
<span class="line-added">1013             printExpr(tree.value);</span>
1014             print(&quot;;&quot;);
1015         } catch (IOException e) {
1016             throw new UncheckedIOException(e);
1017         }
1018     }
1019 
1020     public void visitContinue(JCContinue tree) {
1021         try {
1022             print(&quot;continue&quot;);
1023             if (tree.label != null) print(&quot; &quot; + tree.label);
1024             print(&quot;;&quot;);
1025         } catch (IOException e) {
1026             throw new UncheckedIOException(e);
1027         }
1028     }
1029 
1030     public void visitReturn(JCReturn tree) {
1031         try {
1032             print(&quot;return&quot;);
1033             if (tree.expr != null) {
</pre>
<hr />
<pre>
1284     }
1285 
1286     public void visitTypeCast(JCTypeCast tree) {
1287         try {
1288             open(prec, TreeInfo.prefixPrec);
1289             print(&quot;(&quot;);
1290             printExpr(tree.clazz);
1291             print(&quot;)&quot;);
1292             printExpr(tree.expr, TreeInfo.prefixPrec);
1293             close(prec, TreeInfo.prefixPrec);
1294         } catch (IOException e) {
1295             throw new UncheckedIOException(e);
1296         }
1297     }
1298 
1299     public void visitTypeTest(JCInstanceOf tree) {
1300         try {
1301             open(prec, TreeInfo.ordPrec);
1302             printExpr(tree.expr, TreeInfo.ordPrec);
1303             print(&quot; instanceof &quot;);
<span class="line-modified">1304             if (tree.pattern instanceof JCPattern) {</span>
<span class="line-added">1305                 printPattern(tree.pattern);</span>
<span class="line-added">1306             } else {</span>
<span class="line-added">1307                 printExpr(tree.getType(), TreeInfo.ordPrec + 1);</span>
<span class="line-added">1308             }</span>
1309             close(prec, TreeInfo.ordPrec);
1310         } catch (IOException e) {
1311             throw new UncheckedIOException(e);
1312         }
1313     }
1314 
1315     public void visitIndexed(JCArrayAccess tree) {
1316         try {
1317             printExpr(tree.indexed, TreeInfo.postfixPrec);
1318             print(&quot;[&quot;);
1319             printExpr(tree.index);
1320             print(&quot;]&quot;);
1321         } catch (IOException e) {
1322             throw new UncheckedIOException(e);
1323         }
1324     }
1325 
1326     public void visitSelect(JCFieldAccess tree) {
1327         try {
1328             printExpr(tree.selected, TreeInfo.postfixPrec);
</pre>
</td>
</tr>
</table>
<center><a href="JCTree.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeCopier.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,10 +23,11 @@
  * questions.
  */
 
 package com.sun.tools.javac.jvm;
 
+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 import com.sun.tools.javac.tree.TreeInfo.PosKind;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.code.*;
@@ -86,13 +87,13 @@
         if (instance == null)
             instance = new Gen(context);
         return instance;
     }
 
-    /** Constant pool, reset by genClass.
+    /** Constant pool writer, set by genClass.
      */
-    private final Pool pool;
+    final PoolWriter poolWriter;
 
     protected Gen(Context context) {
         context.put(genKey, this);
 
         names = Names.instance(context);
@@ -119,11 +120,11 @@
             ? options.isSet(G)
             : options.isSet(G_CUSTOM, "vars");
         genCrt = options.isSet(XJCOV);
         debugCode = options.isSet("debug.code");
         disableVirtualizedPrivateInvoke = options.isSet("disableVirtualizedPrivateInvoke");
-        pool = new Pool(types);
+        poolWriter = new PoolWriter(types, names);
 
         // ignore cldc because we cannot have both stackmap formats
         this.stackMap = StackMapFormat.JSR202;
         annotate = Annotate.instance(context);
     }
@@ -163,10 +164,11 @@
 
     boolean inCondSwitchExpression;
     Chain switchExpressionTrueChain;
     Chain switchExpressionFalseChain;
     List<LocalItem> stackBeforeSwitchExpression;
+    LocalItem switchResult;
 
     /** Generate code to load an integer constant.
      *  @param n     The integer to be loaded.
      */
     void loadIntConst(int n) {
@@ -250,21 +252,21 @@
      *  checking for an array with too many dimensions;
      *  return the reference's index.
      *  @param type   The type for which a reference is inserted.
      */
     int makeRef(DiagnosticPosition pos, Type type) {
-        checkDimension(pos, type);
-        if (type.isAnnotated()) {
-            return pool.put((Object)type);
-        } else {
-            return pool.put(type.hasTag(CLASS) ? (Object)type.tsym : (Object)type);
-        }
+        return poolWriter.putClass(checkDimension(pos, type));
     }
 
     /** Check if the given type is an array with too many dimensions.
      */
-    private void checkDimension(DiagnosticPosition pos, Type t) {
+    private Type checkDimension(DiagnosticPosition pos, Type t) {
+        checkDimensionInternal(pos, t);
+        return t;
+    }
+
+    private void checkDimensionInternal(DiagnosticPosition pos, Type t) {
         switch (t.getTag()) {
         case METHOD:
             checkDimension(pos, t.getReturnType());
             for (List<Type> args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
                 checkDimension(pos, args.head);
@@ -278,11 +280,11 @@
         default:
             break;
         }
     }
 
-    /** Create a tempory variable.
+    /** Create a temporary variable.
      *  @param type   The variable's type.
      */
     LocalItem makeTemp(Type type) {
         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
                                     names.empty,
@@ -514,11 +516,11 @@
      */
     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
         if (nerrs != 0 || // only complain about a long string once
             constValue == null ||
             !(constValue instanceof String) ||
-            ((String)constValue).length() < Pool.MAX_STRING_LENGTH)
+            ((String)constValue).length() < PoolWriter.MAX_STRING_LENGTH)
             return;
         log.error(pos, Errors.LimitString);
         nerrs++;
     }
 
@@ -723,10 +725,12 @@
                                       Code.mergeChains(trueJumps, second.trueJumps),
                                       Code.mergeChains(falseJumps, second.falseJumps));
             if (markBranches) result.tree = tree.falsepart;
             return result;
         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
+            code.resolvePending();
+
             boolean prevInCondSwitchExpression = inCondSwitchExpression;
             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
             try {
                 inCondSwitchExpression = true;
@@ -747,10 +751,12 @@
                 inCondSwitchExpression = prevInCondSwitchExpression;
                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
             }
         } else if (inner_tree.hasTag(LETEXPR) && ((LetExpr) inner_tree).needsCond) {
+            code.resolvePending();
+
             LetExpr tree = (LetExpr) inner_tree;
             int limit = code.nextreg;
             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
             try {
                 genStats(tree.defs, env);
@@ -804,11 +810,11 @@
         }
 
         @Override
         public void visitIdent(JCIdent tree) {
             if (tree.sym.owner instanceof ClassSymbol) {
-                pool.put(tree.sym.owner);
+                poolWriter.putClass((ClassSymbol)tree.sym.owner);
             }
         }
 
         @Override
         public void visitConditional(JCConditional tree) {
@@ -845,11 +851,16 @@
         try {
             if (tree.type.constValue() != null) {
                 // Short circuit any expressions which are constants
                 tree.accept(classReferenceVisitor);
                 checkStringConstant(tree.pos(), tree.type.constValue());
-                result = items.makeImmediateItem(tree.type, tree.type.constValue());
+                Symbol sym = TreeInfo.symbol(tree);
+                if (sym != null && isConstantDynamic(sym)) {
+                    result = items.makeDynamicItem(sym);
+                } else {
+                    result = items.makeImmediateItem(tree.type, tree.type.constValue());
+                }
             } else {
                 this.pt = pt;
                 tree.accept(this);
             }
             return result.coerce(pt);
@@ -860,10 +871,16 @@
         } finally {
             this.pt = prevPt;
         }
     }
 
+    public boolean isConstantDynamic(Symbol sym) {
+        return sym.kind == VAR &&
+                sym instanceof DynamicVarSymbol &&
+                ((DynamicVarSymbol)sym).isDynamic();
+    }
+
     /** Derived visitor method: generate code for a list of method arguments.
      *  @param trees    The argument expressions to be visited.
      *  @param pts      The expression's expected types (i.e. the formal parameter
      *                  types of the invoked method).
      */
@@ -1005,12 +1022,12 @@
                                         debugCode,
                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
                                                : null,
                                         syms,
                                         types,
-                                        pool);
-            items = new Items(pool, code, syms, types);
+                                        poolWriter);
+            items = new Items(poolWriter, code, syms, types);
             if (code.debugCode) {
                 System.err.println(meth + " for body " + tree);
             }
 
             // If method is not static, create a new local variable address
@@ -1089,11 +1106,11 @@
     }
     //where
         /** Generate code for a loop.
          *  @param loop       The tree representing the loop.
          *  @param body       The loop's body.
-         *  @param cond       The loop's controling condition.
+         *  @param cond       The loop's controlling condition.
          *  @param step       "Step" statements to be inserted at end of
          *                    each iteration.
          *  @param testFirst  True if the loop test belongs before the body.
          */
         private void genLoop(JCStatement loop,
@@ -1176,13 +1193,15 @@
         result = items.makeStackItem(pt);
     }
 
     private void doHandleSwitchExpression(JCSwitchExpression tree) {
         List<LocalItem> prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
+        LocalItem prevSwitchResult = switchResult;
         int limit = code.nextreg;
         try {
             stackBeforeSwitchExpression = List.nil();
+            switchResult = null;
             if (hasTry(tree)) {
                 //if the switch expression contains try-catch, the catch handlers need to have
                 //an empty stack. So stash whole stack to local variables, and restore it before
                 //breaks:
                 while (code.state.stacksize > 0) {
@@ -1197,19 +1216,21 @@
                                                   this.env.enclMethod.sym);
                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
                     item.store();
                 }
+                switchResult = makeTemp(tree.type);
             }
             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
             try {
                 handleSwitch(tree, tree.selector, tree.cases);
             } finally {
                 code.setLetExprStackPos(prevLetExprStart);
             }
         } finally {
             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
+            switchResult = prevSwitchResult;
             code.endScopes(limit);
         }
     }
     //where:
         private boolean hasTry(JCSwitchExpression tree) {
@@ -1499,11 +1520,11 @@
                                                  code.branch(goto_));
                 }
                 endFinalizerGap(env);
             }
             if (hasFinalizer) {
-                // Create a new register segement to avoid allocating
+                // Create a new register segment to avoid allocating
                 // the same variables in finalizers and other statements.
                 code.newRegSegment();
 
                 // Add a catch-all clause.
 
@@ -1702,55 +1723,81 @@
         genExpr(tree.expr, tree.expr.type).drop();
         Assert.check(code.isStatementStart());
     }
 
     public void visitBreak(JCBreak tree) {
+        Assert.check(code.isStatementStart());
+        final Env<GenContext> targetEnv = unwindBreak(tree.target);
+        targetEnv.info.addExit(code.branch(goto_));
+        endFinalizerGaps(env, targetEnv);
+    }
+
+    public void visitYield(JCYield tree) {
         Assert.check(code.isStatementStart());
         final Env<GenContext> targetEnv;
-        if (tree.isValueBreak()) {
-            //restore stack as it was before the switch expression:
-            for (LocalItem li : stackBeforeSwitchExpression) {
-                li.load();
+        if (inCondSwitchExpression) {
+            CondItem value = genCond(tree.value, CRT_FLOW_TARGET);
+            Chain falseJumps = value.jumpFalse();
+
+            code.resolve(value.trueJumps);
+            Env<GenContext> localEnv = unwindBreak(tree.target);
+            reloadStackBeforeSwitchExpr();
+            Chain trueJumps = code.branch(goto_);
+
+            endFinalizerGaps(env, localEnv);
+
+            code.resolve(falseJumps);
+            targetEnv = unwindBreak(tree.target);
+            reloadStackBeforeSwitchExpr();
+            falseJumps = code.branch(goto_);
+
+            if (switchExpressionTrueChain == null) {
+                switchExpressionTrueChain = trueJumps;
+            } else {
+                switchExpressionTrueChain =
+                        Code.mergeChains(switchExpressionTrueChain, trueJumps);
             }
-            if (inCondSwitchExpression) {
-                CondItem value = genCond(tree.value, CRT_FLOW_TARGET);
-                Chain falseJumps = value.jumpFalse();
-                targetEnv = unwindBreak(tree);
-                code.resolve(value.trueJumps);
-                Chain trueJumps = code.branch(goto_);
-                if (switchExpressionTrueChain == null) {
-                    switchExpressionTrueChain = trueJumps;
-                } else {
-                    switchExpressionTrueChain =
-                            Code.mergeChains(switchExpressionTrueChain, trueJumps);
-                }
-                if (switchExpressionFalseChain == null) {
-                    switchExpressionFalseChain = falseJumps;
-                } else {
-                    switchExpressionFalseChain =
-                            Code.mergeChains(switchExpressionFalseChain, falseJumps);
-                }
+            if (switchExpressionFalseChain == null) {
+                switchExpressionFalseChain = falseJumps;
             } else {
-                genExpr(tree.value, pt).load();
+                switchExpressionFalseChain =
+                        Code.mergeChains(switchExpressionFalseChain, falseJumps);
+            }
+        } else {
+            genExpr(tree.value, pt).load();
+            if (switchResult != null)
+                switchResult.store();
+
+            targetEnv = unwindBreak(tree.target);
+
+            if (code.isAlive()) {
+                reloadStackBeforeSwitchExpr();
+                if (switchResult != null)
+                    switchResult.load();
+
                 code.state.forceStackTop(tree.target.type);
-                targetEnv = unwindBreak(tree);
                 targetEnv.info.addExit(code.branch(goto_));
+                code.markDead();
             }
-        } else {
-            targetEnv = unwindBreak(tree);
-            targetEnv.info.addExit(code.branch(goto_));
         }
         endFinalizerGaps(env, targetEnv);
     }
     //where:
-        private Env<GenContext> unwindBreak(JCBreak tree) {
+        /** As side-effect, might mark code as dead disabling any further emission.
+         */
+        private Env<GenContext> unwindBreak(JCTree target) {
             int tmpPos = code.pendingStatPos;
-            Env<GenContext> targetEnv = unwind(tree.target, env);
+            Env<GenContext> targetEnv = unwind(target, env);
             code.pendingStatPos = tmpPos;
             return targetEnv;
         }
 
+        private void reloadStackBeforeSwitchExpr() {
+            for (LocalItem li : stackBeforeSwitchExpression)
+                li.load();
+        }
+
     public void visitContinue(JCContinue tree) {
         int tmpPos = code.pendingStatPos;
         Env<GenContext> targetEnv = unwind(tree.target, env);
         code.pendingStatPos = tmpPos;
         Assert.check(code.isStatementStart());
@@ -1884,11 +1931,11 @@
         // Enclosing instances or anonymous classes should have been eliminated
         // by now.
         Assert.check(tree.encl == null && tree.def == null);
         setTypeAnnotationPositions(tree.pos);
 
-        code.emitop2(new_, makeRef(tree.pos(), tree.type));
+        code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);
         code.emitop0(dup);
 
         // Generate code for all arguments, where the expected types are
         // the parameters of the constructor's external type (that is,
         // any implicit outer instance appears as first parameter).
@@ -2160,22 +2207,22 @@
         // For basic types, the coerce(...) in genExpr(...) will do
         // the conversion.
         if (!tree.clazz.type.isPrimitive() &&
            !types.isSameType(tree.expr.type, tree.clazz.type) &&
            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
-            code.emitop2(checkcast, makeRef(tree.pos(), tree.clazz.type));
+            code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);
         }
     }
 
     public void visitWildcard(JCWildcard tree) {
         throw new AssertionError(this.getClass().getName());
     }
 
     public void visitTypeTest(JCInstanceOf tree) {
         genExpr(tree.expr, tree.expr.type).load();
         setTypeAnnotationPositions(tree.pos);
-        code.emitop2(instanceof_, makeRef(tree.pos(), tree.clazz.type));
+        code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));
         result = items.makeStackItem(syms.booleanType);
     }
 
     public void visitIndexed(JCArrayAccess tree) {
         genExpr(tree.indexed, tree.indexed.type).load();
@@ -2193,14 +2240,17 @@
                 // Generate code to address the constructor.
                 res.load();
                 res = items.makeMemberItem(sym, true);
             }
             result = res;
+       } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {
+            if (isConstantDynamic(sym)) {
+                setTypeAnnotationPositions(tree.pos);
+            }
+            result = items.makeDynamicItem(sym);
         } else if (sym.kind == VAR && (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
             result = items.makeLocalItem((VarSymbol)sym);
-        } else if (isInvokeDynamic(sym)) {
-            result = items.makeDynamicItem(sym);
         } else if ((sym.flags() & STATIC) != 0) {
             if (!isAccessSuper(env.enclMethod))
                 sym = binaryQualifier(sym, env.enclClass.type);
             result = items.makeStaticItem(sym);
         } else {
@@ -2219,11 +2269,11 @@
 
     public void visitSelect(JCFieldAccess tree) {
         Symbol sym = tree.sym;
 
         if (tree.name == names._class) {
-            code.emitLdc(makeRef(tree.pos(), tree.selected.type));
+            code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));
             result = items.makeStackItem(pt);
             return;
        }
 
         Symbol ssym = TreeInfo.symbol(tree.selected);
@@ -2292,10 +2342,12 @@
         else
             result = items.makeImmediateItem(tree.type, tree.value);
     }
 
     public void visitLetExpr(LetExpr tree) {
+        code.resolvePending();
+
         int limit = code.nextreg;
         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
         try {
             genStats(tree.defs, env);
         } finally {
@@ -2303,11 +2355,11 @@
         }
         result = genExpr(tree.expr, tree.expr.type).load();
         code.endScopes(limit);
     }
 
-    private void generateReferencesToPrunedTree(ClassSymbol classSymbol, Pool pool) {
+    private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {
         List<JCTree> prunedInfo = lower.prunedTree.get(classSymbol);
         if (prunedInfo != null) {
             for (JCTree prunedTree: prunedInfo) {
                 prunedTree.accept(classReferenceVisitor);
             }
@@ -2329,24 +2381,22 @@
         try {
             attrEnv = env;
             ClassSymbol c = cdef.sym;
             this.toplevel = env.toplevel;
             this.endPosTable = toplevel.endPositions;
-            c.pool = pool;
-            pool.reset();
             /* method normalizeDefs() can add references to external classes into the constant pool
              */
             cdef.defs = normalizeDefs(cdef.defs, c);
-            generateReferencesToPrunedTree(c, pool);
+            generateReferencesToPrunedTree(c);
             Env<GenContext> localEnv = new Env<>(cdef, new GenContext());
             localEnv.toplevel = env.toplevel;
             localEnv.enclClass = cdef;
 
             for (List<JCTree> l = cdef.defs; l.nonEmpty(); l = l.tail) {
                 genDef(l.head, localEnv);
             }
-            if (pool.numEntries() > Pool.MAX_ENTRIES) {
+            if (poolWriter.size() > PoolWriter.MAX_ENTRIES) {
                 log.error(cdef.pos(), Errors.LimitPool);
                 nerrs++;
             }
             if (nerrs != 0) {
                 // if errors, discard code

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeScanner.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.util.Iterator;
  29 
<span class="line-modified">  30 import com.sun.source.tree.CaseTree.CaseKind;</span>
  31 import com.sun.source.tree.ModuleTree.ModuleKind;
<span class="line-removed">  32 import com.sun.source.tree.Tree.Kind;</span>
  33 import com.sun.tools.javac.code.*;
  34 import com.sun.tools.javac.code.Attribute.UnresolvedClass;
  35 import com.sun.tools.javac.code.Symbol.*;
  36 import com.sun.tools.javac.code.Type.*;
  37 import com.sun.tools.javac.util.*;
  38 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  39 
  40 import com.sun.tools.javac.tree.JCTree.*;
  41 
  42 import static com.sun.tools.javac.code.Flags.*;
  43 import static com.sun.tools.javac.code.Kinds.Kind.*;
  44 import static com.sun.tools.javac.code.TypeTag.*;
  45 
  46 /** Factory class for trees.
  47  *
  48  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  49  *  If you write code that depends on this, you do so at your own risk.
  50  *  This code and its internal interfaces are subject to change or
  51  *  deletion without notice.&lt;/b&gt;
  52  */
</pre>
<hr />
<pre>
 257     }
 258 
 259     public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
 260         JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);
 261         tree.pos = pos;
 262         return tree;
 263     }
 264 
 265     public JCLabeledStatement Labelled(Name label, JCStatement body) {
 266         JCLabeledStatement tree = new JCLabeledStatement(label, body);
 267         tree.pos = pos;
 268         return tree;
 269     }
 270 
 271     public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases) {
 272         JCSwitch tree = new JCSwitch(selector, cases);
 273         tree.pos = pos;
 274         return tree;
 275     }
 276 
<span class="line-modified"> 277     public JCCase Case(@SuppressWarnings(&quot;removal&quot;) CaseKind caseKind, List&lt;JCExpression&gt; pats,</span>
 278                        List&lt;JCStatement&gt; stats, JCTree body) {
 279         JCCase tree = new JCCase(caseKind, pats, stats, body);
 280         tree.pos = pos;
 281         return tree;
 282     }
 283 
 284     public JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
 285         JCSwitchExpression tree = new JCSwitchExpression(selector, cases);
 286         tree.pos = pos;
 287         return tree;
 288     }
 289 
 290     public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {
 291         JCSynchronized tree = new JCSynchronized(lock, body);
 292         tree.pos = pos;
 293         return tree;
 294     }
 295 
 296     public JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer) {
 297         return Try(List.nil(), body, catchers, finalizer);
</pre>
<hr />
<pre>
 316                                    JCExpression thenpart,
 317                                    JCExpression elsepart)
 318     {
 319         JCConditional tree = new JCConditional(cond, thenpart, elsepart);
 320         tree.pos = pos;
 321         return tree;
 322     }
 323 
 324     public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {
 325         JCIf tree = new JCIf(cond, thenpart, elsepart);
 326         tree.pos = pos;
 327         return tree;
 328     }
 329 
 330     public JCExpressionStatement Exec(JCExpression expr) {
 331         JCExpressionStatement tree = new JCExpressionStatement(expr);
 332         tree.pos = pos;
 333         return tree;
 334     }
 335 
<span class="line-modified"> 336     public JCBreak Break(JCExpression label) {</span>
 337         JCBreak tree = new JCBreak(label, null);
 338         tree.pos = pos;
 339         return tree;
 340     }
 341 






 342     public JCContinue Continue(Name label) {
 343         JCContinue tree = new JCContinue(label, null);
 344         tree.pos = pos;
 345         return tree;
 346     }
 347 
 348     public JCReturn Return(JCExpression expr) {
 349         JCReturn tree = new JCReturn(expr);
 350         tree.pos = pos;
 351         return tree;
 352     }
 353 
 354     public JCThrow Throw(JCExpression expr) {
 355         JCThrow tree = new JCThrow(expr);
 356         tree.pos = pos;
 357         return tree;
 358     }
 359 
 360     public JCAssert Assert(JCExpression cond, JCExpression detail) {
 361         JCAssert tree = new JCAssert(cond, detail);
</pre>
<hr />
<pre>
 442     }
 443 
 444     public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs) {
 445         JCBinary tree = new JCBinary(opcode, lhs, rhs, null);
 446         tree.pos = pos;
 447         return tree;
 448     }
 449 
 450     public JCTypeCast TypeCast(JCTree clazz, JCExpression expr) {
 451         JCTypeCast tree = new JCTypeCast(clazz, expr);
 452         tree.pos = pos;
 453         return tree;
 454     }
 455 
 456     public JCInstanceOf TypeTest(JCExpression expr, JCTree clazz) {
 457         JCInstanceOf tree = new JCInstanceOf(expr, clazz);
 458         tree.pos = pos;
 459         return tree;
 460     }
 461 






 462     public JCArrayAccess Indexed(JCExpression indexed, JCExpression index) {
 463         JCArrayAccess tree = new JCArrayAccess(indexed, index);
 464         tree.pos = pos;
 465         return tree;
 466     }
 467 
 468     public JCFieldAccess Select(JCExpression selected, Name selector) {
 469         JCFieldAccess tree = new JCFieldAccess(selected, selector, null);
 470         tree.pos = pos;
 471         return tree;
 472     }
 473 
 474     public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name,
 475             JCExpression expr, List&lt;JCExpression&gt; typeargs) {
 476         JCMemberReference tree = new JCMemberReference(mode, name, expr, typeargs);
 477         tree.pos = pos;
 478         return tree;
 479     }
 480 
 481     public JCIdent Ident(Name name) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.util.Iterator;
  29 
<span class="line-modified">  30 import com.sun.source.tree.CaseTree;</span>
  31 import com.sun.source.tree.ModuleTree.ModuleKind;

  32 import com.sun.tools.javac.code.*;
  33 import com.sun.tools.javac.code.Attribute.UnresolvedClass;
  34 import com.sun.tools.javac.code.Symbol.*;
  35 import com.sun.tools.javac.code.Type.*;
  36 import com.sun.tools.javac.util.*;
  37 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  38 
  39 import com.sun.tools.javac.tree.JCTree.*;
  40 
  41 import static com.sun.tools.javac.code.Flags.*;
  42 import static com.sun.tools.javac.code.Kinds.Kind.*;
  43 import static com.sun.tools.javac.code.TypeTag.*;
  44 
  45 /** Factory class for trees.
  46  *
  47  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  48  *  If you write code that depends on this, you do so at your own risk.
  49  *  This code and its internal interfaces are subject to change or
  50  *  deletion without notice.&lt;/b&gt;
  51  */
</pre>
<hr />
<pre>
 256     }
 257 
 258     public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
 259         JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);
 260         tree.pos = pos;
 261         return tree;
 262     }
 263 
 264     public JCLabeledStatement Labelled(Name label, JCStatement body) {
 265         JCLabeledStatement tree = new JCLabeledStatement(label, body);
 266         tree.pos = pos;
 267         return tree;
 268     }
 269 
 270     public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases) {
 271         JCSwitch tree = new JCSwitch(selector, cases);
 272         tree.pos = pos;
 273         return tree;
 274     }
 275 
<span class="line-modified"> 276     public JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pats,</span>
 277                        List&lt;JCStatement&gt; stats, JCTree body) {
 278         JCCase tree = new JCCase(caseKind, pats, stats, body);
 279         tree.pos = pos;
 280         return tree;
 281     }
 282 
 283     public JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
 284         JCSwitchExpression tree = new JCSwitchExpression(selector, cases);
 285         tree.pos = pos;
 286         return tree;
 287     }
 288 
 289     public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {
 290         JCSynchronized tree = new JCSynchronized(lock, body);
 291         tree.pos = pos;
 292         return tree;
 293     }
 294 
 295     public JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer) {
 296         return Try(List.nil(), body, catchers, finalizer);
</pre>
<hr />
<pre>
 315                                    JCExpression thenpart,
 316                                    JCExpression elsepart)
 317     {
 318         JCConditional tree = new JCConditional(cond, thenpart, elsepart);
 319         tree.pos = pos;
 320         return tree;
 321     }
 322 
 323     public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {
 324         JCIf tree = new JCIf(cond, thenpart, elsepart);
 325         tree.pos = pos;
 326         return tree;
 327     }
 328 
 329     public JCExpressionStatement Exec(JCExpression expr) {
 330         JCExpressionStatement tree = new JCExpressionStatement(expr);
 331         tree.pos = pos;
 332         return tree;
 333     }
 334 
<span class="line-modified"> 335     public JCBreak Break(Name label) {</span>
 336         JCBreak tree = new JCBreak(label, null);
 337         tree.pos = pos;
 338         return tree;
 339     }
 340 
<span class="line-added"> 341     public JCYield Yield(JCExpression value) {</span>
<span class="line-added"> 342         JCYield tree = new JCYield(value, null);</span>
<span class="line-added"> 343         tree.pos = pos;</span>
<span class="line-added"> 344         return tree;</span>
<span class="line-added"> 345     }</span>
<span class="line-added"> 346 </span>
 347     public JCContinue Continue(Name label) {
 348         JCContinue tree = new JCContinue(label, null);
 349         tree.pos = pos;
 350         return tree;
 351     }
 352 
 353     public JCReturn Return(JCExpression expr) {
 354         JCReturn tree = new JCReturn(expr);
 355         tree.pos = pos;
 356         return tree;
 357     }
 358 
 359     public JCThrow Throw(JCExpression expr) {
 360         JCThrow tree = new JCThrow(expr);
 361         tree.pos = pos;
 362         return tree;
 363     }
 364 
 365     public JCAssert Assert(JCExpression cond, JCExpression detail) {
 366         JCAssert tree = new JCAssert(cond, detail);
</pre>
<hr />
<pre>
 447     }
 448 
 449     public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs) {
 450         JCBinary tree = new JCBinary(opcode, lhs, rhs, null);
 451         tree.pos = pos;
 452         return tree;
 453     }
 454 
 455     public JCTypeCast TypeCast(JCTree clazz, JCExpression expr) {
 456         JCTypeCast tree = new JCTypeCast(clazz, expr);
 457         tree.pos = pos;
 458         return tree;
 459     }
 460 
 461     public JCInstanceOf TypeTest(JCExpression expr, JCTree clazz) {
 462         JCInstanceOf tree = new JCInstanceOf(expr, clazz);
 463         tree.pos = pos;
 464         return tree;
 465     }
 466 
<span class="line-added"> 467     public JCBindingPattern BindingPattern(Name name, JCTree vartype) {</span>
<span class="line-added"> 468         JCBindingPattern tree = new JCBindingPattern(name, null, vartype);</span>
<span class="line-added"> 469         tree.pos = pos;</span>
<span class="line-added"> 470         return tree;</span>
<span class="line-added"> 471     }</span>
<span class="line-added"> 472 </span>
 473     public JCArrayAccess Indexed(JCExpression indexed, JCExpression index) {
 474         JCArrayAccess tree = new JCArrayAccess(indexed, index);
 475         tree.pos = pos;
 476         return tree;
 477     }
 478 
 479     public JCFieldAccess Select(JCExpression selected, Name selector) {
 480         JCFieldAccess tree = new JCFieldAccess(selected, selector, null);
 481         tree.pos = pos;
 482         return tree;
 483     }
 484 
 485     public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name,
 486             JCExpression expr, List&lt;JCExpression&gt; typeargs) {
 487         JCMemberReference tree = new JCMemberReference(mode, name, expr, typeargs);
 488         tree.pos = pos;
 489         return tree;
 490     }
 491 
 492     public JCIdent Ident(Name name) {
</pre>
</td>
</tr>
</table>
<center><a href="TreeInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeScanner.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
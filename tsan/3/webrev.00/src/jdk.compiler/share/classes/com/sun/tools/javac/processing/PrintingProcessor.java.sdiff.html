<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacRoundEnvironment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.processing;
 27 
 28 import javax.annotation.processing.*;
 29 import javax.lang.model.*;
 30 import javax.lang.model.element.*;
 31 import static javax.lang.model.element.ElementKind.*;
 32 import static javax.lang.model.element.NestingKind.*;
 33 import static javax.lang.model.element.ModuleElement.DirectiveKind.*;
 34 import static javax.lang.model.element.ModuleElement.*;
 35 import javax.lang.model.type.*;
 36 import javax.lang.model.util.*;
 37 
 38 import java.io.PrintWriter;
 39 import java.io.Writer;
 40 import java.util.*;
 41 import java.util.stream.Collectors;


 42 
 43 import com.sun.tools.javac.util.DefinedBy;
 44 import com.sun.tools.javac.util.DefinedBy.Api;
 45 import com.sun.tools.javac.util.StringUtils;
 46 
 47 /**
 48  * A processor which prints out elements.  Used to implement the
 49  * -Xprint option; the included visitor class is used to implement
 50  * Elements.printElements.
 51  *
 52  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 53  * If you write code that depends on this, you do so at your own risk.
 54  * This code and its internal interfaces are subject to change or
 55  * deletion without notice.&lt;/b&gt;
 56  */
 57 @SupportedAnnotationTypes(&quot;*&quot;)
<span class="line-modified"> 58 @SupportedSourceVersion(SourceVersion.RELEASE_13)</span>
 59 public class PrintingProcessor extends AbstractProcessor {
 60     PrintWriter writer;
 61 
 62     public PrintingProcessor() {
 63         super();
 64         writer = new PrintWriter(System.out);
 65     }
 66 
 67     public void setWriter(Writer w) {
 68         writer = new PrintWriter(w);
 69     }
 70 
 71     @Override @DefinedBy(Api.ANNOTATION_PROCESSING)
 72     public boolean process(Set&lt;? extends TypeElement&gt; tes,
 73                            RoundEnvironment renv) {
 74 
 75         for(Element element : renv.getRootElements()) {
 76             print(element);
 77         }
 78 
 79         // Just print the elements, nothing more to do.
 80         return true;
 81     }
 82 
 83     void print(Element element) {
 84         new PrintingElementVisitor(writer, processingEnv.getElementUtils()).
 85             visit(element).flush();
 86     }
 87 
 88     /**
 89      * Used for the -Xprint option and called by Elements.printElements
 90      */

 91     public static class PrintingElementVisitor
<span class="line-modified"> 92         extends SimpleElementVisitor9&lt;PrintingElementVisitor, Boolean&gt; {</span>
 93         int indentation; // Indentation level;
 94         final PrintWriter writer;
 95         final Elements elementUtils;
 96 
 97         public PrintingElementVisitor(Writer w, Elements elementUtils) {
 98             super();
 99             this.writer = new PrintWriter(w);
100             this.elementUtils = elementUtils;
101             indentation = 0;
102         }
103 
104         @Override @DefinedBy(Api.LANGUAGE_MODEL)
105         protected PrintingElementVisitor defaultAction(Element e, Boolean newLine) {
106             if (newLine != null &amp;&amp; newLine)
107                 writer.println();
108             printDocComment(e);
109             printModifiers(e);
110             return this;
111         }
112 







113         @Override @DefinedBy(Api.LANGUAGE_MODEL)
114         public PrintingElementVisitor visitExecutable(ExecutableElement e, Boolean p) {
115             ElementKind kind = e.getKind();
116 
117             if (kind != STATIC_INIT &amp;&amp;
118                 kind != INSTANCE_INIT) {
119                 Element enclosing = e.getEnclosingElement();
120 
121                 // Don&#39;t print out the constructor of an anonymous class
122                 if (kind == CONSTRUCTOR &amp;&amp;
123                     enclosing != null &amp;&amp;
124                     NestingKind.ANONYMOUS ==
125                     // Use an anonymous class to determine anonymity!
<span class="line-modified">126                     (new SimpleElementVisitor9&lt;NestingKind, Void&gt;() {</span>
127                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
128                         public NestingKind visitType(TypeElement e, Void p) {
129                             return e.getNestingKind();
130                         }
131                     }).visit(enclosing))
132                     return this;
133 
134                 defaultAction(e, true);
135                 printFormalTypeParameters(e, true);
136 
137                 switch(kind) {
138                     case CONSTRUCTOR:
139                     // Print out simple name of the class
140                     writer.print(e.getEnclosingElement().getSimpleName());
141                     break;
142 
143                     case METHOD:
144                     writer.print(e.getReturnType().toString());
145                     writer.print(&quot; &quot;);
146                     writer.print(e.getSimpleName().toString());
</pre>
<hr />
<pre>
199                 if (nestingKind == TOP_LEVEL) {
200                     PackageElement pkg = elementUtils.getPackageOf(e);
201                     if (!pkg.isUnnamed())
202                         writer.print(&quot;package &quot; + pkg.getQualifiedName() + &quot;;\n&quot;);
203                 }
204 
205                 defaultAction(e, true);
206 
207                 switch(kind) {
208                 case ANNOTATION_TYPE:
209                     writer.print(&quot;@interface&quot;);
210                     break;
211                 default:
212                     writer.print(StringUtils.toLowerCase(kind.toString()));
213                 }
214                 writer.print(&quot; &quot;);
215                 writer.print(e.getSimpleName());
216 
217                 printFormalTypeParameters(e, false);
218 










219                 // Print superclass information if informative
220                 if (kind == CLASS) {
221                     TypeMirror supertype = e.getSuperclass();
222                     if (supertype.getKind() != TypeKind.NONE) {
223                         TypeElement e2 = (TypeElement)
224                             ((DeclaredType) supertype).asElement();
225                         if (e2.getSuperclass().getKind() != TypeKind.NONE)
226                             writer.print(&quot; extends &quot; + supertype);
227                     }
228                 }
229 
230                 printInterfaces(e);
231             }
232             writer.println(&quot; {&quot;);
233             indentation++;
234 
235             if (kind == ENUM) {
236                 List&lt;Element&gt; enclosedElements = new ArrayList&lt;&gt;(e.getEnclosedElements());
237                 // Handle any enum constants specially before other entities.
238                 List&lt;Element&gt; enumConstants = new ArrayList&lt;&gt;();
239                 for(Element element : enclosedElements) {
240                     if (element.getKind() == ENUM_CONSTANT)
241                         enumConstants.add(element);
242                 }
243                 if (!enumConstants.isEmpty()) {
244                     int i;
245                     for(i = 0; i &lt; enumConstants.size()-1; i++) {
246                         this.visit(enumConstants.get(i), true);
247                         writer.print(&quot;,&quot;);
248                     }
249                     this.visit(enumConstants.get(i), true);
250                     writer.println(&quot;;\n&quot;);
251 
252                     enclosedElements.removeAll(enumConstants);
253                 }
254 
255                 for(Element element : enclosedElements)
256                     this.visit(element);
257             } else {
<span class="line-modified">258                 for(Element element : e.getEnclosedElements())</span>






259                     this.visit(element);
260             }
261 
262             indentation--;
263             indent();
264             writer.println(&quot;}&quot;);
265             return this;
266         }
267 
268         @Override @DefinedBy(Api.LANGUAGE_MODEL)
269         public PrintingElementVisitor visitVariable(VariableElement e, Boolean newLine) {
270             ElementKind kind = e.getKind();
271             defaultAction(e, newLine);
272 
273             if (kind == ENUM_CONSTANT)
274                 writer.print(e.getSimpleName());
275             else {
276                 writer.print(e.asType().toString() + &quot; &quot; + e.getSimpleName() );
277                 Object constantValue  = e.getConstantValue();
278                 if (constantValue != null) {
</pre>
<hr />
<pre>
407                 // Break comment into lines
408                 java.util.StringTokenizer st = new StringTokenizer(docComment,
409                                                                   &quot;\n\r&quot;);
410                 indent();
411                 writer.println(&quot;/**&quot;);
412 
413                 while(st.hasMoreTokens()) {
414                     indent();
415                     writer.print(&quot; *&quot;);
416                     writer.println(st.nextToken());
417                 }
418 
419                 indent();
420                 writer.println(&quot; */&quot;);
421             }
422         }
423 
424         private void printModifiers(Element e) {
425             ElementKind kind = e.getKind();
426             if (kind == PARAMETER) {
<span class="line-modified">427                 printAnnotationsInline(e);</span>

428             } else {
429                 printAnnotations(e);
430                 indent();
431             }
432 
433             if (kind == ENUM_CONSTANT)
434                 return;
435 
436             Set&lt;Modifier&gt; modifiers = new LinkedHashSet&lt;&gt;();
437             modifiers.addAll(e.getModifiers());
438 
439             switch (kind) {
440             case ANNOTATION_TYPE:
441             case INTERFACE:
442                 modifiers.remove(Modifier.ABSTRACT);
443                 break;
444 
445             case ENUM:
446                 modifiers.remove(Modifier.FINAL);
447                 modifiers.remove(Modifier.ABSTRACT);
448                 break;
449 




450             case METHOD:
451             case FIELD:
452                 Element enclosingElement = e.getEnclosingElement();
453                 if (enclosingElement != null &amp;&amp;
454                     enclosingElement.getKind().isInterface()) {
455                     modifiers.remove(Modifier.PUBLIC);
456                     modifiers.remove(Modifier.ABSTRACT); // only for methods
457                     modifiers.remove(Modifier.STATIC);   // only for fields
458                     modifiers.remove(Modifier.FINAL);    // only for fields
459                 }
460                 break;
461 
462             }
<span class="line-modified">463 </span>
<span class="line-modified">464             for(Modifier m: modifiers) {</span>
<span class="line-modified">465                 writer.print(m.toString() + &quot; &quot;);</span>

466             }
467         }
468 
469         private void printFormalTypeParameters(Parameterizable e,
470                                                boolean pad) {
471             List&lt;? extends TypeParameterElement&gt; typeParams = e.getTypeParameters();
<span class="line-modified">472             if (typeParams.size() &gt; 0) {</span>
<span class="line-modified">473                 writer.print(&quot;&lt;&quot;);</span>
<span class="line-modified">474 </span>
<span class="line-modified">475                 boolean first = true;</span>
<span class="line-removed">476                 for(TypeParameterElement tpe: typeParams) {</span>
<span class="line-removed">477                     if (!first)</span>
<span class="line-removed">478                         writer.print(&quot;, &quot;);</span>
<span class="line-removed">479                     printAnnotationsInline(tpe);</span>
<span class="line-removed">480                     writer.print(tpe.toString());</span>
<span class="line-removed">481                     first = false;</span>
<span class="line-removed">482                 }</span>
<span class="line-removed">483 </span>
<span class="line-removed">484                 writer.print(&quot;&gt;&quot;);</span>
485                 if (pad)
486                     writer.print(&quot; &quot;);
487             }
488         }
489 
<span class="line-modified">490         private void printAnnotationsInline(Element e) {</span>
<span class="line-modified">491             List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();</span>
<span class="line-modified">492             for(AnnotationMirror annotationMirror : annots) {</span>
<span class="line-modified">493                 writer.print(annotationMirror);</span>
<span class="line-modified">494                 writer.print(&quot; &quot;);</span>
<span class="line-modified">495             }</span>

496         }
497 
498         private void printAnnotations(Element e) {
499             List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();
500             for(AnnotationMirror annotationMirror : annots) {
501                 indent();
502                 writer.println(annotationMirror);
503             }
504         }
505 
506         // TODO: Refactor
507         private void printParameters(ExecutableElement e) {
508             List&lt;? extends VariableElement&gt; parameters = e.getParameters();
509             int size = parameters.size();
510 
511             switch (size) {
512             case 0:
513                 break;
514 
515             case 1:
</pre>
<hr />
<pre>
552                         writer.print(&quot; &quot; + parameter.getSimpleName());
553 
554                         if (i &lt; size)
555                             writer.println(&quot;,&quot;);
556 
557                         i++;
558                     }
559 
560                     if (parameters.size() &gt;= 2)
561                         indentation--;
562                 }
563                 break;
564             }
565         }
566 
567         private void printInterfaces(TypeElement e) {
568             ElementKind kind = e.getKind();
569 
570             if(kind != ANNOTATION_TYPE) {
571                 List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
<span class="line-modified">572                 if (interfaces.size() &gt; 0) {</span>
<span class="line-modified">573                     writer.print((kind.isClass() ? &quot; implements&quot; : &quot; extends&quot;));</span>
<span class="line-modified">574 </span>
<span class="line-modified">575                     boolean first = true;</span>
<span class="line-modified">576                     for(TypeMirror interf: interfaces) {</span>
<span class="line-removed">577                         if (!first)</span>
<span class="line-removed">578                             writer.print(&quot;,&quot;);</span>
<span class="line-removed">579                         writer.print(&quot; &quot;);</span>
<span class="line-removed">580                         writer.print(interf.toString());</span>
<span class="line-removed">581                         first = false;</span>
<span class="line-removed">582                     }</span>
583                 }
584             }
585         }
586 
587         private void printThrows(ExecutableElement e) {
588             List&lt;? extends TypeMirror&gt; thrownTypes = e.getThrownTypes();
589             final int size = thrownTypes.size();
590             if (size != 0) {
591                 writer.print(&quot; throws&quot;);
592 
593                 int i = 1;
594                 for(TypeMirror thrownType: thrownTypes) {
595                     if (i == 1)
596                         writer.print(&quot; &quot;);
597 
598                     if (i == 2)
599                         indentation++;
600 
601                     if (i &gt;= 2)
602                         indent();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.processing;
 27 
 28 import javax.annotation.processing.*;
 29 import javax.lang.model.*;
 30 import javax.lang.model.element.*;
 31 import static javax.lang.model.element.ElementKind.*;
 32 import static javax.lang.model.element.NestingKind.*;
 33 import static javax.lang.model.element.ModuleElement.DirectiveKind.*;
 34 import static javax.lang.model.element.ModuleElement.*;
 35 import javax.lang.model.type.*;
 36 import javax.lang.model.util.*;
 37 
 38 import java.io.PrintWriter;
 39 import java.io.Writer;
 40 import java.util.*;
 41 import java.util.stream.Collectors;
<span class="line-added"> 42 import java.util.stream.Stream;</span>
<span class="line-added"> 43 </span>
 44 
 45 import com.sun.tools.javac.util.DefinedBy;
 46 import com.sun.tools.javac.util.DefinedBy.Api;
 47 import com.sun.tools.javac.util.StringUtils;
 48 
 49 /**
 50  * A processor which prints out elements.  Used to implement the
 51  * -Xprint option; the included visitor class is used to implement
 52  * Elements.printElements.
 53  *
 54  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 55  * If you write code that depends on this, you do so at your own risk.
 56  * This code and its internal interfaces are subject to change or
 57  * deletion without notice.&lt;/b&gt;
 58  */
 59 @SupportedAnnotationTypes(&quot;*&quot;)
<span class="line-modified"> 60 @SupportedSourceVersion(SourceVersion.RELEASE_15)</span>
 61 public class PrintingProcessor extends AbstractProcessor {
 62     PrintWriter writer;
 63 
 64     public PrintingProcessor() {
 65         super();
 66         writer = new PrintWriter(System.out);
 67     }
 68 
 69     public void setWriter(Writer w) {
 70         writer = new PrintWriter(w);
 71     }
 72 
 73     @Override @DefinedBy(Api.ANNOTATION_PROCESSING)
 74     public boolean process(Set&lt;? extends TypeElement&gt; tes,
 75                            RoundEnvironment renv) {
 76 
 77         for(Element element : renv.getRootElements()) {
 78             print(element);
 79         }
 80 
 81         // Just print the elements, nothing more to do.
 82         return true;
 83     }
 84 
 85     void print(Element element) {
 86         new PrintingElementVisitor(writer, processingEnv.getElementUtils()).
 87             visit(element).flush();
 88     }
 89 
 90     /**
 91      * Used for the -Xprint option and called by Elements.printElements
 92      */
<span class="line-added"> 93     @SuppressWarnings(&quot;preview&quot;)</span>
 94     public static class PrintingElementVisitor
<span class="line-modified"> 95         extends SimpleElementVisitor14&lt;PrintingElementVisitor, Boolean&gt; {</span>
 96         int indentation; // Indentation level;
 97         final PrintWriter writer;
 98         final Elements elementUtils;
 99 
100         public PrintingElementVisitor(Writer w, Elements elementUtils) {
101             super();
102             this.writer = new PrintWriter(w);
103             this.elementUtils = elementUtils;
104             indentation = 0;
105         }
106 
107         @Override @DefinedBy(Api.LANGUAGE_MODEL)
108         protected PrintingElementVisitor defaultAction(Element e, Boolean newLine) {
109             if (newLine != null &amp;&amp; newLine)
110                 writer.println();
111             printDocComment(e);
112             printModifiers(e);
113             return this;
114         }
115 
<span class="line-added">116         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-added">117         public PrintingElementVisitor visitRecordComponent(RecordComponentElement e, Boolean p) {</span>
<span class="line-added">118                 // Do nothing; printing of component information done by</span>
<span class="line-added">119                 // printing the record type itself</span>
<span class="line-added">120             return this;</span>
<span class="line-added">121         }</span>
<span class="line-added">122 </span>
123         @Override @DefinedBy(Api.LANGUAGE_MODEL)
124         public PrintingElementVisitor visitExecutable(ExecutableElement e, Boolean p) {
125             ElementKind kind = e.getKind();
126 
127             if (kind != STATIC_INIT &amp;&amp;
128                 kind != INSTANCE_INIT) {
129                 Element enclosing = e.getEnclosingElement();
130 
131                 // Don&#39;t print out the constructor of an anonymous class
132                 if (kind == CONSTRUCTOR &amp;&amp;
133                     enclosing != null &amp;&amp;
134                     NestingKind.ANONYMOUS ==
135                     // Use an anonymous class to determine anonymity!
<span class="line-modified">136                     (new SimpleElementVisitor14&lt;NestingKind, Void&gt;() {</span>
137                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
138                         public NestingKind visitType(TypeElement e, Void p) {
139                             return e.getNestingKind();
140                         }
141                     }).visit(enclosing))
142                     return this;
143 
144                 defaultAction(e, true);
145                 printFormalTypeParameters(e, true);
146 
147                 switch(kind) {
148                     case CONSTRUCTOR:
149                     // Print out simple name of the class
150                     writer.print(e.getEnclosingElement().getSimpleName());
151                     break;
152 
153                     case METHOD:
154                     writer.print(e.getReturnType().toString());
155                     writer.print(&quot; &quot;);
156                     writer.print(e.getSimpleName().toString());
</pre>
<hr />
<pre>
209                 if (nestingKind == TOP_LEVEL) {
210                     PackageElement pkg = elementUtils.getPackageOf(e);
211                     if (!pkg.isUnnamed())
212                         writer.print(&quot;package &quot; + pkg.getQualifiedName() + &quot;;\n&quot;);
213                 }
214 
215                 defaultAction(e, true);
216 
217                 switch(kind) {
218                 case ANNOTATION_TYPE:
219                     writer.print(&quot;@interface&quot;);
220                     break;
221                 default:
222                     writer.print(StringUtils.toLowerCase(kind.toString()));
223                 }
224                 writer.print(&quot; &quot;);
225                 writer.print(e.getSimpleName());
226 
227                 printFormalTypeParameters(e, false);
228 
<span class="line-added">229                 if (kind == RECORD) {</span>
<span class="line-added">230                     // Print out record components</span>
<span class="line-added">231                     writer.print(&quot;(&quot;);</span>
<span class="line-added">232                     writer.print(e.getRecordComponents()</span>
<span class="line-added">233                                  .stream()</span>
<span class="line-added">234                                  .map(recordDes -&gt; recordDes.asType().toString() + &quot; &quot; + recordDes.getSimpleName())</span>
<span class="line-added">235                                  .collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="line-added">236                     writer.print(&quot;)&quot;);</span>
<span class="line-added">237                 }</span>
<span class="line-added">238 </span>
239                 // Print superclass information if informative
240                 if (kind == CLASS) {
241                     TypeMirror supertype = e.getSuperclass();
242                     if (supertype.getKind() != TypeKind.NONE) {
243                         TypeElement e2 = (TypeElement)
244                             ((DeclaredType) supertype).asElement();
245                         if (e2.getSuperclass().getKind() != TypeKind.NONE)
246                             writer.print(&quot; extends &quot; + supertype);
247                     }
248                 }
249 
250                 printInterfaces(e);
251             }
252             writer.println(&quot; {&quot;);
253             indentation++;
254 
255             if (kind == ENUM) {
256                 List&lt;Element&gt; enclosedElements = new ArrayList&lt;&gt;(e.getEnclosedElements());
257                 // Handle any enum constants specially before other entities.
258                 List&lt;Element&gt; enumConstants = new ArrayList&lt;&gt;();
259                 for(Element element : enclosedElements) {
260                     if (element.getKind() == ENUM_CONSTANT)
261                         enumConstants.add(element);
262                 }
263                 if (!enumConstants.isEmpty()) {
264                     int i;
265                     for(i = 0; i &lt; enumConstants.size()-1; i++) {
266                         this.visit(enumConstants.get(i), true);
267                         writer.print(&quot;,&quot;);
268                     }
269                     this.visit(enumConstants.get(i), true);
270                     writer.println(&quot;;\n&quot;);
271 
272                     enclosedElements.removeAll(enumConstants);
273                 }
274 
275                 for(Element element : enclosedElements)
276                     this.visit(element);
277             } else {
<span class="line-modified">278                 for(Element element :</span>
<span class="line-added">279                         (kind != RECORD ?</span>
<span class="line-added">280                          e.getEnclosedElements() :</span>
<span class="line-added">281                          e.getEnclosedElements()</span>
<span class="line-added">282                          .stream()</span>
<span class="line-added">283                          .filter(elt -&gt; elementUtils.getOrigin(elt) == Elements.Origin.EXPLICIT )</span>
<span class="line-added">284                          .collect(Collectors.toList()) ) )</span>
285                     this.visit(element);
286             }
287 
288             indentation--;
289             indent();
290             writer.println(&quot;}&quot;);
291             return this;
292         }
293 
294         @Override @DefinedBy(Api.LANGUAGE_MODEL)
295         public PrintingElementVisitor visitVariable(VariableElement e, Boolean newLine) {
296             ElementKind kind = e.getKind();
297             defaultAction(e, newLine);
298 
299             if (kind == ENUM_CONSTANT)
300                 writer.print(e.getSimpleName());
301             else {
302                 writer.print(e.asType().toString() + &quot; &quot; + e.getSimpleName() );
303                 Object constantValue  = e.getConstantValue();
304                 if (constantValue != null) {
</pre>
<hr />
<pre>
433                 // Break comment into lines
434                 java.util.StringTokenizer st = new StringTokenizer(docComment,
435                                                                   &quot;\n\r&quot;);
436                 indent();
437                 writer.println(&quot;/**&quot;);
438 
439                 while(st.hasMoreTokens()) {
440                     indent();
441                     writer.print(&quot; *&quot;);
442                     writer.println(st.nextToken());
443                 }
444 
445                 indent();
446                 writer.println(&quot; */&quot;);
447             }
448         }
449 
450         private void printModifiers(Element e) {
451             ElementKind kind = e.getKind();
452             if (kind == PARAMETER) {
<span class="line-modified">453                 // Print annotation inline</span>
<span class="line-added">454                 writer.print(annotationsToString(e));</span>
455             } else {
456                 printAnnotations(e);
457                 indent();
458             }
459 
460             if (kind == ENUM_CONSTANT)
461                 return;
462 
463             Set&lt;Modifier&gt; modifiers = new LinkedHashSet&lt;&gt;();
464             modifiers.addAll(e.getModifiers());
465 
466             switch (kind) {
467             case ANNOTATION_TYPE:
468             case INTERFACE:
469                 modifiers.remove(Modifier.ABSTRACT);
470                 break;
471 
472             case ENUM:
473                 modifiers.remove(Modifier.FINAL);
474                 modifiers.remove(Modifier.ABSTRACT);
475                 break;
476 
<span class="line-added">477             case RECORD:</span>
<span class="line-added">478                 modifiers.remove(Modifier.FINAL);</span>
<span class="line-added">479                 break;</span>
<span class="line-added">480 </span>
481             case METHOD:
482             case FIELD:
483                 Element enclosingElement = e.getEnclosingElement();
484                 if (enclosingElement != null &amp;&amp;
485                     enclosingElement.getKind().isInterface()) {
486                     modifiers.remove(Modifier.PUBLIC);
487                     modifiers.remove(Modifier.ABSTRACT); // only for methods
488                     modifiers.remove(Modifier.STATIC);   // only for fields
489                     modifiers.remove(Modifier.FINAL);    // only for fields
490                 }
491                 break;
492 
493             }
<span class="line-modified">494             if (!modifiers.isEmpty()) {</span>
<span class="line-modified">495                 writer.print(modifiers.stream()</span>
<span class="line-modified">496                              .map(Modifier::toString)</span>
<span class="line-added">497                              .collect(Collectors.joining(&quot; &quot;, &quot;&quot;, &quot; &quot;)));</span>
498             }
499         }
500 
501         private void printFormalTypeParameters(Parameterizable e,
502                                                boolean pad) {
503             List&lt;? extends TypeParameterElement&gt; typeParams = e.getTypeParameters();
<span class="line-modified">504             if (!typeParams.isEmpty()) {</span>
<span class="line-modified">505                 writer.print(typeParams.stream()</span>
<span class="line-modified">506                              .map(tpe -&gt; annotationsToString(tpe) + tpe.toString())</span>
<span class="line-modified">507                              .collect(Collectors.joining(&quot;, &quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));</span>









508                 if (pad)
509                     writer.print(&quot; &quot;);
510             }
511         }
512 
<span class="line-modified">513         private String annotationsToString(Element e) {</span>
<span class="line-modified">514             List&lt;? extends AnnotationMirror&gt; annotations = e.getAnnotationMirrors();</span>
<span class="line-modified">515             return annotations.isEmpty() ?</span>
<span class="line-modified">516                 &quot;&quot; :</span>
<span class="line-modified">517                 annotations.stream()</span>
<span class="line-modified">518                 .map(AnnotationMirror::toString)</span>
<span class="line-added">519                 .collect(Collectors.joining(&quot; &quot;, &quot;&quot;, &quot; &quot;));</span>
520         }
521 
522         private void printAnnotations(Element e) {
523             List&lt;? extends AnnotationMirror&gt; annots = e.getAnnotationMirrors();
524             for(AnnotationMirror annotationMirror : annots) {
525                 indent();
526                 writer.println(annotationMirror);
527             }
528         }
529 
530         // TODO: Refactor
531         private void printParameters(ExecutableElement e) {
532             List&lt;? extends VariableElement&gt; parameters = e.getParameters();
533             int size = parameters.size();
534 
535             switch (size) {
536             case 0:
537                 break;
538 
539             case 1:
</pre>
<hr />
<pre>
576                         writer.print(&quot; &quot; + parameter.getSimpleName());
577 
578                         if (i &lt; size)
579                             writer.println(&quot;,&quot;);
580 
581                         i++;
582                     }
583 
584                     if (parameters.size() &gt;= 2)
585                         indentation--;
586                 }
587                 break;
588             }
589         }
590 
591         private void printInterfaces(TypeElement e) {
592             ElementKind kind = e.getKind();
593 
594             if(kind != ANNOTATION_TYPE) {
595                 List&lt;? extends TypeMirror&gt; interfaces = e.getInterfaces();
<span class="line-modified">596                 if (!interfaces.isEmpty()) {</span>
<span class="line-modified">597                     writer.print((kind.isClass() ? &quot; implements &quot; : &quot; extends &quot;));</span>
<span class="line-modified">598                     writer.print(interfaces.stream()</span>
<span class="line-modified">599                                  .map(TypeMirror::toString)</span>
<span class="line-modified">600                                  .collect(Collectors.joining(&quot;, &quot;)));</span>






601                 }
602             }
603         }
604 
605         private void printThrows(ExecutableElement e) {
606             List&lt;? extends TypeMirror&gt; thrownTypes = e.getThrownTypes();
607             final int size = thrownTypes.size();
608             if (size != 0) {
609                 writer.print(&quot; throws&quot;);
610 
611                 int i = 1;
612                 for(TypeMirror thrownType: thrownTypes) {
613                     if (i == 1)
614                         writer.print(&quot; &quot;);
615 
616                     if (i == 2)
617                         indentation++;
618 
619                     if (i &gt;= 2)
620                         indent();
</pre>
</td>
</tr>
</table>
<center><a href="JavacRoundEnvironment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../resources/compiler.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
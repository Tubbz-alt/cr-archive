<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacRoundEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.processing;
 27 
 28 import java.lang.annotation.Annotation;
 29 import javax.annotation.processing.*;
 30 import javax.lang.model.element.*;
 31 import javax.lang.model.util.*;
 32 import java.util.*;
 33 
 34 import com.sun.tools.javac.code.Source.Feature;
 35 import com.sun.tools.javac.util.DefinedBy;
 36 import com.sun.tools.javac.util.DefinedBy.Api;
 37 
 38 /**
 39  * Object providing state about a prior round of annotation processing.
 40  *
 41  * &lt;p&gt;The methods in this class do not take type annotations into account,
 42  * as target types, not java elements.
 43  *
 44  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 45  * If you write code that depends on this, you do so at your own risk.
 46  * This code and its internal interfaces are subject to change or
 47  * deletion without notice.&lt;/b&gt;
 48  */
 49 public class JavacRoundEnvironment implements RoundEnvironment {
 50     // Default equals and hashCode methods are okay.
 51 
 52     private final boolean processingOver;
 53     private final boolean errorRaised;
 54     private final ProcessingEnvironment processingEnv;
 55     private final Elements eltUtils;
 56 
 57     private final boolean allowModules;
 58 
 59     // Caller must pass in an immutable set
 60     private final Set&lt;? extends Element&gt; rootElements;
 61 
 62     JavacRoundEnvironment(boolean processingOver,
 63                           boolean errorRaised,
 64                           Set&lt;? extends Element&gt; rootElements,
 65                           JavacProcessingEnvironment processingEnv) {
 66         this.processingOver = processingOver;
 67         this.errorRaised = errorRaised;
 68         this.rootElements = rootElements;
 69         this.processingEnv = processingEnv;
 70         this.allowModules = Feature.MODULES.allowedInSource(processingEnv.source);
 71         this.eltUtils = processingEnv.getElementUtils();
 72     }
 73 
 74     public String toString() {
 75         return String.format(&quot;[errorRaised=%b, rootElements=%s, processingOver=%b]&quot;,
 76                              errorRaised,
 77                              rootElements,
 78                              processingOver);
 79     }
 80 
 81     @DefinedBy(Api.ANNOTATION_PROCESSING)
 82     public boolean processingOver() {
 83         return processingOver;
 84     }
 85 
 86     /**
 87      * Returns {@code true} if an error was raised in the prior round
 88      * of processing; returns {@code false} otherwise.
 89      *
 90      * @return {@code true} if an error was raised in the prior round
 91      * of processing; returns {@code false} otherwise.
 92      */
 93     @DefinedBy(Api.ANNOTATION_PROCESSING)
 94     public boolean errorRaised() {
 95         return errorRaised;
 96     }
 97 
 98     /**
 99      * Returns the type elements specified by the prior round.
100      *
101      * @return the types elements specified by the prior round, or an
102      * empty set if there were none
103      */
104     @DefinedBy(Api.ANNOTATION_PROCESSING)
105     public Set&lt;? extends Element&gt; getRootElements() {
106         return rootElements;
107     }
108 
109     /**
110      * Returns the elements annotated with the given annotation type.
111      * Only type elements &lt;i&gt;included&lt;/i&gt; in this round of annotation
112      * processing, or declarations of members, parameters, or type
113      * parameters declared within those, are returned.  Included type
114      * elements are {@linkplain #getRootElements specified
115      * types} and any types nested within them.
116      *
117      * @param a  annotation type being requested
118      * @return the elements annotated with the given annotation type,
119      * or an empty set if there are none
120      */
121     @DefinedBy(Api.ANNOTATION_PROCESSING)
122     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a) {
123         throwIfNotAnnotation(a);
124 
125         Set&lt;Element&gt; result = Collections.emptySet();
126         ElementScanner9&lt;Set&lt;Element&gt;, TypeElement&gt; scanner =
127             new AnnotationSetScanner(result);
128 
129         for (Element element : rootElements)
130             result = scanner.scan(element, a);
131 
132         return result;
133     }
134 
135     @DefinedBy(Api.ANNOTATION_PROCESSING)
136     public Set&lt;? extends Element&gt; getElementsAnnotatedWithAny(TypeElement... annotations) {
137         // Don&#39;t bother to special-case annotations.length == 1 as
138         // return getElementsAnnotatedWith(annotations[0]);
139 
140         Set&lt;TypeElement&gt; annotationSet = new LinkedHashSet&lt;&gt;(annotations.length);
141         for (TypeElement annotation : annotations) {
142             throwIfNotAnnotation(annotation);
143             annotationSet.add(annotation);
144         }
145 
146         Set&lt;Element&gt; result = Collections.emptySet();
147         ElementScanner9&lt;Set&lt;Element&gt;, Set&lt;TypeElement&gt;&gt; scanner =
148             new AnnotationSetMultiScanner(result);
149 
150         for (Element element : rootElements)
151             result = scanner.scan(element, annotationSet);
152 
153         return result;
154     }
155 
156     // Could be written as a local class inside getElementsAnnotatedWith
157     private class AnnotationSetScanner extends
158         ElementScanningIncludingTypeParameters&lt;Set&lt;Element&gt;, TypeElement&gt; {
159         // Insertion-order preserving set
160         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
161 
162         AnnotationSetScanner(Set&lt;Element&gt; defaultSet) {
163             super(defaultSet);
164         }
165 
166         @Override @DefinedBy(Api.LANGUAGE_MODEL)
167         public Set&lt;Element&gt; scan(Element e, TypeElement annotation) {
168             for (AnnotationMirror annotMirror :  eltUtils.getAllAnnotationMirrors(e)) {
169                 if (annotation.equals(mirrorAsElement(annotMirror))) {
170                     annotatedElements.add(e);
171                     break;
172                 }
173             }
174             e.accept(this, annotation);
175             return annotatedElements;
176         }
177 
178         @Override @DefinedBy(Api.LANGUAGE_MODEL)
179         public Set&lt;Element&gt; visitModule(ModuleElement e, TypeElement annotation) {
180             // Do not scan a module
181             return annotatedElements;
182         }
183 
184         @Override @DefinedBy(Api.LANGUAGE_MODEL)
185         public Set&lt;Element&gt; visitPackage(PackageElement e, TypeElement annotation) {
186             // Do not scan a package
187             return annotatedElements;
188         }
189     }
190 
191     // Could be written as a local class inside getElementsAnnotatedWithAny
192     private class AnnotationSetMultiScanner extends
193         ElementScanningIncludingTypeParameters&lt;Set&lt;Element&gt;, Set&lt;TypeElement&gt;&gt; {
194         // Insertion-order preserving set
195         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
196 
197         AnnotationSetMultiScanner(Set&lt;Element&gt; defaultSet) {
198             super(defaultSet);
199         }
200 
201         @Override @DefinedBy(Api.LANGUAGE_MODEL)
202         public Set&lt;Element&gt; scan(Element e, Set&lt;TypeElement&gt; annotations) {
203             for (AnnotationMirror annotMirror : eltUtils.getAllAnnotationMirrors(e)) {
204                 if (annotations.contains(mirrorAsElement(annotMirror))) {
205                     annotatedElements.add(e);
206                     break;
207                 }
208             }
209             e.accept(this, annotations);
210             return annotatedElements;
211         }
212 
213         @Override @DefinedBy(Api.LANGUAGE_MODEL)
214         public Set&lt;Element&gt; visitModule(ModuleElement e, Set&lt;TypeElement&gt; annotations) {
215             // Do not scan a module
216             return annotatedElements;
217         }
218 
219         @Override @DefinedBy(Api.LANGUAGE_MODEL)
220         public Set&lt;Element&gt; visitPackage(PackageElement e, Set&lt;TypeElement&gt; annotations) {
221             // Do not scan a package
222             return annotatedElements;
223         }
224     }
225 
226     private static abstract class ElementScanningIncludingTypeParameters&lt;R, P&gt;
227         extends ElementScanner9&lt;R, P&gt; {
228 
229         protected ElementScanningIncludingTypeParameters(R defaultValue) {
230             super(defaultValue);
231         }
232 
233         @Override @DefinedBy(Api.LANGUAGE_MODEL)
234         public R visitType(TypeElement e, P p) {
235             // Type parameters are not considered to be enclosed by a type
236             scan(e.getTypeParameters(), p);
237             return super.visitType(e, p);
238         }
239 
240         @Override @DefinedBy(Api.LANGUAGE_MODEL)
241         public R visitExecutable(ExecutableElement e, P p) {
242             // Type parameters are not considered to be enclosed by an executable
243             scan(e.getTypeParameters(), p);
244             return super.visitExecutable(e, p);
245         }
246     }
247 
248     /**
249      * {@inheritDoc}
250      */
251     @DefinedBy(Api.ANNOTATION_PROCESSING)
252     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a) {
253         throwIfNotAnnotation(a);
254         String name = a.getCanonicalName();
255 
256         if (name == null)
257             return Collections.emptySet();
258         else {
259             TypeElement annotationType = annotationToElement(a);
260 
261             if (annotationType == null)
262                 return Collections.emptySet();
263             else
264                 return getElementsAnnotatedWith(annotationType);
265         }
266     }
267 
268     @DefinedBy(Api.ANNOTATION_PROCESSING)
269     public Set&lt;? extends Element&gt; getElementsAnnotatedWithAny(Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations) {
270         List&lt;TypeElement&gt; annotationsAsElements = new ArrayList&lt;&gt;(annotations.size());
271 
272         for (Class&lt;? extends Annotation&gt; annotation : annotations) {
273             throwIfNotAnnotation(annotation);
274             String name = annotation.getCanonicalName();
275             if (name == null)
276                 continue;
277             annotationsAsElements.add(annotationToElement(annotation));
278         }
279 
280         return getElementsAnnotatedWithAny(annotationsAsElements.toArray(new TypeElement[0]));
281     }
282 
283     private TypeElement annotationToElement(Class&lt;? extends Annotation&gt; annotation) {
284         // First, try an element lookup based on the annotation&#39;s
285         // canonical name. If that fails or is ambiguous, try a lookup
286         // using a particular module, perhaps an unnamed one. This
287         // offers more compatibility for compiling in single-module
288         // mode where the runtime module of an annotation type may
289         // differ from the single module being compiled.
290         String name = annotation.getCanonicalName();
291         TypeElement annotationElement = eltUtils.getTypeElement(name);
292         if (annotationElement != null)
293             return annotationElement;
294         else if (allowModules) {
295             String moduleName = Objects.requireNonNullElse(annotation.getModule().getName(), &quot;&quot;);
296             return eltUtils.getTypeElement(eltUtils.getModuleElement(moduleName), name);
297         } else {
298             return null;
299         }
300     }
301 
302     private Element mirrorAsElement(AnnotationMirror annotationMirror) {
303         return annotationMirror.getAnnotationType().asElement();
304     }
305 
306     private static final String NOT_AN_ANNOTATION_TYPE =
307         &quot;The argument does not represent an annotation type: &quot;;
308 
309     private void throwIfNotAnnotation(Class&lt;? extends Annotation&gt; a) {
310         if (!a.isAnnotation())
311             throw new IllegalArgumentException(NOT_AN_ANNOTATION_TYPE + a);
312     }
313 
314     private void throwIfNotAnnotation(TypeElement a) {
315         if (a.getKind() != ElementKind.ANNOTATION_TYPE)
316             throw new IllegalArgumentException(NOT_AN_ANNOTATION_TYPE + a);
317     }
318 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/main/JavaCompiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DelegatingJavaFileManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Main.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/main/JavaCompiler.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 788             }
 789             return outFile;
 790         }
 791     }
 792 
 793     /** Compile a source file that has been accessed by the class finder.
 794      *  @param c          The class the source file of which needs to be compiled.
 795      */
 796     private void readSourceFile(ClassSymbol c) throws CompletionFailure {
 797         readSourceFile(null, c);
 798     }
 799 
 800     /** Compile a ClassSymbol from source, optionally using the given compilation unit as
 801      *  the source tree.
 802      *  @param tree the compilation unit in which the given ClassSymbol resides,
 803      *              or null if should be parsed from source
 804      *  @param c    the ClassSymbol to complete
 805      */
 806     public void readSourceFile(JCCompilationUnit tree, ClassSymbol c) throws CompletionFailure {
 807         if (completionFailureName == c.fullname) {
<span class="line-modified"> 808             JCDiagnostic msg =</span>
<span class="line-modified"> 809                     diagFactory.fragment(Fragments.UserSelectedCompletionFailure);</span>
<span class="line-removed"> 810             throw new CompletionFailure(c, msg, dcfh);</span>
 811         }
 812         JavaFileObject filename = c.classfile;
 813         JavaFileObject prev = log.useSource(filename);
 814 
 815         if (tree == null) {
 816             try {
 817                 tree = parse(filename, filename.getCharContent(false));
 818             } catch (IOException e) {
 819                 log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 820                 tree = make.TopLevel(List.&lt;JCTree&gt;nil());
 821             } finally {
 822                 log.useSource(prev);
 823             }
 824         }
 825 
 826         if (!taskListener.isEmpty()) {
 827             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 828             taskListener.started(e);
 829         }
 830 
 831         // Process module declarations.
 832         // If module resolution fails, ignore trees, and if trying to
 833         // complete a specific symbol, throw CompletionFailure.
 834         // Note that if module resolution failed, we may not even
 835         // have enough modules available to access java.lang, and
 836         // so risk getting FatalError(&quot;no.java.lang&quot;) from MemberEnter.
 837         if (!modules.enter(List.of(tree), c)) {
<span class="line-modified"> 838             throw new CompletionFailure(c, diags.fragment(Fragments.CantResolveModules), dcfh);</span>
 839         }
 840 
 841         enter.complete(List.of(tree), c);
 842 
 843         if (!taskListener.isEmpty()) {
 844             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 845             taskListener.finished(e);
 846         }
 847 
 848         if (enter.getEnv(c) == null) {
 849             boolean isPkgInfo =
 850                 tree.sourcefile.isNameCompatible(&quot;package-info&quot;,
 851                                                  JavaFileObject.Kind.SOURCE);
 852             boolean isModuleInfo =
 853                 tree.sourcefile.isNameCompatible(&quot;module-info&quot;,
 854                                                  JavaFileObject.Kind.SOURCE);
 855             if (isModuleInfo) {
 856                 if (enter.getEnv(tree.modle) == null) {
 857                     JCDiagnostic diag =
 858                         diagFactory.fragment(Fragments.FileDoesNotContainModule);
</pre>
<hr />
<pre>
 973                     generate(desugar(flow(attribute(todo.remove()))));
 974                 break;
 975 
 976             default:
 977                 Assert.error(&quot;unknown compile policy&quot;);
 978             }
 979         } catch (Abort ex) {
 980             if (devVerbose)
 981                 ex.printStackTrace(System.err);
 982         } finally {
 983             if (verbose) {
 984                 elapsed_msec = elapsed(start_msec);
 985                 log.printVerbose(&quot;total&quot;, Long.toString(elapsed_msec));
 986             }
 987 
 988             reportDeferredDiagnostics();
 989 
 990             if (!log.hasDiagnosticListener()) {
 991                 printCount(&quot;error&quot;, errorCount());
 992                 printCount(&quot;warn&quot;, warningCount());


 993             }
 994             if (!taskListener.isEmpty()) {
 995                 taskListener.finished(new TaskEvent(TaskEvent.Kind.COMPILATION));
 996             }
 997             close();
 998             if (procEnvImpl != null)
 999                 procEnvImpl.close();
1000         }
1001     }
1002 
1003     protected void checkReusable() {
1004         throw new AssertionError(&quot;attempt to reuse JavaCompiler&quot;);
1005     }
1006 
1007     /**
1008      * The list of classes explicitly supplied on the command line for compilation.
1009      * Not always populated.
1010      */
1011     private List&lt;JCClassDecl&gt; rootClasses;
1012 
</pre>
<hr />
<pre>
1472          * already been added to C and its superclasses.
1473          */
1474         class ScanNested extends TreeScanner {
1475             Set&lt;Env&lt;AttrContext&gt;&gt; dependencies = new LinkedHashSet&lt;&gt;();
1476             protected boolean hasLambdas;
1477             @Override
1478             public void visitClassDef(JCClassDecl node) {
1479                 Type st = types.supertype(node.sym.type);
1480                 boolean envForSuperTypeFound = false;
1481                 while (!envForSuperTypeFound &amp;&amp; st.hasTag(CLASS)) {
1482                     ClassSymbol c = st.tsym.outermostClass();
1483                     Env&lt;AttrContext&gt; stEnv = enter.getEnv(c);
1484                     if (stEnv != null &amp;&amp; env != stEnv) {
1485                         if (dependencies.add(stEnv)) {
1486                             boolean prevHasLambdas = hasLambdas;
1487                             try {
1488                                 scan(stEnv.tree);
1489                             } finally {
1490                                 /*
1491                                  * ignore any updates to hasLambdas made during
<span class="line-modified">1492                                  * the nested scan, this ensures an initalized</span>
1493                                  * LambdaToMethod is available only to those
1494                                  * classes that contain lambdas
1495                                  */
1496                                 hasLambdas = prevHasLambdas;
1497                             }
1498                         }
1499                         envForSuperTypeFound = true;
1500                     }
1501                     st = types.supertype(st);
1502                 }
1503                 super.visitClassDef(node);
1504             }
1505             @Override
1506             public void visitLambda(JCLambda tree) {
1507                 hasLambdas = true;
1508                 super.visitLambda(tree);
1509             }
1510             @Override
1511             public void visitReference(JCMemberReference tree) {
1512                 hasLambdas = true;
</pre>
<hr />
<pre>
1540 
1541             if (env.tree.hasTag(JCTree.Tag.PACKAGEDEF) || env.tree.hasTag(JCTree.Tag.MODULEDEF)) {
1542                 if (!(sourceOutput)) {
1543                     if (shouldStop(CompileState.LOWER))
1544                         return;
1545                     List&lt;JCTree&gt; def = lower.translateTopLevelClass(env, env.tree, localMake);
1546                     if (def.head != null) {
1547                         Assert.check(def.tail.isEmpty());
1548                         results.add(new Pair&lt;&gt;(env, (JCClassDecl)def.head));
1549                     }
1550                 }
1551                 return;
1552             }
1553 
1554             if (shouldStop(CompileState.TRANSTYPES))
1555                 return;
1556 
1557             env.tree = transTypes.translateTopLevelClass(env.tree, localMake);
1558             compileStates.put(env, CompileState.TRANSTYPES);
1559 






1560             if (Feature.LAMBDA.allowedInSource(source) &amp;&amp; scanner.hasLambdas) {
1561                 if (shouldStop(CompileState.UNLAMBDA))
1562                     return;
1563 
1564                 env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);
1565                 compileStates.put(env, CompileState.UNLAMBDA);
1566             }
1567 
1568             if (shouldStop(CompileState.LOWER))
1569                 return;
1570 
1571             if (sourceOutput) {
1572                 //emit standard Java source file, only for compilation
1573                 //units enumerated explicitly on the command line
1574                 JCClassDecl cdef = (JCClassDecl)env.tree;
1575                 if (untranslated instanceof JCClassDecl &amp;&amp;
1576                     rootClasses.contains((JCClassDecl)untranslated)) {
1577                     results.add(new Pair&lt;&gt;(env, cdef));
1578                 }
1579                 return;
</pre>
<hr />
<pre>
1828     }
1829 
1830     protected void printNote(String lines) {
1831         log.printRawLines(Log.WriterKind.NOTICE, lines);
1832     }
1833 
1834     /** Print numbers of errors and warnings.
1835      */
1836     public void printCount(String kind, int count) {
1837         if (count != 0) {
1838             String key;
1839             if (count == 1)
1840                 key = &quot;count.&quot; + kind;
1841             else
1842                 key = &quot;count.&quot; + kind + &quot;.plural&quot;;
1843             log.printLines(WriterKind.ERROR, key, String.valueOf(count));
1844             log.flush(Log.WriterKind.ERROR);
1845         }
1846     }
1847 









1848     private static long now() {
1849         return System.currentTimeMillis();
1850     }
1851 
1852     private static long elapsed(long then) {
1853         return now() - then;
1854     }
1855 
1856     public void newRound() {
1857         inputFiles.clear();
1858         todo.clear();
1859     }
1860 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 788             }
 789             return outFile;
 790         }
 791     }
 792 
 793     /** Compile a source file that has been accessed by the class finder.
 794      *  @param c          The class the source file of which needs to be compiled.
 795      */
 796     private void readSourceFile(ClassSymbol c) throws CompletionFailure {
 797         readSourceFile(null, c);
 798     }
 799 
 800     /** Compile a ClassSymbol from source, optionally using the given compilation unit as
 801      *  the source tree.
 802      *  @param tree the compilation unit in which the given ClassSymbol resides,
 803      *              or null if should be parsed from source
 804      *  @param c    the ClassSymbol to complete
 805      */
 806     public void readSourceFile(JCCompilationUnit tree, ClassSymbol c) throws CompletionFailure {
 807         if (completionFailureName == c.fullname) {
<span class="line-modified"> 808             throw new CompletionFailure(</span>
<span class="line-modified"> 809                 c, () -&gt; diagFactory.fragment(Fragments.UserSelectedCompletionFailure), dcfh);</span>

 810         }
 811         JavaFileObject filename = c.classfile;
 812         JavaFileObject prev = log.useSource(filename);
 813 
 814         if (tree == null) {
 815             try {
 816                 tree = parse(filename, filename.getCharContent(false));
 817             } catch (IOException e) {
 818                 log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 819                 tree = make.TopLevel(List.&lt;JCTree&gt;nil());
 820             } finally {
 821                 log.useSource(prev);
 822             }
 823         }
 824 
 825         if (!taskListener.isEmpty()) {
 826             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 827             taskListener.started(e);
 828         }
 829 
 830         // Process module declarations.
 831         // If module resolution fails, ignore trees, and if trying to
 832         // complete a specific symbol, throw CompletionFailure.
 833         // Note that if module resolution failed, we may not even
 834         // have enough modules available to access java.lang, and
 835         // so risk getting FatalError(&quot;no.java.lang&quot;) from MemberEnter.
 836         if (!modules.enter(List.of(tree), c)) {
<span class="line-modified"> 837             throw new CompletionFailure(c, () -&gt; diags.fragment(Fragments.CantResolveModules), dcfh);</span>
 838         }
 839 
 840         enter.complete(List.of(tree), c);
 841 
 842         if (!taskListener.isEmpty()) {
 843             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 844             taskListener.finished(e);
 845         }
 846 
 847         if (enter.getEnv(c) == null) {
 848             boolean isPkgInfo =
 849                 tree.sourcefile.isNameCompatible(&quot;package-info&quot;,
 850                                                  JavaFileObject.Kind.SOURCE);
 851             boolean isModuleInfo =
 852                 tree.sourcefile.isNameCompatible(&quot;module-info&quot;,
 853                                                  JavaFileObject.Kind.SOURCE);
 854             if (isModuleInfo) {
 855                 if (enter.getEnv(tree.modle) == null) {
 856                     JCDiagnostic diag =
 857                         diagFactory.fragment(Fragments.FileDoesNotContainModule);
</pre>
<hr />
<pre>
 972                     generate(desugar(flow(attribute(todo.remove()))));
 973                 break;
 974 
 975             default:
 976                 Assert.error(&quot;unknown compile policy&quot;);
 977             }
 978         } catch (Abort ex) {
 979             if (devVerbose)
 980                 ex.printStackTrace(System.err);
 981         } finally {
 982             if (verbose) {
 983                 elapsed_msec = elapsed(start_msec);
 984                 log.printVerbose(&quot;total&quot;, Long.toString(elapsed_msec));
 985             }
 986 
 987             reportDeferredDiagnostics();
 988 
 989             if (!log.hasDiagnosticListener()) {
 990                 printCount(&quot;error&quot;, errorCount());
 991                 printCount(&quot;warn&quot;, warningCount());
<span class="line-added"> 992                 printSuppressedCount(errorCount(), log.nsuppressederrors, &quot;count.error.recompile&quot;);</span>
<span class="line-added"> 993                 printSuppressedCount(warningCount(), log.nsuppressedwarns, &quot;count.warn.recompile&quot;);</span>
 994             }
 995             if (!taskListener.isEmpty()) {
 996                 taskListener.finished(new TaskEvent(TaskEvent.Kind.COMPILATION));
 997             }
 998             close();
 999             if (procEnvImpl != null)
1000                 procEnvImpl.close();
1001         }
1002     }
1003 
1004     protected void checkReusable() {
1005         throw new AssertionError(&quot;attempt to reuse JavaCompiler&quot;);
1006     }
1007 
1008     /**
1009      * The list of classes explicitly supplied on the command line for compilation.
1010      * Not always populated.
1011      */
1012     private List&lt;JCClassDecl&gt; rootClasses;
1013 
</pre>
<hr />
<pre>
1473          * already been added to C and its superclasses.
1474          */
1475         class ScanNested extends TreeScanner {
1476             Set&lt;Env&lt;AttrContext&gt;&gt; dependencies = new LinkedHashSet&lt;&gt;();
1477             protected boolean hasLambdas;
1478             @Override
1479             public void visitClassDef(JCClassDecl node) {
1480                 Type st = types.supertype(node.sym.type);
1481                 boolean envForSuperTypeFound = false;
1482                 while (!envForSuperTypeFound &amp;&amp; st.hasTag(CLASS)) {
1483                     ClassSymbol c = st.tsym.outermostClass();
1484                     Env&lt;AttrContext&gt; stEnv = enter.getEnv(c);
1485                     if (stEnv != null &amp;&amp; env != stEnv) {
1486                         if (dependencies.add(stEnv)) {
1487                             boolean prevHasLambdas = hasLambdas;
1488                             try {
1489                                 scan(stEnv.tree);
1490                             } finally {
1491                                 /*
1492                                  * ignore any updates to hasLambdas made during
<span class="line-modified">1493                                  * the nested scan, this ensures an initialized</span>
1494                                  * LambdaToMethod is available only to those
1495                                  * classes that contain lambdas
1496                                  */
1497                                 hasLambdas = prevHasLambdas;
1498                             }
1499                         }
1500                         envForSuperTypeFound = true;
1501                     }
1502                     st = types.supertype(st);
1503                 }
1504                 super.visitClassDef(node);
1505             }
1506             @Override
1507             public void visitLambda(JCLambda tree) {
1508                 hasLambdas = true;
1509                 super.visitLambda(tree);
1510             }
1511             @Override
1512             public void visitReference(JCMemberReference tree) {
1513                 hasLambdas = true;
</pre>
<hr />
<pre>
1541 
1542             if (env.tree.hasTag(JCTree.Tag.PACKAGEDEF) || env.tree.hasTag(JCTree.Tag.MODULEDEF)) {
1543                 if (!(sourceOutput)) {
1544                     if (shouldStop(CompileState.LOWER))
1545                         return;
1546                     List&lt;JCTree&gt; def = lower.translateTopLevelClass(env, env.tree, localMake);
1547                     if (def.head != null) {
1548                         Assert.check(def.tail.isEmpty());
1549                         results.add(new Pair&lt;&gt;(env, (JCClassDecl)def.head));
1550                     }
1551                 }
1552                 return;
1553             }
1554 
1555             if (shouldStop(CompileState.TRANSTYPES))
1556                 return;
1557 
1558             env.tree = transTypes.translateTopLevelClass(env.tree, localMake);
1559             compileStates.put(env, CompileState.TRANSTYPES);
1560 
<span class="line-added">1561             if (shouldStop(CompileState.TRANSPATTERNS))</span>
<span class="line-added">1562                 return;</span>
<span class="line-added">1563 </span>
<span class="line-added">1564             env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);</span>
<span class="line-added">1565             compileStates.put(env, CompileState.TRANSPATTERNS);</span>
<span class="line-added">1566 </span>
1567             if (Feature.LAMBDA.allowedInSource(source) &amp;&amp; scanner.hasLambdas) {
1568                 if (shouldStop(CompileState.UNLAMBDA))
1569                     return;
1570 
1571                 env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);
1572                 compileStates.put(env, CompileState.UNLAMBDA);
1573             }
1574 
1575             if (shouldStop(CompileState.LOWER))
1576                 return;
1577 
1578             if (sourceOutput) {
1579                 //emit standard Java source file, only for compilation
1580                 //units enumerated explicitly on the command line
1581                 JCClassDecl cdef = (JCClassDecl)env.tree;
1582                 if (untranslated instanceof JCClassDecl &amp;&amp;
1583                     rootClasses.contains((JCClassDecl)untranslated)) {
1584                     results.add(new Pair&lt;&gt;(env, cdef));
1585                 }
1586                 return;
</pre>
<hr />
<pre>
1835     }
1836 
1837     protected void printNote(String lines) {
1838         log.printRawLines(Log.WriterKind.NOTICE, lines);
1839     }
1840 
1841     /** Print numbers of errors and warnings.
1842      */
1843     public void printCount(String kind, int count) {
1844         if (count != 0) {
1845             String key;
1846             if (count == 1)
1847                 key = &quot;count.&quot; + kind;
1848             else
1849                 key = &quot;count.&quot; + kind + &quot;.plural&quot;;
1850             log.printLines(WriterKind.ERROR, key, String.valueOf(count));
1851             log.flush(Log.WriterKind.ERROR);
1852         }
1853     }
1854 
<span class="line-added">1855     private void printSuppressedCount(int shown, int suppressed, String diagKey) {</span>
<span class="line-added">1856         if (suppressed &gt; 0) {</span>
<span class="line-added">1857             int total = shown + suppressed;</span>
<span class="line-added">1858             log.printLines(WriterKind.ERROR, diagKey,</span>
<span class="line-added">1859                     String.valueOf(shown), String.valueOf(total));</span>
<span class="line-added">1860             log.flush(Log.WriterKind.ERROR);</span>
<span class="line-added">1861         }</span>
<span class="line-added">1862     }</span>
<span class="line-added">1863 </span>
1864     private static long now() {
1865         return System.currentTimeMillis();
1866     }
1867 
1868     private static long elapsed(long then) {
1869         return now() - then;
1870     }
1871 
1872     public void newRound() {
1873         inputFiles.clear();
1874         todo.clear();
1875     }
1876 }
</pre>
</td>
</tr>
</table>
<center><a href="DelegatingJavaFileManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Main.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
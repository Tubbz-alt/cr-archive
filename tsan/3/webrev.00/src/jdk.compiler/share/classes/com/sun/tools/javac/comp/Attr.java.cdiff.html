<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArgumentAttr.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttrContext.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 30,11 ***</span>
  import java.util.stream.Collectors;
  
  import javax.lang.model.element.ElementKind;
  import javax.tools.JavaFileObject;
  
<span class="line-modified">! import com.sun.source.tree.CaseTree.CaseKind;</span>
  import com.sun.source.tree.IdentifierTree;
  import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  import com.sun.source.tree.MemberSelectTree;
  import com.sun.source.tree.TreeVisitor;
  import com.sun.source.util.SimpleTreeVisitor;
<span class="line-new-header">--- 30,11 ---</span>
  import java.util.stream.Collectors;
  
  import javax.lang.model.element.ElementKind;
  import javax.tools.JavaFileObject;
  
<span class="line-modified">! import com.sun.source.tree.CaseTree;</span>
  import com.sun.source.tree.IdentifierTree;
  import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  import com.sun.source.tree.MemberSelectTree;
  import com.sun.source.tree.TreeVisitor;
  import com.sun.source.util.SimpleTreeVisitor;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 47,10 ***</span>
<span class="line-new-header">--- 47,11 ---</span>
  import com.sun.tools.javac.code.TypeMetadata.Annotations;
  import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  import com.sun.tools.javac.comp.Check.CheckContext;
  import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
<span class="line-added">+ import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;</span>
  import com.sun.tools.javac.jvm.*;
  import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 72,11 ***</span>
  import static com.sun.tools.javac.code.Flags.BLOCK;
  import static com.sun.tools.javac.code.Kinds.*;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
  import static com.sun.tools.javac.code.TypeTag.*;
  import static com.sun.tools.javac.code.TypeTag.WILDCARD;
<span class="line-removed">- import com.sun.tools.javac.comp.Analyzer.AnalyzerMode;</span>
  import static com.sun.tools.javac.tree.JCTree.Tag.*;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  
  /** This is the main context-dependent analysis phase in GJC. It
   *  encompasses name resolution, type checking and constant folding as
<span class="line-new-header">--- 73,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,17 ***</span>
<span class="line-new-header">--- 109,19 ---</span>
      final TreeMaker make;
      final ConstFold cfolder;
      final Enter enter;
      final Target target;
      final Types types;
<span class="line-added">+     final Preview preview;</span>
      final JCDiagnostic.Factory diags;
      final TypeAnnotations typeAnnotations;
      final DeferredLintHandler deferredLintHandler;
      final TypeEnvs typeEnvs;
      final Dependencies dependencies;
      final Annotate annotate;
      final ArgumentAttr argumentAttr;
<span class="line-added">+     final MatchBindingsComputer matchBindingsComputer;</span>
  
      public static Attr instance(Context context) {
          Attr instance = context.get(attrKey);
          if (instance == null)
              instance = new Attr(context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,26 ***</span>
<span class="line-new-header">--- 146,31 ---</span>
          analyzer = Analyzer.instance(context);
          deferredAttr = DeferredAttr.instance(context);
          cfolder = ConstFold.instance(context);
          target = Target.instance(context);
          types = Types.instance(context);
<span class="line-added">+         preview = Preview.instance(context);</span>
          diags = JCDiagnostic.Factory.instance(context);
          annotate = Annotate.instance(context);
          typeAnnotations = TypeAnnotations.instance(context);
          deferredLintHandler = DeferredLintHandler.instance(context);
          typeEnvs = TypeEnvs.instance(context);
          dependencies = Dependencies.instance(context);
          argumentAttr = ArgumentAttr.instance(context);
<span class="line-added">+         matchBindingsComputer = MatchBindingsComputer.instance(context);</span>
  
          Options options = Options.instance(context);
  
          Source source = Source.instance(context);
          allowPoly = Feature.POLY.allowedInSource(source);
          allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
          allowLambda = Feature.LAMBDA.allowedInSource(source);
          allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
          allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
<span class="line-added">+         allowReifiableTypesInInstanceof =</span>
<span class="line-added">+                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;</span>
<span class="line-added">+                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());</span>
          sourceName = source.name;
          useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
  
          statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
          varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,10 ***</span>
<span class="line-new-header">--- 199,14 ---</span>
  
      /** Switch: static interface methods enabled?
       */
      boolean allowStaticInterfaceMethods;
  
<span class="line-added">+     /** Switch: reifiable types in instanceof enabled?</span>
<span class="line-added">+      */</span>
<span class="line-added">+     boolean allowReifiableTypesInInstanceof;</span>
<span class="line-added">+ </span>
      /**
       * Switch: warn about use of variable before declaration?
       * RFE: 6425594
       */
      boolean useBeforeDeclarationWarning;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,10 ***</span>
<span class="line-new-header">--- 302,12 ---</span>
               !((base == null ||
                 TreeInfo.isThisQualifier(base)) &amp;&amp;
                 isAssignableAsBlankFinal(v, env)))) {
              if (v.isResourceVariable()) { //TWR resource
                  log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
<span class="line-added">+             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {</span>
<span class="line-added">+                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));</span>
              } else {
                  log.error(pos, Errors.CantAssignValToFinalVar(v));
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,21 ***</span>
                  if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
                      return site;
                  Name name = (Name)node.getIdentifier();
                  if (site.kind == PCK) {
                      env.toplevel.packge = (PackageSymbol)site;
<span class="line-modified">!                     return rs.findIdentInPackage(env, (TypeSymbol)site, name,</span>
                              KindSelector.TYP_PCK);
                  } else {
                      env.enclClass.sym = (ClassSymbol)site;
                      return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
                  }
              }
  
              @Override @DefinedBy(Api.COMPILER_TREE)
              public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
<span class="line-modified">!                 return rs.findIdent(env, (Name)node.getName(), KindSelector.TYP_PCK);</span>
              }
          }
  
      public Type coerce(Type etype, Type ttype) {
          return cfolder.coerce(etype, ttype);
<span class="line-new-header">--- 369,21 ---</span>
                  if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
                      return site;
                  Name name = (Name)node.getIdentifier();
                  if (site.kind == PCK) {
                      env.toplevel.packge = (PackageSymbol)site;
<span class="line-modified">!                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,</span>
                              KindSelector.TYP_PCK);
                  } else {
                      env.enclClass.sym = (ClassSymbol)site;
                      return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
                  }
              }
  
              @Override @DefinedBy(Api.COMPILER_TREE)
              public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
<span class="line-modified">!                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);</span>
              }
          }
  
      public Type coerce(Type etype, Type ttype) {
          return cfolder.coerce(etype, ttype);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,39 ***</span>
                                           KindSelector.TYP : KindSelector.TYP_PCK,
                         Type.noType));
      }
  
      public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
<span class="line-modified">!         breakTree = tree;</span>
<span class="line-removed">-         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</span>
<span class="line-removed">-         EnumSet&lt;AnalyzerMode&gt; analyzerModes = EnumSet.copyOf(analyzer.analyzerModes);</span>
<span class="line-removed">-         try {</span>
<span class="line-removed">-             analyzer.analyzerModes.clear();</span>
<span class="line-removed">-             attribExpr(expr, env);</span>
<span class="line-removed">-         } catch (BreakAttr b) {</span>
<span class="line-removed">-             return b.env;</span>
<span class="line-removed">-         } catch (AssertionError ae) {</span>
<span class="line-removed">-             if (ae.getCause() instanceof BreakAttr) {</span>
<span class="line-removed">-                 return ((BreakAttr)(ae.getCause())).env;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 throw ae;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } finally {</span>
<span class="line-removed">-             breakTree = null;</span>
<span class="line-removed">-             log.useSource(prev);</span>
<span class="line-removed">-             analyzer.analyzerModes.addAll(analyzerModes);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return env;</span>
      }
  
      public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
          breakTree = tree;
          JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
<span class="line-removed">-         EnumSet&lt;AnalyzerMode&gt; analyzerModes = EnumSet.copyOf(analyzer.analyzerModes);</span>
          try {
<span class="line-modified">!             analyzer.analyzerModes.clear();</span>
<span class="line-modified">!             attribStat(stmt, env);</span>
          } catch (BreakAttr b) {
              return b.env;
          } catch (AssertionError ae) {
              if (ae.getCause() instanceof BreakAttr) {
                  return ((BreakAttr)(ae.getCause())).env;
<span class="line-new-header">--- 403,24 ---</span>
                                           KindSelector.TYP : KindSelector.TYP_PCK,
                         Type.noType));
      }
  
      public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
<span class="line-modified">!         return attribToTree(expr, env, tree, unknownExprInfo);</span>
      }
  
      public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
<span class="line-added">+         return attribToTree(stmt, env, tree, statInfo);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {</span>
          breakTree = tree;
          JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
          try {
<span class="line-modified">!             deferredAttr.attribSpeculative(root, env, resultInfo,</span>
<span class="line-modified">!                     null, DeferredAttr.AttributionMode.ANALYZER,</span>
<span class="line-added">+                     argumentAttr.withLocalCacheContext());</span>
          } catch (BreakAttr b) {
              return b.env;
          } catch (AssertionError ae) {
              if (ae.getCause() instanceof BreakAttr) {
                  return ((BreakAttr)(ae.getCause())).env;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,20 ***</span>
                  throw ae;
              }
          } finally {
              breakTree = null;
              log.useSource(prev);
<span class="line-removed">-             analyzer.analyzerModes.addAll(analyzerModes);</span>
          }
          return env;
      }
  
      private JCTree breakTree = null;
  
      private static class BreakAttr extends RuntimeException {
          static final long serialVersionUID = -6924771130405446405L;
<span class="line-modified">!         private Env&lt;AttrContext&gt; env;</span>
          private BreakAttr(Env&lt;AttrContext&gt; env) {
              this.env = env;
          }
      }
  
<span class="line-new-header">--- 428,19 ---</span>
                  throw ae;
              }
          } finally {
              breakTree = null;
              log.useSource(prev);
          }
          return env;
      }
  
      private JCTree breakTree = null;
  
      private static class BreakAttr extends RuntimeException {
          static final long serialVersionUID = -6924771130405446405L;
<span class="line-modified">!         private transient Env&lt;AttrContext&gt; env;</span>
          private BreakAttr(Env&lt;AttrContext&gt; env) {
              this.env = env;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 643,10 ***</span>
<span class="line-new-header">--- 640,12 ---</span>
  
      /** Visitor result: the computed type.
       */
      Type result;
  
<span class="line-added">+     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;</span>
<span class="line-added">+ </span>
      /** Visitor method: attribute a tree, catching any completion failure
       *  exceptions. Return the tree&#39;s type.
       *
       *  @param tree    The tree to be visited.
       *  @param env     The environment visitor argument.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 661,10 ***</span>
<span class="line-new-header">--- 660,12 ---</span>
              if (resultInfo.needsArgumentAttr(tree)) {
                  result = argumentAttr.attribArg(tree, env);
              } else {
                  tree.accept(this);
              }
<span class="line-added">+             matchBindings = matchBindingsComputer.finishBindings(tree,</span>
<span class="line-added">+                                                                  matchBindings);</span>
              if (tree == breakTree &amp;&amp;
                      resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
                  breakTreeFound(copyEnv(env));
              }
              return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,15 ***</span>
  
      /** Derived visitor method: attribute a statement or definition tree.
       */
      public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
          Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return attribTree(tree, env, statInfo);</span>
<span class="line-modified">!         } finally {</span>
<span class="line-removed">-             analyzer.analyzeIfNeeded(tree, analyzeEnv);</span>
<span class="line-removed">-         }</span>
      }
  
      /** Attribute a list of expressions, returning a list of types.
       */
      List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
<span class="line-new-header">--- 732,13 ---</span>
  
      /** Derived visitor method: attribute a statement or definition tree.
       */
      public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
          Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
<span class="line-modified">!         Type result = attribTree(tree, env, statInfo);</span>
<span class="line-modified">!         analyzer.analyzeIfNeeded(tree, analyzeEnv);</span>
<span class="line-modified">!         return result;</span>
      }
  
      /** Attribute a list of expressions, returning a list of types.
       */
      List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 929,11 ***</span>
          return id.type;
      }
  
      public void visitClassDef(JCClassDecl tree) {
          Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
<span class="line-modified">!                 Optional.ofNullable(env.info.isSpeculative ?</span>
                          argumentAttr.withLocalCacheContext() : null);
          try {
              // Local and anonymous classes have not been entered yet, so we need to
              // do it now.
              if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
<span class="line-new-header">--- 928,11 ---</span>
          return id.type;
      }
  
      public void visitClassDef(JCClassDecl tree) {
          Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
<span class="line-modified">!                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?</span>
                          argumentAttr.withLocalCacheContext() : null);
          try {
              // Local and anonymous classes have not been entered yet, so we need to
              // do it now.
              if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1038,10 ***</span>
<span class="line-new-header">--- 1037,83 ---</span>
                  Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
                  attribType(tree.recvparam, newEnv);
                  chk.validate(tree.recvparam, newEnv);
              }
  
<span class="line-added">+             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {</span>
<span class="line-added">+                 // lets find if this method is an accessor</span>
<span class="line-added">+                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()</span>
<span class="line-added">+                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();</span>
<span class="line-added">+                 if (recordComponent.isPresent()) {</span>
<span class="line-added">+                     // the method is a user defined accessor lets check that everything is fine</span>
<span class="line-added">+                     if (!tree.sym.isPublic()) {</span>
<span class="line-added">+                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {</span>
<span class="line-added">+                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,</span>
<span class="line-added">+                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {</span>
<span class="line-added">+                         log.error(tree,</span>
<span class="line-added">+                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (!tree.typarams.isEmpty()) {</span>
<span class="line-added">+                         log.error(tree,</span>
<span class="line-added">+                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (tree.sym.isStatic()) {</span>
<span class="line-added">+                         log.error(tree,</span>
<span class="line-added">+                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (tree.name == names.init) {</span>
<span class="line-added">+                     // if this a constructor other than the canonical one</span>
<span class="line-added">+                     if ((tree.sym.flags_field &amp; RECORD) == 0) {</span>
<span class="line-added">+                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);</span>
<span class="line-added">+                         if (app == null ||</span>
<span class="line-added">+                                 TreeInfo.name(app.meth) != names._this ||</span>
<span class="line-added">+                                 !checkFirstConstructorStat(app, tree, false)) {</span>
<span class="line-added">+                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     } else {</span>
<span class="line-added">+                         // but if it is the canonical:</span>
<span class="line-added">+ </span>
<span class="line-added">+                         // if user generated, then it shouldn&#39;t explicitly invoke any other constructor</span>
<span class="line-added">+                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {</span>
<span class="line-added">+                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);</span>
<span class="line-added">+                             if (app != null &amp;&amp;</span>
<span class="line-added">+                                     (TreeInfo.name(app.meth) == names._this ||</span>
<span class="line-added">+                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;</span>
<span class="line-added">+                                     checkFirstConstructorStat(app, tree, false)) {</span>
<span class="line-added">+                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">+                                         Fragments.Canonical, tree.sym.name,</span>
<span class="line-added">+                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                         }</span>
<span class="line-added">+ </span>
<span class="line-added">+                         // also we want to check that no type variables have been defined</span>
<span class="line-added">+                         if (!tree.typarams.isEmpty()) {</span>
<span class="line-added">+                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">+                                     Fragments.Canonical, tree.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+ </span>
<span class="line-added">+                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the</span>
<span class="line-added">+                          * record components</span>
<span class="line-added">+                          */</span>
<span class="line-added">+                         List&lt;Type&gt; recordComponentTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);</span>
<span class="line-added">+                         for (JCVariableDecl param: tree.params) {</span>
<span class="line-added">+                             if (!types.isSameType(param.type, recordComponentTypes.head)) {</span>
<span class="line-added">+                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">+                                         Fragments.Canonical, tree.sym.name, Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             recordComponentTypes = recordComponentTypes.tail;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              // annotation method checks
              if ((owner.flags() &amp; ANNOTATION) != 0) {
                  // annotation method cannot have throws clause
                  if (tree.thrown.nonEmpty()) {
                      log.error(tree.thrown.head.pos(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1085,26 ***</span>
                  // super(...) or this(...) is given
                  // or we are compiling class java.lang.Object.
                  if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
                      JCBlock body = tree.body;
                      if (body.stats.isEmpty() ||
<span class="line-modified">!                             !TreeInfo.isSelfCall(body.stats.head)) {</span>
<span class="line-modified">!                         body.stats = body.stats.</span>
<span class="line-modified">!                                 prepend(typeEnter.SuperCall(make.at(body.pos),</span>
<span class="line-modified">!                                         List.nil(),</span>
<span class="line-removed">-                                         List.nil(),</span>
<span class="line-removed">-                                         false));</span>
                      } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
                              (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
                              TreeInfo.isSuperCall(body.stats.head)) {
                          // enum constructors are not allowed to call super
                          // directly, so make sure there aren&#39;t any super calls
                          // in enum constructors, except in the compiler
                          // generated one.
                          log.error(tree.body.stats.head.pos(),
                                    Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
                      }
                  }
  
                  // Attribute all type annotations in the body
                  annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
                  annotate.flush();
<span class="line-new-header">--- 1157,45 ---</span>
                  // super(...) or this(...) is given
                  // or we are compiling class java.lang.Object.
                  if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
                      JCBlock body = tree.body;
                      if (body.stats.isEmpty() ||
<span class="line-modified">!                             TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {</span>
<span class="line-modified">!                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),</span>
<span class="line-modified">!                                 make.Ident(names._super), make.Idents(List.nil())));</span>
<span class="line-modified">!                         body.stats = body.stats.prepend(supCall);</span>
                      } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
                              (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
                              TreeInfo.isSuperCall(body.stats.head)) {
                          // enum constructors are not allowed to call super
                          // directly, so make sure there aren&#39;t any super calls
                          // in enum constructors, except in the compiler
                          // generated one.
                          log.error(tree.body.stats.head.pos(),
                                    Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
                      }
<span class="line-added">+                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor</span>
<span class="line-added">+                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);</span>
<span class="line-added">+                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);</span>
<span class="line-added">+                         if (!initParamNames.equals(recordComponentNames)) {</span>
<span class="line-added">+                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">+                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         if (!tree.sym.isPublic()) {</span>
<span class="line-added">+                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">+                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,</span>
<span class="line-added">+                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {</span>
<span class="line-added">+                             log.error(tree,</span>
<span class="line-added">+                                     Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">+                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,</span>
<span class="line-added">+                                             env.enclClass.sym.name,</span>
<span class="line-added">+                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(</span>
<span class="line-added">+                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     }</span>
                  }
  
                  // Attribute all type annotations in the body
                  annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
                  annotate.flush();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1195,16 ***</span>
<span class="line-new-header">--- 1286,30 ---</span>
                  if (tree.isImplicitlyTyped()) {
                      setSyntheticVariableType(tree, v.type);
                  }
              }
              result = tree.type = v.type;
<span class="line-added">+             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {</span>
<span class="line-added">+                 if (isNonArgsMethodInObject(v.name)) {</span>
<span class="line-added">+                     log.error(tree, Errors.IllegalRecordComponentName(v));</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
          }
          finally {
              chk.setLint(prevLint);
          }
      }
  
<span class="line-added">+     private boolean isNonArgsMethodInObject(Name name) {</span>
<span class="line-added">+         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {</span>
<span class="line-added">+             if (s.type.getParameterTypes().isEmpty()) {</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      Fragment canInferLocalVarType(JCVariableDecl tree) {
          LocalInitScanner lis = new LocalInitScanner();
          lis.scan(tree.init);
          return lis.badInferenceMsg;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1271,11 ***</span>
      public void visitSkip(JCSkip tree) {
          result = null;
      }
  
      public void visitBlock(JCBlock tree) {
<span class="line-modified">!         if (env.info.scope.owner.kind == TYP) {</span>
              // Block is a static or instance initializer;
              // let the owner of the environment be a freshly
              // created BLOCK-method.
              Symbol fakeOwner =
                  new MethodSymbol(tree.flags | BLOCK |
<span class="line-new-header">--- 1376,11 ---</span>
      public void visitSkip(JCSkip tree) {
          result = null;
      }
  
      public void visitBlock(JCBlock tree) {
<span class="line-modified">!         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {</span>
              // Block is a static or instance initializer;
              // let the owner of the environment be a freshly
              // created BLOCK-method.
              Symbol fakeOwner =
                  new MethodSymbol(tree.flags | BLOCK |
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1315,41 ***</span>
      }
  
      public void visitDoLoop(JCDoWhileLoop tree) {
          attribStat(tree.body, env.dup(tree));
          attribExpr(tree.cond, env, syms.booleanType);
          result = null;
      }
  
      public void visitWhileLoop(JCWhileLoop tree) {
          attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">!         attribStat(tree.body, env.dup(tree));</span>
          result = null;
      }
  
      public void visitForLoop(JCForLoop tree) {
          Env&lt;AttrContext&gt; loopEnv =
              env.dup(env.tree, env.info.dup(env.info.scope.dup()));
          try {
              attribStats(tree.init, loopEnv);
<span class="line-modified">!             if (tree.cond != null) attribExpr(tree.cond, loopEnv, syms.booleanType);</span>
<span class="line-modified">!             loopEnv.tree = tree; // before, we were not in loop!</span>
<span class="line-modified">!             attribStats(tree.step, loopEnv);</span>
<span class="line-modified">!             attribStat(tree.body, loopEnv);</span>
              result = null;
          }
          finally {
              loopEnv.info.scope.leave();
          }
      }
  
      public void visitForeachLoop(JCEnhancedForLoop tree) {
          Env&lt;AttrContext&gt; loopEnv =
              env.dup(env.tree, env.info.dup(env.info.scope.dup()));
          try {
              //the Formal Parameter of a for-each loop is not in the scope when
<span class="line-modified">!             //attributing the for-each expression; we mimick this by attributing</span>
              //the for-each expression first (against original scope).
              Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
              chk.checkNonVoid(tree.pos(), exprType);
              Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
              if (elemtype == null) {
<span class="line-new-header">--- 1420,79 ---</span>
      }
  
      public void visitDoLoop(JCDoWhileLoop tree) {
          attribStat(tree.body, env.dup(tree));
          attribExpr(tree.cond, env, syms.booleanType);
<span class="line-added">+         if (!breaksOutOf(tree, tree.body)) {</span>
<span class="line-added">+             //include condition&#39;s body when false after the while, if cannot get out of the loop</span>
<span class="line-added">+             MatchBindings condBindings = matchBindings;</span>
<span class="line-added">+             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);</span>
<span class="line-added">+             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">+         }</span>
          result = null;
      }
  
      public void visitWhileLoop(JCWhileLoop tree) {
          attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">!         MatchBindings condBindings = matchBindings;</span>
<span class="line-added">+         // include condition&#39;s bindings when true in the body:</span>
<span class="line-added">+         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             attribStat(tree.body, whileEnv.dup(tree));</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             whileEnv.info.scope.leave();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!breaksOutOf(tree, tree.body)) {</span>
<span class="line-added">+             //include condition&#39;s bindings when false after the while, if cannot get out of the loop</span>
<span class="line-added">+             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);</span>
<span class="line-added">+             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">+         }</span>
          result = null;
      }
  
<span class="line-added">+     private boolean breaksOutOf(JCTree loop, JCTree body) {</span>
<span class="line-added">+         preFlow(body);</span>
<span class="line-added">+         return flow.breaksOutOf(env, loop, body, make);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public void visitForLoop(JCForLoop tree) {
          Env&lt;AttrContext&gt; loopEnv =
              env.dup(env.tree, env.info.dup(env.info.scope.dup()));
<span class="line-added">+         MatchBindings condBindings = MatchBindingsComputer.EMPTY;</span>
          try {
              attribStats(tree.init, loopEnv);
<span class="line-modified">!             if (tree.cond != null) {</span>
<span class="line-modified">!                 attribExpr(tree.cond, loopEnv, syms.booleanType);</span>
<span class="line-modified">!                 // include condition&#39;s bindings when true in the body and step:</span>
<span class="line-modified">!                 condBindings = matchBindings;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 bodyEnv.tree = tree; // before, we were not in loop!</span>
<span class="line-added">+                 attribStats(tree.step, bodyEnv);</span>
<span class="line-added">+                 attribStat(tree.body, bodyEnv);</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 bodyEnv.info.scope.leave();</span>
<span class="line-added">+             }</span>
              result = null;
          }
          finally {
              loopEnv.info.scope.leave();
          }
<span class="line-added">+         if (!breaksOutOf(tree, tree.body)) {</span>
<span class="line-added">+             //include condition&#39;s body when false after the while, if cannot get out of the loop</span>
<span class="line-added">+             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);</span>
<span class="line-added">+             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">+         }</span>
      }
  
      public void visitForeachLoop(JCEnhancedForLoop tree) {
          Env&lt;AttrContext&gt; loopEnv =
              env.dup(env.tree, env.info.dup(env.info.scope.dup()));
          try {
              //the Formal Parameter of a for-each loop is not in the scope when
<span class="line-modified">!             //attributing the for-each expression; we mimic this by attributing</span>
              //the for-each expression first (against original scope).
              Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
              chk.checkNonVoid(tree.pos(), exprType);
              Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
              if (elemtype == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1423,30 ***</span>
  
          ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
          ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
  
          handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
<span class="line-modified">!             caseEnv.info.breakResult = condInfo;</span>
              attribStats(c.stats, caseEnv);
              new TreeScanner() {
                  @Override
<span class="line-modified">!                 public void visitBreak(JCBreak brk) {</span>
                      if (brk.target == tree) {
                          caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
                          caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
                      }
<span class="line-modified">!                     super.visitBreak(brk);</span>
                  }
  
                  @Override public void visitClassDef(JCClassDecl tree) {}
                  @Override public void visitLambda(JCLambda tree) {}
              }.scan(c.stats);
          });
  
          if (tree.cases.isEmpty()) {
              log.error(tree.pos(),
                        Errors.SwitchExpressionEmpty);
          }
  
          Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
  
          result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
<span class="line-new-header">--- 1566,33 ---</span>
  
          ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
          ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
  
          handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
<span class="line-modified">!             caseEnv.info.yieldResult = condInfo;</span>
              attribStats(c.stats, caseEnv);
              new TreeScanner() {
                  @Override
<span class="line-modified">!                 public void visitYield(JCYield brk) {</span>
                      if (brk.target == tree) {
                          caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
                          caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
                      }
<span class="line-modified">!                     super.visitYield(brk);</span>
                  }
  
                  @Override public void visitClassDef(JCClassDecl tree) {}
                  @Override public void visitLambda(JCLambda tree) {}
              }.scan(c.stats);
          });
  
          if (tree.cases.isEmpty()) {
              log.error(tree.pos(),
                        Errors.SwitchExpressionEmpty);
<span class="line-added">+         } else if (caseTypes.isEmpty()) {</span>
<span class="line-added">+             log.error(tree.pos(),</span>
<span class="line-added">+                       Errors.SwitchExpressionNoResultExpressions);</span>
          }
  
          Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
  
          result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1481,12 ***</span>
  
              // Attribute all cases and
              // check that there are no duplicate case labels or default clauses.
              Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
              boolean hasDefault = false;      // Is there a default label?
<span class="line-modified">!             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">-             CaseKind caseKind = null;</span>
              boolean wasError = false;
              for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
                  JCCase c = l.head;
                  if (caseKind == null) {
                      caseKind = c.caseKind;
<span class="line-new-header">--- 1627,11 ---</span>
  
              // Attribute all cases and
              // check that there are no duplicate case labels or default clauses.
              Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
              boolean hasDefault = false;      // Is there a default label?
<span class="line-modified">!             CaseTree.CaseKind caseKind = null;</span>
              boolean wasError = false;
              for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
                  JCCase c = l.head;
                  if (caseKind == null) {
                      caseKind = c.caseKind;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1528,12 ***</span>
                      switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
                  try {
                      attribCase.accept(c, caseEnv);
                  } finally {
                      caseEnv.info.scope.leave();
<span class="line-removed">-                     addVars(c.stats, switchEnv.info.scope);</span>
                  }
              }
          } finally {
              switchEnv.info.scope.leave();
          }
      }
<span class="line-new-header">--- 1673,12 ---</span>
                      switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
                  try {
                      attribCase.accept(c, caseEnv);
                  } finally {
                      caseEnv.info.scope.leave();
                  }
<span class="line-added">+                 addVars(c.stats, switchEnv.info.scope);</span>
              }
          } finally {
              switchEnv.info.scope.leave();
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1671,10 ***</span>
<span class="line-new-header">--- 1816,11 ---</span>
          }
      }
  
      public void visitConditional(JCConditional tree) {
          Type condtype = attribExpr(tree.cond, env, syms.booleanType);
<span class="line-added">+         MatchBindings condBindings = matchBindings;</span>
  
          tree.polyKind = (!allowPoly ||
                  pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
                  isBooleanOrNumeric(env, tree)) ?
                  PolyKind.STANDALONE : PolyKind.POLY;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1688,12 ***</span>
  
          ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
                  unknownExprInfo :
                  resultInfo.dup(conditionalContext(resultInfo.checkContext));
  
<span class="line-modified">!         Type truetype = attribTree(tree.truepart, env, condInfo);</span>
<span class="line-modified">!         Type falsetype = attribTree(tree.falsepart, env, condInfo);</span>
  
          Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
                  condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
                           List.of(truetype, falsetype)) : pt();
          if (condtype.constValue() != null &amp;&amp;
<span class="line-new-header">--- 1834,34 ---</span>
  
          ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
                  unknownExprInfo :
                  resultInfo.dup(conditionalContext(resultInfo.checkContext));
  
<span class="line-modified">! </span>
<span class="line-modified">!         // x ? y : z</span>
<span class="line-added">+         // include x&#39;s bindings when true in y</span>
<span class="line-added">+         // include x&#39;s bindings when false in z</span>
<span class="line-added">+ </span>
<span class="line-added">+         Type truetype;</span>
<span class="line-added">+         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             truetype = attribTree(tree.truepart, trueEnv, condInfo);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             trueEnv.info.scope.leave();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         MatchBindings trueBindings = matchBindings;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Type falsetype;</span>
<span class="line-added">+         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             falseEnv.info.scope.leave();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         MatchBindings falseBindings = matchBindings;</span>
  
          Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
                  condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
                           List.of(truetype, falsetype)) : pt();
          if (condtype.constValue() != null &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1702,10 ***</span>
<span class="line-new-header">--- 1870,11 ---</span>
                  !owntype.hasTag(NONE)) {
              //constant folding
              owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
          }
          result = check(tree, owntype, KindSelector.VAL, resultInfo);
<span class="line-added">+         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);</span>
      }
      //where
          private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
              switch (tree.getTag()) {
                  case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1844,100 ***</span>
          FLOAT,
          DOUBLE,
          BOOLEAN,
      };
  
      public void visitIf(JCIf tree) {
          attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">!         attribStat(tree.thenpart, env);</span>
<span class="line-modified">!         if (tree.elsepart != null)</span>
<span class="line-modified">!             attribStat(tree.elsepart, env);</span>
          chk.checkEmptyIf(tree);
          result = null;
      }
  
      public void visitExec(JCExpressionStatement tree) {
          //a fresh environment is required for 292 inference to work properly ---
          //see Infer.instantiatePolymorphicSignatureInstance()
          Env&lt;AttrContext&gt; localEnv = env.dup(tree);
          attribExpr(tree.expr, localEnv);
          result = null;
      }
  
      public void visitBreak(JCBreak tree) {
<span class="line-modified">!         if (env.info.breakResult != null) {</span>
<span class="line-modified">!             if (tree.value == null) {</span>
<span class="line-modified">!                 tree.target = findJumpTarget(tree.pos(), tree.getTag(), null, env);</span>
<span class="line-modified">!                 if (tree.target.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-modified">!                     log.error(tree.pos(), Errors.BreakMissingValue);</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 if (env.info.breakResult.pt.hasTag(VOID)) {</span>
<span class="line-removed">-                     //can happen?</span>
<span class="line-removed">-                     env.info.breakResult.checkContext.report(tree.value.pos(),</span>
<span class="line-removed">-                               diags.fragment(Fragments.UnexpectedRetVal));</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 boolean attribute = true;</span>
<span class="line-removed">-                 if (tree.value.hasTag(IDENT)) {</span>
<span class="line-removed">-                     //disambiguate break &lt;LABEL&gt; and break &lt;ident-as-an-expression&gt;:</span>
<span class="line-removed">-                     Name label = ((JCIdent) tree.value).name;</span>
<span class="line-removed">-                     Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tree.getTag(), label, env);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     if (jumpTarget.fst != null) {</span>
<span class="line-removed">-                         JCTree speculative = deferredAttr.attribSpeculative(tree.value, env, unknownExprInfo);</span>
<span class="line-removed">-                         if (!speculative.type.hasTag(ERROR)) {</span>
<span class="line-removed">-                             log.error(tree.pos(), Errors.BreakAmbiguousTarget(label));</span>
<span class="line-removed">-                             if (jumpTarget.snd == null) {</span>
<span class="line-removed">-                                 tree.target = jumpTarget.fst;</span>
<span class="line-removed">-                                 attribute = false;</span>
<span class="line-removed">-                             } else {</span>
<span class="line-removed">-                                 //nothing</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                         } else {</span>
<span class="line-removed">-                             if (jumpTarget.snd != null) {</span>
<span class="line-removed">-                                 log.error(tree.pos(), jumpTarget.snd);</span>
<span class="line-removed">-                             }</span>
<span class="line-removed">-                             tree.target = jumpTarget.fst;</span>
<span class="line-removed">-                             attribute = false;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 if (attribute) {</span>
<span class="line-removed">-                     attribTree(tree.value, env, env.info.breakResult);</span>
<span class="line-removed">-                     JCTree immediateTarget = findJumpTarget(tree.pos(), tree.getTag(), null, env);</span>
<span class="line-removed">-                     if (immediateTarget.getTag() != SWITCH_EXPRESSION) {</span>
<span class="line-removed">-                         log.error(tree.pos(), Errors.BreakExprNotImmediate(immediateTarget.getTag()));</span>
<span class="line-removed">-                         Env&lt;AttrContext&gt; env1 = env;</span>
<span class="line-removed">-                         while (env1 != null &amp;&amp; env1.tree.getTag() != SWITCH_EXPRESSION) {</span>
<span class="line-removed">-                             env1 = env1.next;</span>
<span class="line-removed">-                         }</span>
<span class="line-removed">-                         Assert.checkNonNull(env1);</span>
<span class="line-removed">-                         tree.target = env1.tree;</span>
<span class="line-removed">-                     } else {</span>
<span class="line-removed">-                         tree.target = immediateTarget;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          } else {
<span class="line-modified">!             if (tree.value == null || tree.value.hasTag(IDENT)) {</span>
<span class="line-modified">!                 Name label = tree.value != null ? ((JCIdent) tree.value).name : null;</span>
<span class="line-modified">!                 tree.target = findJumpTarget(tree.pos(), tree.getTag(), label, env);</span>
<span class="line-modified">!             } else {</span>
<span class="line-removed">-                 log.error(tree.pos(), Errors.BreakComplexValueNoSwitchExpression);</span>
<span class="line-removed">-                 attribTree(tree.value, env, unknownExprInfo);</span>
<span class="line-removed">-             }</span>
          }
          result = null;
      }
  
      public void visitContinue(JCContinue tree) {
          tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
          result = null;
      }
      //where
<span class="line-modified">!         /** Return the target of a break or continue statement, if it exists,</span>
<span class="line-modified">!          *  report an error if not.</span>
           *  Note: The target of a labelled break or continue is the
           *  (non-labelled) statement tree referred to by the label,
           *  not the tree representing the labelled statement itself.
           *
           *  @param pos     The position to be used for error diagnostics
<span class="line-new-header">--- 2013,113 ---</span>
          FLOAT,
          DOUBLE,
          BOOLEAN,
      };
  
<span class="line-added">+     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {</span>
<span class="line-added">+         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));</span>
<span class="line-added">+         bindings.forEach(env1.info.scope::enter);</span>
<span class="line-added">+         return env1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public void visitIf(JCIf tree) {
          attribExpr(tree.cond, env, syms.booleanType);
<span class="line-modified">! </span>
<span class="line-modified">!         // if (x) { y } [ else z ]</span>
<span class="line-modified">!         // include x&#39;s bindings when true in y</span>
<span class="line-added">+         // include x&#39;s bindings when false in z</span>
<span class="line-added">+ </span>
<span class="line-added">+         MatchBindings condBindings = matchBindings;</span>
<span class="line-added">+         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);</span>
<span class="line-added">+ </span>
<span class="line-added">+         try {</span>
<span class="line-added">+             attribStat(tree.thenpart, thenEnv);</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             thenEnv.info.scope.leave();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         preFlow(tree.thenpart);</span>
<span class="line-added">+         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);</span>
<span class="line-added">+         boolean aliveAfterElse;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (tree.elsepart != null) {</span>
<span class="line-added">+             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);</span>
<span class="line-added">+             try {</span>
<span class="line-added">+                 attribStat(tree.elsepart, elseEnv);</span>
<span class="line-added">+             } finally {</span>
<span class="line-added">+                 elseEnv.info.scope.leave();</span>
<span class="line-added">+             }</span>
<span class="line-added">+             preFlow(tree.elsepart);</span>
<span class="line-added">+             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             aliveAfterElse = true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          chk.checkEmptyIf(tree);
<span class="line-added">+ </span>
<span class="line-added">+         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {</span>
<span class="line-added">+             afterIfBindings = condBindings.bindingsWhenTrue;</span>
<span class="line-added">+         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {</span>
<span class="line-added">+             afterIfBindings = condBindings.bindingsWhenFalse;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         afterIfBindings.forEach(env.info.scope::enter);</span>
<span class="line-added">+         afterIfBindings.forEach(BindingSymbol::preserveBinding);</span>
<span class="line-added">+ </span>
          result = null;
      }
  
<span class="line-added">+         void preFlow(JCTree tree) {</span>
<span class="line-added">+             new PostAttrAnalyzer() {</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 public void scan(JCTree tree) {</span>
<span class="line-added">+                     if (tree == null ||</span>
<span class="line-added">+                             (tree.type != null &amp;&amp;</span>
<span class="line-added">+                             tree.type == Type.stuckType)) {</span>
<span class="line-added">+                         //don&#39;t touch stuck expressions!</span>
<span class="line-added">+                         return;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     super.scan(tree);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }.scan(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
      public void visitExec(JCExpressionStatement tree) {
          //a fresh environment is required for 292 inference to work properly ---
          //see Infer.instantiatePolymorphicSignatureInstance()
          Env&lt;AttrContext&gt; localEnv = env.dup(tree);
          attribExpr(tree.expr, localEnv);
          result = null;
      }
  
      public void visitBreak(JCBreak tree) {
<span class="line-modified">!         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);</span>
<span class="line-modified">!         result = null;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     public void visitYield(JCYield tree) {</span>
<span class="line-modified">!         if (env.info.yieldResult != null) {</span>
<span class="line-modified">!             attribTree(tree.value, env, env.info.yieldResult);</span>
<span class="line-modified">!             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);</span>
          } else {
<span class="line-modified">!             log.error(tree.pos(), tree.value.hasTag(PARENS)</span>
<span class="line-modified">!                     ? Errors.NoSwitchExpressionQualify</span>
<span class="line-modified">!                     : Errors.NoSwitchExpression);</span>
<span class="line-modified">!             attribTree(tree.value, env, unknownExprInfo);</span>
          }
          result = null;
      }
  
      public void visitContinue(JCContinue tree) {
          tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
          result = null;
      }
      //where
<span class="line-modified">!         /** Return the target of a break, continue or yield statement,</span>
<span class="line-modified">!          *  if it exists, report an error if not.</span>
           *  Note: The target of a labelled break or continue is the
           *  (non-labelled) statement tree referred to by the label,
           *  not the tree representing the labelled statement itself.
           *
           *  @param pos     The position to be used for error diagnostics
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2007,16 ***</span>
                          break;
                      case SWITCH:
                          if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
                          break;
                      case SWITCH_EXPRESSION:
<span class="line-modified">!                         if (tag == BREAK) {</span>
<span class="line-modified">!                             if (label == null) {</span>
<span class="line-modified">!                                 return Pair.of(env1.tree, null);</span>
<span class="line-modified">!                             } else {</span>
<span class="line-removed">-                                 pendingError = Errors.BreakOutsideSwitchExpression;</span>
<span class="line-removed">-                             }</span>
                          } else {
                              pendingError = Errors.ContinueOutsideSwitchExpression;
                          }
                          break;
                      case LAMBDA:
<span class="line-new-header">--- 2189,14 ---</span>
                          break;
                      case SWITCH:
                          if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
                          break;
                      case SWITCH_EXPRESSION:
<span class="line-modified">!                         if (tag == YIELD) {</span>
<span class="line-modified">!                             return Pair.of(env1.tree, null);</span>
<span class="line-modified">!                         } else if (tag == BREAK) {</span>
<span class="line-modified">!                             pendingError = Errors.BreakOutsideSwitchExpression;</span>
                          } else {
                              pendingError = Errors.ContinueOutsideSwitchExpression;
                          }
                          break;
                      case LAMBDA:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2027,10 ***</span>
<span class="line-new-header">--- 2207,12 ---</span>
                  }
                  env1 = env1.next;
              }
              if (label != null)
                  return Pair.of(null, Errors.UndefLabel(label));
<span class="line-added">+             else if (pendingError != null)</span>
<span class="line-added">+                 return Pair.of(null, pendingError);</span>
              else if (tag == CONTINUE)
                  return Pair.of(null, Errors.ContOutsideLoop);
              else
                  return Pair.of(null, Errors.BreakOutsideSwitchLoop);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2038,12 ***</span>
      public void visitReturn(JCReturn tree) {
          // Check that there is an enclosing method which is
          // nested within than the enclosing class.
          if (env.info.returnResult == null) {
              log.error(tree.pos(), Errors.RetOutsideMeth);
<span class="line-modified">!         } else if (env.info.breakResult != null) {</span>
              log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
          } else {
              // Attribute return expression, if it exists, and check that
              // it conforms to result type of enclosing method.
              if (tree.expr != null) {
                  if (env.info.returnResult.pt.hasTag(VOID)) {
<span class="line-new-header">--- 2220,18 ---</span>
      public void visitReturn(JCReturn tree) {
          // Check that there is an enclosing method which is
          // nested within than the enclosing class.
          if (env.info.returnResult == null) {
              log.error(tree.pos(), Errors.RetOutsideMeth);
<span class="line-modified">!         } else if (env.info.yieldResult != null) {</span>
              log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
<span class="line-added">+         } else if (!env.info.isLambda &amp;&amp;</span>
<span class="line-added">+                 !env.info.isNewClass &amp;&amp;</span>
<span class="line-added">+                 env.enclMethod != null &amp;&amp;</span>
<span class="line-added">+                 TreeInfo.isCompactConstructor(env.enclMethod)) {</span>
<span class="line-added">+             log.error(env.enclMethod,</span>
<span class="line-added">+                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));</span>
          } else {
              // Attribute return expression, if it exists, and check that
              // it conforms to result type of enclosing method.
              if (tree.expr != null) {
                  if (env.info.returnResult.pt.hasTag(VOID)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2098,11 ***</span>
  
          ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
          if (isConstructorCall) {
              // We are seeing a ...this(...) or ...super(...) call.
              // Check that this is the first statement in a constructor.
<span class="line-modified">!             if (checkFirstConstructorStat(tree, env)) {</span>
  
                  // Record the fact
                  // that this is a constructor call (using isSelfCall).
                  localEnv.info.isSelfCall = true;
  
<span class="line-new-header">--- 2286,11 ---</span>
  
          ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
          if (isConstructorCall) {
              // We are seeing a ...this(...) or ...super(...) call.
              // Check that this is the first statement in a constructor.
<span class="line-modified">!             if (checkFirstConstructorStat(tree, env.enclMethod, true)) {</span>
  
                  // Record the fact
                  // that this is a constructor call (using isSelfCall).
                  localEnv.info.isSelfCall = true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2237,23 ***</span>
              }
          }
  
          /** Check that given application node appears as first statement
           *  in a constructor call.
<span class="line-modified">!          *  @param tree   The application node</span>
<span class="line-modified">!          *  @param env    The environment current at the application.</span>
           */
<span class="line-modified">!         boolean checkFirstConstructorStat(JCMethodInvocation tree, Env&lt;AttrContext&gt; env) {</span>
<span class="line-removed">-             JCMethodDecl enclMethod = env.enclMethod;</span>
              if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
                  JCBlock body = enclMethod.body;
                  if (body.stats.head.hasTag(EXEC) &amp;&amp;
                      ((JCExpressionStatement) body.stats.head).expr == tree)
                      return true;
              }
<span class="line-modified">!             log.error(tree.pos(),</span>
<span class="line-modified">!                       Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));</span>
              return false;
          }
  
          /** Obtain a method type with given argument types.
           */
<span class="line-new-header">--- 2425,25 ---</span>
              }
          }
  
          /** Check that given application node appears as first statement
           *  in a constructor call.
<span class="line-modified">!          *  @param tree          The application node</span>
<span class="line-modified">!          *  @param enclMethod    The enclosing method of the application.</span>
<span class="line-added">+          *  @param error         Should an error be issued?</span>
           */
<span class="line-modified">!         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {</span>
              if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
                  JCBlock body = enclMethod.body;
                  if (body.stats.head.hasTag(EXEC) &amp;&amp;
                      ((JCExpressionStatement) body.stats.head).expr == tree)
                      return true;
              }
<span class="line-modified">!             if (error) {</span>
<span class="line-modified">!                 log.error(tree.pos(),</span>
<span class="line-added">+                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));</span>
<span class="line-added">+             }</span>
              return false;
          }
  
          /** Obtain a method type with given argument types.
           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2702,12 ***</span>
          boolean needsRecovery =
                  resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
          try {
              if (needsRecovery &amp;&amp; isSerializable(pt())) {
                  localEnv.info.isSerializable = true;
<span class="line-modified">!                 localEnv.info.isLambda = true;</span>
              }
              List&lt;Type&gt; explicitParamTypes = null;
              if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
                  //attribute lambda parameters
                  attribStats(that.params, localEnv);
                  explicitParamTypes = TreeInfo.types(that.params);
<span class="line-new-header">--- 2892,13 ---</span>
          boolean needsRecovery =
                  resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
          try {
              if (needsRecovery &amp;&amp; isSerializable(pt())) {
                  localEnv.info.isSerializable = true;
<span class="line-modified">!                 localEnv.info.isSerializableLambda = true;</span>
              }
<span class="line-added">+             localEnv.info.isLambda = true;</span>
              List&lt;Type&gt; explicitParamTypes = null;
              if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
                  //attribute lambda parameters
                  attribStats(that.params, localEnv);
                  explicitParamTypes = TreeInfo.types(that.params);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2817,10 ***</span>
<span class="line-new-header">--- 3008,12 ---</span>
          } catch (Types.FunctionDescriptorLookupError ex) {
              JCDiagnostic cause = ex.getDiagnostic();
              resultInfo.checkContext.report(that, cause);
              result = that.type = types.createErrorType(pt());
              return;
<span class="line-added">+         } catch (CompletionFailure cf) {</span>
<span class="line-added">+             chk.completionError(that.pos(), cf);</span>
          } catch (Throwable t) {
              //when an unexpected exception happens, avoid attempts to attribute the same tree again
              //as that would likely cause the same exception again.
              needsRecovery = false;
              throw t;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2912,11 ***</span>
                  }
  
                  public void visitLambda(JCLambda that) {
                      // or lambda expressions!
                  }
<span class="line-modified">!             }.scan(tree);</span>
          }
  
          Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
  
              @Override
<span class="line-new-header">--- 3105,11 ---</span>
                  }
  
                  public void visitLambda(JCLambda that) {
                      // or lambda expressions!
                  }
<span class="line-modified">!             }.scan(tree.body);</span>
          }
  
          Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
  
              @Override
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3134,11 ***</span>
                  }
                  lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
              } else {
                  lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
              }
<span class="line-modified">!             lambdaEnv.info.breakResult = null;</span>
              return lambdaEnv;
          }
  
      @Override
      public void visitReference(final JCMemberReference that) {
<span class="line-new-header">--- 3327,11 ---</span>
                  }
                  lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
              } else {
                  lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
              }
<span class="line-modified">!             lambdaEnv.info.yieldResult = null;</span>
              return lambdaEnv;
          }
  
      @Override
      public void visitReference(final JCMemberReference that) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3273,14 ***</span>
                  // stop here
                  result = that.type = currentTarget;
                  return;
              }
  
<span class="line-modified">!             if (!env.info.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {</span>
                  Type enclosingType = exprType.getEnclosingType();
                  if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
<span class="line-modified">!                     // Check for the existence of an apropriate outer instance</span>
                      rs.resolveImplicitThis(that.pos(), env, exprType);
                  }
              }
  
              if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
<span class="line-new-header">--- 3466,14 ---</span>
                  // stop here
                  result = that.type = currentTarget;
                  return;
              }
  
<span class="line-modified">!             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {</span>
                  Type enclosingType = exprType.getEnclosingType();
                  if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
<span class="line-modified">!                     // Check for the existence of an appropriate outer instance</span>
                      rs.resolveImplicitThis(that.pos(), env, exprType);
                  }
              }
  
              if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3577,16 ***</span>
                      owntype = cfolder.coerce(ctype, owntype);
                  }
              }
          }
          result = check(tree, owntype, KindSelector.VAL, resultInfo);
      }
  
      public void visitBinary(JCBinary tree) {
          // Attribute arguments.
          Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
<span class="line-modified">!         Type right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, env));</span>
          // Find operator.
          Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
          Type owntype = types.createErrorType(tree.type);
          if (operator != operators.noOpSymbol &amp;&amp;
                  !left.isErroneous() &amp;&amp;
<span class="line-new-header">--- 3770,45 ---</span>
                      owntype = cfolder.coerce(ctype, owntype);
                  }
              }
          }
          result = check(tree, owntype, KindSelector.VAL, resultInfo);
<span class="line-added">+         matchBindings = matchBindingsComputer.unary(tree, matchBindings);</span>
      }
  
      public void visitBinary(JCBinary tree) {
          // Attribute arguments.
          Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
<span class="line-modified">!         // x &amp;&amp; y</span>
<span class="line-added">+         // include x&#39;s bindings when true in y</span>
<span class="line-added">+ </span>
<span class="line-added">+         // x || y</span>
<span class="line-added">+         // include x&#39;s bindings when false in y</span>
<span class="line-added">+ </span>
<span class="line-added">+         MatchBindings lhsBindings = matchBindings;</span>
<span class="line-added">+         List&lt;BindingSymbol&gt; propagatedBindings;</span>
<span class="line-added">+         switch (tree.getTag()) {</span>
<span class="line-added">+             case AND:</span>
<span class="line-added">+                 propagatedBindings = lhsBindings.bindingsWhenTrue;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             case OR:</span>
<span class="line-added">+                 propagatedBindings = lhsBindings.bindingsWhenFalse;</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             default:</span>
<span class="line-added">+                 propagatedBindings = List.nil();</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);</span>
<span class="line-added">+         Type right;</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             rhsEnv.info.scope.leave();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);</span>
<span class="line-added">+ </span>
          // Find operator.
          Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
          Type owntype = types.createErrorType(tree.type);
          if (operator != operators.noOpSymbol &amp;&amp;
                  !left.isErroneous() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3648,23 ***</span>
      }
  
      public void visitTypeTest(JCInstanceOf tree) {
          Type exprtype = chk.checkNullOrRefType(
                  tree.expr.pos(), attribExpr(tree.expr, env));
<span class="line-modified">!         Type clazztype = attribType(tree.clazz, env);</span>
          if (!clazztype.hasTag(TYPEVAR)) {
<span class="line-modified">!             clazztype = chk.checkClassOrArrayType(tree.clazz.pos(), clazztype);</span>
          }
          if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
<span class="line-modified">!             log.error(tree.clazz.pos(), Errors.IllegalGenericTypeForInstof);</span>
<span class="line-modified">!             clazztype = types.createErrorType(clazztype);</span>
          }
<span class="line-modified">!         chk.validate(tree.clazz, env, false);</span>
          chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
          result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
      }
  
      public void visitIndexed(JCArrayAccess tree) {
          Type owntype = types.createErrorType(tree.type);
          Type atype = attribExpr(tree.indexed, env);
          attribExpr(tree.index, env, syms.intType);
          if (types.isArray(atype))
<span class="line-new-header">--- 3870,68 ---</span>
      }
  
      public void visitTypeTest(JCInstanceOf tree) {
          Type exprtype = chk.checkNullOrRefType(
                  tree.expr.pos(), attribExpr(tree.expr, env));
<span class="line-modified">!         Type clazztype;</span>
<span class="line-added">+         JCTree typeTree;</span>
<span class="line-added">+         if (tree.pattern.getTag() == BINDINGPATTERN) {</span>
<span class="line-added">+             attribTree(tree.pattern, env, unknownExprInfo);</span>
<span class="line-added">+             clazztype = tree.pattern.type;</span>
<span class="line-added">+             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;</span>
<span class="line-added">+             typeTree = pattern.vartype;</span>
<span class="line-added">+             if (!clazztype.hasTag(TYPEVAR)) {</span>
<span class="line-added">+                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             clazztype = attribType(tree.pattern, env);</span>
<span class="line-added">+             typeTree = tree.pattern;</span>
<span class="line-added">+         }</span>
          if (!clazztype.hasTag(TYPEVAR)) {
<span class="line-modified">!             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);</span>
          }
          if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
<span class="line-modified">!             boolean valid = false;</span>
<span class="line-modified">!             if (allowReifiableTypesInInstanceof) {</span>
<span class="line-added">+                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {</span>
<span class="line-added">+                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 Warner warner = new Warner();</span>
<span class="line-added">+                 if (!types.isCastable(exprtype, clazztype, warner)) {</span>
<span class="line-added">+                     chk.basicHandler.report(tree.expr.pos(),</span>
<span class="line-added">+                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));</span>
<span class="line-added">+                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {</span>
<span class="line-added">+                     log.error(tree.expr.pos(),</span>
<span class="line-added">+                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     valid = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (!valid) {</span>
<span class="line-added">+                 clazztype = types.createErrorType(clazztype);</span>
<span class="line-added">+             }</span>
          }
<span class="line-modified">!         chk.validate(typeTree, env, false);</span>
          chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
          result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
      }
  
<span class="line-added">+     public void visitBindingPattern(JCBindingPattern tree) {</span>
<span class="line-added">+         ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);</span>
<span class="line-added">+         tree.type = attribTree(tree.vartype, env, varInfo);</span>
<span class="line-added">+         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);</span>
<span class="line-added">+         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {</span>
<span class="line-added">+             chk.checkTransparentVar(tree.pos(), v, env.info.scope);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());</span>
<span class="line-added">+         annotate.flush();</span>
<span class="line-added">+         result = tree.type;</span>
<span class="line-added">+         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      public void visitIndexed(JCArrayAccess tree) {
          Type owntype = types.createErrorType(tree.type);
          Type atype = attribExpr(tree.indexed, env);
          attribExpr(tree.index, env, syms.intType);
          if (types.isArray(atype))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3748,11 ***</span>
              while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
                  env1 = env1.outer;
          }
  
          if (env.info.isSerializable) {
<span class="line-modified">!             chk.checkAccessFromSerializableElement(tree, env.info.isLambda);</span>
          }
  
          result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
      }
  
<span class="line-new-header">--- 4015,11 ---</span>
              while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
                  env1 = env1.outer;
          }
  
          if (env.info.isSerializable) {
<span class="line-modified">!             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);</span>
          }
  
          result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3890,11 ***</span>
                  if (site1 != null) site = site1;
              }
          }
  
          if (env.info.isSerializable) {
<span class="line-modified">!             chk.checkAccessFromSerializableElement(tree, env.info.isLambda);</span>
          }
  
          env.info.selectSuper = selectSuperPrev;
          result = checkId(tree, site, sym, env, resultInfo);
      }
<span class="line-new-header">--- 4157,11 ---</span>
                  if (site1 != null) site = site1;
              }
          }
  
          if (env.info.isSerializable) {
<span class="line-modified">!             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);</span>
          }
  
          env.info.selectSuper = selectSuperPrev;
          result = checkId(tree, site, sym, env, resultInfo);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3914,11 ***</span>
              DiagnosticPosition pos = tree.pos();
              Name name = tree.name;
              switch (site.getTag()) {
              case PACKAGE:
                  return rs.accessBase(
<span class="line-modified">!                     rs.findIdentInPackage(env, site.tsym, name, resultInfo.pkind),</span>
                      pos, location, site, name, true);
              case ARRAY:
              case CLASS:
                  if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
                      return rs.resolveQualifiedMethod(
<span class="line-new-header">--- 4181,11 ---</span>
              DiagnosticPosition pos = tree.pos();
              Name name = tree.name;
              switch (site.getTag()) {
              case PACKAGE:
                  return rs.accessBase(
<span class="line-modified">!                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),</span>
                      pos, location, site, name, true);
              case ARRAY:
              case CLASS:
                  if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
                      return rs.resolveQualifiedMethod(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3929,20 ***</span>
                      // In this case, we have already made sure in
                      // visitSelect that qualifier expression is a type.
                      return syms.getClassField(site, types);
                  } else {
                      // We are seeing a plain identifier as selector.
<span class="line-modified">!                     Symbol sym = rs.findIdentInType(env, site, name, resultInfo.pkind);</span>
                          sym = rs.accessBase(sym, pos, location, site, name, true);
                      return sym;
                  }
              case WILDCARD:
                  throw new AssertionError(tree);
              case TYPEVAR:
                  // Normally, site.getUpperBound() shouldn&#39;t be null.
                  // It should only happen during memberEnter/attribBase
<span class="line-modified">!                 // when determining the super type which *must* beac</span>
                  // done before attributing the type variables.  In
                  // other words, we are seeing this illegal program:
                  // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
                  Symbol sym = (site.getUpperBound() != null)
                      ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
<span class="line-new-header">--- 4196,20 ---</span>
                      // In this case, we have already made sure in
                      // visitSelect that qualifier expression is a type.
                      return syms.getClassField(site, types);
                  } else {
                      // We are seeing a plain identifier as selector.
<span class="line-modified">!                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);</span>
                          sym = rs.accessBase(sym, pos, location, site, name, true);
                      return sym;
                  }
              case WILDCARD:
                  throw new AssertionError(tree);
              case TYPEVAR:
                  // Normally, site.getUpperBound() shouldn&#39;t be null.
                  // It should only happen during memberEnter/attribBase
<span class="line-modified">!                 // when determining the super type which *must* be</span>
                  // done before attributing the type variables.  In
                  // other words, we are seeing this illegal program:
                  // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
                  Symbol sym = (site.getUpperBound() != null)
                      ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4133,10 ***</span>
<span class="line-new-header">--- 4400,11 ---</span>
  
              if (sym.name != names.init || tree.hasTag(REFERENCE)) {
                  chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
                  chk.checkSunAPI(tree.pos(), sym);
                  chk.checkProfile(tree.pos(), sym);
<span class="line-added">+                 chk.checkPreview(tree.pos(), sym);</span>
              }
  
              // If symbol is a variable, check that its type and
              // kind are compatible with the prototype and protokind.
              return check(tree, owntype, sym.kind.toSelector(), resultInfo);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4220,11 ***</span>
           * reference its static members unless they are constant.
           *
           * @param tree    The tree making up the variable reference.
           * @param env     The current environment.
           * @param v       The variable&#39;s symbol.
<span class="line-modified">!          * @jls  section 8.9 Enums</span>
           */
          private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
              // JLS:
              //
              // &quot;It is a compile-time error to reference a static field
<span class="line-new-header">--- 4488,11 ---</span>
           * reference its static members unless they are constant.
           *
           * @param tree    The tree making up the variable reference.
           * @param env     The current environment.
           * @param v       The variable&#39;s symbol.
<span class="line-modified">!          * @jls 8.9 Enum Types</span>
           */
          private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
              // JLS:
              //
              // &quot;It is a compile-time error to reference a static field
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4910,11 ***</span>
                  &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
                  &amp;&amp; !c.isAnonymous()) {
              checkSerialVersionUID(tree, c);
          }
          if (allowTypeAnnos) {
<span class="line-modified">!             // Correctly organize the postions of the type annotations</span>
              typeAnnotations.organizeTypeAnnotationsBodies(tree);
  
              // Check type annotations applicability rules
              validateTypeAnnotations(tree, false);
          }
<span class="line-new-header">--- 5178,11 ---</span>
                  &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
                  &amp;&amp; !c.isAnonymous()) {
              checkSerialVersionUID(tree, c);
          }
          if (allowTypeAnnos) {
<span class="line-modified">!             // Correctly organize the positions of the type annotations</span>
              typeAnnotations.organizeTypeAnnotationsBodies(tree);
  
              // Check type annotations applicability rules
              validateTypeAnnotations(tree, false);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5051,12 ***</span>
              if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
                  validateAnnotatedType(tree.clazz, tree.clazz.type);
              super.visitTypeCast(tree);
          }
          public void visitTypeTest(JCInstanceOf tree) {
<span class="line-modified">!             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)</span>
<span class="line-modified">!                 validateAnnotatedType(tree.clazz, tree.clazz.type);</span>
              super.visitTypeTest(tree);
          }
          public void visitNewClass(JCNewClass tree) {
              if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
                  if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
<span class="line-new-header">--- 5319,12 ---</span>
              if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
                  validateAnnotatedType(tree.clazz, tree.clazz.type);
              super.visitTypeCast(tree);
          }
          public void visitTypeTest(JCInstanceOf tree) {
<span class="line-modified">!             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)</span>
<span class="line-modified">!                 validateAnnotatedType(tree.pattern, tree.pattern.type);</span>
              super.visitTypeTest(tree);
          }
          public void visitNewClass(JCNewClass tree) {
              if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
                  if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5220,11 ***</span>
      /**
       * Handle missing types/symbols in an AST. This routine is useful when
       * the compiler has encountered some errors (which might have ended up
       * terminating attribution abruptly); if the compiler is used in fail-over
       * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
<span class="line-modified">!      * prevents NPE to be progagated during subsequent compilation steps.</span>
       */
      public void postAttr(JCTree tree) {
          new PostAttrAnalyzer().scan(tree);
      }
  
<span class="line-new-header">--- 5488,11 ---</span>
      /**
       * Handle missing types/symbols in an AST. This routine is useful when
       * the compiler has encountered some errors (which might have ended up
       * terminating attribution abruptly); if the compiler is used in fail-over
       * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
<span class="line-modified">!      * prevents NPE to be propagated during subsequent compilation steps.</span>
       */
      public void postAttr(JCTree tree) {
          new PostAttrAnalyzer().scan(tree);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5312,10 ***</span>
<span class="line-new-header">--- 5580,19 ---</span>
                  that.vartype = make.at(Position.NOPOS).Erroneous();
              }
              super.visitVarDef(that);
          }
  
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitBindingPattern(JCBindingPattern that) {</span>
<span class="line-added">+             if (that.symbol == null) {</span>
<span class="line-added">+                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);</span>
<span class="line-added">+                 that.symbol.adr = 0;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             super.visitBindingPattern(that);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public void visitNewClass(JCNewClass that) {
              if (that.constructor == null) {
                  that.constructor = new MethodSymbol(0, names.init,
                          dummyMethodType(), syms.noSymbol);
</pre>
<center><a href="ArgumentAttr.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AttrContext.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
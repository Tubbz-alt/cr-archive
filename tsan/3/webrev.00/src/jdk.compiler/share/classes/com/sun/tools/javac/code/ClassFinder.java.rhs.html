<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/ClassFinder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 1999, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Iterator;
 33 import java.util.Map;
 34 import java.util.NoSuchElementException;
 35 import java.util.Set;
<a name="1" id="anc1"></a><span class="line-added"> 36 import java.util.function.Supplier;</span>
 37 
 38 import javax.lang.model.SourceVersion;
 39 import javax.tools.JavaFileManager;
 40 import javax.tools.JavaFileManager.Location;
 41 import javax.tools.JavaFileObject;
 42 import javax.tools.JavaFileObject.Kind;
 43 import javax.tools.StandardJavaFileManager;
 44 import javax.tools.StandardLocation;
 45 
 46 import com.sun.tools.javac.code.Scope.WriteableScope;
 47 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 48 import com.sun.tools.javac.code.Symbol.Completer;
 49 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 50 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 51 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 52 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 53 import com.sun.tools.javac.comp.Annotate;
 54 import com.sun.tools.javac.file.JRTIndex;
 55 import com.sun.tools.javac.file.JavacFileManager;
 56 import com.sun.tools.javac.jvm.ClassReader;
 57 import com.sun.tools.javac.jvm.Profile;
 58 import com.sun.tools.javac.main.Option;
 59 import com.sun.tools.javac.platform.PlatformDescription;
 60 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
 61 import com.sun.tools.javac.util.*;
 62 
 63 import static javax.tools.StandardLocation.*;
 64 
 65 import static com.sun.tools.javac.code.Flags.*;
 66 import static com.sun.tools.javac.code.Kinds.Kind.*;
 67 import com.sun.tools.javac.code.Symbol;
 68 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 69 import com.sun.tools.javac.main.DelegatingJavaFileManager;
 70 
 71 import com.sun.tools.javac.util.Dependencies.CompletionCause;
 72 
 73 /**
 74  *  This class provides operations to locate class definitions
 75  *  from the source and class files on the paths provided to javac.
 76  *
 77  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 78  *  If you write code that depends on this, you do so at your own risk.
 79  *  This code and its internal interfaces are subject to change or
 80  *  deletion without notice.&lt;/b&gt;
 81  */
 82 public class ClassFinder {
 83     /** The context key for the class finder. */
 84     protected static final Context.Key&lt;ClassFinder&gt; classFinderKey = new Context.Key&lt;&gt;();
 85 
 86     ClassReader reader;
 87 
 88     private final Annotate annotate;
 89 
 90     /** Switch: verbose output.
 91      */
 92     boolean verbose;
 93 
 94     /**
 95      * Switch: cache completion failures unless -XDdev is used
 96      */
 97     private boolean cacheCompletionFailure;
 98 
 99     /**
100      * Switch: prefer source files instead of newer when both source
101      * and class are available
102      **/
103     protected boolean preferSource;
104 
105     /**
106      * Switch: Search classpath and sourcepath for classes before the
107      * bootclasspath
108      */
109     protected boolean userPathsFirst;
110 
111     /** The log to use for verbose output
112      */
113     final Log log;
114 
115     /** The symbol table. */
116     Symtab syms;
117 
118     /** The name table. */
119     final Names names;
120 
121     /** Force a completion failure on this name
122      */
123     final Name completionFailureName;
124 
125     /** Access to files
126      */
127     private final JavaFileManager fileManager;
128 
129     /** Dependency tracker
130      */
131     private final Dependencies dependencies;
132 
133     /** Factory for diagnostics
134      */
135     JCDiagnostic.Factory diagFactory;
136 
137     final DeferredCompletionFailureHandler dcfh;
138 
139     /** Can be reassigned from outside:
140      *  the completer to be used for &quot;.java&quot; files. If this remains unassigned
141      *  &quot;.java&quot; files will not be loaded.
142      */
143     public Completer sourceCompleter = Completer.NULL_COMPLETER;
144 
145     /** The path name of the class file currently being read.
146      */
147     protected JavaFileObject currentClassFile = null;
148 
149     /** The class or method currently being read.
150      */
151     protected Symbol currentOwner = null;
152 
153     /**
154      * The currently selected profile.
155      */
156     private final Profile profile;
157 
158     /**
159      * Use direct access to the JRTIndex to access the temporary
160      * replacement for the info that used to be in ct.sym.
161      * In time, this will go away and be replaced by the module system.
162      */
163     private final JRTIndex jrtIndex;
164 
165     /**
166      * Completer that delegates to the complete-method of this class.
167      */
168     private final Completer thisCompleter = this::complete;
169 
170     public Completer getCompleter() {
171         return thisCompleter;
172     }
173 
174     /** Get the ClassFinder instance for this invocation. */
175     public static ClassFinder instance(Context context) {
176         ClassFinder instance = context.get(classFinderKey);
177         if (instance == null)
178             instance = new ClassFinder(context);
179         return instance;
180     }
181 
182     /** Construct a new class finder. */
183     protected ClassFinder(Context context) {
184         context.put(classFinderKey, this);
185         reader = ClassReader.instance(context);
186         names = Names.instance(context);
187         syms = Symtab.instance(context);
188         fileManager = context.get(JavaFileManager.class);
189         dependencies = Dependencies.instance(context);
190         if (fileManager == null)
191             throw new AssertionError(&quot;FileManager initialization error&quot;);
192         diagFactory = JCDiagnostic.Factory.instance(context);
193         dcfh = DeferredCompletionFailureHandler.instance(context);
194 
195         log = Log.instance(context);
196         annotate = Annotate.instance(context);
197 
198         Options options = Options.instance(context);
199         verbose = options.isSet(Option.VERBOSE);
200         cacheCompletionFailure = options.isUnset(&quot;dev&quot;);
201         preferSource = &quot;source&quot;.equals(options.get(&quot;-Xprefer&quot;));
202         userPathsFirst = options.isSet(Option.XXUSERPATHSFIRST);
203 
204         completionFailureName =
205             options.isSet(&quot;failcomplete&quot;)
206             ? names.fromString(options.get(&quot;failcomplete&quot;))
207             : null;
208 
209         // Temporary, until more info is available from the module system.
210         boolean useCtProps;
211         JavaFileManager fm = context.get(JavaFileManager.class);
212         if (fm instanceof DelegatingJavaFileManager) {
213             fm = ((DelegatingJavaFileManager) fm).getBaseFileManager();
214         }
215         if (fm instanceof JavacFileManager) {
216             JavacFileManager jfm = (JavacFileManager) fm;
217             useCtProps = jfm.isDefaultBootClassPath() &amp;&amp; jfm.isSymbolFileEnabled();
218         } else if (fm.getClass().getName().equals(&quot;com.sun.tools.sjavac.comp.SmartFileManager&quot;)) {
219             useCtProps = !options.isSet(&quot;ignore.symbol.file&quot;);
220         } else {
221             useCtProps = false;
222         }
223         jrtIndex = useCtProps &amp;&amp; JRTIndex.isAvailable() ? JRTIndex.getSharedInstance() : null;
224 
225         profile = Profile.instance(context);
<a name="2" id="anc2"></a><span class="line-modified">226         cachedCompletionFailure = new CompletionFailure(null, () -&gt; null, dcfh);</span>
227         cachedCompletionFailure.setStackTrace(new StackTraceElement[0]);
228     }
229 
230 
231 /************************************************************************
232  * Temporary ct.sym replacement
233  *
234  * The following code is a temporary substitute for the ct.sym mechanism
235  * used in JDK 6 thru JDK 8.
236  * This mechanism will eventually be superseded by the Jigsaw module system.
237  ***********************************************************************/
238 
239     /**
240      * Returns any extra flags for a class symbol.
241      * This information used to be provided using private annotations
242      * in the class file in ct.sym; in time, this information will be
243      * available from the module system.
244      */
245     long getSupplementaryFlags(ClassSymbol c) {
246         if (jrtIndex == null || !jrtIndex.isInJRT(c.classfile) || c.name == names.module_info) {
247             return 0;
248         }
249 
250         if (supplementaryFlags == null) {
251             supplementaryFlags = new HashMap&lt;&gt;();
252         }
253 
254         Long flags = supplementaryFlags.get(c.packge());
255         if (flags == null) {
256             long newFlags = 0;
257             try {
258                 JRTIndex.CtSym ctSym = jrtIndex.getCtSym(c.packge().flatName());
259                 Profile minProfile = Profile.DEFAULT;
260                 if (ctSym.proprietary)
261                     newFlags |= PROPRIETARY;
262                 if (ctSym.minProfile != null)
263                     minProfile = Profile.lookup(ctSym.minProfile);
264                 if (profile != Profile.DEFAULT &amp;&amp; minProfile.value &gt; profile.value) {
265                     newFlags |= NOT_IN_PROFILE;
266                 }
267             } catch (IOException ignore) {
268             }
269             supplementaryFlags.put(c.packge(), flags = newFlags);
270         }
271         return flags;
272     }
273 
274     private Map&lt;PackageSymbol, Long&gt; supplementaryFlags;
275 
276 /************************************************************************
277  * Loading Classes
278  ***********************************************************************/
279 
280     /** Completion for classes to be loaded. Before a class is loaded
281      *  we make sure its enclosing class (if any) is loaded.
282      */
283     private void complete(Symbol sym) throws CompletionFailure {
284         if (sym.kind == TYP) {
285             try {
286                 ClassSymbol c = (ClassSymbol) sym;
287                 dependencies.push(c, CompletionCause.CLASS_READER);
288                 annotate.blockAnnotations();
289                 c.members_field = new Scope.ErrorScope(c); // make sure it&#39;s always defined
290                 completeOwners(c.owner);
291                 completeEnclosing(c);
292                 fillIn(c);
293             } finally {
294                 annotate.unblockAnnotationsNoFlush();
295                 dependencies.pop();
296             }
297         } else if (sym.kind == PCK) {
298             PackageSymbol p = (PackageSymbol)sym;
299             try {
300                 fillIn(p);
301             } catch (IOException ex) {
<a name="3" id="anc3"></a><span class="line-modified">302                 throw new CompletionFailure(</span>
<span class="line-modified">303                         sym,</span>
<span class="line-modified">304                         () -&gt; diagFactory.fragment(</span>
<span class="line-added">305                             Fragments.ExceptionMessage(ex.getLocalizedMessage())),</span>
<span class="line-added">306                         dcfh)</span>
<span class="line-added">307                     .initCause(ex);</span>
308             }
309         }
310         if (!reader.filling)
311             annotate.flush(); // finish attaching annotations
312     }
313 
314     /** complete up through the enclosing package. */
315     private void completeOwners(Symbol o) {
316         if (o.kind != PCK) completeOwners(o.owner);
317         o.complete();
318     }
319 
320     /**
321      * Tries to complete lexically enclosing classes if c looks like a
322      * nested class.  This is similar to completeOwners but handles
323      * the situation when a nested class is accessed directly as it is
324      * possible with the Tree API or javax.lang.model.*.
325      */
326     private void completeEnclosing(ClassSymbol c) {
327         if (c.owner.kind == PCK) {
328             Symbol owner = c.owner;
329             for (Name name : Convert.enclosingCandidates(Convert.shortName(c.name))) {
330                 Symbol encl = owner.members().findFirst(name);
331                 if (encl == null)
332                     encl = syms.getClass(c.packge().modle, TypeSymbol.formFlatName(name, owner));
333                 if (encl != null)
334                     encl.complete();
335             }
336         }
337     }
338 
339     /** Fill in definition of class `c&#39; from corresponding class or
340      *  source file.
341      */
342     void fillIn(ClassSymbol c) {
343         if (completionFailureName == c.fullname) {
<a name="4" id="anc4"></a><span class="line-modified">344             throw new CompletionFailure(</span>
<span class="line-modified">345                 c, () -&gt; diagFactory.fragment(Fragments.UserSelectedCompletionFailure), dcfh);</span>

346         }
347         currentOwner = c;
348         JavaFileObject classfile = c.classfile;
349         if (classfile != null) {
350             JavaFileObject previousClassFile = currentClassFile;
351             Symbol prevOwner = c.owner;
352             Name prevName = c.fullname;
353             try {
354                 if (reader.filling) {
355                     Assert.error(&quot;Filling &quot; + classfile.toUri() + &quot; during &quot; + previousClassFile);
356                 }
357                 currentClassFile = classfile;
358                 if (verbose) {
359                     log.printVerbose(&quot;loading&quot;, currentClassFile.getName());
360                 }
361                 if (classfile.getKind() == JavaFileObject.Kind.CLASS) {
362                     reader.readClassFile(c);
363                     c.flags_field |= getSupplementaryFlags(c);
364                 } else {
365                     if (!sourceCompleter.isTerminal()) {
366                         sourceCompleter.complete(c);
367                     } else {
368                         throw new IllegalStateException(&quot;Source completer required to read &quot;
369                                                         + classfile.toUri());
370                     }
371                 }
372             } catch (BadClassFile cf) {
373                 //the symbol may be partially initialized, purge it:
374                 c.owner = prevOwner;
375                 c.members_field.getSymbols(sym -&gt; sym.kind == TYP).forEach(sym -&gt; {
376                     ClassSymbol csym = (ClassSymbol) sym;
377                     csym.owner = sym.packge();
378                     csym.owner.members().enter(sym);
379                     csym.fullname = sym.flatName();
380                     csym.name = Convert.shortName(sym.flatName());
381                     csym.reset();
382                 });
383                 c.fullname = prevName;
384                 c.name = Convert.shortName(prevName);
385                 c.reset();
386                 throw cf;
387             } finally {
388                 currentClassFile = previousClassFile;
389             }
390         } else {
391             throw classFileNotFound(c);
392         }
393     }
394     // where
395         private CompletionFailure classFileNotFound(ClassSymbol c) {
<a name="5" id="anc5"></a><span class="line-modified">396             return newCompletionFailure(</span>
<span class="line-modified">397                 c, () -&gt; diagFactory.fragment(Fragments.ClassFileNotFound(c.flatname)));</span>

398         }
399         /** Static factory for CompletionFailure objects.
400          *  In practice, only one can be used at a time, so we share one
401          *  to reduce the expense of allocating new exception objects.
402          */
403         private CompletionFailure newCompletionFailure(TypeSymbol c,
<a name="6" id="anc6"></a><span class="line-modified">404                                                        Supplier&lt;JCDiagnostic&gt; diag) {</span>
405             if (!cacheCompletionFailure) {
406                 // log.warning(&quot;proc.messager&quot;,
407                 //             Log.getLocalizedString(&quot;class.file.not.found&quot;, c.flatname));
408                 // c.debug.printStackTrace();
409                 return new CompletionFailure(c, diag, dcfh);
410             } else {
411                 CompletionFailure result = cachedCompletionFailure;
412                 result.sym = c;
<a name="7" id="anc7"></a><span class="line-modified">413                 result.resetDiagnostic(diag);</span>
414                 return result;
415             }
416         }
417         private final CompletionFailure cachedCompletionFailure;
418 
419 
420     /** Load a toplevel class with given fully qualified name
421      *  The class is entered into `classes&#39; only if load was successful.
422      */
423     public ClassSymbol loadClass(ModuleSymbol msym, Name flatname) throws CompletionFailure {
424         Assert.checkNonNull(msym);
425         Name packageName = Convert.packagePart(flatname);
426         PackageSymbol ps = syms.lookupPackage(msym, packageName);
427 
428         Assert.checkNonNull(ps.modle, () -&gt; &quot;msym=&quot; + msym + &quot;; flatName=&quot; + flatname);
429 
430         boolean absent = syms.getClass(ps.modle, flatname) == null;
431         ClassSymbol c = syms.enterClass(ps.modle, flatname);
432 
433         if (c.members_field == null) {
434             try {
435                 c.complete();
436             } catch (CompletionFailure ex) {
437                 if (absent) {
438                     syms.removeClass(ps.modle, flatname);
439                     ex.dcfh.classSymbolRemoved(c);
440                 }
441                 throw ex;
442             }
443         }
444         return c;
445     }
446 
447 /************************************************************************
448  * Loading Packages
449  ***********************************************************************/
450 
451     /** Include class corresponding to given class file in package,
452      *  unless (1) we already have one the same kind (.class or .java), or
453      *         (2) we have one of the other kind, and the given class file
454      *             is older.
455      */
456     protected void includeClassFile(PackageSymbol p, JavaFileObject file) {
457         if ((p.flags_field &amp; EXISTS) == 0)
458             for (Symbol q = p; q != null &amp;&amp; q.kind == PCK; q = q.owner)
459                 q.flags_field |= EXISTS;
460         JavaFileObject.Kind kind = file.getKind();
461         int seen;
462         if (kind == JavaFileObject.Kind.CLASS)
463             seen = CLASS_SEEN;
464         else
465             seen = SOURCE_SEEN;
466         String binaryName = fileManager.inferBinaryName(currentLoc, file);
467         int lastDot = binaryName.lastIndexOf(&quot;.&quot;);
468         Name classname = names.fromString(binaryName.substring(lastDot + 1));
469         boolean isPkgInfo = classname == names.package_info;
470         ClassSymbol c = isPkgInfo
471             ? p.package_info
472             : (ClassSymbol) p.members_field.findFirst(classname);
473         if (c == null) {
474             c = syms.enterClass(p.modle, classname, p);
475             if (c.classfile == null) // only update the file if&#39;s it&#39;s newly created
476                 c.classfile = file;
477             if (isPkgInfo) {
478                 p.package_info = c;
479             } else {
480                 if (c.owner == p)  // it might be an inner class
481                     p.members_field.enter(c);
482             }
483         } else if (!preferCurrent &amp;&amp; c.classfile != null &amp;&amp; (c.flags_field &amp; seen) == 0) {
484             // if c.classfile == null, we are currently compiling this class
485             // and no further action is necessary.
486             // if (c.flags_field &amp; seen) != 0, we have already encountered
487             // a file of the same kind; again no further action is necessary.
488             if ((c.flags_field &amp; (CLASS_SEEN | SOURCE_SEEN)) != 0)
489                 c.classfile = preferredFileObject(file, c.classfile);
490         }
491         c.flags_field |= seen;
492     }
493 
494     /** Implement policy to choose to derive information from a source
495      *  file or a class file when both are present.  May be overridden
496      *  by subclasses.
497      */
498     protected JavaFileObject preferredFileObject(JavaFileObject a,
499                                            JavaFileObject b) {
500 
501         if (preferSource)
502             return (a.getKind() == JavaFileObject.Kind.SOURCE) ? a : b;
503         else {
504             long adate = a.getLastModified();
505             long bdate = b.getLastModified();
506             // 6449326: policy for bad lastModifiedTime in ClassReader
507             //assert adate &gt;= 0 &amp;&amp; bdate &gt;= 0;
508             return (adate &gt; bdate) ? a : b;
509         }
510     }
511 
512     /**
513      * specifies types of files to be read when filling in a package symbol
514      */
515     // Note: overridden by JavadocClassFinder
516     protected EnumSet&lt;JavaFileObject.Kind&gt; getPackageFileKinds() {
517         return EnumSet.of(JavaFileObject.Kind.CLASS, JavaFileObject.Kind.SOURCE);
518     }
519 
520     /**
521      * this is used to support javadoc
522      */
523     protected void extraFileActions(PackageSymbol pack, JavaFileObject fe) {
524     }
525 
526     protected Location currentLoc; // FIXME
527 
528     private boolean verbosePath = true;
529 
530     // Set to true when the currently selected file should be kept
531     private boolean preferCurrent;
532 
533     /** Load directory of package into members scope.
534      */
535     private void fillIn(PackageSymbol p) throws IOException {
536         if (p.members_field == null)
537             p.members_field = WriteableScope.create(p);
538 
539         ModuleSymbol msym = p.modle;
540 
541         Assert.checkNonNull(msym, p::toString);
542 
543         msym.complete();
544 
545         if (msym == syms.noModule) {
546             preferCurrent = false;
547             if (userPathsFirst) {
548                 scanUserPaths(p, true);
549                 preferCurrent = true;
550                 scanPlatformPath(p);
551             } else {
552                 scanPlatformPath(p);
553                 scanUserPaths(p, true);
554             }
555         } else if (msym.classLocation == StandardLocation.CLASS_PATH) {
556             scanUserPaths(p, msym.sourceLocation == StandardLocation.SOURCE_PATH);
557         } else {
558             scanModulePaths(p, msym);
559         }
560     }
561 
562     // TODO: for now, this is a much simplified form of scanUserPaths
563     // and (deliberately) does not default sourcepath to classpath.
564     // But, we need to think about retaining existing behavior for
565     // -classpath and -sourcepath for single module mode.
566     // One plausible solution is to detect if the module&#39;s sourceLocation
567     // is the same as the module&#39;s classLocation.
568     private void scanModulePaths(PackageSymbol p, ModuleSymbol msym) throws IOException {
569         Set&lt;JavaFileObject.Kind&gt; kinds = getPackageFileKinds();
570 
571         Set&lt;JavaFileObject.Kind&gt; classKinds = EnumSet.copyOf(kinds);
572         classKinds.remove(JavaFileObject.Kind.SOURCE);
573         boolean wantClassFiles = !classKinds.isEmpty();
574 
575         Set&lt;JavaFileObject.Kind&gt; sourceKinds = EnumSet.copyOf(kinds);
576         sourceKinds.remove(JavaFileObject.Kind.CLASS);
577         boolean wantSourceFiles = !sourceKinds.isEmpty();
578 
579         String packageName = p.fullname.toString();
580 
581         Location classLocn = msym.classLocation;
582         Location sourceLocn = msym.sourceLocation;
583         Location patchLocn = msym.patchLocation;
584         Location patchOutLocn = msym.patchOutputLocation;
585 
586         boolean prevPreferCurrent = preferCurrent;
587 
588         try {
589             preferCurrent = false;
590             if (wantClassFiles &amp;&amp; (patchOutLocn != null)) {
591                 fillIn(p, patchOutLocn,
592                        list(patchOutLocn,
593                             p,
594                             packageName,
595                             classKinds));
596             }
597             if ((wantClassFiles || wantSourceFiles) &amp;&amp; (patchLocn != null)) {
598                 Set&lt;JavaFileObject.Kind&gt; combined = EnumSet.noneOf(JavaFileObject.Kind.class);
599                 combined.addAll(classKinds);
600                 combined.addAll(sourceKinds);
601                 fillIn(p, patchLocn,
602                        list(patchLocn,
603                             p,
604                             packageName,
605                             combined));
606             }
607             preferCurrent = true;
608             if (wantClassFiles &amp;&amp; (classLocn != null)) {
609                 fillIn(p, classLocn,
610                        list(classLocn,
611                             p,
612                             packageName,
613                             classKinds));
614             }
615             if (wantSourceFiles &amp;&amp; (sourceLocn != null)) {
616                 fillIn(p, sourceLocn,
617                        list(sourceLocn,
618                             p,
619                             packageName,
620                             sourceKinds));
621             }
622         } finally {
623             preferCurrent = prevPreferCurrent;
624         }
625     }
626 
627     /**
628      * Scans class path and source path for files in given package.
629      */
630     private void scanUserPaths(PackageSymbol p, boolean includeSourcePath) throws IOException {
631         Set&lt;JavaFileObject.Kind&gt; kinds = getPackageFileKinds();
632 
633         Set&lt;JavaFileObject.Kind&gt; classKinds = EnumSet.copyOf(kinds);
634         classKinds.remove(JavaFileObject.Kind.SOURCE);
635         boolean wantClassFiles = !classKinds.isEmpty();
636 
637         Set&lt;JavaFileObject.Kind&gt; sourceKinds = EnumSet.copyOf(kinds);
638         sourceKinds.remove(JavaFileObject.Kind.CLASS);
639         boolean wantSourceFiles = !sourceKinds.isEmpty();
640 
641         boolean haveSourcePath = includeSourcePath &amp;&amp; fileManager.hasLocation(SOURCE_PATH);
642 
643         if (verbose &amp;&amp; verbosePath) {
644             verbosePath = false; // print once per compile
645             if (fileManager instanceof StandardJavaFileManager) {
646                 StandardJavaFileManager fm = (StandardJavaFileManager)fileManager;
647                 if (haveSourcePath &amp;&amp; wantSourceFiles) {
648                     List&lt;Path&gt; path = List.nil();
649                     for (Path sourcePath : fm.getLocationAsPaths(SOURCE_PATH)) {
650                         path = path.prepend(sourcePath);
651                     }
652                     log.printVerbose(&quot;sourcepath&quot;, path.reverse().toString());
653                 } else if (wantSourceFiles) {
654                     List&lt;Path&gt; path = List.nil();
655                     for (Path classPath : fm.getLocationAsPaths(CLASS_PATH)) {
656                         path = path.prepend(classPath);
657                     }
658                     log.printVerbose(&quot;sourcepath&quot;, path.reverse().toString());
659                 }
660                 if (wantClassFiles) {
661                     List&lt;Path&gt; path = List.nil();
662                     for (Path platformPath : fm.getLocationAsPaths(PLATFORM_CLASS_PATH)) {
663                         path = path.prepend(platformPath);
664                     }
665                     for (Path classPath : fm.getLocationAsPaths(CLASS_PATH)) {
666                         path = path.prepend(classPath);
667                     }
668                     log.printVerbose(&quot;classpath&quot;,  path.reverse().toString());
669                 }
670             }
671         }
672 
673         String packageName = p.fullname.toString();
674         if (wantSourceFiles &amp;&amp; !haveSourcePath) {
675             fillIn(p, CLASS_PATH,
676                    list(CLASS_PATH,
677                         p,
678                         packageName,
679                         kinds));
680         } else {
681             if (wantClassFiles)
682                 fillIn(p, CLASS_PATH,
683                        list(CLASS_PATH,
684                             p,
685                             packageName,
686                             classKinds));
687             if (wantSourceFiles)
688                 fillIn(p, SOURCE_PATH,
689                        list(SOURCE_PATH,
690                             p,
691                             packageName,
692                             sourceKinds));
693         }
694     }
695 
696     /**
697      * Scans platform class path for files in given package.
698      */
699     private void scanPlatformPath(PackageSymbol p) throws IOException {
700         fillIn(p, PLATFORM_CLASS_PATH,
701                list(PLATFORM_CLASS_PATH,
702                     p,
703                     p.fullname.toString(),
704                     EnumSet.of(JavaFileObject.Kind.CLASS)));
705     }
706     // where
707         @SuppressWarnings(&quot;fallthrough&quot;)
708         private void fillIn(PackageSymbol p,
709                             Location location,
710                             Iterable&lt;JavaFileObject&gt; files)
711         {
712             currentLoc = location;
713             for (JavaFileObject fo : files) {
714                 switch (fo.getKind()) {
715                 case OTHER:
716                     extraFileActions(p, fo);
717                     break;
718                 case CLASS:
719                 case SOURCE: {
720                     // TODO pass binaryName to includeClassFile
721                     String binaryName = fileManager.inferBinaryName(currentLoc, fo);
722                     String simpleName = binaryName.substring(binaryName.lastIndexOf(&quot;.&quot;) + 1);
723                     if (SourceVersion.isIdentifier(simpleName) ||
724                         simpleName.equals(&quot;package-info&quot;))
725                         includeClassFile(p, fo);
726                     break;
727                 }
728                 default:
729                     extraFileActions(p, fo);
730                     break;
731                 }
732             }
733         }
734 
735         Iterable&lt;JavaFileObject&gt; list(Location location,
736                                       PackageSymbol p,
737                                       String packageName,
738                                       Set&lt;Kind&gt; kinds) throws IOException {
739             Iterable&lt;JavaFileObject&gt; listed = fileManager.list(location,
740                                                                packageName,
741                                                                EnumSet.allOf(Kind.class),
742                                                                false);
743             return () -&gt; new Iterator&lt;JavaFileObject&gt;() {
744                 private final Iterator&lt;JavaFileObject&gt; original = listed.iterator();
745                 private JavaFileObject next;
746                 @Override
747                 public boolean hasNext() {
748                     if (next == null) {
749                         while (original.hasNext()) {
750                             JavaFileObject fo = original.next();
751 
752                             if (fo.getKind() != Kind.CLASS &amp;&amp;
753                                 fo.getKind() != Kind.SOURCE) {
754                                 p.flags_field |= Flags.HAS_RESOURCE;
755                             }
756 
757                             if (kinds.contains(fo.getKind())) {
758                                 next = fo;
759                                 break;
760                             }
761                         }
762                     }
763                     return next != null;
764                 }
765 
766                 @Override
767                 public JavaFileObject next() {
768                     if (!hasNext())
769                         throw new NoSuchElementException();
770                     JavaFileObject result = next;
771                     next = null;
772                     return result;
773                 }
774 
775             };
776         }
777 
778     /**
779      * Used for bad class definition files, such as bad .class files or
780      * for .java files with unexpected package or class names.
781      */
782     public static class BadClassFile extends CompletionFailure {
783         private static final long serialVersionUID = 0;
784 
785         public BadClassFile(TypeSymbol sym, JavaFileObject file, JCDiagnostic diag,
786                 JCDiagnostic.Factory diagFactory, DeferredCompletionFailureHandler dcfh) {
<a name="8" id="anc8"></a><span class="line-modified">787             super(sym, () -&gt; createBadClassFileDiagnostic(file, diag, diagFactory), dcfh);</span>
788         }
789         // where
790         private static JCDiagnostic createBadClassFileDiagnostic(
791                 JavaFileObject file, JCDiagnostic diag, JCDiagnostic.Factory diagFactory) {
792             String key = (file.getKind() == JavaFileObject.Kind.SOURCE
793                         ? &quot;bad.source.file.header&quot; : &quot;bad.class.file.header&quot;);
794             return diagFactory.fragment(key, file, diag);
795         }
796     }
797 
798     public static class BadEnclosingMethodAttr extends BadClassFile {
799         private static final long serialVersionUID = 0;
800 
801         public BadEnclosingMethodAttr(TypeSymbol sym, JavaFileObject file, JCDiagnostic diag,
802                 JCDiagnostic.Factory diagFactory, DeferredCompletionFailureHandler dcfh) {
803             super(sym, file, diag, diagFactory, dcfh);
804         }
805     }
806 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
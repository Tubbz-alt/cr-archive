<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.util.ArrayDeque;
  30 import java.util.Collections;
  31 import java.util.EnumMap;
  32 import java.util.Map;
  33 
  34 import javax.lang.model.type.*;
  35 
  36 import com.sun.tools.javac.code.Symbol.*;
  37 import com.sun.tools.javac.code.TypeMetadata.Entry;
  38 import com.sun.tools.javac.code.Types.TypeMapping;
<a name="1" id="anc1"></a><span class="line-added">  39 import com.sun.tools.javac.code.Types.UniqueType;</span>
  40 import com.sun.tools.javac.comp.Infer.IncorporationAction;
<a name="2" id="anc2"></a><span class="line-added">  41 import com.sun.tools.javac.jvm.ClassFile;</span>
<span class="line-added">  42 import com.sun.tools.javac.jvm.PoolConstant;</span>
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import static com.sun.tools.javac.code.BoundKind.*;
  47 import static com.sun.tools.javac.code.Flags.*;
  48 import static com.sun.tools.javac.code.Kinds.Kind.*;
  49 import static com.sun.tools.javac.code.TypeTag.*;
  50 
  51 /** This class represents Java types. The class itself defines the behavior of
  52  *  the following types:
  53  *  &lt;pre&gt;
  54  *  base types (tags: BYTE, CHAR, SHORT, INT, LONG, FLOAT, DOUBLE, BOOLEAN),
  55  *  type `void&#39; (tag: VOID),
  56  *  the bottom type (tag: BOT),
  57  *  the missing type (tag: NONE).
  58  *  &lt;/pre&gt;
  59  *  &lt;p&gt;The behavior of the following types is defined in subclasses, which are
  60  *  all static inner classes of this class:
  61  *  &lt;pre&gt;
  62  *  class types (tag: CLASS, class: ClassType),
  63  *  array types (tag: ARRAY, class: ArrayType),
  64  *  method types (tag: METHOD, class: MethodType),
  65  *  package types (tag: PACKAGE, class: PackageType),
  66  *  type variables (tag: TYPEVAR, class: TypeVar),
  67  *  type arguments (tag: WILDCARD, class: WildcardType),
  68  *  generic method types (tag: FORALL, class: ForAll),
  69  *  the error type (tag: ERROR, class: ErrorType).
  70  *  &lt;/pre&gt;
  71  *
  72  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  73  *  If you write code that depends on this, you do so at your own risk.
  74  *  This code and its internal interfaces are subject to change or
  75  *  deletion without notice.&lt;/b&gt;
  76  *
  77  *  @see TypeTag
  78  */
<a name="3" id="anc3"></a><span class="line-modified">  79 public abstract class Type extends AnnoConstruct implements TypeMirror, PoolConstant {</span>
  80 
  81     /**
  82      * Type metadata,  Should be {@code null} for the default value.
  83      *
  84      * Note: it is an invariant that for any {@code TypeMetadata}
  85      * class, a given {@code Type} may have at most one metadata array
  86      * entry of that class.
  87      */
  88     protected final TypeMetadata metadata;
  89 
  90     public TypeMetadata getMetadata() {
  91         return metadata;
  92     }
  93 
  94     public Entry getMetadataOfKind(final Entry.Kind kind) {
  95         return metadata != null ? metadata.get(kind) : null;
  96     }
  97 
  98     /** Constant type: no type at all. */
  99     public static final JCNoType noType = new JCNoType() {
 100         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 101         public String toString() {
 102             return &quot;none&quot;;
 103         }
 104     };
 105 
 106     /** Constant type: special type to be used during recovery of deferred expressions. */
 107     public static final JCNoType recoveryType = new JCNoType(){
 108         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 109         public String toString() {
 110             return &quot;recovery&quot;;
 111         }
 112     };
 113 
 114     /** Constant type: special type to be used for marking stuck trees. */
 115     public static final JCNoType stuckType = new JCNoType() {
 116         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 117         public String toString() {
 118             return &quot;stuck&quot;;
 119         }
 120     };
 121 
 122     /** If this switch is turned on, the names of type variables
 123      *  and anonymous classes are printed with hashcodes appended.
 124      */
 125     public static boolean moreInfo = false;
 126 
 127     /** The defining class / interface / package / type variable.
 128      */
 129     public TypeSymbol tsym;
 130 
<a name="4" id="anc4"></a><span class="line-added"> 131     @Override</span>
<span class="line-added"> 132     public int poolTag() {</span>
<span class="line-added"> 133         throw new AssertionError(&quot;Invalid pool entry&quot;);</span>
<span class="line-added"> 134     }</span>
<span class="line-added"> 135 </span>
<span class="line-added"> 136     @Override</span>
<span class="line-added"> 137     public Object poolKey(Types types) {</span>
<span class="line-added"> 138         return new UniqueType(this, types);</span>
<span class="line-added"> 139     }</span>
<span class="line-added"> 140 </span>
 141     /**
 142      * Checks if the current type tag is equal to the given tag.
 143      * @return true if tag is equal to the current type tag.
 144      */
 145     public boolean hasTag(TypeTag tag) {
 146         return tag == getTag();
 147     }
 148 
 149     /**
 150      * Returns the current type tag.
 151      * @return the value of the current type tag.
 152      */
 153     public abstract TypeTag getTag();
 154 
 155     public boolean isNumeric() {
 156         return false;
 157     }
 158 
 159     public boolean isIntegral() {
 160         return false;
 161     }
 162 
 163     public boolean isPrimitive() {
 164         return false;
 165     }
 166 
 167     public boolean isPrimitiveOrVoid() {
 168         return false;
 169     }
 170 
 171     public boolean isReference() {
 172         return false;
 173     }
 174 
 175     public boolean isNullOrReference() {
 176         return false;
 177     }
 178 
 179     public boolean isPartial() {
 180         return false;
 181     }
 182 
 183     /**
 184      * The constant value of this type, null if this type does not
 185      * have a constant value attribute. Only primitive types and
 186      * strings (ClassType) can have a constant value attribute.
 187      * @return the constant value attribute of this type
 188      */
 189     public Object constValue() {
 190         return null;
 191     }
 192 
 193     /** Is this a constant type whose value is false?
 194      */
 195     public boolean isFalse() {
 196         return false;
 197     }
 198 
 199     /** Is this a constant type whose value is true?
 200      */
 201     public boolean isTrue() {
 202         return false;
 203     }
 204 
 205     /**
 206      * Get the representation of this type used for modelling purposes.
 207      * By default, this is itself. For ErrorType, a different value
 208      * may be provided.
 209      */
 210     public Type getModelType() {
 211         return this;
 212     }
 213 
 214     public static List&lt;Type&gt; getModelTypes(List&lt;Type&gt; ts) {
 215         ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 216         for (Type t: ts)
 217             lb.append(t.getModelType());
 218         return lb.toList();
 219     }
 220 
 221     /**For ErrorType, returns the original type, otherwise returns the type itself.
 222      */
 223     public Type getOriginalType() {
 224         return this;
 225     }
 226 
 227     public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) { return v.visitType(this, s); }
 228 
 229     /** Define a type given its tag, type symbol, and type annotations
 230      */
 231 
 232     public Type(TypeSymbol tsym, TypeMetadata metadata) {
 233         Assert.checkNonNull(metadata);
 234         this.tsym = tsym;
 235         this.metadata = metadata;
 236     }
 237 
 238     /**
 239      * A subclass of {@link Types.TypeMapping} which applies a mapping recursively to the subterms
 240      * of a given type expression. This mapping returns the original type is no changes occurred
 241      * when recursively mapping the original type&#39;s subterms.
 242      */
 243     public static abstract class StructuralTypeMapping&lt;S&gt; extends Types.TypeMapping&lt;S&gt; {
 244 
 245         @Override
 246         public Type visitClassType(ClassType t, S s) {
 247             Type outer = t.getEnclosingType();
 248             Type outer1 = visit(outer, s);
 249             List&lt;Type&gt; typarams = t.getTypeArguments();
 250             List&lt;Type&gt; typarams1 = visit(typarams, s);
 251             if (outer1 == outer &amp;&amp; typarams1 == typarams) return t;
 252             else return new ClassType(outer1, typarams1, t.tsym, t.metadata) {
 253                 @Override
 254                 protected boolean needsStripping() {
 255                     return true;
 256                 }
 257             };
 258         }
 259 
 260         @Override
 261         public Type visitWildcardType(WildcardType wt, S s) {
 262             Type t = wt.type;
 263             if (t != null)
 264                 t = visit(t, s);
 265             if (t == wt.type)
 266                 return wt;
 267             else
 268                 return new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.metadata) {
 269                     @Override
 270                     protected boolean needsStripping() {
 271                         return true;
 272                     }
 273                 };
 274         }
 275 
 276         @Override
 277         public Type visitArrayType(ArrayType t, S s) {
 278             Type elemtype = t.elemtype;
 279             Type elemtype1 = visit(elemtype, s);
 280             if (elemtype1 == elemtype) return t;
 281             else return new ArrayType(elemtype1, t.tsym, t.metadata) {
 282                 @Override
 283                 protected boolean needsStripping() {
 284                     return true;
 285                 }
 286             };
 287         }
 288 
 289         @Override
 290         public Type visitMethodType(MethodType t, S s) {
 291             List&lt;Type&gt; argtypes = t.argtypes;
 292             Type restype = t.restype;
 293             List&lt;Type&gt; thrown = t.thrown;
 294             List&lt;Type&gt; argtypes1 = visit(argtypes, s);
 295             Type restype1 = visit(restype, s);
 296             List&lt;Type&gt; thrown1 = visit(thrown, s);
 297             if (argtypes1 == argtypes &amp;&amp;
 298                 restype1 == restype &amp;&amp;
 299                 thrown1 == thrown) return t;
 300             else return new MethodType(argtypes1, restype1, thrown1, t.tsym) {
 301                 @Override
 302                 protected boolean needsStripping() {
 303                     return true;
 304                 }
 305             };
 306         }
 307 
 308         @Override
 309         public Type visitForAll(ForAll t, S s) {
 310             return visit(t.qtype, s);
 311         }
 312     }
 313 
 314     /** map a type function over all immediate descendants of this type
 315      */
 316     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping, Z arg) {
 317         return mapping.visit(this, arg);
 318     }
 319 
 320     /** map a type function over all immediate descendants of this type (no arg version)
 321      */
 322     public &lt;Z&gt; Type map(TypeMapping&lt;Z&gt; mapping) {
 323         return mapping.visit(this, null);
 324     }
 325 
 326     /** Define a constant type, of the same kind as this type
 327      *  and with given constant value
 328      */
 329     public Type constType(Object constValue) {
 330         throw new AssertionError();
 331     }
 332 
 333     /**
 334      * If this is a constant type, return its underlying type.
 335      * Otherwise, return the type itself.
 336      */
 337     public Type baseType() {
 338         return this;
 339     }
 340 
 341     /**
 342      * Returns the original version of this type, before metadata were added. This routine is meant
 343      * for internal use only (i.e. {@link Type#equalsIgnoreMetadata(Type)}, {@link Type#stripMetadata});
 344      * it should not be used outside this class.
 345      */
 346     protected Type typeNoMetadata() {
 347         return metadata == TypeMetadata.EMPTY ? this : baseType();
 348     }
 349 
 350     /**
 351      * Create a new copy of this type but with the specified TypeMetadata.
 352      */
 353     public abstract Type cloneWithMetadata(TypeMetadata metadata);
 354 
 355     /**
 356      * Does this type require annotation stripping for API clients?
 357      */
 358     protected boolean needsStripping() {
 359         return false;
 360     }
 361 
 362     /**
 363      * Strip all metadata associated with this type - this could return a new clone of the type.
 364      * This routine is only used to present the correct annotated types back to the users when types
 365      * are accessed through compiler APIs; it should not be used anywhere in the compiler internals
 366      * as doing so might result in performance penalties.
 367      */
 368     public Type stripMetadataIfNeeded() {
 369         return needsStripping() ?
 370                 accept(stripMetadata, null) :
 371                 this;
 372     }
 373 
 374     public Type stripMetadata() {
 375         return accept(stripMetadata, null);
 376     }
 377     //where
 378         private final static TypeMapping&lt;Void&gt; stripMetadata = new StructuralTypeMapping&lt;Void&gt;() {
 379             @Override
 380             public Type visitClassType(ClassType t, Void aVoid) {
 381                 return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);
 382             }
 383 
 384             @Override
 385             public Type visitArrayType(ArrayType t, Void aVoid) {
 386                 return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);
 387             }
 388 
 389             @Override
 390             public Type visitTypeVar(TypeVar t, Void aVoid) {
 391                 return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);
 392             }
 393 
 394             @Override
 395             public Type visitWildcardType(WildcardType wt, Void aVoid) {
 396                 return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);
 397             }
 398         };
 399 
 400     public Type annotatedType(final List&lt;Attribute.TypeCompound&gt; annos) {
 401         final Entry annoMetadata = new TypeMetadata.Annotations(annos);
 402         return cloneWithMetadata(metadata.combine(annoMetadata));
 403     }
 404 
 405     public boolean isAnnotated() {
 406         final TypeMetadata.Annotations metadata =
 407             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 408 
 409         return null != metadata &amp;&amp; !metadata.getAnnotations().isEmpty();
 410     }
 411 
 412     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 413     public List&lt;Attribute.TypeCompound&gt; getAnnotationMirrors() {
 414         final TypeMetadata.Annotations metadata =
 415             (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);
 416 
 417         return metadata == null ? List.nil() : metadata.getAnnotations();
 418     }
 419 
 420 
 421     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 422     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationType) {
 423         return null;
 424     }
 425 
 426 
 427     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 428     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationType) {
 429         @SuppressWarnings(&quot;unchecked&quot;)
 430         A[] tmp = (A[]) java.lang.reflect.Array.newInstance(annotationType, 0);
 431         return tmp;
 432     }
 433 
 434     /** Return the base types of a list of types.
 435      */
 436     public static List&lt;Type&gt; baseTypes(List&lt;Type&gt; ts) {
 437         if (ts.nonEmpty()) {
 438             Type t = ts.head.baseType();
 439             List&lt;Type&gt; baseTypes = baseTypes(ts.tail);
 440             if (t != ts.head || baseTypes != ts.tail)
 441                 return baseTypes.prepend(t);
 442         }
 443         return ts;
 444     }
 445 
 446     protected void appendAnnotationsString(StringBuilder sb,
 447                                          boolean prefix) {
 448         if (isAnnotated()) {
 449             if (prefix) {
 450                 sb.append(&quot; &quot;);
 451             }
 452             sb.append(getAnnotationMirrors());
 453             sb.append(&quot; &quot;);
 454         }
 455     }
 456 
 457     protected void appendAnnotationsString(StringBuilder sb) {
 458         appendAnnotationsString(sb, false);
 459     }
 460 
 461     /** The Java source which this type represents.
 462      */
 463     @DefinedBy(Api.LANGUAGE_MODEL)
 464     public String toString() {
 465         StringBuilder sb = new StringBuilder();
 466         appendAnnotationsString(sb);
 467         if (tsym == null || tsym.name == null) {
 468             sb.append(&quot;&lt;none&gt;&quot;);
 469         } else {
 470             sb.append(tsym.name);
 471         }
 472         if (moreInfo &amp;&amp; hasTag(TYPEVAR)) {
 473             sb.append(hashCode());
 474         }
 475         return sb.toString();
 476     }
 477 
 478     /**
 479      * The Java source which this type list represents.  A List is
<a name="5" id="anc5"></a><span class="line-modified"> 480      * represented as a comma-separated listing of the elements in</span>
 481      * that list.
 482      */
 483     public static String toString(List&lt;Type&gt; ts) {
 484         if (ts.isEmpty()) {
 485             return &quot;&quot;;
 486         } else {
 487             StringBuilder buf = new StringBuilder();
 488             buf.append(ts.head.toString());
 489             for (List&lt;Type&gt; l = ts.tail; l.nonEmpty(); l = l.tail)
 490                 buf.append(&quot;,&quot;).append(l.head.toString());
 491             return buf.toString();
 492         }
 493     }
 494 
 495     /**
 496      * The constant value of this type, converted to String
 497      */
 498     public String stringValue() {
 499         Object cv = Assert.checkNonNull(constValue());
 500         return cv.toString();
 501     }
 502 
 503     /**
 504      * Override this method with care. For most Type instances this should behave as ==.
 505      */
 506     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 507     public boolean equals(Object t) {
 508         return this == t;
 509     }
 510 
 511     public boolean equalsIgnoreMetadata(Type t) {
 512         return typeNoMetadata().equals(t.typeNoMetadata());
 513     }
 514 
 515     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 516     public int hashCode() {
 517         return super.hashCode();
 518     }
 519 
 520     public String argtypes(boolean varargs) {
 521         List&lt;Type&gt; args = getParameterTypes();
 522         if (!varargs) return args.toString();
 523         StringBuilder buf = new StringBuilder();
 524         while (args.tail.nonEmpty()) {
 525             buf.append(args.head);
 526             args = args.tail;
 527             buf.append(&#39;,&#39;);
 528         }
 529         if (args.head.hasTag(ARRAY)) {
 530             buf.append(((ArrayType)args.head).elemtype);
 531             if (args.head.getAnnotationMirrors().nonEmpty()) {
 532                 buf.append(args.head.getAnnotationMirrors());
 533             }
 534             buf.append(&quot;...&quot;);
 535         } else {
 536             buf.append(args.head);
 537         }
 538         return buf.toString();
 539     }
 540 
 541     /** Access methods.
 542      */
 543     public List&lt;Type&gt;        getTypeArguments()  { return List.nil(); }
 544     public Type              getEnclosingType()  { return null; }
 545     public List&lt;Type&gt;        getParameterTypes() { return List.nil(); }
 546     public Type              getReturnType()     { return null; }
 547     public Type              getReceiverType()   { return null; }
 548     public List&lt;Type&gt;        getThrownTypes()    { return List.nil(); }
 549     public Type              getUpperBound()     { return null; }
 550     public Type              getLowerBound()     { return null; }
 551 
 552     /** Navigation methods, these will work for classes, type variables,
 553      *  foralls, but will return null for arrays and methods.
 554      */
 555 
 556    /** Return all parameters of this type and all its outer types in order
 557     *  outer (first) to inner (last).
 558     */
 559     public List&lt;Type&gt; allparams() { return List.nil(); }
 560 
 561     /** Does this type contain &quot;error&quot; elements?
 562      */
 563     public boolean isErroneous() {
 564         return false;
 565     }
 566 
 567     public static boolean isErroneous(List&lt;Type&gt; ts) {
 568         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 569             if (l.head.isErroneous()) return true;
 570         return false;
 571     }
 572 
 573     /** Is this type parameterized?
 574      *  A class type is parameterized if it has some parameters.
 575      *  An array type is parameterized if its element type is parameterized.
 576      *  All other types are not parameterized.
 577      */
 578     public boolean isParameterized() {
 579         return false;
 580     }
 581 
 582     /** Is this type a raw type?
 583      *  A class type is a raw type if it misses some of its parameters.
 584      *  An array type is a raw type if its element type is raw.
 585      *  All other types are not raw.
 586      *  Type validation will ensure that the only raw types
 587      *  in a program are types that miss all their type variables.
 588      */
 589     public boolean isRaw() {
 590         return false;
 591     }
 592 
 593     /**
 594      * A compound type is a special class type whose supertypes are used to store a list
 595      * of component types. There are two kinds of compound types: (i) intersection types
 596      * {@see IntersectionClassType} and (ii) union types {@see UnionClassType}.
 597      */
 598     public boolean isCompound() {
 599         return false;
 600     }
 601 
 602     public boolean isIntersection() {
 603         return false;
 604     }
 605 
 606     public boolean isUnion() {
 607         return false;
 608     }
 609 
 610     public boolean isInterface() {
 611         return (tsym.flags() &amp; INTERFACE) != 0;
 612     }
 613 
 614     public boolean isFinal() {
 615         return (tsym.flags() &amp; FINAL) != 0;
 616     }
 617 
 618     /**
 619      * Does this type contain occurrences of type t?
 620      */
 621     public boolean contains(Type t) {
 622         return t.equalsIgnoreMetadata(this);
 623     }
 624 
 625     public static boolean contains(List&lt;Type&gt; ts, Type t) {
 626         for (List&lt;Type&gt; l = ts;
 627              l.tail != null /*inlined: l.nonEmpty()*/;
 628              l = l.tail)
 629             if (l.head.contains(t)) return true;
 630         return false;
 631     }
 632 
 633     /** Does this type contain an occurrence of some type in &#39;ts&#39;?
 634      */
 635     public boolean containsAny(List&lt;Type&gt; ts) {
 636         for (Type t : ts)
 637             if (this.contains(t)) return true;
 638         return false;
 639     }
 640 
 641     public static boolean containsAny(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
 642         for (Type t : ts1)
 643             if (t.containsAny(ts2)) return true;
 644         return false;
 645     }
 646 
 647     public static List&lt;Type&gt; filter(List&lt;Type&gt; ts, Filter&lt;Type&gt; tf) {
 648         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 649         for (Type t : ts) {
 650             if (tf.accepts(t)) {
 651                 buf.append(t);
 652             }
 653         }
 654         return buf.toList();
 655     }
 656 
 657     public boolean isSuperBound() { return false; }
 658     public boolean isExtendsBound() { return false; }
 659     public boolean isUnbound() { return false; }
 660     public Type withTypeVar(Type t) { return this; }
 661 
 662     /** The underlying method type of this type.
 663      */
 664     public MethodType asMethodType() { throw new AssertionError(); }
 665 
 666     /** Complete loading all classes in this type.
 667      */
 668     public void complete() {}
 669 
 670     public TypeSymbol asElement() {
 671         return tsym;
 672     }
 673 
 674     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 675     public TypeKind getKind() {
 676         return TypeKind.OTHER;
 677     }
 678 
 679     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 680     public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 681         throw new AssertionError();
 682     }
 683 
 684     public static class JCPrimitiveType extends Type
 685             implements javax.lang.model.type.PrimitiveType {
 686 
 687         TypeTag tag;
 688 
 689         public JCPrimitiveType(TypeTag tag, TypeSymbol tsym) {
 690             this(tag, tsym, TypeMetadata.EMPTY);
 691         }
 692 
 693         private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {
 694             super(tsym, metadata);
 695             this.tag = tag;
 696             Assert.check(tag.isPrimitive);
 697         }
 698 
 699         @Override
 700         public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {
 701             return new JCPrimitiveType(tag, tsym, md) {
 702                 @Override
 703                 public Type baseType() { return JCPrimitiveType.this.baseType(); }
 704             };
 705         }
 706 
 707         @Override
 708         public boolean isNumeric() {
 709             return tag != BOOLEAN;
 710         }
 711 
 712         @Override
 713         public boolean isIntegral() {
 714             switch (tag) {
 715                 case CHAR:
 716                 case BYTE:
 717                 case SHORT:
 718                 case INT:
 719                 case LONG:
 720                     return true;
 721                 default:
 722                     return false;
 723             }
 724         }
 725 
 726         @Override
 727         public boolean isPrimitive() {
 728             return true;
 729         }
 730 
 731         @Override
 732         public TypeTag getTag() {
 733             return tag;
 734         }
 735 
 736         @Override
 737         public boolean isPrimitiveOrVoid() {
 738             return true;
 739         }
 740 
 741         /** Define a constant type, of the same kind as this type
 742          *  and with given constant value
 743          */
 744         @Override
 745         public Type constType(Object constValue) {
 746             final Object value = constValue;
 747             return new JCPrimitiveType(tag, tsym, metadata) {
 748                     @Override
 749                     public Object constValue() {
 750                         return value;
 751                     }
 752                     @Override
 753                     public Type baseType() {
 754                         return tsym.type;
 755                     }
 756                 };
 757         }
 758 
 759         /**
 760          * The constant value of this type, converted to String
 761          */
 762         @Override
 763         public String stringValue() {
 764             Object cv = Assert.checkNonNull(constValue());
 765             if (tag == BOOLEAN) {
 766                 return ((Integer) cv).intValue() == 0 ? &quot;false&quot; : &quot;true&quot;;
 767             }
 768             else if (tag == CHAR) {
 769                 return String.valueOf((char) ((Integer) cv).intValue());
 770             }
 771             else {
 772                 return cv.toString();
 773             }
 774         }
 775 
 776         /** Is this a constant type whose value is false?
 777          */
 778         @Override
 779         public boolean isFalse() {
 780             return
 781                 tag == BOOLEAN &amp;&amp;
 782                 constValue() != null &amp;&amp;
 783                 ((Integer)constValue()).intValue() == 0;
 784         }
 785 
 786         /** Is this a constant type whose value is true?
 787          */
 788         @Override
 789         public boolean isTrue() {
 790             return
 791                 tag == BOOLEAN &amp;&amp;
 792                 constValue() != null &amp;&amp;
 793                 ((Integer)constValue()).intValue() != 0;
 794         }
 795 
 796         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 797         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 798             return v.visitPrimitive(this, p);
 799         }
 800 
 801         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 802         public TypeKind getKind() {
 803             switch (tag) {
 804                 case BYTE:      return TypeKind.BYTE;
 805                 case CHAR:      return TypeKind.CHAR;
 806                 case SHORT:     return TypeKind.SHORT;
 807                 case INT:       return TypeKind.INT;
 808                 case LONG:      return TypeKind.LONG;
 809                 case FLOAT:     return TypeKind.FLOAT;
 810                 case DOUBLE:    return TypeKind.DOUBLE;
 811                 case BOOLEAN:   return TypeKind.BOOLEAN;
 812             }
 813             throw new AssertionError();
 814         }
 815 
 816     }
 817 
 818     public static class WildcardType extends Type
 819             implements javax.lang.model.type.WildcardType {
 820 
 821         public Type type;
 822         public BoundKind kind;
 823         public TypeVar bound;
 824 
 825         @Override
 826         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
 827             return v.visitWildcardType(this, s);
 828         }
 829 
 830         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym) {
 831             this(type, kind, tsym, null, TypeMetadata.EMPTY);
 832         }
 833 
 834         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 835                             TypeMetadata metadata) {
 836             this(type, kind, tsym, null, metadata);
 837         }
 838 
 839         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 840                             TypeVar bound) {
 841             this(type, kind, tsym, bound, TypeMetadata.EMPTY);
 842         }
 843 
 844         public WildcardType(Type type, BoundKind kind, TypeSymbol tsym,
 845                             TypeVar bound, TypeMetadata metadata) {
 846             super(tsym, metadata);
 847             this.type = Assert.checkNonNull(type);
 848             this.kind = kind;
 849             this.bound = bound;
 850         }
 851 
 852         @Override
 853         public WildcardType cloneWithMetadata(TypeMetadata md) {
 854             return new WildcardType(type, kind, tsym, bound, md) {
 855                 @Override
 856                 public Type baseType() { return WildcardType.this.baseType(); }
 857             };
 858         }
 859 
 860         @Override
 861         public TypeTag getTag() {
 862             return WILDCARD;
 863         }
 864 
 865         @Override
 866         public boolean contains(Type t) {
 867             return kind != UNBOUND &amp;&amp; type.contains(t);
 868         }
 869 
 870         public boolean isSuperBound() {
 871             return kind == SUPER ||
 872                 kind == UNBOUND;
 873         }
 874         public boolean isExtendsBound() {
 875             return kind == EXTENDS ||
 876                 kind == UNBOUND;
 877         }
 878         public boolean isUnbound() {
 879             return kind == UNBOUND;
 880         }
 881 
 882         @Override
 883         public boolean isReference() {
 884             return true;
 885         }
 886 
 887         @Override
 888         public boolean isNullOrReference() {
 889             return true;
 890         }
 891 
 892         @Override
 893         public Type withTypeVar(Type t) {
 894             //-System.err.println(this+&quot;.withTypeVar(&quot;+t+&quot;);&quot;);//DEBUG
 895             if (bound == t)
 896                 return this;
 897             bound = (TypeVar)t;
 898             return this;
 899         }
 900 
 901         boolean isPrintingBound = false;
 902         @DefinedBy(Api.LANGUAGE_MODEL)
 903         public String toString() {
 904             StringBuilder s = new StringBuilder();
 905             appendAnnotationsString(s);
 906             s.append(kind.toString());
 907             if (kind != UNBOUND)
 908                 s.append(type);
 909             if (moreInfo &amp;&amp; bound != null &amp;&amp; !isPrintingBound)
 910                 try {
 911                     isPrintingBound = true;
 912                     s.append(&quot;{:&quot;).append(bound.getUpperBound()).append(&quot;:}&quot;);
 913                 } finally {
 914                     isPrintingBound = false;
 915                 }
 916             return s.toString();
 917         }
 918 
 919         @DefinedBy(Api.LANGUAGE_MODEL)
 920         public Type getExtendsBound() {
 921             if (kind == EXTENDS)
 922                 return type;
 923             else
 924                 return null;
 925         }
 926 
 927         @DefinedBy(Api.LANGUAGE_MODEL)
 928         public Type getSuperBound() {
 929             if (kind == SUPER)
 930                 return type;
 931             else
 932                 return null;
 933         }
 934 
 935         @DefinedBy(Api.LANGUAGE_MODEL)
 936         public TypeKind getKind() {
 937             return TypeKind.WILDCARD;
 938         }
 939 
 940         @DefinedBy(Api.LANGUAGE_MODEL)
 941         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
 942             return v.visitWildcard(this, p);
 943         }
 944     }
 945 
<a name="6" id="anc6"></a><span class="line-modified"> 946     public static class ClassType extends Type implements DeclaredType, LoadableConstant,</span>
 947                                                           javax.lang.model.type.ErrorType {
 948 
 949         /** The enclosing type of this type. If this is the type of an inner
 950          *  class, outer_field refers to the type of its enclosing
 951          *  instance class, in all other cases it refers to noType.
 952          */
 953         private Type outer_field;
 954 
 955         /** The type parameters of this type (to be set once class is loaded).
 956          */
 957         public List&lt;Type&gt; typarams_field;
 958 
 959         /** A cache variable for the type parameters of this type,
 960          *  appended to all parameters of its enclosing class.
 961          *  @see #allparams
 962          */
 963         public List&lt;Type&gt; allparams_field;
 964 
 965         /** The supertype of this class (to be set once class is loaded).
 966          */
 967         public Type supertype_field;
 968 
 969         /** The interfaces of this class (to be set once class is loaded).
 970          */
 971         public List&lt;Type&gt; interfaces_field;
 972 
 973         /** All the interfaces of this class, including missing ones.
 974          */
 975         public List&lt;Type&gt; all_interfaces_field;
 976 
 977         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym) {
 978             this(outer, typarams, tsym, TypeMetadata.EMPTY);
 979         }
 980 
 981         public ClassType(Type outer, List&lt;Type&gt; typarams, TypeSymbol tsym,
 982                          TypeMetadata metadata) {
 983             super(tsym, metadata);
 984             this.outer_field = outer;
 985             this.typarams_field = typarams;
 986             this.allparams_field = null;
 987             this.supertype_field = null;
 988             this.interfaces_field = null;
 989         }
 990 
<a name="7" id="anc7"></a><span class="line-added"> 991         public int poolTag() {</span>
<span class="line-added"> 992             return ClassFile.CONSTANT_Class;</span>
<span class="line-added"> 993         }</span>
<span class="line-added"> 994 </span>
 995         @Override
 996         public ClassType cloneWithMetadata(TypeMetadata md) {
 997             return new ClassType(outer_field, typarams_field, tsym, md) {
 998                 @Override
 999                 public Type baseType() { return ClassType.this.baseType(); }
1000             };
1001         }
1002 
1003         @Override
1004         public TypeTag getTag() {
1005             return CLASS;
1006         }
1007 
1008         @Override
1009         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1010             return v.visitClassType(this, s);
1011         }
1012 
1013         public Type constType(Object constValue) {
1014             final Object value = constValue;
1015             return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {
1016                     @Override
1017                     public Object constValue() {
1018                         return value;
1019                     }
1020                     @Override
1021                     public Type baseType() {
1022                         return tsym.type;
1023                     }
1024                 };
1025         }
1026 
1027         /** The Java source which this type represents.
1028          */
1029         @DefinedBy(Api.LANGUAGE_MODEL)
1030         public String toString() {
1031             StringBuilder buf = new StringBuilder();
1032             if (getEnclosingType().hasTag(CLASS) &amp;&amp; tsym.owner.kind == TYP) {
1033                 buf.append(getEnclosingType().toString());
1034                 buf.append(&quot;.&quot;);
1035                 appendAnnotationsString(buf);
1036                 buf.append(className(tsym, false));
1037             } else {
1038                 appendAnnotationsString(buf);
1039                 buf.append(className(tsym, true));
1040             }
1041 
1042             if (getTypeArguments().nonEmpty()) {
1043                 buf.append(&#39;&lt;&#39;);
1044                 buf.append(getTypeArguments().toString());
1045                 buf.append(&quot;&gt;&quot;);
1046             }
1047             return buf.toString();
1048         }
1049 //where
1050             private String className(Symbol sym, boolean longform) {
1051                 if (sym.name.isEmpty() &amp;&amp; (sym.flags() &amp; COMPOUND) != 0) {
1052                     StringBuilder s = new StringBuilder(supertype_field.toString());
1053                     for (List&lt;Type&gt; is=interfaces_field; is.nonEmpty(); is = is.tail) {
1054                         s.append(&quot;&amp;&quot;);
1055                         s.append(is.head.toString());
1056                     }
1057                     return s.toString();
1058                 } else if (sym.name.isEmpty()) {
1059                     String s;
1060                     ClassType norm = (ClassType) tsym.type;
1061                     if (norm == null) {
1062                         s = Log.getLocalizedString(&quot;anonymous.class&quot;, (Object)null);
1063                     } else if (norm.interfaces_field != null &amp;&amp; norm.interfaces_field.nonEmpty()) {
1064                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1065                                                    norm.interfaces_field.head);
1066                     } else {
1067                         s = Log.getLocalizedString(&quot;anonymous.class&quot;,
1068                                                    norm.supertype_field);
1069                     }
1070                     if (moreInfo)
1071                         s += String.valueOf(sym.hashCode());
1072                     return s;
1073                 } else if (longform) {
1074                     return sym.getQualifiedName().toString();
1075                 } else {
1076                     return sym.name.toString();
1077                 }
1078             }
1079 
1080         @DefinedBy(Api.LANGUAGE_MODEL)
1081         public List&lt;Type&gt; getTypeArguments() {
1082             if (typarams_field == null) {
1083                 complete();
1084                 if (typarams_field == null)
1085                     typarams_field = List.nil();
1086             }
1087             return typarams_field;
1088         }
1089 
1090         public boolean hasErasedSupertypes() {
1091             return isRaw();
1092         }
1093 
1094         @DefinedBy(Api.LANGUAGE_MODEL)
1095         public Type getEnclosingType() {
1096             return outer_field;
1097         }
1098 
1099         public void setEnclosingType(Type outer) {
1100             outer_field = outer;
1101         }
1102 
1103         public List&lt;Type&gt; allparams() {
1104             if (allparams_field == null) {
1105                 allparams_field = getTypeArguments().prependList(getEnclosingType().allparams());
1106             }
1107             return allparams_field;
1108         }
1109 
1110         public boolean isErroneous() {
1111             return
1112                 getEnclosingType().isErroneous() ||
1113                 isErroneous(getTypeArguments()) ||
1114                 this != tsym.type &amp;&amp; tsym.type.isErroneous();
1115         }
1116 
1117         public boolean isParameterized() {
1118             return allparams().tail != null;
1119             // optimization, was: allparams().nonEmpty();
1120         }
1121 
1122         @Override
1123         public boolean isReference() {
1124             return true;
1125         }
1126 
1127         @Override
1128         public boolean isNullOrReference() {
1129             return true;
1130         }
1131 
1132         /** A cache for the rank. */
1133         int rank_field = -1;
1134 
1135         /** A class type is raw if it misses some
1136          *  of its type parameter sections.
1137          *  After validation, this is equivalent to:
1138          *  {@code allparams.isEmpty() &amp;&amp; tsym.type.allparams.nonEmpty(); }
1139          */
1140         public boolean isRaw() {
1141             return
1142                 this != tsym.type &amp;&amp; // necessary, but not sufficient condition
1143                 tsym.type.allparams().nonEmpty() &amp;&amp;
1144                 allparams().isEmpty();
1145         }
1146 
1147         public boolean contains(Type elem) {
1148             return
1149                 elem.equalsIgnoreMetadata(this)
1150                 || (isParameterized()
1151                     &amp;&amp; (getEnclosingType().contains(elem) || contains(getTypeArguments(), elem)))
1152                 || (isCompound()
1153                     &amp;&amp; (supertype_field.contains(elem) || contains(interfaces_field, elem)));
1154         }
1155 
1156         public void complete() {
1157             tsym.complete();
1158         }
1159 
1160         @DefinedBy(Api.LANGUAGE_MODEL)
1161         public TypeKind getKind() {
1162             tsym.apiComplete();
1163             return tsym.kind == TYP ? TypeKind.DECLARED : TypeKind.ERROR;
1164         }
1165 
1166         @DefinedBy(Api.LANGUAGE_MODEL)
1167         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1168             return v.visitDeclared(this, p);
1169         }
1170     }
1171 
1172     public static class ErasedClassType extends ClassType {
1173         public ErasedClassType(Type outer, TypeSymbol tsym,
1174                                TypeMetadata metadata) {
1175             super(outer, List.nil(), tsym, metadata);
1176         }
1177 
1178         @Override
1179         public boolean hasErasedSupertypes() {
1180             return true;
1181         }
1182     }
1183 
1184     // a clone of a ClassType that knows about the alternatives of a union type.
1185     public static class UnionClassType extends ClassType implements UnionType {
1186         final List&lt;? extends Type&gt; alternatives_field;
1187 
1188         public UnionClassType(ClassType ct, List&lt;? extends Type&gt; alternatives) {
1189             // Presently no way to refer to this type directly, so we
1190             // cannot put annotations directly on it.
1191             super(ct.outer_field, ct.typarams_field, ct.tsym);
1192             allparams_field = ct.allparams_field;
1193             supertype_field = ct.supertype_field;
1194             interfaces_field = ct.interfaces_field;
1195             all_interfaces_field = ct.interfaces_field;
1196             alternatives_field = alternatives;
1197         }
1198 
1199         @Override
1200         public UnionClassType cloneWithMetadata(TypeMetadata md) {
1201             throw new AssertionError(&quot;Cannot add metadata to a union type&quot;);
1202         }
1203 
1204         public Type getLub() {
1205             return tsym.type;
1206         }
1207 
1208         @DefinedBy(Api.LANGUAGE_MODEL)
1209         public java.util.List&lt;? extends TypeMirror&gt; getAlternatives() {
1210             return Collections.unmodifiableList(alternatives_field);
1211         }
1212 
1213         @Override
1214         public boolean isUnion() {
1215             return true;
1216         }
1217 
1218         @Override
1219         public boolean isCompound() {
1220             return getLub().isCompound();
1221         }
1222 
1223         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1224         public TypeKind getKind() {
1225             return TypeKind.UNION;
1226         }
1227 
1228         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1229         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1230             return v.visitUnion(this, p);
1231         }
1232 
1233         public Iterable&lt;? extends Type&gt; getAlternativeTypes() {
1234             return alternatives_field;
1235         }
1236     }
1237 
1238     // a clone of a ClassType that knows about the bounds of an intersection type.
1239     public static class IntersectionClassType extends ClassType implements IntersectionType {
1240 
1241         public boolean allInterfaces;
1242 
1243         public IntersectionClassType(List&lt;Type&gt; bounds, ClassSymbol csym, boolean allInterfaces) {
1244             // Presently no way to refer to this type directly, so we
1245             // cannot put annotations directly on it.
1246             super(Type.noType, List.nil(), csym);
1247             this.allInterfaces = allInterfaces;
1248             Assert.check((csym.flags() &amp; COMPOUND) != 0);
1249             supertype_field = bounds.head;
1250             interfaces_field = bounds.tail;
1251             Assert.check(!supertype_field.tsym.isCompleted() ||
1252                     !supertype_field.isInterface(), supertype_field);
1253         }
1254 
1255         @Override
1256         public IntersectionClassType cloneWithMetadata(TypeMetadata md) {
1257             throw new AssertionError(&quot;Cannot add metadata to an intersection type&quot;);
1258         }
1259 
1260         @DefinedBy(Api.LANGUAGE_MODEL)
1261         public java.util.List&lt;? extends TypeMirror&gt; getBounds() {
1262             return Collections.unmodifiableList(getExplicitComponents());
1263         }
1264 
1265         @Override
1266         public boolean isCompound() {
1267             return true;
1268         }
1269 
1270         public List&lt;Type&gt; getComponents() {
1271             return interfaces_field.prepend(supertype_field);
1272         }
1273 
1274         @Override
1275         public boolean isIntersection() {
1276             return true;
1277         }
1278 
1279         public List&lt;Type&gt; getExplicitComponents() {
1280             return allInterfaces ?
1281                     interfaces_field :
1282                     getComponents();
1283         }
1284 
1285         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1286         public TypeKind getKind() {
1287             return TypeKind.INTERSECTION;
1288         }
1289 
1290         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1291         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1292             return v.visitIntersection(this, p);
1293         }
1294     }
1295 
1296     public static class ArrayType extends Type
<a name="8" id="anc8"></a><span class="line-modified">1297             implements LoadableConstant, javax.lang.model.type.ArrayType {</span>
1298 
1299         public Type elemtype;
1300 
1301         public ArrayType(Type elemtype, TypeSymbol arrayClass) {
1302             this(elemtype, arrayClass, TypeMetadata.EMPTY);
1303         }
1304 
1305         public ArrayType(Type elemtype, TypeSymbol arrayClass,
1306                          TypeMetadata metadata) {
1307             super(arrayClass, metadata);
1308             this.elemtype = elemtype;
1309         }
1310 
1311         public ArrayType(ArrayType that) {
1312             //note: type metadata is deliberately shared here, as we want side-effects from annotation
1313             //processing to flow from original array to the cloned array.
1314             this(that.elemtype, that.tsym, that.getMetadata());
1315         }
1316 
<a name="9" id="anc9"></a><span class="line-added">1317         public int poolTag() {</span>
<span class="line-added">1318             return ClassFile.CONSTANT_Class;</span>
<span class="line-added">1319         }</span>
<span class="line-added">1320 </span>
1321         @Override
1322         public ArrayType cloneWithMetadata(TypeMetadata md) {
1323             return new ArrayType(elemtype, tsym, md) {
1324                 @Override
1325                 public Type baseType() { return ArrayType.this.baseType(); }
1326             };
1327         }
1328 
1329         @Override
1330         public TypeTag getTag() {
1331             return ARRAY;
1332         }
1333 
1334         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1335             return v.visitArrayType(this, s);
1336         }
1337 
1338         @DefinedBy(Api.LANGUAGE_MODEL)
1339         public String toString() {
1340             StringBuilder sb = new StringBuilder();
1341 
1342             // First append root component type
1343             Type t = elemtype;
1344             while (t.getKind() == TypeKind.ARRAY)
1345                 t = ((ArrayType) t).getComponentType();
1346             sb.append(t);
1347 
1348             // then append @Anno[] @Anno[] ... @Anno[]
1349             t = this;
1350             do {
1351                 t.appendAnnotationsString(sb, true);
1352                 sb.append(&quot;[]&quot;);
1353                 t = ((ArrayType) t).getComponentType();
1354             } while (t.getKind() == TypeKind.ARRAY);
1355 
1356             return sb.toString();
1357         }
1358 
1359         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1360         public boolean equals(Object obj) {
1361             if (obj instanceof ArrayType) {
1362                 ArrayType that = (ArrayType)obj;
1363                 return this == that ||
1364                         elemtype.equals(that.elemtype);
1365             }
1366 
1367             return false;
1368         }
1369 
1370         @DefinedBy(Api.LANGUAGE_MODEL)
1371         public int hashCode() {
1372             return (ARRAY.ordinal() &lt;&lt; 5) + elemtype.hashCode();
1373         }
1374 
1375         public boolean isVarargs() {
1376             return false;
1377         }
1378 
1379         public List&lt;Type&gt; allparams() { return elemtype.allparams(); }
1380 
1381         public boolean isErroneous() {
1382             return elemtype.isErroneous();
1383         }
1384 
1385         public boolean isParameterized() {
1386             return elemtype.isParameterized();
1387         }
1388 
1389         @Override
1390         public boolean isReference() {
1391             return true;
1392         }
1393 
1394         @Override
1395         public boolean isNullOrReference() {
1396             return true;
1397         }
1398 
1399         public boolean isRaw() {
1400             return elemtype.isRaw();
1401         }
1402 
1403         public ArrayType makeVarargs() {
1404             return new ArrayType(elemtype, tsym, metadata) {
1405                 @Override
1406                 public boolean isVarargs() {
1407                     return true;
1408                 }
1409             };
1410         }
1411 
1412         public boolean contains(Type elem) {
1413             return elem.equalsIgnoreMetadata(this) || elemtype.contains(elem);
1414         }
1415 
1416         public void complete() {
1417             elemtype.complete();
1418         }
1419 
1420         @DefinedBy(Api.LANGUAGE_MODEL)
1421         public Type getComponentType() {
1422             return elemtype;
1423         }
1424 
1425         @DefinedBy(Api.LANGUAGE_MODEL)
1426         public TypeKind getKind() {
1427             return TypeKind.ARRAY;
1428         }
1429 
1430         @DefinedBy(Api.LANGUAGE_MODEL)
1431         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1432             return v.visitArray(this, p);
1433         }
1434     }
1435 
<a name="10" id="anc10"></a><span class="line-modified">1436     public static class MethodType extends Type implements ExecutableType, LoadableConstant {</span>
1437 
1438         public List&lt;Type&gt; argtypes;
1439         public Type restype;
1440         public List&lt;Type&gt; thrown;
1441 
1442         /** The type annotations on the method receiver.
1443          */
1444         public Type recvtype;
1445 
1446         public MethodType(List&lt;Type&gt; argtypes,
1447                           Type restype,
1448                           List&lt;Type&gt; thrown,
1449                           TypeSymbol methodClass) {
1450             // Presently no way to refer to a method type directly, so
1451             // we cannot put type annotations on it.
1452             super(methodClass, TypeMetadata.EMPTY);
1453             this.argtypes = argtypes;
1454             this.restype = restype;
1455             this.thrown = thrown;
1456         }
1457 
1458         @Override
1459         public MethodType cloneWithMetadata(TypeMetadata md) {
1460             throw new AssertionError(&quot;Cannot add metadata to a method type&quot;);
1461         }
1462 
1463         @Override
1464         public TypeTag getTag() {
1465             return METHOD;
1466         }
1467 
1468         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1469             return v.visitMethodType(this, s);
1470         }
1471 
1472         /** The Java source which this type represents.
1473          *
1474          *  XXX 06/09/99 iris This isn&#39;t correct Java syntax, but it probably
1475          *  should be.
1476          */
1477         @DefinedBy(Api.LANGUAGE_MODEL)
1478         public String toString() {
1479             StringBuilder sb = new StringBuilder();
1480             appendAnnotationsString(sb);
1481             sb.append(&#39;(&#39;);
1482             sb.append(argtypes);
1483             sb.append(&#39;)&#39;);
1484             sb.append(restype);
1485             return sb.toString();
1486         }
1487 
1488         @DefinedBy(Api.LANGUAGE_MODEL)
1489         public List&lt;Type&gt;        getParameterTypes() { return argtypes; }
1490         @DefinedBy(Api.LANGUAGE_MODEL)
1491         public Type              getReturnType()     { return restype; }
1492         @DefinedBy(Api.LANGUAGE_MODEL)
1493         public Type              getReceiverType()   { return recvtype; }
1494         @DefinedBy(Api.LANGUAGE_MODEL)
1495         public List&lt;Type&gt;        getThrownTypes()    { return thrown; }
1496 
1497         public boolean isErroneous() {
1498             return
1499                 isErroneous(argtypes) ||
1500                 restype != null &amp;&amp; restype.isErroneous();
1501         }
1502 
<a name="11" id="anc11"></a><span class="line-added">1503         @Override</span>
<span class="line-added">1504         public int poolTag() {</span>
<span class="line-added">1505             return ClassFile.CONSTANT_MethodType;</span>
<span class="line-added">1506         }</span>
<span class="line-added">1507 </span>
1508         public boolean contains(Type elem) {
1509             return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);
1510         }
1511 
1512         public MethodType asMethodType() { return this; }
1513 
1514         public void complete() {
1515             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1516                 l.head.complete();
1517             restype.complete();
1518             recvtype.complete();
1519             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1520                 l.head.complete();
1521         }
1522 
1523         @DefinedBy(Api.LANGUAGE_MODEL)
1524         public List&lt;TypeVar&gt; getTypeVariables() {
1525             return List.nil();
1526         }
1527 
1528         public TypeSymbol asElement() {
1529             return null;
1530         }
1531 
1532         @DefinedBy(Api.LANGUAGE_MODEL)
1533         public TypeKind getKind() {
1534             return TypeKind.EXECUTABLE;
1535         }
1536 
1537         @DefinedBy(Api.LANGUAGE_MODEL)
1538         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1539             return v.visitExecutable(this, p);
1540         }
1541     }
1542 
1543     public static class PackageType extends Type implements NoType {
1544 
1545         PackageType(PackageSymbol tsym) {
1546             // Package types cannot be annotated
1547             super(tsym, TypeMetadata.EMPTY);
1548         }
1549 
1550         @Override
1551         public PackageType cloneWithMetadata(TypeMetadata md) {
1552             throw new AssertionError(&quot;Cannot add metadata to a package type&quot;);
1553         }
1554 
1555         @Override
1556         public TypeTag getTag() {
1557             return PACKAGE;
1558         }
1559 
1560         @Override
1561         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1562             return v.visitPackageType(this, s);
1563         }
1564 
1565         @DefinedBy(Api.LANGUAGE_MODEL)
1566         public String toString() {
1567             return tsym.getQualifiedName().toString();
1568         }
1569 
1570         @DefinedBy(Api.LANGUAGE_MODEL)
1571         public TypeKind getKind() {
1572             return TypeKind.PACKAGE;
1573         }
1574 
1575         @DefinedBy(Api.LANGUAGE_MODEL)
1576         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1577             return v.visitNoType(this, p);
1578         }
1579     }
1580 
1581     public static class ModuleType extends Type implements NoType {
1582 
1583         ModuleType(ModuleSymbol tsym) {
1584             // Module types cannot be annotated
1585             super(tsym, TypeMetadata.EMPTY);
1586         }
1587 
1588         @Override
1589         public ModuleType cloneWithMetadata(TypeMetadata md) {
1590             throw new AssertionError(&quot;Cannot add metadata to a module type&quot;);
1591         }
1592 
1593         @Override
1594         public ModuleType annotatedType(List&lt;Attribute.TypeCompound&gt; annos) {
1595             throw new AssertionError(&quot;Cannot annotate a module type&quot;);
1596         }
1597 
1598         @Override
1599         public TypeTag getTag() {
1600             return TypeTag.MODULE;
1601         }
1602 
1603         @Override
1604         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1605             return v.visitModuleType(this, s);
1606         }
1607 
1608         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1609         public String toString() {
1610             return tsym.getQualifiedName().toString();
1611         }
1612 
1613         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1614         public TypeKind getKind() {
1615             return TypeKind.MODULE;
1616         }
1617 
1618         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1619         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1620             return v.visitNoType(this, p);
1621         }
1622     }
1623 
1624     public static class TypeVar extends Type implements TypeVariable {
1625 
1626         /** The upper bound of this type variable; set from outside.
1627          *  Must be nonempty once it is set.
1628          *  For a bound, `bound&#39; is the bound type itself.
1629          *  Multiple bounds are expressed as a single class type which has the
1630          *  individual bounds as superclass, respectively interfaces.
1631          *  The class type then has as `tsym&#39; a compiler generated class `c&#39;,
1632          *  which has a flag COMPOUND and whose owner is the type variable
1633          *  itself. Furthermore, the erasure_field of the class
1634          *  points to the first class or interface bound.
1635          */
1636         private Type _bound = null;
1637 
1638         /** The lower bound of this type variable.
1639          *  TypeVars don&#39;t normally have a lower bound, so it is normally set
1640          *  to syms.botType.
1641          *  Subtypes, such as CapturedType, may provide a different value.
1642          */
1643         public Type lower;
1644 
1645         public TypeVar(Name name, Symbol owner, Type lower) {
1646             super(null, TypeMetadata.EMPTY);
1647             Assert.checkNonNull(lower);
1648             tsym = new TypeVariableSymbol(0, name, this, owner);
1649             this.setUpperBound(null);
1650             this.lower = lower;
1651         }
1652 
1653         public TypeVar(TypeSymbol tsym, Type bound, Type lower) {
1654             this(tsym, bound, lower, TypeMetadata.EMPTY);
1655         }
1656 
1657         public TypeVar(TypeSymbol tsym, Type bound, Type lower,
1658                        TypeMetadata metadata) {
1659             super(tsym, metadata);
1660             Assert.checkNonNull(lower);
1661             this.setUpperBound(bound);
1662             this.lower = lower;
1663         }
1664 
1665         @Override
1666         public TypeVar cloneWithMetadata(TypeMetadata md) {
1667             return new TypeVar(tsym, getUpperBound(), lower, md) {
1668                 @Override
1669                 public Type baseType() { return TypeVar.this.baseType(); }
1670 
1671                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1672                 public Type getUpperBound() { return TypeVar.this.getUpperBound(); }
1673 
1674                 public void setUpperBound(Type bound) { TypeVar.this.setUpperBound(bound); }
1675             };
1676         }
1677 
1678         @Override
1679         public TypeTag getTag() {
1680             return TYPEVAR;
1681         }
1682 
1683         @Override
1684         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1685             return v.visitTypeVar(this, s);
1686         }
1687 
1688         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1689         public Type getUpperBound() { return _bound; }
1690 
1691         public void setUpperBound(Type bound) { this._bound = bound; }
1692 
1693         int rank_field = -1;
1694 
1695         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1696         public Type getLowerBound() {
1697             return lower;
1698         }
1699 
1700         @DefinedBy(Api.LANGUAGE_MODEL)
1701         public TypeKind getKind() {
1702             return TypeKind.TYPEVAR;
1703         }
1704 
1705         public boolean isCaptured() {
1706             return false;
1707         }
1708 
1709         @Override
1710         public boolean isReference() {
1711             return true;
1712         }
1713 
1714         @Override
1715         public boolean isNullOrReference() {
1716             return true;
1717         }
1718 
1719         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1720         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1721             return v.visitTypeVariable(this, p);
1722         }
1723     }
1724 
1725     /** A captured type variable comes from wildcards which can have
1726      *  both upper and lower bound.  CapturedType extends TypeVar with
1727      *  a lower bound.
1728      */
1729     public static class CapturedType extends TypeVar {
1730 
1731         public WildcardType wildcard;
1732 
1733         public CapturedType(Name name,
1734                             Symbol owner,
1735                             Type upper,
1736                             Type lower,
1737                             WildcardType wildcard) {
1738             super(name, owner, lower);
1739             this.lower = Assert.checkNonNull(lower);
1740             this.setUpperBound(upper);
1741             this.wildcard = wildcard;
1742         }
1743 
1744         public CapturedType(TypeSymbol tsym,
1745                             Type bound,
1746                             Type upper,
1747                             Type lower,
1748                             WildcardType wildcard,
1749                             TypeMetadata metadata) {
1750             super(tsym, bound, lower, metadata);
1751             this.wildcard = wildcard;
1752         }
1753 
1754         @Override
1755         public CapturedType cloneWithMetadata(TypeMetadata md) {
1756             return new CapturedType(tsym, getUpperBound(), getUpperBound(), lower, wildcard, md) {
1757                 @Override
1758                 public Type baseType() { return CapturedType.this.baseType(); }
1759 
1760                 @Override @DefinedBy(Api.LANGUAGE_MODEL)
1761                 public Type getUpperBound() { return CapturedType.this.getUpperBound(); }
1762 
1763                 public void setUpperBound(Type bound) { CapturedType.this.setUpperBound(bound); }
1764             };
1765         }
1766 
1767         @Override
1768         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1769             return v.visitCapturedType(this, s);
1770         }
1771 
1772         @Override
1773         public boolean isCaptured() {
1774             return true;
1775         }
1776 
1777         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1778         public String toString() {
1779             StringBuilder sb = new StringBuilder();
1780             appendAnnotationsString(sb);
1781             sb.append(&quot;capture#&quot;);
1782             sb.append((hashCode() &amp; 0xFFFFFFFFL) % Printer.PRIME);
1783             sb.append(&quot; of &quot;);
1784             sb.append(wildcard);
1785             return sb.toString();
1786         }
1787     }
1788 
1789     public static abstract class DelegatedType extends Type {
1790         public Type qtype;
1791         public TypeTag tag;
1792 
1793         public DelegatedType(TypeTag tag, Type qtype) {
1794             this(tag, qtype, TypeMetadata.EMPTY);
1795         }
1796 
1797         public DelegatedType(TypeTag tag, Type qtype,
1798                              TypeMetadata metadata) {
1799             super(qtype.tsym, metadata);
1800             this.tag = tag;
1801             this.qtype = qtype;
1802         }
1803 
1804         public TypeTag getTag() { return tag; }
1805         @DefinedBy(Api.LANGUAGE_MODEL)
1806         public String toString() { return qtype.toString(); }
1807         public List&lt;Type&gt; getTypeArguments() { return qtype.getTypeArguments(); }
1808         public Type getEnclosingType() { return qtype.getEnclosingType(); }
1809         public List&lt;Type&gt; getParameterTypes() { return qtype.getParameterTypes(); }
1810         public Type getReturnType() { return qtype.getReturnType(); }
1811         public Type getReceiverType() { return qtype.getReceiverType(); }
1812         public List&lt;Type&gt; getThrownTypes() { return qtype.getThrownTypes(); }
1813         public List&lt;Type&gt; allparams() { return qtype.allparams(); }
1814         public Type getUpperBound() { return qtype.getUpperBound(); }
1815         public boolean isErroneous() { return qtype.isErroneous(); }
1816     }
1817 
1818     /**
1819      * The type of a generic method type. It consists of a method type and
1820      * a list of method type-parameters that are used within the method
1821      * type.
1822      */
1823     public static class ForAll extends DelegatedType implements ExecutableType {
1824         public List&lt;Type&gt; tvars;
1825 
1826         public ForAll(List&lt;Type&gt; tvars, Type qtype) {
1827             super(FORALL, (MethodType)qtype);
1828             this.tvars = tvars;
1829         }
1830 
1831         @Override
1832         public ForAll cloneWithMetadata(TypeMetadata md) {
1833             throw new AssertionError(&quot;Cannot add metadata to a forall type&quot;);
1834         }
1835 
1836         @Override
1837         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1838             return v.visitForAll(this, s);
1839         }
1840 
1841         @DefinedBy(Api.LANGUAGE_MODEL)
1842         public String toString() {
1843             StringBuilder sb = new StringBuilder();
1844             appendAnnotationsString(sb);
1845             sb.append(&#39;&lt;&#39;);
1846             sb.append(tvars);
1847             sb.append(&#39;&gt;&#39;);
1848             sb.append(qtype);
1849             return sb.toString();
1850         }
1851 
1852         public List&lt;Type&gt; getTypeArguments()   { return tvars; }
1853 
1854         public boolean isErroneous()  {
1855             return qtype.isErroneous();
1856         }
1857 
1858         public boolean contains(Type elem) {
1859             return qtype.contains(elem);
1860         }
1861 
1862         public MethodType asMethodType() {
1863             return (MethodType)qtype;
1864         }
1865 
1866         public void complete() {
1867             for (List&lt;Type&gt; l = tvars; l.nonEmpty(); l = l.tail) {
1868                 ((TypeVar)l.head).getUpperBound().complete();
1869             }
1870             qtype.complete();
1871         }
1872 
1873         @DefinedBy(Api.LANGUAGE_MODEL)
1874         public List&lt;TypeVar&gt; getTypeVariables() {
1875             return List.convert(TypeVar.class, getTypeArguments());
1876         }
1877 
1878         @DefinedBy(Api.LANGUAGE_MODEL)
1879         public TypeKind getKind() {
1880             return TypeKind.EXECUTABLE;
1881         }
1882 
1883         @DefinedBy(Api.LANGUAGE_MODEL)
1884         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
1885             return v.visitExecutable(this, p);
1886         }
1887     }
1888 
1889     /** A class for inference variables, for use during method/diamond type
1890      *  inference. An inference variable has upper/lower bounds and a set
1891      *  of equality constraints. Such bounds are set during subtyping, type-containment,
1892      *  type-equality checks, when the types being tested contain inference variables.
1893      *  A change listener can be attached to an inference variable, to receive notifications
1894      *  whenever the bounds of an inference variable change.
1895      */
1896     public static class UndetVar extends DelegatedType {
1897 
1898         enum Kind {
1899             NORMAL,
1900             CAPTURED,
1901             THROWS;
1902         }
1903 
1904         /** Inference variable change listener. The listener method is called
1905          *  whenever a change to the inference variable&#39;s bounds occurs
1906          */
1907         public interface UndetVarListener {
1908             /** called when some inference variable bounds (of given kinds ibs) change */
1909             void varBoundChanged(UndetVar uv, InferenceBound ib, Type bound, boolean update);
1910             /** called when the inferred type is set on some inference variable */
1911             default void varInstantiated(UndetVar uv) { Assert.error(); }
1912         }
1913 
1914         /**
1915          * Inference variable bound kinds
1916          */
1917         public enum InferenceBound {
1918             /** lower bounds */
1919             LOWER {
1920                 public InferenceBound complement() { return UPPER; }
1921             },
1922             /** equality constraints */
1923             EQ {
1924                 public InferenceBound complement() { return EQ; }
1925             },
1926             /** upper bounds */
1927             UPPER {
1928                 public InferenceBound complement() { return LOWER; }
1929             };
1930 
1931             public abstract InferenceBound complement();
1932 
1933             public boolean lessThan(InferenceBound that) {
1934                 if (that == this) {
1935                     return false;
1936                 } else {
1937                     switch (that) {
1938                         case UPPER: return true;
1939                         case LOWER: return false;
1940                         case EQ: return (this != UPPER);
1941                         default:
1942                             Assert.error(&quot;Cannot get here!&quot;);
1943                             return false;
1944                     }
1945                 }
1946             }
1947         }
1948 
1949         /** list of incorporation actions (used by the incorporation engine). */
1950         public ArrayDeque&lt;IncorporationAction&gt; incorporationActions = new ArrayDeque&lt;&gt;();
1951 
1952         /** inference variable bounds */
1953         protected Map&lt;InferenceBound, List&lt;Type&gt;&gt; bounds;
1954 
1955         /** inference variable&#39;s inferred type (set from Infer.java) */
1956         private Type inst = null;
1957 
1958         /** number of declared (upper) bounds */
1959         public int declaredCount;
1960 
1961         /** inference variable&#39;s change listener */
1962         public UndetVarListener listener = null;
1963 
1964         Kind kind;
1965 
1966         @Override
1967         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
1968             return v.visitUndetVar(this, s);
1969         }
1970 
1971         public UndetVar(TypeVar origin, UndetVarListener listener, Types types) {
1972             // This is a synthesized internal type, so we cannot annotate it.
1973             super(UNDETVAR, origin);
1974             this.kind = origin.isCaptured() ?
1975                     Kind.CAPTURED :
1976                     Kind.NORMAL;
1977             this.listener = listener;
1978             bounds = new EnumMap&lt;&gt;(InferenceBound.class);
1979             List&lt;Type&gt; declaredBounds = types.getBounds(origin);
1980             declaredCount = declaredBounds.length();
1981             bounds.put(InferenceBound.UPPER, List.nil());
1982             bounds.put(InferenceBound.LOWER, List.nil());
1983             bounds.put(InferenceBound.EQ, List.nil());
1984             for (Type t : declaredBounds.reverse()) {
1985                 //add bound works in reverse order
1986                 addBound(InferenceBound.UPPER, t, types, true);
1987             }
1988             if (origin.isCaptured() &amp;&amp; !origin.lower.hasTag(BOT)) {
1989                 //add lower bound if needed
1990                 addBound(InferenceBound.LOWER, origin.lower, types, true);
1991             }
1992         }
1993 
1994         @DefinedBy(Api.LANGUAGE_MODEL)
1995         public String toString() {
1996             StringBuilder sb = new StringBuilder();
1997             appendAnnotationsString(sb);
1998             if (inst == null) {
1999                 sb.append(qtype);
2000                 sb.append(&#39;?&#39;);
2001             } else {
2002                 sb.append(inst);
2003             }
2004             return sb.toString();
2005         }
2006 
2007         public String debugString() {
2008             String result = &quot;inference var = &quot; + qtype + &quot;\n&quot;;
2009             if (inst != null) {
2010                 result += &quot;inst = &quot; + inst + &#39;\n&#39;;
2011             }
2012             for (InferenceBound bound: InferenceBound.values()) {
2013                 List&lt;Type&gt; aboundList = bounds.get(bound);
2014                 if (aboundList != null &amp;&amp; aboundList.size() &gt; 0) {
2015                     result += bound + &quot; = &quot; + aboundList + &#39;\n&#39;;
2016                 }
2017             }
2018             return result;
2019         }
2020 
2021         public void setThrow() {
2022             if (this.kind == Kind.CAPTURED) {
2023                 //invalid state transition
2024                 throw new IllegalStateException();
2025             }
2026             this.kind = Kind.THROWS;
2027         }
2028 
2029         /**
2030          * Returns a new copy of this undet var.
2031          */
2032         public UndetVar dup(Types types) {
2033             UndetVar uv2 = new UndetVar((TypeVar)qtype, listener, types);
2034             dupTo(uv2, types);
2035             return uv2;
2036         }
2037 
2038         /**
2039          * Dumps the contents of this undet var on another undet var.
2040          */
2041         public void dupTo(UndetVar uv2, Types types) {
2042             uv2.listener = null;
2043             uv2.bounds.clear();
2044             for (InferenceBound ib : InferenceBound.values()) {
2045                 uv2.bounds.put(ib, List.nil());
2046                 for (Type t : getBounds(ib)) {
2047                     uv2.addBound(ib, t, types, true);
2048                 }
2049             }
2050             uv2.inst = inst;
2051             uv2.listener = listener;
2052             uv2.incorporationActions = new ArrayDeque&lt;&gt;();
2053             for (IncorporationAction action : incorporationActions) {
2054                 uv2.incorporationActions.add(action.dup(uv2));
2055             }
2056             uv2.kind = kind;
2057         }
2058 
2059         @Override
2060         public UndetVar cloneWithMetadata(TypeMetadata md) {
2061             throw new AssertionError(&quot;Cannot add metadata to an UndetVar type&quot;);
2062         }
2063 
2064         @Override
2065         public boolean isPartial() {
2066             return true;
2067         }
2068 
2069         @Override
2070         public Type baseType() {
2071             return (inst == null) ? this : inst.baseType();
2072         }
2073 
2074         public Type getInst() {
2075             return inst;
2076         }
2077 
2078         public void setInst(Type inst) {
2079             this.inst = inst;
2080             if (listener != null) {
2081                 listener.varInstantiated(this);
2082             }
2083         }
2084 
2085         /** get all bounds of a given kind */
2086         public List&lt;Type&gt; getBounds(InferenceBound... ibs) {
2087             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2088             for (InferenceBound ib : ibs) {
2089                 buf.appendList(bounds.get(ib));
2090             }
2091             return buf.toList();
2092         }
2093 
2094         /** get the list of declared (upper) bounds */
2095         public List&lt;Type&gt; getDeclaredBounds() {
2096             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
2097             int count = 0;
2098             for (Type b : getBounds(InferenceBound.UPPER)) {
2099                 if (count++ == declaredCount) break;
2100                 buf.append(b);
2101             }
2102             return buf.toList();
2103         }
2104 
2105         /** internal method used to override an undetvar bounds */
2106         public void setBounds(InferenceBound ib, List&lt;Type&gt; newBounds) {
2107             bounds.put(ib, newBounds);
2108         }
2109 
2110         /** add a bound of a given kind - this might trigger listener notification */
2111         public final void addBound(InferenceBound ib, Type bound, Types types) {
2112             // Per JDK-8075793: in pre-8 sources, follow legacy javac behavior
2113             // when capture variables are inferred as bounds: for lower bounds,
2114             // map to the capture variable&#39;s upper bound; for upper bounds,
2115             // if the capture variable has a lower bound, map to that type
2116             if (types.mapCapturesToBounds) {
2117                 switch (ib) {
2118                     case LOWER:
2119                         bound = types.cvarUpperBound(bound);
2120                         break;
2121                     case UPPER:
2122                         Type altBound = types.cvarLowerBound(bound);
2123                         if (!altBound.hasTag(TypeTag.BOT)) bound = altBound;
2124                         break;
2125                 }
2126             }
2127             addBound(ib, bound, types, false);
2128         }
2129 
2130         @SuppressWarnings(&quot;fallthrough&quot;)
2131         private void addBound(InferenceBound ib, Type bound, Types types, boolean update) {
2132             if (kind == Kind.CAPTURED &amp;&amp; !update) {
2133                 //Captured inference variables bounds must not be updated during incorporation,
2134                 //except when some inference variable (beta) has been instantiated in the
2135                 //right-hand-side of a &#39;C&lt;alpha&gt; = capture(C&lt;? extends/super beta&gt;) constraint.
2136                 if (bound.hasTag(UNDETVAR) &amp;&amp; !((UndetVar)bound).isCaptured()) {
2137                     //If the new incoming bound is itself a (regular) inference variable,
2138                     //then we are allowed to propagate this inference variable bounds to it.
2139                     ((UndetVar)bound).addBound(ib.complement(), this, types, false);
2140                 }
2141             } else {
2142                 Type bound2 = bound.map(toTypeVarMap).baseType();
2143                 List&lt;Type&gt; prevBounds = bounds.get(ib);
2144                 if (bound == qtype) return;
2145                 for (Type b : prevBounds) {
2146                     //check for redundancy - do not add same bound twice
2147                     if (types.isSameType(b, bound2)) return;
2148                 }
2149                 bounds.put(ib, prevBounds.prepend(bound2));
2150                 notifyBoundChange(ib, bound2, false);
2151             }
2152         }
2153         //where
2154             TypeMapping&lt;Void&gt; toTypeVarMap = new StructuralTypeMapping&lt;Void&gt;() {
2155                 @Override
2156                 public Type visitUndetVar(UndetVar uv, Void _unused) {
2157                     return uv.inst != null ? uv.inst : uv.qtype;
2158                 }
2159             };
2160 
2161         /** replace types in all bounds - this might trigger listener notification */
2162         public void substBounds(List&lt;Type&gt; from, List&lt;Type&gt; to, Types types) {
2163             final ListBuffer&lt;Pair&lt;InferenceBound, Type&gt;&gt;  boundsChanged = new ListBuffer&lt;&gt;();
2164             UndetVarListener prevListener = listener;
2165             try {
2166                 //setup new listener for keeping track of changed bounds
2167                 listener = (uv, ib, t, _ignored) -&gt; {
2168                     Assert.check(uv == UndetVar.this);
2169                     boundsChanged.add(new Pair&lt;&gt;(ib, t));
2170                 };
2171                 for (Map.Entry&lt;InferenceBound, List&lt;Type&gt;&gt; _entry : bounds.entrySet()) {
2172                     InferenceBound ib = _entry.getKey();
2173                     List&lt;Type&gt; prevBounds = _entry.getValue();
2174                     ListBuffer&lt;Type&gt; newBounds = new ListBuffer&lt;&gt;();
2175                     ListBuffer&lt;Type&gt; deps = new ListBuffer&lt;&gt;();
2176                     //step 1 - re-add bounds that are not dependent on ivars
2177                     for (Type t : prevBounds) {
2178                         if (!t.containsAny(from)) {
2179                             newBounds.append(t);
2180                         } else {
2181                             deps.append(t);
2182                         }
2183                     }
2184                     //step 2 - replace bounds
2185                     bounds.put(ib, newBounds.toList());
2186                     //step 3 - for each dependency, add new replaced bound
2187                     for (Type dep : deps) {
2188                         addBound(ib, types.subst(dep, from, to), types, true);
2189                     }
2190                 }
2191             } finally {
2192                 listener = prevListener;
2193                 for (Pair&lt;InferenceBound, Type&gt; boundUpdate : boundsChanged) {
2194                     notifyBoundChange(boundUpdate.fst, boundUpdate.snd, true);
2195                 }
2196             }
2197         }
2198 
2199         private void notifyBoundChange(InferenceBound ib, Type bound, boolean update) {
2200             if (listener != null) {
2201                 listener.varBoundChanged(this, ib, bound, update);
2202             }
2203         }
2204 
2205         public final boolean isCaptured() {
2206             return kind == Kind.CAPTURED;
2207         }
2208 
2209         public final boolean isThrows() {
2210             return kind == Kind.THROWS;
2211         }
2212     }
2213 
2214     /** Represents NONE.
2215      */
2216     public static class JCNoType extends Type implements NoType {
2217         public JCNoType() {
2218             // Need to use List.nil(), because JCNoType constructor
2219             // gets called in static initializers in Type, where
2220             // noAnnotations is also defined.
2221             super(null, TypeMetadata.EMPTY);
2222         }
2223 
2224         @Override
2225         public JCNoType cloneWithMetadata(TypeMetadata md) {
2226             throw new AssertionError(&quot;Cannot add metadata to a JCNoType&quot;);
2227         }
2228 
2229         @Override
2230         public TypeTag getTag() {
2231             return NONE;
2232         }
2233 
2234         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2235         public TypeKind getKind() {
2236             return TypeKind.NONE;
2237         }
2238 
2239         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2240         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2241             return v.visitNoType(this, p);
2242         }
2243 
2244         @Override
2245         public boolean isCompound() { return false; }
2246     }
2247 
2248     /** Represents VOID.
2249      */
2250     public static class JCVoidType extends Type implements NoType {
2251 
2252         public JCVoidType() {
2253             // Void cannot be annotated
2254             super(null, TypeMetadata.EMPTY);
2255         }
2256 
2257         @Override
2258         public JCVoidType cloneWithMetadata(TypeMetadata md) {
2259             throw new AssertionError(&quot;Cannot add metadata to a void type&quot;);
2260         }
2261 
2262         @Override
2263         public TypeTag getTag() {
2264             return VOID;
2265         }
2266 
2267         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2268         public TypeKind getKind() {
2269             return TypeKind.VOID;
2270         }
2271 
2272         @Override
2273         public boolean isCompound() { return false; }
2274 
2275         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2276         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2277             return v.visitNoType(this, p);
2278         }
2279 
2280         @Override
2281         public boolean isPrimitiveOrVoid() {
2282             return true;
2283         }
2284     }
2285 
2286     static class BottomType extends Type implements NullType {
2287         public BottomType() {
2288             // Bottom is a synthesized internal type, so it cannot be annotated
2289             super(null, TypeMetadata.EMPTY);
2290         }
2291 
2292         @Override
2293         public BottomType cloneWithMetadata(TypeMetadata md) {
2294             throw new AssertionError(&quot;Cannot add metadata to a bottom type&quot;);
2295         }
2296 
2297         @Override
2298         public TypeTag getTag() {
2299             return BOT;
2300         }
2301 
2302         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2303         public TypeKind getKind() {
2304             return TypeKind.NULL;
2305         }
2306 
2307         @Override
2308         public boolean isCompound() { return false; }
2309 
2310         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2311         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2312             return v.visitNull(this, p);
2313         }
2314 
2315         @Override
2316         public Type constType(Object value) {
2317             return this;
2318         }
2319 
2320         @Override
2321         public String stringValue() {
2322             return &quot;null&quot;;
2323         }
2324 
2325         @Override
2326         public boolean isNullOrReference() {
2327             return true;
2328         }
2329 
2330     }
2331 
2332     public static class ErrorType extends ClassType
2333             implements javax.lang.model.type.ErrorType {
2334 
2335         private Type originalType = null;
2336 
2337         public ErrorType(ClassSymbol c, Type originalType) {
2338             this(originalType, c);
2339             c.type = this;
2340             c.kind = ERR;
2341             c.members_field = new Scope.ErrorScope(c);
2342         }
2343 
2344         public ErrorType(Type originalType, TypeSymbol tsym) {
2345             super(noType, List.nil(), null);
2346             this.tsym = tsym;
2347             this.originalType = (originalType == null ? noType : originalType);
2348         }
2349 
2350         private ErrorType(Type originalType, TypeSymbol tsym,
2351                           TypeMetadata metadata) {
2352             super(noType, List.nil(), null, metadata);
2353             this.tsym = tsym;
2354             this.originalType = (originalType == null ? noType : originalType);
2355         }
2356 
2357         @Override
2358         public ErrorType cloneWithMetadata(TypeMetadata md) {
2359             return new ErrorType(originalType, tsym, md) {
2360                 @Override
2361                 public Type baseType() { return ErrorType.this.baseType(); }
2362             };
2363         }
2364 
2365         @Override
2366         public TypeTag getTag() {
2367             return ERROR;
2368         }
2369 
2370         @Override
2371         public boolean isPartial() {
2372             return true;
2373         }
2374 
2375         @Override
2376         public boolean isReference() {
2377             return true;
2378         }
2379 
2380         @Override
2381         public boolean isNullOrReference() {
2382             return true;
2383         }
2384 
2385         public ErrorType(Name name, TypeSymbol container, Type originalType) {
2386             this(new ClassSymbol(PUBLIC|STATIC|ACYCLIC, name, null, container), originalType);
2387         }
2388 
2389         @Override
2390         public &lt;R,S&gt; R accept(Type.Visitor&lt;R,S&gt; v, S s) {
2391             return v.visitErrorType(this, s);
2392         }
2393 
2394         public Type constType(Object constValue) { return this; }
2395         @DefinedBy(Api.LANGUAGE_MODEL)
2396         public Type getEnclosingType()           { return Type.noType; }
2397         public Type getReturnType()              { return this; }
2398         public Type asSub(Symbol sym)            { return this; }
2399 
2400         public boolean isGenType(Type t)         { return true; }
2401         public boolean isErroneous()             { return true; }
2402         public boolean isCompound()              { return false; }
2403         public boolean isInterface()             { return false; }
2404 
2405         public List&lt;Type&gt; allparams()            { return List.nil(); }
2406         @DefinedBy(Api.LANGUAGE_MODEL)
2407         public List&lt;Type&gt; getTypeArguments()     { return List.nil(); }
2408 
2409         @DefinedBy(Api.LANGUAGE_MODEL)
2410         public TypeKind getKind() {
2411             return TypeKind.ERROR;
2412         }
2413 
2414         public Type getOriginalType() {
2415             return originalType;
2416         }
2417 
2418         @DefinedBy(Api.LANGUAGE_MODEL)
2419         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2420             return v.visitError(this, p);
2421         }
2422     }
2423 
2424     public static class UnknownType extends Type {
2425 
2426         public UnknownType() {
2427             // Unknown is a synthesized internal type, so it cannot be
2428             // annotated.
2429             super(null, TypeMetadata.EMPTY);
2430         }
2431 
2432         @Override
2433         public UnknownType cloneWithMetadata(TypeMetadata md) {
2434             throw new AssertionError(&quot;Cannot add metadata to an unknown type&quot;);
2435         }
2436 
2437         @Override
2438         public TypeTag getTag() {
2439             return UNKNOWN;
2440         }
2441 
2442         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2443         public &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; v, P p) {
2444             return v.visitUnknown(this, p);
2445         }
2446 
2447         @Override
2448         public boolean isPartial() {
2449             return true;
2450         }
2451     }
2452 
2453     /**
2454      * A visitor for types.  A visitor is used to implement operations
2455      * (or relations) on types.  Most common operations on types are
2456      * binary relations and this interface is designed for binary
2457      * relations, that is, operations of the form
2458      * Type&amp;nbsp;&amp;times;&amp;nbsp;S&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2459      * &lt;!-- In plain text: Type x S -&gt; R --&gt;
2460      *
2461      * @param &lt;R&gt; the return type of the operation implemented by this
2462      * visitor; use Void if no return type is needed.
2463      * @param &lt;S&gt; the type of the second argument (the first being the
2464      * type itself) of the operation implemented by this visitor; use
2465      * Void if a second argument is not needed.
2466      */
2467     public interface Visitor&lt;R,S&gt; {
2468         R visitClassType(ClassType t, S s);
2469         R visitWildcardType(WildcardType t, S s);
2470         R visitArrayType(ArrayType t, S s);
2471         R visitMethodType(MethodType t, S s);
2472         R visitPackageType(PackageType t, S s);
2473         R visitModuleType(ModuleType t, S s);
2474         R visitTypeVar(TypeVar t, S s);
2475         R visitCapturedType(CapturedType t, S s);
2476         R visitForAll(ForAll t, S s);
2477         R visitUndetVar(UndetVar t, S s);
2478         R visitErrorType(ErrorType t, S s);
2479         R visitType(Type t, S s);
2480     }
2481 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
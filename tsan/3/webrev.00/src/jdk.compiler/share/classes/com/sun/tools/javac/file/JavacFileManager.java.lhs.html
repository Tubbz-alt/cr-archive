<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.file;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
<a name="2" id="anc2"></a>
  30 import java.lang.module.Configuration;
  31 import java.lang.module.ModuleFinder;
  32 import java.net.MalformedURLException;
  33 import java.net.URI;
  34 import java.net.URISyntaxException;
  35 import java.net.URL;
  36 import java.nio.CharBuffer;
  37 import java.nio.charset.Charset;
  38 import java.nio.file.FileSystem;
  39 import java.nio.file.FileSystems;
  40 import java.nio.file.FileVisitOption;
  41 import java.nio.file.FileVisitResult;
  42 import java.nio.file.Files;
  43 import java.nio.file.InvalidPathException;
  44 import java.nio.file.LinkOption;
  45 import java.nio.file.Path;
  46 import java.nio.file.Paths;
  47 import java.nio.file.ProviderNotFoundException;
  48 import java.nio.file.SimpleFileVisitor;
  49 import java.nio.file.attribute.BasicFileAttributes;
  50 import java.nio.file.spi.FileSystemProvider;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.Collection;
  54 import java.util.Collections;
  55 import java.util.Comparator;
  56 import java.util.EnumSet;
  57 import java.util.HashMap;
  58 import java.util.Iterator;
  59 import java.util.Map;
  60 import java.util.Objects;
  61 import java.util.ServiceLoader;
  62 import java.util.Set;
  63 import java.util.stream.Collectors;
  64 import java.util.stream.Stream;
  65 
  66 import javax.lang.model.SourceVersion;
  67 import javax.tools.FileObject;
  68 import javax.tools.JavaFileManager;
  69 import javax.tools.JavaFileObject;
  70 import javax.tools.StandardJavaFileManager;
  71 
  72 import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
  73 import com.sun.tools.javac.file.RelativePath.RelativeFile;
<a name="3" id="anc3"></a>
  74 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  75 import com.sun.tools.javac.util.Assert;
  76 import com.sun.tools.javac.util.Context;
  77 import com.sun.tools.javac.util.Context.Factory;
  78 import com.sun.tools.javac.util.DefinedBy;
  79 import com.sun.tools.javac.util.DefinedBy.Api;
  80 import com.sun.tools.javac.util.List;
  81 import com.sun.tools.javac.util.ListBuffer;
  82 
  83 import static java.nio.file.FileVisitOption.FOLLOW_LINKS;
  84 
  85 import static javax.tools.StandardLocation.*;
  86 
  87 /**
  88  * This class provides access to the source, class and other files
  89  * used by the compiler and related tools.
  90  *
  91  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  92  * If you write code that depends on this, you do so at your own risk.
  93  * This code and its internal interfaces are subject to change or
  94  * deletion without notice.&lt;/b&gt;
  95  */
  96 public class JavacFileManager extends BaseFileManager implements StandardJavaFileManager {
  97 
  98     public static char[] toArray(CharBuffer buffer) {
  99         if (buffer.hasArray())
 100             return buffer.compact().flip().array();
 101         else
 102             return buffer.toString().toCharArray();
 103     }
 104 
 105     private FSInfo fsInfo;
 106 
 107     private static final Set&lt;JavaFileObject.Kind&gt; SOURCE_OR_CLASS =
 108         Set.of(JavaFileObject.Kind.SOURCE, JavaFileObject.Kind.CLASS);
 109 
 110     protected boolean symbolFileEnabled;
 111 
 112     private PathFactory pathFactory = Paths::get;
 113 
 114     protected enum SortFiles implements Comparator&lt;Path&gt; {
 115         FORWARD {
 116             @Override
 117             public int compare(Path f1, Path f2) {
 118                 return f1.getFileName().compareTo(f2.getFileName());
 119             }
 120         },
 121         REVERSE {
 122             @Override
 123             public int compare(Path f1, Path f2) {
 124                 return -f1.getFileName().compareTo(f2.getFileName());
 125             }
 126         }
 127     }
 128 
 129     protected SortFiles sortFiles;
 130 
<a name="4" id="anc4"></a>












 131     /**
 132      * Register a Context.Factory to create a JavacFileManager.
 133      */
 134     public static void preRegister(Context context) {
 135         context.put(JavaFileManager.class,
 136                 (Factory&lt;JavaFileManager&gt;)c -&gt; new JavacFileManager(c, true, null));
 137     }
 138 
 139     /**
 140      * Create a JavacFileManager using a given context, optionally registering
 141      * it as the JavaFileManager for that context.
 142      */
 143     public JavacFileManager(Context context, boolean register, Charset charset) {
 144         super(charset);
 145         if (register)
 146             context.put(JavaFileManager.class, this);
 147         setContext(context);
 148     }
 149 
 150     /**
 151      * Set the context for JavacFileManager.
 152      */
 153     @Override
 154     public void setContext(Context context) {
 155         super.setContext(context);
 156 
 157         fsInfo = FSInfo.instance(context);
 158 
 159         symbolFileEnabled = !options.isSet(&quot;ignore.symbol.file&quot;);
 160 
 161         String sf = options.get(&quot;sortFiles&quot;);
 162         if (sf != null) {
 163             sortFiles = (sf.equals(&quot;reverse&quot;) ? SortFiles.REVERSE : SortFiles.FORWARD);
 164         }
 165     }
 166 
 167     @Override @DefinedBy(DefinedBy.Api.COMPILER)
 168     public void setPathFactory(PathFactory f) {
 169         pathFactory = Objects.requireNonNull(f);
 170         locations.setPathFactory(f);
 171     }
 172 
 173     private Path getPath(String first, String... more) {
 174         return pathFactory.getPath(first, more);
 175     }
 176 
 177     /**
 178      * Set whether or not to use ct.sym as an alternate to rt.jar.
 179      */
 180     public void setSymbolFileEnabled(boolean b) {
 181         symbolFileEnabled = b;
 182     }
 183 
 184     public boolean isSymbolFileEnabled() {
 185         return symbolFileEnabled;
 186     }
 187 
 188     // used by tests
 189     public JavaFileObject getJavaFileObject(String name) {
 190         return getJavaFileObjects(name).iterator().next();
 191     }
 192 
 193     // used by tests
 194     public JavaFileObject getJavaFileObject(Path file) {
 195         return getJavaFileObjects(file).iterator().next();
 196     }
 197 
 198     public JavaFileObject getFileForOutput(String classname,
 199                                            JavaFileObject.Kind kind,
 200                                            JavaFileObject sibling)
 201         throws IOException
 202     {
 203         return getJavaFileForOutput(CLASS_OUTPUT, classname, kind, sibling);
 204     }
 205 
 206     @Override @DefinedBy(Api.COMPILER)
 207     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromStrings(Iterable&lt;String&gt; names) {
 208         ListBuffer&lt;Path&gt; paths = new ListBuffer&lt;&gt;();
 209         for (String name : names)
 210             paths.append(getPath(nullCheck(name)));
 211         return getJavaFileObjectsFromPaths(paths.toList());
 212     }
 213 
 214     @Override @DefinedBy(Api.COMPILER)
 215     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(String... names) {
 216         return getJavaFileObjectsFromStrings(Arrays.asList(nullCheck(names)));
 217     }
 218 
 219     private static boolean isValidName(String name) {
 220         // Arguably, isValidName should reject keywords (such as in SourceVersion.isName() ),
 221         // but the set of keywords depends on the source level, and we don&#39;t want
 222         // impls of JavaFileManager to have to be dependent on the source level.
 223         // Therefore we simply check that the argument is a sequence of identifiers
 224         // separated by &quot;.&quot;.
 225         for (String s : name.split(&quot;\\.&quot;, -1)) {
 226             if (!SourceVersion.isIdentifier(s))
 227                 return false;
 228         }
 229         return true;
 230     }
 231 
 232     private static void validateClassName(String className) {
 233         if (!isValidName(className))
 234             throw new IllegalArgumentException(&quot;Invalid class name: &quot; + className);
 235     }
 236 
 237     private static void validatePackageName(String packageName) {
 238         if (packageName.length() &gt; 0 &amp;&amp; !isValidName(packageName))
 239             throw new IllegalArgumentException(&quot;Invalid packageName name: &quot; + packageName);
 240     }
 241 
 242     public static void testName(String name,
 243                                 boolean isValidPackageName,
 244                                 boolean isValidClassName)
 245     {
 246         try {
 247             validatePackageName(name);
 248             if (!isValidPackageName)
 249                 throw new AssertionError(&quot;Invalid package name accepted: &quot; + name);
 250             printAscii(&quot;Valid package name: \&quot;%s\&quot;&quot;, name);
 251         } catch (IllegalArgumentException e) {
 252             if (isValidPackageName)
 253                 throw new AssertionError(&quot;Valid package name rejected: &quot; + name);
 254             printAscii(&quot;Invalid package name: \&quot;%s\&quot;&quot;, name);
 255         }
 256         try {
 257             validateClassName(name);
 258             if (!isValidClassName)
 259                 throw new AssertionError(&quot;Invalid class name accepted: &quot; + name);
 260             printAscii(&quot;Valid class name: \&quot;%s\&quot;&quot;, name);
 261         } catch (IllegalArgumentException e) {
 262             if (isValidClassName)
 263                 throw new AssertionError(&quot;Valid class name rejected: &quot; + name);
 264             printAscii(&quot;Invalid class name: \&quot;%s\&quot;&quot;, name);
 265         }
 266     }
 267 
 268     private static void printAscii(String format, Object... args) {
 269         String message;
 270         try {
 271             final String ascii = &quot;US-ASCII&quot;;
 272             message = new String(String.format(null, format, args).getBytes(ascii), ascii);
 273         } catch (java.io.UnsupportedEncodingException ex) {
 274             throw new AssertionError(ex);
 275         }
 276         System.out.println(message);
 277     }
 278 
 279     private final Map&lt;Path, Container&gt; containers = new HashMap&lt;&gt;();
 280 
 281     synchronized Container getContainer(Path path) throws IOException {
 282         Container fs = containers.get(path);
 283 
 284         if (fs != null) {
 285             return fs;
 286         }
 287 
 288         if (fsInfo.isFile(path) &amp;&amp; path.equals(Locations.thisSystemModules)) {
 289             containers.put(path, fs = new JRTImageContainer());
 290             return fs;
 291         }
 292 
 293         Path realPath = fsInfo.getCanonicalFile(path);
 294 
 295         fs = containers.get(realPath);
 296 
 297         if (fs != null) {
 298             containers.put(path, fs);
 299             return fs;
 300         }
 301 
 302         BasicFileAttributes attr = null;
 303 
 304         try {
 305             attr = Files.readAttributes(realPath, BasicFileAttributes.class);
 306         } catch (IOException ex) {
 307             //non-existing
 308             fs = MISSING_CONTAINER;
 309         }
 310 
 311         if (attr != null) {
 312             if (attr.isDirectory()) {
 313                 fs = new DirectoryContainer(realPath);
 314             } else {
 315                 try {
 316                     fs = new ArchiveContainer(path);
 317                 } catch (ProviderNotFoundException | SecurityException ex) {
 318                     throw new IOException(ex);
 319                 }
 320             }
 321         }
 322 
 323         containers.put(realPath, fs);
 324         containers.put(path, fs);
 325 
 326         return fs;
 327     }
 328 
 329     private interface Container {
 330         /**
 331          * Insert all files in subdirectory subdirectory of container which
 332          * match fileKinds into resultList
 333          */
 334         public abstract void list(Path userPath,
 335                                   RelativeDirectory subdirectory,
 336                                   Set&lt;JavaFileObject.Kind&gt; fileKinds,
 337                                   boolean recurse,
 338                                   ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException;
 339         public abstract JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException;
 340         public abstract void close() throws IOException;
<a name="5" id="anc5"></a>






 341     }
 342 
 343     private static final Container MISSING_CONTAINER =  new Container() {
 344         @Override
 345         public void list(Path userPath,
 346                          RelativeDirectory subdirectory,
 347                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 348                          boolean recurse,
 349                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 350         }
 351         @Override
 352         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 353             return null;
 354         }
 355         @Override
 356         public void close() throws IOException {}
<a name="6" id="anc6"></a>







 357     };
 358 
 359     private final class JRTImageContainer implements Container {
 360 
 361         /**
 362          * Insert all files in a subdirectory of the platform image
 363          * which match fileKinds into resultList.
 364          */
 365         @Override
 366         public void list(Path userPath,
 367                          RelativeDirectory subdirectory,
 368                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 369                          boolean recurse,
 370                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 371             try {
 372                 JRTIndex.Entry e = getJRTIndex().getEntry(subdirectory);
 373                 if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 374                     return;
 375                 for (Path file: e.files.values()) {
 376                     if (fileKinds.contains(getKind(file))) {
 377                         JavaFileObject fe
 378                                 = PathFileObject.forJRTPath(JavacFileManager.this, file);
 379                         resultList.append(fe);
 380                     }
 381                 }
 382 
 383                 if (recurse) {
 384                     for (RelativeDirectory rd: e.subdirs) {
 385                         list(userPath, rd, fileKinds, recurse, resultList);
 386                     }
 387                 }
 388             } catch (IOException ex) {
 389                 ex.printStackTrace(System.err);
 390                 log.error(Errors.ErrorReadingFile(userPath, getMessage(ex)));
 391             }
 392         }
 393 
 394         @Override
 395         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 396             JRTIndex.Entry e = getJRTIndex().getEntry(name.dirname());
 397             if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 398                 return null;
 399             Path p = e.files.get(name.basename());
 400             if (p != null) {
 401                 return PathFileObject.forJRTPath(JavacFileManager.this, p);
 402             } else {
 403                 return null;
 404             }
 405         }
 406 
 407         @Override
 408         public void close() throws IOException {
 409         }
<a name="7" id="anc7"></a>









 410     }
 411 
 412     private synchronized JRTIndex getJRTIndex() {
 413         if (jrtIndex == null)
 414             jrtIndex = JRTIndex.getSharedInstance();
 415         return jrtIndex;
 416     }
 417 
 418     private JRTIndex jrtIndex;
 419 
 420     private final class DirectoryContainer implements Container {
 421         private final Path directory;
 422 
 423         public DirectoryContainer(Path directory) {
 424             this.directory = directory;
 425         }
 426 
 427         /**
 428          * Insert all files in subdirectory subdirectory of directory userPath
 429          * which match fileKinds into resultList
 430          */
 431         @Override
 432         public void list(Path userPath,
 433                          RelativeDirectory subdirectory,
 434                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 435                          boolean recurse,
 436                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 437             Path d;
 438             try {
 439                 d = subdirectory.resolveAgainst(userPath);
 440             } catch (InvalidPathException ignore) {
 441                 return ;
 442             }
 443 
 444             if (!Files.exists(d)) {
 445                return;
 446             }
 447 
 448             if (!caseMapCheck(d, subdirectory)) {
 449                 return;
 450             }
 451 
 452             java.util.List&lt;Path&gt; files;
 453             try (Stream&lt;Path&gt; s = Files.list(d)) {
 454                 files = (sortFiles == null ? s : s.sorted(sortFiles)).collect(Collectors.toList());
 455             } catch (IOException ignore) {
 456                 return;
 457             }
 458 
 459             for (Path f: files) {
 460                 String fname = f.getFileName().toString();
 461                 if (fname.endsWith(&quot;/&quot;))
 462                     fname = fname.substring(0, fname.length() - 1);
 463                 if (Files.isDirectory(f)) {
 464                     if (recurse &amp;&amp; SourceVersion.isIdentifier(fname)) {
 465                         list(userPath,
 466                              new RelativeDirectory(subdirectory, fname),
 467                              fileKinds,
 468                              recurse,
 469                              resultList);
 470                     }
 471                 } else {
 472                     if (isValidFile(fname, fileKinds)) {
 473                         try {
 474                             RelativeFile file = new RelativeFile(subdirectory, fname);
 475                             JavaFileObject fe = PathFileObject.forDirectoryPath(JavacFileManager.this,
 476                                     file.resolveAgainst(directory), userPath, file);
 477                             resultList.append(fe);
 478                         } catch (InvalidPathException e) {
 479                             throw new IOException(&quot;error accessing directory &quot; + directory + e);
 480                         }
 481                     }
 482                 }
 483             }
 484         }
 485 
 486         @Override
 487         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 488             try {
 489                 Path f = name.resolveAgainst(userPath);
 490                 if (Files.exists(f))
 491                     return PathFileObject.forSimplePath(JavacFileManager.this,
 492                             fsInfo.getCanonicalFile(f), f);
 493             } catch (InvalidPathException ignore) {
 494             }
 495             return null;
 496         }
 497 
 498         @Override
 499         public void close() throws IOException {
 500         }
<a name="8" id="anc8"></a>









 501     }
 502 
 503     private static final Set&lt;FileVisitOption&gt; NO_FILE_VISIT_OPTIONS = Set.of();
 504     private static final Set&lt;FileVisitOption&gt; FOLLOW_LINKS_OPTIONS = Set.of(FOLLOW_LINKS);
 505 
 506     private final class ArchiveContainer implements Container {
 507         private final Path archivePath;
 508         private final FileSystem fileSystem;
<a name="9" id="anc9"></a><span class="line-modified"> 509         private final Map&lt;RelativePath, Path&gt; packages;</span>
 510 
 511         public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {
 512             this.archivePath = archivePath;
 513             if (multiReleaseValue != null &amp;&amp; archivePath.toString().endsWith(&quot;.jar&quot;)) {
 514                 Map&lt;String,String&gt; env = Collections.singletonMap(&quot;multi-release&quot;, multiReleaseValue);
 515                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();
 516                 Assert.checkNonNull(jarFSProvider, &quot;should have been caught before!&quot;);
 517                 this.fileSystem = jarFSProvider.newFileSystem(archivePath, env);
 518             } else {
<a name="10" id="anc10"></a><span class="line-modified"> 519                 this.fileSystem = FileSystems.newFileSystem(archivePath, null);</span>
 520             }
 521             packages = new HashMap&lt;&gt;();
 522             for (Path root : fileSystem.getRootDirectories()) {
 523                 Files.walkFileTree(root, NO_FILE_VISIT_OPTIONS, Integer.MAX_VALUE,
 524                         new SimpleFileVisitor&lt;Path&gt;() {
 525                             @Override
 526                             public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
 527                                 if (isValid(dir.getFileName())) {
 528                                     packages.put(new RelativeDirectory(root.relativize(dir).toString()), dir);
 529                                     return FileVisitResult.CONTINUE;
 530                                 } else {
 531                                     return FileVisitResult.SKIP_SUBTREE;
 532                                 }
 533                             }
 534                         });
 535             }
 536         }
 537 
 538         /**
 539          * Insert all files in subdirectory subdirectory of this archive
 540          * which match fileKinds into resultList
 541          */
 542         @Override
 543         public void list(Path userPath,
 544                          RelativeDirectory subdirectory,
 545                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 546                          boolean recurse,
 547                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 548             Path resolvedSubdirectory = packages.get(subdirectory);
 549 
 550             if (resolvedSubdirectory == null)
 551                 return ;
 552 
 553             int maxDepth = (recurse ? Integer.MAX_VALUE : 1);
 554             Files.walkFileTree(resolvedSubdirectory, FOLLOW_LINKS_OPTIONS, maxDepth,
 555                     new SimpleFileVisitor&lt;Path&gt;() {
 556                         @Override
 557                         public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
 558                             if (isValid(dir.getFileName())) {
 559                                 return FileVisitResult.CONTINUE;
 560                             } else {
 561                                 return FileVisitResult.SKIP_SUBTREE;
 562                             }
 563                         }
 564 
 565                         @Override
 566                         public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
 567                             if (attrs.isRegularFile() &amp;&amp; fileKinds.contains(getKind(file.getFileName().toString()))) {
 568                                 JavaFileObject fe = PathFileObject.forJarPath(
 569                                         JavacFileManager.this, file, archivePath);
 570                                 resultList.append(fe);
 571                             }
 572                             return FileVisitResult.CONTINUE;
 573                         }
 574                     });
 575 
 576         }
 577 
 578         private boolean isValid(Path fileName) {
 579             if (fileName == null) {
 580                 return true;
 581             } else {
 582                 String name = fileName.toString();
 583                 if (name.endsWith(&quot;/&quot;)) {
 584                     name = name.substring(0, name.length() - 1);
 585                 }
 586                 return SourceVersion.isIdentifier(name);
 587             }
 588         }
 589 
 590         @Override
 591         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 592             RelativeDirectory root = name.dirname();
 593             Path packagepath = packages.get(root);
 594             if (packagepath != null) {
 595                 Path relpath = packagepath.resolve(name.basename());
 596                 if (Files.exists(relpath)) {
 597                     return PathFileObject.forJarPath(JavacFileManager.this, relpath, userPath);
 598                 }
 599             }
 600             return null;
 601         }
 602 
 603         @Override
 604         public void close() throws IOException {
 605             fileSystem.close();
 606         }
<a name="11" id="anc11"></a>









 607     }
 608 
 609     /**
 610      * container is a directory, a zip file, or a non-existent path.
 611      */
 612     private boolean isValidFile(String s, Set&lt;JavaFileObject.Kind&gt; fileKinds) {
 613         JavaFileObject.Kind kind = getKind(s);
 614         return fileKinds.contains(kind);
 615     }
 616 
 617     private static final boolean fileSystemIsCaseSensitive =
 618         File.separatorChar == &#39;/&#39;;
 619 
 620     /** Hack to make Windows case sensitive. Test whether given path
 621      *  ends in a string of characters with the same case as given name.
 622      *  Ignore file separators in both path and name.
 623      */
 624     private boolean caseMapCheck(Path f, RelativePath name) {
 625         if (fileSystemIsCaseSensitive) return true;
 626         // Note that toRealPath() returns the case-sensitive
 627         // spelled file name.
 628         String path;
 629         char sep;
 630         try {
 631             path = f.toRealPath(LinkOption.NOFOLLOW_LINKS).toString();
 632             sep = f.getFileSystem().getSeparator().charAt(0);
 633         } catch (IOException ex) {
 634             return false;
 635         }
 636         char[] pcs = path.toCharArray();
 637         char[] ncs = name.path.toCharArray();
 638         int i = pcs.length - 1;
 639         int j = ncs.length - 1;
 640         while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 641             while (i &gt;= 0 &amp;&amp; pcs[i] == sep) i--;
 642             while (j &gt;= 0 &amp;&amp; ncs[j] == &#39;/&#39;) j--;
 643             if (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 644                 if (pcs[i] != ncs[j]) return false;
 645                 i--;
 646                 j--;
 647             }
 648         }
 649         return j &lt; 0;
 650     }
 651 
 652     /** Flush any output resources.
 653      */
 654     @Override @DefinedBy(Api.COMPILER)
 655     public void flush() {
 656         contentCache.clear();
<a name="12" id="anc12"></a>

 657     }
 658 
 659     /**
 660      * Close the JavaFileManager, releasing resources.
 661      */
 662     @Override @DefinedBy(Api.COMPILER)
 663     public void close() throws IOException {
 664         if (deferredCloseTimeout &gt; 0) {
 665             deferredClose();
 666             return;
 667         }
 668 
 669         locations.close();
 670         for (Container container: containers.values()) {
 671             container.close();
 672         }
 673         containers.clear();
<a name="13" id="anc13"></a>

 674         contentCache.clear();
 675     }
 676 
 677     @Override @DefinedBy(Api.COMPILER)
 678     public ClassLoader getClassLoader(Location location) {
 679         checkNotModuleOrientedLocation(location);
 680         Iterable&lt;? extends File&gt; path = getLocation(location);
 681         if (path == null)
 682             return null;
 683         ListBuffer&lt;URL&gt; lb = new ListBuffer&lt;&gt;();
 684         for (File f: path) {
 685             try {
 686                 lb.append(f.toURI().toURL());
 687             } catch (MalformedURLException e) {
 688                 throw new AssertionError(e);
 689             }
 690         }
 691 
 692         return getClassLoader(lb.toArray(new URL[lb.size()]));
 693     }
 694 
 695     @Override @DefinedBy(Api.COMPILER)
 696     public Iterable&lt;JavaFileObject&gt; list(Location location,
 697                                          String packageName,
 698                                          Set&lt;JavaFileObject.Kind&gt; kinds,
 699                                          boolean recurse)
 700         throws IOException
 701     {
 702         checkNotModuleOrientedLocation(location);
 703         // validatePackageName(packageName);
 704         nullCheck(packageName);
 705         nullCheck(kinds);
 706 
<a name="14" id="anc14"></a><span class="line-removed"> 707         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);</span>
<span class="line-removed"> 708         if (path == null)</span>
<span class="line-removed"> 709             return List.nil();</span>
 710         RelativeDirectory subdirectory = RelativeDirectory.forPackage(packageName);
 711         ListBuffer&lt;JavaFileObject&gt; results = new ListBuffer&lt;&gt;();
 712 
<a name="15" id="anc15"></a><span class="line-modified"> 713         for (Path directory : path) {</span>
<span class="line-modified"> 714             Container container = getContainer(directory);</span>
<span class="line-modified"> 715 </span>
 716             container.list(directory, subdirectory, kinds, recurse, results);
 717         }
 718 
 719         return results.toList();
 720     }
 721 
 722     @Override @DefinedBy(Api.COMPILER)
 723     public String inferBinaryName(Location location, JavaFileObject file) {
 724         checkNotModuleOrientedLocation(location);
 725         Objects.requireNonNull(file);
 726         // Need to match the path semantics of list(location, ...)
 727         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);
 728         if (path == null) {
 729             return null;
 730         }
 731 
 732         if (file instanceof PathFileObject) {
 733             return ((PathFileObject) file).inferBinaryName(path);
 734         } else
 735             throw new IllegalArgumentException(file.getClass().getName());
 736     }
 737 
 738     @Override @DefinedBy(Api.COMPILER)
 739     public boolean isSameFile(FileObject a, FileObject b) {
 740         nullCheck(a);
 741         nullCheck(b);
 742         if (a instanceof PathFileObject &amp;&amp; b instanceof PathFileObject)
 743             return ((PathFileObject) a).isSameFile((PathFileObject) b);
 744         return a.equals(b);
 745     }
 746 
 747     @Override @DefinedBy(Api.COMPILER)
 748     public boolean hasLocation(Location location) {
 749         nullCheck(location);
 750         return locations.hasLocation(location);
 751     }
 752 
 753     protected boolean hasExplicitLocation(Location location) {
 754         nullCheck(location);
 755         return locations.hasExplicitLocation(location);
 756     }
 757 
 758     @Override @DefinedBy(Api.COMPILER)
 759     public JavaFileObject getJavaFileForInput(Location location,
 760                                               String className,
 761                                               JavaFileObject.Kind kind)
 762         throws IOException
 763     {
 764         checkNotModuleOrientedLocation(location);
 765         // validateClassName(className);
 766         nullCheck(className);
 767         nullCheck(kind);
 768         if (!SOURCE_OR_CLASS.contains(kind))
 769             throw new IllegalArgumentException(&quot;Invalid kind: &quot; + kind);
 770         return getFileForInput(location, RelativeFile.forClass(className, kind));
 771     }
 772 
 773     @Override @DefinedBy(Api.COMPILER)
 774     public FileObject getFileForInput(Location location,
 775                                       String packageName,
 776                                       String relativeName)
 777         throws IOException
 778     {
 779         checkNotModuleOrientedLocation(location);
 780         // validatePackageName(packageName);
 781         nullCheck(packageName);
 782         if (!isRelativeUri(relativeName))
 783             throw new IllegalArgumentException(&quot;Invalid relative name: &quot; + relativeName);
 784         RelativeFile name = packageName.length() == 0
 785             ? new RelativeFile(relativeName)
 786             : new RelativeFile(RelativeDirectory.forPackage(packageName), relativeName);
 787         return getFileForInput(location, name);
 788     }
 789 
 790     private JavaFileObject getFileForInput(Location location, RelativeFile name) throws IOException {
 791         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);
 792         if (path == null)
 793             return null;
 794 
 795         for (Path file: path) {
 796             JavaFileObject fo = getContainer(file).getFileObject(file, name);
 797 
 798             if (fo != null) {
 799                 return fo;
 800             }
 801         }
 802         return null;
 803     }
 804 
 805     @Override @DefinedBy(Api.COMPILER)
 806     public JavaFileObject getJavaFileForOutput(Location location,
 807                                                String className,
 808                                                JavaFileObject.Kind kind,
 809                                                FileObject sibling)
 810         throws IOException
 811     {
 812         checkOutputLocation(location);
 813         // validateClassName(className);
 814         nullCheck(className);
 815         nullCheck(kind);
 816         if (!SOURCE_OR_CLASS.contains(kind))
 817             throw new IllegalArgumentException(&quot;Invalid kind: &quot; + kind);
 818         return getFileForOutput(location, RelativeFile.forClass(className, kind), sibling);
 819     }
 820 
 821     @Override @DefinedBy(Api.COMPILER)
 822     public FileObject getFileForOutput(Location location,
 823                                        String packageName,
 824                                        String relativeName,
 825                                        FileObject sibling)
 826         throws IOException
 827     {
 828         checkOutputLocation(location);
 829         // validatePackageName(packageName);
 830         nullCheck(packageName);
 831         if (!isRelativeUri(relativeName))
 832             throw new IllegalArgumentException(&quot;Invalid relative name: &quot; + relativeName);
 833         RelativeFile name = packageName.length() == 0
 834             ? new RelativeFile(relativeName)
 835             : new RelativeFile(RelativeDirectory.forPackage(packageName), relativeName);
 836         return getFileForOutput(location, name, sibling);
 837     }
 838 
 839     private JavaFileObject getFileForOutput(Location location,
 840                                             RelativeFile fileName,
 841                                             FileObject sibling)
 842         throws IOException
 843     {
 844         Path dir;
 845         if (location == CLASS_OUTPUT) {
 846             if (getClassOutDir() != null) {
 847                 dir = getClassOutDir();
 848             } else {
 849                 String baseName = fileName.basename();
 850                 if (sibling != null &amp;&amp; sibling instanceof PathFileObject) {
 851                     return ((PathFileObject) sibling).getSibling(baseName);
 852                 } else {
 853                     Path p = getPath(baseName);
 854                     Path real = fsInfo.getCanonicalFile(p);
 855                     return PathFileObject.forSimplePath(this, real, p);
 856                 }
 857             }
 858         } else if (location == SOURCE_OUTPUT) {
 859             dir = (getSourceOutDir() != null ? getSourceOutDir() : getClassOutDir());
 860         } else {
 861             Iterable&lt;? extends Path&gt; path = locations.getLocation(location);
 862             dir = null;
 863             for (Path f: path) {
 864                 dir = f;
 865                 break;
 866             }
 867         }
 868 
 869         try {
 870             if (dir == null) {
 871                 dir = getPath(System.getProperty(&quot;user.dir&quot;));
 872             }
 873             Path path = fileName.resolveAgainst(fsInfo.getCanonicalFile(dir));
 874             return PathFileObject.forDirectoryPath(this, path, dir, fileName);
 875         } catch (InvalidPathException e) {
 876             throw new IOException(&quot;bad filename &quot; + fileName, e);
 877         }
 878     }
 879 
 880     @Override @DefinedBy(Api.COMPILER)
 881     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromFiles(
 882         Iterable&lt;? extends File&gt; files)
 883     {
 884         ArrayList&lt;PathFileObject&gt; result;
 885         if (files instanceof Collection&lt;?&gt;)
 886             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)files).size());
 887         else
 888             result = new ArrayList&lt;&gt;();
 889         for (File f: files) {
 890             Objects.requireNonNull(f);
 891             Path p = f.toPath();
 892             result.add(PathFileObject.forSimplePath(this,
 893                     fsInfo.getCanonicalFile(p), p));
 894         }
 895         return result;
 896     }
 897 
 898     @Override @DefinedBy(Api.COMPILER)
 899     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(
<a name="16" id="anc16"></a><span class="line-modified"> 900         Iterable&lt;? extends Path&gt; paths)</span>
 901     {
 902         ArrayList&lt;PathFileObject&gt; result;
 903         if (paths instanceof Collection&lt;?&gt;)
 904             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)paths).size());
 905         else
 906             result = new ArrayList&lt;&gt;();
 907         for (Path p: paths)
 908             result.add(PathFileObject.forSimplePath(this,
 909                     fsInfo.getCanonicalFile(p), p));
 910         return result;
 911     }
 912 
 913     @Override @DefinedBy(Api.COMPILER)
 914     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(File... files) {
 915         return getJavaFileObjectsFromFiles(Arrays.asList(nullCheck(files)));
 916     }
 917 
 918     @Override @DefinedBy(Api.COMPILER)
 919     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(Path... paths) {
 920         return getJavaFileObjectsFromPaths(Arrays.asList(nullCheck(paths)));
 921     }
 922 
 923     @Override @DefinedBy(Api.COMPILER)
 924     public void setLocation(Location location,
 925                             Iterable&lt;? extends File&gt; searchpath)
 926         throws IOException
 927     {
 928         nullCheck(location);
 929         locations.setLocation(location, asPaths(searchpath));
<a name="17" id="anc17"></a>
 930     }
 931 
 932     @Override @DefinedBy(Api.COMPILER)
 933     public void setLocationFromPaths(Location location,
 934                             Collection&lt;? extends Path&gt; searchpath)
 935         throws IOException
 936     {
 937         nullCheck(location);
 938         locations.setLocation(location, nullCheck(searchpath));
<a name="18" id="anc18"></a>
 939     }
 940 
 941     @Override @DefinedBy(Api.COMPILER)
 942     public Iterable&lt;? extends File&gt; getLocation(Location location) {
 943         nullCheck(location);
 944         return asFiles(locations.getLocation(location));
 945     }
 946 
 947     @Override @DefinedBy(Api.COMPILER)
<a name="19" id="anc19"></a><span class="line-modified"> 948     public Iterable&lt;? extends Path&gt; getLocationAsPaths(Location location) {</span>
 949         nullCheck(location);
 950         return locations.getLocation(location);
 951     }
 952 
<a name="20" id="anc20"></a>





































































































 953     @Override @DefinedBy(Api.COMPILER)
 954     public boolean contains(Location location, FileObject fo) throws IOException {
 955         nullCheck(location);
 956         nullCheck(fo);
 957         Path p = asPath(fo);
 958         return locations.contains(location, p);
 959     }
 960 
 961     private Path getClassOutDir() {
 962         return locations.getOutputLocation(CLASS_OUTPUT);
 963     }
 964 
 965     private Path getSourceOutDir() {
 966         return locations.getOutputLocation(SOURCE_OUTPUT);
 967     }
 968 
 969     @Override @DefinedBy(Api.COMPILER)
 970     public Location getLocationForModule(Location location, String moduleName) throws IOException {
 971         checkModuleOrientedOrOutputLocation(location);
 972         nullCheck(moduleName);
 973         if (location == SOURCE_OUTPUT &amp;&amp; getSourceOutDir() == null)
 974             location = CLASS_OUTPUT;
 975         return locations.getLocationForModule(location, moduleName);
 976     }
 977 
 978     @Override @DefinedBy(Api.COMPILER)
 979     public &lt;S&gt; ServiceLoader&lt;S&gt; getServiceLoader(Location location, Class&lt;S&gt; service) throws IOException {
 980         nullCheck(location);
 981         nullCheck(service);
 982         getClass().getModule().addUses(service);
 983         if (location.isModuleOrientedLocation()) {
 984             Collection&lt;Path&gt; paths = locations.getLocation(location);
 985             ModuleFinder finder = ModuleFinder.of(paths.toArray(new Path[paths.size()]));
 986             ModuleLayer bootLayer = ModuleLayer.boot();
 987             Configuration cf = bootLayer.configuration().resolveAndBind(ModuleFinder.of(), finder, Collections.emptySet());
 988             ModuleLayer layer = bootLayer.defineModulesWithOneLoader(cf, ClassLoader.getSystemClassLoader());
 989             return ServiceLoader.load(layer, service);
 990         } else {
 991             return ServiceLoader.load(service, getClassLoader(location));
 992         }
 993     }
 994 
 995     @Override @DefinedBy(Api.COMPILER)
 996     public Location getLocationForModule(Location location, JavaFileObject fo) throws IOException {
 997         checkModuleOrientedOrOutputLocation(location);
 998         if (!(fo instanceof PathFileObject))
 999             return null;
1000         Path p = Locations.normalize(((PathFileObject) fo).path);
1001             // need to find p in location
1002         return locations.getLocationForModule(location, p);
1003     }
1004 
1005     @Override @DefinedBy(Api.COMPILER)
1006     public void setLocationForModule(Location location, String moduleName, Collection&lt;? extends Path&gt; paths)
1007             throws IOException {
1008         nullCheck(location);
1009         checkModuleOrientedOrOutputLocation(location);
1010         locations.setLocationForModule(location, nullCheck(moduleName), nullCheck(paths));
<a name="21" id="anc21"></a>
1011     }
1012 
1013     @Override @DefinedBy(Api.COMPILER)
1014     public String inferModuleName(Location location) {
1015         checkNotModuleOrientedLocation(location);
1016         return locations.inferModuleName(location);
1017     }
1018 
1019     @Override @DefinedBy(Api.COMPILER)
1020     public Iterable&lt;Set&lt;Location&gt;&gt; listLocationsForModules(Location location) throws IOException {
1021         checkModuleOrientedOrOutputLocation(location);
1022         return locations.listLocationsForModules(location);
1023     }
1024 
1025     @Override @DefinedBy(Api.COMPILER)
1026     public Path asPath(FileObject file) {
1027         if (file instanceof PathFileObject) {
1028             return ((PathFileObject) file).path;
1029         } else
1030             throw new IllegalArgumentException(file.getName());
1031     }
1032 
1033     /**
1034      * Enforces the specification of a &quot;relative&quot; name as used in
1035      * {@linkplain #getFileForInput(Location,String,String)
1036      * getFileForInput}.  This method must follow the rules defined in
1037      * that method, do not make any changes without consulting the
1038      * specification.
1039      */
1040     protected static boolean isRelativeUri(URI uri) {
1041         if (uri.isAbsolute())
1042             return false;
1043         String path = uri.normalize().getPath();
1044         if (path.length() == 0 /* isEmpty() is mustang API */)
1045             return false;
1046         if (!path.equals(uri.getPath())) // implicitly checks for embedded . and ..
1047             return false;
1048         if (path.startsWith(&quot;/&quot;) || path.startsWith(&quot;./&quot;) || path.startsWith(&quot;../&quot;))
1049             return false;
1050         return true;
1051     }
1052 
1053     // Convenience method
1054     protected static boolean isRelativeUri(String u) {
1055         try {
1056             return isRelativeUri(new URI(u));
1057         } catch (URISyntaxException e) {
1058             return false;
1059         }
1060     }
1061 
1062     /**
1063      * Converts a relative file name to a relative URI.  This is
1064      * different from File.toURI as this method does not canonicalize
1065      * the file before creating the URI.  Furthermore, no schema is
1066      * used.
1067      * @param file a relative file name
1068      * @return a relative URI
1069      * @throws IllegalArgumentException if the file name is not
1070      * relative according to the definition given in {@link
1071      * javax.tools.JavaFileManager#getFileForInput}
1072      */
1073     public static String getRelativeName(File file) {
1074         if (!file.isAbsolute()) {
1075             String result = file.getPath().replace(File.separatorChar, &#39;/&#39;);
1076             if (isRelativeUri(result))
1077                 return result;
1078         }
1079         throw new IllegalArgumentException(&quot;Invalid relative path: &quot; + file);
1080     }
1081 
1082     /**
1083      * Get a detail message from an IOException.
1084      * Most, but not all, instances of IOException provide a non-null result
1085      * for getLocalizedMessage().  But some instances return null: in these
<a name="22" id="anc22"></a><span class="line-modified">1086      * cases, fallover to getMessage(), and if even that is null, return the</span>
1087      * name of the exception itself.
1088      * @param e an IOException
1089      * @return a string to include in a compiler diagnostic
1090      */
1091     public static String getMessage(IOException e) {
1092         String s = e.getLocalizedMessage();
1093         if (s != null)
1094             return s;
1095         s = e.getMessage();
1096         if (s != null)
1097             return s;
1098         return e.toString();
1099     }
1100 
1101     private void checkOutputLocation(Location location) {
1102         Objects.requireNonNull(location);
1103         if (!location.isOutputLocation())
1104             throw new IllegalArgumentException(&quot;location is not an output location: &quot; + location.getName());
1105     }
1106 
1107     private void checkModuleOrientedOrOutputLocation(Location location) {
1108         Objects.requireNonNull(location);
1109         if (!location.isModuleOrientedLocation() &amp;&amp; !location.isOutputLocation())
1110             throw new IllegalArgumentException(
1111                     &quot;location is not an output location or a module-oriented location: &quot;
1112                             + location.getName());
1113     }
1114 
1115     private void checkNotModuleOrientedLocation(Location location) {
1116         Objects.requireNonNull(location);
1117         if (location.isModuleOrientedLocation())
1118             throw new IllegalArgumentException(&quot;location is module-oriented: &quot; + location.getName());
1119     }
1120 
1121     /* Converters between files and paths.
1122      * These are temporary until we can update the StandardJavaFileManager API.
1123      */
1124 
1125     private static Iterable&lt;Path&gt; asPaths(final Iterable&lt;? extends File&gt; files) {
1126         if (files == null)
1127             return null;
1128 
1129         return () -&gt; new Iterator&lt;Path&gt;() {
1130             Iterator&lt;? extends File&gt; iter = files.iterator();
1131 
1132             @Override
1133             public boolean hasNext() {
1134                 return iter.hasNext();
1135             }
1136 
1137             @Override
1138             public Path next() {
1139                 return iter.next().toPath();
1140             }
1141         };
1142     }
1143 
1144     private static Iterable&lt;File&gt; asFiles(final Iterable&lt;? extends Path&gt; paths) {
1145         if (paths == null)
1146             return null;
1147 
1148         return () -&gt; new Iterator&lt;File&gt;() {
1149             Iterator&lt;? extends Path&gt; iter = paths.iterator();
1150 
1151             @Override
1152             public boolean hasNext() {
1153                 return iter.hasNext();
1154             }
1155 
1156             @Override
1157             public File next() {
1158                 try {
1159                     return iter.next().toFile();
1160                 } catch (UnsupportedOperationException e) {
1161                     throw new IllegalStateException(e);
1162                 }
1163             }
1164         };
1165     }
<a name="23" id="anc23"></a>














1166 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
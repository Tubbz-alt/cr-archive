<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/ClassFinder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attribute.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DeferredCompletionFailureHandler.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/ClassFinder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Iterator;
 33 import java.util.Map;
 34 import java.util.NoSuchElementException;
 35 import java.util.Set;

 36 
 37 import javax.lang.model.SourceVersion;
 38 import javax.tools.JavaFileManager;
 39 import javax.tools.JavaFileManager.Location;
 40 import javax.tools.JavaFileObject;
 41 import javax.tools.JavaFileObject.Kind;
 42 import javax.tools.StandardJavaFileManager;
 43 import javax.tools.StandardLocation;
 44 
 45 import com.sun.tools.javac.code.Scope.WriteableScope;
 46 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 47 import com.sun.tools.javac.code.Symbol.Completer;
 48 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 49 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 50 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 51 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 52 import com.sun.tools.javac.comp.Annotate;
 53 import com.sun.tools.javac.file.JRTIndex;
 54 import com.sun.tools.javac.file.JavacFileManager;
 55 import com.sun.tools.javac.jvm.ClassReader;
</pre>
<hr />
<pre>
205             ? names.fromString(options.get(&quot;failcomplete&quot;))
206             : null;
207 
208         // Temporary, until more info is available from the module system.
209         boolean useCtProps;
210         JavaFileManager fm = context.get(JavaFileManager.class);
211         if (fm instanceof DelegatingJavaFileManager) {
212             fm = ((DelegatingJavaFileManager) fm).getBaseFileManager();
213         }
214         if (fm instanceof JavacFileManager) {
215             JavacFileManager jfm = (JavacFileManager) fm;
216             useCtProps = jfm.isDefaultBootClassPath() &amp;&amp; jfm.isSymbolFileEnabled();
217         } else if (fm.getClass().getName().equals(&quot;com.sun.tools.sjavac.comp.SmartFileManager&quot;)) {
218             useCtProps = !options.isSet(&quot;ignore.symbol.file&quot;);
219         } else {
220             useCtProps = false;
221         }
222         jrtIndex = useCtProps &amp;&amp; JRTIndex.isAvailable() ? JRTIndex.getSharedInstance() : null;
223 
224         profile = Profile.instance(context);
<span class="line-modified">225         cachedCompletionFailure = new CompletionFailure(null, (JCDiagnostic) null, dcfh);</span>
226         cachedCompletionFailure.setStackTrace(new StackTraceElement[0]);
227     }
228 
229 
230 /************************************************************************
231  * Temporary ct.sym replacement
232  *
233  * The following code is a temporary substitute for the ct.sym mechanism
234  * used in JDK 6 thru JDK 8.
235  * This mechanism will eventually be superseded by the Jigsaw module system.
236  ***********************************************************************/
237 
238     /**
239      * Returns any extra flags for a class symbol.
240      * This information used to be provided using private annotations
241      * in the class file in ct.sym; in time, this information will be
242      * available from the module system.
243      */
244     long getSupplementaryFlags(ClassSymbol c) {
245         if (jrtIndex == null || !jrtIndex.isInJRT(c.classfile) || c.name == names.module_info) {
</pre>
<hr />
<pre>
281      */
282     private void complete(Symbol sym) throws CompletionFailure {
283         if (sym.kind == TYP) {
284             try {
285                 ClassSymbol c = (ClassSymbol) sym;
286                 dependencies.push(c, CompletionCause.CLASS_READER);
287                 annotate.blockAnnotations();
288                 c.members_field = new Scope.ErrorScope(c); // make sure it&#39;s always defined
289                 completeOwners(c.owner);
290                 completeEnclosing(c);
291                 fillIn(c);
292             } finally {
293                 annotate.unblockAnnotationsNoFlush();
294                 dependencies.pop();
295             }
296         } else if (sym.kind == PCK) {
297             PackageSymbol p = (PackageSymbol)sym;
298             try {
299                 fillIn(p);
300             } catch (IOException ex) {
<span class="line-modified">301                 JCDiagnostic msg =</span>
<span class="line-modified">302                         diagFactory.fragment(Fragments.ExceptionMessage(ex.getLocalizedMessage()));</span>
<span class="line-modified">303                 throw new CompletionFailure(sym, msg, dcfh).initCause(ex);</span>



304             }
305         }
306         if (!reader.filling)
307             annotate.flush(); // finish attaching annotations
308     }
309 
310     /** complete up through the enclosing package. */
311     private void completeOwners(Symbol o) {
312         if (o.kind != PCK) completeOwners(o.owner);
313         o.complete();
314     }
315 
316     /**
317      * Tries to complete lexically enclosing classes if c looks like a
318      * nested class.  This is similar to completeOwners but handles
319      * the situation when a nested class is accessed directly as it is
320      * possible with the Tree API or javax.lang.model.*.
321      */
322     private void completeEnclosing(ClassSymbol c) {
323         if (c.owner.kind == PCK) {
324             Symbol owner = c.owner;
325             for (Name name : Convert.enclosingCandidates(Convert.shortName(c.name))) {
326                 Symbol encl = owner.members().findFirst(name);
327                 if (encl == null)
328                     encl = syms.getClass(c.packge().modle, TypeSymbol.formFlatName(name, owner));
329                 if (encl != null)
330                     encl.complete();
331             }
332         }
333     }
334 
335     /** Fill in definition of class `c&#39; from corresponding class or
336      *  source file.
337      */
338     void fillIn(ClassSymbol c) {
339         if (completionFailureName == c.fullname) {
<span class="line-modified">340             JCDiagnostic msg =</span>
<span class="line-modified">341                     diagFactory.fragment(Fragments.UserSelectedCompletionFailure);</span>
<span class="line-removed">342             throw new CompletionFailure(c, msg, dcfh);</span>
343         }
344         currentOwner = c;
345         JavaFileObject classfile = c.classfile;
346         if (classfile != null) {
347             JavaFileObject previousClassFile = currentClassFile;
348             Symbol prevOwner = c.owner;
349             Name prevName = c.fullname;
350             try {
351                 if (reader.filling) {
352                     Assert.error(&quot;Filling &quot; + classfile.toUri() + &quot; during &quot; + previousClassFile);
353                 }
354                 currentClassFile = classfile;
355                 if (verbose) {
356                     log.printVerbose(&quot;loading&quot;, currentClassFile.getName());
357                 }
358                 if (classfile.getKind() == JavaFileObject.Kind.CLASS) {
359                     reader.readClassFile(c);
360                     c.flags_field |= getSupplementaryFlags(c);
361                 } else {
362                     if (!sourceCompleter.isTerminal()) {
</pre>
<hr />
<pre>
373                     ClassSymbol csym = (ClassSymbol) sym;
374                     csym.owner = sym.packge();
375                     csym.owner.members().enter(sym);
376                     csym.fullname = sym.flatName();
377                     csym.name = Convert.shortName(sym.flatName());
378                     csym.reset();
379                 });
380                 c.fullname = prevName;
381                 c.name = Convert.shortName(prevName);
382                 c.reset();
383                 throw cf;
384             } finally {
385                 currentClassFile = previousClassFile;
386             }
387         } else {
388             throw classFileNotFound(c);
389         }
390     }
391     // where
392         private CompletionFailure classFileNotFound(ClassSymbol c) {
<span class="line-modified">393             JCDiagnostic diag =</span>
<span class="line-modified">394                 diagFactory.fragment(Fragments.ClassFileNotFound(c.flatname));</span>
<span class="line-removed">395             return newCompletionFailure(c, diag);</span>
396         }
397         /** Static factory for CompletionFailure objects.
398          *  In practice, only one can be used at a time, so we share one
399          *  to reduce the expense of allocating new exception objects.
400          */
401         private CompletionFailure newCompletionFailure(TypeSymbol c,
<span class="line-modified">402                                                        JCDiagnostic diag) {</span>
403             if (!cacheCompletionFailure) {
404                 // log.warning(&quot;proc.messager&quot;,
405                 //             Log.getLocalizedString(&quot;class.file.not.found&quot;, c.flatname));
406                 // c.debug.printStackTrace();
407                 return new CompletionFailure(c, diag, dcfh);
408             } else {
409                 CompletionFailure result = cachedCompletionFailure;
410                 result.sym = c;
<span class="line-modified">411                 result.diag = diag;</span>
412                 return result;
413             }
414         }
415         private final CompletionFailure cachedCompletionFailure;
416 
417 
418     /** Load a toplevel class with given fully qualified name
419      *  The class is entered into `classes&#39; only if load was successful.
420      */
421     public ClassSymbol loadClass(ModuleSymbol msym, Name flatname) throws CompletionFailure {
422         Assert.checkNonNull(msym);
423         Name packageName = Convert.packagePart(flatname);
424         PackageSymbol ps = syms.lookupPackage(msym, packageName);
425 
426         Assert.checkNonNull(ps.modle, () -&gt; &quot;msym=&quot; + msym + &quot;; flatName=&quot; + flatname);
427 
428         boolean absent = syms.getClass(ps.modle, flatname) == null;
429         ClassSymbol c = syms.enterClass(ps.modle, flatname);
430 
431         if (c.members_field == null) {
</pre>
<hr />
<pre>
765                 public JavaFileObject next() {
766                     if (!hasNext())
767                         throw new NoSuchElementException();
768                     JavaFileObject result = next;
769                     next = null;
770                     return result;
771                 }
772 
773             };
774         }
775 
776     /**
777      * Used for bad class definition files, such as bad .class files or
778      * for .java files with unexpected package or class names.
779      */
780     public static class BadClassFile extends CompletionFailure {
781         private static final long serialVersionUID = 0;
782 
783         public BadClassFile(TypeSymbol sym, JavaFileObject file, JCDiagnostic diag,
784                 JCDiagnostic.Factory diagFactory, DeferredCompletionFailureHandler dcfh) {
<span class="line-modified">785             super(sym, createBadClassFileDiagnostic(file, diag, diagFactory), dcfh);</span>
786         }
787         // where
788         private static JCDiagnostic createBadClassFileDiagnostic(
789                 JavaFileObject file, JCDiagnostic diag, JCDiagnostic.Factory diagFactory) {
790             String key = (file.getKind() == JavaFileObject.Kind.SOURCE
791                         ? &quot;bad.source.file.header&quot; : &quot;bad.class.file.header&quot;);
792             return diagFactory.fragment(key, file, diag);
793         }
794     }
795 
796     public static class BadEnclosingMethodAttr extends BadClassFile {
797         private static final long serialVersionUID = 0;
798 
799         public BadEnclosingMethodAttr(TypeSymbol sym, JavaFileObject file, JCDiagnostic diag,
800                 JCDiagnostic.Factory diagFactory, DeferredCompletionFailureHandler dcfh) {
801             super(sym, file, diag, diagFactory, dcfh);
802         }
803     }
804 }
</pre>
</td>
<td>
<hr />
<pre>
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.code;
 27 
 28 import java.io.IOException;
 29 import java.nio.file.Path;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Iterator;
 33 import java.util.Map;
 34 import java.util.NoSuchElementException;
 35 import java.util.Set;
<span class="line-added"> 36 import java.util.function.Supplier;</span>
 37 
 38 import javax.lang.model.SourceVersion;
 39 import javax.tools.JavaFileManager;
 40 import javax.tools.JavaFileManager.Location;
 41 import javax.tools.JavaFileObject;
 42 import javax.tools.JavaFileObject.Kind;
 43 import javax.tools.StandardJavaFileManager;
 44 import javax.tools.StandardLocation;
 45 
 46 import com.sun.tools.javac.code.Scope.WriteableScope;
 47 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 48 import com.sun.tools.javac.code.Symbol.Completer;
 49 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 50 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 51 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 52 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 53 import com.sun.tools.javac.comp.Annotate;
 54 import com.sun.tools.javac.file.JRTIndex;
 55 import com.sun.tools.javac.file.JavacFileManager;
 56 import com.sun.tools.javac.jvm.ClassReader;
</pre>
<hr />
<pre>
206             ? names.fromString(options.get(&quot;failcomplete&quot;))
207             : null;
208 
209         // Temporary, until more info is available from the module system.
210         boolean useCtProps;
211         JavaFileManager fm = context.get(JavaFileManager.class);
212         if (fm instanceof DelegatingJavaFileManager) {
213             fm = ((DelegatingJavaFileManager) fm).getBaseFileManager();
214         }
215         if (fm instanceof JavacFileManager) {
216             JavacFileManager jfm = (JavacFileManager) fm;
217             useCtProps = jfm.isDefaultBootClassPath() &amp;&amp; jfm.isSymbolFileEnabled();
218         } else if (fm.getClass().getName().equals(&quot;com.sun.tools.sjavac.comp.SmartFileManager&quot;)) {
219             useCtProps = !options.isSet(&quot;ignore.symbol.file&quot;);
220         } else {
221             useCtProps = false;
222         }
223         jrtIndex = useCtProps &amp;&amp; JRTIndex.isAvailable() ? JRTIndex.getSharedInstance() : null;
224 
225         profile = Profile.instance(context);
<span class="line-modified">226         cachedCompletionFailure = new CompletionFailure(null, () -&gt; null, dcfh);</span>
227         cachedCompletionFailure.setStackTrace(new StackTraceElement[0]);
228     }
229 
230 
231 /************************************************************************
232  * Temporary ct.sym replacement
233  *
234  * The following code is a temporary substitute for the ct.sym mechanism
235  * used in JDK 6 thru JDK 8.
236  * This mechanism will eventually be superseded by the Jigsaw module system.
237  ***********************************************************************/
238 
239     /**
240      * Returns any extra flags for a class symbol.
241      * This information used to be provided using private annotations
242      * in the class file in ct.sym; in time, this information will be
243      * available from the module system.
244      */
245     long getSupplementaryFlags(ClassSymbol c) {
246         if (jrtIndex == null || !jrtIndex.isInJRT(c.classfile) || c.name == names.module_info) {
</pre>
<hr />
<pre>
282      */
283     private void complete(Symbol sym) throws CompletionFailure {
284         if (sym.kind == TYP) {
285             try {
286                 ClassSymbol c = (ClassSymbol) sym;
287                 dependencies.push(c, CompletionCause.CLASS_READER);
288                 annotate.blockAnnotations();
289                 c.members_field = new Scope.ErrorScope(c); // make sure it&#39;s always defined
290                 completeOwners(c.owner);
291                 completeEnclosing(c);
292                 fillIn(c);
293             } finally {
294                 annotate.unblockAnnotationsNoFlush();
295                 dependencies.pop();
296             }
297         } else if (sym.kind == PCK) {
298             PackageSymbol p = (PackageSymbol)sym;
299             try {
300                 fillIn(p);
301             } catch (IOException ex) {
<span class="line-modified">302                 throw new CompletionFailure(</span>
<span class="line-modified">303                         sym,</span>
<span class="line-modified">304                         () -&gt; diagFactory.fragment(</span>
<span class="line-added">305                             Fragments.ExceptionMessage(ex.getLocalizedMessage())),</span>
<span class="line-added">306                         dcfh)</span>
<span class="line-added">307                     .initCause(ex);</span>
308             }
309         }
310         if (!reader.filling)
311             annotate.flush(); // finish attaching annotations
312     }
313 
314     /** complete up through the enclosing package. */
315     private void completeOwners(Symbol o) {
316         if (o.kind != PCK) completeOwners(o.owner);
317         o.complete();
318     }
319 
320     /**
321      * Tries to complete lexically enclosing classes if c looks like a
322      * nested class.  This is similar to completeOwners but handles
323      * the situation when a nested class is accessed directly as it is
324      * possible with the Tree API or javax.lang.model.*.
325      */
326     private void completeEnclosing(ClassSymbol c) {
327         if (c.owner.kind == PCK) {
328             Symbol owner = c.owner;
329             for (Name name : Convert.enclosingCandidates(Convert.shortName(c.name))) {
330                 Symbol encl = owner.members().findFirst(name);
331                 if (encl == null)
332                     encl = syms.getClass(c.packge().modle, TypeSymbol.formFlatName(name, owner));
333                 if (encl != null)
334                     encl.complete();
335             }
336         }
337     }
338 
339     /** Fill in definition of class `c&#39; from corresponding class or
340      *  source file.
341      */
342     void fillIn(ClassSymbol c) {
343         if (completionFailureName == c.fullname) {
<span class="line-modified">344             throw new CompletionFailure(</span>
<span class="line-modified">345                 c, () -&gt; diagFactory.fragment(Fragments.UserSelectedCompletionFailure), dcfh);</span>

346         }
347         currentOwner = c;
348         JavaFileObject classfile = c.classfile;
349         if (classfile != null) {
350             JavaFileObject previousClassFile = currentClassFile;
351             Symbol prevOwner = c.owner;
352             Name prevName = c.fullname;
353             try {
354                 if (reader.filling) {
355                     Assert.error(&quot;Filling &quot; + classfile.toUri() + &quot; during &quot; + previousClassFile);
356                 }
357                 currentClassFile = classfile;
358                 if (verbose) {
359                     log.printVerbose(&quot;loading&quot;, currentClassFile.getName());
360                 }
361                 if (classfile.getKind() == JavaFileObject.Kind.CLASS) {
362                     reader.readClassFile(c);
363                     c.flags_field |= getSupplementaryFlags(c);
364                 } else {
365                     if (!sourceCompleter.isTerminal()) {
</pre>
<hr />
<pre>
376                     ClassSymbol csym = (ClassSymbol) sym;
377                     csym.owner = sym.packge();
378                     csym.owner.members().enter(sym);
379                     csym.fullname = sym.flatName();
380                     csym.name = Convert.shortName(sym.flatName());
381                     csym.reset();
382                 });
383                 c.fullname = prevName;
384                 c.name = Convert.shortName(prevName);
385                 c.reset();
386                 throw cf;
387             } finally {
388                 currentClassFile = previousClassFile;
389             }
390         } else {
391             throw classFileNotFound(c);
392         }
393     }
394     // where
395         private CompletionFailure classFileNotFound(ClassSymbol c) {
<span class="line-modified">396             return newCompletionFailure(</span>
<span class="line-modified">397                 c, () -&gt; diagFactory.fragment(Fragments.ClassFileNotFound(c.flatname)));</span>

398         }
399         /** Static factory for CompletionFailure objects.
400          *  In practice, only one can be used at a time, so we share one
401          *  to reduce the expense of allocating new exception objects.
402          */
403         private CompletionFailure newCompletionFailure(TypeSymbol c,
<span class="line-modified">404                                                        Supplier&lt;JCDiagnostic&gt; diag) {</span>
405             if (!cacheCompletionFailure) {
406                 // log.warning(&quot;proc.messager&quot;,
407                 //             Log.getLocalizedString(&quot;class.file.not.found&quot;, c.flatname));
408                 // c.debug.printStackTrace();
409                 return new CompletionFailure(c, diag, dcfh);
410             } else {
411                 CompletionFailure result = cachedCompletionFailure;
412                 result.sym = c;
<span class="line-modified">413                 result.resetDiagnostic(diag);</span>
414                 return result;
415             }
416         }
417         private final CompletionFailure cachedCompletionFailure;
418 
419 
420     /** Load a toplevel class with given fully qualified name
421      *  The class is entered into `classes&#39; only if load was successful.
422      */
423     public ClassSymbol loadClass(ModuleSymbol msym, Name flatname) throws CompletionFailure {
424         Assert.checkNonNull(msym);
425         Name packageName = Convert.packagePart(flatname);
426         PackageSymbol ps = syms.lookupPackage(msym, packageName);
427 
428         Assert.checkNonNull(ps.modle, () -&gt; &quot;msym=&quot; + msym + &quot;; flatName=&quot; + flatname);
429 
430         boolean absent = syms.getClass(ps.modle, flatname) == null;
431         ClassSymbol c = syms.enterClass(ps.modle, flatname);
432 
433         if (c.members_field == null) {
</pre>
<hr />
<pre>
767                 public JavaFileObject next() {
768                     if (!hasNext())
769                         throw new NoSuchElementException();
770                     JavaFileObject result = next;
771                     next = null;
772                     return result;
773                 }
774 
775             };
776         }
777 
778     /**
779      * Used for bad class definition files, such as bad .class files or
780      * for .java files with unexpected package or class names.
781      */
782     public static class BadClassFile extends CompletionFailure {
783         private static final long serialVersionUID = 0;
784 
785         public BadClassFile(TypeSymbol sym, JavaFileObject file, JCDiagnostic diag,
786                 JCDiagnostic.Factory diagFactory, DeferredCompletionFailureHandler dcfh) {
<span class="line-modified">787             super(sym, () -&gt; createBadClassFileDiagnostic(file, diag, diagFactory), dcfh);</span>
788         }
789         // where
790         private static JCDiagnostic createBadClassFileDiagnostic(
791                 JavaFileObject file, JCDiagnostic diag, JCDiagnostic.Factory diagFactory) {
792             String key = (file.getKind() == JavaFileObject.Kind.SOURCE
793                         ? &quot;bad.source.file.header&quot; : &quot;bad.class.file.header&quot;);
794             return diagFactory.fragment(key, file, diag);
795         }
796     }
797 
798     public static class BadEnclosingMethodAttr extends BadClassFile {
799         private static final long serialVersionUID = 0;
800 
801         public BadEnclosingMethodAttr(TypeSymbol sym, JavaFileObject file, JCDiagnostic diag,
802                 JCDiagnostic.Factory diagFactory, DeferredCompletionFailureHandler dcfh) {
803             super(sym, file, diag, diagFactory, dcfh);
804         }
805     }
806 }
</pre>
</td>
</tr>
</table>
<center><a href="Attribute.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="DeferredCompletionFailureHandler.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
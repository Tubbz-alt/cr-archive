<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Flow.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InferenceContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Infer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 120         Options options = Options.instance(context);
 121         Source source = Source.instance(context);
 122         allowGraphInference = Feature.GRAPH_INFERENCE.allowedInSource(source)
 123                 &amp;&amp; options.isUnset(&quot;useLegacyInference&quot;);
 124         dependenciesFolder = options.get(&quot;debug.dumpInferenceGraphsTo&quot;);
 125         pendingGraphs = List.nil();
 126 
 127         emptyContext = new InferenceContext(this, List.nil());
 128     }
 129 
 130     /** A value for prototypes that admit any type, including polymorphic ones. */
 131     public static final Type anyPoly = new JCNoType();
 132 
 133    /**
 134     * This exception class is design to store a list of diagnostics corresponding
 135     * to inference errors that can arise during a method applicability check.
 136     */
 137     public static class InferenceException extends InapplicableMethodException {
 138         private static final long serialVersionUID = 0;
 139 
<span class="line-modified"> 140         List&lt;JCDiagnostic&gt; messages = List.nil();</span>
 141 
 142         InferenceException() {
 143             super(null);
 144         }
 145 
 146         @Override
 147         public JCDiagnostic getDiagnostic() {
 148             return messages.head;
 149         }
 150     }
 151 
 152     InferenceException error(JCDiagnostic diag) {
 153         InferenceException result = new InferenceException();
 154         if (diag != null) {
 155             result.messages = result.messages.append(diag);
 156         }
 157         return result;
 158     }
 159 
 160     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Inference routines&quot;&gt;
</pre>
<hr />
<pre>
 262 
 263         private List&lt;Type&gt; roots(MethodType mt, DeferredAttrContext deferredAttrContext) {
 264             if (deferredAttrContext != null &amp;&amp; deferredAttrContext.mode == AttrMode.CHECK) {
 265                 ListBuffer&lt;Type&gt; roots = new ListBuffer&lt;&gt;();
 266                 roots.add(mt.getReturnType());
 267                 for (DeferredAttr.DeferredAttrNode n : deferredAttrContext.deferredAttrNodes) {
 268                     roots.addAll(n.deferredStuckPolicy.stuckVars());
 269                     roots.addAll(n.deferredStuckPolicy.depVars());
 270                 }
 271                 List&lt;Type&gt; thrownVars = deferredAttrContext.inferenceContext.inferencevars.stream()
 272                                 .filter(tv -&gt; (tv.tsym.flags() &amp; Flags.THROWS) != 0).collect(List.collector());
 273                 List&lt;Type&gt; result = roots.toList();
 274                 result = result.appendList(thrownVars.diff(result));
 275                 return result;
 276             } else {
 277                 return List.of(mt.getReturnType());
 278             }
 279         }
 280 
 281     /**
<span class="line-modified"> 282      * A partially infered method/constructor type; such a type can be checked multiple times</span>
 283      * against different targets.
 284      */
 285     public class PartiallyInferredMethodType extends MethodType {
 286         public PartiallyInferredMethodType(MethodType mtype, InferenceContext inferenceContext, Env&lt;AttrContext&gt; env, Warner warn) {
 287             super(mtype.getParameterTypes(), mtype.getReturnType(), mtype.getThrownTypes(), mtype.tsym);
 288             this.inferenceContext = inferenceContext;
 289             this.env = env;
 290             this.warn = warn;
 291         }
 292 
 293         /** The inference context. */
 294         final InferenceContext inferenceContext;
 295 
 296         /** The attribution environment. */
 297         Env&lt;AttrContext&gt; env;
 298 
 299         /** The warner. */
 300         final Warner warn;
 301 
 302         @Override
 303         public boolean isPartial() {
 304             return true;
 305         }
 306 
 307         /**
 308          * Checks this type against a target; this means generating return type constraints, solve
<span class="line-modified"> 309          * and then roll back the results (to avoid poolluting the context).</span>
 310          */
 311         Type check(Attr.ResultInfo resultInfo) {
 312             Warner noWarnings = new Warner(null);
 313             List&lt;Type&gt; saved_undet = null;
 314             try {
 315                 /** we need to save the inference context before generating target type constraints.
 316                  *  This constraints may pollute the inference context and make it useless in case we
 317                  *  need to use it several times: with several targets.
 318                  */
 319                 saved_undet = inferenceContext.save();
 320                 boolean unchecked = warn.hasNonSilentLint(Lint.LintCategory.UNCHECKED);
 321                 if (!unchecked) {
 322                     boolean shouldPropagate = shouldPropagate(getReturnType(), resultInfo, inferenceContext);
 323 
 324                     InferenceContext minContext = shouldPropagate ?
 325                             inferenceContext.min(roots(asMethodType(), null), false, warn) :
 326                             inferenceContext;
 327 
 328                     MethodType other = (MethodType)minContext.update(asMethodType());
 329                     Type newRestype = generateReturnConstraints(env.tree, resultInfo,  //B3
</pre>
<hr />
<pre>
1304         throw new AssertionError(&quot;can&#39;t get to this place&quot;);
1305     }
1306 
1307     // &lt;/editor-fold&gt;
1308 
1309     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Inference engine&quot;&gt;
1310     /**
1311      * Graph inference strategy - act as an input to the inference solver; a strategy is
1312      * composed of two ingredients: (i) find a node to solve in the inference graph,
1313      * and (ii) tell th engine when we are done fixing inference variables
1314      */
1315     interface GraphStrategy {
1316 
1317         /**
1318          * A NodeNotFoundException is thrown whenever an inference strategy fails
1319          * to pick the next node to solve in the inference graph.
1320          */
1321         public static class NodeNotFoundException extends RuntimeException {
1322             private static final long serialVersionUID = 0;
1323 
<span class="line-modified">1324             InferenceGraph graph;</span>
1325 
1326             public NodeNotFoundException(InferenceGraph graph) {
1327                 this.graph = graph;
1328             }
1329         }
1330         /**
1331          * Pick the next node (leaf) to solve in the graph
1332          */
1333         Node pickNode(InferenceGraph g) throws NodeNotFoundException;
1334         /**
1335          * Is this the last step?
1336          */
1337         boolean done();
1338     }
1339 
1340     /**
1341      * Simple solver strategy class that locates all leaves inside a graph
1342      * and picks the first leaf as the next node to solve
1343      */
1344     abstract class LeafSolver implements GraphStrategy {
</pre>
<hr />
<pre>
1604         GraphInferenceSteps(EnumSet&lt;InferenceStep&gt; steps) {
1605             this.steps = steps;
1606         }
1607     }
1608 
1609     /**
1610      * There are two kinds of dependencies between inference variables. The basic
1611      * kind of dependency (or bound dependency) arises when a variable mention
1612      * another variable in one of its bounds. There&#39;s also a more subtle kind
1613      * of dependency that arises when a variable &#39;might&#39; lead to better constraints
1614      * on another variable (this is typically the case with variables holding up
1615      * stuck expressions).
1616      */
1617     enum DependencyKind implements GraphUtils.DependencyKind {
1618 
1619         /** bound dependency */
1620         BOUND(&quot;dotted&quot;),
1621         /** stuck dependency */
1622         STUCK(&quot;dashed&quot;);
1623 
<span class="line-modified">1624         final String dotSyle;</span>
1625 
<span class="line-modified">1626         private DependencyKind(String dotSyle) {</span>
<span class="line-modified">1627             this.dotSyle = dotSyle;</span>
1628         }
1629     }
1630 
1631     /**
1632      * This is the graph inference solver - the solver organizes all inference variables in
1633      * a given inference context by bound dependencies - in the general case, such dependencies
1634      * would lead to a cyclic directed graph (hence the name); the dependency info is used to build
1635      * an acyclic graph, where all cyclic variables are bundled together. An inference
1636      * step corresponds to solving a node in the acyclic graph - this is done by
1637      * relying on a given strategy (see GraphStrategy).
1638      */
1639     class GraphSolver {
1640 
1641         InferenceContext inferenceContext;
1642         Warner warn;
1643 
1644         GraphSolver(InferenceContext inferenceContext, Warner warn) {
1645             this.inferenceContext = inferenceContext;
1646             this.warn = warn;
1647         }
</pre>
<hr />
<pre>
1812                  * topology.
1813                  */
1814                 private void graphChanged(Node from, Node to) {
1815                     if (removeDependency(from)) {
1816                         if (to != null) {
1817                             addDependency(to);
1818                         }
1819                     }
1820                 }
1821 
1822                 @Override
1823                 public Properties nodeAttributes() {
1824                     Properties p = new Properties();
1825                     p.put(&quot;label&quot;, &quot;\&quot;&quot; + toString() + &quot;\&quot;&quot;);
1826                     return p;
1827                 }
1828 
1829                 @Override
1830                 public Properties dependencyAttributes(Node sink, GraphUtils.DependencyKind dk) {
1831                     Properties p = new Properties();
<span class="line-modified">1832                     p.put(&quot;style&quot;, ((DependencyKind)dk).dotSyle);</span>
1833                     StringBuilder buf = new StringBuilder();
1834                     String sep = &quot;&quot;;
1835                     for (Type from : data) {
1836                         UndetVar uv = (UndetVar)inferenceContext.asUndetVar(from);
1837                         for (Type bound : uv.getBounds(InferenceBound.values())) {
1838                             if (bound.containsAny(List.from(sink.data))) {
1839                                 buf.append(sep);
1840                                 buf.append(bound);
1841                                 sep = &quot;,&quot;;
1842                             }
1843                         }
1844                     }
1845                     p.put(&quot;label&quot;, &quot;\&quot;&quot; + buf.toString() + &quot;\&quot;&quot;);
1846                     return p;
1847                 }
1848             }
1849 
1850             /** the nodes in the inference graph */
1851             ArrayList&lt;Node&gt; nodes;
1852 
</pre>
</td>
<td>
<hr />
<pre>
 120         Options options = Options.instance(context);
 121         Source source = Source.instance(context);
 122         allowGraphInference = Feature.GRAPH_INFERENCE.allowedInSource(source)
 123                 &amp;&amp; options.isUnset(&quot;useLegacyInference&quot;);
 124         dependenciesFolder = options.get(&quot;debug.dumpInferenceGraphsTo&quot;);
 125         pendingGraphs = List.nil();
 126 
 127         emptyContext = new InferenceContext(this, List.nil());
 128     }
 129 
 130     /** A value for prototypes that admit any type, including polymorphic ones. */
 131     public static final Type anyPoly = new JCNoType();
 132 
 133    /**
 134     * This exception class is design to store a list of diagnostics corresponding
 135     * to inference errors that can arise during a method applicability check.
 136     */
 137     public static class InferenceException extends InapplicableMethodException {
 138         private static final long serialVersionUID = 0;
 139 
<span class="line-modified"> 140         transient List&lt;JCDiagnostic&gt; messages = List.nil();</span>
 141 
 142         InferenceException() {
 143             super(null);
 144         }
 145 
 146         @Override
 147         public JCDiagnostic getDiagnostic() {
 148             return messages.head;
 149         }
 150     }
 151 
 152     InferenceException error(JCDiagnostic diag) {
 153         InferenceException result = new InferenceException();
 154         if (diag != null) {
 155             result.messages = result.messages.append(diag);
 156         }
 157         return result;
 158     }
 159 
 160     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Inference routines&quot;&gt;
</pre>
<hr />
<pre>
 262 
 263         private List&lt;Type&gt; roots(MethodType mt, DeferredAttrContext deferredAttrContext) {
 264             if (deferredAttrContext != null &amp;&amp; deferredAttrContext.mode == AttrMode.CHECK) {
 265                 ListBuffer&lt;Type&gt; roots = new ListBuffer&lt;&gt;();
 266                 roots.add(mt.getReturnType());
 267                 for (DeferredAttr.DeferredAttrNode n : deferredAttrContext.deferredAttrNodes) {
 268                     roots.addAll(n.deferredStuckPolicy.stuckVars());
 269                     roots.addAll(n.deferredStuckPolicy.depVars());
 270                 }
 271                 List&lt;Type&gt; thrownVars = deferredAttrContext.inferenceContext.inferencevars.stream()
 272                                 .filter(tv -&gt; (tv.tsym.flags() &amp; Flags.THROWS) != 0).collect(List.collector());
 273                 List&lt;Type&gt; result = roots.toList();
 274                 result = result.appendList(thrownVars.diff(result));
 275                 return result;
 276             } else {
 277                 return List.of(mt.getReturnType());
 278             }
 279         }
 280 
 281     /**
<span class="line-modified"> 282      * A partially inferred method/constructor type; such a type can be checked multiple times</span>
 283      * against different targets.
 284      */
 285     public class PartiallyInferredMethodType extends MethodType {
 286         public PartiallyInferredMethodType(MethodType mtype, InferenceContext inferenceContext, Env&lt;AttrContext&gt; env, Warner warn) {
 287             super(mtype.getParameterTypes(), mtype.getReturnType(), mtype.getThrownTypes(), mtype.tsym);
 288             this.inferenceContext = inferenceContext;
 289             this.env = env;
 290             this.warn = warn;
 291         }
 292 
 293         /** The inference context. */
 294         final InferenceContext inferenceContext;
 295 
 296         /** The attribution environment. */
 297         Env&lt;AttrContext&gt; env;
 298 
 299         /** The warner. */
 300         final Warner warn;
 301 
 302         @Override
 303         public boolean isPartial() {
 304             return true;
 305         }
 306 
 307         /**
 308          * Checks this type against a target; this means generating return type constraints, solve
<span class="line-modified"> 309          * and then roll back the results (to avoid polluting the context).</span>
 310          */
 311         Type check(Attr.ResultInfo resultInfo) {
 312             Warner noWarnings = new Warner(null);
 313             List&lt;Type&gt; saved_undet = null;
 314             try {
 315                 /** we need to save the inference context before generating target type constraints.
 316                  *  This constraints may pollute the inference context and make it useless in case we
 317                  *  need to use it several times: with several targets.
 318                  */
 319                 saved_undet = inferenceContext.save();
 320                 boolean unchecked = warn.hasNonSilentLint(Lint.LintCategory.UNCHECKED);
 321                 if (!unchecked) {
 322                     boolean shouldPropagate = shouldPropagate(getReturnType(), resultInfo, inferenceContext);
 323 
 324                     InferenceContext minContext = shouldPropagate ?
 325                             inferenceContext.min(roots(asMethodType(), null), false, warn) :
 326                             inferenceContext;
 327 
 328                     MethodType other = (MethodType)minContext.update(asMethodType());
 329                     Type newRestype = generateReturnConstraints(env.tree, resultInfo,  //B3
</pre>
<hr />
<pre>
1304         throw new AssertionError(&quot;can&#39;t get to this place&quot;);
1305     }
1306 
1307     // &lt;/editor-fold&gt;
1308 
1309     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Inference engine&quot;&gt;
1310     /**
1311      * Graph inference strategy - act as an input to the inference solver; a strategy is
1312      * composed of two ingredients: (i) find a node to solve in the inference graph,
1313      * and (ii) tell th engine when we are done fixing inference variables
1314      */
1315     interface GraphStrategy {
1316 
1317         /**
1318          * A NodeNotFoundException is thrown whenever an inference strategy fails
1319          * to pick the next node to solve in the inference graph.
1320          */
1321         public static class NodeNotFoundException extends RuntimeException {
1322             private static final long serialVersionUID = 0;
1323 
<span class="line-modified">1324             transient InferenceGraph graph;</span>
1325 
1326             public NodeNotFoundException(InferenceGraph graph) {
1327                 this.graph = graph;
1328             }
1329         }
1330         /**
1331          * Pick the next node (leaf) to solve in the graph
1332          */
1333         Node pickNode(InferenceGraph g) throws NodeNotFoundException;
1334         /**
1335          * Is this the last step?
1336          */
1337         boolean done();
1338     }
1339 
1340     /**
1341      * Simple solver strategy class that locates all leaves inside a graph
1342      * and picks the first leaf as the next node to solve
1343      */
1344     abstract class LeafSolver implements GraphStrategy {
</pre>
<hr />
<pre>
1604         GraphInferenceSteps(EnumSet&lt;InferenceStep&gt; steps) {
1605             this.steps = steps;
1606         }
1607     }
1608 
1609     /**
1610      * There are two kinds of dependencies between inference variables. The basic
1611      * kind of dependency (or bound dependency) arises when a variable mention
1612      * another variable in one of its bounds. There&#39;s also a more subtle kind
1613      * of dependency that arises when a variable &#39;might&#39; lead to better constraints
1614      * on another variable (this is typically the case with variables holding up
1615      * stuck expressions).
1616      */
1617     enum DependencyKind implements GraphUtils.DependencyKind {
1618 
1619         /** bound dependency */
1620         BOUND(&quot;dotted&quot;),
1621         /** stuck dependency */
1622         STUCK(&quot;dashed&quot;);
1623 
<span class="line-modified">1624         final String dotStyle;</span>
1625 
<span class="line-modified">1626         private DependencyKind(String dotStyle) {</span>
<span class="line-modified">1627             this.dotStyle = dotStyle;</span>
1628         }
1629     }
1630 
1631     /**
1632      * This is the graph inference solver - the solver organizes all inference variables in
1633      * a given inference context by bound dependencies - in the general case, such dependencies
1634      * would lead to a cyclic directed graph (hence the name); the dependency info is used to build
1635      * an acyclic graph, where all cyclic variables are bundled together. An inference
1636      * step corresponds to solving a node in the acyclic graph - this is done by
1637      * relying on a given strategy (see GraphStrategy).
1638      */
1639     class GraphSolver {
1640 
1641         InferenceContext inferenceContext;
1642         Warner warn;
1643 
1644         GraphSolver(InferenceContext inferenceContext, Warner warn) {
1645             this.inferenceContext = inferenceContext;
1646             this.warn = warn;
1647         }
</pre>
<hr />
<pre>
1812                  * topology.
1813                  */
1814                 private void graphChanged(Node from, Node to) {
1815                     if (removeDependency(from)) {
1816                         if (to != null) {
1817                             addDependency(to);
1818                         }
1819                     }
1820                 }
1821 
1822                 @Override
1823                 public Properties nodeAttributes() {
1824                     Properties p = new Properties();
1825                     p.put(&quot;label&quot;, &quot;\&quot;&quot; + toString() + &quot;\&quot;&quot;);
1826                     return p;
1827                 }
1828 
1829                 @Override
1830                 public Properties dependencyAttributes(Node sink, GraphUtils.DependencyKind dk) {
1831                     Properties p = new Properties();
<span class="line-modified">1832                     p.put(&quot;style&quot;, ((DependencyKind)dk).dotStyle);</span>
1833                     StringBuilder buf = new StringBuilder();
1834                     String sep = &quot;&quot;;
1835                     for (Type from : data) {
1836                         UndetVar uv = (UndetVar)inferenceContext.asUndetVar(from);
1837                         for (Type bound : uv.getBounds(InferenceBound.values())) {
1838                             if (bound.containsAny(List.from(sink.data))) {
1839                                 buf.append(sep);
1840                                 buf.append(bound);
1841                                 sep = &quot;,&quot;;
1842                             }
1843                         }
1844                     }
1845                     p.put(&quot;label&quot;, &quot;\&quot;&quot; + buf.toString() + &quot;\&quot;&quot;);
1846                     return p;
1847                 }
1848             }
1849 
1850             /** the nodes in the inference graph */
1851             ArrayList&lt;Node&gt; nodes;
1852 
</pre>
</td>
</tr>
</table>
<center><a href="Flow.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InferenceContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
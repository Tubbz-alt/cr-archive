<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacRoundEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.processing;
 27 
 28 import java.lang.annotation.Annotation;
 29 import javax.annotation.processing.*;
 30 import javax.lang.model.element.*;
 31 import javax.lang.model.util.*;
 32 import java.util.*;
 33 
 34 import com.sun.tools.javac.code.Source.Feature;
 35 import com.sun.tools.javac.util.DefinedBy;
 36 import com.sun.tools.javac.util.DefinedBy.Api;
 37 
 38 /**
 39  * Object providing state about a prior round of annotation processing.
 40  *
 41  * &lt;p&gt;The methods in this class do not take type annotations into account,
 42  * as target types, not java elements.
 43  *
 44  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 45  * If you write code that depends on this, you do so at your own risk.
 46  * This code and its internal interfaces are subject to change or
 47  * deletion without notice.&lt;/b&gt;
 48  */
 49 public class JavacRoundEnvironment implements RoundEnvironment {
 50     // Default equals and hashCode methods are okay.
 51 
 52     private final boolean processingOver;
 53     private final boolean errorRaised;
 54     private final ProcessingEnvironment processingEnv;
 55     private final Elements eltUtils;
 56 
 57     private final boolean allowModules;
 58 
 59     // Caller must pass in an immutable set
 60     private final Set&lt;? extends Element&gt; rootElements;
 61 
 62     JavacRoundEnvironment(boolean processingOver,
 63                           boolean errorRaised,
 64                           Set&lt;? extends Element&gt; rootElements,
 65                           JavacProcessingEnvironment processingEnv) {
 66         this.processingOver = processingOver;
 67         this.errorRaised = errorRaised;
 68         this.rootElements = rootElements;
 69         this.processingEnv = processingEnv;
 70         this.allowModules = Feature.MODULES.allowedInSource(processingEnv.source);
 71         this.eltUtils = processingEnv.getElementUtils();
 72     }
 73 
 74     public String toString() {
 75         return String.format(&quot;[errorRaised=%b, rootElements=%s, processingOver=%b]&quot;,
 76                              errorRaised,
 77                              rootElements,
 78                              processingOver);
 79     }
 80 
 81     @DefinedBy(Api.ANNOTATION_PROCESSING)
 82     public boolean processingOver() {
 83         return processingOver;
 84     }
 85 
 86     /**
 87      * Returns {@code true} if an error was raised in the prior round
 88      * of processing; returns {@code false} otherwise.
 89      *
 90      * @return {@code true} if an error was raised in the prior round
 91      * of processing; returns {@code false} otherwise.
 92      */
 93     @DefinedBy(Api.ANNOTATION_PROCESSING)
 94     public boolean errorRaised() {
 95         return errorRaised;
 96     }
 97 
 98     /**
 99      * Returns the type elements specified by the prior round.
100      *
101      * @return the types elements specified by the prior round, or an
102      * empty set if there were none
103      */
104     @DefinedBy(Api.ANNOTATION_PROCESSING)
105     public Set&lt;? extends Element&gt; getRootElements() {
106         return rootElements;
107     }
108 
109     /**
110      * Returns the elements annotated with the given annotation type.
111      * Only type elements &lt;i&gt;included&lt;/i&gt; in this round of annotation
<a name="2" id="anc2"></a><span class="line-modified">112      * processing, or declarations of members, parameters, type</span>
<span class="line-modified">113      * parameters, or record components declared within those, are returned.</span>
<span class="line-modified">114      * Included type elements are {@linkplain #getRootElements specified</span>
115      * types} and any types nested within them.
116      *
117      * @param a  annotation type being requested
118      * @return the elements annotated with the given annotation type,
119      * or an empty set if there are none
120      */
121     @DefinedBy(Api.ANNOTATION_PROCESSING)
122     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a) {
123         throwIfNotAnnotation(a);
124 
125         Set&lt;Element&gt; result = Collections.emptySet();
<a name="3" id="anc3"></a><span class="line-modified">126         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">127         var scanner = new AnnotationSetScanner(result);</span>
128 
129         for (Element element : rootElements)
130             result = scanner.scan(element, a);
131 
132         return result;
133     }
134 
135     @DefinedBy(Api.ANNOTATION_PROCESSING)
136     public Set&lt;? extends Element&gt; getElementsAnnotatedWithAny(TypeElement... annotations) {
137         // Don&#39;t bother to special-case annotations.length == 1 as
138         // return getElementsAnnotatedWith(annotations[0]);
139 
140         Set&lt;TypeElement&gt; annotationSet = new LinkedHashSet&lt;&gt;(annotations.length);
141         for (TypeElement annotation : annotations) {
142             throwIfNotAnnotation(annotation);
143             annotationSet.add(annotation);
144         }
145 
146         Set&lt;Element&gt; result = Collections.emptySet();
<a name="4" id="anc4"></a><span class="line-modified">147         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">148         var scanner = new AnnotationSetMultiScanner(result);</span>
149 
150         for (Element element : rootElements)
151             result = scanner.scan(element, annotationSet);
152 
153         return result;
154     }
155 
156     // Could be written as a local class inside getElementsAnnotatedWith
<a name="5" id="anc5"></a><span class="line-added">157     @SuppressWarnings(&quot;preview&quot;)</span>
158     private class AnnotationSetScanner extends
<a name="6" id="anc6"></a><span class="line-modified">159         ElementScanner14&lt;Set&lt;Element&gt;, TypeElement&gt; {</span>
160         // Insertion-order preserving set
161         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
162 
163         AnnotationSetScanner(Set&lt;Element&gt; defaultSet) {
164             super(defaultSet);
165         }
166 
167         @Override @DefinedBy(Api.LANGUAGE_MODEL)
168         public Set&lt;Element&gt; scan(Element e, TypeElement annotation) {
169             for (AnnotationMirror annotMirror :  eltUtils.getAllAnnotationMirrors(e)) {
170                 if (annotation.equals(mirrorAsElement(annotMirror))) {
171                     annotatedElements.add(e);
172                     break;
173                 }
174             }
175             e.accept(this, annotation);
176             return annotatedElements;
177         }
178 
179         @Override @DefinedBy(Api.LANGUAGE_MODEL)
180         public Set&lt;Element&gt; visitModule(ModuleElement e, TypeElement annotation) {
181             // Do not scan a module
182             return annotatedElements;
183         }
184 
185         @Override @DefinedBy(Api.LANGUAGE_MODEL)
186         public Set&lt;Element&gt; visitPackage(PackageElement e, TypeElement annotation) {
187             // Do not scan a package
188             return annotatedElements;
189         }
190     }
191 
192     // Could be written as a local class inside getElementsAnnotatedWithAny
<a name="7" id="anc7"></a><span class="line-added">193     @SuppressWarnings(&quot;preview&quot;)</span>
194     private class AnnotationSetMultiScanner extends
<a name="8" id="anc8"></a><span class="line-modified">195         ElementScanner14&lt;Set&lt;Element&gt;, Set&lt;TypeElement&gt;&gt; {</span>
196         // Insertion-order preserving set
197         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
198 
199         AnnotationSetMultiScanner(Set&lt;Element&gt; defaultSet) {
200             super(defaultSet);
201         }
202 
203         @Override @DefinedBy(Api.LANGUAGE_MODEL)
204         public Set&lt;Element&gt; scan(Element e, Set&lt;TypeElement&gt; annotations) {
205             for (AnnotationMirror annotMirror : eltUtils.getAllAnnotationMirrors(e)) {
206                 if (annotations.contains(mirrorAsElement(annotMirror))) {
207                     annotatedElements.add(e);
208                     break;
209                 }
210             }
211             e.accept(this, annotations);
212             return annotatedElements;
213         }
214 
215         @Override @DefinedBy(Api.LANGUAGE_MODEL)
216         public Set&lt;Element&gt; visitModule(ModuleElement e, Set&lt;TypeElement&gt; annotations) {
217             // Do not scan a module
218             return annotatedElements;
219         }
220 
221         @Override @DefinedBy(Api.LANGUAGE_MODEL)
222         public Set&lt;Element&gt; visitPackage(PackageElement e, Set&lt;TypeElement&gt; annotations) {
223             // Do not scan a package
224             return annotatedElements;
225         }
226     }
227 
<a name="9" id="anc9"></a>





















228     /**
229      * {@inheritDoc}
230      */
231     @DefinedBy(Api.ANNOTATION_PROCESSING)
232     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a) {
233         throwIfNotAnnotation(a);
234         String name = a.getCanonicalName();
235 
236         if (name == null)
237             return Collections.emptySet();
238         else {
239             TypeElement annotationType = annotationToElement(a);
240 
241             if (annotationType == null)
242                 return Collections.emptySet();
243             else
244                 return getElementsAnnotatedWith(annotationType);
245         }
246     }
247 
248     @DefinedBy(Api.ANNOTATION_PROCESSING)
249     public Set&lt;? extends Element&gt; getElementsAnnotatedWithAny(Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations) {
250         List&lt;TypeElement&gt; annotationsAsElements = new ArrayList&lt;&gt;(annotations.size());
251 
252         for (Class&lt;? extends Annotation&gt; annotation : annotations) {
253             throwIfNotAnnotation(annotation);
254             String name = annotation.getCanonicalName();
255             if (name == null)
256                 continue;
257             annotationsAsElements.add(annotationToElement(annotation));
258         }
259 
260         return getElementsAnnotatedWithAny(annotationsAsElements.toArray(new TypeElement[0]));
261     }
262 
263     private TypeElement annotationToElement(Class&lt;? extends Annotation&gt; annotation) {
264         // First, try an element lookup based on the annotation&#39;s
265         // canonical name. If that fails or is ambiguous, try a lookup
266         // using a particular module, perhaps an unnamed one. This
267         // offers more compatibility for compiling in single-module
268         // mode where the runtime module of an annotation type may
269         // differ from the single module being compiled.
270         String name = annotation.getCanonicalName();
271         TypeElement annotationElement = eltUtils.getTypeElement(name);
272         if (annotationElement != null)
273             return annotationElement;
274         else if (allowModules) {
275             String moduleName = Objects.requireNonNullElse(annotation.getModule().getName(), &quot;&quot;);
276             return eltUtils.getTypeElement(eltUtils.getModuleElement(moduleName), name);
277         } else {
278             return null;
279         }
280     }
281 
282     private Element mirrorAsElement(AnnotationMirror annotationMirror) {
283         return annotationMirror.getAnnotationType().asElement();
284     }
285 
286     private static final String NOT_AN_ANNOTATION_TYPE =
287         &quot;The argument does not represent an annotation type: &quot;;
288 
289     private void throwIfNotAnnotation(Class&lt;? extends Annotation&gt; a) {
290         if (!a.isAnnotation())
291             throw new IllegalArgumentException(NOT_AN_ANNOTATION_TYPE + a);
292     }
293 
294     private void throwIfNotAnnotation(TypeElement a) {
295         if (a.getKind() != ElementKind.ANNOTATION_TYPE)
296             throw new IllegalArgumentException(NOT_AN_ANNOTATION_TYPE + a);
297     }
298 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
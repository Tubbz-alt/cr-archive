<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Code.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Items.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Gen.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 

  28 import com.sun.tools.javac.tree.TreeInfo.PosKind;
  29 import com.sun.tools.javac.util.*;
  30 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  31 import com.sun.tools.javac.util.List;
  32 import com.sun.tools.javac.code.*;
  33 import com.sun.tools.javac.code.Attribute.TypeCompound;
  34 import com.sun.tools.javac.code.Symbol.VarSymbol;
  35 import com.sun.tools.javac.comp.*;
  36 import com.sun.tools.javac.tree.*;
  37 
  38 import com.sun.tools.javac.code.Symbol.*;
  39 import com.sun.tools.javac.code.Type.*;
  40 import com.sun.tools.javac.jvm.Code.*;
  41 import com.sun.tools.javac.jvm.Items.*;
  42 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  43 import com.sun.tools.javac.tree.EndPosTable;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 
  46 import static com.sun.tools.javac.code.Flags.*;
  47 import static com.sun.tools.javac.code.Kinds.Kind.*;
</pre>
<hr />
<pre>
  71     private final Name accessDollar;
  72     private final Types types;
  73     private final Lower lower;
  74     private final Annotate annotate;
  75     private final StringConcat concat;
  76 
  77     /** Format of stackmap tables to be generated. */
  78     private final Code.StackMapFormat stackMap;
  79 
  80     /** A type that serves as the expected type for all method expressions.
  81      */
  82     private final Type methodType;
  83 
  84     public static Gen instance(Context context) {
  85         Gen instance = context.get(genKey);
  86         if (instance == null)
  87             instance = new Gen(context);
  88         return instance;
  89     }
  90 
<span class="line-modified">  91     /** Constant pool, reset by genClass.</span>
  92      */
<span class="line-modified">  93     private final Pool pool;</span>
  94 
  95     protected Gen(Context context) {
  96         context.put(genKey, this);
  97 
  98         names = Names.instance(context);
  99         log = Log.instance(context);
 100         syms = Symtab.instance(context);
 101         chk = Check.instance(context);
 102         rs = Resolve.instance(context);
 103         make = TreeMaker.instance(context);
 104         target = Target.instance(context);
 105         types = Types.instance(context);
 106         concat = StringConcat.instance(context);
 107 
 108         methodType = new MethodType(null, null, null, syms.methodClass);
 109         accessDollar = names.
 110             fromString(&quot;access&quot; + target.syntheticNameChar());
 111         lower = Lower.instance(context);
 112 
 113         Options options = Options.instance(context);
 114         lineDebugInfo =
 115             options.isUnset(G_CUSTOM) ||
 116             options.isSet(G_CUSTOM, &quot;lines&quot;);
 117         varDebugInfo =
 118             options.isUnset(G_CUSTOM)
 119             ? options.isSet(G)
 120             : options.isSet(G_CUSTOM, &quot;vars&quot;);
 121         genCrt = options.isSet(XJCOV);
 122         debugCode = options.isSet(&quot;debug.code&quot;);
 123         disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
<span class="line-modified"> 124         pool = new Pool(types);</span>
 125 
 126         // ignore cldc because we cannot have both stackmap formats
 127         this.stackMap = StackMapFormat.JSR202;
 128         annotate = Annotate.instance(context);
 129     }
 130 
 131     /** Switches
 132      */
 133     private final boolean lineDebugInfo;
 134     private final boolean varDebugInfo;
 135     private final boolean genCrt;
 136     private final boolean debugCode;
 137     private boolean disableVirtualizedPrivateInvoke;
 138 
 139     /** Code buffer, set by genMethod.
 140      */
 141     private Code code;
 142 
 143     /** Items structure, set by genMethod.
 144      */
</pre>
<hr />
<pre>
 148      */
 149     private Env&lt;AttrContext&gt; attrEnv;
 150 
 151     /** The top level tree.
 152      */
 153     private JCCompilationUnit toplevel;
 154 
 155     /** The number of code-gen errors in this class.
 156      */
 157     private int nerrs = 0;
 158 
 159     /** An object containing mappings of syntax trees to their
 160      *  ending source positions.
 161      */
 162     EndPosTable endPosTable;
 163 
 164     boolean inCondSwitchExpression;
 165     Chain switchExpressionTrueChain;
 166     Chain switchExpressionFalseChain;
 167     List&lt;LocalItem&gt; stackBeforeSwitchExpression;

 168 
 169     /** Generate code to load an integer constant.
 170      *  @param n     The integer to be loaded.
 171      */
 172     void loadIntConst(int n) {
 173         items.makeImmediateItem(syms.intType, n).load();
 174     }
 175 
 176     /** The opcode that loads a zero constant of a given type code.
 177      *  @param tc   The given type code (@see ByteCode).
 178      */
 179     public static int zero(int tc) {
 180         switch(tc) {
 181         case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
 182             return iconst_0;
 183         case LONGcode:
 184             return lconst_0;
 185         case FLOATcode:
 186             return fconst_0;
 187         case DOUBLEcode:
</pre>
<hr />
<pre>
 235 
 236         if (sym.owner == site.tsym ||
 237             (sym.flags() &amp; (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {
 238             return sym;
 239         }
 240 
 241         // leave alone methods inherited from Object
 242         // JLS 13.1.
 243         if (sym.owner == syms.objectType.tsym)
 244             return sym;
 245 
 246         return sym.clone(site.tsym);
 247     }
 248 
 249     /** Insert a reference to given type in the constant pool,
 250      *  checking for an array with too many dimensions;
 251      *  return the reference&#39;s index.
 252      *  @param type   The type for which a reference is inserted.
 253      */
 254     int makeRef(DiagnosticPosition pos, Type type) {
<span class="line-modified"> 255         checkDimension(pos, type);</span>
<span class="line-removed"> 256         if (type.isAnnotated()) {</span>
<span class="line-removed"> 257             return pool.put((Object)type);</span>
<span class="line-removed"> 258         } else {</span>
<span class="line-removed"> 259             return pool.put(type.hasTag(CLASS) ? (Object)type.tsym : (Object)type);</span>
<span class="line-removed"> 260         }</span>
 261     }
 262 
 263     /** Check if the given type is an array with too many dimensions.
 264      */
<span class="line-modified"> 265     private void checkDimension(DiagnosticPosition pos, Type t) {</span>





 266         switch (t.getTag()) {
 267         case METHOD:
 268             checkDimension(pos, t.getReturnType());
 269             for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
 270                 checkDimension(pos, args.head);
 271             break;
 272         case ARRAY:
 273             if (types.dimensions(t) &gt; ClassFile.MAX_DIMENSIONS) {
 274                 log.error(pos, Errors.LimitDimensions);
 275                 nerrs++;
 276             }
 277             break;
 278         default:
 279             break;
 280         }
 281     }
 282 
<span class="line-modified"> 283     /** Create a tempory variable.</span>
 284      *  @param type   The variable&#39;s type.
 285      */
 286     LocalItem makeTemp(Type type) {
 287         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
 288                                     names.empty,
 289                                     type,
 290                                     env.enclMethod.sym);
 291         code.newLocal(v);
 292         return items.makeLocalItem(v);
 293     }
 294 
 295     /** Generate code to call a non-private method or constructor.
 296      *  @param pos         Position to be used for error reporting.
 297      *  @param site        The type of which the method is a member.
 298      *  @param name        The method&#39;s name.
 299      *  @param argtypes    The method&#39;s argument types.
 300      *  @param isStatic    A flag that indicates whether we call a
 301      *                     static or instance method.
 302      */
 303     void callMethod(DiagnosticPosition pos,
</pre>
<hr />
<pre>
 499         ListBuffer&lt;Attribute.TypeCompound&gt; nonfieldTAs = new ListBuffer&lt;&gt;();
 500         for (TypeCompound ta : tas) {
 501             Assert.check(ta.getPosition().type != TargetType.UNKNOWN);
 502             if (ta.getPosition().type == TargetType.FIELD) {
 503                 fieldTAs.add(ta);
 504             } else {
 505                 nonfieldTAs.add(ta);
 506             }
 507         }
 508         sym.setTypeAttributes(fieldTAs.toList());
 509         return nonfieldTAs.toList();
 510     }
 511 
 512     /** Check a constant value and report if it is a string that is
 513      *  too large.
 514      */
 515     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
 516         if (nerrs != 0 || // only complain about a long string once
 517             constValue == null ||
 518             !(constValue instanceof String) ||
<span class="line-modified"> 519             ((String)constValue).length() &lt; Pool.MAX_STRING_LENGTH)</span>
 520             return;
 521         log.error(pos, Errors.LimitString);
 522         nerrs++;
 523     }
 524 
 525     /** Insert instance initializer code into initial constructor.
 526      *  @param md        The tree potentially representing a
 527      *                   constructor&#39;s definition.
 528      *  @param initCode  The list of instance initializer statements.
 529      *  @param initTAs  Type annotations from the initializer expression.
 530      */
 531     void normalizeMethod(JCMethodDecl md, List&lt;JCStatement&gt; initCode, List&lt;TypeCompound&gt; initTAs) {
 532         if (md.name == names.init &amp;&amp; TreeInfo.isInitialConstructor(md)) {
 533             // We are seeing a constructor that does not call another
 534             // constructor of the same class.
 535             List&lt;JCStatement&gt; stats = md.body.stats;
 536             ListBuffer&lt;JCStatement&gt; newstats = new ListBuffer&lt;&gt;();
 537 
 538             if (stats.nonEmpty()) {
 539                 // Copy initializers of synthetic variables generated in
</pre>
<hr />
<pre>
 708                 code.resolve(cond.falseJumps);
 709                 CondItem result = genCond(tree.falsepart, CRT_FLOW_TARGET);
 710                 if (markBranches) result.tree = tree.falsepart;
 711                 return result;
 712             }
 713             Chain secondJumps = cond.jumpFalse();
 714             code.resolve(cond.trueJumps);
 715             CondItem first = genCond(tree.truepart, CRT_FLOW_TARGET);
 716             if (markBranches) first.tree = tree.truepart;
 717             Chain falseJumps = first.jumpFalse();
 718             code.resolve(first.trueJumps);
 719             Chain trueJumps = code.branch(goto_);
 720             code.resolve(secondJumps);
 721             CondItem second = genCond(tree.falsepart, CRT_FLOW_TARGET);
 722             CondItem result = items.makeCondItem(second.opcode,
 723                                       Code.mergeChains(trueJumps, second.trueJumps),
 724                                       Code.mergeChains(falseJumps, second.falseJumps));
 725             if (markBranches) result.tree = tree.falsepart;
 726             return result;
 727         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {


 728             boolean prevInCondSwitchExpression = inCondSwitchExpression;
 729             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
 730             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
 731             try {
 732                 inCondSwitchExpression = true;
 733                 switchExpressionTrueChain = null;
 734                 switchExpressionFalseChain = null;
 735                 try {
 736                     doHandleSwitchExpression((JCSwitchExpression) inner_tree);
 737                 } catch (CompletionFailure ex) {
 738                     chk.completionError(_tree.pos(), ex);
 739                     code.state.stacksize = 1;
 740                 }
 741                 CondItem result = items.makeCondItem(goto_,
 742                                                      switchExpressionTrueChain,
 743                                                      switchExpressionFalseChain);
 744                 if (markBranches) result.tree = _tree;
 745                 return result;
 746             } finally {
 747                 inCondSwitchExpression = prevInCondSwitchExpression;
 748                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
 749                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
 750             }
 751         } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {


 752             LetExpr tree = (LetExpr) inner_tree;
 753             int limit = code.nextreg;
 754             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
 755             try {
 756                 genStats(tree.defs, env);
 757             } finally {
 758                 code.setLetExprStackPos(prevLetExprStart);
 759             }
 760             CondItem result = genCond(tree.expr, markBranches);
 761             code.endScopes(limit);
 762             return result;
 763         } else {
 764             CondItem result = genExpr(_tree, syms.booleanType).mkCond();
 765             if (markBranches) result.tree = _tree;
 766             return result;
 767         }
 768     }
 769 
 770     public Code getCode() {
 771         return code;
</pre>
<hr />
<pre>
 789 
 790         @Override
 791         public void visitTree(JCTree tree) {}
 792 
 793         @Override
 794         public void visitBinary(JCBinary tree) {
 795             tree.lhs.accept(this);
 796             tree.rhs.accept(this);
 797         }
 798 
 799         @Override
 800         public void visitSelect(JCFieldAccess tree) {
 801             if (tree.selected.type.hasTag(CLASS)) {
 802                 makeRef(tree.selected.pos(), tree.selected.type);
 803             }
 804         }
 805 
 806         @Override
 807         public void visitIdent(JCIdent tree) {
 808             if (tree.sym.owner instanceof ClassSymbol) {
<span class="line-modified"> 809                 pool.put(tree.sym.owner);</span>
 810             }
 811         }
 812 
 813         @Override
 814         public void visitConditional(JCConditional tree) {
 815             tree.cond.accept(this);
 816             tree.truepart.accept(this);
 817             tree.falsepart.accept(this);
 818         }
 819 
 820         @Override
 821         public void visitUnary(JCUnary tree) {
 822             tree.arg.accept(this);
 823         }
 824 
 825         @Override
 826         public void visitParens(JCParens tree) {
 827             tree.expr.accept(this);
 828         }
 829 
 830         @Override
 831         public void visitTypeCast(JCTypeCast tree) {
 832             tree.expr.accept(this);
 833         }
 834     }
 835 
 836     private ClassReferenceVisitor classReferenceVisitor = new ClassReferenceVisitor();
 837 
 838     /** Visitor method: generate code for an expression, catching and reporting
 839      *  any completion failures.
 840      *  @param tree    The expression to be visited.
 841      *  @param pt      The expression&#39;s expected type (proto-type).
 842      */
 843     public Item genExpr(JCTree tree, Type pt) {
 844         Type prevPt = this.pt;
 845         try {
 846             if (tree.type.constValue() != null) {
 847                 // Short circuit any expressions which are constants
 848                 tree.accept(classReferenceVisitor);
 849                 checkStringConstant(tree.pos(), tree.type.constValue());
<span class="line-modified"> 850                 result = items.makeImmediateItem(tree.type, tree.type.constValue());</span>





 851             } else {
 852                 this.pt = pt;
 853                 tree.accept(this);
 854             }
 855             return result.coerce(pt);
 856         } catch (CompletionFailure ex) {
 857             chk.completionError(tree.pos(), ex);
 858             code.state.stacksize = 1;
 859             return items.makeStackItem(pt);
 860         } finally {
 861             this.pt = prevPt;
 862         }
 863     }
 864 






 865     /** Derived visitor method: generate code for a list of method arguments.
 866      *  @param trees    The argument expressions to be visited.
 867      *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
 868      *                  types of the invoked method).
 869      */
 870     public void genArgs(List&lt;JCExpression&gt; trees, List&lt;Type&gt; pts) {
 871         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail) {
 872             genExpr(l.head, pts.head).load();
 873             pts = pts.tail;
 874         }
 875         // require lists be of same length
 876         Assert.check(pts.isEmpty());
 877     }
 878 
 879 /* ************************************************************************
 880  * Visitor methods for statements and definitions
 881  *************************************************************************/
 882 
 883     /** Thrown when the byte code size exceeds limit.
 884      */
</pre>
<hr />
<pre>
 990 
 991                 // Fill in type annotation positions for exception parameters
 992                 code.fillExceptionParameterPositions();
 993             }
 994         }
 995 
 996         private int initCode(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
 997             MethodSymbol meth = tree.sym;
 998 
 999             // Create a new code structure.
1000             meth.code = code = new Code(meth,
1001                                         fatcode,
1002                                         lineDebugInfo ? toplevel.lineMap : null,
1003                                         varDebugInfo,
1004                                         stackMap,
1005                                         debugCode,
1006                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
1007                                                : null,
1008                                         syms,
1009                                         types,
<span class="line-modified">1010                                         pool);</span>
<span class="line-modified">1011             items = new Items(pool, code, syms, types);</span>
1012             if (code.debugCode) {
1013                 System.err.println(meth + &quot; for body &quot; + tree);
1014             }
1015 
1016             // If method is not static, create a new local variable address
1017             // for `this&#39;.
1018             if ((tree.mods.flags &amp; STATIC) == 0) {
1019                 Type selfType = meth.owner.type;
1020                 if (meth.isConstructor() &amp;&amp; selfType != syms.objectType)
1021                     selfType = UninitializedType.uninitializedThis(selfType);
1022                 code.setDefined(
1023                         code.newLocal(
1024                             new VarSymbol(FINAL, names._this, selfType, meth.owner)));
1025             }
1026 
1027             // Mark all parameters as defined from the beginning of
1028             // the method.
1029             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1030                 checkDimension(l.head.pos(), l.head.sym.type);
1031                 code.setDefined(code.newLocal(l.head.sym));
</pre>
<hr />
<pre>
1074     }
1075 
1076     public void visitDoLoop(JCDoWhileLoop tree) {
1077         genLoop(tree, tree.body, tree.cond, List.nil(), false);
1078     }
1079 
1080     public void visitWhileLoop(JCWhileLoop tree) {
1081         genLoop(tree, tree.body, tree.cond, List.nil(), true);
1082     }
1083 
1084     public void visitForLoop(JCForLoop tree) {
1085         int limit = code.nextreg;
1086         genStats(tree.init, env);
1087         genLoop(tree, tree.body, tree.cond, tree.step, true);
1088         code.endScopes(limit);
1089     }
1090     //where
1091         /** Generate code for a loop.
1092          *  @param loop       The tree representing the loop.
1093          *  @param body       The loop&#39;s body.
<span class="line-modified">1094          *  @param cond       The loop&#39;s controling condition.</span>
1095          *  @param step       &quot;Step&quot; statements to be inserted at end of
1096          *                    each iteration.
1097          *  @param testFirst  True if the loop test belongs before the body.
1098          */
1099         private void genLoop(JCStatement loop,
1100                              JCStatement body,
1101                              JCExpression cond,
1102                              List&lt;JCExpressionStatement&gt; step,
1103                              boolean testFirst) {
1104             Env&lt;GenContext&gt; loopEnv = env.dup(loop, new GenContext());
1105             int startpc = code.entryPoint();
1106             if (testFirst) { //while or for loop
1107                 CondItem c;
1108                 if (cond != null) {
1109                     code.statBegin(cond.pos);
1110                     Assert.check(code.isStatementStart());
1111                     c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1112                 } else {
1113                     c = items.makeCondItem(goto_);
1114                 }
</pre>
<hr />
<pre>
1161 
1162     public void visitSwitch(JCSwitch tree) {
1163         handleSwitch(tree, tree.selector, tree.cases);
1164     }
1165 
1166     @Override
1167     public void visitSwitchExpression(JCSwitchExpression tree) {
1168         code.resolvePending();
1169         boolean prevInCondSwitchExpression = inCondSwitchExpression;
1170         try {
1171             inCondSwitchExpression = false;
1172             doHandleSwitchExpression(tree);
1173         } finally {
1174             inCondSwitchExpression = prevInCondSwitchExpression;
1175         }
1176         result = items.makeStackItem(pt);
1177     }
1178 
1179     private void doHandleSwitchExpression(JCSwitchExpression tree) {
1180         List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;

1181         int limit = code.nextreg;
1182         try {
1183             stackBeforeSwitchExpression = List.nil();

1184             if (hasTry(tree)) {
1185                 //if the switch expression contains try-catch, the catch handlers need to have
1186                 //an empty stack. So stash whole stack to local variables, and restore it before
1187                 //breaks:
1188                 while (code.state.stacksize &gt; 0) {
1189                     Type type = code.state.peek();
1190                     Name varName = names.fromString(target.syntheticNameChar() +
1191                                                     &quot;stack&quot; +
1192                                                     target.syntheticNameChar() +
1193                                                     tree.pos +
1194                                                     target.syntheticNameChar() +
1195                                                     code.state.stacksize);
1196                     VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,
1197                                                   this.env.enclMethod.sym);
1198                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
1199                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
1200                     item.store();
1201                 }

1202             }
1203             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
1204             try {
1205                 handleSwitch(tree, tree.selector, tree.cases);
1206             } finally {
1207                 code.setLetExprStackPos(prevLetExprStart);
1208             }
1209         } finally {
1210             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;

1211             code.endScopes(limit);
1212         }
1213     }
1214     //where:
1215         private boolean hasTry(JCSwitchExpression tree) {
1216             boolean[] hasTry = new boolean[1];
1217             new TreeScanner() {
1218                 @Override
1219                 public void visitTry(JCTry tree) {
1220                     hasTry[0] = true;
1221                 }
1222 
1223                 @Override
1224                 public void visitClassDef(JCClassDecl tree) {
1225                 }
1226 
1227                 @Override
1228                 public void visitLambda(JCLambda tree) {
1229                 }
1230             }.scan(tree);
</pre>
<hr />
<pre>
1484             code.statBegin(TreeInfo.endPos(env.tree));
1485             Chain exitChain = code.branch(goto_);
1486             endFinalizerGap(env);
1487             env.info.finalize.afterBody();
1488             boolean hasFinalizer =
1489                 env.info.finalize != null &amp;&amp;
1490                 env.info.finalize.hasFinalizer();
1491             if (startpc != endpc) for (List&lt;JCCatch&gt; l = catchers; l.nonEmpty(); l = l.tail) {
1492                 // start off with exception on stack
1493                 code.entryPoint(stateTry, l.head.param.sym.type);
1494                 genCatch(l.head, env, startpc, endpc, gaps);
1495                 genFinalizer(env);
1496                 if (hasFinalizer || l.tail.nonEmpty()) {
1497                     code.statBegin(TreeInfo.endPos(env.tree));
1498                     exitChain = Code.mergeChains(exitChain,
1499                                                  code.branch(goto_));
1500                 }
1501                 endFinalizerGap(env);
1502             }
1503             if (hasFinalizer) {
<span class="line-modified">1504                 // Create a new register segement to avoid allocating</span>
1505                 // the same variables in finalizers and other statements.
1506                 code.newRegSegment();
1507 
1508                 // Add a catch-all clause.
1509 
1510                 // start off with exception on stack
1511                 int catchallpc = code.entryPoint(stateTry, syms.throwableType);
1512 
1513                 // Register all exception ranges for catch all clause.
1514                 // The range of the catch all clause is from the beginning
1515                 // of the try or synchronized block until the present
1516                 // code pointer excluding all gaps in the current
1517                 // environment&#39;s GenContext.
1518                 int startseg = startpc;
1519                 while (env.info.gaps.nonEmpty()) {
1520                     int endseg = env.info.gaps.next().intValue();
1521                     registerCatch(body.pos(), startseg, endseg,
1522                                   catchallpc, 0);
1523                     startseg = env.info.gaps.next().intValue();
1524                 }
</pre>
<hr />
<pre>
1687         Assert.check(code.isStatementStart());
1688     }
1689 
1690     public void visitExec(JCExpressionStatement tree) {
1691         // Optimize x++ to ++x and x-- to --x.
1692         JCExpression e = tree.expr;
1693         switch (e.getTag()) {
1694             case POSTINC:
1695                 ((JCUnary) e).setTag(PREINC);
1696                 break;
1697             case POSTDEC:
1698                 ((JCUnary) e).setTag(PREDEC);
1699                 break;
1700         }
1701         Assert.check(code.isStatementStart());
1702         genExpr(tree.expr, tree.expr.type).drop();
1703         Assert.check(code.isStatementStart());
1704     }
1705 
1706     public void visitBreak(JCBreak tree) {







1707         Assert.check(code.isStatementStart());
1708         final Env&lt;GenContext&gt; targetEnv;
<span class="line-modified">1709         if (tree.isValueBreak()) {</span>
<span class="line-modified">1710             //restore stack as it was before the switch expression:</span>
<span class="line-modified">1711             for (LocalItem li : stackBeforeSwitchExpression) {</span>
<span class="line-modified">1712                 li.load();</span>

















1713             }
<span class="line-modified">1714             if (inCondSwitchExpression) {</span>
<span class="line-modified">1715                 CondItem value = genCond(tree.value, CRT_FLOW_TARGET);</span>
<span class="line-removed">1716                 Chain falseJumps = value.jumpFalse();</span>
<span class="line-removed">1717                 targetEnv = unwindBreak(tree);</span>
<span class="line-removed">1718                 code.resolve(value.trueJumps);</span>
<span class="line-removed">1719                 Chain trueJumps = code.branch(goto_);</span>
<span class="line-removed">1720                 if (switchExpressionTrueChain == null) {</span>
<span class="line-removed">1721                     switchExpressionTrueChain = trueJumps;</span>
<span class="line-removed">1722                 } else {</span>
<span class="line-removed">1723                     switchExpressionTrueChain =</span>
<span class="line-removed">1724                             Code.mergeChains(switchExpressionTrueChain, trueJumps);</span>
<span class="line-removed">1725                 }</span>
<span class="line-removed">1726                 if (switchExpressionFalseChain == null) {</span>
<span class="line-removed">1727                     switchExpressionFalseChain = falseJumps;</span>
<span class="line-removed">1728                 } else {</span>
<span class="line-removed">1729                     switchExpressionFalseChain =</span>
<span class="line-removed">1730                             Code.mergeChains(switchExpressionFalseChain, falseJumps);</span>
<span class="line-removed">1731                 }</span>
1732             } else {
<span class="line-modified">1733                 genExpr(tree.value, pt).load();</span>














1734                 code.state.forceStackTop(tree.target.type);
<span class="line-removed">1735                 targetEnv = unwindBreak(tree);</span>
1736                 targetEnv.info.addExit(code.branch(goto_));

1737             }
<span class="line-removed">1738         } else {</span>
<span class="line-removed">1739             targetEnv = unwindBreak(tree);</span>
<span class="line-removed">1740             targetEnv.info.addExit(code.branch(goto_));</span>
1741         }
1742         endFinalizerGaps(env, targetEnv);
1743     }
1744     //where:
<span class="line-modified">1745         private Env&lt;GenContext&gt; unwindBreak(JCBreak tree) {</span>


1746             int tmpPos = code.pendingStatPos;
<span class="line-modified">1747             Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);</span>
1748             code.pendingStatPos = tmpPos;
1749             return targetEnv;
1750         }
1751 





1752     public void visitContinue(JCContinue tree) {
1753         int tmpPos = code.pendingStatPos;
1754         Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
1755         code.pendingStatPos = tmpPos;
1756         Assert.check(code.isStatementStart());
1757         targetEnv.info.addCont(code.branch(goto_));
1758         endFinalizerGaps(env, targetEnv);
1759     }
1760 
1761     public void visitReturn(JCReturn tree) {
1762         int limit = code.nextreg;
1763         final Env&lt;GenContext&gt; targetEnv;
1764 
1765         /* Save and then restore the location of the return in case a finally
1766          * is expanded (with unwind()) in the middle of our bytecodes.
1767          */
1768         int tmpPos = code.pendingStatPos;
1769         if (tree.expr != null) {
1770             Assert.check(code.isStatementStart());
1771             Item r = genExpr(tree.expr, pt).load();
</pre>
<hr />
<pre>
1869         for (Symbol s : new com.sun.tools.javac.model.FilteredMemberList(clazz.members())) {
1870             if (!s.getKind().isField())
1871                 continue;
1872 
1873             for (Attribute.TypeCompound ta : s.getRawTypeAttributes()) {
1874                 if (ta.hasUnknownPosition())
1875                     ta.tryFixPosition();
1876 
1877                 if (ta.position.matchesPos(treePos))
1878                     ta.position.updatePosOffset(code.cp);
1879             }
1880         }
1881     }
1882 
1883     public void visitNewClass(JCNewClass tree) {
1884         // Enclosing instances or anonymous classes should have been eliminated
1885         // by now.
1886         Assert.check(tree.encl == null &amp;&amp; tree.def == null);
1887         setTypeAnnotationPositions(tree.pos);
1888 
<span class="line-modified">1889         code.emitop2(new_, makeRef(tree.pos(), tree.type));</span>
1890         code.emitop0(dup);
1891 
1892         // Generate code for all arguments, where the expected types are
1893         // the parameters of the constructor&#39;s external type (that is,
1894         // any implicit outer instance appears as first parameter).
1895         genArgs(tree.args, tree.constructor.externalType(types).getParameterTypes());
1896 
1897         items.makeMemberItem(tree.constructor, true).invoke();
1898         result = items.makeStackItem(tree.type);
1899     }
1900 
1901     public void visitNewArray(JCNewArray tree) {
1902         setTypeAnnotationPositions(tree.pos);
1903 
1904         if (tree.elems != null) {
1905             Type elemtype = types.elemtype(tree.type);
1906             loadIntConst(tree.elems.length());
1907             Item arr = makeNewArray(tree.pos(), tree.type, 1);
1908             int i = 0;
1909             for (List&lt;JCExpression&gt; l = tree.elems; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
2145             }
2146             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2147                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2148                 return items.makeCondItem(opcode);
2149             } else {
2150                 code.emitop0(opcode);
2151                 return items.makeStackItem(optype.restype);
2152             }
2153         }
2154 
2155     public void visitTypeCast(JCTypeCast tree) {
2156         result = genExpr(tree.expr, tree.clazz.type).load();
2157         setTypeAnnotationPositions(tree.pos);
2158         // Additional code is only needed if we cast to a reference type
2159         // which is not statically a supertype of the expression&#39;s type.
2160         // For basic types, the coerce(...) in genExpr(...) will do
2161         // the conversion.
2162         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2163            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
2164            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
<span class="line-modified">2165             code.emitop2(checkcast, makeRef(tree.pos(), tree.clazz.type));</span>
2166         }
2167     }
2168 
2169     public void visitWildcard(JCWildcard tree) {
2170         throw new AssertionError(this.getClass().getName());
2171     }
2172 
2173     public void visitTypeTest(JCInstanceOf tree) {
2174         genExpr(tree.expr, tree.expr.type).load();
2175         setTypeAnnotationPositions(tree.pos);
<span class="line-modified">2176         code.emitop2(instanceof_, makeRef(tree.pos(), tree.clazz.type));</span>
2177         result = items.makeStackItem(syms.booleanType);
2178     }
2179 
2180     public void visitIndexed(JCArrayAccess tree) {
2181         genExpr(tree.indexed, tree.indexed.type).load();
2182         genExpr(tree.index, syms.intType).load();
2183         result = items.makeIndexedItem(tree.type);
2184     }
2185 
2186     public void visitIdent(JCIdent tree) {
2187         Symbol sym = tree.sym;
2188         if (tree.name == names._this || tree.name == names._super) {
2189             Item res = tree.name == names._this
2190                 ? items.makeThisItem()
2191                 : items.makeSuperItem();
2192             if (sym.kind == MTH) {
2193                 // Generate code to address the constructor.
2194                 res.load();
2195                 res = items.makeMemberItem(sym, true);
2196             }
2197             result = res;





2198         } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
2199             result = items.makeLocalItem((VarSymbol)sym);
<span class="line-removed">2200         } else if (isInvokeDynamic(sym)) {</span>
<span class="line-removed">2201             result = items.makeDynamicItem(sym);</span>
2202         } else if ((sym.flags() &amp; STATIC) != 0) {
2203             if (!isAccessSuper(env.enclMethod))
2204                 sym = binaryQualifier(sym, env.enclClass.type);
2205             result = items.makeStaticItem(sym);
2206         } else {
2207             items.makeThisItem().load();
2208             sym = binaryQualifier(sym, env.enclClass.type);
2209             result = items.makeMemberItem(sym, nonVirtualForPrivateAccess(sym));
2210         }
2211     }
2212 
2213     //where
2214     private boolean nonVirtualForPrivateAccess(Symbol sym) {
2215         boolean useVirtual = target.hasVirtualPrivateInvoke() &amp;&amp;
2216                              !disableVirtualizedPrivateInvoke;
2217         return !useVirtual &amp;&amp; ((sym.flags() &amp; PRIVATE) != 0);
2218     }
2219 
2220     public void visitSelect(JCFieldAccess tree) {
2221         Symbol sym = tree.sym;
2222 
2223         if (tree.name == names._class) {
<span class="line-modified">2224             code.emitLdc(makeRef(tree.pos(), tree.selected.type));</span>
2225             result = items.makeStackItem(pt);
2226             return;
2227        }
2228 
2229         Symbol ssym = TreeInfo.symbol(tree.selected);
2230 
2231         // Are we selecting via super?
2232         boolean selectSuper =
2233             ssym != null &amp;&amp; (ssym.kind == TYP || ssym.name == names._super);
2234 
2235         // Are we accessing a member of the superclass in an access method
2236         // resulting from a qualified super?
2237         boolean accessSuper = isAccessSuper(env.enclMethod);
2238 
2239         Item base = (selectSuper)
2240             ? items.makeSuperItem()
2241             : genExpr(tree.selected, tree.selected.type);
2242 
2243         if (sym.kind == VAR &amp;&amp; ((VarSymbol) sym).getConstValue() != null) {
2244             // We are seeing a variable that is constant but its selecting
</pre>
<hr />
<pre>
2277                                        selectSuper || accessSuper);
2278                 }
2279             }
2280         }
2281     }
2282 
2283     public boolean isInvokeDynamic(Symbol sym) {
2284         return sym.kind == MTH &amp;&amp; ((MethodSymbol)sym).isDynamic();
2285     }
2286 
2287     public void visitLiteral(JCLiteral tree) {
2288         if (tree.type.hasTag(BOT)) {
2289             code.emitop0(aconst_null);
2290             result = items.makeStackItem(tree.type);
2291         }
2292         else
2293             result = items.makeImmediateItem(tree.type, tree.value);
2294     }
2295 
2296     public void visitLetExpr(LetExpr tree) {


2297         int limit = code.nextreg;
2298         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
2299         try {
2300             genStats(tree.defs, env);
2301         } finally {
2302             code.setLetExprStackPos(prevLetExprStart);
2303         }
2304         result = genExpr(tree.expr, tree.expr.type).load();
2305         code.endScopes(limit);
2306     }
2307 
<span class="line-modified">2308     private void generateReferencesToPrunedTree(ClassSymbol classSymbol, Pool pool) {</span>
2309         List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
2310         if (prunedInfo != null) {
2311             for (JCTree prunedTree: prunedInfo) {
2312                 prunedTree.accept(classReferenceVisitor);
2313             }
2314         }
2315     }
2316 
2317 /* ************************************************************************
2318  * main method
2319  *************************************************************************/
2320 
2321     /** Generate code for a class definition.
2322      *  @param env   The attribution environment that belongs to the
2323      *               outermost class containing this class definition.
2324      *               We need this for resolving some additional symbols.
2325      *  @param cdef  The tree representing the class definition.
2326      *  @return      True if code is generated with no errors.
2327      */
2328     public boolean genClass(Env&lt;AttrContext&gt; env, JCClassDecl cdef) {
2329         try {
2330             attrEnv = env;
2331             ClassSymbol c = cdef.sym;
2332             this.toplevel = env.toplevel;
2333             this.endPosTable = toplevel.endPositions;
<span class="line-removed">2334             c.pool = pool;</span>
<span class="line-removed">2335             pool.reset();</span>
2336             /* method normalizeDefs() can add references to external classes into the constant pool
2337              */
2338             cdef.defs = normalizeDefs(cdef.defs, c);
<span class="line-modified">2339             generateReferencesToPrunedTree(c, pool);</span>
2340             Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
2341             localEnv.toplevel = env.toplevel;
2342             localEnv.enclClass = cdef;
2343 
2344             for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2345                 genDef(l.head, localEnv);
2346             }
<span class="line-modified">2347             if (pool.numEntries() &gt; Pool.MAX_ENTRIES) {</span>
2348                 log.error(cdef.pos(), Errors.LimitPool);
2349                 nerrs++;
2350             }
2351             if (nerrs != 0) {
2352                 // if errors, discard code
2353                 for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2354                     if (l.head.hasTag(METHODDEF))
2355                         ((JCMethodDecl) l.head).sym.code = null;
2356                 }
2357             }
2358             cdef.defs = List.nil(); // discard trees
2359             return nerrs == 0;
2360         } finally {
2361             // note: this method does NOT support recursion.
2362             attrEnv = null;
2363             this.env = null;
2364             toplevel = null;
2365             endPosTable = null;
2366             nerrs = 0;
2367         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
<span class="line-added">  28 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
  29 import com.sun.tools.javac.tree.TreeInfo.PosKind;
  30 import com.sun.tools.javac.util.*;
  31 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  32 import com.sun.tools.javac.util.List;
  33 import com.sun.tools.javac.code.*;
  34 import com.sun.tools.javac.code.Attribute.TypeCompound;
  35 import com.sun.tools.javac.code.Symbol.VarSymbol;
  36 import com.sun.tools.javac.comp.*;
  37 import com.sun.tools.javac.tree.*;
  38 
  39 import com.sun.tools.javac.code.Symbol.*;
  40 import com.sun.tools.javac.code.Type.*;
  41 import com.sun.tools.javac.jvm.Code.*;
  42 import com.sun.tools.javac.jvm.Items.*;
  43 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  44 import com.sun.tools.javac.tree.EndPosTable;
  45 import com.sun.tools.javac.tree.JCTree.*;
  46 
  47 import static com.sun.tools.javac.code.Flags.*;
  48 import static com.sun.tools.javac.code.Kinds.Kind.*;
</pre>
<hr />
<pre>
  72     private final Name accessDollar;
  73     private final Types types;
  74     private final Lower lower;
  75     private final Annotate annotate;
  76     private final StringConcat concat;
  77 
  78     /** Format of stackmap tables to be generated. */
  79     private final Code.StackMapFormat stackMap;
  80 
  81     /** A type that serves as the expected type for all method expressions.
  82      */
  83     private final Type methodType;
  84 
  85     public static Gen instance(Context context) {
  86         Gen instance = context.get(genKey);
  87         if (instance == null)
  88             instance = new Gen(context);
  89         return instance;
  90     }
  91 
<span class="line-modified">  92     /** Constant pool writer, set by genClass.</span>
  93      */
<span class="line-modified">  94     final PoolWriter poolWriter;</span>
  95 
  96     protected Gen(Context context) {
  97         context.put(genKey, this);
  98 
  99         names = Names.instance(context);
 100         log = Log.instance(context);
 101         syms = Symtab.instance(context);
 102         chk = Check.instance(context);
 103         rs = Resolve.instance(context);
 104         make = TreeMaker.instance(context);
 105         target = Target.instance(context);
 106         types = Types.instance(context);
 107         concat = StringConcat.instance(context);
 108 
 109         methodType = new MethodType(null, null, null, syms.methodClass);
 110         accessDollar = names.
 111             fromString(&quot;access&quot; + target.syntheticNameChar());
 112         lower = Lower.instance(context);
 113 
 114         Options options = Options.instance(context);
 115         lineDebugInfo =
 116             options.isUnset(G_CUSTOM) ||
 117             options.isSet(G_CUSTOM, &quot;lines&quot;);
 118         varDebugInfo =
 119             options.isUnset(G_CUSTOM)
 120             ? options.isSet(G)
 121             : options.isSet(G_CUSTOM, &quot;vars&quot;);
 122         genCrt = options.isSet(XJCOV);
 123         debugCode = options.isSet(&quot;debug.code&quot;);
 124         disableVirtualizedPrivateInvoke = options.isSet(&quot;disableVirtualizedPrivateInvoke&quot;);
<span class="line-modified"> 125         poolWriter = new PoolWriter(types, names);</span>
 126 
 127         // ignore cldc because we cannot have both stackmap formats
 128         this.stackMap = StackMapFormat.JSR202;
 129         annotate = Annotate.instance(context);
 130     }
 131 
 132     /** Switches
 133      */
 134     private final boolean lineDebugInfo;
 135     private final boolean varDebugInfo;
 136     private final boolean genCrt;
 137     private final boolean debugCode;
 138     private boolean disableVirtualizedPrivateInvoke;
 139 
 140     /** Code buffer, set by genMethod.
 141      */
 142     private Code code;
 143 
 144     /** Items structure, set by genMethod.
 145      */
</pre>
<hr />
<pre>
 149      */
 150     private Env&lt;AttrContext&gt; attrEnv;
 151 
 152     /** The top level tree.
 153      */
 154     private JCCompilationUnit toplevel;
 155 
 156     /** The number of code-gen errors in this class.
 157      */
 158     private int nerrs = 0;
 159 
 160     /** An object containing mappings of syntax trees to their
 161      *  ending source positions.
 162      */
 163     EndPosTable endPosTable;
 164 
 165     boolean inCondSwitchExpression;
 166     Chain switchExpressionTrueChain;
 167     Chain switchExpressionFalseChain;
 168     List&lt;LocalItem&gt; stackBeforeSwitchExpression;
<span class="line-added"> 169     LocalItem switchResult;</span>
 170 
 171     /** Generate code to load an integer constant.
 172      *  @param n     The integer to be loaded.
 173      */
 174     void loadIntConst(int n) {
 175         items.makeImmediateItem(syms.intType, n).load();
 176     }
 177 
 178     /** The opcode that loads a zero constant of a given type code.
 179      *  @param tc   The given type code (@see ByteCode).
 180      */
 181     public static int zero(int tc) {
 182         switch(tc) {
 183         case INTcode: case BYTEcode: case SHORTcode: case CHARcode:
 184             return iconst_0;
 185         case LONGcode:
 186             return lconst_0;
 187         case FLOATcode:
 188             return fconst_0;
 189         case DOUBLEcode:
</pre>
<hr />
<pre>
 237 
 238         if (sym.owner == site.tsym ||
 239             (sym.flags() &amp; (STATIC | SYNTHETIC)) == (STATIC | SYNTHETIC)) {
 240             return sym;
 241         }
 242 
 243         // leave alone methods inherited from Object
 244         // JLS 13.1.
 245         if (sym.owner == syms.objectType.tsym)
 246             return sym;
 247 
 248         return sym.clone(site.tsym);
 249     }
 250 
 251     /** Insert a reference to given type in the constant pool,
 252      *  checking for an array with too many dimensions;
 253      *  return the reference&#39;s index.
 254      *  @param type   The type for which a reference is inserted.
 255      */
 256     int makeRef(DiagnosticPosition pos, Type type) {
<span class="line-modified"> 257         return poolWriter.putClass(checkDimension(pos, type));</span>





 258     }
 259 
 260     /** Check if the given type is an array with too many dimensions.
 261      */
<span class="line-modified"> 262     private Type checkDimension(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 263         checkDimensionInternal(pos, t);</span>
<span class="line-added"> 264         return t;</span>
<span class="line-added"> 265     }</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267     private void checkDimensionInternal(DiagnosticPosition pos, Type t) {</span>
 268         switch (t.getTag()) {
 269         case METHOD:
 270             checkDimension(pos, t.getReturnType());
 271             for (List&lt;Type&gt; args = t.getParameterTypes(); args.nonEmpty(); args = args.tail)
 272                 checkDimension(pos, args.head);
 273             break;
 274         case ARRAY:
 275             if (types.dimensions(t) &gt; ClassFile.MAX_DIMENSIONS) {
 276                 log.error(pos, Errors.LimitDimensions);
 277                 nerrs++;
 278             }
 279             break;
 280         default:
 281             break;
 282         }
 283     }
 284 
<span class="line-modified"> 285     /** Create a temporary variable.</span>
 286      *  @param type   The variable&#39;s type.
 287      */
 288     LocalItem makeTemp(Type type) {
 289         VarSymbol v = new VarSymbol(Flags.SYNTHETIC,
 290                                     names.empty,
 291                                     type,
 292                                     env.enclMethod.sym);
 293         code.newLocal(v);
 294         return items.makeLocalItem(v);
 295     }
 296 
 297     /** Generate code to call a non-private method or constructor.
 298      *  @param pos         Position to be used for error reporting.
 299      *  @param site        The type of which the method is a member.
 300      *  @param name        The method&#39;s name.
 301      *  @param argtypes    The method&#39;s argument types.
 302      *  @param isStatic    A flag that indicates whether we call a
 303      *                     static or instance method.
 304      */
 305     void callMethod(DiagnosticPosition pos,
</pre>
<hr />
<pre>
 501         ListBuffer&lt;Attribute.TypeCompound&gt; nonfieldTAs = new ListBuffer&lt;&gt;();
 502         for (TypeCompound ta : tas) {
 503             Assert.check(ta.getPosition().type != TargetType.UNKNOWN);
 504             if (ta.getPosition().type == TargetType.FIELD) {
 505                 fieldTAs.add(ta);
 506             } else {
 507                 nonfieldTAs.add(ta);
 508             }
 509         }
 510         sym.setTypeAttributes(fieldTAs.toList());
 511         return nonfieldTAs.toList();
 512     }
 513 
 514     /** Check a constant value and report if it is a string that is
 515      *  too large.
 516      */
 517     private void checkStringConstant(DiagnosticPosition pos, Object constValue) {
 518         if (nerrs != 0 || // only complain about a long string once
 519             constValue == null ||
 520             !(constValue instanceof String) ||
<span class="line-modified"> 521             ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH)</span>
 522             return;
 523         log.error(pos, Errors.LimitString);
 524         nerrs++;
 525     }
 526 
 527     /** Insert instance initializer code into initial constructor.
 528      *  @param md        The tree potentially representing a
 529      *                   constructor&#39;s definition.
 530      *  @param initCode  The list of instance initializer statements.
 531      *  @param initTAs  Type annotations from the initializer expression.
 532      */
 533     void normalizeMethod(JCMethodDecl md, List&lt;JCStatement&gt; initCode, List&lt;TypeCompound&gt; initTAs) {
 534         if (md.name == names.init &amp;&amp; TreeInfo.isInitialConstructor(md)) {
 535             // We are seeing a constructor that does not call another
 536             // constructor of the same class.
 537             List&lt;JCStatement&gt; stats = md.body.stats;
 538             ListBuffer&lt;JCStatement&gt; newstats = new ListBuffer&lt;&gt;();
 539 
 540             if (stats.nonEmpty()) {
 541                 // Copy initializers of synthetic variables generated in
</pre>
<hr />
<pre>
 710                 code.resolve(cond.falseJumps);
 711                 CondItem result = genCond(tree.falsepart, CRT_FLOW_TARGET);
 712                 if (markBranches) result.tree = tree.falsepart;
 713                 return result;
 714             }
 715             Chain secondJumps = cond.jumpFalse();
 716             code.resolve(cond.trueJumps);
 717             CondItem first = genCond(tree.truepart, CRT_FLOW_TARGET);
 718             if (markBranches) first.tree = tree.truepart;
 719             Chain falseJumps = first.jumpFalse();
 720             code.resolve(first.trueJumps);
 721             Chain trueJumps = code.branch(goto_);
 722             code.resolve(secondJumps);
 723             CondItem second = genCond(tree.falsepart, CRT_FLOW_TARGET);
 724             CondItem result = items.makeCondItem(second.opcode,
 725                                       Code.mergeChains(trueJumps, second.trueJumps),
 726                                       Code.mergeChains(falseJumps, second.falseJumps));
 727             if (markBranches) result.tree = tree.falsepart;
 728             return result;
 729         } else if (inner_tree.hasTag(SWITCH_EXPRESSION)) {
<span class="line-added"> 730             code.resolvePending();</span>
<span class="line-added"> 731 </span>
 732             boolean prevInCondSwitchExpression = inCondSwitchExpression;
 733             Chain prevSwitchExpressionTrueChain = switchExpressionTrueChain;
 734             Chain prevSwitchExpressionFalseChain = switchExpressionFalseChain;
 735             try {
 736                 inCondSwitchExpression = true;
 737                 switchExpressionTrueChain = null;
 738                 switchExpressionFalseChain = null;
 739                 try {
 740                     doHandleSwitchExpression((JCSwitchExpression) inner_tree);
 741                 } catch (CompletionFailure ex) {
 742                     chk.completionError(_tree.pos(), ex);
 743                     code.state.stacksize = 1;
 744                 }
 745                 CondItem result = items.makeCondItem(goto_,
 746                                                      switchExpressionTrueChain,
 747                                                      switchExpressionFalseChain);
 748                 if (markBranches) result.tree = _tree;
 749                 return result;
 750             } finally {
 751                 inCondSwitchExpression = prevInCondSwitchExpression;
 752                 switchExpressionTrueChain = prevSwitchExpressionTrueChain;
 753                 switchExpressionFalseChain = prevSwitchExpressionFalseChain;
 754             }
 755         } else if (inner_tree.hasTag(LETEXPR) &amp;&amp; ((LetExpr) inner_tree).needsCond) {
<span class="line-added"> 756             code.resolvePending();</span>
<span class="line-added"> 757 </span>
 758             LetExpr tree = (LetExpr) inner_tree;
 759             int limit = code.nextreg;
 760             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
 761             try {
 762                 genStats(tree.defs, env);
 763             } finally {
 764                 code.setLetExprStackPos(prevLetExprStart);
 765             }
 766             CondItem result = genCond(tree.expr, markBranches);
 767             code.endScopes(limit);
 768             return result;
 769         } else {
 770             CondItem result = genExpr(_tree, syms.booleanType).mkCond();
 771             if (markBranches) result.tree = _tree;
 772             return result;
 773         }
 774     }
 775 
 776     public Code getCode() {
 777         return code;
</pre>
<hr />
<pre>
 795 
 796         @Override
 797         public void visitTree(JCTree tree) {}
 798 
 799         @Override
 800         public void visitBinary(JCBinary tree) {
 801             tree.lhs.accept(this);
 802             tree.rhs.accept(this);
 803         }
 804 
 805         @Override
 806         public void visitSelect(JCFieldAccess tree) {
 807             if (tree.selected.type.hasTag(CLASS)) {
 808                 makeRef(tree.selected.pos(), tree.selected.type);
 809             }
 810         }
 811 
 812         @Override
 813         public void visitIdent(JCIdent tree) {
 814             if (tree.sym.owner instanceof ClassSymbol) {
<span class="line-modified"> 815                 poolWriter.putClass((ClassSymbol)tree.sym.owner);</span>
 816             }
 817         }
 818 
 819         @Override
 820         public void visitConditional(JCConditional tree) {
 821             tree.cond.accept(this);
 822             tree.truepart.accept(this);
 823             tree.falsepart.accept(this);
 824         }
 825 
 826         @Override
 827         public void visitUnary(JCUnary tree) {
 828             tree.arg.accept(this);
 829         }
 830 
 831         @Override
 832         public void visitParens(JCParens tree) {
 833             tree.expr.accept(this);
 834         }
 835 
 836         @Override
 837         public void visitTypeCast(JCTypeCast tree) {
 838             tree.expr.accept(this);
 839         }
 840     }
 841 
 842     private ClassReferenceVisitor classReferenceVisitor = new ClassReferenceVisitor();
 843 
 844     /** Visitor method: generate code for an expression, catching and reporting
 845      *  any completion failures.
 846      *  @param tree    The expression to be visited.
 847      *  @param pt      The expression&#39;s expected type (proto-type).
 848      */
 849     public Item genExpr(JCTree tree, Type pt) {
 850         Type prevPt = this.pt;
 851         try {
 852             if (tree.type.constValue() != null) {
 853                 // Short circuit any expressions which are constants
 854                 tree.accept(classReferenceVisitor);
 855                 checkStringConstant(tree.pos(), tree.type.constValue());
<span class="line-modified"> 856                 Symbol sym = TreeInfo.symbol(tree);</span>
<span class="line-added"> 857                 if (sym != null &amp;&amp; isConstantDynamic(sym)) {</span>
<span class="line-added"> 858                     result = items.makeDynamicItem(sym);</span>
<span class="line-added"> 859                 } else {</span>
<span class="line-added"> 860                     result = items.makeImmediateItem(tree.type, tree.type.constValue());</span>
<span class="line-added"> 861                 }</span>
 862             } else {
 863                 this.pt = pt;
 864                 tree.accept(this);
 865             }
 866             return result.coerce(pt);
 867         } catch (CompletionFailure ex) {
 868             chk.completionError(tree.pos(), ex);
 869             code.state.stacksize = 1;
 870             return items.makeStackItem(pt);
 871         } finally {
 872             this.pt = prevPt;
 873         }
 874     }
 875 
<span class="line-added"> 876     public boolean isConstantDynamic(Symbol sym) {</span>
<span class="line-added"> 877         return sym.kind == VAR &amp;&amp;</span>
<span class="line-added"> 878                 sym instanceof DynamicVarSymbol &amp;&amp;</span>
<span class="line-added"> 879                 ((DynamicVarSymbol)sym).isDynamic();</span>
<span class="line-added"> 880     }</span>
<span class="line-added"> 881 </span>
 882     /** Derived visitor method: generate code for a list of method arguments.
 883      *  @param trees    The argument expressions to be visited.
 884      *  @param pts      The expression&#39;s expected types (i.e. the formal parameter
 885      *                  types of the invoked method).
 886      */
 887     public void genArgs(List&lt;JCExpression&gt; trees, List&lt;Type&gt; pts) {
 888         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail) {
 889             genExpr(l.head, pts.head).load();
 890             pts = pts.tail;
 891         }
 892         // require lists be of same length
 893         Assert.check(pts.isEmpty());
 894     }
 895 
 896 /* ************************************************************************
 897  * Visitor methods for statements and definitions
 898  *************************************************************************/
 899 
 900     /** Thrown when the byte code size exceeds limit.
 901      */
</pre>
<hr />
<pre>
1007 
1008                 // Fill in type annotation positions for exception parameters
1009                 code.fillExceptionParameterPositions();
1010             }
1011         }
1012 
1013         private int initCode(JCMethodDecl tree, Env&lt;GenContext&gt; env, boolean fatcode) {
1014             MethodSymbol meth = tree.sym;
1015 
1016             // Create a new code structure.
1017             meth.code = code = new Code(meth,
1018                                         fatcode,
1019                                         lineDebugInfo ? toplevel.lineMap : null,
1020                                         varDebugInfo,
1021                                         stackMap,
1022                                         debugCode,
1023                                         genCrt ? new CRTable(tree, env.toplevel.endPositions)
1024                                                : null,
1025                                         syms,
1026                                         types,
<span class="line-modified">1027                                         poolWriter);</span>
<span class="line-modified">1028             items = new Items(poolWriter, code, syms, types);</span>
1029             if (code.debugCode) {
1030                 System.err.println(meth + &quot; for body &quot; + tree);
1031             }
1032 
1033             // If method is not static, create a new local variable address
1034             // for `this&#39;.
1035             if ((tree.mods.flags &amp; STATIC) == 0) {
1036                 Type selfType = meth.owner.type;
1037                 if (meth.isConstructor() &amp;&amp; selfType != syms.objectType)
1038                     selfType = UninitializedType.uninitializedThis(selfType);
1039                 code.setDefined(
1040                         code.newLocal(
1041                             new VarSymbol(FINAL, names._this, selfType, meth.owner)));
1042             }
1043 
1044             // Mark all parameters as defined from the beginning of
1045             // the method.
1046             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1047                 checkDimension(l.head.pos(), l.head.sym.type);
1048                 code.setDefined(code.newLocal(l.head.sym));
</pre>
<hr />
<pre>
1091     }
1092 
1093     public void visitDoLoop(JCDoWhileLoop tree) {
1094         genLoop(tree, tree.body, tree.cond, List.nil(), false);
1095     }
1096 
1097     public void visitWhileLoop(JCWhileLoop tree) {
1098         genLoop(tree, tree.body, tree.cond, List.nil(), true);
1099     }
1100 
1101     public void visitForLoop(JCForLoop tree) {
1102         int limit = code.nextreg;
1103         genStats(tree.init, env);
1104         genLoop(tree, tree.body, tree.cond, tree.step, true);
1105         code.endScopes(limit);
1106     }
1107     //where
1108         /** Generate code for a loop.
1109          *  @param loop       The tree representing the loop.
1110          *  @param body       The loop&#39;s body.
<span class="line-modified">1111          *  @param cond       The loop&#39;s controlling condition.</span>
1112          *  @param step       &quot;Step&quot; statements to be inserted at end of
1113          *                    each iteration.
1114          *  @param testFirst  True if the loop test belongs before the body.
1115          */
1116         private void genLoop(JCStatement loop,
1117                              JCStatement body,
1118                              JCExpression cond,
1119                              List&lt;JCExpressionStatement&gt; step,
1120                              boolean testFirst) {
1121             Env&lt;GenContext&gt; loopEnv = env.dup(loop, new GenContext());
1122             int startpc = code.entryPoint();
1123             if (testFirst) { //while or for loop
1124                 CondItem c;
1125                 if (cond != null) {
1126                     code.statBegin(cond.pos);
1127                     Assert.check(code.isStatementStart());
1128                     c = genCond(TreeInfo.skipParens(cond), CRT_FLOW_CONTROLLER);
1129                 } else {
1130                     c = items.makeCondItem(goto_);
1131                 }
</pre>
<hr />
<pre>
1178 
1179     public void visitSwitch(JCSwitch tree) {
1180         handleSwitch(tree, tree.selector, tree.cases);
1181     }
1182 
1183     @Override
1184     public void visitSwitchExpression(JCSwitchExpression tree) {
1185         code.resolvePending();
1186         boolean prevInCondSwitchExpression = inCondSwitchExpression;
1187         try {
1188             inCondSwitchExpression = false;
1189             doHandleSwitchExpression(tree);
1190         } finally {
1191             inCondSwitchExpression = prevInCondSwitchExpression;
1192         }
1193         result = items.makeStackItem(pt);
1194     }
1195 
1196     private void doHandleSwitchExpression(JCSwitchExpression tree) {
1197         List&lt;LocalItem&gt; prevStackBeforeSwitchExpression = stackBeforeSwitchExpression;
<span class="line-added">1198         LocalItem prevSwitchResult = switchResult;</span>
1199         int limit = code.nextreg;
1200         try {
1201             stackBeforeSwitchExpression = List.nil();
<span class="line-added">1202             switchResult = null;</span>
1203             if (hasTry(tree)) {
1204                 //if the switch expression contains try-catch, the catch handlers need to have
1205                 //an empty stack. So stash whole stack to local variables, and restore it before
1206                 //breaks:
1207                 while (code.state.stacksize &gt; 0) {
1208                     Type type = code.state.peek();
1209                     Name varName = names.fromString(target.syntheticNameChar() +
1210                                                     &quot;stack&quot; +
1211                                                     target.syntheticNameChar() +
1212                                                     tree.pos +
1213                                                     target.syntheticNameChar() +
1214                                                     code.state.stacksize);
1215                     VarSymbol var = new VarSymbol(Flags.SYNTHETIC, varName, type,
1216                                                   this.env.enclMethod.sym);
1217                     LocalItem item = items.new LocalItem(type, code.newLocal(var));
1218                     stackBeforeSwitchExpression = stackBeforeSwitchExpression.prepend(item);
1219                     item.store();
1220                 }
<span class="line-added">1221                 switchResult = makeTemp(tree.type);</span>
1222             }
1223             int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
1224             try {
1225                 handleSwitch(tree, tree.selector, tree.cases);
1226             } finally {
1227                 code.setLetExprStackPos(prevLetExprStart);
1228             }
1229         } finally {
1230             stackBeforeSwitchExpression = prevStackBeforeSwitchExpression;
<span class="line-added">1231             switchResult = prevSwitchResult;</span>
1232             code.endScopes(limit);
1233         }
1234     }
1235     //where:
1236         private boolean hasTry(JCSwitchExpression tree) {
1237             boolean[] hasTry = new boolean[1];
1238             new TreeScanner() {
1239                 @Override
1240                 public void visitTry(JCTry tree) {
1241                     hasTry[0] = true;
1242                 }
1243 
1244                 @Override
1245                 public void visitClassDef(JCClassDecl tree) {
1246                 }
1247 
1248                 @Override
1249                 public void visitLambda(JCLambda tree) {
1250                 }
1251             }.scan(tree);
</pre>
<hr />
<pre>
1505             code.statBegin(TreeInfo.endPos(env.tree));
1506             Chain exitChain = code.branch(goto_);
1507             endFinalizerGap(env);
1508             env.info.finalize.afterBody();
1509             boolean hasFinalizer =
1510                 env.info.finalize != null &amp;&amp;
1511                 env.info.finalize.hasFinalizer();
1512             if (startpc != endpc) for (List&lt;JCCatch&gt; l = catchers; l.nonEmpty(); l = l.tail) {
1513                 // start off with exception on stack
1514                 code.entryPoint(stateTry, l.head.param.sym.type);
1515                 genCatch(l.head, env, startpc, endpc, gaps);
1516                 genFinalizer(env);
1517                 if (hasFinalizer || l.tail.nonEmpty()) {
1518                     code.statBegin(TreeInfo.endPos(env.tree));
1519                     exitChain = Code.mergeChains(exitChain,
1520                                                  code.branch(goto_));
1521                 }
1522                 endFinalizerGap(env);
1523             }
1524             if (hasFinalizer) {
<span class="line-modified">1525                 // Create a new register segment to avoid allocating</span>
1526                 // the same variables in finalizers and other statements.
1527                 code.newRegSegment();
1528 
1529                 // Add a catch-all clause.
1530 
1531                 // start off with exception on stack
1532                 int catchallpc = code.entryPoint(stateTry, syms.throwableType);
1533 
1534                 // Register all exception ranges for catch all clause.
1535                 // The range of the catch all clause is from the beginning
1536                 // of the try or synchronized block until the present
1537                 // code pointer excluding all gaps in the current
1538                 // environment&#39;s GenContext.
1539                 int startseg = startpc;
1540                 while (env.info.gaps.nonEmpty()) {
1541                     int endseg = env.info.gaps.next().intValue();
1542                     registerCatch(body.pos(), startseg, endseg,
1543                                   catchallpc, 0);
1544                     startseg = env.info.gaps.next().intValue();
1545                 }
</pre>
<hr />
<pre>
1708         Assert.check(code.isStatementStart());
1709     }
1710 
1711     public void visitExec(JCExpressionStatement tree) {
1712         // Optimize x++ to ++x and x-- to --x.
1713         JCExpression e = tree.expr;
1714         switch (e.getTag()) {
1715             case POSTINC:
1716                 ((JCUnary) e).setTag(PREINC);
1717                 break;
1718             case POSTDEC:
1719                 ((JCUnary) e).setTag(PREDEC);
1720                 break;
1721         }
1722         Assert.check(code.isStatementStart());
1723         genExpr(tree.expr, tree.expr.type).drop();
1724         Assert.check(code.isStatementStart());
1725     }
1726 
1727     public void visitBreak(JCBreak tree) {
<span class="line-added">1728         Assert.check(code.isStatementStart());</span>
<span class="line-added">1729         final Env&lt;GenContext&gt; targetEnv = unwindBreak(tree.target);</span>
<span class="line-added">1730         targetEnv.info.addExit(code.branch(goto_));</span>
<span class="line-added">1731         endFinalizerGaps(env, targetEnv);</span>
<span class="line-added">1732     }</span>
<span class="line-added">1733 </span>
<span class="line-added">1734     public void visitYield(JCYield tree) {</span>
1735         Assert.check(code.isStatementStart());
1736         final Env&lt;GenContext&gt; targetEnv;
<span class="line-modified">1737         if (inCondSwitchExpression) {</span>
<span class="line-modified">1738             CondItem value = genCond(tree.value, CRT_FLOW_TARGET);</span>
<span class="line-modified">1739             Chain falseJumps = value.jumpFalse();</span>
<span class="line-modified">1740 </span>
<span class="line-added">1741             code.resolve(value.trueJumps);</span>
<span class="line-added">1742             Env&lt;GenContext&gt; localEnv = unwindBreak(tree.target);</span>
<span class="line-added">1743             reloadStackBeforeSwitchExpr();</span>
<span class="line-added">1744             Chain trueJumps = code.branch(goto_);</span>
<span class="line-added">1745 </span>
<span class="line-added">1746             endFinalizerGaps(env, localEnv);</span>
<span class="line-added">1747 </span>
<span class="line-added">1748             code.resolve(falseJumps);</span>
<span class="line-added">1749             targetEnv = unwindBreak(tree.target);</span>
<span class="line-added">1750             reloadStackBeforeSwitchExpr();</span>
<span class="line-added">1751             falseJumps = code.branch(goto_);</span>
<span class="line-added">1752 </span>
<span class="line-added">1753             if (switchExpressionTrueChain == null) {</span>
<span class="line-added">1754                 switchExpressionTrueChain = trueJumps;</span>
<span class="line-added">1755             } else {</span>
<span class="line-added">1756                 switchExpressionTrueChain =</span>
<span class="line-added">1757                         Code.mergeChains(switchExpressionTrueChain, trueJumps);</span>
1758             }
<span class="line-modified">1759             if (switchExpressionFalseChain == null) {</span>
<span class="line-modified">1760                 switchExpressionFalseChain = falseJumps;</span>
















1761             } else {
<span class="line-modified">1762                 switchExpressionFalseChain =</span>
<span class="line-added">1763                         Code.mergeChains(switchExpressionFalseChain, falseJumps);</span>
<span class="line-added">1764             }</span>
<span class="line-added">1765         } else {</span>
<span class="line-added">1766             genExpr(tree.value, pt).load();</span>
<span class="line-added">1767             if (switchResult != null)</span>
<span class="line-added">1768                 switchResult.store();</span>
<span class="line-added">1769 </span>
<span class="line-added">1770             targetEnv = unwindBreak(tree.target);</span>
<span class="line-added">1771 </span>
<span class="line-added">1772             if (code.isAlive()) {</span>
<span class="line-added">1773                 reloadStackBeforeSwitchExpr();</span>
<span class="line-added">1774                 if (switchResult != null)</span>
<span class="line-added">1775                     switchResult.load();</span>
<span class="line-added">1776 </span>
1777                 code.state.forceStackTop(tree.target.type);

1778                 targetEnv.info.addExit(code.branch(goto_));
<span class="line-added">1779                 code.markDead();</span>
1780             }



1781         }
1782         endFinalizerGaps(env, targetEnv);
1783     }
1784     //where:
<span class="line-modified">1785         /** As side-effect, might mark code as dead disabling any further emission.</span>
<span class="line-added">1786          */</span>
<span class="line-added">1787         private Env&lt;GenContext&gt; unwindBreak(JCTree target) {</span>
1788             int tmpPos = code.pendingStatPos;
<span class="line-modified">1789             Env&lt;GenContext&gt; targetEnv = unwind(target, env);</span>
1790             code.pendingStatPos = tmpPos;
1791             return targetEnv;
1792         }
1793 
<span class="line-added">1794         private void reloadStackBeforeSwitchExpr() {</span>
<span class="line-added">1795             for (LocalItem li : stackBeforeSwitchExpression)</span>
<span class="line-added">1796                 li.load();</span>
<span class="line-added">1797         }</span>
<span class="line-added">1798 </span>
1799     public void visitContinue(JCContinue tree) {
1800         int tmpPos = code.pendingStatPos;
1801         Env&lt;GenContext&gt; targetEnv = unwind(tree.target, env);
1802         code.pendingStatPos = tmpPos;
1803         Assert.check(code.isStatementStart());
1804         targetEnv.info.addCont(code.branch(goto_));
1805         endFinalizerGaps(env, targetEnv);
1806     }
1807 
1808     public void visitReturn(JCReturn tree) {
1809         int limit = code.nextreg;
1810         final Env&lt;GenContext&gt; targetEnv;
1811 
1812         /* Save and then restore the location of the return in case a finally
1813          * is expanded (with unwind()) in the middle of our bytecodes.
1814          */
1815         int tmpPos = code.pendingStatPos;
1816         if (tree.expr != null) {
1817             Assert.check(code.isStatementStart());
1818             Item r = genExpr(tree.expr, pt).load();
</pre>
<hr />
<pre>
1916         for (Symbol s : new com.sun.tools.javac.model.FilteredMemberList(clazz.members())) {
1917             if (!s.getKind().isField())
1918                 continue;
1919 
1920             for (Attribute.TypeCompound ta : s.getRawTypeAttributes()) {
1921                 if (ta.hasUnknownPosition())
1922                     ta.tryFixPosition();
1923 
1924                 if (ta.position.matchesPos(treePos))
1925                     ta.position.updatePosOffset(code.cp);
1926             }
1927         }
1928     }
1929 
1930     public void visitNewClass(JCNewClass tree) {
1931         // Enclosing instances or anonymous classes should have been eliminated
1932         // by now.
1933         Assert.check(tree.encl == null &amp;&amp; tree.def == null);
1934         setTypeAnnotationPositions(tree.pos);
1935 
<span class="line-modified">1936         code.emitop2(new_, checkDimension(tree.pos(), tree.type), PoolWriter::putClass);</span>
1937         code.emitop0(dup);
1938 
1939         // Generate code for all arguments, where the expected types are
1940         // the parameters of the constructor&#39;s external type (that is,
1941         // any implicit outer instance appears as first parameter).
1942         genArgs(tree.args, tree.constructor.externalType(types).getParameterTypes());
1943 
1944         items.makeMemberItem(tree.constructor, true).invoke();
1945         result = items.makeStackItem(tree.type);
1946     }
1947 
1948     public void visitNewArray(JCNewArray tree) {
1949         setTypeAnnotationPositions(tree.pos);
1950 
1951         if (tree.elems != null) {
1952             Type elemtype = types.elemtype(tree.type);
1953             loadIntConst(tree.elems.length());
1954             Item arr = makeNewArray(tree.pos(), tree.type, 1);
1955             int i = 0;
1956             for (List&lt;JCExpression&gt; l = tree.elems; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
2192             }
2193             if (opcode &gt;= ifeq &amp;&amp; opcode &lt;= if_acmpne ||
2194                 opcode == if_acmp_null || opcode == if_acmp_nonnull) {
2195                 return items.makeCondItem(opcode);
2196             } else {
2197                 code.emitop0(opcode);
2198                 return items.makeStackItem(optype.restype);
2199             }
2200         }
2201 
2202     public void visitTypeCast(JCTypeCast tree) {
2203         result = genExpr(tree.expr, tree.clazz.type).load();
2204         setTypeAnnotationPositions(tree.pos);
2205         // Additional code is only needed if we cast to a reference type
2206         // which is not statically a supertype of the expression&#39;s type.
2207         // For basic types, the coerce(...) in genExpr(...) will do
2208         // the conversion.
2209         if (!tree.clazz.type.isPrimitive() &amp;&amp;
2210            !types.isSameType(tree.expr.type, tree.clazz.type) &amp;&amp;
2211            types.asSuper(tree.expr.type, tree.clazz.type.tsym) == null) {
<span class="line-modified">2212             code.emitop2(checkcast, checkDimension(tree.pos(), tree.clazz.type), PoolWriter::putClass);</span>
2213         }
2214     }
2215 
2216     public void visitWildcard(JCWildcard tree) {
2217         throw new AssertionError(this.getClass().getName());
2218     }
2219 
2220     public void visitTypeTest(JCInstanceOf tree) {
2221         genExpr(tree.expr, tree.expr.type).load();
2222         setTypeAnnotationPositions(tree.pos);
<span class="line-modified">2223         code.emitop2(instanceof_, makeRef(tree.pos(), tree.pattern.type));</span>
2224         result = items.makeStackItem(syms.booleanType);
2225     }
2226 
2227     public void visitIndexed(JCArrayAccess tree) {
2228         genExpr(tree.indexed, tree.indexed.type).load();
2229         genExpr(tree.index, syms.intType).load();
2230         result = items.makeIndexedItem(tree.type);
2231     }
2232 
2233     public void visitIdent(JCIdent tree) {
2234         Symbol sym = tree.sym;
2235         if (tree.name == names._this || tree.name == names._super) {
2236             Item res = tree.name == names._this
2237                 ? items.makeThisItem()
2238                 : items.makeSuperItem();
2239             if (sym.kind == MTH) {
2240                 // Generate code to address the constructor.
2241                 res.load();
2242                 res = items.makeMemberItem(sym, true);
2243             }
2244             result = res;
<span class="line-added">2245        } else if (isInvokeDynamic(sym) || isConstantDynamic(sym)) {</span>
<span class="line-added">2246             if (isConstantDynamic(sym)) {</span>
<span class="line-added">2247                 setTypeAnnotationPositions(tree.pos);</span>
<span class="line-added">2248             }</span>
<span class="line-added">2249             result = items.makeDynamicItem(sym);</span>
2250         } else if (sym.kind == VAR &amp;&amp; (sym.owner.kind == MTH || sym.owner.kind == VAR)) {
2251             result = items.makeLocalItem((VarSymbol)sym);


2252         } else if ((sym.flags() &amp; STATIC) != 0) {
2253             if (!isAccessSuper(env.enclMethod))
2254                 sym = binaryQualifier(sym, env.enclClass.type);
2255             result = items.makeStaticItem(sym);
2256         } else {
2257             items.makeThisItem().load();
2258             sym = binaryQualifier(sym, env.enclClass.type);
2259             result = items.makeMemberItem(sym, nonVirtualForPrivateAccess(sym));
2260         }
2261     }
2262 
2263     //where
2264     private boolean nonVirtualForPrivateAccess(Symbol sym) {
2265         boolean useVirtual = target.hasVirtualPrivateInvoke() &amp;&amp;
2266                              !disableVirtualizedPrivateInvoke;
2267         return !useVirtual &amp;&amp; ((sym.flags() &amp; PRIVATE) != 0);
2268     }
2269 
2270     public void visitSelect(JCFieldAccess tree) {
2271         Symbol sym = tree.sym;
2272 
2273         if (tree.name == names._class) {
<span class="line-modified">2274             code.emitLdc((LoadableConstant)checkDimension(tree.pos(), tree.selected.type));</span>
2275             result = items.makeStackItem(pt);
2276             return;
2277        }
2278 
2279         Symbol ssym = TreeInfo.symbol(tree.selected);
2280 
2281         // Are we selecting via super?
2282         boolean selectSuper =
2283             ssym != null &amp;&amp; (ssym.kind == TYP || ssym.name == names._super);
2284 
2285         // Are we accessing a member of the superclass in an access method
2286         // resulting from a qualified super?
2287         boolean accessSuper = isAccessSuper(env.enclMethod);
2288 
2289         Item base = (selectSuper)
2290             ? items.makeSuperItem()
2291             : genExpr(tree.selected, tree.selected.type);
2292 
2293         if (sym.kind == VAR &amp;&amp; ((VarSymbol) sym).getConstValue() != null) {
2294             // We are seeing a variable that is constant but its selecting
</pre>
<hr />
<pre>
2327                                        selectSuper || accessSuper);
2328                 }
2329             }
2330         }
2331     }
2332 
2333     public boolean isInvokeDynamic(Symbol sym) {
2334         return sym.kind == MTH &amp;&amp; ((MethodSymbol)sym).isDynamic();
2335     }
2336 
2337     public void visitLiteral(JCLiteral tree) {
2338         if (tree.type.hasTag(BOT)) {
2339             code.emitop0(aconst_null);
2340             result = items.makeStackItem(tree.type);
2341         }
2342         else
2343             result = items.makeImmediateItem(tree.type, tree.value);
2344     }
2345 
2346     public void visitLetExpr(LetExpr tree) {
<span class="line-added">2347         code.resolvePending();</span>
<span class="line-added">2348 </span>
2349         int limit = code.nextreg;
2350         int prevLetExprStart = code.setLetExprStackPos(code.state.stacksize);
2351         try {
2352             genStats(tree.defs, env);
2353         } finally {
2354             code.setLetExprStackPos(prevLetExprStart);
2355         }
2356         result = genExpr(tree.expr, tree.expr.type).load();
2357         code.endScopes(limit);
2358     }
2359 
<span class="line-modified">2360     private void generateReferencesToPrunedTree(ClassSymbol classSymbol) {</span>
2361         List&lt;JCTree&gt; prunedInfo = lower.prunedTree.get(classSymbol);
2362         if (prunedInfo != null) {
2363             for (JCTree prunedTree: prunedInfo) {
2364                 prunedTree.accept(classReferenceVisitor);
2365             }
2366         }
2367     }
2368 
2369 /* ************************************************************************
2370  * main method
2371  *************************************************************************/
2372 
2373     /** Generate code for a class definition.
2374      *  @param env   The attribution environment that belongs to the
2375      *               outermost class containing this class definition.
2376      *               We need this for resolving some additional symbols.
2377      *  @param cdef  The tree representing the class definition.
2378      *  @return      True if code is generated with no errors.
2379      */
2380     public boolean genClass(Env&lt;AttrContext&gt; env, JCClassDecl cdef) {
2381         try {
2382             attrEnv = env;
2383             ClassSymbol c = cdef.sym;
2384             this.toplevel = env.toplevel;
2385             this.endPosTable = toplevel.endPositions;


2386             /* method normalizeDefs() can add references to external classes into the constant pool
2387              */
2388             cdef.defs = normalizeDefs(cdef.defs, c);
<span class="line-modified">2389             generateReferencesToPrunedTree(c);</span>
2390             Env&lt;GenContext&gt; localEnv = new Env&lt;&gt;(cdef, new GenContext());
2391             localEnv.toplevel = env.toplevel;
2392             localEnv.enclClass = cdef;
2393 
2394             for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2395                 genDef(l.head, localEnv);
2396             }
<span class="line-modified">2397             if (poolWriter.size() &gt; PoolWriter.MAX_ENTRIES) {</span>
2398                 log.error(cdef.pos(), Errors.LimitPool);
2399                 nerrs++;
2400             }
2401             if (nerrs != 0) {
2402                 // if errors, discard code
2403                 for (List&lt;JCTree&gt; l = cdef.defs; l.nonEmpty(); l = l.tail) {
2404                     if (l.head.hasTag(METHODDEF))
2405                         ((JCMethodDecl) l.head).sym.code = null;
2406                 }
2407             }
2408             cdef.defs = List.nil(); // discard trees
2409             return nerrs == 0;
2410         } finally {
2411             // note: this method does NOT support recursion.
2412             attrEnv = null;
2413             this.env = null;
2414             toplevel = null;
2415             endPosTable = null;
2416             nerrs = 0;
2417         }
</pre>
</td>
</tr>
</table>
<center><a href="Code.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Items.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Analyzer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import java.util.ArrayDeque;
 29 import java.util.Arrays;
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Map;
 33 import java.util.Queue;
 34 import java.util.stream.Collectors;
 35 
 36 import com.sun.source.tree.LambdaExpressionTree;
 37 import com.sun.source.tree.NewClassTree;
 38 import com.sun.tools.javac.code.Flags;
 39 import com.sun.tools.javac.code.Kinds.Kind;
 40 import com.sun.tools.javac.code.Source;
 41 import com.sun.tools.javac.code.Source.Feature;
 42 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 43 import com.sun.tools.javac.code.Type;
 44 import com.sun.tools.javac.code.Types;
 45 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
 46 import com.sun.tools.javac.comp.DeferredAttr.AttributionMode;
 47 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 48 import com.sun.tools.javac.tree.JCTree;
 49 import com.sun.tools.javac.tree.JCTree.JCBlock;
 50 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 51 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 52 import com.sun.tools.javac.tree.JCTree.JCEnhancedForLoop;
 53 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 54 import com.sun.tools.javac.tree.JCTree.JCIf;
 55 import com.sun.tools.javac.tree.JCTree.JCLambda;
 56 import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;
 57 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 58 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 59 import com.sun.tools.javac.tree.JCTree.JCNewClass;
 60 import com.sun.tools.javac.tree.JCTree.JCStatement;
 61 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 62 import com.sun.tools.javac.tree.JCTree.JCTry;
 63 import com.sun.tools.javac.tree.JCTree.JCTypeApply;
 64 import com.sun.tools.javac.tree.JCTree.JCUnary;
 65 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 66 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 67 import com.sun.tools.javac.tree.JCTree.Tag;
 68 import com.sun.tools.javac.tree.TreeCopier;
 69 import com.sun.tools.javac.tree.TreeInfo;
 70 import com.sun.tools.javac.tree.TreeMaker;
 71 import com.sun.tools.javac.tree.TreeScanner;
 72 import com.sun.tools.javac.util.Assert;
 73 import com.sun.tools.javac.util.Context;
 74 import com.sun.tools.javac.util.DefinedBy;
 75 import com.sun.tools.javac.util.DefinedBy.Api;
 76 import com.sun.tools.javac.util.DiagnosticSource;
 77 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
 78 import com.sun.tools.javac.util.List;
 79 import com.sun.tools.javac.util.ListBuffer;
 80 import com.sun.tools.javac.util.Log;
 81 import com.sun.tools.javac.util.Options;
 82 import com.sun.tools.javac.util.Position;
 83 
 84 import static com.sun.tools.javac.code.Flags.GENERATEDCONSTR;
 85 import static com.sun.tools.javac.code.TypeTag.CLASS;
 86 import static com.sun.tools.javac.tree.JCTree.Tag.APPLY;
 87 import static com.sun.tools.javac.tree.JCTree.Tag.FOREACHLOOP;
 88 import static com.sun.tools.javac.tree.JCTree.Tag.LABELLED;
 89 import static com.sun.tools.javac.tree.JCTree.Tag.METHODDEF;
 90 import static com.sun.tools.javac.tree.JCTree.Tag.NEWCLASS;
 91 import static com.sun.tools.javac.tree.JCTree.Tag.NULLCHK;
 92 import static com.sun.tools.javac.tree.JCTree.Tag.TYPEAPPLY;
 93 import static com.sun.tools.javac.tree.JCTree.Tag.VARDEF;
 94 
 95 /**
 96  * Helper class for defining custom code analysis, such as finding instance creation expression
 97  * that can benefit from diamond syntax.
 98  */
 99 public class Analyzer {
100     protected static final Context.Key&lt;Analyzer&gt; analyzerKey = new Context.Key&lt;&gt;();
101 
102     final Types types;
103     final Log log;
104     final Attr attr;
105     final DeferredAttr deferredAttr;
106     final ArgumentAttr argumentAttr;
107     final TreeMaker make;
108     final AnalyzerCopier copier;
109     private final boolean allowDiamondWithAnonymousClassCreation;
110 
111     final EnumSet&lt;AnalyzerMode&gt; analyzerModes;
112 
113     public static Analyzer instance(Context context) {
114         Analyzer instance = context.get(analyzerKey);
115         if (instance == null)
116             instance = new Analyzer(context);
117         return instance;
118     }
119 
120     protected Analyzer(Context context) {
121         context.put(analyzerKey, this);
122         types = Types.instance(context);
123         log = Log.instance(context);
124         attr = Attr.instance(context);
125         deferredAttr = DeferredAttr.instance(context);
126         argumentAttr = ArgumentAttr.instance(context);
127         make = TreeMaker.instance(context);
128         copier = new AnalyzerCopier();
129         Options options = Options.instance(context);
130         String findOpt = options.get(&quot;find&quot;);
131         //parse modes
132         Source source = Source.instance(context);
133         allowDiamondWithAnonymousClassCreation = Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source);
134         analyzerModes = AnalyzerMode.getAnalyzerModes(findOpt, source);
135     }
136 
137     /**
138      * This enum defines supported analyzer modes, as well as defining the logic for decoding
139      * the {@code -XDfind} option.
140      */
141     enum AnalyzerMode {
142         DIAMOND(&quot;diamond&quot;, Feature.DIAMOND),
143         LAMBDA(&quot;lambda&quot;, Feature.LAMBDA),
144         METHOD(&quot;method&quot;, Feature.GRAPH_INFERENCE),
145         LOCAL(&quot;local&quot;, Feature.LOCAL_VARIABLE_TYPE_INFERENCE);
146 
147         final String opt;
148         final Feature feature;
149 
150         AnalyzerMode(String opt, Feature feature) {
151             this.opt = opt;
152             this.feature = feature;
153         }
154 
155         /**
156          * This method is used to parse the {@code find} option.
157          * Possible modes are separated by colon; a mode can be excluded by
158          * prepending &#39;-&#39; to its name. Finally, the special mode &#39;all&#39; can be used to
159          * add all modes to the resulting enum.
160          */
161         static EnumSet&lt;AnalyzerMode&gt; getAnalyzerModes(String opt, Source source) {
162             if (opt == null) {
163                 return EnumSet.noneOf(AnalyzerMode.class);
164             }
165             List&lt;String&gt; modes = List.from(opt.split(&quot;,&quot;));
166             EnumSet&lt;AnalyzerMode&gt; res = EnumSet.noneOf(AnalyzerMode.class);
167             if (modes.contains(&quot;all&quot;)) {
168                 res = EnumSet.allOf(AnalyzerMode.class);
169             }
170             for (AnalyzerMode mode : values()) {
171                 if (modes.contains(&quot;-&quot; + mode.opt) || !mode.feature.allowedInSource(source)) {
172                     res.remove(mode);
173                 } else if (modes.contains(mode.opt)) {
174                     res.add(mode);
175                 }
176             }
177             return res;
178         }
179     }
180 
181     /**
182      * A statement analyzer is a work-unit that matches certain AST nodes (of given type {@code S}),
183      * rewrites them to different AST nodes (of type {@code T}) and then generates some meaningful
184      * messages in case the analysis has been successful.
185      */
186     abstract class StatementAnalyzer&lt;S extends JCTree, T extends JCTree&gt; {
187 
188         AnalyzerMode mode;
189         JCTree.Tag tag;
190 
191         StatementAnalyzer(AnalyzerMode mode, Tag tag) {
192             this.mode = mode;
193             this.tag = tag;
194         }
195 
196         /**
197          * Is this analyzer allowed to run?
198          */
199         boolean isEnabled() {
200             return analyzerModes.contains(mode);
201         }
202 
203         /**
204          * Should this analyzer be rewriting the given tree?
205          */
206         abstract boolean match(S tree);
207 
208         /**
209          * Rewrite a given AST node into a new one(s)
210          */
211         abstract List&lt;T&gt; rewrite(S oldTree);
212 
213         /**
214          * Entry-point for comparing results and generating diagnostics.
215          */
216         abstract void process(S oldTree, T newTree, boolean hasErrors);
217     }
218 
219     /**
220      * This analyzer checks if generic instance creation expression can use diamond syntax.
221      */
222     class DiamondInitializer extends StatementAnalyzer&lt;JCNewClass, JCNewClass&gt; {
223 
224         DiamondInitializer() {
225             super(AnalyzerMode.DIAMOND, NEWCLASS);
226         }
227 
228         @Override
229         boolean match(JCNewClass tree) {
230             return tree.clazz.hasTag(TYPEAPPLY) &amp;&amp;
231                     !TreeInfo.isDiamond(tree) &amp;&amp;
232                     (tree.def == null || allowDiamondWithAnonymousClassCreation);
233         }
234 
235         @Override
236         List&lt;JCNewClass&gt; rewrite(JCNewClass oldTree) {
237             if (oldTree.clazz.hasTag(TYPEAPPLY)) {
238                 JCNewClass nc = copier.copy(oldTree);
239                 ((JCTypeApply)nc.clazz).arguments = List.nil();
240                 return List.of(nc);
241             } else {
242                 return List.of(oldTree);
243             }
244         }
245 
246         @Override
247         void process(JCNewClass oldTree, JCNewClass newTree, boolean hasErrors) {
248             if (!hasErrors) {
249                 List&lt;Type&gt; inferredArgs, explicitArgs;
250                 if (oldTree.def != null) {
251                     inferredArgs = newTree.def.implementing.nonEmpty()
252                                       ? newTree.def.implementing.get(0).type.getTypeArguments()
253                                       : newTree.def.extending.type.getTypeArguments();
254                     explicitArgs = oldTree.def.implementing.nonEmpty()
255                                       ? oldTree.def.implementing.get(0).type.getTypeArguments()
256                                       : oldTree.def.extending.type.getTypeArguments();
257                 } else {
258                     inferredArgs = newTree.type.getTypeArguments();
259                     explicitArgs = oldTree.type.getTypeArguments();
260                 }
261                 for (Type t : inferredArgs) {
262                     if (!types.isSameType(t, explicitArgs.head)) {
263                         return;
264                     }
265                     explicitArgs = explicitArgs.tail;
266                 }
267                 //exact match
268                 log.warning(oldTree.clazz, Warnings.DiamondRedundantArgs);
269             }
270         }
271     }
272 
273     /**
274      * This analyzer checks if anonymous instance creation expression can replaced by lambda.
275      */
276     class LambdaAnalyzer extends StatementAnalyzer&lt;JCNewClass, JCLambda&gt; {
277 
278         LambdaAnalyzer() {
279             super(AnalyzerMode.LAMBDA, NEWCLASS);
280         }
281 
282         @Override
283         boolean match (JCNewClass tree){
284             Type clazztype = tree.clazz.type;
285             return tree.def != null &amp;&amp;
286                     clazztype.hasTag(CLASS) &amp;&amp;
287                     types.isFunctionalInterface(clazztype.tsym) &amp;&amp;
288                     decls(tree.def).length() == 1;
289         }
290         //where
291             private List&lt;JCTree&gt; decls(JCClassDecl decl) {
292                 ListBuffer&lt;JCTree&gt; decls = new ListBuffer&lt;&gt;();
293                 for (JCTree t : decl.defs) {
294                     if (t.hasTag(METHODDEF)) {
295                         JCMethodDecl md = (JCMethodDecl)t;
296                         if ((md.getModifiers().flags &amp; GENERATEDCONSTR) == 0) {
297                             decls.add(md);
298                         }
299                     } else {
300                         decls.add(t);
301                     }
302                 }
303                 return decls.toList();
304             }
305 
306         @Override
307         List&lt;JCLambda&gt; rewrite(JCNewClass oldTree){
308             JCMethodDecl md = (JCMethodDecl)copier.copy(decls(oldTree.def).head);
309             List&lt;JCVariableDecl&gt; params = md.params;
310             JCBlock body = md.body;
311             JCLambda newTree = make.at(oldTree).Lambda(params, body);
312             return List.of(newTree);
313         }
314 
315         @Override
316         void process (JCNewClass oldTree, JCLambda newTree, boolean hasErrors){
317             if (!hasErrors) {
318                 log.warning(oldTree.def, Warnings.PotentialLambdaFound);
319             }
320         }
321     }
322 
323     /**
324      * This analyzer checks if generic method call has redundant type arguments.
325      */
326     class RedundantTypeArgAnalyzer extends StatementAnalyzer&lt;JCMethodInvocation, JCMethodInvocation&gt; {
327 
328         RedundantTypeArgAnalyzer() {
329             super(AnalyzerMode.METHOD, APPLY);
330         }
331 
332         @Override
333         boolean match (JCMethodInvocation tree){
334             return tree.typeargs != null &amp;&amp;
335                     tree.typeargs.nonEmpty();
336         }
337         @Override
338         List&lt;JCMethodInvocation&gt; rewrite(JCMethodInvocation oldTree){
339             JCMethodInvocation app = copier.copy(oldTree);
340             app.typeargs = List.nil();
341             return List.of(app);
342         }
343 
344         @Override
345         void process (JCMethodInvocation oldTree, JCMethodInvocation newTree, boolean hasErrors){
346             if (!hasErrors) {
347                 //exact match
348                 log.warning(oldTree, Warnings.MethodRedundantTypeargs);
349             }
350         }
351     }
352 
353     /**
354      * Base class for local variable inference analyzers.
355      */
356     abstract class RedundantLocalVarTypeAnalyzerBase&lt;X extends JCStatement&gt; extends StatementAnalyzer&lt;X, X&gt; {
357 
358         RedundantLocalVarTypeAnalyzerBase(JCTree.Tag tag) {
359             super(AnalyzerMode.LOCAL, tag);
360         }
361 
362         boolean isImplicitlyTyped(JCVariableDecl decl) {
363             return decl.vartype.pos == Position.NOPOS;
364         }
365 
366         /**
367          * Map a variable tree into a new declaration using implicit type.
368          */
369         JCVariableDecl rewriteVarType(JCVariableDecl oldTree) {
370             JCVariableDecl newTree = copier.copy(oldTree);
371             newTree.vartype = null;
372             return newTree;
373         }
374 
375         /**
376          * Analyze results of local variable inference.
377          */
378         void processVar(JCVariableDecl oldTree, JCVariableDecl newTree, boolean hasErrors) {
379             if (!hasErrors) {
380                 if (types.isSameType(oldTree.type, newTree.type)) {
381                     log.warning(oldTree, Warnings.LocalRedundantType);
382                 }
383             }
384         }
385     }
386 
387     /**
388      * This analyzer checks if a local variable declaration has redundant type.
389      */
390     class RedundantLocalVarTypeAnalyzer extends RedundantLocalVarTypeAnalyzerBase&lt;JCVariableDecl&gt; {
391 
392         RedundantLocalVarTypeAnalyzer() {
393             super(VARDEF);
394         }
395 
396         boolean match(JCVariableDecl tree){
397             return tree.sym.owner.kind == Kind.MTH &amp;&amp;
398                     tree.init != null &amp;&amp; !isImplicitlyTyped(tree) &amp;&amp;
399                     attr.canInferLocalVarType(tree) == null;
400         }
401         @Override
402         List&lt;JCVariableDecl&gt; rewrite(JCVariableDecl oldTree) {
403             return List.of(rewriteVarType(oldTree));
404         }
405         @Override
406         void process(JCVariableDecl oldTree, JCVariableDecl newTree, boolean hasErrors){
407             processVar(oldTree, newTree, hasErrors);
408         }
409     }
410 
411     /**
412      * This analyzer checks if a for each variable declaration has redundant type.
413      */
414     class RedundantLocalVarTypeAnalyzerForEach extends RedundantLocalVarTypeAnalyzerBase&lt;JCEnhancedForLoop&gt; {
415 
416         RedundantLocalVarTypeAnalyzerForEach() {
417             super(FOREACHLOOP);
418         }
419 
420         @Override
421         boolean match(JCEnhancedForLoop tree){
422             return !isImplicitlyTyped(tree.var);
423         }
424         @Override
425         List&lt;JCEnhancedForLoop&gt; rewrite(JCEnhancedForLoop oldTree) {
426             JCEnhancedForLoop newTree = copier.copy(oldTree);
427             newTree.var = rewriteVarType(oldTree.var);
428             newTree.body = make.at(oldTree.body).Block(0, List.nil());
429             return List.of(newTree);
430         }
431         @Override
432         void process(JCEnhancedForLoop oldTree, JCEnhancedForLoop newTree, boolean hasErrors){
433             processVar(oldTree.var, newTree.var, hasErrors);
434         }
435     }
436 
437     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
438     StatementAnalyzer&lt;JCTree, JCTree&gt;[] analyzers = new StatementAnalyzer[] {
439             new DiamondInitializer(),
440             new LambdaAnalyzer(),
441             new RedundantTypeArgAnalyzer(),
442             new RedundantLocalVarTypeAnalyzer(),
443             new RedundantLocalVarTypeAnalyzerForEach()
444     };
445 
446     /**
447      * Create a copy of Env if needed.
448      */
449     Env&lt;AttrContext&gt; copyEnvIfNeeded(JCTree tree, Env&lt;AttrContext&gt; env) {
450         if (!analyzerModes.isEmpty() &amp;&amp;
451                 !env.info.attributionMode.isSpeculative &amp;&amp;
452                 TreeInfo.isStatement(tree) &amp;&amp;
453                 !tree.hasTag(LABELLED)) {
454             Env&lt;AttrContext&gt; analyzeEnv =
455                     env.dup(env.tree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));
456             analyzeEnv.info.returnResult = analyzeEnv.info.returnResult != null ?
457                     attr.new ResultInfo(analyzeEnv.info.returnResult.pkind,
458                                         analyzeEnv.info.returnResult.pt) : null;
459             return analyzeEnv;
460         } else {
461             return null;
462         }
463     }
464 
465     /**
466      * Analyze an AST node if needed.
467      */
468     void analyzeIfNeeded(JCTree tree, Env&lt;AttrContext&gt; env) {
469         if (env != null) {
470             JCStatement stmt = (JCStatement)tree;
471             analyze(stmt, env);
472         }
473     }
474 
475     /**
476      * Analyze an AST node; this involves collecting a list of all the nodes that needs rewriting,
477      * and speculatively type-check the rewritten code to compare results against previously attributed code.
478      */
479     protected void analyze(JCStatement statement, Env&lt;AttrContext&gt; env) {
480         StatementScanner statementScanner = new StatementScanner(statement, env);
481         statementScanner.scan();
482 
483         if (!statementScanner.rewritings.isEmpty()) {
484             for (RewritingContext rewriting : statementScanner.rewritings) {
485                 deferredAnalysisHelper.queue(rewriting);
486             }
487         }
488     }
489 
490     /**
491      * Helper interface to handle deferral of analysis tasks.
492      */
493     interface DeferredAnalysisHelper {
494         /**
495          * Add a new analysis task to the queue.
496          */
497         void queue(RewritingContext rewriting);
498         /**
499          * Flush queue with given attribution env.
500          */
501         void flush(Env&lt;AttrContext&gt; flushEnv);
502     }
503 
504     /**
505      * Dummy deferral handler.
506      */
507     DeferredAnalysisHelper flushDeferredHelper = new DeferredAnalysisHelper() {
508         @Override
509         public void queue(RewritingContext rewriting) {
510             //do nothing
511         }
512 
513         @Override
514         public void flush(Env&lt;AttrContext&gt; flushEnv) {
515             //do nothing
516         }
517     };
518 
519     /**
520      * Simple deferral handler. All tasks belonging to the same outermost class are added to
521      * the same queue. The queue is flushed after flow analysis (only if no error occurred).
522      */
523     DeferredAnalysisHelper queueDeferredHelper = new DeferredAnalysisHelper() {
524 
525         Map&lt;ClassSymbol, Queue&lt;RewritingContext&gt;&gt; Q = new HashMap&lt;&gt;();
526 
527         @Override
528         public void queue(RewritingContext rewriting) {
529             Queue&lt;RewritingContext&gt; s = Q.computeIfAbsent(rewriting.env.enclClass.sym.outermostClass(), k -&gt; new ArrayDeque&lt;&gt;());
530             s.add(rewriting);
531         }
532 
533         @Override
534         public void flush(Env&lt;AttrContext&gt; flushEnv) {
535             if (!Q.isEmpty()) {
536                 DeferredAnalysisHelper prevHelper = deferredAnalysisHelper;
537                 try {
538                     deferredAnalysisHelper = flushDeferredHelper;
539                     Queue&lt;RewritingContext&gt; rewritings = Q.get(flushEnv.enclClass.sym.outermostClass());
540                     while (rewritings != null &amp;&amp; !rewritings.isEmpty()) {
541                         doAnalysis(rewritings.remove());
542                     }
543                 } finally {
544                     deferredAnalysisHelper = prevHelper;
545                 }
546             }
547         }
548     };
549 
550     DeferredAnalysisHelper deferredAnalysisHelper = queueDeferredHelper;
551 
552     void doAnalysis(RewritingContext rewriting) {
553         DiagnosticSource prevSource = log.currentSource();
554         LocalCacheContext localCacheContext = argumentAttr.withLocalCacheContext();
555         try {
556             log.useSource(rewriting.env.toplevel.getSourceFile());
557 
558             JCStatement treeToAnalyze = (JCStatement)rewriting.originalTree;
559             if (rewriting.env.info.scope.owner.kind == Kind.TYP) {
560                 //add a block to hoist potential dangling variable declarations
561                 treeToAnalyze = make.at(Position.NOPOS)
562                                     .Block(Flags.SYNTHETIC, List.of((JCStatement)rewriting.originalTree));
563             }
564 
565             //TODO: to further refine the analysis, try all rewriting combinations
566             deferredAttr.attribSpeculative(treeToAnalyze, rewriting.env, attr.statInfo, new TreeRewriter(rewriting),
567                     () -&gt; rewriting.diagHandler(), AttributionMode.ANALYZER, argumentAttr.withLocalCacheContext());
568             rewriting.analyzer.process(rewriting.oldTree, rewriting.replacement, rewriting.erroneous);
569         } catch (Throwable ex) {
570             Assert.error(&quot;Analyzer error when processing: &quot; +
571                          rewriting.originalTree + &quot;:&quot; + ex.toString() + &quot;\n&quot; +
572                          Arrays.stream(ex.getStackTrace())
573                                .map(se -&gt; se.toString())
574                                .collect(Collectors.joining(&quot;\n&quot;)));
575         } finally {
576             log.useSource(prevSource.getFile());
577             localCacheContext.leave();
578         }
579     }
580 
581     public void flush(Env&lt;AttrContext&gt; flushEnv) {
582         deferredAnalysisHelper.flush(flushEnv);
583     }
584 
585     /**
586      * Subclass of {@link com.sun.tools.javac.tree.TreeScanner} which visit AST-nodes w/o crossing
587      * statement boundaries.
588      */
589     class StatementScanner extends TreeScanner {
590         /** Tree rewritings (generated by analyzers). */
591         ListBuffer&lt;RewritingContext&gt; rewritings = new ListBuffer&lt;&gt;();
592         JCTree originalTree;
593         Env&lt;AttrContext&gt; env;
594 
595         StatementScanner(JCTree originalTree, Env&lt;AttrContext&gt; env) {
596             this.originalTree = originalTree;
597             this.env = attr.copyEnv(env);
598         }
599 
600         public void scan() {
601             scan(originalTree);
602         }
603 
604         @Override
605         @SuppressWarnings(&quot;unchecked&quot;)
606         public void scan(JCTree tree) {
607             if (tree != null) {
608                 for (StatementAnalyzer&lt;JCTree, JCTree&gt; analyzer : analyzers) {
609                     if (analyzer.isEnabled() &amp;&amp;
610                             tree.hasTag(analyzer.tag) &amp;&amp;
611                             analyzer.match(tree)) {
612                         for (JCTree t : analyzer.rewrite(tree)) {
613                             rewritings.add(new RewritingContext(originalTree, tree, t, analyzer, env));
614                         }
615                         break; //TODO: cover cases where multiple matching analyzers are found
616                     }
617                 }
618             }
619             super.scan(tree);
620         }
621 
622         @Override
623         public void visitClassDef(JCClassDecl tree) {
624             //do nothing (prevents seeing same stuff twice)
625         }
626 
627         @Override
628         public void visitMethodDef(JCMethodDecl tree) {
629             //do nothing (prevents seeing same stuff twice)
630         }
631 
632         @Override
633         public void visitBlock(JCBlock tree) {
634             //do nothing (prevents seeing same stuff twice)
635         }
636 
637         @Override
638         public void visitLambda(JCLambda tree) {
639             //do nothing (prevents seeing same stuff in lambda expression twice)
640         }
641 
642         @Override
643         public void visitSwitch(JCSwitch tree) {
644             scan(tree.getExpression());
645         }
646 
647         @Override
648         public void visitForLoop(JCForLoop tree) {
649             //skip body and var decl (to prevents same statements to be analyzed twice)
650             scan(tree.getCondition());
651             scan(tree.getUpdate());
652         }
653 
654         @Override
655         public void visitTry(JCTry tree) {
656             //skip resources (to prevents same statements to be analyzed twice)
657             scan(tree.getBlock());
658             scan(tree.getCatches());
659             scan(tree.getFinallyBlock());
660         }
661 
662         @Override
663         public void visitForeachLoop(JCEnhancedForLoop tree) {
664             //skip body (to prevents same statements to be analyzed twice)
665             scan(tree.getExpression());
666         }
667 
668         @Override
669         public void visitWhileLoop(JCWhileLoop tree) {
670             //skip body (to prevents same statements to be analyzed twice)
671             scan(tree.getCondition());
672         }
673 
674         @Override
675         public void visitDoLoop(JCDoWhileLoop tree) {
676             //skip body (to prevents same statements to be analyzed twice)
677             scan(tree.getCondition());
678         }
679 
680         @Override
681         public void visitIf(JCIf tree) {
682             //skip body (to prevents same statements to be analyzed twice)
683             scan(tree.getCondition());
684         }
685     }
686 
687     class RewritingContext {
688         // the whole tree being analyzed
689         JCTree originalTree;
690         // a subtree, old tree, that will be rewritten
691         JCTree oldTree;
692         // the replacement for the old tree
693         JCTree replacement;
694         // did the compiler find any error
695         boolean erroneous;
696         // the env
697         Env&lt;AttrContext&gt; env;
698         // the corresponding analyzer
699         StatementAnalyzer&lt;JCTree, JCTree&gt; analyzer;
700 
701         RewritingContext(
702                 JCTree originalTree,
703                 JCTree oldTree,
704                 JCTree replacement,
705                 StatementAnalyzer&lt;JCTree, JCTree&gt; analyzer,
706                 Env&lt;AttrContext&gt; env) {
707             this.originalTree = originalTree;
708             this.oldTree = oldTree;
709             this.replacement = replacement;
710             this.analyzer = analyzer;
711             this.env = attr.copyEnv(env);
712             /*  this is a temporary workaround that should be removed once we have a truly independent
713              *  clone operation
714              */
715             if (originalTree.hasTag(VARDEF)) {
716                 // avoid redefinition clashes
717                 this.env.info.scope.remove(((JCVariableDecl)originalTree).sym);
718             }
719         }
720 
721         /**
722          * Simple deferred diagnostic handler which filters out all messages and keep track of errors.
723          */
724         Log.DeferredDiagnosticHandler diagHandler() {
725             return new Log.DeferredDiagnosticHandler(log, d -&gt; {
726                 if (d.getType() == DiagnosticType.ERROR) {
727                     erroneous = true;
728                 }
729                 return true;
730             });
731         }
732     }
733 
734     /**
735      * Subclass of TreeCopier that maps nodes matched by analyzers onto new AST nodes.
736      */
737     class AnalyzerCopier extends TreeCopier&lt;Void&gt; {
738 
739         public AnalyzerCopier() {
740             super(make);
741         }
742 
743         @Override @DefinedBy(Api.COMPILER_TREE)
744         public JCTree visitLambdaExpression(LambdaExpressionTree node, Void _unused) {
745             JCLambda oldLambda = (JCLambda)node;
746             JCLambda newLambda = (JCLambda)super.visitLambdaExpression(node, _unused);
747             if (oldLambda.paramKind == ParameterKind.IMPLICIT) {
748                 //reset implicit lambda parameters (whose type might have been set during attr)
749                 newLambda.paramKind = ParameterKind.IMPLICIT;
750                 newLambda.params.forEach(p -&gt; p.vartype = null);
751             }
752             return newLambda;
753         }
754 
755         @Override @DefinedBy(Api.COMPILER_TREE)
756         public JCTree visitNewClass(NewClassTree node, Void aVoid) {
757             JCNewClass oldNewClazz = (JCNewClass)node;
758             JCNewClass newNewClazz = (JCNewClass)super.visitNewClass(node, aVoid);
759             if (!oldNewClazz.args.isEmpty() &amp;&amp; oldNewClazz.args.head.hasTag(NULLCHK)) {
760                 //workaround to Attr generating trees
761                 newNewClazz.encl = ((JCUnary)newNewClazz.args.head).arg;
762                 newNewClazz.args = newNewClazz.args.tail;
763             }
764             return newNewClazz;
765         }
766     }
767 
768    class TreeRewriter extends AnalyzerCopier {
769 
770         RewritingContext rewriting;
771 
772         TreeRewriter(RewritingContext rewriting) {
773             this.rewriting = rewriting;
774         }
775 
776         @Override
777         @SuppressWarnings(&quot;unchecked&quot;)
778         public &lt;Z extends JCTree&gt; Z copy(Z tree, Void _unused) {
779             Z newTree = super.copy(tree, null);
780             if (tree != null &amp;&amp; tree == rewriting.oldTree) {
781                 Assert.checkNonNull(rewriting.replacement);
782                 newTree = (Z)rewriting.replacement;
783             }
784             return newTree;
785         }
786     }
787 }
    </pre>
  </body>
</html>
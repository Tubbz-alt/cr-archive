<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<a name="2" id="anc2"></a><span class="line-added">  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;</span>
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
<a name="3" id="anc3"></a><span class="line-added">  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;</span>
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
<a name="4" id="anc4"></a><span class="line-added">  68 import java.util.function.Consumer;</span>
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean checkVarargsAccessAfterResolution;
 109     private final boolean compactMethodDiags;
 110     private final boolean allowLocalVariableTypeInference;
<a name="5" id="anc5"></a><span class="line-added"> 111     private final boolean allowYieldStatement;</span>
 112     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 113 
 114     WriteableScope polymorphicSignatureScope;
 115 
 116     protected Resolve(Context context) {
 117         context.put(resolveKey, this);
 118         syms = Symtab.instance(context);
 119 
 120         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 121         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 122         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 123         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 124 
 125         names = Names.instance(context);
 126         log = Log.instance(context);
 127         attr = Attr.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         chk = Check.instance(context);
 130         infer = Infer.instance(context);
 131         finder = ClassFinder.instance(context);
 132         moduleFinder = ModuleFinder.instance(context);
 133         types = Types.instance(context);
 134         diags = JCDiagnostic.Factory.instance(context);
<a name="6" id="anc6"></a><span class="line-added"> 135         Preview preview = Preview.instance(context);</span>
 136         Source source = Source.instance(context);
 137         Options options = Options.instance(context);
 138         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 139                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 140         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 141         Target target = Target.instance(context);
 142         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 143         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
<a name="7" id="anc7"></a><span class="line-added"> 144         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 145                 Feature.SWITCH_EXPRESSION.allowedInSource(source);</span>
 146         checkVarargsAccessAfterResolution =
 147                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 148         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 149         allowModules = Feature.MODULES.allowedInSource(source);
 150     }
 151 
 152     /** error symbols, which are returned when resolution fails
 153      */
 154     private final SymbolNotFoundError varNotFound;
 155     private final SymbolNotFoundError methodNotFound;
 156     private final SymbolNotFoundError typeNotFound;
 157 
 158     /** empty reference lookup result */
 159     private final ReferenceLookupResult referenceNotFound;
 160 
 161     public static Resolve instance(Context context) {
 162         Resolve instance = context.get(resolveKey);
 163         if (instance == null)
 164             instance = new Resolve(context);
 165         return instance;
 166     }
 167 
 168     private static Symbol bestOf(Symbol s1,
 169                                  Symbol s2) {
 170         return s1.kind.betterThan(s2.kind) ? s1 : s2;
 171     }
 172 
 173     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;
 174     enum VerboseResolutionMode {
 175         SUCCESS(&quot;success&quot;),
 176         FAILURE(&quot;failure&quot;),
 177         APPLICABLE(&quot;applicable&quot;),
 178         INAPPLICABLE(&quot;inapplicable&quot;),
 179         DEFERRED_INST(&quot;deferred-inference&quot;),
 180         PREDEF(&quot;predef&quot;),
 181         OBJECT_INIT(&quot;object-init&quot;),
 182         INTERNAL(&quot;internal&quot;);
 183 
 184         final String opt;
 185 
 186         private VerboseResolutionMode(String opt) {
 187             this.opt = opt;
 188         }
 189 
 190         static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
 191             String s = opts.get(&quot;debug.verboseResolution&quot;);
 192             EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);
 193             if (s == null) return res;
 194             if (s.contains(&quot;all&quot;)) {
 195                 res = EnumSet.allOf(VerboseResolutionMode.class);
 196             }
 197             Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
 198             for (VerboseResolutionMode mode : values()) {
 199                 if (args.contains(mode.opt)) {
 200                     res.add(mode);
 201                 } else if (args.contains(&quot;-&quot; + mode.opt)) {
 202                     res.remove(mode);
 203                 }
 204             }
 205             return res;
 206         }
 207     }
 208 
 209     void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
 210             List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
 211         boolean success = !bestSoFar.kind.isResolutionError();
 212 
 213         if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
 214             return;
 215         } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
 216             return;
 217         }
 218 
 219         if (bestSoFar.name == names.init &amp;&amp;
 220                 bestSoFar.owner == syms.objectType.tsym &amp;&amp;
 221                 !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
 222             return; //skip diags for Object constructor resolution
 223         } else if (site == syms.predefClass.type &amp;&amp;
 224                 !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
 225             return; //skip spurious diags for predef symbols (i.e. operators)
 226         } else if (currentResolutionContext.internalResolution &amp;&amp;
 227                 !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
 228             return;
 229         }
 230 
 231         int pos = 0;
 232         int mostSpecificPos = -1;
 233         ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
 234         for (Candidate c : currentResolutionContext.candidates) {
 235             if (currentResolutionContext.step != c.step ||
 236                     (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
 237                     (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
 238                 continue;
 239             } else {
 240                 subDiags.append(c.isApplicable() ?
 241                         getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
 242                         getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
 243                 if (c.sym == bestSoFar)
 244                     mostSpecificPos = pos;
 245                 pos++;
 246             }
 247         }
 248         String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;
 249         List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));
 250         JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
 251                 site.tsym, mostSpecificPos, currentResolutionContext.step,
 252                 methodArguments(argtypes2),
 253                 methodArguments(typeargtypes));
 254         JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
 255         log.report(d);
 256     }
 257 
 258     JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
 259         JCDiagnostic subDiag = null;
 260         if (sym.type.hasTag(FORALL)) {
 261             subDiag = diags.fragment(Fragments.PartialInstSig(inst));
 262         }
 263 
 264         String key = subDiag == null ?
 265                 &quot;applicable.method.found&quot; :
 266                 &quot;applicable.method.found.1&quot;;
 267 
 268         return diags.fragment(key, pos, sym, subDiag);
 269     }
 270 
 271     JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
 272         return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
 273     }
 274     // &lt;/editor-fold&gt;
 275 
 276 /* ************************************************************************
 277  * Identifier resolution
 278  *************************************************************************/
 279 
 280     /** An environment is &quot;static&quot; if its static level is greater than
 281      *  the one of its outer environment
 282      */
 283     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 284         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 285     }
 286 
 287     /** An environment is an &quot;initializer&quot; if it is a constructor or
 288      *  an instance initializer.
 289      */
 290     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 291         Symbol owner = env.info.scope.owner;
 292         return owner.isConstructor() ||
 293             owner.owner.kind == TYP &amp;&amp;
 294             (owner.kind == VAR ||
 295              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 296             (owner.flags() &amp; STATIC) == 0;
 297     }
 298 
<a name="8" id="anc8"></a><span class="line-modified"> 299     /** Is class accessible in given environment?</span>
 300      *  @param env    The current environment.
 301      *  @param c      The class whose accessibility is checked.
 302      */
 303     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 304         return isAccessible(env, c, false);
 305     }
 306 
 307     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 308 
 309         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 310            to refer to an inaccessible type
 311         */
 312         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 313             return true;
 314 
 315         if (env.info.visitingServiceImplementation &amp;&amp;
 316             env.toplevel.modle == c.packge().modle) {
 317             return true;
 318         }
 319 
 320         boolean isAccessible = false;
 321         switch ((short)(c.flags() &amp; AccessFlags)) {
 322             case PRIVATE:
 323                 isAccessible =
 324                     env.enclClass.sym.outermostClass() ==
 325                     c.owner.outermostClass();
 326                 break;
 327             case 0:
 328                 isAccessible =
 329                     env.toplevel.packge == c.owner // fast special case
 330                     ||
 331                     env.toplevel.packge == c.packge();
 332                 break;
 333             default: // error recovery
 334                 isAccessible = true;
 335                 break;
 336             case PUBLIC:
 337                 if (allowModules) {
 338                     ModuleSymbol currModule = env.toplevel.modle;
 339                     currModule.complete();
 340                     PackageSymbol p = c.packge();
 341                     isAccessible =
 342                         currModule == p.modle ||
 343                         currModule.visiblePackages.get(p.fullname) == p ||
 344                         p == syms.rootPackage ||
 345                         (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
 346                 } else {
 347                     isAccessible = true;
 348                 }
 349                 break;
 350             case PROTECTED:
 351                 isAccessible =
 352                     env.toplevel.packge == c.owner // fast special case
 353                     ||
 354                     env.toplevel.packge == c.packge()
 355                     ||
 356                     isInnerSubClass(env.enclClass.sym, c.owner);
 357                 break;
 358         }
 359         return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?
 360             isAccessible :
 361             isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
 362     }
 363     //where
 364         /** Is given class a subclass of given base class, or an inner class
 365          *  of a subclass?
 366          *  Return null if no such class exists.
 367          *  @param c     The class which is the subclass or is contained in it.
 368          *  @param base  The base class
 369          */
 370         private boolean isInnerSubClass(ClassSymbol c, Symbol base) {
 371             while (c != null &amp;&amp; !c.isSubClass(base, types)) {
 372                 c = c.owner.enclClass();
 373             }
 374             return c != null;
 375         }
 376 
 377     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
 378         return isAccessible(env, t, false);
 379     }
 380 
 381     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
 382         return (t.hasTag(ARRAY))
 383             ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
 384             : isAccessible(env, t.tsym, checkInner);
 385     }
 386 
 387     /** Is symbol accessible as a member of given type in given environment?
 388      *  @param env    The current environment.
 389      *  @param site   The type of which the tested symbol is regarded
 390      *                as a member.
 391      *  @param sym    The symbol.
 392      */
 393     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
 394         return isAccessible(env, site, sym, false);
 395     }
 396     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
 397         if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
 398 
 399         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 400            to refer to an inaccessible type
 401         */
 402         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 403             return true;
 404 
 405         if (env.info.visitingServiceImplementation &amp;&amp;
 406             env.toplevel.modle == sym.packge().modle) {
 407             return true;
 408         }
 409 
 410         switch ((short)(sym.flags() &amp; AccessFlags)) {
 411         case PRIVATE:
 412             return
 413                 (env.enclClass.sym == sym.owner // fast special case
 414                  ||
 415                  env.enclClass.sym.outermostClass() ==
 416                  sym.owner.outermostClass())
 417                 &amp;&amp;
 418                 sym.isInheritedIn(site.tsym, types);
 419         case 0:
 420             return
 421                 (env.toplevel.packge == sym.owner.owner // fast special case
 422                  ||
 423                  env.toplevel.packge == sym.packge())
 424                 &amp;&amp;
 425                 isAccessible(env, site, checkInner)
 426                 &amp;&amp;
 427                 sym.isInheritedIn(site.tsym, types)
 428                 &amp;&amp;
 429                 notOverriddenIn(site, sym);
 430         case PROTECTED:
 431             return
 432                 (env.toplevel.packge == sym.owner.owner // fast special case
 433                  ||
 434                  env.toplevel.packge == sym.packge()
 435                  ||
 436                  isProtectedAccessible(sym, env.enclClass.sym, site)
 437                  ||
 438                  // OK to select instance method or field from &#39;super&#39; or type name
 439                  // (but type names should be disallowed elsewhere!)
 440                  env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)
 441                 &amp;&amp;
 442                 isAccessible(env, site, checkInner)
 443                 &amp;&amp;
 444                 notOverriddenIn(site, sym);
 445         default: // this case includes erroneous combinations as well
 446             return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);
 447         }
 448     }
 449     //where
 450     /* `sym&#39; is accessible only if not overridden by
 451      * another symbol which is a member of `site&#39;
 452      * (because, if it is overridden, `sym&#39; is not strictly
 453      * speaking a member of `site&#39;). A polymorphic signature method
 454      * cannot be overridden (e.g. MH.invokeExact(Object[])).
 455      */
 456     private boolean notOverriddenIn(Type site, Symbol sym) {
 457         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
 458             return true;
 459         else {
 460             Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
 461             return (s2 == null || s2 == sym || sym.owner == s2.owner ||
 462                     !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
 463         }
 464     }
 465     //where
 466         /** Is given protected symbol accessible if it is selected from given site
 467          *  and the selection takes place in given class?
 468          *  @param sym     The symbol with protected access
 469          *  @param c       The class where the access takes place
 470          *  @site          The type of the qualifier
 471          */
 472         private
 473         boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
 474             Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
 475             while (c != null &amp;&amp;
 476                    !(c.isSubClass(sym.owner, types) &amp;&amp;
 477                      (c.flags() &amp; INTERFACE) == 0 &amp;&amp;
 478                      // In JLS 2e 6.6.2.1, the subclass restriction applies
 479                      // only to instance fields and methods -- types are excluded
 480                      // regardless of whether they are declared &#39;static&#39; or not.
 481                      ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
 482                 c = c.owner.enclClass();
 483             return c != null;
 484         }
 485 
 486     /**
 487      * Performs a recursive scan of a type looking for accessibility problems
 488      * from current attribution environment
 489      */
 490     void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
 491         accessibilityChecker.visit(t, env);
 492     }
 493 
 494     /**
 495      * Accessibility type-visitor
 496      */
 497     Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =
 498             new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {
 499 
 500         void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {
 501             for (Type t : ts) {
 502                 visit(t, env);
 503             }
 504         }
 505 
 506         public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
 507             return null;
 508         }
 509 
 510         @Override
 511         public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
 512             visit(t.elemtype, env);
 513             return null;
 514         }
 515 
 516         @Override
 517         public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
 518             visit(t.getTypeArguments(), env);
 519             if (!isAccessible(env, t, true)) {
 520                 accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
 521             }
 522             return null;
 523         }
 524 
 525         @Override
 526         public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
 527             visit(t.type, env);
 528             return null;
 529         }
 530 
 531         @Override
 532         public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
 533             visit(t.getParameterTypes(), env);
 534             visit(t.getReturnType(), env);
 535             visit(t.getThrownTypes(), env);
 536             return null;
 537         }
 538     };
 539 
 540     /** Try to instantiate the type of a method so that it fits
 541      *  given type arguments and argument types. If successful, return
 542      *  the method&#39;s instantiated type, else return null.
 543      *  The instantiation will take into account an additional leading
 544      *  formal parameter if the method is an instance method seen as a member
 545      *  of an under determined site. In this case, we treat site as an additional
 546      *  parameter and the parameters of the class containing the method as
 547      *  additional type variables that get instantiated.
 548      *
 549      *  @param env         The current environment
 550      *  @param site        The type of which the method is a member.
 551      *  @param m           The method symbol.
 552      *  @param argtypes    The invocation&#39;s given value arguments.
 553      *  @param typeargtypes    The invocation&#39;s given type arguments.
 554      *  @param allowBoxing Allow boxing conversions of arguments.
 555      *  @param useVarargs Box trailing arguments into an array for varargs.
 556      */
 557     Type rawInstantiate(Env&lt;AttrContext&gt; env,
 558                         Type site,
 559                         Symbol m,
 560                         ResultInfo resultInfo,
 561                         List&lt;Type&gt; argtypes,
 562                         List&lt;Type&gt; typeargtypes,
 563                         boolean allowBoxing,
 564                         boolean useVarargs,
 565                         Warner warn) throws Infer.InferenceException {
 566         Type mt = types.memberType(site, m);
 567         // tvars is the list of formal type variables for which type arguments
 568         // need to inferred.
 569         List&lt;Type&gt; tvars = List.nil();
 570         if (typeargtypes == null) typeargtypes = List.nil();
 571         if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 572             // This is not a polymorphic method, but typeargs are supplied
 573             // which is fine, see JLS 15.12.2.1
 574         } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 575             ForAll pmt = (ForAll) mt;
 576             if (typeargtypes.length() != pmt.tvars.length())
 577                  // not enough args
 578                 throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
 579             // Check type arguments are within bounds
 580             List&lt;Type&gt; formals = pmt.tvars;
 581             List&lt;Type&gt; actuals = typeargtypes;
 582             while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
 583                 List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),
 584                                                 pmt.tvars, typeargtypes);
 585                 for (; bounds.nonEmpty(); bounds = bounds.tail) {
 586                     if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {
 587                         throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));
 588                     }
 589                 }
 590                 formals = formals.tail;
 591                 actuals = actuals.tail;
 592             }
 593             mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
 594         } else if (mt.hasTag(FORALL)) {
 595             ForAll pmt = (ForAll) mt;
 596             List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
 597             tvars = tvars.appendList(tvars1);
 598             mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
 599         }
 600 
 601         // find out whether we need to go the slow route via infer
 602         boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
 603         for (List&lt;Type&gt; l = argtypes;
 604              l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
 605              l = l.tail) {
 606             if (l.head.hasTag(FORALL)) instNeeded = true;
 607         }
 608 
 609         if (instNeeded) {
 610             return infer.instantiateMethod(env,
 611                                     tvars,
 612                                     (MethodType)mt,
 613                                     resultInfo,
 614                                     (MethodSymbol)m,
 615                                     argtypes,
 616                                     allowBoxing,
 617                                     useVarargs,
 618                                     currentResolutionContext,
 619                                     warn);
 620         }
 621 
 622         DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
 623         currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
 624                                 argtypes, mt.getParameterTypes(), warn);
 625         dc.complete();
 626         return mt;
 627     }
 628 
 629     Type checkMethod(Env&lt;AttrContext&gt; env,
 630                      Type site,
 631                      Symbol m,
 632                      ResultInfo resultInfo,
 633                      List&lt;Type&gt; argtypes,
 634                      List&lt;Type&gt; typeargtypes,
 635                      Warner warn) {
 636         MethodResolutionContext prevContext = currentResolutionContext;
 637         try {
 638             currentResolutionContext = new MethodResolutionContext();
 639             currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
 640                     AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
 641             if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
 642                 //method/constructor references need special check class
 643                 //to handle inference variables in &#39;argtypes&#39; (might happen
 644                 //during an unsticking round)
 645                 currentResolutionContext.methodCheck =
 646                         new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
 647             }
 648             MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
 649             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 650                     step.isBoxingRequired(), step.isVarargsRequired(), warn);
 651         }
 652         finally {
 653             currentResolutionContext = prevContext;
 654         }
 655     }
 656 
 657     /** Same but returns null instead throwing a NoInstanceException
 658      */
 659     Type instantiate(Env&lt;AttrContext&gt; env,
 660                      Type site,
 661                      Symbol m,
 662                      ResultInfo resultInfo,
 663                      List&lt;Type&gt; argtypes,
 664                      List&lt;Type&gt; typeargtypes,
 665                      boolean allowBoxing,
 666                      boolean useVarargs,
 667                      Warner warn) {
 668         try {
 669             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 670                                   allowBoxing, useVarargs, warn);
 671         } catch (InapplicableMethodException ex) {
 672             return null;
 673         }
 674     }
 675 
 676     /**
 677      * This interface defines an entry point that should be used to perform a
 678      * method check. A method check usually consist in determining as to whether
 679      * a set of types (actuals) is compatible with another set of types (formals).
 680      * Since the notion of compatibility can vary depending on the circumstances,
 681      * this interfaces allows to easily add new pluggable method check routines.
 682      */
 683     interface MethodCheck {
 684         /**
 685          * Main method check routine. A method check usually consist in determining
 686          * as to whether a set of types (actuals) is compatible with another set of
 687          * types (formals). If an incompatibility is found, an unchecked exception
 688          * is assumed to be thrown.
 689          */
 690         void argumentsAcceptable(Env&lt;AttrContext&gt; env,
 691                                 DeferredAttrContext deferredAttrContext,
 692                                 List&lt;Type&gt; argtypes,
 693                                 List&lt;Type&gt; formals,
 694                                 Warner warn);
 695 
 696         /**
 697          * Retrieve the method check object that will be used during a
 698          * most specific check.
 699          */
 700         MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
 701     }
 702 
 703     /**
 704      * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
 705      */
 706     enum MethodCheckDiag {
 707         /**
 708          * Actuals and formals differs in length.
 709          */
 710         ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
 711         /**
 712          * An actual is incompatible with a formal.
 713          */
 714         ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
 715         /**
 716          * An actual is incompatible with the varargs element type.
 717          */
 718         VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
 719         /**
 720          * The varargs element type is inaccessible.
 721          */
 722         INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
 723 
 724         final String basicKey;
 725         final String inferKey;
 726 
 727         MethodCheckDiag(String basicKey, String inferKey) {
 728             this.basicKey = basicKey;
 729             this.inferKey = inferKey;
 730         }
 731 
 732         String regex() {
 733             return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);
 734         }
 735     }
 736 
 737     /**
 738      * Dummy method check object. All methods are deemed applicable, regardless
 739      * of their formal parameter types.
 740      */
 741     MethodCheck nilMethodCheck = new MethodCheck() {
 742         public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {
 743             //do nothing - method always applicable regardless of actuals
 744         }
 745 
 746         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 747             return this;
 748         }
 749     };
 750 
 751     /**
 752      * Base class for &#39;real&#39; method checks. The class defines the logic for
 753      * iterating through formals and actuals and provides and entry point
 754      * that can be used by subclasses in order to define the actual check logic.
 755      */
 756     abstract class AbstractMethodCheck implements MethodCheck {
 757         @Override
 758         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 759                                     DeferredAttrContext deferredAttrContext,
 760                                     List&lt;Type&gt; argtypes,
 761                                     List&lt;Type&gt; formals,
 762                                     Warner warn) {
 763             //should we expand formals?
 764             boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
 765             JCTree callTree = treeForDiagnostics(env);
 766             List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
 767 
 768             //inference context used during this method check
 769             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
 770 
 771             Type varargsFormal = useVarargs ? formals.last() : null;
 772 
 773             if (varargsFormal == null &amp;&amp;
 774                     argtypes.size() != formals.size()) {
 775                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 776             }
 777 
 778             while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
 779                 DiagnosticPosition pos = trees != null ? trees.head : null;
 780                 checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);
 781                 argtypes = argtypes.tail;
 782                 formals = formals.tail;
 783                 trees = trees != null ? trees.tail : trees;
 784             }
 785 
 786             if (formals.head != varargsFormal) {
 787                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 788             }
 789 
 790             if (useVarargs) {
 791                 //note: if applicability check is triggered by most specific test,
 792                 //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
 793                 final Type elt = types.elemtype(varargsFormal);
 794                 while (argtypes.nonEmpty()) {
 795                     DiagnosticPosition pos = trees != null ? trees.head : null;
 796                     checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
 797                     argtypes = argtypes.tail;
 798                     trees = trees != null ? trees.tail : trees;
 799                 }
 800             }
 801         }
 802 
 803             // where
 804             private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
 805                 return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;
 806             }
 807 
 808         /**
 809          * Does the actual argument conforms to the corresponding formal?
 810          */
 811         abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);
 812 
 813         protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
 814             boolean inferDiag = inferenceContext != infer.emptyContext;
 815             if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
 816                 Object[] args2 = new Object[args.length + 1];
 817                 System.arraycopy(args, 0, args2, 1, args.length);
 818                 args2[0] = inferenceContext.inferenceVars();
 819                 args = args2;
 820             }
 821             String key = inferDiag ? diag.inferKey : diag.basicKey;
 822             throw inferDiag ?
 823                 infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
 824                 methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
 825         }
 826 
 827         /**
 828          * To eliminate the overhead associated with allocating an exception object in such an
 829          * hot execution path, we use flyweight pattern - and share the same exception instance
 830          * across multiple method check failures.
 831          */
 832         class SharedInapplicableMethodException extends InapplicableMethodException {
 833             private static final long serialVersionUID = 0;
 834 
 835             SharedInapplicableMethodException() {
 836                 super(null);
 837             }
 838 
 839             SharedInapplicableMethodException setMessage(JCDiagnostic details) {
 840                 this.diagnostic = details;
 841                 return this;
 842             }
 843         }
 844 
 845         SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
 846 
 847         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 848             return nilMethodCheck;
 849         }
 850 
 851     }
 852 
 853     /**
 854      * Arity-based method check. A method is applicable if the number of actuals
 855      * supplied conforms to the method signature.
 856      */
 857     MethodCheck arityMethodCheck = new AbstractMethodCheck() {
 858         @Override
 859         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 860             //do nothing - actual always compatible to formals
 861         }
 862 
 863         @Override
 864         public String toString() {
 865             return &quot;arityMethodCheck&quot;;
 866         }
 867     };
 868 
 869     /**
 870      * Main method applicability routine. Given a list of actual types A,
 871      * a list of formal types F, determines whether the types in A are
 872      * compatible (by method invocation conversion) with the types in F.
 873      *
 874      * Since this routine is shared between overload resolution and method
 875      * type-inference, a (possibly empty) inference context is used to convert
 876      * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
 877      * check so that constraints can be propagated and collected.
 878      *
 879      * Moreover, if one or more types in A is a deferred type, this routine uses
 880      * DeferredAttr in order to perform deferred attribution. If one or more actual
 881      * deferred types are stuck, they are placed in a queue and revisited later
 882      * after the remainder of the arguments have been seen. If this is not sufficient
 883      * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
 884      *
 885      * A method check handler (see above) is used in order to report errors.
 886      */
 887     MethodCheck resolveMethodCheck = new AbstractMethodCheck() {
 888 
 889         @Override
 890         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 891             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 892             mresult.check(pos, actual);
 893         }
 894 
 895         @Override
 896         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 897                                     DeferredAttrContext deferredAttrContext,
 898                                     List&lt;Type&gt; argtypes,
 899                                     List&lt;Type&gt; formals,
 900                                     Warner warn) {
 901             super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
 902             // should we check varargs element type accessibility?
 903             if (deferredAttrContext.phase.isVarargsRequired()) {
 904                 if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
 905                     varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
 906                 }
 907             }
 908         }
 909 
 910         /**
 911          * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
 912          * varargs element type of either the method invocation type signature (after inference completes)
 913          * or the method declaration signature (before inference completes).
 914          */
 915         private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {
 916             if (inferenceContext.free(t)) {
 917                 inferenceContext.addFreeTypeListener(List.of(t),
 918                         solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
 919             } else {
 920                 if (!isAccessible(env, types.erasure(t))) {
 921                     Symbol location = env.enclClass.sym;
 922                     reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
 923                 }
 924             }
 925         }
 926 
 927         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 928                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 929             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 930                 MethodCheckDiag methodDiag = varargsCheck ?
 931                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 932 
 933                 @Override
 934                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 935                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 936                 }
 937             };
 938             return new MethodResultInfo(to, checkContext);
 939         }
 940 
 941         @Override
 942         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 943             return new MostSpecificCheck(actuals);
 944         }
 945 
 946         @Override
 947         public String toString() {
 948             return &quot;resolveMethodCheck&quot;;
 949         }
 950     };
 951 
 952     /**
 953      * This class handles method reference applicability checks; since during
 954      * these checks it&#39;s sometime possible to have inference variables on
 955      * the actual argument types list, the method applicability check must be
 956      * extended so that inference variables are &#39;opened&#39; as needed.
 957      */
 958     class MethodReferenceCheck extends AbstractMethodCheck {
 959 
 960         InferenceContext pendingInferenceContext;
 961 
 962         MethodReferenceCheck(InferenceContext pendingInferenceContext) {
 963             this.pendingInferenceContext = pendingInferenceContext;
 964         }
 965 
 966         @Override
 967         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 968             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 969             mresult.check(pos, actual);
 970         }
 971 
 972         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 973                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 974             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 975                 MethodCheckDiag methodDiag = varargsCheck ?
 976                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 977 
 978                 @Override
 979                 public boolean compatible(Type found, Type req, Warner warn) {
 980                     found = pendingInferenceContext.asUndetVar(found);
 981                     if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {
 982                         req = types.boxedClass(req).type;
 983                     }
 984                     return super.compatible(found, req, warn);
 985                 }
 986 
 987                 @Override
 988                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 989                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 990                 }
 991             };
 992             return new MethodResultInfo(to, checkContext);
 993         }
 994 
 995         @Override
 996         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 997             return new MostSpecificCheck(actuals);
 998         }
 999 
1000         @Override
1001         public String toString() {
1002             return &quot;MethodReferenceCheck&quot;;
1003         }
1004     }
1005 
1006     /**
1007      * Check context to be used during method applicability checks. A method check
1008      * context might contain inference variables.
1009      */
1010     abstract class MethodCheckContext implements CheckContext {
1011 
1012         boolean strict;
1013         DeferredAttrContext deferredAttrContext;
1014         Warner rsWarner;
1015 
1016         public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1017            this.strict = strict;
1018            this.deferredAttrContext = deferredAttrContext;
1019            this.rsWarner = rsWarner;
1020         }
1021 
1022         public boolean compatible(Type found, Type req, Warner warn) {
1023             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
1024             return strict ?
1025                     types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
1026                     types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
1027         }
1028 
1029         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1030             throw new InapplicableMethodException(details);
1031         }
1032 
1033         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
1034             return rsWarner;
1035         }
1036 
1037         public InferenceContext inferenceContext() {
1038             return deferredAttrContext.inferenceContext;
1039         }
1040 
1041         public DeferredAttrContext deferredAttrContext() {
1042             return deferredAttrContext;
1043         }
1044 
1045         @Override
1046         public String toString() {
1047             return &quot;MethodCheckContext&quot;;
1048         }
1049     }
1050 
1051     /**
1052      * ResultInfo class to be used during method applicability checks. Check
1053      * for deferred types goes through special path.
1054      */
1055     class MethodResultInfo extends ResultInfo {
1056 
1057         public MethodResultInfo(Type pt, CheckContext checkContext) {
1058             attr.super(KindSelector.VAL, pt, checkContext);
1059         }
1060 
1061         @Override
1062         protected Type check(DiagnosticPosition pos, Type found) {
1063             if (found.hasTag(DEFERRED)) {
1064                 DeferredType dt = (DeferredType)found;
1065                 return dt.check(this);
1066             } else {
1067                 Type uResult = U(found);
1068                 Type capturedType = pos == null || pos.getTree() == null ?
1069                         types.capture(uResult) :
1070                         checkContext.inferenceContext()
1071                             .cachedCapture(pos.getTree(), uResult, true);
1072                 return super.check(pos, chk.checkNonVoid(pos, capturedType));
1073             }
1074         }
1075 
1076         /**
1077          * javac has a long-standing &#39;simplification&#39; (see 6391995):
1078          * given an actual argument type, the method check is performed
1079          * on its upper bound. This leads to inconsistencies when an
1080          * argument type is checked against itself. For example, given
1081          * a type-variable T, it is not true that {@code U(T) &lt;: T},
1082          * so we need to guard against that.
1083          */
1084         private Type U(Type found) {
1085             return found == pt ?
1086                     found : types.cvarUpperBound(found);
1087         }
1088 
1089         @Override
1090         protected MethodResultInfo dup(Type newPt) {
1091             return new MethodResultInfo(newPt, checkContext);
1092         }
1093 
1094         @Override
1095         protected ResultInfo dup(CheckContext newContext) {
1096             return new MethodResultInfo(pt, newContext);
1097         }
1098 
1099         @Override
1100         protected ResultInfo dup(Type newPt, CheckContext newContext) {
1101             return new MethodResultInfo(newPt, newContext);
1102         }
1103     }
1104 
1105     /**
1106      * Most specific method applicability routine. Given a list of actual types A,
1107      * a list of formal types F1, and a list of formal types F2, the routine determines
1108      * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.
1109      * argument types A.
1110      */
1111     class MostSpecificCheck implements MethodCheck {
1112 
1113         List&lt;Type&gt; actuals;
1114 
1115         MostSpecificCheck(List&lt;Type&gt; actuals) {
1116             this.actuals = actuals;
1117         }
1118 
1119         @Override
1120         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
1121                                     DeferredAttrContext deferredAttrContext,
1122                                     List&lt;Type&gt; formals1,
1123                                     List&lt;Type&gt; formals2,
1124                                     Warner warn) {
1125             formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
1126             while (formals2.nonEmpty()) {
1127                 ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);
1128                 mresult.check(null, formals1.head);
1129                 formals1 = formals1.tail;
1130                 formals2 = formals2.tail;
1131                 actuals = actuals.isEmpty() ? actuals : actuals.tail;
1132             }
1133         }
1134 
1135        /**
1136         * Create a method check context to be used during the most specific applicability check
1137         */
1138         ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
1139                Warner rsWarner, Type actual) {
1140             return attr.new ResultInfo(KindSelector.VAL, to,
1141                    new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
1142         }
1143 
1144         /**
1145          * Subclass of method check context class that implements most specific
1146          * method conversion. If the actual type under analysis is a deferred type
1147          * a full blown structural analysis is carried out.
1148          */
1149         class MostSpecificCheckContext extends MethodCheckContext {
1150 
1151             Type actual;
1152 
1153             public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {
1154                 super(true, deferredAttrContext, rsWarner);
1155                 this.actual = actual;
1156             }
1157 
1158             public boolean compatible(Type found, Type req, Warner warn) {
1159                 if (allowFunctionalInterfaceMostSpecific &amp;&amp;
1160                         unrelatedFunctionalInterfaces(found, req) &amp;&amp;
1161                         (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
1162                     DeferredType dt = (DeferredType) actual;
1163                     JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
1164                     if (speculativeTree != deferredAttr.stuckTree) {
1165                         return functionalInterfaceMostSpecific(found, req, speculativeTree);
1166                     }
1167                 }
1168                 return compatibleBySubtyping(found, req);
1169             }
1170 
1171             private boolean compatibleBySubtyping(Type found, Type req) {
1172                 if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {
1173                     found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);
1174                 }
1175                 return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));
1176             }
1177 
1178             /** Whether {@code t} and {@code s} are unrelated functional interface types. */
1179             private boolean unrelatedFunctionalInterfaces(Type t, Type s) {
1180                 return types.isFunctionalInterface(t.tsym) &amp;&amp;
1181                        types.isFunctionalInterface(s.tsym) &amp;&amp;
1182                        unrelatedInterfaces(t, s);
1183             }
1184 
1185             /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/
1186             private boolean unrelatedInterfaces(Type t, Type s) {
1187                 if (t.isCompound()) {
1188                     for (Type ti : types.interfaces(t)) {
1189                         if (!unrelatedInterfaces(ti, s)) {
1190                             return false;
1191                         }
1192                     }
1193                     return true;
1194                 } else if (s.isCompound()) {
1195                     for (Type si : types.interfaces(s)) {
1196                         if (!unrelatedInterfaces(t, si)) {
1197                             return false;
1198                         }
1199                     }
1200                     return true;
1201                 } else {
1202                     return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;
1203                 }
1204             }
1205 
1206             /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1207             private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {
1208                 Type tDesc = types.findDescriptorType(types.capture(t));
1209                 Type tDescNoCapture = types.findDescriptorType(t);
1210                 Type sDesc = types.findDescriptorType(s);
1211                 final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();
1212                 final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();
1213                 final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();
1214 
1215                 // compare type parameters
1216                 if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
1217                     return false;
1218                 }
1219                 // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
1220                 List&lt;Type&gt; tIter = tTypeParams;
1221                 List&lt;Type&gt; sIter = sTypeParams;
1222                 while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
1223                     Type tBound = tIter.head.getUpperBound();
1224                     Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);
1225                     if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {
1226                         return false;
1227                     }
1228                     if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {
1229                         return false;
1230                     }
1231                     tIter = tIter.tail;
1232                     sIter = sIter.tail;
1233                 }
1234                 if (!tIter.isEmpty() || !sIter.isEmpty()) {
1235                     return false;
1236                 }
1237 
1238                 // compare parameters
1239                 List&lt;Type&gt; tParams = tDesc.getParameterTypes();
1240                 List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
1241                 List&lt;Type&gt; sParams = sDesc.getParameterTypes();
1242                 while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
1243                     Type tParam = tParams.head;
1244                     Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
1245                     Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
1246                     if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {
1247                         return false;
1248                     }
1249                     if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
1250                         return false;
1251                     }
1252                     if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
1253                         return false;
1254                     }
1255                     tParams = tParams.tail;
1256                     tParamsNoCapture = tParamsNoCapture.tail;
1257                     sParams = sParams.tail;
1258                 }
1259                 if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {
1260                     return false;
1261                 }
1262 
1263                 // compare returns
1264                 Type tRet = tDesc.getReturnType();
1265                 Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);
1266                 if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
1267                     return false;
1268                 }
1269                 MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
1270                 msc.scan(tree);
1271                 return msc.result;
1272             }
1273 
1274             /**
1275              * Tests whether one functional interface type can be considered more specific
1276              * than another unrelated functional interface type for the scanned expression.
1277              */
1278             class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
1279 
1280                 final Type tRet;
1281                 final Type sRet;
1282                 boolean result;
1283 
1284                 /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1285                 MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
1286                     this.tRet = tRet;
1287                     this.sRet = sRet;
1288                     result = true;
1289                 }
1290 
1291                 @Override
1292                 void skip(JCTree tree) {
1293                     result &amp;= false;
1294                 }
1295 
1296                 @Override
1297                 public void visitConditional(JCConditional tree) {
1298                     scan(asExpr(tree.truepart));
1299                     scan(asExpr(tree.falsepart));
1300                 }
1301 
1302                 @Override
1303                 public void visitReference(JCMemberReference tree) {
1304                     if (sRet.hasTag(VOID)) {
1305                         result &amp;= true;
1306                     } else if (tRet.hasTag(VOID)) {
1307                         result &amp;= false;
1308                     } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
1309                         boolean retValIsPrimitive =
1310                                 tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;
1311                                 tree.sym.type.getReturnType().isPrimitive();
1312                         result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1313                                   (retValIsPrimitive != sRet.isPrimitive());
1314                     } else {
1315                         result &amp;= compatibleBySubtyping(tRet, sRet);
1316                     }
1317                 }
1318 
1319                 @Override
1320                 public void visitParens(JCParens tree) {
1321                     scan(asExpr(tree.expr));
1322                 }
1323 
1324                 @Override
1325                 public void visitLambda(JCLambda tree) {
1326                     if (sRet.hasTag(VOID)) {
1327                         result &amp;= true;
1328                     } else if (tRet.hasTag(VOID)) {
1329                         result &amp;= false;
1330                     } else {
1331                         List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
1332                         if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {
1333                             for (JCExpression expr : lambdaResults) {
1334                                 result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
1335                             }
1336                         } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
1337                             for (JCExpression expr : lambdaResults) {
1338                                 boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
1339                                 result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1340                                         (retValIsPrimitive != sRet.isPrimitive());
1341                             }
1342                         } else {
1343                             result &amp;= compatibleBySubtyping(tRet, sRet);
1344                         }
1345                     }
1346                 }
1347                 //where
1348 
1349                 private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
1350                     if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1351                         return List.of(asExpr((JCExpression) lambda.body));
1352                     } else {
1353                         final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
1354                         DeferredAttr.LambdaReturnScanner lambdaScanner =
1355                                 new DeferredAttr.LambdaReturnScanner() {
1356                                     @Override
1357                                     public void visitReturn(JCReturn tree) {
1358                                         if (tree.expr != null) {
1359                                             buffer.append(asExpr(tree.expr));
1360                                         }
1361                                     }
1362                                 };
1363                         lambdaScanner.scan(lambda.body);
1364                         return buffer.toList();
1365                     }
1366                 }
1367 
1368                 private JCExpression asExpr(JCExpression expr) {
1369                     if (expr.type.hasTag(DEFERRED)) {
1370                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1371                         if (speculativeTree != deferredAttr.stuckTree) {
1372                             expr = (JCExpression)speculativeTree;
1373                         }
1374                     }
1375                     return expr;
1376                 }
1377             }
1378 
1379         }
1380 
1381         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1382             Assert.error(&quot;Cannot get here!&quot;);
1383             return null;
1384         }
1385     }
1386 
1387     public static class InapplicableMethodException extends RuntimeException {
1388         private static final long serialVersionUID = 0;
1389 
<a name="9" id="anc9"></a><span class="line-modified">1390         transient JCDiagnostic diagnostic;</span>
1391 
1392         InapplicableMethodException(JCDiagnostic diag) {
1393             this.diagnostic = diag;
1394         }
1395 
1396         public JCDiagnostic getDiagnostic() {
1397             return diagnostic;
1398         }
1399     }
1400 
1401 /* ***************************************************************************
1402  *  Symbol lookup
1403  *  the following naming conventions for arguments are used
1404  *
1405  *       env      is the environment where the symbol was mentioned
1406  *       site     is the type of which the symbol is a member
1407  *       name     is the symbol&#39;s name
1408  *                if no arguments are given
1409  *       argtypes are the value arguments, if we search for a method
1410  *
1411  *  If no symbol was found, a ResolveError detailing the problem is returned.
1412  ****************************************************************************/
1413 
1414     /** Find field. Synthetic fields are always skipped.
1415      *  @param env     The current environment.
1416      *  @param site    The original type from where the selection takes place.
1417      *  @param name    The name of the field.
1418      *  @param c       The class to search for the field. This is always
1419      *                 a superclass or implemented interface of site&#39;s class.
1420      */
1421     Symbol findField(Env&lt;AttrContext&gt; env,
1422                      Type site,
1423                      Name name,
1424                      TypeSymbol c) {
1425         while (c.type.hasTag(TYPEVAR))
1426             c = c.type.getUpperBound().tsym;
1427         Symbol bestSoFar = varNotFound;
1428         Symbol sym;
1429         for (Symbol s : c.members().getSymbolsByName(name)) {
1430             if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1431                 return isAccessible(env, site, s)
1432                     ? s : new AccessError(env, site, s);
1433             }
1434         }
1435         Type st = types.supertype(c.type);
1436         if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
1437             sym = findField(env, site, name, st.tsym);
1438             bestSoFar = bestOf(bestSoFar, sym);
1439         }
1440         for (List&lt;Type&gt; l = types.interfaces(c.type);
1441              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
1442              l = l.tail) {
1443             sym = findField(env, site, name, l.head.tsym);
1444             if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;
1445                 sym.owner != bestSoFar.owner)
1446                 bestSoFar = new AmbiguityError(bestSoFar, sym);
1447             else
1448                 bestSoFar = bestOf(bestSoFar, sym);
1449         }
1450         return bestSoFar;
1451     }
1452 
1453     /** Resolve a field identifier, throw a fatal error if not found.
1454      *  @param pos       The position to use for error reporting.
1455      *  @param env       The environment current at the method invocation.
1456      *  @param site      The type of the qualifying expression, in which
1457      *                   identifier is searched.
1458      *  @param name      The identifier&#39;s name.
1459      */
1460     public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
1461                                           Type site, Name name) {
1462         Symbol sym = findField(env, site, name, site.tsym);
1463         if (sym.kind == VAR) return (VarSymbol)sym;
1464         else throw new FatalError(
1465                  diags.fragment(Fragments.FatalErrCantLocateField(name)));
1466     }
1467 
1468     /** Find unqualified variable or field with given name.
1469      *  Synthetic fields always skipped.
1470      *  @param env     The current environment.
1471      *  @param name    The name of the variable or field.
1472      */
1473     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1474         Symbol bestSoFar = varNotFound;
1475         Env&lt;AttrContext&gt; env1 = env;
1476         boolean staticOnly = false;
1477         while (env1.outer != null) {
1478             Symbol sym = null;
1479             if (isStatic(env1)) staticOnly = true;
1480             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1481                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1482                     sym = s;
1483                     break;
1484                 }
1485             }
1486             if (sym == null) {
1487                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1488             }
1489             if (sym.exists()) {
1490                 if (staticOnly &amp;&amp;
1491                     sym.kind == VAR &amp;&amp;
<a name="10" id="anc10"></a><span class="line-modified">1492                         // if it is a field</span>
<span class="line-added">1493                         (sym.owner.kind == TYP ||</span>
<span class="line-added">1494                         // or it is a local variable but it is not declared inside of the static local type</span>
<span class="line-added">1495                         // only records so far, then error</span>
<span class="line-added">1496                         (sym.owner.kind == MTH) &amp;&amp;</span>
<span class="line-added">1497                         (env.enclClass.sym.flags() &amp; STATIC) != 0 &amp;&amp;</span>
<span class="line-added">1498                         sym.enclClass() != env.enclClass.sym) &amp;&amp;</span>
1499                     (sym.flags() &amp; STATIC) == 0)
1500                     return new StaticError(sym);
1501                 else
1502                     return sym;
1503             } else {
1504                 bestSoFar = bestOf(bestSoFar, sym);
1505             }
1506 
1507             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1508             env1 = env1.outer;
1509         }
1510 
1511         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1512         if (sym.exists())
1513             return sym;
1514         if (bestSoFar.exists())
1515             return bestSoFar;
1516 
1517         Symbol origin = null;
1518         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
1519             for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
1520                 if (currentSymbol.kind != VAR)
1521                     continue;
1522                 // invariant: sym.kind == Symbol.Kind.VAR
1523                 if (!bestSoFar.kind.isResolutionError() &amp;&amp;
1524                     currentSymbol.owner != bestSoFar.owner)
1525                     return new AmbiguityError(bestSoFar, currentSymbol);
1526                 else if (!bestSoFar.kind.betterThan(VAR)) {
1527                     origin = sc.getOrigin(currentSymbol).owner;
1528                     bestSoFar = isAccessible(env, origin.type, currentSymbol)
1529                         ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
1530                 }
1531             }
1532             if (bestSoFar.exists()) break;
1533         }
1534         if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)
1535             return bestSoFar.clone(origin);
1536         else
1537             return bestSoFar;
1538     }
1539 
1540     Warner noteWarner = new Warner();
1541 
1542     /** Select the best method for a call site among two choices.
1543      *  @param env              The current environment.
1544      *  @param site             The original type from where the
1545      *                          selection takes place.
1546      *  @param argtypes         The invocation&#39;s value arguments,
1547      *  @param typeargtypes     The invocation&#39;s type arguments,
1548      *  @param sym              Proposed new best match.
1549      *  @param bestSoFar        Previously found best match.
1550      *  @param allowBoxing Allow boxing conversions of arguments.
1551      *  @param useVarargs Box trailing arguments into an array for varargs.
1552      */
1553     @SuppressWarnings(&quot;fallthrough&quot;)
1554     Symbol selectBest(Env&lt;AttrContext&gt; env,
1555                       Type site,
1556                       List&lt;Type&gt; argtypes,
1557                       List&lt;Type&gt; typeargtypes,
1558                       Symbol sym,
1559                       Symbol bestSoFar,
1560                       boolean allowBoxing,
1561                       boolean useVarargs) {
1562         if (sym.kind == ERR ||
1563                 (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
1564                 !notOverriddenIn(site, sym)) {
1565             return bestSoFar;
1566         } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {
1567             return bestSoFar.kind.isResolutionError() ?
1568                     new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :
1569                     bestSoFar;
1570         }
1571         Assert.check(!sym.kind.isResolutionError());
1572         try {
1573             types.noWarnings.clear();
1574             Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,
1575                                allowBoxing, useVarargs, types.noWarnings);
1576             currentResolutionContext.addApplicableCandidate(sym, mt);
1577         } catch (InapplicableMethodException ex) {
1578             currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
1579             switch (bestSoFar.kind) {
1580                 case ABSENT_MTH:
1581                     return new InapplicableSymbolError(currentResolutionContext);
1582                 case WRONG_MTH:
1583                     bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
1584                 default:
1585                     return bestSoFar;
1586             }
1587         }
1588         if (!isAccessible(env, site, sym)) {
1589             return (bestSoFar.kind == ABSENT_MTH)
1590                 ? new AccessError(env, site, sym)
1591                 : bestSoFar;
1592         }
1593         return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)
1594             ? sym
1595             : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
1596     }
1597 
1598     /* Return the most specific of the two methods for a call,
1599      *  given that both are accessible and applicable.
1600      *  @param m1               A new candidate for most specific.
1601      *  @param m2               The previous most specific candidate.
1602      *  @param env              The current environment.
1603      *  @param site             The original type from where the selection
1604      *                          takes place.
1605      *  @param allowBoxing Allow boxing conversions of arguments.
1606      *  @param useVarargs Box trailing arguments into an array for varargs.
1607      */
1608     Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,
1609                         Symbol m2,
1610                         Env&lt;AttrContext&gt; env,
1611                         final Type site,
1612                         boolean useVarargs) {
1613         switch (m2.kind) {
1614         case MTH:
1615             if (m1 == m2) return m1;
1616             boolean m1SignatureMoreSpecific =
1617                     signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);
1618             boolean m2SignatureMoreSpecific =
1619                     signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
1620             if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {
1621                 Type mt1 = types.memberType(site, m1);
1622                 Type mt2 = types.memberType(site, m2);
1623                 if (!types.overrideEquivalent(mt1, mt2))
1624                     return ambiguityError(m1, m2);
1625 
1626                 // same signature; select (a) the non-bridge method, or
1627                 // (b) the one that overrides the other, or (c) the concrete
1628                 // one, or (d) merge both abstract signatures
1629                 if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
1630                     return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
1631 
1632                 if (m1.baseSymbol() == m2.baseSymbol()) {
1633                     // this is the same imported symbol which has been cloned twice.
1634                     // Return the first one (either will do).
1635                     return m1;
1636                 }
1637 
1638                 // if one overrides or hides the other, use it
1639                 TypeSymbol m1Owner = (TypeSymbol)m1.owner;
1640                 TypeSymbol m2Owner = (TypeSymbol)m2.owner;
1641                 // the two owners can never be the same if the target methods are compiled from source,
1642                 // but we need to protect against cases where the methods are defined in some classfile
1643                 // and make sure we issue an ambiguity error accordingly (by skipping the logic below).
1644                 if (m1Owner != m2Owner) {
1645                     if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
1646                         ((m1.owner.flags_field &amp; INTERFACE) == 0 ||
1647                          (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1648                         m1.overrides(m2, m1Owner, types, false))
1649                         return m1;
1650                     if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
1651                         ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
1652                          (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1653                         m2.overrides(m1, m2Owner, types, false))
1654                         return m2;
1655                 }
1656                 boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
1657                 boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
1658                 if (m1Abstract &amp;&amp; !m2Abstract) return m2;
1659                 if (m2Abstract &amp;&amp; !m1Abstract) return m1;
1660                 // both abstract or both concrete
1661                 return ambiguityError(m1, m2);
1662             }
1663             if (m1SignatureMoreSpecific) return m1;
1664             if (m2SignatureMoreSpecific) return m2;
1665             return ambiguityError(m1, m2);
1666         case AMBIGUOUS:
1667             //compare m1 to ambiguous methods in m2
1668             AmbiguityError e = (AmbiguityError)m2.baseSymbol();
1669             boolean m1MoreSpecificThanAnyAmbiguous = true;
1670             boolean allAmbiguousMoreSpecificThanM1 = true;
1671             for (Symbol s : e.ambiguousSyms) {
1672                 Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
1673                 m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
1674                 allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
1675             }
1676             if (m1MoreSpecificThanAnyAmbiguous)
1677                 return m1;
1678             //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
1679             //more specific than m1, add it as a new ambiguous method:
1680             if (!allAmbiguousMoreSpecificThanM1)
1681                 e.addAmbiguousSymbol(m1);
1682             return e;
1683         default:
1684             throw new AssertionError();
1685         }
1686     }
1687     //where
1688     private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {
1689         noteWarner.clear();
1690         int maxLength = Math.max(
1691                             Math.max(m1.type.getParameterTypes().length(), actuals.length()),
1692                             m2.type.getParameterTypes().length());
1693         MethodResolutionContext prevResolutionContext = currentResolutionContext;
1694         try {
1695             currentResolutionContext = new MethodResolutionContext();
1696             currentResolutionContext.step = prevResolutionContext.step;
1697             currentResolutionContext.methodCheck =
1698                     prevResolutionContext.methodCheck.mostSpecificCheck(actuals);
1699             Type mst = instantiate(env, site, m2, null,
1700                     adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
1701                     false, useVarargs, noteWarner);
1702             return mst != null &amp;&amp;
1703                     !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
1704         } finally {
1705             currentResolutionContext = prevResolutionContext;
1706         }
1707     }
1708 
1709     List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
1710         if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
1711             Type varargsElem = types.elemtype(args.last());
1712             if (varargsElem == null) {
1713                 Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);
1714             }
1715             List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();
1716             while (newArgs.length() &lt; length) {
1717                 newArgs = newArgs.append(newArgs.last());
1718             }
1719             return newArgs;
1720         } else {
1721             return args;
1722         }
1723     }
1724     //where
1725     Symbol ambiguityError(Symbol m1, Symbol m2) {
1726         if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {
1727             return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;
1728         } else {
1729             return new AmbiguityError(m1, m2);
1730         }
1731     }
1732 
1733     Symbol findMethodInScope(Env&lt;AttrContext&gt; env,
1734             Type site,
1735             Name name,
1736             List&lt;Type&gt; argtypes,
1737             List&lt;Type&gt; typeargtypes,
1738             Scope sc,
1739             Symbol bestSoFar,
1740             boolean allowBoxing,
1741             boolean useVarargs,
1742             boolean abstractok) {
1743         for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
1744             bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
1745                     bestSoFar, allowBoxing, useVarargs);
1746         }
1747         return bestSoFar;
1748     }
1749     //where
1750         class LookupFilter implements Filter&lt;Symbol&gt; {
1751 
1752             boolean abstractOk;
1753 
1754             LookupFilter(boolean abstractOk) {
1755                 this.abstractOk = abstractOk;
1756             }
1757 
1758             public boolean accepts(Symbol s) {
1759                 long flags = s.flags();
1760                 return s.kind == MTH &amp;&amp;
1761                         (flags &amp; SYNTHETIC) == 0 &amp;&amp;
1762                         (abstractOk ||
1763                         (flags &amp; DEFAULT) != 0 ||
1764                         (flags &amp; ABSTRACT) == 0);
1765             }
1766         }
1767 
1768     /** Find best qualified method matching given name, type and value
1769      *  arguments.
1770      *  @param env       The current environment.
1771      *  @param site      The original type from where the selection
1772      *                   takes place.
1773      *  @param name      The method&#39;s name.
1774      *  @param argtypes  The method&#39;s value arguments.
1775      *  @param typeargtypes The method&#39;s type arguments
1776      *  @param allowBoxing Allow boxing conversions of arguments.
1777      *  @param useVarargs Box trailing arguments into an array for varargs.
1778      */
1779     Symbol findMethod(Env&lt;AttrContext&gt; env,
1780                       Type site,
1781                       Name name,
1782                       List&lt;Type&gt; argtypes,
1783                       List&lt;Type&gt; typeargtypes,
1784                       boolean allowBoxing,
1785                       boolean useVarargs) {
1786         Symbol bestSoFar = methodNotFound;
1787         bestSoFar = findMethod(env,
1788                           site,
1789                           name,
1790                           argtypes,
1791                           typeargtypes,
1792                           site.tsym.type,
1793                           bestSoFar,
1794                           allowBoxing,
1795                           useVarargs);
1796         return bestSoFar;
1797     }
1798     // where
1799     private Symbol findMethod(Env&lt;AttrContext&gt; env,
1800                               Type site,
1801                               Name name,
1802                               List&lt;Type&gt; argtypes,
1803                               List&lt;Type&gt; typeargtypes,
1804                               Type intype,
1805                               Symbol bestSoFar,
1806                               boolean allowBoxing,
1807                               boolean useVarargs) {
1808         @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
1809         List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
1810 
1811         InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
1812         for (TypeSymbol s : superclasses(intype)) {
1813             bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1814                     s.members(), bestSoFar, allowBoxing, useVarargs, true);
1815             if (name == names.init) return bestSoFar;
1816             iphase = (iphase == null) ? null : iphase.update(s, this);
1817             if (iphase != null) {
1818                 for (Type itype : types.interfaces(s.type)) {
1819                     itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
1820                 }
1821             }
1822         }
1823 
1824         Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;
1825                 (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
1826                 bestSoFar : methodNotFound;
1827 
1828         for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
1829             //keep searching for abstract methods
1830             for (Type itype : itypes[iphase2.ordinal()]) {
1831                 if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
1832                 if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
1833                         (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
1834                 bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1835                         itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
1836                 if (concrete != bestSoFar &amp;&amp;
1837                     concrete.kind.isValid() &amp;&amp;
1838                     bestSoFar.kind.isValid() &amp;&amp;
1839                         types.isSubSignature(concrete.type, bestSoFar.type)) {
1840                     //this is an hack - as javac does not do full membership checks
1841                     //most specific ends up comparing abstract methods that might have
1842                     //been implemented by some concrete method in a subclass and,
1843                     //because of raw override, it is possible for an abstract method
1844                     //to be more specific than the concrete method - so we need
1845                     //to explicitly call that out (see CR 6178365)
1846                     bestSoFar = concrete;
1847                 }
1848             }
1849         }
1850         return bestSoFar;
1851     }
1852 
1853     enum InterfaceLookupPhase {
1854         ABSTRACT_OK() {
1855             @Override
1856             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1857                 //We should not look for abstract methods if receiver is a concrete class
1858                 //(as concrete classes are expected to implement all abstracts coming
1859                 //from superinterfaces)
1860                 if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {
1861                     return this;
1862                 } else {
1863                     return DEFAULT_OK;
1864                 }
1865             }
1866         },
1867         DEFAULT_OK() {
1868             @Override
1869             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1870                 return this;
1871             }
1872         };
1873 
1874         abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
1875     }
1876 
1877     /**
1878      * Return an Iterable object to scan the superclasses of a given type.
1879      * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally
1880      * access more supertypes than strictly needed (as this could trigger completion
1881      * errors if some of the not-needed supertypes are missing/ill-formed).
1882      */
1883     Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {
1884         return () -&gt; new Iterator&lt;TypeSymbol&gt;() {
1885 
1886             List&lt;TypeSymbol&gt; seen = List.nil();
1887             TypeSymbol currentSym = symbolFor(intype);
1888             TypeSymbol prevSym = null;
1889 
1890             public boolean hasNext() {
1891                 if (currentSym == syms.noSymbol) {
1892                     currentSym = symbolFor(types.supertype(prevSym.type));
1893                 }
1894                 return currentSym != null;
1895             }
1896 
1897             public TypeSymbol next() {
1898                 prevSym = currentSym;
1899                 currentSym = syms.noSymbol;
1900                 Assert.check(prevSym != null || prevSym != syms.noSymbol);
1901                 return prevSym;
1902             }
1903 
1904             public void remove() {
1905                 throw new UnsupportedOperationException();
1906             }
1907 
1908             TypeSymbol symbolFor(Type t) {
1909                 if (!t.hasTag(CLASS) &amp;&amp;
1910                         !t.hasTag(TYPEVAR)) {
1911                     return null;
1912                 }
1913                 t = types.skipTypeVars(t, false);
1914                 if (seen.contains(t.tsym)) {
1915                     //degenerate case in which we have a circular
1916                     //class hierarchy - because of ill-formed classfiles
1917                     return null;
1918                 }
1919                 seen = seen.prepend(t.tsym);
1920                 return t.tsym;
1921             }
1922         };
1923     }
1924 
1925     /** Find unqualified method matching given name, type and value arguments.
1926      *  @param env       The current environment.
1927      *  @param name      The method&#39;s name.
1928      *  @param argtypes  The method&#39;s value arguments.
1929      *  @param typeargtypes  The method&#39;s type arguments.
1930      *  @param allowBoxing Allow boxing conversions of arguments.
1931      *  @param useVarargs Box trailing arguments into an array for varargs.
1932      */
1933     Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
1934                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
1935                    boolean allowBoxing, boolean useVarargs) {
1936         Symbol bestSoFar = methodNotFound;
1937         Env&lt;AttrContext&gt; env1 = env;
1938         boolean staticOnly = false;
1939         while (env1.outer != null) {
1940             if (isStatic(env1)) staticOnly = true;
1941             Assert.check(env1.info.preferredTreeForDiagnostics == null);
1942             env1.info.preferredTreeForDiagnostics = env.tree;
1943             try {
1944                 Symbol sym = findMethod(
1945                     env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,
1946                     allowBoxing, useVarargs);
1947                 if (sym.exists()) {
1948                     if (staticOnly &amp;&amp;
1949                         sym.kind == MTH &amp;&amp;
1950                         sym.owner.kind == TYP &amp;&amp;
1951                         (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
1952                     else return sym;
1953                 } else {
1954                     bestSoFar = bestOf(bestSoFar, sym);
1955                 }
1956             } finally {
1957                 env1.info.preferredTreeForDiagnostics = null;
1958             }
1959             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1960             env1 = env1.outer;
1961         }
1962 
1963         Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
1964                                 typeargtypes, allowBoxing, useVarargs);
1965         if (sym.exists())
1966             return sym;
1967 
1968         for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {
1969             Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
1970             if (currentSym.kind == MTH) {
1971                 if (currentSym.owner.type != origin.type)
1972                     currentSym = currentSym.clone(origin);
1973                 if (!isAccessible(env, origin.type, currentSym))
1974                     currentSym = new AccessError(env, origin.type, currentSym);
1975                 bestSoFar = selectBest(env, origin.type,
1976                                        argtypes, typeargtypes,
1977                                        currentSym, bestSoFar,
1978                                        allowBoxing, useVarargs);
1979             }
1980         }
1981         if (bestSoFar.exists())
1982             return bestSoFar;
1983 
1984         for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
1985             Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;
1986             if (currentSym.kind == MTH) {
1987                 if (currentSym.owner.type != origin.type)
1988                     currentSym = currentSym.clone(origin);
1989                 if (!isAccessible(env, origin.type, currentSym))
1990                     currentSym = new AccessError(env, origin.type, currentSym);
1991                 bestSoFar = selectBest(env, origin.type,
1992                                        argtypes, typeargtypes,
1993                                        currentSym, bestSoFar,
1994                                        allowBoxing, useVarargs);
1995             }
1996         }
1997         return bestSoFar;
1998     }
1999 
2000     /** Load toplevel or member class with given fully qualified name and
2001      *  verify that it is accessible.
2002      *  @param env       The current environment.
2003      *  @param name      The fully qualified name of the class to be loaded.
2004      */
2005     Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
2006         try {
2007             ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
2008             return isAccessible(env, c) ? c : new AccessError(env, null, c);
2009         } catch (ClassFinder.BadClassFile err) {
2010             return new BadClassFileError(err);
2011         } catch (CompletionFailure ex) {
2012             Symbol candidate = recoveryLoadClass.loadClass(env, name);
2013 
2014             if (candidate != null) {
2015                 return candidate;
2016             }
2017 
2018             return typeNotFound;
2019         }
2020     }
2021 
2022     public interface RecoveryLoadClass {
2023         Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);
2024     }
2025 
2026     private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
2027 
2028     private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
2029         @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {
2030             List&lt;Name&gt; candidates = Convert.classCandidates(name);
2031             return lookupInvisibleSymbol(env, name,
2032                                          n -&gt; () -&gt; createCompoundIterator(candidates,
2033                                                                            c -&gt; syms.getClassesForName(c)
2034                                                                                     .iterator()),
2035                                          (ms, n) -&gt; {
2036                 for (Name candidate : candidates) {
2037                     try {
2038                         return finder.loadClass(ms, candidate);
2039                     } catch (CompletionFailure cf) {
2040                         //ignore
2041                     }
2042                 }
2043                 return null;
2044             }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
2045         }
2046     };
2047 
2048     private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {
2049         Scope importScope = env.toplevel.namedImportScope;
2050         Symbol existing = importScope.findFirst(Convert.shortName(name),
2051                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2052 
2053         if (existing != null) {
2054             return new InvisibleSymbolError(env, true, existing);
2055         }
2056         return null;
2057     };
2058 
2059     private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
2060         Scope importScope = env.toplevel.starImportScope;
2061         Symbol existing = importScope.findFirst(Convert.shortName(name),
2062                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2063 
2064         if (existing != null) {
2065             try {
2066                 existing = finder.loadClass(existing.packge().modle, name);
2067 
2068                 return new InvisibleSymbolError(env, true, existing);
2069             } catch (CompletionFailure cf) {
2070                 //ignore
2071             }
2072         }
2073 
2074         return null;
2075     };
2076 
2077     Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {
2078         PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);
2079 
2080         if (allowModules &amp;&amp; isImportOnDemand(env, name)) {
2081             if (pack.members().isEmpty()) {
2082                 return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {
2083                     sym.complete();
2084                     return !sym.members().isEmpty();
2085                 }, pack);
2086             }
2087         }
2088 
2089         return pack;
2090     }
2091 
2092     private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {
2093         if (!env.tree.hasTag(IMPORT))
2094             return false;
2095 
2096         JCTree qualid = ((JCImport) env.tree).qualid;
2097 
2098         if (!qualid.hasTag(SELECT))
2099             return false;
2100 
2101         if (TreeInfo.name(qualid) != names.asterisk)
2102             return false;
2103 
2104         return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
2105     }
2106 
2107     private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
2108                                                             Name name,
2109                                                             Function&lt;Name, Iterable&lt;S&gt;&gt; get,
2110                                                             BiFunction&lt;ModuleSymbol, Name, S&gt; load,
2111                                                             Predicate&lt;S&gt; validate,
2112                                                             Symbol defaultResult) {
2113         //even if a class/package cannot be found in the current module and among packages in modules
2114         //it depends on that are exported for any or this module, the class/package may exist internally
2115         //in some of these modules, or may exist in a module on which this module does not depend.
2116         //Provide better diagnostic in such cases by looking for the class in any module:
2117         Iterable&lt;? extends S&gt; candidates = get.apply(name);
2118 
2119         for (S sym : candidates) {
2120             if (validate.test(sym))
2121                 return createInvisibleSymbolError(env, sym);
2122         }
2123 
2124         Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
2125 
2126         recoverableModules.add(syms.unnamedModule);
2127         recoverableModules.remove(env.toplevel.modle);
2128 
2129         for (ModuleSymbol ms : recoverableModules) {
2130             //avoid overly eager completing classes from source-based modules, as those
2131             //may not be completable with the current compiler settings:
2132             if (ms.sourceLocation == null) {
2133                 if (ms.classLocation == null) {
2134                     ms = moduleFinder.findModule(ms);
2135                 }
2136 
2137                 if (ms.kind != ERR) {
2138                     S sym = load.apply(ms, name);
2139 
2140                     if (sym != null &amp;&amp; validate.test(sym)) {
2141                         return createInvisibleSymbolError(env, sym);
2142                     }
2143                 }
2144             }
2145         }
2146 
2147         return defaultResult;
2148     }
2149 
2150     private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {
2151         if (symbolPackageVisible(env, sym)) {
2152             return new AccessError(env, null, sym);
2153         } else {
2154             return new InvisibleSymbolError(env, false, sym);
2155         }
2156     }
2157 
2158     private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {
2159         ModuleSymbol envMod = env.toplevel.modle;
2160         PackageSymbol symPack = sym.packge();
2161         return envMod == symPack.modle ||
2162                envMod.visiblePackages.containsKey(symPack.fullname);
2163     }
2164 
2165     /**
2166      * Find a type declared in a scope (not inherited).  Return null
2167      * if none is found.
2168      *  @param env       The current environment.
2169      *  @param site      The original type from where the selection takes
2170      *                   place.
2171      *  @param name      The type&#39;s name.
2172      *  @param c         The class to search for the member type. This is
2173      *                   always a superclass or implemented interface of
2174      *                   site&#39;s class.
2175      */
2176     Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,
2177                                    Type site,
2178                                    Name name,
2179                                    TypeSymbol c) {
2180         for (Symbol sym : c.members().getSymbolsByName(name)) {
2181             if (sym.kind == TYP) {
2182                 return isAccessible(env, site, sym)
2183                     ? sym
2184                     : new AccessError(env, site, sym);
2185             }
2186         }
2187         return typeNotFound;
2188     }
2189 
2190     /** Find a member type inherited from a superclass or interface.
2191      *  @param env       The current environment.
2192      *  @param site      The original type from where the selection takes
2193      *                   place.
2194      *  @param name      The type&#39;s name.
2195      *  @param c         The class to search for the member type. This is
2196      *                   always a superclass or implemented interface of
2197      *                   site&#39;s class.
2198      */
2199     Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
2200                                    Type site,
2201                                    Name name,
2202                                    TypeSymbol c) {
2203         Symbol bestSoFar = typeNotFound;
2204         Symbol sym;
2205         Type st = types.supertype(c.type);
2206         if (st != null &amp;&amp; st.hasTag(CLASS)) {
2207             sym = findMemberType(env, site, name, st.tsym);
2208             bestSoFar = bestOf(bestSoFar, sym);
2209         }
2210         for (List&lt;Type&gt; l = types.interfaces(c.type);
2211              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
2212              l = l.tail) {
2213             sym = findMemberType(env, site, name, l.head.tsym);
2214             if (!bestSoFar.kind.isResolutionError() &amp;&amp;
2215                 !sym.kind.isResolutionError() &amp;&amp;
2216                 sym.owner != bestSoFar.owner)
2217                 bestSoFar = new AmbiguityError(bestSoFar, sym);
2218             else
2219                 bestSoFar = bestOf(bestSoFar, sym);
2220         }
2221         return bestSoFar;
2222     }
2223 
2224     /** Find qualified member type.
2225      *  @param env       The current environment.
2226      *  @param site      The original type from where the selection takes
2227      *                   place.
2228      *  @param name      The type&#39;s name.
2229      *  @param c         The class to search for the member type. This is
2230      *                   always a superclass or implemented interface of
2231      *                   site&#39;s class.
2232      */
2233     Symbol findMemberType(Env&lt;AttrContext&gt; env,
2234                           Type site,
2235                           Name name,
2236                           TypeSymbol c) {
2237         Symbol sym = findImmediateMemberType(env, site, name, c);
2238 
2239         if (sym != typeNotFound)
2240             return sym;
2241 
2242         return findInheritedMemberType(env, site, name, c);
2243 
2244     }
2245 
2246     /** Find a global type in given scope and load corresponding class.
2247      *  @param env       The current environment.
2248      *  @param scope     The scope in which to look for the type.
2249      *  @param name      The type&#39;s name.
2250      */
2251     Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
2252         Symbol bestSoFar = typeNotFound;
2253         for (Symbol s : scope.getSymbolsByName(name)) {
2254             Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
2255             if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
2256                 bestSoFar != sym)
2257                 return new AmbiguityError(bestSoFar, sym);
2258             else
2259                 bestSoFar = bestOf(bestSoFar, sym);
2260         }
2261         return bestSoFar;
2262     }
2263 
2264     Symbol findTypeVar(Env&lt;AttrContext&gt; env, Name name, boolean staticOnly) {
2265         for (Symbol sym : env.info.scope.getSymbolsByName(name)) {
2266             if (sym.kind == TYP) {
2267                 if (staticOnly &amp;&amp;
2268                     sym.type.hasTag(TYPEVAR) &amp;&amp;
2269                     sym.owner.kind == TYP)
2270                     return new StaticError(sym);
2271                 return sym;
2272             }
2273         }
2274         return typeNotFound;
2275     }
2276 
2277     /** Find an unqualified type symbol.
2278      *  @param env       The current environment.
2279      *  @param name      The type&#39;s name.
2280      */
2281     Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
2282         if (name == names.empty)
2283             return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types
2284         Symbol bestSoFar = typeNotFound;
2285         Symbol sym;
2286         boolean staticOnly = false;
2287         for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
2288             if (isStatic(env1)) staticOnly = true;
2289             // First, look for a type variable and the first member type
2290             final Symbol tyvar = findTypeVar(env1, name, staticOnly);
2291             sym = findImmediateMemberType(env1, env1.enclClass.sym.type,
2292                                           name, env1.enclClass.sym);
2293 
2294             // Return the type variable if we have it, and have no
2295             // immediate member, OR the type variable is for a method.
2296             if (tyvar != typeNotFound) {
2297                 if (env.baseClause || sym == typeNotFound ||
2298                     (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
2299                      tyvar.owner.kind == MTH)) {
2300                     return tyvar;
2301                 }
2302             }
2303 
2304             // If the environment is a class def, finish up,
2305             // otherwise, do the entire findMemberType
2306             if (sym == typeNotFound)
2307                 sym = findInheritedMemberType(env1, env1.enclClass.sym.type,
2308                                               name, env1.enclClass.sym);
2309 
2310             if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
2311                 sym.type.hasTag(CLASS) &amp;&amp;
2312                 sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
2313                 env1.enclClass.sym.type.isParameterized() &amp;&amp;
2314                 sym.type.getEnclosingType().isParameterized())
2315                 return new StaticError(sym);
2316             else if (sym.exists()) return sym;
2317             else bestSoFar = bestOf(bestSoFar, sym);
2318 
2319             JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
2320             if ((encl.sym.flags() &amp; STATIC) != 0)
2321                 staticOnly = true;
2322         }
2323 
2324         if (!env.tree.hasTag(IMPORT)) {
2325             sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
2326             if (sym.exists()) return sym;
2327             else bestSoFar = bestOf(bestSoFar, sym);
2328 
2329             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2330             if (sym.exists()) return sym;
2331             else bestSoFar = bestOf(bestSoFar, sym);
2332 
2333             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2334             if (sym.exists()) return sym;
2335             else bestSoFar = bestOf(bestSoFar, sym);
2336 
2337             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2338             if (sym.exists()) return sym;
2339             else bestSoFar = bestOf(bestSoFar, sym);
2340         }
2341 
2342         return bestSoFar;
2343     }
2344 
2345     /** Find an unqualified identifier which matches a specified kind set.
<a name="11" id="anc11"></a><span class="line-added">2346      *  @param pos       position on which report warnings, if any;</span>
<span class="line-added">2347      *                   null warnings should not be reported</span>
2348      *  @param env       The current environment.
2349      *  @param name      The identifier&#39;s name.
2350      *  @param kind      Indicates the possible symbol kinds
2351      *                   (a subset of VAL, TYP, PCK).
2352      */
<a name="12" id="anc12"></a><span class="line-modified">2353     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {</span>
<span class="line-modified">2354         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);</span>
2355     }
2356 
2357     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2358         Symbol bestSoFar = typeNotFound;
2359         Symbol sym;
2360 
2361         if (kind.contains(KindSelector.VAL)) {
2362             sym = findVar(env, name);
2363             if (sym.exists()) return sym;
2364             else bestSoFar = bestOf(bestSoFar, sym);
2365         }
2366 
2367         if (kind.contains(KindSelector.TYP)) {
2368             sym = findType(env, name);
2369 
2370             if (sym.exists()) return sym;
2371             else bestSoFar = bestOf(bestSoFar, sym);
2372         }
2373 
2374         if (kind.contains(KindSelector.PCK))
2375             return lookupPackage(env, name);
2376         else return bestSoFar;
2377     }
2378 
2379     /** Find an identifier in a package which matches a specified kind set.
<a name="13" id="anc13"></a><span class="line-added">2380      *  @param pos       position on which report warnings, if any;</span>
<span class="line-added">2381      *                   null warnings should not be reported</span>
2382      *  @param env       The current environment.
2383      *  @param name      The identifier&#39;s name.
2384      *  @param kind      Indicates the possible symbol kinds
2385      *                   (a nonempty subset of TYP, PCK).
2386      */
<a name="14" id="anc14"></a><span class="line-modified">2387     Symbol findIdentInPackage(DiagnosticPosition pos,</span>
<span class="line-added">2388                               Env&lt;AttrContext&gt; env, TypeSymbol pck,</span>
2389                               Name name, KindSelector kind) {
<a name="15" id="anc15"></a><span class="line-modified">2390         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);</span>
2391     }
2392 
2393     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2394                               Name name, KindSelector kind) {
2395         Name fullname = TypeSymbol.formFullName(name, pck);
2396         Symbol bestSoFar = typeNotFound;
2397         if (kind.contains(KindSelector.TYP)) {
2398             RecoveryLoadClass recoveryLoadClass =
2399                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
<a name="16" id="anc16"></a><span class="line-modified">2400                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?</span>
2401                         doRecoveryLoadClass : noRecovery;
2402             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2403             if (sym.exists()) {
2404                 // don&#39;t allow programs to use flatnames
2405                 if (name == sym.name) return sym;
2406             }
2407             else bestSoFar = bestOf(bestSoFar, sym);
2408         }
2409         if (kind.contains(KindSelector.PCK)) {
2410             return lookupPackage(env, fullname);
2411         }
2412         return bestSoFar;
2413     }
2414 
2415     /** Find an identifier among the members of a given type `site&#39;.
<a name="17" id="anc17"></a><span class="line-added">2416      *  @param pos       position on which report warnings, if any;</span>
<span class="line-added">2417      *                   null warnings should not be reported</span>
2418      *  @param env       The current environment.
2419      *  @param site      The type containing the symbol to be found.
2420      *  @param name      The identifier&#39;s name.
2421      *  @param kind      Indicates the possible symbol kinds
2422      *                   (a subset of VAL, TYP).
2423      */
<a name="18" id="anc18"></a><span class="line-modified">2424     Symbol findIdentInType(DiagnosticPosition pos,</span>
<span class="line-added">2425                            Env&lt;AttrContext&gt; env, Type site,</span>
2426                            Name name, KindSelector kind) {
<a name="19" id="anc19"></a><span class="line-modified">2427         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);</span>
2428     }
2429 
2430     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2431                            Name name, KindSelector kind) {
2432         Symbol bestSoFar = typeNotFound;
2433         Symbol sym;
2434         if (kind.contains(KindSelector.VAL)) {
2435             sym = findField(env, site, name, site.tsym);
2436             if (sym.exists()) return sym;
2437             else bestSoFar = bestOf(bestSoFar, sym);
2438         }
2439 
2440         if (kind.contains(KindSelector.TYP)) {
2441             sym = findMemberType(env, site, name, site.tsym);
2442             if (sym.exists()) return sym;
2443             else bestSoFar = bestOf(bestSoFar, sym);
2444         }
2445         return bestSoFar;
2446     }
2447 
<a name="20" id="anc20"></a><span class="line-modified">2448     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {</span>
<span class="line-modified">2449         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {</span>
<span class="line-modified">2450             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {</span>
<span class="line-modified">2451                 bestSoFar = new BadRestrictedTypeError(names.var);</span>
<span class="line-added">2452             } else if (name.equals(names.yield)) {</span>
<span class="line-added">2453                 if (allowYieldStatement) {</span>
<span class="line-added">2454                     bestSoFar = new BadRestrictedTypeError(names.yield);</span>
<span class="line-added">2455                 } else if (pos != null) {</span>
<span class="line-added">2456                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));</span>
<span class="line-added">2457                 }</span>
<span class="line-added">2458             }</span>
2459         }
2460         return bestSoFar;
2461     }
2462 
2463 /* ***************************************************************************
2464  *  Access checking
2465  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2466  *  an error message in the process
2467  ****************************************************************************/
2468 
2469     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2470      *  else pass through unchanged,
2471      *  additional arguments duplicate what has been used in trying to find the
2472      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2473      *  expect misses to happen frequently.
2474      *
2475      *  @param sym       The symbol that was found, or a ResolveError.
2476      *  @param pos       The position to use for error reporting.
2477      *  @param location  The symbol the served as a context for this lookup
2478      *  @param site      The original type from where the selection took place.
2479      *  @param name      The symbol&#39;s name.
2480      *  @param qualified Did we get here through a qualified expression resolution?
2481      *  @param argtypes  The invocation&#39;s value arguments,
2482      *                   if we looked for a method.
2483      *  @param typeargtypes  The invocation&#39;s type arguments,
2484      *                   if we looked for a method.
2485      *  @param logResolveHelper helper class used to log resolve errors
2486      */
2487     Symbol accessInternal(Symbol sym,
2488                   DiagnosticPosition pos,
2489                   Symbol location,
2490                   Type site,
2491                   Name name,
2492                   boolean qualified,
2493                   List&lt;Type&gt; argtypes,
2494                   List&lt;Type&gt; typeargtypes,
2495                   LogResolveHelper logResolveHelper) {
2496         if (sym.kind.isResolutionError()) {
2497             ResolveError errSym = (ResolveError)sym.baseSymbol();
2498             sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
2499             argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
2500             if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {
2501                 logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);
2502             }
2503         }
2504         return sym;
2505     }
2506 
2507     /**
2508      * Variant of the generalized access routine, to be used for generating method
2509      * resolution diagnostics
2510      */
2511     Symbol accessMethod(Symbol sym,
2512                   DiagnosticPosition pos,
2513                   Symbol location,
2514                   Type site,
2515                   Name name,
2516                   boolean qualified,
2517                   List&lt;Type&gt; argtypes,
2518                   List&lt;Type&gt; typeargtypes) {
2519         return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
2520     }
2521 
2522     /** Same as original accessMethod(), but without location.
2523      */
2524     Symbol accessMethod(Symbol sym,
2525                   DiagnosticPosition pos,
2526                   Type site,
2527                   Name name,
2528                   boolean qualified,
2529                   List&lt;Type&gt; argtypes,
2530                   List&lt;Type&gt; typeargtypes) {
2531         return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);
2532     }
2533 
2534     /**
2535      * Variant of the generalized access routine, to be used for generating variable,
2536      * type resolution diagnostics
2537      */
2538     Symbol accessBase(Symbol sym,
2539                   DiagnosticPosition pos,
2540                   Symbol location,
2541                   Type site,
2542                   Name name,
2543                   boolean qualified) {
2544         return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
2545     }
2546 
2547     /** Same as original accessBase(), but without location.
2548      */
2549     Symbol accessBase(Symbol sym,
2550                   DiagnosticPosition pos,
2551                   Type site,
2552                   Name name,
2553                   boolean qualified) {
2554         return accessBase(sym, pos, site.tsym, site, name, qualified);
2555     }
2556 
2557     interface LogResolveHelper {
2558         boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
2559         List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
2560     }
2561 
2562     LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
2563         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2564             return !site.isErroneous();
2565         }
2566         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2567             return argtypes;
2568         }
2569     };
2570 
2571     LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
2572         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2573             return !site.isErroneous() &amp;&amp;
2574                         !Type.isErroneous(argtypes) &amp;&amp;
2575                         (typeargtypes == null || !Type.isErroneous(typeargtypes));
2576         }
2577         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2578             return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
2579         }
2580     };
2581 
2582     class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {
2583 
2584         public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {
2585             deferredAttr.super(mode, msym, step);
2586         }
2587 
2588         @Override
2589         protected Type typeOf(DeferredType dt, Type pt) {
2590             Type res = super.typeOf(dt, pt);
2591             if (!res.isErroneous()) {
2592                 switch (TreeInfo.skipParens(dt.tree).getTag()) {
2593                     case LAMBDA:
2594                     case REFERENCE:
2595                         return dt;
2596                     case CONDEXPR:
2597                         return res == Type.recoveryType ?
2598                                 dt : res;
2599                 }
2600             }
2601             return res;
2602         }
2603     }
2604 
2605     /** Check that sym is not an abstract method.
2606      */
2607     void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
2608         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2609             log.error(pos,
2610                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2611     }
2612 
2613 /* ***************************************************************************
2614  *  Name resolution
2615  *  Naming conventions are as for symbol lookup
2616  *  Unlike the find... methods these methods will report access errors
2617  ****************************************************************************/
2618 
2619     /** Resolve an unqualified (non-method) identifier.
2620      *  @param pos       The position to use for error reporting.
2621      *  @param env       The environment current at the identifier use.
2622      *  @param name      The identifier&#39;s name.
2623      *  @param kind      The set of admissible symbol kinds for the identifier.
2624      */
2625     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2626                         Name name, KindSelector kind) {
2627         return accessBase(
<a name="21" id="anc21"></a><span class="line-modified">2628             findIdent(pos, env, name, kind),</span>
2629             pos, env.enclClass.sym.type, name, false);
2630     }
2631 
2632     /** Resolve an unqualified method identifier.
2633      *  @param pos       The position to use for error reporting.
2634      *  @param env       The environment current at the method invocation.
2635      *  @param name      The identifier&#39;s name.
2636      *  @param argtypes  The types of the invocation&#39;s value arguments.
2637      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2638      */
2639     Symbol resolveMethod(DiagnosticPosition pos,
2640                          Env&lt;AttrContext&gt; env,
2641                          Name name,
2642                          List&lt;Type&gt; argtypes,
2643                          List&lt;Type&gt; typeargtypes) {
2644         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2645                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2646                     @Override
2647                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2648                         return findFun(env, name, argtypes, typeargtypes,
2649                                 phase.isBoxingRequired(),
2650                                 phase.isVarargsRequired());
2651                     }});
2652     }
2653 
2654     /** Resolve a qualified method identifier
2655      *  @param pos       The position to use for error reporting.
2656      *  @param env       The environment current at the method invocation.
2657      *  @param site      The type of the qualifying expression, in which
2658      *                   identifier is searched.
2659      *  @param name      The identifier&#39;s name.
2660      *  @param argtypes  The types of the invocation&#39;s value arguments.
2661      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2662      */
2663     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2664                                   Type site, Name name, List&lt;Type&gt; argtypes,
2665                                   List&lt;Type&gt; typeargtypes) {
2666         return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
2667     }
2668     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2669                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2670                                   List&lt;Type&gt; typeargtypes) {
2671         return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
2672     }
2673     private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
2674                                   DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2675                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2676                                   List&lt;Type&gt; typeargtypes) {
2677         return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {
2678             @Override
2679             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2680                 return findMethod(env, site, name, argtypes, typeargtypes,
2681                         phase.isBoxingRequired(),
2682                         phase.isVarargsRequired());
2683             }
2684             @Override
2685             Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2686                 if (sym.kind.isResolutionError()) {
2687                     sym = super.access(env, pos, location, sym);
2688                 } else {
2689                     MethodSymbol msym = (MethodSymbol)sym;
2690                     if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
2691                         env.info.pendingResolutionPhase = BASIC;
2692                         return findPolymorphicSignatureInstance(env, sym, argtypes);
2693                     }
2694                 }
2695                 return sym;
2696             }
2697         });
2698     }
2699 
2700     /** Find or create an implicit method of exactly the given type (after erasure).
2701      *  Searches in a side table, not the main scope of the site.
2702      *  This emulates the lookup process required by JSR 292 in JVM.
2703      *  @param env       Attribution environment
2704      *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
2705      *  @param argtypes  The required argument types
2706      */
2707     Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,
2708                                             final Symbol spMethod,
2709                                             List&lt;Type&gt; argtypes) {
2710         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
2711                 (MethodSymbol)spMethod, currentResolutionContext, argtypes);
2712         return findPolymorphicSignatureInstance(spMethod, mtype);
2713     }
2714 
2715     Symbol findPolymorphicSignatureInstance(final Symbol spMethod,
2716                                             Type mtype) {
2717         for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {
2718             // Check that there is already a method symbol for the method
2719             // type and owner
2720             if (types.isSameType(mtype, sym.type) &amp;&amp;
2721                 spMethod.owner == sym.owner) {
2722                 return sym;
2723             }
2724         }
2725 
2726         // Create the desired method
2727         // Retain static modifier is to support invocations to
2728         // MethodHandle.linkTo* methods
2729         long flags = ABSTRACT | HYPOTHETICAL |
2730                      spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
2731         Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
2732             @Override
2733             public Symbol baseSymbol() {
2734                 return spMethod;
2735             }
2736         };
2737         if (!mtype.isErroneous()) { // Cache only if kosher.
2738             polymorphicSignatureScope.enter(msym);
2739         }
2740         return msym;
2741     }
2742 
2743     /** Resolve a qualified method identifier, throw a fatal error if not
2744      *  found.
2745      *  @param pos       The position to use for error reporting.
2746      *  @param env       The environment current at the method invocation.
2747      *  @param site      The type of the qualifying expression, in which
2748      *                   identifier is searched.
2749      *  @param name      The identifier&#39;s name.
2750      *  @param argtypes  The types of the invocation&#39;s value arguments.
2751      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2752      */
2753     public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2754                                         Type site, Name name,
2755                                         List&lt;Type&gt; argtypes,
2756                                         List&lt;Type&gt; typeargtypes) {
2757         MethodResolutionContext resolveContext = new MethodResolutionContext();
2758         resolveContext.internalResolution = true;
2759         Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
2760                 site, name, argtypes, typeargtypes);
2761         if (sym.kind == MTH) return (MethodSymbol)sym;
2762         else throw new FatalError(
2763                  diags.fragment(Fragments.FatalErrCantLocateMeth(name)));
2764     }
2765 
2766     /** Resolve constructor.
2767      *  @param pos       The position to use for error reporting.
2768      *  @param env       The environment current at the constructor invocation.
2769      *  @param site      The type of class for which a constructor is searched.
2770      *  @param argtypes  The types of the constructor invocation&#39;s value
2771      *                   arguments.
2772      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2773      *                   arguments.
2774      */
2775     Symbol resolveConstructor(DiagnosticPosition pos,
2776                               Env&lt;AttrContext&gt; env,
2777                               Type site,
2778                               List&lt;Type&gt; argtypes,
2779                               List&lt;Type&gt; typeargtypes) {
2780         return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
2781     }
2782 
2783     private Symbol resolveConstructor(MethodResolutionContext resolveContext,
2784                               final DiagnosticPosition pos,
2785                               Env&lt;AttrContext&gt; env,
2786                               Type site,
2787                               List&lt;Type&gt; argtypes,
2788                               List&lt;Type&gt; typeargtypes) {
2789         return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2790             @Override
2791             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2792                 return findConstructor(pos, env, site, argtypes, typeargtypes,
2793                         phase.isBoxingRequired(),
2794                         phase.isVarargsRequired());
2795             }
2796         });
2797     }
2798 
2799     /** Resolve a constructor, throw a fatal error if not found.
2800      *  @param pos       The position to use for error reporting.
2801      *  @param env       The environment current at the method invocation.
2802      *  @param site      The type to be constructed.
2803      *  @param argtypes  The types of the invocation&#39;s value arguments.
2804      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2805      */
2806     public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2807                                         Type site,
2808                                         List&lt;Type&gt; argtypes,
2809                                         List&lt;Type&gt; typeargtypes) {
2810         MethodResolutionContext resolveContext = new MethodResolutionContext();
2811         resolveContext.internalResolution = true;
2812         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2813         if (sym.kind == MTH) return (MethodSymbol)sym;
2814         else throw new FatalError(
2815                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2816     }
2817 
2818     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2819                               Type site, List&lt;Type&gt; argtypes,
2820                               List&lt;Type&gt; typeargtypes,
2821                               boolean allowBoxing,
2822                               boolean useVarargs) {
2823         Symbol sym = findMethod(env, site,
2824                                     names.init, argtypes,
2825                                     typeargtypes, allowBoxing,
2826                                     useVarargs);
2827         chk.checkDeprecated(pos, env.info.scope.owner, sym);
<a name="22" id="anc22"></a><span class="line-added">2828         chk.checkPreview(pos, sym);</span>
2829         return sym;
2830     }
2831 
2832     /** Resolve constructor using diamond inference.
2833      *  @param pos       The position to use for error reporting.
2834      *  @param env       The environment current at the constructor invocation.
2835      *  @param site      The type of class for which a constructor is searched.
2836      *                   The scope of this class has been touched in attribution.
2837      *  @param argtypes  The types of the constructor invocation&#39;s value
2838      *                   arguments.
2839      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2840      *                   arguments.
2841      */
2842     Symbol resolveDiamond(DiagnosticPosition pos,
2843                               Env&lt;AttrContext&gt; env,
2844                               Type site,
2845                               List&lt;Type&gt; argtypes,
2846                               List&lt;Type&gt; typeargtypes) {
2847         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2848                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2849                     @Override
2850                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2851                         return findDiamond(env, site, argtypes, typeargtypes,
2852                                 phase.isBoxingRequired(),
2853                                 phase.isVarargsRequired());
2854                     }
2855                     @Override
2856                     Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2857                         if (sym.kind.isResolutionError()) {
2858                             if (sym.kind != WRONG_MTH &amp;&amp;
2859                                 sym.kind != WRONG_MTHS) {
2860                                 sym = super.access(env, pos, location, sym);
2861                             } else {
2862                                 final JCDiagnostic details = sym.kind == WRONG_MTH ?
2863                                                 ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
2864                                                 null;
2865                                 sym = new DiamondError(sym, currentResolutionContext);
2866                                 sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
2867                                 env.info.pendingResolutionPhase = currentResolutionContext.step;
2868                             }
2869                         }
2870                         return sym;
2871                     }});
2872     }
2873 
2874     /** This method scans all the constructor symbol in a given class scope -
2875      *  assuming that the original scope contains a constructor of the kind:
2876      *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
2877      *  a method check is executed against the modified constructor type:
2878      *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
2879      *  inference. The inferred return type of the synthetic constructor IS
2880      *  the inferred type for the diamond operator.
2881      */
2882     private Symbol findDiamond(Env&lt;AttrContext&gt; env,
2883                               Type site,
2884                               List&lt;Type&gt; argtypes,
2885                               List&lt;Type&gt; typeargtypes,
2886                               boolean allowBoxing,
2887                               boolean useVarargs) {
2888         Symbol bestSoFar = methodNotFound;
2889         TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
2890         for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {
2891             //- System.out.println(&quot; e &quot; + e.sym);
2892             if (sym.kind == MTH &amp;&amp;
2893                 (sym.flags_field &amp; SYNTHETIC) == 0) {
2894                     List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
2895                             ((ForAll)sym.type).tvars :
2896                             List.nil();
2897                     Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
2898                                                  types.createMethodTypeWithReturn(sym.type.asMethodType(), site));
2899                     MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {
2900                         @Override
2901                         public Symbol baseSymbol() {
2902                             return sym;
2903                         }
2904                     };
2905                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
2906                             newConstr,
2907                             bestSoFar,
2908                             allowBoxing,
2909                             useVarargs);
2910             }
2911         }
2912         return bestSoFar;
2913     }
2914 
2915     Symbol getMemberReference(DiagnosticPosition pos,
2916             Env&lt;AttrContext&gt; env,
2917             JCMemberReference referenceTree,
2918             Type site,
2919             Name name) {
2920 
2921         site = types.capture(site);
2922 
2923         ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(
2924                 referenceTree, site, name, List.nil(), null, VARARITY);
2925 
2926         Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());
2927         Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,
2928                 nilMethodCheck, lookupHelper);
2929 
2930         env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;
2931 
2932         return sym;
2933     }
2934 
2935     ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,
2936                                   Type site,
2937                                   Name name,
2938                                   List&lt;Type&gt; argtypes,
2939                                   List&lt;Type&gt; typeargtypes,
2940                                   MethodResolutionPhase maxPhase) {
2941         if (!name.equals(names.init)) {
2942             //method reference
2943             return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);
2944         } else if (site.hasTag(ARRAY)) {
2945             //array constructor reference
2946             return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2947         } else {
2948             //class constructor reference
2949             return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2950         }
2951     }
2952 
2953     /**
2954      * Resolution of member references is typically done as a single
2955      * overload resolution step, where the argument types A are inferred from
2956      * the target functional descriptor.
2957      *
2958      * If the member reference is a method reference with a type qualifier,
2959      * a two-step lookup process is performed. The first step uses the
2960      * expected argument list A, while the second step discards the first
2961      * type from A (which is treated as a receiver type).
2962      *
2963      * There are two cases in which inference is performed: (i) if the member
2964      * reference is a constructor reference and the qualifier type is raw - in
2965      * which case diamond inference is used to infer a parameterization for the
2966      * type qualifier; (ii) if the member reference is an unbound reference
2967      * where the type qualifier is raw - in that case, during the unbound lookup
2968      * the receiver argument type is used to infer an instantiation for the raw
2969      * qualifier type.
2970      *
2971      * When a multi-step resolution process is exploited, the process of picking
2972      * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
2973      *
2974      * This routine returns a pair (T,S), where S is the member reference symbol,
2975      * and T is the type of the class in which S is defined. This is necessary as
2976      * the type T might be dynamically inferred (i.e. if constructor reference
2977      * has a raw qualifier).
2978      */
2979     Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,
2980                                   JCMemberReference referenceTree,
2981                                   Type site,
2982                                   Name name,
2983                                   List&lt;Type&gt; argtypes,
2984                                   List&lt;Type&gt; typeargtypes,
2985                                   Type descriptor,
2986                                   MethodCheck methodCheck,
2987                                   InferenceContext inferenceContext,
2988                                   ReferenceChooser referenceChooser) {
2989 
2990         //step 1 - bound lookup
2991         ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
2992                 referenceTree, site, name, argtypes, typeargtypes, VARARITY);
2993         Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());
2994         MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();
2995         boundSearchResolveContext.methodCheck = methodCheck;
2996         Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),
2997                 site.tsym, boundSearchResolveContext, boundLookupHelper);
2998         ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
2999 
3000         //step 2 - unbound lookup
3001         Symbol unboundSym = methodNotFound;
3002         Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());
3003         ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);
3004         ReferenceLookupResult unboundRes = referenceNotFound;
3005         if (unboundLookupHelper != null) {
3006             MethodResolutionContext unboundSearchResolveContext =
3007                     new MethodResolutionContext();
3008             unboundSearchResolveContext.methodCheck = methodCheck;
3009             unboundSym = lookupMethod(unboundEnv, env.tree.pos(),
3010                     site.tsym, unboundSearchResolveContext, unboundLookupHelper);
3011             unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
3012         }
3013 
3014         //merge results
3015         Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
3016         ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
3017         res = new Pair&lt;&gt;(bestRes.sym,
3018                 bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);
3019         env.info.pendingResolutionPhase = bestRes == unboundRes ?
3020                 unboundEnv.info.pendingResolutionPhase :
3021                 boundEnv.info.pendingResolutionPhase;
3022 
3023         if (!res.fst.kind.isResolutionError()) {
3024             //handle sigpoly method references
3025             MethodSymbol msym = (MethodSymbol)res.fst;
3026             if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
3027                 env.info.pendingResolutionPhase = BASIC;
3028                 res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
3029             }
3030         }
3031 
3032         return res;
3033     }
3034 
3035     /**
3036      * This class is used to represent a method reference lookup result. It keeps track of two
3037      * things: (i) the symbol found during a method reference lookup and (ii) the static kind
3038      * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).
3039      */
3040     static class ReferenceLookupResult {
3041 
3042         /**
3043          * Static kind associated with a method reference lookup. Erroneous lookups end up with
3044          * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
3045          * depending on whether all applicable candidates are static or non-static methods,
3046          * respectively. If a successful lookup has both static and non-static applicable methods,
3047          * its kind is set to BOTH.
3048          */
3049         enum StaticKind {
3050             STATIC,
3051             NON_STATIC,
3052             BOTH,
3053             UNDEFINED;
3054 
3055             /**
3056              * Retrieve the static kind associated with a given (method) symbol.
3057              */
3058             static StaticKind from(Symbol s) {
3059                 return s.isStatic() ?
3060                         STATIC : NON_STATIC;
3061             }
3062 
3063             /**
3064              * Merge two static kinds together.
3065              */
3066             static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
3067                 if (sk1 == UNDEFINED) {
3068                     return sk2;
3069                 } else if (sk2 == UNDEFINED) {
3070                     return sk1;
3071                 } else {
3072                     return sk1 == sk2 ? sk1 : BOTH;
3073                 }
3074             }
3075         }
3076 
3077         /** The static kind. */
3078         StaticKind staticKind;
3079 
3080         /** The lookup result. */
3081         Symbol sym;
3082 
3083         ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
3084             this(sym, staticKind(sym, resolutionContext));
3085         }
3086 
3087         private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
3088             this.staticKind = staticKind;
3089             this.sym = sym;
3090         }
3091 
3092         private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
3093             switch (sym.kind) {
3094                 case MTH:
3095                 case AMBIGUOUS:
3096                     return resolutionContext.candidates.stream()
3097                             .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
3098                             .map(c -&gt; StaticKind.from(c.sym))
3099                             .reduce(StaticKind::reduce)
3100                             .orElse(StaticKind.UNDEFINED);
3101                 default:
3102                     return StaticKind.UNDEFINED;
3103             }
3104         }
3105 
3106         /**
3107          * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
3108          */
3109         boolean isSuccess() {
3110             return staticKind != StaticKind.UNDEFINED;
3111         }
3112 
3113         /**
3114          * Does this result have given static kind?
3115          */
3116         boolean hasKind(StaticKind sk) {
3117             return this.staticKind == sk;
3118         }
3119 
3120         /**
3121          * Error recovery helper: can this lookup result be ignored (for the purpose of returning
3122          * some &#39;better&#39; result) ?
3123          */
3124         boolean canIgnore() {
3125             switch (sym.kind) {
3126                 case ABSENT_MTH:
3127                     return true;
3128                 case WRONG_MTH:
3129                     InapplicableSymbolError errSym =
3130                             (InapplicableSymbolError)sym.baseSymbol();
3131                     return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
3132                             .matches(errSym.errCandidate().snd);
3133                 case WRONG_MTHS:
3134                     InapplicableSymbolsError errSyms =
3135                             (InapplicableSymbolsError)sym.baseSymbol();
3136                     return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();
3137                 default:
3138                     return false;
3139             }
3140         }
3141 
3142         static ReferenceLookupResult error(Symbol sym) {
3143             return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
3144         }
3145     }
3146 
3147     /**
3148      * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
3149      * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
3150      * result of method reference resolution.
3151      */
3152     abstract class ReferenceChooser {
3153         /**
3154          * Generate a result from a pair of lookup result objects. This method delegates to the
3155          * appropriate result generation routine.
3156          */
3157         ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3158             return unboundRes != referenceNotFound ?
3159                     unboundResult(boundRes, unboundRes) :
3160                     boundResult(boundRes);
3161         }
3162 
3163         /**
3164          * Generate a symbol from a given bound lookup result.
3165          */
3166         abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
3167 
3168         /**
3169          * Generate a symbol from a pair of bound/unbound lookup results.
3170          */
3171         abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
3172     }
3173 
3174     /**
3175      * This chooser implements the selection strategy used during a full lookup; this logic
3176      * is described in JLS SE 8 (15.3.2).
3177      */
3178     ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
3179 
3180         @Override
3181         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3182             return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
3183                     boundRes : //the search produces a non-static method
3184                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3185         }
3186 
3187         @Override
3188         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3189             if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
3190                     (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
3191                 //the first search produces a static method and no non-static method is applicable
3192                 //during the second search
3193                 return boundRes;
3194             } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
3195                     (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {
3196                 //the second search produces a non-static method and no static method is applicable
3197                 //during the first search
3198                 return unboundRes;
3199             } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
3200                 //both searches produce some result; ambiguity (error recovery)
3201                 return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
3202             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3203                 //Both searches failed to produce a result with correct staticness (i.e. first search
3204                 //produces an non-static method). Alternatively, a given search produced a result
3205                 //with the right staticness, but the other search has applicable methods with wrong
3206                 //staticness (error recovery)
3207                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3208                         boundRes.sym : unboundRes.sym, true));
3209             } else {
3210                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3211                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3212                         unboundRes : boundRes;
3213             }
3214         }
3215     };
3216 
3217     /**
3218      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3219      * is described in JLS SE 8 (15.12.2.1).
3220      */
3221     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3222 
3223         @Override
3224         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3225             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3226                     boundRes : //the search has at least one applicable non-static method
3227                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3228         }
3229 
3230         @Override
3231         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3232             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
<a name="23" id="anc23"></a><span class="line-modified">3233                 //the first search has at least one applicable static method</span>
3234                 return boundRes;
3235             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3236                 //the second search has at least one applicable non-static method
3237                 return unboundRes;
3238             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3239                 //either the first search produces a non-static method, or second search produces
3240                 //a non-static method (error recovery)
3241                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3242                         boundRes.sym : unboundRes.sym, true));
3243             } else {
3244                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3245                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3246                         unboundRes : boundRes;
3247             }
3248         }
3249     };
3250 
3251     /**
3252      * Helper for defining custom method-like lookup logic; a lookup helper
3253      * provides hooks for (i) the actual lookup logic and (ii) accessing the
3254      * lookup result (this step might result in compiler diagnostics to be generated)
3255      */
3256     abstract class LookupHelper {
3257 
3258         /** name of the symbol to lookup */
3259         Name name;
3260 
3261         /** location in which the lookup takes place */
3262         Type site;
3263 
3264         /** actual types used during the lookup */
3265         List&lt;Type&gt; argtypes;
3266 
3267         /** type arguments used during the lookup */
3268         List&lt;Type&gt; typeargtypes;
3269 
3270         /** Max overload resolution phase handled by this helper */
3271         MethodResolutionPhase maxPhase;
3272 
3273         LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3274             this.name = name;
3275             this.site = site;
3276             this.argtypes = argtypes;
3277             this.typeargtypes = typeargtypes;
3278             this.maxPhase = maxPhase;
3279         }
3280 
3281         /**
3282          * Should lookup stop at given phase with given result
3283          */
3284         final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
3285             return phase.ordinal() &gt; maxPhase.ordinal() ||
3286                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;
3287         }
3288 
3289         /**
3290          * Search for a symbol under a given overload resolution phase - this method
3291          * is usually called several times, once per each overload resolution phase
3292          */
3293         abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3294 
3295         /**
3296          * Dump overload resolution info
3297          */
3298         void debug(DiagnosticPosition pos, Symbol sym) {
3299             //do nothing
3300         }
3301 
3302         /**
3303          * Validate the result of the lookup
3304          */
3305         abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
3306     }
3307 
3308     abstract class BasicLookupHelper extends LookupHelper {
3309 
3310         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3311             this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
3312         }
3313 
3314         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3315             super(name, site, argtypes, typeargtypes, maxPhase);
3316         }
3317 
3318         @Override
3319         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3320             Symbol sym = doLookup(env, phase);
3321             if (sym.kind == AMBIGUOUS) {
3322                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3323                 sym = a_err.mergeAbstracts(site);
3324             }
3325             return sym;
3326         }
3327 
3328         abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3329 
3330         @Override
3331         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3332             if (sym.kind.isResolutionError()) {
3333                 //if nothing is found return the &#39;first&#39; error
3334                 sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);
3335             }
3336             return sym;
3337         }
3338 
3339         @Override
3340         void debug(DiagnosticPosition pos, Symbol sym) {
3341             reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
3342         }
3343     }
3344 
3345     /**
3346      * Helper class for member reference lookup. A reference lookup helper
3347      * defines the basic logic for member reference lookup; a method gives
3348      * access to an &#39;unbound&#39; helper used to perform an unbound member
3349      * reference lookup.
3350      */
3351     abstract class ReferenceLookupHelper extends LookupHelper {
3352 
3353         /** The member reference tree */
3354         JCMemberReference referenceTree;
3355 
3356         ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3357                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3358             super(name, site, argtypes, typeargtypes, maxPhase);
3359             this.referenceTree = referenceTree;
3360         }
3361 
3362         /**
3363          * Returns an unbound version of this lookup helper. By default, this
3364          * method returns an dummy lookup helper.
3365          */
3366         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3367             return null;
3368         }
3369 
3370         /**
3371          * Get the kind of the member reference
3372          */
3373         abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
3374 
3375         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3376             if (sym.kind == AMBIGUOUS) {
3377                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3378                 sym = a_err.mergeAbstracts(site);
3379             }
3380             //skip error reporting
3381             return sym;
3382         }
3383     }
3384 
3385     /**
3386      * Helper class for method reference lookup. The lookup logic is based
3387      * upon Resolve.findMethod; in certain cases, this helper class has a
3388      * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
3389      * In such cases, non-static lookup results are thrown away.
3390      */
3391     class MethodReferenceLookupHelper extends ReferenceLookupHelper {
3392 
3393         /** The original method reference lookup site. */
3394         Type originalSite;
3395 
3396         MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3397                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3398             super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);
3399             this.originalSite = site;
3400         }
3401 
3402         @Override
3403         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3404             return findMethod(env, site, name, argtypes, typeargtypes,
3405                     phase.isBoxingRequired(), phase.isVarargsRequired());
3406         }
3407 
3408         @Override
3409         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3410             if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {
3411                 if (argtypes.nonEmpty() &amp;&amp;
3412                         (argtypes.head.hasTag(NONE) ||
3413                         types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {
3414                     return new UnboundMethodReferenceLookupHelper(referenceTree, name,
3415                             originalSite, argtypes, typeargtypes, maxPhase);
3416                 } else {
3417                     return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {
3418                         @Override
3419                         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3420                             return this;
3421                         }
3422 
3423                         @Override
3424                         Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3425                             return methodNotFound;
3426                         }
3427 
3428                         @Override
3429                         ReferenceKind referenceKind(Symbol sym) {
3430                             Assert.error();
3431                             return null;
3432                         }
3433                     };
3434                 }
3435             } else {
3436                 return super.unboundLookup(inferenceContext);
3437             }
3438         }
3439 
3440         @Override
3441         ReferenceKind referenceKind(Symbol sym) {
3442             if (sym.isStatic()) {
3443                 return ReferenceKind.STATIC;
3444             } else {
3445                 Name selName = TreeInfo.name(referenceTree.getQualifierExpression());
3446                 return selName != null &amp;&amp; selName == names._super ?
3447                         ReferenceKind.SUPER :
3448                         ReferenceKind.BOUND;
3449             }
3450         }
3451     }
3452 
3453     /**
3454      * Helper class for unbound method reference lookup. Essentially the same
3455      * as the basic method reference lookup helper; main difference is that static
3456      * lookup results are thrown away. If qualifier type is raw, an attempt to
3457      * infer a parameterized type is made using the first actual argument (that
3458      * would otherwise be ignored during the lookup).
3459      */
3460     class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
3461 
3462         UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3463                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3464             super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
3465             if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {
3466                 Type asSuperSite = types.asSuper(argtypes.head, site.tsym);
3467                 this.site = types.skipTypeVars(asSuperSite, true);
3468             }
3469         }
3470 
3471         @Override
3472         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3473             return this;
3474         }
3475 
3476         @Override
3477         ReferenceKind referenceKind(Symbol sym) {
3478             return ReferenceKind.UNBOUND;
3479         }
3480     }
3481 
3482     /**
3483      * Helper class for array constructor lookup; an array constructor lookup
3484      * is simulated by looking up a method that returns the array type specified
3485      * as qualifier, and that accepts a single int parameter (size of the array).
3486      */
3487     class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3488 
3489         ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3490                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3491             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3492         }
3493 
3494         @Override
3495         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3496             WriteableScope sc = WriteableScope.create(syms.arrayClass);
3497             MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);
3498             arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
3499             sc.enter(arrayConstr);
3500             return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);
3501         }
3502 
3503         @Override
3504         ReferenceKind referenceKind(Symbol sym) {
3505             return ReferenceKind.ARRAY_CTOR;
3506         }
3507     }
3508 
3509     /**
3510      * Helper class for constructor reference lookup. The lookup logic is based
3511      * upon either Resolve.findMethod or Resolve.findDiamond - depending on
3512      * whether the constructor reference needs diamond inference (this is the case
3513      * if the qualifier type is raw). A special erroneous symbol is returned
3514      * if the lookup returns the constructor of an inner class and there&#39;s no
3515      * enclosing instance in scope.
3516      */
3517     class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3518 
3519         boolean needsInference;
3520 
3521         ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3522                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3523             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3524             if (site.isRaw()) {
3525                 this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
3526                 needsInference = true;
3527             }
3528         }
3529 
3530         @Override
3531         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3532             Symbol sym = needsInference ?
3533                 findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
3534                 findMethod(env, site, name, argtypes, typeargtypes,
3535                         phase.isBoxingRequired(), phase.isVarargsRequired());
3536             return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
3537         }
3538 
3539         @Override
3540         ReferenceKind referenceKind(Symbol sym) {
3541             return site.getEnclosingType().hasTag(NONE) ?
3542                     ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
3543         }
3544     }
3545 
3546     /**
3547      * Main overload resolution routine. On each overload resolution step, a
3548      * lookup helper class is used to perform the method/constructor lookup;
3549      * at the end of the lookup, the helper is used to validate the results
3550      * (this last step might trigger overload resolution diagnostics).
3551      */
3552     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {
3553         MethodResolutionContext resolveContext = new MethodResolutionContext();
3554         resolveContext.methodCheck = methodCheck;
3555         return lookupMethod(env, pos, location, resolveContext, lookupHelper);
3556     }
3557 
3558     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,
3559             MethodResolutionContext resolveContext, LookupHelper lookupHelper) {
3560         MethodResolutionContext prevResolutionContext = currentResolutionContext;
3561         try {
3562             Symbol bestSoFar = methodNotFound;
3563             currentResolutionContext = resolveContext;
3564             for (MethodResolutionPhase phase : methodResolutionSteps) {
3565                 if (lookupHelper.shouldStop(bestSoFar, phase))
3566                     break;
3567                 MethodResolutionPhase prevPhase = currentResolutionContext.step;
3568                 Symbol prevBest = bestSoFar;
3569                 currentResolutionContext.step = phase;
3570                 Symbol sym = lookupHelper.lookup(env, phase);
3571                 lookupHelper.debug(pos, sym);
3572                 bestSoFar = phase.mergeResults(bestSoFar, sym);
3573                 env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;
3574             }
3575             return lookupHelper.access(env, pos, location, bestSoFar);
3576         } finally {
3577             currentResolutionContext = prevResolutionContext;
3578         }
3579     }
3580 
3581     /**
3582      * Resolve `c.name&#39; where name == this or name == super.
3583      * @param pos           The position to use for error reporting.
3584      * @param env           The environment current at the expression.
3585      * @param c             The qualifier.
3586      * @param name          The identifier&#39;s name.
3587      */
3588     Symbol resolveSelf(DiagnosticPosition pos,
3589                        Env&lt;AttrContext&gt; env,
3590                        TypeSymbol c,
3591                        Name name) {
3592         Env&lt;AttrContext&gt; env1 = env;
3593         boolean staticOnly = false;
3594         while (env1.outer != null) {
3595             if (isStatic(env1)) staticOnly = true;
3596             if (env1.enclClass.sym == c) {
3597                 Symbol sym = env1.info.scope.findFirst(name);
3598                 if (sym != null) {
3599                     if (staticOnly) sym = new StaticError(sym);
3600                     return accessBase(sym, pos, env.enclClass.sym.type,
3601                                   name, true);
3602                 }
3603             }
3604             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
3605             env1 = env1.outer;
3606         }
3607         if (c.isInterface() &amp;&amp;
3608             name == names._super &amp;&amp; !isStatic(env) &amp;&amp;
3609             types.isDirectSuperInterface(c, env.enclClass.sym)) {
3610             //this might be a default super call if one of the superinterfaces is &#39;c&#39;
3611             for (Type t : pruneInterfaces(env.enclClass.type)) {
3612                 if (t.tsym == c) {
3613                     env.info.defaultSuperCallSite = t;
3614                     return new VarSymbol(0, names._super,
3615                             types.asSuper(env.enclClass.type, c), env.enclClass.sym);
3616                 }
3617             }
3618             //find a direct super type that is a subtype of &#39;c&#39;
3619             for (Type i : types.directSupertypes(env.enclClass.type)) {
3620                 if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
3621                     log.error(pos,
3622                               Errors.IllegalDefaultSuperCall(c,
3623                                                              Fragments.RedundantSupertype(c, i)));
3624                     return syms.errSymbol;
3625                 }
3626             }
3627             Assert.error();
3628         }
3629         log.error(pos, Errors.NotEnclClass(c));
3630         return syms.errSymbol;
3631     }
3632     //where
3633     private List&lt;Type&gt; pruneInterfaces(Type t) {
3634         ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
3635         for (Type t1 : types.interfaces(t)) {
3636             boolean shouldAdd = true;
3637             for (Type t2 : types.directSupertypes(t)) {
3638                 if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
3639                     shouldAdd = false;
3640                 }
3641             }
3642             if (shouldAdd) {
3643                 result.append(t1);
3644             }
3645         }
3646         return result.toList();
3647     }
3648 
3649 
3650     /**
3651      * Resolve `c.this&#39; for an enclosing class c that contains the
3652      * named member.
3653      * @param pos           The position to use for error reporting.
3654      * @param env           The environment current at the expression.
3655      * @param member        The member that must be contained in the result.
3656      */
3657     Symbol resolveSelfContaining(DiagnosticPosition pos,
3658                                  Env&lt;AttrContext&gt; env,
3659                                  Symbol member,
3660                                  boolean isSuperCall) {
3661         Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);
3662         if (sym == null) {
3663             log.error(pos, Errors.EnclClassRequired(member));
3664             return syms.errSymbol;
3665         } else {
3666             return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
3667         }
3668     }
3669 
3670     boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
3671         if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
3672             Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);
3673             return encl == null || encl.kind.isResolutionError();
3674         }
3675         return false;
3676     }
3677 
3678     private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
3679                                  Symbol member,
3680                                  boolean isSuperCall) {
3681         Name name = names._this;
3682         Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
3683         boolean staticOnly = false;
3684         if (env1 != null) {
3685             while (env1 != null &amp;&amp; env1.outer != null) {
3686                 if (isStatic(env1)) staticOnly = true;
3687                 if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {
3688                     Symbol sym = env1.info.scope.findFirst(name);
3689                     if (sym != null) {
3690                         if (staticOnly) sym = new StaticError(sym);
3691                         return sym;
3692                     }
3693                 }
3694                 if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)
3695                     staticOnly = true;
3696                 env1 = env1.outer;
3697             }
3698         }
3699         return null;
3700     }
3701 
3702     /**
3703      * Resolve an appropriate implicit this instance for t&#39;s container.
3704      * JLS 8.8.5.1 and 15.9.2
3705      */
3706     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {
3707         return resolveImplicitThis(pos, env, t, false);
3708     }
3709 
3710     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
3711         Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)
3712                          ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)
3713                          : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
3714         if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {
3715             log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
3716         }
3717         return thisType;
3718     }
3719 
3720 /* ***************************************************************************
3721  *  ResolveError classes, indicating error situations when accessing symbols
3722  ****************************************************************************/
3723 
3724     //used by TransTypes when checking target type of synthetic cast
3725     public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
3726         AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
3727         logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
3728     }
3729     //where
3730     private void logResolveError(ResolveError error,
3731             DiagnosticPosition pos,
3732             Symbol location,
3733             Type site,
3734             Name name,
3735             List&lt;Type&gt; argtypes,
3736             List&lt;Type&gt; typeargtypes) {
3737         JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
3738                 pos, location, site, name, argtypes, typeargtypes);
3739         if (d != null) {
3740             d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
3741             log.report(d);
3742         }
3743     }
3744 
3745     private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
3746 
3747     public Object methodArguments(List&lt;Type&gt; argtypes) {
3748         if (argtypes == null || argtypes.isEmpty()) {
3749             return noArgs;
3750         } else {
3751             ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();
3752             for (Type t : argtypes) {
3753                 if (t.hasTag(DEFERRED)) {
3754                     diagArgs.append(((DeferredAttr.DeferredType)t).tree);
3755                 } else {
3756                     diagArgs.append(t);
3757                 }
3758             }
3759             return diagArgs;
3760         }
3761     }
3762 
3763     /**
3764      * Root class for resolution errors. Subclass of ResolveError
3765      * represent a different kinds of resolution error - as such they must
3766      * specify how they map into concrete compiler diagnostics.
3767      */
3768     abstract class ResolveError extends Symbol {
3769 
3770         /** The name of the kind of error, for debugging only. */
3771         final String debugName;
3772 
3773         ResolveError(Kind kind, String debugName) {
3774             super(kind, 0, null, null, null);
3775             this.debugName = debugName;
3776         }
3777 
3778         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3779         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
3780             throw new AssertionError();
3781         }
3782 
3783         @Override
3784         public String toString() {
3785             return debugName;
3786         }
3787 
3788         @Override
3789         public boolean exists() {
3790             return false;
3791         }
3792 
3793         @Override
3794         public boolean isStatic() {
3795             return false;
3796         }
3797 
3798         /**
3799          * Create an external representation for this erroneous symbol to be
3800          * used during attribution - by default this returns the symbol of a
3801          * brand new error type which stores the original type found
3802          * during resolution.
3803          *
3804          * @param name     the name used during resolution
3805          * @param location the location from which the symbol is accessed
3806          */
3807         protected Symbol access(Name name, TypeSymbol location) {
3808             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
3809         }
3810 
3811         /**
3812          * Create a diagnostic representing this resolution error.
3813          *
3814          * @param dkind     The kind of the diagnostic to be created (e.g error).
3815          * @param pos       The position to be used for error reporting.
3816          * @param site      The original type from where the selection took place.
3817          * @param name      The name of the symbol to be resolved.
3818          * @param argtypes  The invocation&#39;s value arguments,
3819          *                  if we looked for a method.
3820          * @param typeargtypes  The invocation&#39;s type arguments,
3821          *                      if we looked for a method.
3822          */
3823         abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3824                 DiagnosticPosition pos,
3825                 Symbol location,
3826                 Type site,
3827                 Name name,
3828                 List&lt;Type&gt; argtypes,
3829                 List&lt;Type&gt; typeargtypes);
3830     }
3831 
3832     /**
3833      * This class is the root class of all resolution errors caused by
3834      * an invalid symbol being found during resolution.
3835      */
3836     abstract class InvalidSymbolError extends ResolveError {
3837 
3838         /** The invalid symbol found during resolution */
3839         Symbol sym;
3840 
3841         InvalidSymbolError(Kind kind, Symbol sym, String debugName) {
3842             super(kind, debugName);
3843             this.sym = sym;
3844         }
3845 
3846         @Override
3847         public boolean exists() {
3848             return true;
3849         }
3850 
3851         @Override
3852         public String toString() {
3853              return super.toString() + &quot; wrongSym=&quot; + sym;
3854         }
3855 
3856         @Override
3857         public Symbol access(Name name, TypeSymbol location) {
3858             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3859                 return types.createErrorType(name, location, sym.type).tsym;
3860             else
3861                 return sym;
3862         }
3863     }
3864 
<a name="24" id="anc24"></a><span class="line-modified">3865     class BadRestrictedTypeError extends ResolveError {</span>
<span class="line-modified">3866         private final Name typeName;</span>
<span class="line-modified">3867         BadRestrictedTypeError(Name typeName) {</span>
<span class="line-added">3868             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);</span>
<span class="line-added">3869             this.typeName = typeName;</span>
3870         }
3871 
3872         @Override
3873         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
<a name="25" id="anc25"></a><span class="line-modified">3874             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);</span>
3875         }
3876     }
3877 
3878     /**
3879      * InvalidSymbolError error class indicating that a symbol matching a
3880      * given name does not exists in a given site.
3881      */
3882     class SymbolNotFoundError extends ResolveError {
3883 
3884         SymbolNotFoundError(Kind kind) {
3885             this(kind, &quot;symbol not found error&quot;);
3886         }
3887 
3888         SymbolNotFoundError(Kind kind, String debugName) {
3889             super(kind, debugName);
3890         }
3891 
3892         @Override
3893         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3894                 DiagnosticPosition pos,
3895                 Symbol location,
3896                 Type site,
3897                 Name name,
3898                 List&lt;Type&gt; argtypes,
3899                 List&lt;Type&gt; typeargtypes) {
3900             argtypes = argtypes == null ? List.nil() : argtypes;
3901             typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;
3902             if (name == names.error)
3903                 return null;
3904 
3905             boolean hasLocation = false;
3906             if (location == null) {
3907                 location = site.tsym;
3908             }
3909             if (!location.name.isEmpty()) {
3910                 if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
3911                     return diags.create(dkind, log.currentSource(), pos,
3912                         &quot;doesnt.exist&quot;, location);
3913                 }
3914                 hasLocation = !location.name.equals(names._this) &amp;&amp;
3915                         !location.name.equals(names._super);
3916             }
3917             boolean isConstructor = name == names.init;
3918             KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
3919             Name idname = isConstructor ? site.tsym.name : name;
3920             String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);
3921             if (hasLocation) {
3922                 return diags.create(dkind, log.currentSource(), pos,
3923                         errKey, kindname, idname, //symbol kindname, name
3924                         typeargtypes, args(argtypes), //type parameters and arguments (if any)
3925                         getLocationDiag(location, site)); //location kindname, type
3926             }
3927             else {
3928                 return diags.create(dkind, log.currentSource(), pos,
3929                         errKey, kindname, idname, //symbol kindname, name
3930                         typeargtypes, args(argtypes)); //type parameters and arguments (if any)
3931             }
3932         }
3933         //where
3934         private Object args(List&lt;Type&gt; args) {
3935             return args.isEmpty() ? args : methodArguments(args);
3936         }
3937 
3938         private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
3939             String key = &quot;cant.resolve&quot;;
3940             String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;
3941             switch (kindname) {
3942                 case METHOD:
3943                 case CONSTRUCTOR: {
3944                     suffix += &quot;.args&quot;;
3945                     suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;
3946                 }
3947             }
3948             return key + suffix;
3949         }
3950         private JCDiagnostic getLocationDiag(Symbol location, Type site) {
3951             if (location.kind == VAR) {
3952                 return diags.fragment(Fragments.Location1(kindName(location),
3953                                                           location,
3954                                                           location.type));
3955             } else {
3956                 return diags.fragment(Fragments.Location(typeKindName(site),
3957                                       site,
3958                                       null));
3959             }
3960         }
3961     }
3962 
3963     /**
3964      * InvalidSymbolError error class indicating that a given symbol
3965      * (either a method, a constructor or an operand) is not applicable
3966      * given an actual arguments/type argument list.
3967      */
3968     class InapplicableSymbolError extends ResolveError {
3969 
3970         protected MethodResolutionContext resolveContext;
3971 
3972         InapplicableSymbolError(MethodResolutionContext context) {
3973             this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);
3974         }
3975 
3976         protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
3977             super(kind, debugName);
3978             this.resolveContext = context;
3979         }
3980 
3981         @Override
3982         public String toString() {
3983             return super.toString();
3984         }
3985 
3986         @Override
3987         public boolean exists() {
3988             return true;
3989         }
3990 
3991         @Override
3992         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3993                 DiagnosticPosition pos,
3994                 Symbol location,
3995                 Type site,
3996                 Name name,
3997                 List&lt;Type&gt; argtypes,
3998                 List&lt;Type&gt; typeargtypes) {
3999             if (name == names.error)
4000                 return null;
4001 
4002             Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();
4003             if (compactMethodDiags) {
4004                 JCDiagnostic simpleDiag =
4005                     MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);
4006                 if (simpleDiag != null) {
4007                     return simpleDiag;
4008                 }
4009             }
4010             Symbol ws = c.fst.asMemberOf(site, types);
4011             return diags.create(dkind, log.currentSource(), pos,
4012                       &quot;cant.apply.symbol&quot;,
4013                       kindName(ws),
4014                       ws.name == names.init ? ws.owner.name : ws.name,
4015                       methodArguments(ws.type.getParameterTypes()),
4016                       methodArguments(argtypes),
4017                       kindName(ws.owner),
4018                       ws.owner.type,
4019                       c.snd);
4020         }
4021 
4022         @Override
4023         public Symbol access(Name name, TypeSymbol location) {
4024             Symbol sym = bestCandidate();
4025             return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;
4026         }
4027 
4028         protected Symbol bestCandidate() {
4029             return errCandidate().fst;
4030         }
4031 
4032         protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4033             Candidate bestSoFar = null;
4034             for (Candidate c : resolveContext.candidates) {
4035                 if (c.isApplicable()) continue;
4036                 bestSoFar = c;
4037             }
4038             Assert.checkNonNull(bestSoFar);
4039             return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
4040         }
4041     }
4042 
4043     /**
4044      * ResolveError error class indicating that a symbol (either methods, constructors or operand)
4045      * is not applicable given an actual arguments/type argument list.
4046      */
4047     class InapplicableSymbolsError extends InapplicableSymbolError {
4048 
4049         InapplicableSymbolsError(MethodResolutionContext context) {
4050             super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
4051         }
4052 
4053         @Override
4054         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4055                 DiagnosticPosition pos,
4056                 Symbol location,
4057                 Type site,
4058                 Name name,
4059                 List&lt;Type&gt; argtypes,
4060                 List&lt;Type&gt; typeargtypes) {
4061             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4062             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
4063                     filterCandidates(candidatesMap) :
4064                     mapCandidates();
4065             if (filteredCandidates.isEmpty()) {
4066                 filteredCandidates = candidatesMap;
4067             }
4068             boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
4069             if (filteredCandidates.size() &gt; 1) {
4070                 JCDiagnostic err = diags.create(dkind,
4071                         null,
4072                         truncatedDiag ?
4073                             EnumSet.of(DiagnosticFlag.COMPRESSED) :
4074                             EnumSet.noneOf(DiagnosticFlag.class),
4075                         log.currentSource(),
4076                         pos,
4077                         &quot;cant.apply.symbols&quot;,
4078                         name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),
4079                         name == names.init ? site.tsym.name : name,
4080                         methodArguments(argtypes));
4081                 return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
4082             } else if (filteredCandidates.size() == 1) {
4083                 Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
4084                                 filteredCandidates.entrySet().iterator().next();
4085                 final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
4086                 JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
4087                     @Override
4088                     protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4089                         return p;
4090                     }
4091                 }.getDiagnostic(dkind, pos,
4092                     location, site, name, argtypes, typeargtypes);
4093                 if (truncatedDiag) {
4094                     d.setFlag(DiagnosticFlag.COMPRESSED);
4095                 }
4096                 return d;
4097             } else {
4098                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,
4099                     location, site, name, argtypes, typeargtypes);
4100             }
4101         }
4102         //where
4103             private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
4104                 MostSpecificMap candidates = new MostSpecificMap();
4105                 for (Candidate c : resolveContext.candidates) {
4106                     if (c.isApplicable()) continue;
4107                     candidates.put(c);
4108                 }
4109                 return candidates;
4110             }
4111 
4112             @SuppressWarnings(&quot;serial&quot;)
4113             private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {
4114                 private void put(Candidate c) {
4115                     ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
4116                     for (Symbol s : keySet()) {
4117                         if (s == c.sym) {
4118                             continue;
4119                         }
4120                         if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
4121                             overridden.add(s);
4122                         } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
4123                             return;
4124                         }
4125                     }
4126                     for (Symbol s : overridden) {
4127                         remove(s);
4128                     }
4129                     put(c.sym, c.details);
4130                 }
4131             }
4132 
4133             Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {
4134                 Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
4135                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4136                     JCDiagnostic d = _entry.getValue();
4137                     if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {
4138                         candidates.put(_entry.getKey(), d);
4139                     }
4140                 }
4141                 return candidates;
4142             }
4143 
4144             private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
4145                 List&lt;JCDiagnostic&gt; details = List.nil();
4146                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4147                     Symbol sym = _entry.getKey();
4148                     JCDiagnostic detailDiag =
4149                             diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
4150                                                                         sym.location(site, types),
4151                                                                         sym.asMemberOf(site, types),
4152                                                                         _entry.getValue()));
4153                     details = details.prepend(detailDiag);
4154                 }
4155                 //typically members are visited in reverse order (see Scope)
4156                 //so we need to reverse the candidate list so that candidates
4157                 //conform to source order
4158                 return details;
4159             }
4160 
4161         @Override
4162         protected Symbol bestCandidate() {
4163             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4164             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = filterCandidates(candidatesMap);
4165             if (filteredCandidates.size() == 1) {
4166                 return filteredCandidates.keySet().iterator().next();
4167             }
4168             return null;
4169         }
4170     }
4171 
4172     /**
4173      * DiamondError error class indicating that a constructor symbol is not applicable
4174      * given an actual arguments/type argument list using diamond inference.
4175      */
4176     class DiamondError extends InapplicableSymbolError {
4177 
4178         Symbol sym;
4179 
4180         public DiamondError(Symbol sym, MethodResolutionContext context) {
4181             super(sym.kind, &quot;diamondError&quot;, context);
4182             this.sym = sym;
4183         }
4184 
4185         JCDiagnostic getDetails() {
4186             return (sym.kind == WRONG_MTH) ?
4187                     ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
4188                     null;
4189         }
4190 
4191         @Override
4192         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
4193                 Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4194             JCDiagnostic details = getDetails();
4195             if (details != null &amp;&amp; compactMethodDiags) {
4196                 JCDiagnostic simpleDiag =
4197                         MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
4198                 if (simpleDiag != null) {
4199                     return simpleDiag;
4200                 }
4201             }
4202             String key = details == null ?
4203                 &quot;cant.apply.diamond&quot; :
4204                 &quot;cant.apply.diamond.1&quot;;
4205             return diags.create(dkind, log.currentSource(), pos, key,
4206                     Fragments.Diamond(site.tsym), details);
4207         }
4208     }
4209 
4210     /**
4211      * An InvalidSymbolError error class indicating that a symbol is not
4212      * accessible from a given site
4213      */
4214     class AccessError extends InvalidSymbolError {
4215 
4216         private Env&lt;AttrContext&gt; env;
4217         private Type site;
4218 
4219         AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
4220             super(HIDDEN, sym, &quot;access error&quot;);
4221             this.env = env;
4222             this.site = site;
4223         }
4224 
4225         @Override
4226         public boolean exists() {
4227             return false;
4228         }
4229 
4230         @Override
4231         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4232                 DiagnosticPosition pos,
4233                 Symbol location,
4234                 Type site,
4235                 Name name,
4236                 List&lt;Type&gt; argtypes,
4237                 List&lt;Type&gt; typeargtypes) {
4238             if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
4239                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,
4240                         pos, location, site, name, argtypes, typeargtypes);
4241             }
4242             else if ((sym.flags() &amp; PUBLIC) != 0
4243                 || (env != null &amp;&amp; this.site != null
4244                     &amp;&amp; !isAccessible(env, this.site))) {
4245                 if (sym.owner.kind == PCK) {
4246                     return diags.create(dkind, log.currentSource(),
4247                             pos, &quot;not.def.access.package.cant.access&quot;,
4248                         sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
4249                 } else if (   sym.packge() != syms.rootPackage
4250                            &amp;&amp; !symbolPackageVisible(env, sym)) {
4251                     return diags.create(dkind, log.currentSource(),
4252                             pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
4253                             sym, sym.location(), sym.location().packge(),
4254                             inaccessiblePackageReason(env, sym.packge()));
4255                 } else {
4256                     return diags.create(dkind, log.currentSource(),
4257                             pos, &quot;not.def.access.class.intf.cant.access&quot;,
4258                         sym, sym.location());
4259                 }
4260             }
4261             else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
4262                 return diags.create(dkind, log.currentSource(),
4263                         pos, &quot;report.access&quot;, sym,
4264                         asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
4265                         sym.location());
4266             }
4267             else {
4268                 return diags.create(dkind, log.currentSource(),
4269                         pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());
4270             }
4271         }
4272 
4273         private String toString(Type type) {
4274             StringBuilder sb = new StringBuilder();
4275             sb.append(type);
4276             if (type != null) {
4277                 sb.append(&quot;[tsym:&quot;).append(type.tsym);
4278                 if (type.tsym != null)
4279                     sb.append(&quot;packge:&quot;).append(type.tsym.packge());
4280                 sb.append(&quot;]&quot;);
4281             }
4282             return sb.toString();
4283         }
4284     }
4285 
4286     class InvisibleSymbolError extends InvalidSymbolError {
4287 
4288         private final Env&lt;AttrContext&gt; env;
4289         private final boolean suppressError;
4290 
4291         InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
4292             super(HIDDEN, sym, &quot;invisible class error&quot;);
4293             this.env = env;
4294             this.suppressError = suppressError;
4295             this.name = sym.name;
4296         }
4297 
4298         @Override
4299         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4300                 DiagnosticPosition pos,
4301                 Symbol location,
4302                 Type site,
4303                 Name name,
4304                 List&lt;Type&gt; argtypes,
4305                 List&lt;Type&gt; typeargtypes) {
4306             if (suppressError)
4307                 return null;
4308 
4309             if (sym.kind == PCK) {
4310                 JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4311                 return diags.create(dkind, log.currentSource(),
4312                         pos, &quot;package.not.visible&quot;, sym, details);
4313             }
4314 
4315             JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4316 
4317             if (pos.getTree() != null) {
4318                 Symbol o = sym;
4319                 JCTree tree = pos.getTree();
4320 
4321                 while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
4322                     o = o.owner;
4323                     tree = ((JCFieldAccess) tree).selected;
4324                 }
4325 
4326                 if (o.kind == PCK) {
4327                     pos = tree.pos();
4328 
4329                     return diags.create(dkind, log.currentSource(),
4330                             pos, &quot;package.not.visible&quot;, o, details);
4331                 }
4332             }
4333 
4334             return diags.create(dkind, log.currentSource(),
4335                     pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
4336         }
4337     }
4338 
4339     JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
4340         //no dependency:
4341         if (!env.toplevel.modle.readModules.contains(sym.modle)) {
4342             //does not read:
4343             if (sym.modle != syms.unnamedModule) {
4344                 if (env.toplevel.modle != syms.unnamedModule) {
4345                     return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
4346                                                                             sym,
4347                                                                             sym.modle));
4348                 } else {
4349                     return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
4350                                                                                        sym.modle));
4351                 }
4352             } else {
4353                 return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
4354                                                                                env.toplevel.modle));
4355             }
4356         } else {
4357             if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
4358                 //not exported to this module:
4359                 if (env.toplevel.modle != syms.unnamedModule) {
4360                     return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
4361                                                                                     sym.modle,
4362                                                                                     env.toplevel.modle));
4363                 } else {
4364                     return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,
4365                                                                                                sym.modle));
4366                 }
4367             } else {
4368                 //not exported:
4369                 if (env.toplevel.modle != syms.unnamedModule) {
4370                     return diags.fragment(Fragments.NotDefAccessNotExported(sym,
4371                                                                             sym.modle));
4372                 } else {
4373                     return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,
4374                                                                                        sym.modle));
4375                 }
4376             }
4377         }
4378     }
4379 
4380     /**
4381      * InvalidSymbolError error class indicating that an instance member
4382      * has erroneously been accessed from a static context.
4383      */
4384     class StaticError extends InvalidSymbolError {
4385 
4386         StaticError(Symbol sym) {
4387             super(STATICERR, sym, &quot;static error&quot;);
4388         }
4389 
4390         @Override
4391         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4392                 DiagnosticPosition pos,
4393                 Symbol location,
4394                 Type site,
4395                 Name name,
4396                 List&lt;Type&gt; argtypes,
4397                 List&lt;Type&gt; typeargtypes) {
4398             Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
4399                 ? types.erasure(sym.type).tsym
4400                 : sym);
4401             return diags.create(dkind, log.currentSource(), pos,
4402                     &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
4403         }
4404     }
4405 
4406     /**
4407      * InvalidSymbolError error class indicating that a pair of symbols
4408      * (either methods, constructors or operands) are ambiguous
4409      * given an actual arguments/type argument list.
4410      */
4411     class AmbiguityError extends ResolveError {
4412 
4413         /** The other maximally specific symbol */
4414         List&lt;Symbol&gt; ambiguousSyms = List.nil();
4415 
4416         @Override
4417         public boolean exists() {
4418             return true;
4419         }
4420 
4421         AmbiguityError(Symbol sym1, Symbol sym2) {
4422             super(AMBIGUOUS, &quot;ambiguity error&quot;);
4423             ambiguousSyms = flatten(sym2).appendList(flatten(sym1));
4424         }
4425 
4426         private List&lt;Symbol&gt; flatten(Symbol sym) {
4427             if (sym.kind == AMBIGUOUS) {
4428                 return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
4429             } else {
4430                 return List.of(sym);
4431             }
4432         }
4433 
4434         AmbiguityError addAmbiguousSymbol(Symbol s) {
4435             ambiguousSyms = ambiguousSyms.prepend(s);
4436             return this;
4437         }
4438 
4439         @Override
4440         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4441                 DiagnosticPosition pos,
4442                 Symbol location,
4443                 Type site,
4444                 Name name,
4445                 List&lt;Type&gt; argtypes,
4446                 List&lt;Type&gt; typeargtypes) {
4447             List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
4448             Symbol s1 = diagSyms.head;
4449             Symbol s2 = diagSyms.tail.head;
4450             Name sname = s1.name;
4451             if (sname == names.init) sname = s1.owner.name;
4452             return diags.create(dkind, log.currentSource(),
4453                     pos, &quot;ref.ambiguous&quot;, sname,
4454                     kindName(s1),
4455                     s1,
4456                     s1.location(site, types),
4457                     kindName(s2),
4458                     s2,
4459                     s2.location(site, types));
4460         }
4461 
4462         /**
4463          * If multiple applicable methods are found during overload and none of them
4464          * is more specific than the others, attempt to merge their signatures.
4465          */
4466         Symbol mergeAbstracts(Type site) {
4467             List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
4468             return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
4469         }
4470 
4471         @Override
4472         protected Symbol access(Name name, TypeSymbol location) {
4473             Symbol firstAmbiguity = ambiguousSyms.last();
4474             return firstAmbiguity.kind == TYP ?
4475                     types.createErrorType(name, location, firstAmbiguity.type).tsym :
4476                     firstAmbiguity;
4477         }
4478     }
4479 
4480     class BadVarargsMethod extends ResolveError {
4481 
4482         ResolveError delegatedError;
4483 
4484         BadVarargsMethod(ResolveError delegatedError) {
4485             super(delegatedError.kind, &quot;badVarargs&quot;);
4486             this.delegatedError = delegatedError;
4487         }
4488 
4489         @Override
4490         public Symbol baseSymbol() {
4491             return delegatedError.baseSymbol();
4492         }
4493 
4494         @Override
4495         protected Symbol access(Name name, TypeSymbol location) {
4496             return delegatedError.access(name, location);
4497         }
4498 
4499         @Override
4500         public boolean exists() {
4501             return true;
4502         }
4503 
4504         @Override
4505         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4506             return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
4507         }
4508     }
4509 
4510     /**
4511      * BadMethodReferenceError error class indicating that a method reference symbol has been found,
4512      * but with the wrong staticness.
4513      */
4514     class BadMethodReferenceError extends StaticError {
4515 
4516         boolean unboundLookup;
4517 
4518         public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
4519             super(sym);
4520             this.unboundLookup = unboundLookup;
4521         }
4522 
4523         @Override
4524         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4525             final String key;
4526             if (!unboundLookup) {
4527                 key = &quot;bad.static.method.in.bound.lookup&quot;;
4528             } else if (sym.isStatic()) {
4529                 key = &quot;bad.static.method.in.unbound.lookup&quot;;
4530             } else {
4531                 key = &quot;bad.instance.method.in.unbound.lookup&quot;;
4532             }
4533             return sym.kind.isResolutionError() ?
4534                     ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
4535                     diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
4536         }
4537     }
4538 
4539     /**
4540      * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
4541      * but pointing to a class for which an enclosing instance is not available.
4542      */
4543     class BadConstructorReferenceError extends InvalidSymbolError {
4544 
4545         public BadConstructorReferenceError(Symbol sym) {
4546             super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
4547         }
4548 
4549         @Override
4550         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4551            return diags.create(dkind, log.currentSource(), pos,
4552                 &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
4553         }
4554     }
4555 
4556     class BadClassFileError extends InvalidSymbolError {
4557 
4558         private final CompletionFailure ex;
4559 
4560         public BadClassFileError(CompletionFailure ex) {
4561             super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
4562             this.name = sym.name;
4563             this.ex = ex;
4564         }
4565 
4566         @Override
4567         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4568             JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
4569                 &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
4570 
4571             d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
4572             return d;
4573         }
4574 
4575     }
4576 
4577     /**
4578      * Helper class for method resolution diagnostic simplification.
4579      * Certain resolution diagnostic are rewritten as simpler diagnostic
4580      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4581      * is stripped away, as it doesn&#39;t carry additional info. The logic
4582      * for matching a given diagnostic is given in terms of a template
4583      * hierarchy: a diagnostic template can be specified programmatically,
4584      * so that only certain diagnostics are matched. Each templete is then
4585      * associated with a rewriter object that carries out the task of rewtiting
4586      * the diagnostic to a simpler one.
4587      */
4588     static class MethodResolutionDiagHelper {
4589 
4590         /**
4591          * A diagnostic rewriter transforms a method resolution diagnostic
4592          * into a simpler one
4593          */
4594         interface DiagnosticRewriter {
4595             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<a name="26" id="anc26"></a><span class="line-modified">4596                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,</span>
4597                     DiagnosticType preferredKind, JCDiagnostic d);
4598         }
4599 
4600         /**
4601          * A diagnostic template is made up of two ingredients: (i) a regular
4602          * expression for matching a diagnostic key and (ii) a list of sub-templates
4603          * for matching diagnostic arguments.
4604          */
4605         static class Template {
4606 
4607             /** regex used to match diag key */
4608             String regex;
4609 
4610             /** templates used to match diagnostic args */
4611             Template[] subTemplates;
4612 
4613             Template(String key, Template... subTemplates) {
4614                 this.regex = key;
4615                 this.subTemplates = subTemplates;
4616             }
4617 
4618             /**
4619              * Returns true if the regex matches the diagnostic key and if
4620              * all diagnostic arguments are matches by corresponding sub-templates.
4621              */
4622             boolean matches(Object o) {
4623                 JCDiagnostic d = (JCDiagnostic)o;
4624                 Object[] args = d.getArgs();
4625                 if (!d.getCode().matches(regex) ||
4626                         subTemplates.length != d.getArgs().length) {
4627                     return false;
4628                 }
4629                 for (int i = 0; i &lt; args.length ; i++) {
4630                     if (!subTemplates[i].matches(args[i])) {
4631                         return false;
4632                     }
4633                 }
4634                 return true;
4635             }
4636         }
4637 
4638         /**
4639          * Common rewriter for all argument mismatch simplifications.
4640          */
4641         static class ArgMismatchRewriter implements DiagnosticRewriter {
4642 
4643             /** the index of the subdiagnostic to be used as primary. */
4644             int causeIndex;
4645 
4646             public ArgMismatchRewriter(int causeIndex) {
4647                 this.causeIndex = causeIndex;
4648             }
4649 
4650             @Override
4651             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
<a name="27" id="anc27"></a><span class="line-modified">4652                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,</span>
4653                     DiagnosticType preferredKind, JCDiagnostic d) {
4654                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4655                 DiagnosticPosition pos = d.getDiagnosticPosition();
4656                 if (pos == null) {
<a name="28" id="anc28"></a><span class="line-modified">4657                     pos = preferredPos;</span>
4658                 }
4659                 return diags.create(preferredKind, preferredSource, pos,
4660                         &quot;prob.found.req&quot;, cause);
4661             }
4662         }
4663 
4664         /** a dummy template that match any diagnostic argument */
4665         static final Template skip = new Template(&quot;&quot;) {
4666             @Override
4667             boolean matches(Object d) {
4668                 return true;
4669             }
4670         };
4671 
4672         /** template for matching inference-free arguments mismatch failures */
4673         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4674 
4675         /** template for matching inference related arguments mismatch failures */
4676         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4677             @Override
4678             boolean matches(Object o) {
4679                 if (!super.matches(o)) {
4680                     return false;
4681                 }
4682                 JCDiagnostic d = (JCDiagnostic)o;
4683                 @SuppressWarnings(&quot;unchecked&quot;)
4684                 List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
4685                 return !containsAny(d, tvars);
4686             }
4687 
4688             BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
4689                 if (o instanceof Type) {
4690                     return ((Type)o).containsAny(ts);
4691                 } else if (o instanceof JCDiagnostic) {
4692                     return containsAny((JCDiagnostic)o, ts);
4693                 } else {
4694                     return false;
4695                 }
4696             };
4697 
4698             boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
4699                 return Stream.of(d.getArgs())
4700                         .anyMatch(o -&gt; containsPredicate.test(o, ts));
4701             }
4702         };
4703 
4704         /** rewriter map used for method resolution simplification */
4705         static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
4706 
4707         static {
4708             rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
4709             rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
4710         }
4711 
4712         /**
4713          * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
4714          * and rewrite it accordingly.
4715          */
4716         static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
4717                                     DiagnosticType dkind, JCDiagnostic d) {
4718             for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
4719                 if (_entry.getKey().matches(d)) {
4720                     JCDiagnostic simpleDiag =
4721                             _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
4722                     simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
4723                     return simpleDiag;
4724                 }
4725             }
4726             return null;
4727         }
4728     }
4729 
4730     enum MethodResolutionPhase {
4731         BASIC(false, false),
4732         BOX(true, false),
4733         VARARITY(true, true) {
4734             @Override
4735             public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
4736                 //Check invariants (see {@code LookupHelper.shouldStop})
4737                 Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
4738                 if (!sym.kind.isResolutionError()) {
4739                     //varargs resolution successful
4740                     return sym;
4741                 } else {
4742                     //pick best error
4743                     switch (bestSoFar.kind) {
4744                         case WRONG_MTH:
4745                         case WRONG_MTHS:
4746                             //Override previous errors if they were caused by argument mismatch.
4747                             //This generally means preferring current symbols - but we need to pay
4748                             //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
4749                             //than the previous rounds, and adjust that accordingly.
4750                             switch (sym.kind) {
4751                                 case WRONG_MTH:
4752                                     //if the previous round matched more than one method, return that
4753                                     //result instead
4754                                     return bestSoFar.kind == WRONG_MTHS ?
4755                                             bestSoFar : sym;
4756                                 case ABSENT_MTH:
4757                                     //do not override erroneous symbol if the arity lookup did not
4758                                     //match any method
4759                                     return bestSoFar;
4760                                 case WRONG_MTHS:
4761                                 default:
4762                                     //safe to override
4763                                     return sym;
4764                             }
4765                         default:
4766                             //otherwise, return first error
4767                             return bestSoFar;
4768                     }
4769                 }
4770             }
4771         };
4772 
4773         final boolean isBoxingRequired;
4774         final boolean isVarargsRequired;
4775 
4776         MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
4777            this.isBoxingRequired = isBoxingRequired;
4778            this.isVarargsRequired = isVarargsRequired;
4779         }
4780 
4781         public boolean isBoxingRequired() {
4782             return isBoxingRequired;
4783         }
4784 
4785         public boolean isVarargsRequired() {
4786             return isVarargsRequired;
4787         }
4788 
4789         public Symbol mergeResults(Symbol prev, Symbol sym) {
4790             return sym;
4791         }
4792     }
4793 
4794     final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
4795 
4796     /**
4797      * A resolution context is used to keep track of intermediate results of
4798      * overload resolution, such as list of method that are not applicable
4799      * (used to generate more precise diagnostics) and so on. Resolution contexts
4800      * can be nested - this means that when each overload resolution routine should
4801      * work within the resolution context it created.
4802      */
4803     class MethodResolutionContext {
4804 
4805         private List&lt;Candidate&gt; candidates = List.nil();
4806 
4807         MethodResolutionPhase step = null;
4808 
4809         MethodCheck methodCheck = resolveMethodCheck;
4810 
4811         private boolean internalResolution = false;
4812         private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
4813 
4814         void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
4815             Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
4816             candidates = candidates.append(c);
4817         }
4818 
4819         void addApplicableCandidate(Symbol sym, Type mtype) {
4820             Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
4821             candidates = candidates.append(c);
4822         }
4823 
4824         DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
4825             DeferredAttrContext parent = (pendingResult == null)
4826                 ? deferredAttr.emptyDeferredAttrContext
4827                 : pendingResult.checkContext.deferredAttrContext();
4828             return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
4829                     inferenceContext, parent, warn);
4830         }
4831 
4832         /**
4833          * This class represents an overload resolution candidate. There are two
4834          * kinds of candidates: applicable methods and inapplicable methods;
4835          * applicable methods have a pointer to the instantiated method type,
4836          * while inapplicable candidates contain further details about the
4837          * reason why the method has been considered inapplicable.
4838          */
4839         @SuppressWarnings(&quot;overrides&quot;)
4840         class Candidate {
4841 
4842             final MethodResolutionPhase step;
4843             final Symbol sym;
4844             final JCDiagnostic details;
4845             final Type mtype;
4846 
4847             private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
4848                 this.step = step;
4849                 this.sym = sym;
4850                 this.details = details;
4851                 this.mtype = mtype;
4852             }
4853 
4854             boolean isApplicable() {
4855                 return mtype != null;
4856             }
4857         }
4858 
4859         DeferredAttr.AttrMode attrMode() {
4860             return attrMode;
4861         }
4862 
4863         boolean internal() {
4864             return internalResolution;
4865         }
4866     }
4867 
4868     MethodResolutionContext currentResolutionContext = null;
4869 }
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
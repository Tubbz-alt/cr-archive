<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/code/TypeAnnotations.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import javax.lang.model.element.Element;
  29 import javax.lang.model.element.ElementKind;
  30 import javax.lang.model.type.TypeKind;
  31 import javax.tools.JavaFileObject;
  32 
  33 import com.sun.tools.javac.code.Attribute.Array;
  34 import com.sun.tools.javac.code.Attribute.TypeCompound;
  35 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  36 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  37 import com.sun.tools.javac.code.Type.ArrayType;
  38 import com.sun.tools.javac.code.Type.CapturedType;
  39 import com.sun.tools.javac.code.Type.ClassType;
  40 import com.sun.tools.javac.code.Type.ErrorType;
  41 import com.sun.tools.javac.code.Type.ForAll;
  42 import com.sun.tools.javac.code.Type.MethodType;
  43 import com.sun.tools.javac.code.Type.PackageType;
  44 import com.sun.tools.javac.code.Type.TypeVar;
  45 import com.sun.tools.javac.code.Type.UndetVar;
  46 import com.sun.tools.javac.code.Type.Visitor;
  47 import com.sun.tools.javac.code.Type.WildcardType;
  48 import com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntry;
  49 import com.sun.tools.javac.code.TypeAnnotationPosition.TypePathEntryKind;
  50 import com.sun.tools.javac.code.Symbol.VarSymbol;
  51 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  52 import com.sun.tools.javac.code.Type.ModuleType;
  53 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  54 import com.sun.tools.javac.comp.Annotate;
  55 import com.sun.tools.javac.comp.Attr;
  56 import com.sun.tools.javac.comp.AttrContext;
  57 import com.sun.tools.javac.comp.Env;
  58 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  59 import com.sun.tools.javac.tree.JCTree;
  60 import com.sun.tools.javac.tree.TreeInfo;
  61 import com.sun.tools.javac.tree.JCTree.JCBlock;
  62 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
  63 import com.sun.tools.javac.tree.JCTree.JCExpression;
  64 import com.sun.tools.javac.tree.JCTree.JCLambda;
  65 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
  66 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
  67 import com.sun.tools.javac.tree.JCTree.JCNewClass;
  68 import com.sun.tools.javac.tree.JCTree.JCTypeApply;
  69 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  70 import com.sun.tools.javac.tree.TreeScanner;
  71 import com.sun.tools.javac.tree.JCTree.*;
  72 import com.sun.tools.javac.util.Assert;
  73 import com.sun.tools.javac.util.Context;
  74 import com.sun.tools.javac.util.List;
  75 import com.sun.tools.javac.util.ListBuffer;
  76 import com.sun.tools.javac.util.Log;
  77 import com.sun.tools.javac.util.Names;
  78 
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 
  81 /**
  82  * Contains operations specific to processing type annotations.
  83  * This class has two functions:
  84  * separate declaration from type annotations and insert the type
  85  * annotations to their types;
  86  * and determine the TypeAnnotationPositions for all type annotations.
  87  */
  88 public class TypeAnnotations {
  89     protected static final Context.Key&lt;TypeAnnotations&gt; typeAnnosKey = new Context.Key&lt;&gt;();
  90 
  91     public static TypeAnnotations instance(Context context) {
  92         TypeAnnotations instance = context.get(typeAnnosKey);
  93         if (instance == null)
  94             instance = new TypeAnnotations(context);
  95         return instance;
  96     }
  97 
  98     final Log log;
  99     final Names names;
 100     final Symtab syms;
 101     final Annotate annotate;
 102     final Attr attr;
 103 
 104     protected TypeAnnotations(Context context) {
 105         context.put(typeAnnosKey, this);
 106         names = Names.instance(context);
 107         log = Log.instance(context);
 108         syms = Symtab.instance(context);
 109         annotate = Annotate.instance(context);
 110         attr = Attr.instance(context);
 111     }
 112 
 113     /**
 114      * Separate type annotations from declaration annotations and
 115      * determine the correct positions for type annotations.
 116      * This version only visits types in signatures and should be
 117      * called from MemberEnter.
 118      */
 119     public void organizeTypeAnnotationsSignatures(final Env&lt;AttrContext&gt; env, final JCClassDecl tree) {
 120         annotate.afterTypes(() -&gt; {
 121             JavaFileObject oldSource = log.useSource(env.toplevel.sourcefile);
 122             try {
 123                 new TypeAnnotationPositions(true).scan(tree);
 124             } finally {
 125                 log.useSource(oldSource);
 126             }
 127         });
 128     }
 129 
 130     public void validateTypeAnnotationsSignatures(final Env&lt;AttrContext&gt; env, final JCClassDecl tree) {
 131         annotate.validate(() -&gt; { //validate annotations
 132             JavaFileObject oldSource = log.useSource(env.toplevel.sourcefile);
 133             try {
 134                 attr.validateTypeAnnotations(tree, true);
 135             } finally {
 136                 log.useSource(oldSource);
 137             }
 138         });
 139     }
 140 
 141     /**
 142      * This version only visits types in bodies, that is, field initializers,
 143      * top-level blocks, and method bodies, and should be called from Attr.
 144      */
 145     public void organizeTypeAnnotationsBodies(JCClassDecl tree) {
 146         new TypeAnnotationPositions(false).scan(tree);
 147     }
 148 
 149     public enum AnnotationType { DECLARATION, TYPE, NONE, BOTH }
 150 
 151     public List&lt;Attribute&gt; annotationTargets(TypeSymbol tsym) {
 152         Attribute.Compound atTarget = tsym.getAnnotationTypeMetadata().getTarget();
 153         if (atTarget == null) {
 154             return null;
 155         }
 156 
 157         Attribute atValue = atTarget.member(names.value);
 158         if (!(atValue instanceof Attribute.Array)) {
 159             return null;
 160         }
 161 
 162         List&lt;Attribute&gt; targets = ((Array)atValue).getValue();
 163         if (targets.stream().anyMatch(a -&gt; !(a instanceof Attribute.Enum))) {
 164             return null;
 165         }
 166 
 167         return targets;
 168     }
 169 
 170     /**
 171      * Determine whether an annotation is a declaration annotation,
 172      * a type annotation, or both (or none, i.e a non-annotation masquerading as one).
 173      */
 174     public AnnotationType annotationTargetType(Attribute.Compound a, Symbol s) {
 175         if (!a.type.tsym.isAnnotationType()) {
 176             return AnnotationType.NONE;
 177         }
 178         List&lt;Attribute&gt; targets = annotationTargets(a.type.tsym);
 179         return (targets == null) ?
 180                 AnnotationType.DECLARATION :
 181                 targets.stream()
 182                         .map(attr -&gt; targetToAnnotationType(attr, s))
 183                         .reduce(AnnotationType.NONE, this::combineAnnotationType);
 184     }
 185 
 186     private AnnotationType combineAnnotationType(AnnotationType at1, AnnotationType at2) {
 187         if (at1 == AnnotationType.NONE) {
 188             return at2;
 189         } else if (at2 == AnnotationType.NONE) {
 190             return at1;
 191         } else if (at1 != at2) {
 192             return AnnotationType.BOTH;
 193         } else {
 194             return at1;
 195         }
 196     }
 197 
 198     private AnnotationType targetToAnnotationType(Attribute a, Symbol s) {
 199         Attribute.Enum e = (Attribute.Enum)a;
 200         if (e.value.name == names.TYPE) {
 201             if (s.kind == TYP)
 202                 return AnnotationType.DECLARATION;
 203         } else if (e.value.name == names.FIELD || e.value.name == names.RECORD_COMPONENT) {
 204             if (s.kind == VAR &amp;&amp;
 205                     s.owner.kind != MTH)
 206                 return AnnotationType.DECLARATION;
 207         } else if (e.value.name == names.METHOD) {
 208             if (s.kind == MTH &amp;&amp;
 209                     !s.isConstructor())
 210                 return AnnotationType.DECLARATION;
 211         } else if (e.value.name == names.PARAMETER) {
 212             if (s.kind == VAR &amp;&amp;
 213                     s.owner.kind == MTH &amp;&amp;
 214                     (s.flags() &amp; Flags.PARAMETER) != 0)
 215                 return AnnotationType.DECLARATION;
 216         } else if (e.value.name == names.CONSTRUCTOR) {
 217             if (s.kind == MTH &amp;&amp;
 218                     s.isConstructor())
 219                 return AnnotationType.DECLARATION;
 220         } else if (e.value.name == names.LOCAL_VARIABLE) {
 221             if (s.kind == VAR &amp;&amp;
 222                     s.owner.kind == MTH &amp;&amp;
 223                     (s.flags() &amp; Flags.PARAMETER) == 0)
 224                 return AnnotationType.DECLARATION;
 225         } else if (e.value.name == names.ANNOTATION_TYPE) {
 226             if (s.kind == TYP &amp;&amp;
 227                     (s.flags() &amp; Flags.ANNOTATION) != 0)
 228                 return AnnotationType.DECLARATION;
 229         } else if (e.value.name == names.PACKAGE) {
 230             if (s.kind == PCK)
 231                 return AnnotationType.DECLARATION;
 232         } else if (e.value.name == names.TYPE_USE) {
 233             if (s.kind == TYP ||
 234                     s.kind == VAR ||
 235                     (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
 236                     !s.type.getReturnType().hasTag(TypeTag.VOID)) ||
 237                     (s.kind == MTH &amp;&amp; s.isConstructor()))
 238                 return AnnotationType.TYPE;
 239         } else if (e.value.name == names.TYPE_PARAMETER) {
 240             /* Irrelevant in this case */
 241             // TYPE_PARAMETER doesn&#39;t aid in distinguishing between
 242             // Type annotations and declaration annotations on an
 243             // Element
 244         } else if (e.value.name == names.MODULE) {
 245             if (s.kind == MDL)
 246                 return AnnotationType.DECLARATION;
 247         } else {
 248             Assert.error(&quot;annotationTargetType(): unrecognized Attribute name &quot; + e.value.name +
 249                     &quot; (&quot; + e.value.name.getClass() + &quot;)&quot;);
 250             return AnnotationType.DECLARATION;
 251         }
 252         return AnnotationType.NONE;
 253     }
 254 
 255     private class TypeAnnotationPositions extends TreeScanner {
 256 
 257         private final boolean sigOnly;
 258 
 259         TypeAnnotationPositions(boolean sigOnly) {
 260             this.sigOnly = sigOnly;
 261         }
 262 
 263         /*
 264          * When traversing the AST we keep the &quot;frames&quot; of visited
 265          * trees in order to determine the position of annotations.
 266          */
 267         private List&lt;JCTree&gt; frames = List.nil();
 268 
 269         protected void push(JCTree t) {
 270             frames = frames.prepend(t);
 271         }
 272         protected JCTree pop() {
 273             JCTree t = frames.head;
 274             frames = frames.tail;
 275             return t;
 276             }
 277         // could this be frames.elems.tail.head?
 278         private JCTree peek2() {
 279             return frames.tail.head;
 280         }
 281 
 282         @Override
 283         public void scan(JCTree tree) {
 284             push(tree);
 285             try {
 286                 super.scan(tree);
 287             } finally {
 288                 pop();
 289             }
 290         }
 291 
 292         /**
 293          * Separates type annotations from declaration annotations.
 294          * This step is needed because in certain locations (where declaration
 295          * and type annotations can be mixed, e.g. the type of a field)
 296          * we never build an JCAnnotatedType. This step finds these
 297          * annotations and marks them as if they were part of the type.
 298          */
 299         private void separateAnnotationsKinds(JCTree typetree, Type type,
 300                                               Symbol sym, TypeAnnotationPosition pos)
 301         {
 302             List&lt;Attribute.Compound&gt; allAnnotations = sym.getRawAttributes();
 303             ListBuffer&lt;Attribute.Compound&gt; declAnnos = new ListBuffer&lt;&gt;();
 304             ListBuffer&lt;Attribute.TypeCompound&gt; typeAnnos = new ListBuffer&lt;&gt;();
 305             ListBuffer&lt;Attribute.TypeCompound&gt; onlyTypeAnnos = new ListBuffer&lt;&gt;();
 306 
 307             for (Attribute.Compound a : allAnnotations) {
 308                 switch (annotationTargetType(a, sym)) {
 309                     case DECLARATION:
 310                         declAnnos.append(a);
 311                         break;
 312                     case BOTH: {
 313                         declAnnos.append(a);
 314                         Attribute.TypeCompound ta = toTypeCompound(a, pos);
 315                         typeAnnos.append(ta);
 316                         break;
 317                     }
 318                     case TYPE: {
 319                         Attribute.TypeCompound ta = toTypeCompound(a, pos);
 320                         typeAnnos.append(ta);
 321                         // Also keep track which annotations are only type annotations
 322                         onlyTypeAnnos.append(ta);
 323                         break;
 324                     }
 325                     case NONE: // Error signaled already, just drop the non-annotation.
 326                         break;
 327                 }
 328             }
 329 
 330             // If we have no type annotations we are done for this Symbol
 331             if (typeAnnos.isEmpty()) {
 332                 return;
 333             }
 334 
 335             // Reset decl annotations to the set {all - type only}
 336             sym.resetAnnotations();
 337             sym.setDeclarationAttributes(declAnnos.toList());
 338 
 339             List&lt;Attribute.TypeCompound&gt; typeAnnotations = typeAnnos.toList();
 340 
 341             if (type == null) {
 342                 // When type is null, put the type annotations to the symbol.
 343                 // This is used for constructor return annotations, for which
 344                 // we use the type of the enclosing class.
 345                 type = sym.getEnclosingElement().asType();
 346 
 347                 // Declaration annotations are always allowed on constructor returns.
 348                 // Therefore, use typeAnnotations instead of onlyTypeAnnos.
 349                 typeWithAnnotations(typetree, type, typeAnnotations, typeAnnotations, pos);
 350                 // Note that we don&#39;t use the result, the call to
 351                 // typeWithAnnotations side-effects the type annotation positions.
 352                 // This is important for constructors of nested classes.
 353                 sym.appendUniqueTypeAttributes(typeAnnotations);
 354                 return;
 355             }
 356 
 357             // type is non-null, add type annotations from declaration context to the type
 358             type = typeWithAnnotations(typetree, type, typeAnnotations, onlyTypeAnnos.toList(), pos);
 359 
 360             if (sym.getKind() == ElementKind.METHOD) {
 361                 sym.type.asMethodType().restype = type;
 362             } else if (sym.getKind() == ElementKind.PARAMETER &amp;&amp; currentLambda == null) {
 363                 sym.type = type;
 364                 if (sym.getQualifiedName().equals(names._this)) {
 365                     sym.owner.type.asMethodType().recvtype = type;
 366                     // note that the typeAnnotations will also be added to the owner below.
 367                 } else {
 368                     MethodType methType = sym.owner.type.asMethodType();
 369                     List&lt;VarSymbol&gt; params = ((MethodSymbol)sym.owner).params;
 370                     List&lt;Type&gt; oldArgs = methType.argtypes;
 371                     ListBuffer&lt;Type&gt; newArgs = new ListBuffer&lt;&gt;();
 372                     while (params.nonEmpty()) {
 373                         if (params.head == sym) {
 374                             newArgs.add(type);
 375                         } else {
 376                             newArgs.add(oldArgs.head);
 377                         }
 378                         oldArgs = oldArgs.tail;
 379                         params = params.tail;
 380                     }
 381                     methType.argtypes = newArgs.toList();
 382                 }
 383             } else {
 384                 sym.type = type;
 385             }
 386 
 387             sym.appendUniqueTypeAttributes(typeAnnotations);
 388 
 389             if (sym.getKind() == ElementKind.PARAMETER ||
 390                 sym.getKind() == ElementKind.LOCAL_VARIABLE ||
 391                 sym.getKind() == ElementKind.RESOURCE_VARIABLE ||
 392                 sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {
 393                 appendTypeAnnotationsToOwner(sym, typeAnnotations);
 394             }
 395         }
 396 
 397         private void appendTypeAnnotationsToOwner(Symbol sym, List&lt;Attribute.TypeCompound&gt; typeAnnotations) {
 398             // Make sure all type annotations from the symbol are also
 399             // on the owner. If the owner is an initializer block, propagate
 400             // to the type.
 401             final long ownerFlags = sym.owner.flags();
 402             if ((ownerFlags &amp; Flags.BLOCK) != 0) {
 403                 // Store init and clinit type annotations with the ClassSymbol
 404                 // to allow output in Gen.normalizeDefs.
 405                 ClassSymbol cs = (ClassSymbol) sym.owner.owner;
 406                 if ((ownerFlags &amp; Flags.STATIC) != 0) {
 407                     cs.appendClassInitTypeAttributes(typeAnnotations);
 408                 } else {
 409                     cs.appendInitTypeAttributes(typeAnnotations);
 410                 }
 411             } else {
 412                 sym.owner.appendUniqueTypeAttributes(typeAnnotations);
 413             }
 414         }
 415 
 416         // This method has a similar purpose as
 417         // {@link com.sun.tools.javac.parser.JavacParser.insertAnnotationsToMostInner(JCExpression, List&lt;JCTypeAnnotation&gt;, boolean)}
 418         // We found a type annotation in a declaration annotation position,
 419         // for example, on the return type.
 420         // Such an annotation is _not_ part of an JCAnnotatedType tree and we therefore
 421         // need to set its position explicitly.
 422         // The method returns a copy of type that contains these annotations.
 423         //
 424         // As a side effect the method sets the type annotation position of &quot;annotations&quot;.
 425         // Note that it is assumed that all annotations share the same position.
 426         private Type typeWithAnnotations(final JCTree typetree, final Type type,
 427                 final List&lt;Attribute.TypeCompound&gt; annotations,
 428                 final List&lt;Attribute.TypeCompound&gt; onlyTypeAnnotations,
 429                 final TypeAnnotationPosition pos)
 430         {
 431             if (annotations.isEmpty()) {
 432                 return type;
 433             }
 434             // All annotations share the same position
 435             for (TypeCompound tc : annotations) {
 436                 Assert.check(tc.position == pos);
 437             }
 438 
 439             if (type.hasTag(TypeTag.ARRAY))
 440                 return rewriteArrayType((ArrayType)type, annotations, pos);
 441 
 442             if (type.hasTag(TypeTag.TYPEVAR)) {
 443                 return type.annotatedType(onlyTypeAnnotations);
 444             } else if (type.getKind() == TypeKind.UNION) {
 445                 // There is a TypeKind, but no TypeTag.
 446                 JCTypeUnion tutree = (JCTypeUnion)typetree;
 447                 JCExpression fst = tutree.alternatives.get(0);
 448                 Type res = typeWithAnnotations(fst, fst.type, annotations, onlyTypeAnnotations, pos);
 449                 fst.type = res;
 450                 // TODO: do we want to set res as first element in uct.alternatives?
 451                 // UnionClassType uct = (com.sun.tools.javac.code.Type.UnionClassType)type;
 452                 // Return the un-annotated union-type.
 453                 return type;
 454             } else {
 455                 Type enclTy = type;
 456                 Element enclEl = type.asElement();
 457                 JCTree enclTr = typetree;
 458 
 459                 while (enclEl != null &amp;&amp;
 460                         enclEl.getKind() != ElementKind.PACKAGE &amp;&amp;
 461                         enclTy != null &amp;&amp;
 462                         enclTy.getKind() != TypeKind.NONE &amp;&amp;
 463                         enclTy.getKind() != TypeKind.ERROR &amp;&amp;
 464                         (enclTr.getKind() == JCTree.Kind.MEMBER_SELECT ||
 465                                 enclTr.getKind() == JCTree.Kind.PARAMETERIZED_TYPE ||
 466                                 enclTr.getKind() == JCTree.Kind.ANNOTATED_TYPE)) {
 467                     // Iterate also over the type tree, not just the type: the type is already
 468                     // completely resolved and we cannot distinguish where the annotation
 469                     // belongs for a nested type.
 470                     if (enclTr.getKind() == JCTree.Kind.MEMBER_SELECT) {
 471                         // only change encl in this case.
 472                         enclTy = enclTy.getEnclosingType();
 473                         enclEl = enclEl.getEnclosingElement();
 474                         enclTr = ((JCFieldAccess)enclTr).getExpression();
 475                     } else if (enclTr.getKind() == JCTree.Kind.PARAMETERIZED_TYPE) {
 476                         enclTr = ((JCTypeApply)enclTr).getType();
 477                     } else {
 478                         // only other option because of while condition
 479                         enclTr = ((JCAnnotatedType)enclTr).getUnderlyingType();
 480                     }
 481                 }
 482 
 483                 /** We are trying to annotate some enclosing type,
 484                  * but nothing more exists.
 485                  */
 486                 if (enclTy != null &amp;&amp;
 487                         enclTy.hasTag(TypeTag.NONE)) {
 488                     switch (onlyTypeAnnotations.size()) {
 489                         case 0:
 490                             // Don&#39;t issue an error if all type annotations are
 491                             // also declaration annotations.
 492                             // If the annotations are also declaration annotations, they are
 493                             // illegal as type annotations but might be legal as declaration annotations.
 494                             // The normal declaration annotation checks make sure that the use is valid.
 495                             break;
 496                         case 1:
 497                             log.error(typetree.pos(),
 498                                       Errors.CantTypeAnnotateScoping1(onlyTypeAnnotations.head));
 499                             break;
 500                         default:
 501                             log.error(typetree.pos(),
 502                                       Errors.CantTypeAnnotateScoping(onlyTypeAnnotations));
 503                     }
 504                     return type;
 505                 }
 506 
 507                 // At this point we have visited the part of the nested
 508                 // type that is written in the source code.
 509                 // Now count from here to the actual top-level class to determine
 510                 // the correct nesting.
 511 
 512                 // The genericLocation for the annotation.
 513                 ListBuffer&lt;TypePathEntry&gt; depth = new ListBuffer&lt;&gt;();
 514 
 515                 Type topTy = enclTy;
 516                 while (enclEl != null &amp;&amp;
 517                         enclEl.getKind() != ElementKind.PACKAGE &amp;&amp;
 518                         topTy != null &amp;&amp;
 519                         topTy.getKind() != TypeKind.NONE &amp;&amp;
 520                         topTy.getKind() != TypeKind.ERROR) {
 521                     topTy = topTy.getEnclosingType();
 522                     enclEl = enclEl.getEnclosingElement();
 523 
 524                     if (topTy != null &amp;&amp; topTy.getKind() != TypeKind.NONE) {
 525                         // Only count enclosing types.
 526                         depth = depth.append(TypePathEntry.INNER_TYPE);
 527                     }
 528                 }
 529 
 530                 if (depth.nonEmpty()) {
 531                     // Only need to change the annotation positions
 532                     // if they are on an enclosed type.
 533                     pos.location = pos.location.appendList(depth.toList());
 534                 }
 535 
 536                 Type ret = typeWithAnnotations(type, enclTy, annotations);
 537                 typetree.type = ret;
 538                 return ret;
 539             }
 540         }
 541 
 542         /**
 543          * Create a copy of the {@code Type type} with the help of the Tree for a type
 544          * {@code JCTree typetree} inserting all type annotations in {@code annotations} to the
 545          * innermost array component type.
 546          *
 547          * SIDE EFFECT: Update position for the annotations to be {@code pos}.
 548          */
 549         private Type rewriteArrayType(ArrayType type, List&lt;TypeCompound&gt; annotations, TypeAnnotationPosition pos) {
 550             ArrayType tomodify = new ArrayType(type);
 551             ArrayType res = tomodify;
 552 
 553             List&lt;TypePathEntry&gt; loc = List.nil();
 554 
 555             // peel one and update loc
 556             Type tmpType = type.elemtype;
 557             loc = loc.prepend(TypePathEntry.ARRAY);
 558 
 559             while (tmpType.hasTag(TypeTag.ARRAY)) {
 560                 ArrayType arr = (ArrayType)tmpType;
 561 
 562                 // Update last type with new element type
 563                 ArrayType tmp = new ArrayType(arr);
 564                 tomodify.elemtype = tmp;
 565                 tomodify = tmp;
 566 
 567                 tmpType = arr.elemtype;
 568                 loc = loc.prepend(TypePathEntry.ARRAY);
 569             }
 570 
 571             // Fix innermost element type
 572             Type elemType;
 573             if (tmpType.getMetadata() != null) {
 574                 List&lt;TypeCompound&gt; tcs;
 575                 if (tmpType.getAnnotationMirrors().isEmpty()) {
 576                     tcs = annotations;
 577                 } else {
 578                     // Special case, lets prepend
 579                     tcs =  annotations.appendList(tmpType.getAnnotationMirrors());
 580                 }
 581                 elemType = tmpType.cloneWithMetadata(tmpType
 582                         .getMetadata()
 583                         .without(Kind.ANNOTATIONS)
 584                         .combine(new TypeMetadata.Annotations(tcs)));
 585             } else {
 586                 elemType = tmpType.cloneWithMetadata(new TypeMetadata(new TypeMetadata.Annotations(annotations)));
 587             }
 588             tomodify.elemtype = elemType;
 589 
 590             // Update positions
 591             pos.location = loc;
 592 
 593             return res;
 594         }
 595 
 596         /** Return a copy of the first type that only differs by
 597          * inserting the annotations to the left-most/inner-most type
 598          * or the type given by stopAt.
 599          *
 600          * We need the stopAt parameter to know where on a type to
 601          * put the annotations.
 602          * If we have nested classes Outer &gt; Middle &gt; Inner, and we
 603          * have the source type &quot;@A Middle.Inner&quot;, we will invoke
 604          * this method with type = Outer.Middle.Inner,
 605          * stopAt = Middle.Inner, and annotations = @A.
 606          *
 607          * @param type The type to copy.
 608          * @param stopAt The type to stop at.
 609          * @param annotations The annotations to insert.
 610          * @return A copy of type that contains the annotations.
 611          */
 612         private Type typeWithAnnotations(final Type type,
 613                 final Type stopAt,
 614                 final List&lt;Attribute.TypeCompound&gt; annotations) {
 615             Visitor&lt;Type, List&lt;TypeCompound&gt;&gt; visitor =
 616                     new Type.Visitor&lt;Type, List&lt;Attribute.TypeCompound&gt;&gt;() {
 617                 @Override
 618                 public Type visitClassType(ClassType t, List&lt;TypeCompound&gt; s) {
 619                     // assert that t.constValue() == null?
 620                     if (t == stopAt ||
 621                         t.getEnclosingType() == Type.noType) {
 622                         return t.annotatedType(s);
 623                     } else {
 624                         ClassType ret = new ClassType(t.getEnclosingType().accept(this, s),
 625                                                       t.typarams_field, t.tsym,
 626                                                       t.getMetadata());
 627                         ret.all_interfaces_field = t.all_interfaces_field;
 628                         ret.allparams_field = t.allparams_field;
 629                         ret.interfaces_field = t.interfaces_field;
 630                         ret.rank_field = t.rank_field;
 631                         ret.supertype_field = t.supertype_field;
 632                         return ret;
 633                     }
 634                 }
 635 
 636                 @Override
 637                 public Type visitWildcardType(WildcardType t, List&lt;TypeCompound&gt; s) {
 638                     return t.annotatedType(s);
 639                 }
 640 
 641                 @Override
 642                 public Type visitArrayType(ArrayType t, List&lt;TypeCompound&gt; s) {
 643                     ArrayType ret = new ArrayType(t.elemtype.accept(this, s), t.tsym,
 644                                                   t.getMetadata());
 645                     return ret;
 646                 }
 647 
 648                 @Override
 649                 public Type visitMethodType(MethodType t, List&lt;TypeCompound&gt; s) {
 650                     // Impossible?
 651                     return t;
 652                 }
 653 
 654                 @Override
 655                 public Type visitPackageType(PackageType t, List&lt;TypeCompound&gt; s) {
 656                     // Impossible?
 657                     return t;
 658                 }
 659 
 660                 @Override
 661                 public Type visitTypeVar(TypeVar t, List&lt;TypeCompound&gt; s) {
 662                     return t.annotatedType(s);
 663                 }
 664 
 665                 @Override
 666                 public Type visitModuleType(ModuleType t, List&lt;TypeCompound&gt; s) {
 667                     return t.annotatedType(s);
 668                 }
 669 
 670                 @Override
 671                 public Type visitCapturedType(CapturedType t, List&lt;TypeCompound&gt; s) {
 672                     return t.annotatedType(s);
 673                 }
 674 
 675                 @Override
 676                 public Type visitForAll(ForAll t, List&lt;TypeCompound&gt; s) {
 677                     // Impossible?
 678                     return t;
 679                 }
 680 
 681                 @Override
 682                 public Type visitUndetVar(UndetVar t, List&lt;TypeCompound&gt; s) {
 683                     // Impossible?
 684                     return t;
 685                 }
 686 
 687                 @Override
 688                 public Type visitErrorType(ErrorType t, List&lt;TypeCompound&gt; s) {
 689                     return t.annotatedType(s);
 690                 }
 691 
 692                 @Override
 693                 public Type visitType(Type t, List&lt;TypeCompound&gt; s) {
 694                     return t.annotatedType(s);
 695                 }
 696             };
 697 
 698             return type.accept(visitor, annotations);
 699         }
 700 
 701         private Attribute.TypeCompound toTypeCompound(Attribute.Compound a, TypeAnnotationPosition p) {
 702             // It is safe to alias the position.
 703             return new Attribute.TypeCompound(a, p);
 704         }
 705 
 706 
 707         /* This is the beginning of the second part of organizing
 708          * type annotations: determine the type annotation positions.
 709          */
 710         private TypeAnnotationPosition
 711             resolveFrame(JCTree tree,
 712                          JCTree frame,
 713                          List&lt;JCTree&gt; path,
 714                          JCLambda currentLambda,
 715                          int outer_type_index,
 716                          ListBuffer&lt;TypePathEntry&gt; location)
 717         {
 718 
 719             // Note that p.offset is set in
 720             // com.sun.tools.javac.jvm.Gen.setTypeAnnotationPositions(int)
 721 
 722             switch (frame.getKind()) {
 723                 case TYPE_CAST:
 724                     return TypeAnnotationPosition.typeCast(location.toList(),
 725                                                            currentLambda,
 726                                                            outer_type_index,
 727                                                            frame.pos);
 728 
 729                 case INSTANCE_OF:
 730                     return TypeAnnotationPosition.instanceOf(location.toList(),
 731                                                              currentLambda,
 732                                                              frame.pos);
 733 
 734                 case NEW_CLASS:
 735                     final JCNewClass frameNewClass = (JCNewClass) frame;
 736                     if (frameNewClass.def != null) {
 737                         // Special handling for anonymous class instantiations
 738                         final JCClassDecl frameClassDecl = frameNewClass.def;
 739                         if (frameClassDecl.implementing.contains(tree)) {
 740                             final int type_index =
 741                                 frameClassDecl.implementing.indexOf(tree);
 742                             return TypeAnnotationPosition
 743                                 .classExtends(location.toList(), currentLambda,
 744                                               type_index, frame.pos);
 745                         } else {
 746                             //for encl.new @TA Clazz(), tree may be different from frameClassDecl.extending
 747                             return TypeAnnotationPosition
 748                                 .classExtends(location.toList(), currentLambda,
 749                                               frame.pos);
 750                         }
 751                     } else if (frameNewClass.typeargs.contains(tree)) {
 752                         final int type_index =
 753                             frameNewClass.typeargs.indexOf(tree);
 754                         return TypeAnnotationPosition
 755                             .constructorInvocationTypeArg(location.toList(),
 756                                                           currentLambda,
 757                                                           type_index,
 758                                                           frame.pos);
 759                     } else {
 760                         return TypeAnnotationPosition
 761                             .newObj(location.toList(), currentLambda,
 762                                     frame.pos);
 763                     }
 764 
 765                 case NEW_ARRAY:
 766                     return TypeAnnotationPosition
 767                         .newObj(location.toList(), currentLambda, frame.pos);
 768 
 769                 case ANNOTATION_TYPE:
 770                 case CLASS:
 771                 case ENUM:
 772                 case INTERFACE:
 773                 case RECORD:
 774                     if (((JCClassDecl)frame).extending == tree) {
 775                         return TypeAnnotationPosition
 776                             .classExtends(location.toList(), currentLambda,
 777                                           frame.pos);
 778                     } else if (((JCClassDecl)frame).implementing.contains(tree)) {
 779                         final int type_index =
 780                             ((JCClassDecl)frame).implementing.indexOf(tree);
 781                         return TypeAnnotationPosition
 782                             .classExtends(location.toList(), currentLambda,
 783                                           type_index, frame.pos);
 784                     } else if (((JCClassDecl)frame).typarams.contains(tree)) {
 785                         final int parameter_index =
 786                             ((JCClassDecl)frame).typarams.indexOf(tree);
 787                         return TypeAnnotationPosition
 788                             .typeParameter(location.toList(), currentLambda,
 789                                            parameter_index, frame.pos);
 790                     } else {
 791                         throw new AssertionError(&quot;Could not determine position of tree &quot; +
 792                                                  tree + &quot; within frame &quot; + frame);
 793                     }
 794 
 795                 case METHOD: {
 796                     final JCMethodDecl frameMethod = (JCMethodDecl) frame;
 797                     if (frameMethod.thrown.contains(tree)) {
 798                         final int type_index = frameMethod.thrown.indexOf(tree);
 799                         return TypeAnnotationPosition
 800                             .methodThrows(location.toList(), currentLambda,
 801                                           type_index, frame.pos);
 802                     } else if (frameMethod.restype == tree) {
 803                         return TypeAnnotationPosition
 804                             .methodReturn(location.toList(), currentLambda,
 805                                           frame.pos);
 806                     } else if (frameMethod.typarams.contains(tree)) {
 807                         final int parameter_index =
 808                             frameMethod.typarams.indexOf(tree);
 809                         return TypeAnnotationPosition
 810                             .methodTypeParameter(location.toList(),
 811                                                  currentLambda,
 812                                                  parameter_index, frame.pos);
 813                     } else {
 814                         throw new AssertionError(&quot;Could not determine position of tree &quot; + tree +
 815                                                  &quot; within frame &quot; + frame);
 816                     }
 817                 }
 818 
 819                 case PARAMETERIZED_TYPE: {
 820                     List&lt;JCTree&gt; newPath = path.tail;
 821 
 822                     if (((JCTypeApply)frame).clazz == tree) {
 823                         // generic: RAW; noop
 824                     } else if (((JCTypeApply)frame).arguments.contains(tree)) {
 825                         JCTypeApply taframe = (JCTypeApply) frame;
 826                         int arg = taframe.arguments.indexOf(tree);
 827                         location = location.prepend(
 828                             new TypePathEntry(TypePathEntryKind.TYPE_ARGUMENT,
 829                                               arg));
 830 
 831                         Type typeToUse;
 832                         if (newPath.tail != null &amp;&amp;
 833                             newPath.tail.head.hasTag(Tag.NEWCLASS)) {
 834                             // If we are within an anonymous class
 835                             // instantiation, use its type, because it
 836                             // contains a correctly nested type.
 837                             typeToUse = newPath.tail.head.type;
 838                         } else {
 839                             typeToUse = taframe.type;
 840                         }
 841 
 842                         location = locateNestedTypes(typeToUse, location);
 843                     } else {
 844                         throw new AssertionError(&quot;Could not determine type argument position of tree &quot; + tree +
 845                                                  &quot; within frame &quot; + frame);
 846                     }
 847 
 848                     return resolveFrame(newPath.head, newPath.tail.head,
 849                                         newPath, currentLambda,
 850                                         outer_type_index, location);
 851                 }
 852 
 853                 case MEMBER_REFERENCE: {
 854                     JCMemberReference mrframe = (JCMemberReference) frame;
 855 
 856                     if (mrframe.expr == tree) {
 857                         switch (mrframe.mode) {
 858                         case INVOKE:
 859                             return TypeAnnotationPosition
 860                                 .methodRef(location.toList(), currentLambda,
 861                                            frame.pos);
 862                         case NEW:
 863                             return TypeAnnotationPosition
 864                                 .constructorRef(location.toList(),
 865                                                 currentLambda,
 866                                                 frame.pos);
 867                         default:
 868                             throw new AssertionError(&quot;Unknown method reference mode &quot; + mrframe.mode +
 869                                                      &quot; for tree &quot; + tree + &quot; within frame &quot; + frame);
 870                         }
 871                     } else if (mrframe.typeargs != null &amp;&amp;
 872                             mrframe.typeargs.contains(tree)) {
 873                         final int type_index = mrframe.typeargs.indexOf(tree);
 874                         switch (mrframe.mode) {
 875                         case INVOKE:
 876                             return TypeAnnotationPosition
 877                                 .methodRefTypeArg(location.toList(),
 878                                                   currentLambda,
 879                                                   type_index, frame.pos);
 880                         case NEW:
 881                             return TypeAnnotationPosition
 882                                 .constructorRefTypeArg(location.toList(),
 883                                                        currentLambda,
 884                                                        type_index, frame.pos);
 885                         default:
 886                             throw new AssertionError(&quot;Unknown method reference mode &quot; + mrframe.mode +
 887                                                    &quot; for tree &quot; + tree + &quot; within frame &quot; + frame);
 888                         }
 889                     } else {
 890                         throw new AssertionError(&quot;Could not determine type argument position of tree &quot; + tree +
 891                                                &quot; within frame &quot; + frame);
 892                     }
 893                 }
 894 
 895                 case ARRAY_TYPE: {
 896                     location = location.prepend(TypePathEntry.ARRAY);
 897                     List&lt;JCTree&gt; newPath = path.tail;
 898                     while (true) {
 899                         JCTree npHead = newPath.tail.head;
 900                         if (npHead.hasTag(JCTree.Tag.TYPEARRAY)) {
 901                             newPath = newPath.tail;
 902                             location = location.prepend(TypePathEntry.ARRAY);
 903                         } else if (npHead.hasTag(JCTree.Tag.ANNOTATED_TYPE)) {
 904                             newPath = newPath.tail;
 905                         } else {
 906                             break;
 907                         }
 908                     }
 909                     return resolveFrame(newPath.head, newPath.tail.head,
 910                                         newPath, currentLambda,
 911                                         outer_type_index, location);
 912                 }
 913 
 914                 case TYPE_PARAMETER:
 915                     if (path.tail.tail.head.hasTag(JCTree.Tag.CLASSDEF)) {
 916                         final JCClassDecl clazz =
 917                             (JCClassDecl)path.tail.tail.head;
 918                         final int parameter_index =
 919                             clazz.typarams.indexOf(path.tail.head);
 920                         final int bound_index =
 921                             ((JCTypeParameter)frame).bounds.get(0)
 922                             .type.isInterface() ?
 923                             ((JCTypeParameter)frame).bounds.indexOf(tree) + 1:
 924                             ((JCTypeParameter)frame).bounds.indexOf(tree);
 925                         return TypeAnnotationPosition
 926                             .typeParameterBound(location.toList(),
 927                                                 currentLambda,
 928                                                 parameter_index, bound_index,
 929                                                 frame.pos);
 930                     } else if (path.tail.tail.head.hasTag(JCTree.Tag.METHODDEF)) {
 931                         final JCMethodDecl method =
 932                             (JCMethodDecl)path.tail.tail.head;
 933                         final int parameter_index =
 934                             method.typarams.indexOf(path.tail.head);
 935                         final int bound_index =
 936                             ((JCTypeParameter)frame).bounds.get(0)
 937                             .type.isInterface() ?
 938                             ((JCTypeParameter)frame).bounds.indexOf(tree) + 1:
 939                             ((JCTypeParameter)frame).bounds.indexOf(tree);
 940                         return TypeAnnotationPosition
 941                             .methodTypeParameterBound(location.toList(),
 942                                                       currentLambda,
 943                                                       parameter_index,
 944                                                       bound_index,
 945                                                       frame.pos);
 946                     } else {
 947                         throw new AssertionError(&quot;Could not determine position of tree &quot; + tree +
 948                                                  &quot; within frame &quot; + frame);
 949                     }
 950 
 951                 case BINDING_PATTERN:
 952                 case VARIABLE:
 953                     VarSymbol v = frame.hasTag(Tag.BINDINGPATTERN) ? ((JCBindingPattern) frame).symbol : ((JCVariableDecl) frame).sym;
 954                     if (v.getKind() != ElementKind.FIELD) {
 955                         appendTypeAnnotationsToOwner(v, v.getRawTypeAttributes());
 956                     }
 957                     switch (v.getKind()) {
 958                         case BINDING_VARIABLE:
 959                         case LOCAL_VARIABLE:
 960                             return TypeAnnotationPosition
 961                                 .localVariable(location.toList(), currentLambda,
 962                                                frame.pos);
 963                         case FIELD:
 964                             return TypeAnnotationPosition.field(location.toList(),
 965                                                                 currentLambda,
 966                                                                 frame.pos);
 967                         case PARAMETER:
 968                             if (v.getQualifiedName().equals(names._this)) {
 969                                 return TypeAnnotationPosition
 970                                     .methodReceiver(location.toList(),
 971                                                     currentLambda,
 972                                                     frame.pos);
 973                             } else {
 974                                 final int parameter_index =
 975                                     methodParamIndex(path, frame);
 976                                 return TypeAnnotationPosition
 977                                     .methodParameter(location.toList(),
 978                                                      currentLambda,
 979                                                      parameter_index,
 980                                                      frame.pos);
 981                             }
 982                         case EXCEPTION_PARAMETER:
 983                             return TypeAnnotationPosition
 984                                 .exceptionParameter(location.toList(),
 985                                                     currentLambda,
 986                                                     frame.pos);
 987                         case RESOURCE_VARIABLE:
 988                             return TypeAnnotationPosition
 989                                 .resourceVariable(location.toList(),
 990                                                   currentLambda,
 991                                                   frame.pos);
 992                         default:
 993                             throw new AssertionError(&quot;Found unexpected type annotation for variable: &quot; + v + &quot; with kind: &quot; + v.getKind());
 994                     }
 995 
 996                 case ANNOTATED_TYPE: {
 997                     if (frame == tree) {
 998                         // This is only true for the first annotated type we see.
 999                         // For any other annotated types along the path, we do
1000                         // not care about inner types.
1001                         JCAnnotatedType atypetree = (JCAnnotatedType) frame;
1002                         final Type utype = atypetree.underlyingType.type;
1003                         Assert.checkNonNull(utype);
1004                         Symbol tsym = utype.tsym;
1005                         if (tsym.getKind().equals(ElementKind.TYPE_PARAMETER) ||
1006                                 utype.getKind().equals(TypeKind.WILDCARD) ||
1007                                 utype.getKind().equals(TypeKind.ARRAY)) {
1008                             // Type parameters, wildcards, and arrays have the declaring
1009                             // class/method as enclosing elements.
1010                             // There is actually nothing to do for them.
1011                         } else {
1012                             location = locateNestedTypes(utype, location);
1013                         }
1014                     }
1015                     List&lt;JCTree&gt; newPath = path.tail;
1016                     return resolveFrame(newPath.head, newPath.tail.head,
1017                                         newPath, currentLambda,
1018                                         outer_type_index, location);
1019                 }
1020 
1021                 case UNION_TYPE: {
1022                     List&lt;JCTree&gt; newPath = path.tail;
1023                     return resolveFrame(newPath.head, newPath.tail.head,
1024                                         newPath, currentLambda,
1025                                         outer_type_index, location);
1026                 }
1027 
1028                 case INTERSECTION_TYPE: {
1029                     JCTypeIntersection isect = (JCTypeIntersection)frame;
1030                     final List&lt;JCTree&gt; newPath = path.tail;
1031                     return resolveFrame(newPath.head, newPath.tail.head,
1032                                         newPath, currentLambda,
1033                                         isect.bounds.indexOf(tree), location);
1034                 }
1035 
1036                 case METHOD_INVOCATION: {
1037                     JCMethodInvocation invocation = (JCMethodInvocation)frame;
1038                     if (!invocation.typeargs.contains(tree)) {
1039                         return TypeAnnotationPosition.unknown;
1040                     }
1041                     MethodSymbol exsym = (MethodSymbol) TreeInfo.symbol(invocation.getMethodSelect());
1042                     final int type_index = invocation.typeargs.indexOf(tree);
1043                     if (exsym == null) {
1044                         throw new AssertionError(&quot;could not determine symbol for {&quot; + invocation + &quot;}&quot;);
1045                     } else if (exsym.isConstructor()) {
1046                         return TypeAnnotationPosition
1047                             .constructorInvocationTypeArg(location.toList(),
1048                                                           currentLambda,
1049                                                           type_index,
1050                                                           invocation.pos);
1051                     } else {
1052                         return TypeAnnotationPosition
1053                             .methodInvocationTypeArg(location.toList(),
1054                                                      currentLambda,
1055                                                      type_index,
1056                                                      invocation.pos);
1057                     }
1058                 }
1059 
1060                 case EXTENDS_WILDCARD:
1061                 case SUPER_WILDCARD: {
1062                     // Annotations in wildcard bounds
1063                     final List&lt;JCTree&gt; newPath = path.tail;
1064                     return resolveFrame(newPath.head, newPath.tail.head,
1065                                         newPath, currentLambda,
1066                                         outer_type_index,
1067                                         location.prepend(TypePathEntry.WILDCARD));
1068                 }
1069 
1070                 case MEMBER_SELECT: {
1071                     final List&lt;JCTree&gt; newPath = path.tail;
1072                     return resolveFrame(newPath.head, newPath.tail.head,
1073                                         newPath, currentLambda,
1074                                         outer_type_index, location);
1075                 }
1076 
1077                 default:
1078                     throw new AssertionError(&quot;Unresolved frame: &quot; + frame +
1079                                              &quot; of kind: &quot; + frame.getKind() +
1080                                              &quot;\n    Looking for tree: &quot; + tree);
1081             }
1082         }
1083 
1084         private ListBuffer&lt;TypePathEntry&gt;
1085             locateNestedTypes(Type type,
1086                               ListBuffer&lt;TypePathEntry&gt; depth) {
1087             Type encl = type.getEnclosingType();
1088             while (encl != null &amp;&amp;
1089                     encl.getKind() != TypeKind.NONE &amp;&amp;
1090                     encl.getKind() != TypeKind.ERROR) {
1091                 depth = depth.prepend(TypePathEntry.INNER_TYPE);
1092                 encl = encl.getEnclosingType();
1093             }
1094             return depth;
1095         }
1096 
1097         private int methodParamIndex(List&lt;JCTree&gt; path, JCTree param) {
1098             List&lt;JCTree&gt; curr = path;
1099             while (curr.head.getTag() != Tag.METHODDEF &amp;&amp;
1100                     curr.head.getTag() != Tag.LAMBDA) {
1101                 curr = curr.tail;
1102             }
1103             if (curr.head.getTag() == Tag.METHODDEF) {
1104                 JCMethodDecl method = (JCMethodDecl)curr.head;
1105                 return method.params.indexOf(param);
1106             } else if (curr.head.getTag() == Tag.LAMBDA) {
1107                 JCLambda lambda = (JCLambda)curr.head;
1108                 return lambda.params.indexOf(param);
1109             } else {
1110                 Assert.error(&quot;methodParamIndex expected to find method or lambda for param: &quot; + param);
1111                 return -1;
1112             }
1113         }
1114 
1115         // Each class (including enclosed inner classes) is visited separately.
1116         // This flag is used to prevent from visiting inner classes.
1117         private boolean isInClass = false;
1118 
1119         @Override
1120         public void visitClassDef(JCClassDecl tree) {
1121             if (isInClass)
1122                 return;
1123             isInClass = true;
1124 
1125             if (sigOnly) {
1126                 scan(tree.mods);
1127                 scan(tree.typarams);
1128                 scan(tree.extending);
1129                 scan(tree.implementing);
1130             }
1131             scan(tree.defs);
1132             if (tree.sym.isRecord()) {
1133                 tree.sym.getRecordComponents().stream().forEach(rc -&gt; scan(rc.accessorMeth));
1134             }
1135         }
1136 
1137         /**
1138          * Resolve declaration vs. type annotations in methods and
1139          * then determine the positions.
1140          */
1141         @Override
1142         public void visitMethodDef(final JCMethodDecl tree) {
1143             if (tree.sym == null) {
1144                 Assert.error(&quot;Visiting tree node before memberEnter&quot;);
1145             }
1146             if (sigOnly) {
1147                 if (!tree.mods.annotations.isEmpty()) {
1148                     if (tree.sym.isConstructor()) {
1149                         final TypeAnnotationPosition pos =
1150                             TypeAnnotationPosition.methodReturn(tree.pos);
1151                         // Use null to mark that the annotations go
1152                         // with the symbol.
1153                         separateAnnotationsKinds(tree, null, tree.sym, pos);
1154                     } else {
1155                         final TypeAnnotationPosition pos =
1156                             TypeAnnotationPosition.methodReturn(tree.restype.pos);
1157                         separateAnnotationsKinds(tree.restype,
1158                                                  tree.sym.type.getReturnType(),
1159                                                  tree.sym, pos);
1160                     }
1161                 }
1162                 if (tree.recvparam != null &amp;&amp; tree.recvparam.sym != null &amp;&amp;
1163                         !tree.recvparam.mods.annotations.isEmpty()) {
1164                     // Nothing to do for separateAnnotationsKinds if
1165                     // there are no annotations of either kind.
1166                     // TODO: make sure there are no declaration annotations.
1167                     final TypeAnnotationPosition pos = TypeAnnotationPosition.methodReceiver(tree.recvparam.vartype.pos);
1168                     push(tree.recvparam);
1169                     try {
1170                         separateAnnotationsKinds(tree.recvparam.vartype, tree.recvparam.sym.type, tree.recvparam.sym, pos);
1171                     } finally {
1172                         pop();
1173                     }
1174                 }
1175                 int i = 0;
1176                 for (JCVariableDecl param : tree.params) {
1177                     if (!param.mods.annotations.isEmpty()) {
1178                         // Nothing to do for separateAnnotationsKinds if
1179                         // there are no annotations of either kind.
1180                         final TypeAnnotationPosition pos = TypeAnnotationPosition.methodParameter(i, param.vartype.pos);
1181                         push(param);
1182                         try {
1183                             separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);
1184                         } finally {
1185                             pop();
1186                         }
1187                     }
1188                     ++i;
1189                 }
1190             }
1191 
1192             if (sigOnly) {
1193                 scan(tree.mods);
1194                 scan(tree.restype);
1195                 scan(tree.typarams);
1196                 scan(tree.recvparam);
1197                 scan(tree.params);
1198                 scan(tree.thrown);
1199             } else {
1200                 scan(tree.defaultValue);
1201                 scan(tree.body);
1202             }
1203         }
1204 
1205         /* Store a reference to the current lambda expression, to
1206          * be used by all type annotations within this expression.
1207          */
1208         private JCLambda currentLambda = null;
1209 
1210         public void visitLambda(JCLambda tree) {
1211             JCLambda prevLambda = currentLambda;
1212             try {
1213                 currentLambda = tree;
1214 
1215                 int i = 0;
1216                 for (JCVariableDecl param : tree.params) {
1217                     if (!param.mods.annotations.isEmpty()) {
1218                         // Nothing to do for separateAnnotationsKinds if
1219                         // there are no annotations of either kind.
1220                         final TypeAnnotationPosition pos =  TypeAnnotationPosition
1221                                 .methodParameter(tree, i, param.vartype.pos);
1222                         push(param);
1223                         try {
1224                             separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);
1225                         } finally {
1226                             pop();
1227                         }
1228                     }
1229                     ++i;
1230                 }
1231 
1232                 scan(tree.body);
1233                 scan(tree.params);
1234             } finally {
1235                 currentLambda = prevLambda;
1236             }
1237         }
1238 
1239         /**
1240          * Resolve declaration vs. type annotations in variable declarations and
1241          * then determine the positions.
1242          */
1243         @Override
1244         public void visitVarDef(final JCVariableDecl tree) {
1245             if (tree.mods.annotations.isEmpty()) {
1246                 // Nothing to do for separateAnnotationsKinds if
1247                 // there are no annotations of either kind.
1248             } else if (tree.sym == null) {
1249                 Assert.error(&quot;Visiting tree node before memberEnter&quot;);
1250             } else if (tree.sym.getKind() == ElementKind.PARAMETER) {
1251                 // Parameters are handled in visitMethodDef or visitLambda.
1252             } else if (tree.sym.getKind() == ElementKind.FIELD) {
1253                 if (sigOnly) {
1254                     TypeAnnotationPosition pos =
1255                         TypeAnnotationPosition.field(tree.pos);
1256                     separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1257                 }
1258             } else if (tree.sym.getKind() == ElementKind.LOCAL_VARIABLE) {
1259                 final TypeAnnotationPosition pos =
1260                     TypeAnnotationPosition.localVariable(currentLambda,
1261                                                          tree.pos);
1262                 if (!tree.isImplicitlyTyped()) {
1263                     separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1264                 }
1265             } else if (tree.sym.getKind() == ElementKind.EXCEPTION_PARAMETER) {
1266                 final TypeAnnotationPosition pos =
1267                     TypeAnnotationPosition.exceptionParameter(currentLambda,
1268                                                               tree.pos);
1269                 separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1270             } else if (tree.sym.getKind() == ElementKind.RESOURCE_VARIABLE) {
1271                 final TypeAnnotationPosition pos =
1272                     TypeAnnotationPosition.resourceVariable(currentLambda,
1273                                                             tree.pos);
1274                 separateAnnotationsKinds(tree.vartype, tree.sym.type, tree.sym, pos);
1275             } else if (tree.sym.getKind() == ElementKind.ENUM_CONSTANT) {
1276                 // No type annotations can occur here.
1277             } else {
1278                 // There is nothing else in a variable declaration that needs separation.
1279                 Assert.error(&quot;Unhandled variable kind: &quot; + tree.sym.getKind());
1280             }
1281 
1282             scan(tree.mods);
1283             scan(tree.vartype);
1284             if (!sigOnly) {
1285                 scan(tree.init);
1286             }
1287         }
1288 
1289         @Override
1290         public void visitBlock(JCBlock tree) {
1291             // Do not descend into top-level blocks when only interested
1292             // in the signature.
1293             if (!sigOnly) {
1294                 scan(tree.stats);
1295             }
1296         }
1297 
1298         @Override
1299         public void visitAnnotatedType(JCAnnotatedType tree) {
1300             push(tree);
1301             findPosition(tree, tree, tree.annotations);
1302             pop();
1303             super.visitAnnotatedType(tree);
1304         }
1305 
1306         @Override
1307         public void visitTypeParameter(JCTypeParameter tree) {
1308             findPosition(tree, peek2(), tree.annotations);
1309             super.visitTypeParameter(tree);
1310         }
1311 
1312         private void propagateNewClassAnnotationsToOwner(JCNewClass tree) {
1313             Symbol sym = tree.def.sym;
1314             // The anonymous class&#39; synthetic class declaration is itself an inner class,
1315             // so the type path is one INNER_TYPE entry deeper than that of the
1316             // lexically enclosing class.
1317             List&lt;TypePathEntry&gt; depth =
1318                     locateNestedTypes(sym.owner.enclClass().type, new ListBuffer&lt;&gt;())
1319                             .append(TypePathEntry.INNER_TYPE).toList();
1320             TypeAnnotationPosition pos =
1321                     TypeAnnotationPosition.newObj(depth, /* currentLambda= */ null, tree.pos);
1322 
1323             ListBuffer&lt;Attribute.TypeCompound&gt; newattrs = new ListBuffer&lt;&gt;();
1324             List&lt;TypePathEntry&gt; expectedLocation =
1325                     locateNestedTypes(tree.clazz.type, new ListBuffer&lt;&gt;()).toList();
1326             for (Attribute.TypeCompound old : sym.getRawTypeAttributes()) {
1327                 // Only propagate type annotations from the top-level supertype,
1328                 // (including if the supertype is an inner class).
1329                 if (old.position.location.equals(expectedLocation)) {
1330                     newattrs.append(new Attribute.TypeCompound(old.type, old.values, pos));
1331                 }
1332             }
1333 
1334             sym.owner.appendUniqueTypeAttributes(newattrs.toList());
1335         }
1336 
1337         @Override
1338         public void visitNewClass(JCNewClass tree) {
1339             if (tree.def != null &amp;&amp; tree.def.sym != null) {
1340                 propagateNewClassAnnotationsToOwner(tree);
1341             }
1342 
1343             scan(tree.encl);
1344             scan(tree.typeargs);
1345             if (tree.def == null) {
1346                 scan(tree.clazz);
1347             } // else super type will already have been scanned in the context of the anonymous class.
1348             scan(tree.args);
1349 
1350             // The class body will already be scanned.
1351             // scan(tree.def);
1352         }
1353 
1354         @Override
1355         public void visitNewArray(JCNewArray tree) {
1356             findPosition(tree, tree, tree.annotations);
1357             int dimAnnosCount = tree.dimAnnotations.size();
1358             ListBuffer&lt;TypePathEntry&gt; depth = new ListBuffer&lt;&gt;();
1359 
1360             // handle annotations associated with dimensions
1361             for (int i = 0; i &lt; dimAnnosCount; ++i) {
1362                 ListBuffer&lt;TypePathEntry&gt; location =
1363                     new ListBuffer&lt;TypePathEntry&gt;();
1364                 if (i != 0) {
1365                     depth = depth.append(TypePathEntry.ARRAY);
1366                     location = location.appendList(depth.toList());
1367                 }
1368                 final TypeAnnotationPosition p =
1369                     TypeAnnotationPosition.newObj(location.toList(),
1370                                                   currentLambda,
1371                                                   tree.pos);
1372 
1373                 setTypeAnnotationPos(tree.dimAnnotations.get(i), p);
1374             }
1375 
1376             // handle &quot;free&quot; annotations
1377             // int i = dimAnnosCount == 0 ? 0 : dimAnnosCount - 1;
1378             // TODO: is depth.size == i here?
1379             JCExpression elemType = tree.elemtype;
1380             depth = depth.append(TypePathEntry.ARRAY);
1381             while (elemType != null) {
1382                 if (elemType.hasTag(JCTree.Tag.ANNOTATED_TYPE)) {
1383                     JCAnnotatedType at = (JCAnnotatedType)elemType;
1384                     final ListBuffer&lt;TypePathEntry&gt; locationbuf =
1385                         locateNestedTypes(elemType.type,
1386                                           new ListBuffer&lt;TypePathEntry&gt;());
1387                     final List&lt;TypePathEntry&gt; location =
1388                         locationbuf.toList().prependList(depth.toList());
1389                     final TypeAnnotationPosition p =
1390                         TypeAnnotationPosition.newObj(location, currentLambda,
1391                                                       tree.pos);
1392                     setTypeAnnotationPos(at.annotations, p);
1393                     elemType = at.underlyingType;
1394                 } else if (elemType.hasTag(JCTree.Tag.TYPEARRAY)) {
1395                     depth = depth.append(TypePathEntry.ARRAY);
1396                     elemType = ((JCArrayTypeTree)elemType).elemtype;
1397                 } else if (elemType.hasTag(JCTree.Tag.SELECT)) {
1398                     elemType = ((JCFieldAccess)elemType).selected;
1399                 } else {
1400                     break;
1401                 }
1402             }
1403             scan(tree.elems);
1404         }
1405 
1406         private void findPosition(JCTree tree, JCTree frame, List&lt;JCAnnotation&gt; annotations) {
1407             if (!annotations.isEmpty())
1408             {
1409                 final TypeAnnotationPosition p =
1410                     resolveFrame(tree, frame, frames, currentLambda, 0, new ListBuffer&lt;&gt;());
1411 
1412                 setTypeAnnotationPos(annotations, p);
1413             }
1414         }
1415 
1416         private void setTypeAnnotationPos(List&lt;JCAnnotation&gt; annotations, TypeAnnotationPosition position)
1417         {
1418             // attribute might be null during DeferredAttr;
1419             // we will be back later.
1420             for (JCAnnotation anno : annotations) {
1421                 if (anno.attribute != null)
1422                     ((Attribute.TypeCompound) anno.attribute).position = position;
1423             }
1424         }
1425 
1426 
1427         @Override
1428         public String toString() {
1429             return super.toString() + &quot;: sigOnly: &quot; + sigOnly;
1430         }
1431     }
1432 }
    </pre>
  </body>
</html>
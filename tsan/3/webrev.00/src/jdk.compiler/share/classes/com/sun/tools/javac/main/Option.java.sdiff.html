<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/main/Option.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Main.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../model/AnnotationProxyMaker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/main/Option.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 167         public void process(OptionHelper helper, String option) {
 168             helper.put(&quot;-Xlint:none&quot;, option);
 169         }
 170     },
 171 
 172     VERBOSE(&quot;-verbose&quot;, &quot;opt.verbose&quot;, STANDARD, BASIC),
 173 
 174     // -deprecation is retained for command-line backward compatibility
 175     DEPRECATION(&quot;-deprecation&quot;, &quot;opt.deprecation&quot;, STANDARD, BASIC) {
 176         @Override
 177         public void process(OptionHelper helper, String option) {
 178             helper.put(&quot;-Xlint:deprecation&quot;, option);
 179         }
 180     },
 181 
 182     CLASS_PATH(&quot;--class-path -classpath -cp&quot;, &quot;opt.arg.path&quot;, &quot;opt.classpath&quot;, STANDARD, FILEMANAGER),
 183 
 184     SOURCE_PATH(&quot;--source-path -sourcepath&quot;, &quot;opt.arg.path&quot;, &quot;opt.sourcepath&quot;, STANDARD, FILEMANAGER),
 185 
 186     MODULE_SOURCE_PATH(&quot;--module-source-path&quot;, &quot;opt.arg.mspath&quot;, &quot;opt.modulesourcepath&quot;, STANDARD, FILEMANAGER) {
<span class="line-modified"> 187         // The deferred filemanager diagnostics mechanism assumes a single value per option,</span>
 188         // but --module-source-path-module can be used multiple times, once in the old form
 189         // and once per module in the new form.  Therefore we compose an overall value for the
 190         // option containing the individual values given on the command line, separated by NULL.
 191         // The standard file manager code knows to split apart the NULL-separated components.
 192         @Override
 193         public void process(OptionHelper helper, String option, String arg) throws InvalidValueException {
 194             if (arg.isEmpty()) {
 195                 throw helper.newInvalidValueException(Errors.NoValueForOption(option));
 196             }
 197             Pattern moduleSpecificForm = getPattern();
 198             String prev = helper.get(MODULE_SOURCE_PATH);
 199             if (prev == null) {
 200                 super.process(helper, option, arg);
 201             } else  if (moduleSpecificForm.matcher(arg).matches()) {
 202                 String argModule = arg.substring(0, arg.indexOf(&#39;=&#39;));
 203                 boolean isRepeated = Arrays.stream(prev.split(&quot;\0&quot;))
 204                         .filter(s -&gt; moduleSpecificForm.matcher(s).matches())
 205                         .map(s -&gt; s.substring(0, s.indexOf(&#39;=&#39;)))
 206                         .anyMatch(s -&gt; s.equals(argModule));
 207                 if (isRepeated) {
</pre>
<hr />
<pre>
 216                     throw helper.newInvalidValueException(Errors.MultipleValuesForModuleSourcePath);
 217                 } else {
 218                     super.process(helper, option, prev + &#39;\0&#39; + arg);
 219                 }
 220             }
 221         }
 222 
 223         @Override
 224         public Pattern getPattern() {
 225             return Pattern.compile(&quot;([\\p{Alnum}$_.]+)=(.*)&quot;);
 226         }
 227     },
 228 
 229     MODULE_PATH(&quot;--module-path -p&quot;, &quot;opt.arg.path&quot;, &quot;opt.modulepath&quot;, STANDARD, FILEMANAGER),
 230 
 231     UPGRADE_MODULE_PATH(&quot;--upgrade-module-path&quot;, &quot;opt.arg.path&quot;, &quot;opt.upgrademodulepath&quot;, STANDARD, FILEMANAGER),
 232 
 233     SYSTEM(&quot;--system&quot;, &quot;opt.arg.jdk&quot;, &quot;opt.system&quot;, STANDARD, FILEMANAGER),
 234 
 235     PATCH_MODULE(&quot;--patch-module&quot;, &quot;opt.arg.patch&quot;, &quot;opt.patch&quot;, EXTENDED, FILEMANAGER) {
<span class="line-modified"> 236         // The deferred filemanager diagnostics mechanism assumes a single value per option,</span>
 237         // but --patch-module can be used multiple times, once per module. Therefore we compose
 238         // a value for the option containing the last value specified for each module, and separate
 239         // the module=path pairs by an invalid path character, NULL.
 240         // The standard file manager code knows to split apart the NULL-separated components.
 241         @Override
 242         public void process(OptionHelper helper, String option, String arg) throws InvalidValueException {
 243             if (arg.isEmpty()) {
 244                 throw helper.newInvalidValueException(Errors.NoValueForOption(option));
 245             } else if (getPattern().matcher(arg).matches()) {
 246                 String prev = helper.get(PATCH_MODULE);
 247                 if (prev == null) {
 248                     super.process(helper, option, arg);
 249                 } else {
 250                     String argModulePackage = arg.substring(0, arg.indexOf(&#39;=&#39;));
 251                     boolean isRepeated = Arrays.stream(prev.split(&quot;\0&quot;))
 252                             .map(s -&gt; s.substring(0, s.indexOf(&#39;=&#39;)))
 253                             .collect(Collectors.toSet())
 254                             .contains(argModulePackage);
 255                     if (isRepeated) {
 256                         throw helper.newInvalidValueException(Errors.RepeatedValueForPatchModule(argModulePackage));
</pre>
</td>
<td>
<hr />
<pre>
 167         public void process(OptionHelper helper, String option) {
 168             helper.put(&quot;-Xlint:none&quot;, option);
 169         }
 170     },
 171 
 172     VERBOSE(&quot;-verbose&quot;, &quot;opt.verbose&quot;, STANDARD, BASIC),
 173 
 174     // -deprecation is retained for command-line backward compatibility
 175     DEPRECATION(&quot;-deprecation&quot;, &quot;opt.deprecation&quot;, STANDARD, BASIC) {
 176         @Override
 177         public void process(OptionHelper helper, String option) {
 178             helper.put(&quot;-Xlint:deprecation&quot;, option);
 179         }
 180     },
 181 
 182     CLASS_PATH(&quot;--class-path -classpath -cp&quot;, &quot;opt.arg.path&quot;, &quot;opt.classpath&quot;, STANDARD, FILEMANAGER),
 183 
 184     SOURCE_PATH(&quot;--source-path -sourcepath&quot;, &quot;opt.arg.path&quot;, &quot;opt.sourcepath&quot;, STANDARD, FILEMANAGER),
 185 
 186     MODULE_SOURCE_PATH(&quot;--module-source-path&quot;, &quot;opt.arg.mspath&quot;, &quot;opt.modulesourcepath&quot;, STANDARD, FILEMANAGER) {
<span class="line-modified"> 187         // The deferred file manager diagnostics mechanism assumes a single value per option,</span>
 188         // but --module-source-path-module can be used multiple times, once in the old form
 189         // and once per module in the new form.  Therefore we compose an overall value for the
 190         // option containing the individual values given on the command line, separated by NULL.
 191         // The standard file manager code knows to split apart the NULL-separated components.
 192         @Override
 193         public void process(OptionHelper helper, String option, String arg) throws InvalidValueException {
 194             if (arg.isEmpty()) {
 195                 throw helper.newInvalidValueException(Errors.NoValueForOption(option));
 196             }
 197             Pattern moduleSpecificForm = getPattern();
 198             String prev = helper.get(MODULE_SOURCE_PATH);
 199             if (prev == null) {
 200                 super.process(helper, option, arg);
 201             } else  if (moduleSpecificForm.matcher(arg).matches()) {
 202                 String argModule = arg.substring(0, arg.indexOf(&#39;=&#39;));
 203                 boolean isRepeated = Arrays.stream(prev.split(&quot;\0&quot;))
 204                         .filter(s -&gt; moduleSpecificForm.matcher(s).matches())
 205                         .map(s -&gt; s.substring(0, s.indexOf(&#39;=&#39;)))
 206                         .anyMatch(s -&gt; s.equals(argModule));
 207                 if (isRepeated) {
</pre>
<hr />
<pre>
 216                     throw helper.newInvalidValueException(Errors.MultipleValuesForModuleSourcePath);
 217                 } else {
 218                     super.process(helper, option, prev + &#39;\0&#39; + arg);
 219                 }
 220             }
 221         }
 222 
 223         @Override
 224         public Pattern getPattern() {
 225             return Pattern.compile(&quot;([\\p{Alnum}$_.]+)=(.*)&quot;);
 226         }
 227     },
 228 
 229     MODULE_PATH(&quot;--module-path -p&quot;, &quot;opt.arg.path&quot;, &quot;opt.modulepath&quot;, STANDARD, FILEMANAGER),
 230 
 231     UPGRADE_MODULE_PATH(&quot;--upgrade-module-path&quot;, &quot;opt.arg.path&quot;, &quot;opt.upgrademodulepath&quot;, STANDARD, FILEMANAGER),
 232 
 233     SYSTEM(&quot;--system&quot;, &quot;opt.arg.jdk&quot;, &quot;opt.system&quot;, STANDARD, FILEMANAGER),
 234 
 235     PATCH_MODULE(&quot;--patch-module&quot;, &quot;opt.arg.patch&quot;, &quot;opt.patch&quot;, EXTENDED, FILEMANAGER) {
<span class="line-modified"> 236         // The deferred file manager diagnostics mechanism assumes a single value per option,</span>
 237         // but --patch-module can be used multiple times, once per module. Therefore we compose
 238         // a value for the option containing the last value specified for each module, and separate
 239         // the module=path pairs by an invalid path character, NULL.
 240         // The standard file manager code knows to split apart the NULL-separated components.
 241         @Override
 242         public void process(OptionHelper helper, String option, String arg) throws InvalidValueException {
 243             if (arg.isEmpty()) {
 244                 throw helper.newInvalidValueException(Errors.NoValueForOption(option));
 245             } else if (getPattern().matcher(arg).matches()) {
 246                 String prev = helper.get(PATCH_MODULE);
 247                 if (prev == null) {
 248                     super.process(helper, option, arg);
 249                 } else {
 250                     String argModulePackage = arg.substring(0, arg.indexOf(&#39;=&#39;));
 251                     boolean isRepeated = Arrays.stream(prev.split(&quot;\0&quot;))
 252                             .map(s -&gt; s.substring(0, s.indexOf(&#39;=&#39;)))
 253                             .collect(Collectors.toSet())
 254                             .contains(argModulePackage);
 255                     if (isRepeated) {
 256                         throw helper.newInvalidValueException(Errors.RepeatedValueForPatchModule(argModulePackage));
</pre>
</td>
</tr>
</table>
<center><a href="Main.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../model/AnnotationProxyMaker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
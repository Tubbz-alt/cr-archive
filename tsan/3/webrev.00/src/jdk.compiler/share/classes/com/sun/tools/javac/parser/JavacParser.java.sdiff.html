<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
<span class="line-modified">  32 import com.sun.source.tree.CaseTree.CaseKind;</span>
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
</pre>
<hr />
<pre>
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);




 185     }
 186 
 187     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 188         return  keepEndPositions
 189                 ? new SimpleEndPosTable(this)
 190                 : new EmptyEndPosTable(this);
 191     }
 192 
 193     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 194         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 195     }
 196 
 197     /** Switch: should we fold strings?
 198      */
 199     boolean allowStringFolding;
 200 
 201     /** Switch: should we keep docComments?
 202      */
 203     boolean keepDocComments;
 204 
 205     /** Switch: should we keep line table?
 206      */
 207     boolean keepLineMap;
 208 
 209     /** Switch: is &quot;this&quot; allowed as an identifier?
 210      * This is needed to parse receiver types.
 211      */
 212     boolean allowThisIdent;
 213 








 214     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 215      */
 216     JCVariableDecl receiverParam;
 217 
 218     /** When terms are parsed, the mode determines which is expected:
 219      *     mode = EXPR        : an expression
 220      *     mode = TYPE        : a type
 221      *     mode = NOPARAMS    : no parameters allowed for type
 222      *     mode = TYPEARG     : type argument
 223      *     mode |= NOLAMBDA   : lambdas are not allowed
 224      */
 225     protected static final int EXPR = 0x1;
 226     protected static final int TYPE = 0x2;
 227     protected static final int NOPARAMS = 0x4;
 228     protected static final int TYPEARG = 0x8;
 229     protected static final int DIAMOND = 0x10;
 230     protected static final int NOLAMBDA = 0x20;
 231 
 232     protected void selectExprMode() {
 233         mode = (mode &amp; NOLAMBDA) | EXPR;
</pre>
<hr />
<pre>
 752         return parseType(false);
 753     }
 754 
 755     public JCExpression parseType(boolean allowVar) {
 756         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 757         return parseType(allowVar, annotations);
 758     }
 759 
 760     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 761         JCExpression result = unannotatedType(allowVar);
 762 
 763         if (annotations.nonEmpty()) {
 764             result = insertAnnotationsToMostInner(result, annotations, false);
 765         }
 766 
 767         return result;
 768     }
 769 
 770     public JCExpression unannotatedType(boolean allowVar) {
 771         JCExpression result = term(TYPE);

 772 
<span class="line-modified"> 773         if (!allowVar &amp;&amp; isRestrictedLocalVarTypeName(result, true)) {</span>
<span class="line-modified"> 774             syntaxError(result.pos, Errors.VarNotAllowedHere);</span>
 775         }
 776 
 777         return result;
 778     }
 779 
 780 
 781 
 782     protected JCExpression term(int newmode) {
 783         int prevmode = mode;
 784         mode = newmode;
 785         JCExpression t = term();
 786         lastmode = mode;
 787         mode = prevmode;
 788         return t;
 789     }
 790 
 791     /**
 792      *  {@literal
 793      *  Expression = Expression1 [ExpressionRest]
 794      *  ExpressionRest = [AssignmentOperator Expression1]
</pre>
<hr />
<pre>
 869             return t;
 870         }
 871     }
 872 
 873     /** Expression2   = Expression3 [Expression2Rest]
 874      *  Type2         = Type3
 875      *  TypeNoParams2 = TypeNoParams3
 876      */
 877     JCExpression term2() {
 878         JCExpression t = term3();
 879         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 880             selectExprMode();
 881             return term2Rest(t, TreeInfo.orPrec);
 882         } else {
 883             return t;
 884         }
 885     }
 886 
 887     /*  Expression2Rest = {infixop Expression3}
 888      *                  | Expression3 instanceof Type

 889      *  infixop         = &quot;||&quot;
 890      *                  | &quot;&amp;&amp;&quot;
 891      *                  | &quot;|&quot;
 892      *                  | &quot;^&quot;
 893      *                  | &quot;&amp;&quot;
 894      *                  | &quot;==&quot; | &quot;!=&quot;
 895      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 896      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 897      *                  | &quot;+&quot; | &quot;-&quot;
 898      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 899      */
 900     JCExpression term2Rest(JCExpression t, int minprec) {
 901         JCExpression[] odStack = newOdStack();
 902         Token[] opStack = newOpStack();
 903 
 904         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 905         int top = 0;
 906         odStack[0] = t;
 907         int startPos = token.pos;
 908         Token topOp = Tokens.DUMMY;
 909         while (prec(token.kind) &gt;= minprec) {
 910             opStack[top] = topOp;
<span class="line-modified"> 911             top++;</span>
<span class="line-modified"> 912             topOp = token;</span>
<span class="line-modified"> 913             nextToken();</span>
<span class="line-modified"> 914             odStack[top] = (topOp.kind == INSTANCEOF) ? parseType() : term3();</span>












 915             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
<span class="line-modified"> 916                 odStack[top-1] = makeOp(topOp.pos, topOp.kind, odStack[top-1],</span>
<span class="line-removed"> 917                                         odStack[top]);</span>
 918                 top--;
 919                 topOp = opStack[top];
 920             }
 921         }
 922         Assert.check(top == 0);
 923         t = odStack[0];
 924 
 925         if (t.hasTag(JCTree.Tag.PLUS)) {
 926             t = foldStrings(t);
 927         }
 928 
 929         odStackSupply.add(odStack);
 930         opStackSupply.add(opStack);
 931         return t;
 932     }
 933     //where
<span class="line-removed"> 934         /** Construct a binary or type test node.</span>
<span class="line-removed"> 935          */</span>
<span class="line-removed"> 936         private JCExpression makeOp(int pos,</span>
<span class="line-removed"> 937                                     TokenKind topOp,</span>
<span class="line-removed"> 938                                     JCExpression od1,</span>
<span class="line-removed"> 939                                     JCExpression od2)</span>
<span class="line-removed"> 940         {</span>
<span class="line-removed"> 941             if (topOp == INSTANCEOF) {</span>
<span class="line-removed"> 942                 return F.at(pos).TypeTest(od1, od2);</span>
<span class="line-removed"> 943             } else {</span>
<span class="line-removed"> 944                 return F.at(pos).Binary(optag(topOp), od1, od2);</span>
<span class="line-removed"> 945             }</span>
<span class="line-removed"> 946         }</span>
 947         /** If tree is a concatenation of string literals, replace it
 948          *  by a single literal representing the concatenated string.
 949          */
 950         protected JCExpression foldStrings(JCExpression tree) {
 951             if (!allowStringFolding)
 952                 return tree;
 953             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
 954             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
 955             boolean needsFolding = false;
 956             JCExpression curr = tree;
 957             while (true) {
 958                 if (curr.hasTag(JCTree.Tag.PLUS)) {
 959                     JCBinary op = (JCBinary)curr;
 960                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
 961                     curr = op.lhs;
 962                 } else {
 963                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
 964                     break; //last one!
 965                 }
 966             }
</pre>
<hr />
<pre>
1360             if ((mode &amp; EXPR) != 0) {
1361                 nextToken();
1362                 if (token.kind == DOT) {
1363                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1364                     t = bracketsSuffix(ti);
1365                 } else {
1366                     return illegal(pos);
1367                 }
1368             } else {
1369                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1370                 // a void type (like other primitive types) to the next phase.
1371                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1372                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1373                 nextToken();
1374                 return ti;
1375                 //return illegal();
1376             }
1377             break;
1378         case SWITCH:
1379             checkSourceLevel(Feature.SWITCH_EXPRESSION);

1380             int switchPos = token.pos;
1381             nextToken();
1382             JCExpression selector = parExpression();
1383             accept(LBRACE);
1384             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1385             while (true) {
1386                 pos = token.pos;
1387                 switch (token.kind) {
1388                 case CASE:
1389                 case DEFAULT:
1390                     cases.appendList(switchExpressionStatementGroup());
1391                     break;
1392                 case RBRACE: case EOF:
1393                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1394                                                                                cases.toList()));
1395                     e.endpos = token.pos;
1396                     accept(RBRACE);
1397                     return e;
1398                 default:
1399                     nextToken(); // to ensure progress
</pre>
<hr />
<pre>
1407     }
1408 
1409     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1410         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1411         int casePos = token.pos;
1412         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1413 
1414         if (token.kind == DEFAULT) {
1415             nextToken();
1416         } else {
1417             accept(CASE);
1418             while (true) {
1419                 pats.append(term(EXPR | NOLAMBDA));
1420                 if (token.kind != COMMA) break;
1421                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1422                 nextToken();
1423             };
1424         }
1425         List&lt;JCStatement&gt; stats = null;
1426         JCTree body = null;
<span class="line-modified">1427         @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">1428         CaseKind kind;</span>
1429         switch (token.kind) {
1430             case ARROW:
1431                 checkSourceLevel(Feature.SWITCH_RULE);
1432                 nextToken();
1433                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1434                     stats = List.of(parseStatement());
1435                     body = stats.head;
1436                     kind = JCCase.RULE;
1437                 } else {
1438                     JCExpression value = parseExpression();
<span class="line-modified">1439                     stats = List.of(to(F.at(value).Break(value)));</span>
1440                     body = value;
1441                     kind = JCCase.RULE;
1442                     accept(SEMI);
1443                 }
1444                 break;
1445             default:
1446                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1447                 stats = blockStatements();
1448                 kind = JCCase.STATEMENT;
1449                 break;
1450         }
1451         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1452         return caseExprs.toList();
1453     }
1454 
1455     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1456         if (typeArgs != null) illegal();
1457         while (true) {
1458             int pos1 = token.pos;
1459             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
</pre>
<hr />
<pre>
1590                             nextKind == TokenKind.LBRACKET ||
1591                             nextKind == TokenKind.COLCOL;
1592                     }
1593                     break;
1594                 default:
1595                     return false;
1596             }
1597         }
1598     }
1599 
1600     /**
1601      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1602      * method reference or a binary expression. To disambiguate, look for a
1603      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1604      */
1605     @SuppressWarnings(&quot;fallthrough&quot;)
1606     ParensResult analyzeParens() {
1607         int depth = 0;
1608         boolean type = false;
1609         ParensResult defaultResult = ParensResult.PARENS;
<span class="line-modified">1610         outer: for (int lookahead = 0 ; ; lookahead++) {</span>
1611             TokenKind tk = S.token(lookahead).kind;
1612             switch (tk) {
1613                 case COMMA:
1614                     type = true;
1615                 case EXTENDS: case SUPER: case DOT: case AMP:
1616                     //skip
1617                     break;
1618                 case QUES:
1619                     if (peekToken(lookahead, EXTENDS) ||
1620                             peekToken(lookahead, SUPER)) {
1621                         //wildcards
1622                         type = true;
1623                     }
1624                     break;
1625                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1626                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1627                     if (peekToken(lookahead, RPAREN)) {
1628                         //Type, &#39;)&#39; -&gt; cast
1629                         return ParensResult.CAST;
1630                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
</pre>
<hr />
<pre>
1638                         return ParensResult.PARENS;
1639                     } else if (peekToken(lookahead, RPAREN)) {
1640                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1641                         return ParensResult.EXPLICIT_LAMBDA;
1642                     }
1643                     break;
1644                 case RPAREN:
1645                     // if we have seen something that looks like a type,
1646                     // then it&#39;s a cast expression
1647                     if (type) return ParensResult.CAST;
1648                     // otherwise, disambiguate cast vs. parenthesized expression
1649                     // based on subsequent token.
1650                     switch (S.token(lookahead + 1).kind) {
1651                         /*case PLUSPLUS: case SUBSUB: */
1652                         case BANG: case TILDE:
1653                         case LPAREN: case THIS: case SUPER:
1654                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1655                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1656                         case TRUE: case FALSE: case NULL:
1657                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:

1658                         case BYTE: case SHORT: case CHAR: case INT:
1659                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1660                             return ParensResult.CAST;
1661                         default:
1662                             return defaultResult;
1663                     }
1664                 case UNDERSCORE:
1665                 case ASSERT:
1666                 case ENUM:
1667                 case IDENTIFIER:
1668                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1669                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1670                         return ParensResult.EXPLICIT_LAMBDA;
1671                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1672                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1673                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1674                                                       : ParensResult.PARENS;
1675                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1676                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1677                     }
</pre>
<hr />
<pre>
1759                     break;
1760                 default:
1761                     //this includes EOF
1762                     return defaultResult;
1763             }
1764         }
1765     }
1766 
1767     /** Accepts all identifier-like tokens */
1768     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1769 
1770     enum ParensResult {
1771         CAST,
1772         EXPLICIT_LAMBDA,
1773         IMPLICIT_LAMBDA,
1774         PARENS
1775     }
1776 
1777     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1778         List&lt;JCVariableDecl&gt; params = explicitParams ?
<span class="line-modified">1779                 formalParameters(true) :</span>
1780                 implicitParameters(hasParens);
1781         if (explicitParams) {
1782             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1783             for (JCVariableDecl param: params) {

1784                 if (param.vartype != null &amp;&amp;
<span class="line-modified">1785                         isRestrictedLocalVarTypeName(param.vartype, false) &amp;&amp;</span>
1786                         param.vartype.hasTag(TYPEARRAY)) {
1787                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1788                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
<span class="line-modified">1789                             ? Errors.VarNotAllowedArray : Errors.VarNotAllowedHere);</span>
1790                 }
1791                 lambdaClassifier.addParameter(param);
1792                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1793                     break;
1794                 }
1795             }
1796             if (lambdaClassifier.diagFragment != null) {
1797                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1798             }
1799             for (JCVariableDecl param: params) {
1800                 if (param.vartype != null
<span class="line-modified">1801                         &amp;&amp; isRestrictedLocalVarTypeName(param.vartype, true)) {</span>
1802                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1803                     param.startPos = TreeInfo.getStartPos(param.vartype);
1804                     param.vartype = null;
1805                 }
1806             }
1807         }
1808         return lambdaExpressionOrStatementRest(params, pos);
1809     }
1810 
1811     enum LambdaParameterKind {
1812         VAR(0),
1813         EXPLICIT(1),
1814         IMPLICIT(2),
1815         ERROR(-1);
1816 
1817         private final int index;
1818 
1819         LambdaParameterKind(int index) {
1820             this.index = index;
1821         }
1822     }
1823 
1824     private final static Fragment[][] decisionTable = new Fragment[][] {
1825         /*              VAR                              EXPLICIT                         IMPLICIT  */
1826         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1827         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1828         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1829     };
1830 
1831     class LambdaClassifier {
1832 
1833         LambdaParameterKind kind;
1834         Fragment diagFragment;
1835         List&lt;JCVariableDecl&gt; params;
1836 
1837         void addParameter(JCVariableDecl param) {
1838             if (param.vartype != null &amp;&amp; param.name != names.empty) {
<span class="line-modified">1839                 if (isRestrictedLocalVarTypeName(param.vartype, false)) {</span>
1840                     reduce(LambdaParameterKind.VAR);
1841                 } else {
1842                     reduce(LambdaParameterKind.EXPLICIT);
1843                 }
1844             }
1845             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1846                 param.vartype != null &amp;&amp; param.name == names.empty) {
1847                 reduce(LambdaParameterKind.IMPLICIT);
1848             }
1849         }
1850 
1851         private void reduce(LambdaParameterKind newKind) {
1852             if (kind == null) {
1853                 kind = newKind;
1854             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1855                 LambdaParameterKind currentKind = kind;
1856                 kind = LambdaParameterKind.ERROR;
1857                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1858                         newKind.index == LambdaParameterKind.VAR.index;
1859                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
</pre>
<hr />
<pre>
1926     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1927      */
1928     List&lt;JCExpression&gt; arguments() {
1929         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1930         if (token.kind == LPAREN) {
1931             nextToken();
1932             if (token.kind != RPAREN) {
1933                 args.append(parseExpression());
1934                 while (token.kind == COMMA) {
1935                     nextToken();
1936                     args.append(parseExpression());
1937                 }
1938             }
1939             accept(RPAREN);
1940         } else {
1941             syntaxError(token.pos, Errors.Expected(LPAREN));
1942         }
1943         return args.toList();
1944     }
1945 
<span class="line-modified">1946     JCMethodInvocation arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {</span>
1947         int pos = token.pos;
1948         List&lt;JCExpression&gt; args = arguments();
<span class="line-modified">1949         return toP(F.at(pos).Apply(typeArgs, t, args));</span>

















1950     }
1951 
1952     /**  TypeArgumentsOpt = [ TypeArguments ]
1953      */
1954     JCExpression typeArgumentsOpt(JCExpression t) {
1955         if (token.kind == LT &amp;&amp;
1956             (mode &amp; TYPE) != 0 &amp;&amp;
1957             (mode &amp; NOPARAMS) == 0) {
1958             selectTypeMode();
1959             return typeArguments(t, false);
1960         } else {
1961             return t;
1962         }
1963     }
1964     List&lt;JCExpression&gt; typeArgumentsOpt() {
1965         return typeArgumentsOpt(TYPE);
1966     }
1967 
1968     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
1969         if (token.kind == LT) {
</pre>
<hr />
<pre>
2356 
2357             if (elems != null) {
2358                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2359             }
2360 
2361             return na;
2362         }
2363     }
2364 
2365     /** ClassCreatorRest = Arguments [ClassBody]
2366      */
2367     JCNewClass classCreatorRest(int newpos,
2368                                   JCExpression encl,
2369                                   List&lt;JCExpression&gt; typeArgs,
2370                                   JCExpression t)
2371     {
2372         List&lt;JCExpression&gt; args = arguments();
2373         JCClassDecl body = null;
2374         if (token.kind == LBRACE) {
2375             int pos = token.pos;
<span class="line-modified">2376             List&lt;JCTree&gt; defs = classOrInterfaceBody(names.empty, false);</span>
2377             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2378             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2379         }
2380         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2381     }
2382 
2383     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2384      */
2385     JCExpression arrayInitializer(int newpos, JCExpression t) {
2386         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2387         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2388     }
2389 
2390     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2391         accept(LBRACE);
2392         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2393         if (token.kind == COMMA) {
2394             nextToken();
2395         } else if (token.kind != RBRACE) {
2396             elems.append(variableInitializer());
</pre>
<hr />
<pre>
2488             Error error = null;
2489             switch (first.getTag()) {
2490             case CLASSDEF:
2491                 error = Errors.ClassNotAllowed;
2492                 break;
2493             case VARDEF:
2494                 error = Errors.VariableNotAllowed;
2495                 break;
2496             }
2497             if (error != null) {
2498                 log.error(DiagnosticFlag.SYNTAX, first, error);
2499                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2500                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2501             }
2502             return first;
2503         }
2504     }
2505 
2506     /**This method parses a statement appearing inside a block.
2507      */

2508     List&lt;JCStatement&gt; blockStatement() {
2509         //todo: skip to anchor on error(?)

2510         int pos = token.pos;
2511         switch (token.kind) {
2512         case RBRACE: case CASE: case DEFAULT: case EOF:
2513             return List.nil();
2514         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2515         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2516         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2517         case ASSERT:
2518             return List.of(parseSimpleStatement());
2519         case MONKEYS_AT:
2520         case FINAL: {
<span class="line-modified">2521             Comment dc = token.comment(CommentStyle.JAVADOC);</span>
2522             JCModifiers mods = modifiersOpt();
2523             if (token.kind == INTERFACE ||
2524                 token.kind == CLASS ||
<span class="line-modified">2525                 token.kind == ENUM) {</span>
<span class="line-modified">2526                 return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</span>

2527             } else {
2528                 JCExpression t = parseType(true);
2529                 return localVariableDeclarations(mods, t);
2530             }
2531         }
2532         case ABSTRACT: case STRICTFP: {
<span class="line-modified">2533             Comment dc = token.comment(CommentStyle.JAVADOC);</span>
2534             JCModifiers mods = modifiersOpt();
<span class="line-modified">2535             return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</span>
2536         }
2537         case INTERFACE:
2538         case CLASS:
<span class="line-modified">2539             Comment dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="line-modified">2540             return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
2541         case ENUM:
2542             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2543             dc = token.comment(CommentStyle.JAVADOC);
<span class="line-modified">2544             return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
<span class="line-modified">2545         default:</span>


















































2546             Token prevToken = token;
2547             JCExpression t = term(EXPR | TYPE);
2548             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2549                 nextToken();
2550                 JCStatement stat = parseStatementAsBlock();
2551                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2552             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2553                 pos = token.pos;
2554                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2555                 F.at(pos);
2556                 return localVariableDeclarations(mods, t);
2557             } else {
2558                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2559                 t = checkExprStat(t);
2560                 accept(SEMI);
2561                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2562                 return List.of(expr);
2563             }
2564         }
2565     }
</pre>
<hr />
<pre>
2684             JCExpression lock = parExpression();
2685             JCBlock body = block();
2686             return F.at(pos).Synchronized(lock, body);
2687         }
2688         case RETURN: {
2689             nextToken();
2690             JCExpression result = token.kind == SEMI ? null : parseExpression();
2691             accept(SEMI);
2692             JCReturn t = toP(F.at(pos).Return(result));
2693             return t;
2694         }
2695         case THROW: {
2696             nextToken();
2697             JCExpression exc = parseExpression();
2698             accept(SEMI);
2699             JCThrow t = toP(F.at(pos).Throw(exc));
2700             return t;
2701         }
2702         case BREAK: {
2703             nextToken();
<span class="line-modified">2704             JCExpression value = token.kind == SEMI ? null : parseExpression();</span>
2705             accept(SEMI);
<span class="line-modified">2706             JCBreak t = toP(F.at(pos).Break(value));</span>
2707             return t;
2708         }
2709         case CONTINUE: {
2710             nextToken();
2711             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2712             accept(SEMI);
2713             JCContinue t =  toP(F.at(pos).Continue(label));
2714             return t;
2715         }
2716         case SEMI:
2717             nextToken();
2718             return toP(F.at(pos).Skip());
2719         case ELSE:
2720             int elsePos = token.pos;
2721             nextToken();
2722             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2723         case FINALLY:
2724             int finallyPos = token.pos;
2725             nextToken();
2726             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
</pre>
<hr />
<pre>
2806                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2807             }
2808         }
2809     }
2810 
2811     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2812         int pos = token.pos;
2813         List&lt;JCStatement&gt; stats;
2814         JCCase c;
2815         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2816         switch (token.kind) {
2817         case CASE: {
2818             nextToken();
2819             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2820             while (true) {
2821                 pats.append(term(EXPR | NOLAMBDA));
2822                 if (token.kind != COMMA) break;
2823                 nextToken();
2824                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2825             };
<span class="line-modified">2826             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">2827             CaseKind caseKind;</span>
2828             JCTree body = null;
2829             if (token.kind == ARROW) {
2830                 checkSourceLevel(Feature.SWITCH_RULE);
2831                 accept(ARROW);
2832                 caseKind = JCCase.RULE;
2833                 JCStatement statement = parseStatementAsBlock();
2834                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2835                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2836                 }
2837                 stats = List.of(statement);
2838                 body = stats.head;
2839             } else {
2840                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2841                 caseKind = JCCase.STATEMENT;
2842                 stats = blockStatements();
2843             }
2844             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2845             if (stats.isEmpty())
2846                 storeEnd(c, S.prevToken().endPos);
2847             return cases.append(c).toList();
2848         }
2849         case DEFAULT: {
2850             nextToken();
<span class="line-modified">2851             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="line-removed">2852             CaseKind caseKind;</span>
2853             JCTree body = null;
2854             if (token.kind == ARROW) {
2855                 checkSourceLevel(Feature.SWITCH_RULE);
2856                 accept(ARROW);
2857                 caseKind = JCCase.RULE;
2858                 JCStatement statement = parseStatementAsBlock();
2859                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2860                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2861                 }
2862                 stats = List.of(statement);
2863                 body = stats.head;
2864             } else {
2865                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2866                 caseKind = JCCase.STATEMENT;
2867                 stats = blockStatements();
2868             }
2869             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
2870             if (stats.isEmpty())
2871                 storeEnd(c, S.prevToken().endPos);
2872             return cases.append(c).toList();
</pre>
<hr />
<pre>
3163 
3164     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3165      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3166      *
3167      *  @param reqInit  Is an initializer always required?
3168      *  @param dc       The documentation comment for the variable declarations, or null.
3169      */
3170     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3171                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3172         type = bracketsOpt(type);
3173         JCExpression init = null;
3174         if (token.kind == EQ) {
3175             nextToken();
3176             init = variableInitializer();
3177         }
3178         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3179         JCTree elemType = TreeInfo.innermostType(type, true);
3180         int startPos = Position.NOPOS;
3181         if (elemType.hasTag(IDENT)) {
3182             Name typeName = ((JCIdent)elemType).name;
<span class="line-modified">3183             if (isRestrictedLocalVarTypeName(typeName, pos, !compound &amp;&amp; localDecl)) {</span>
3184                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3185                     //error - &#39;var&#39; and arrays
<span class="line-modified">3186                     reportSyntaxError(pos, Errors.VarNotAllowedArray);</span>
3187                 } else {
3188                     if(compound)
3189                         //error - &#39;var&#39; in compound local var decl
<span class="line-modified">3190                         reportSyntaxError(pos, Errors.VarNotAllowedCompound);</span>
3191                     startPos = TreeInfo.getStartPos(mods);
3192                     if (startPos == Position.NOPOS)
3193                         startPos = TreeInfo.getStartPos(type);
3194                     //implicit type
3195                     type = null;
3196                 }
3197             }
3198         }
3199         JCVariableDecl result =
3200             toP(F.at(pos).VarDef(mods, name, type, init));
3201         attach(result, dc);
3202         result.startPos = startPos;
3203         return result;
3204     }
3205 
<span class="line-modified">3206     boolean isRestrictedLocalVarTypeName(JCExpression e, boolean shouldWarn) {</span>
3207         switch (e.getTag()) {
3208             case IDENT:
<span class="line-modified">3209                 return isRestrictedLocalVarTypeName(((JCIdent)e).name, e.pos, shouldWarn);</span>
3210             case TYPEARRAY:
<span class="line-modified">3211                 return isRestrictedLocalVarTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);</span>
3212             default:
<span class="line-modified">3213                 return false;</span>
3214         }
3215     }
3216 
<span class="line-modified">3217     boolean isRestrictedLocalVarTypeName(Name name, int pos, boolean shouldWarn) {</span>
3218         if (name == names.var) {
3219             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3220                 return true;
3221             } else if (shouldWarn) {
<span class="line-modified">3222                 log.warning(pos, Warnings.VarNotAllowed);</span>














3223             }
3224         }
3225         return false;
3226     }
3227 
3228     /** VariableDeclaratorId = Ident BracketsOpt
3229      */
3230     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3231         return variableDeclaratorId(mods, type, false);
3232     }
3233     //where
3234     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3235         int pos = token.pos;
3236         Name name;
3237         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3238             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3239             name = token.name();
3240             nextToken();
3241         } else {
3242             if (allowThisIdent ||
</pre>
<hr />
<pre>
3260                         }
3261                     }
3262                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3263                 }
3264             } else {
3265                 /** if it is a lambda parameter and the token kind is not an identifier,
3266                  *  and there are no modifiers or annotations, then this means that the compiler
3267                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3268                  *  var or explicit parameters. So we assign the error name to the parameter name
3269                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3270                  *  a higher level.
3271                  */
3272                 name = names.empty;
3273             }
3274         }
3275         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3276                 token.kind == LBRACKET) {
3277             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3278         }
3279         type = bracketsOpt(type);

3280         return toP(F.at(pos).VarDef(mods, name, type, null));
3281     }
3282 
3283     /** Resources = Resource { &quot;;&quot; Resources }
3284      */
3285     List&lt;JCTree&gt; resources() {
3286         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3287         defs.append(resource());
3288         while (token.kind == SEMI) {
3289             // All but last of multiple declarators must subsume a semicolon
3290             storeEnd(defs.last(), token.endPos);
3291             int semiColonPos = token.pos;
3292             nextToken();
3293             if (token.kind == RPAREN) { // Optional trailing semicolon
3294                                        // after last resource
3295                 break;
3296             }
3297             defs.append(resource());
3298         }
3299         return defs.toList();
</pre>
<hr />
<pre>
3529                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3530                 nextToken();
3531                 break;
3532             } else {
3533                 pid = toP(F.at(pos1).Select(pid, ident()));
3534             }
3535         } while (token.kind == DOT);
3536         accept(SEMI);
3537         return toP(F.at(pos).Import(pid, importStatic));
3538     }
3539 
3540     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3541      *                  | &quot;;&quot;
3542      */
3543     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3544         int pos = token.pos;
3545         if (mods == null &amp;&amp; token.kind == SEMI) {
3546             nextToken();
3547             return toP(F.at(pos).Skip());
3548         } else {
<span class="line-modified">3549             return classOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);</span>
3550         }
3551     }
3552 
3553     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3554      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3555      *  @param mods     Any modifiers starting the class or interface declaration
3556      *  @param dc       The documentation comment for the class, or null.
3557      */
<span class="line-modified">3558     protected JCStatement classOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {</span>
3559         if (token.kind == CLASS) {
3560             return classDeclaration(mods, dc);


3561         } else if (token.kind == INTERFACE) {
3562             return interfaceDeclaration(mods, dc);
3563         } else if (token.kind == ENUM) {
3564             return enumDeclaration(mods, dc);
3565         } else {
3566             int pos = token.pos;
3567             List&lt;JCTree&gt; errs;
<span class="line-modified">3568             if (LAX_IDENTIFIER.accepts(token.kind)) {</span>
<span class="line-modified">3569                 errs = List.of(mods, toP(F.at(pos).Ident(ident())));</span>
<span class="line-modified">3570                 setErrorEndPos(token.pos);</span>
<span class="line-modified">3571             } else {</span>
<span class="line-removed">3572                 errs = List.of(mods);</span>
<span class="line-removed">3573             }</span>
<span class="line-removed">3574             final JCErroneous erroneousTree;</span>
<span class="line-removed">3575             if (parseModuleInfo) {</span>
<span class="line-removed">3576                 erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);</span>
3577             } else {
<span class="line-modified">3578                 erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));</span>
















3579             }
<span class="line-removed">3580             return toP(F.Exec(erroneousTree));</span>
3581         }
3582     }
3583 
3584     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3585      *                     [IMPLEMENTS TypeList] ClassBody
3586      *  @param mods    The modifiers starting the class declaration
3587      *  @param dc       The documentation comment for the class, or null.
3588      */
3589     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3590         int pos = token.pos;
3591         accept(CLASS);
3592         Name name = typeName();
3593 
3594         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3595 
3596         JCExpression extending = null;
3597         if (token.kind == EXTENDS) {
3598             nextToken();
3599             extending = parseType();
3600         }
3601         List&lt;JCExpression&gt; implementing = List.nil();
3602         if (token.kind == IMPLEMENTS) {
3603             nextToken();
3604             implementing = typeList();
3605         }
<span class="line-modified">3606         List&lt;JCTree&gt; defs = classOrInterfaceBody(name, false);</span>
3607         JCClassDecl result = toP(F.at(pos).ClassDef(
3608             mods, name, typarams, extending, implementing, defs));
3609         attach(result, dc);
3610         return result;
3611     }
3612 












































3613     Name typeName() {
3614         int pos = token.pos;
3615         Name name = ident();
<span class="line-modified">3616         if (isRestrictedLocalVarTypeName(name, pos, true)) {</span>
<span class="line-modified">3617             reportSyntaxError(pos, Errors.VarNotAllowed);</span>
3618         }
3619         return name;
3620     }
3621 
3622     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3623      *                         [EXTENDS TypeList] InterfaceBody
3624      *  @param mods    The modifiers starting the interface declaration
3625      *  @param dc       The documentation comment for the interface, or null.
3626      */
3627     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3628         int pos = token.pos;
3629         accept(INTERFACE);
3630 
3631         Name name = typeName();
3632 
3633         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3634 
3635         List&lt;JCExpression&gt; extending = List.nil();
3636         if (token.kind == EXTENDS) {
3637             nextToken();
3638             extending = typeList();
3639         }
<span class="line-modified">3640         List&lt;JCTree&gt; defs = classOrInterfaceBody(name, true);</span>
3641         JCClassDecl result = toP(F.at(pos).ClassDef(
3642             mods, name, typarams, null, extending, defs));
3643         attach(result, dc);
3644         return result;
3645     }
3646 
3647     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3648      *  @param mods    The modifiers starting the enum declaration
3649      *  @param dc       The documentation comment for the enum, or null.
3650      */
3651     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3652         int pos = token.pos;
3653         accept(ENUM);
3654 
3655         Name name = typeName();
3656 
3657         List&lt;JCExpression&gt; implementing = List.nil();
3658         if (token.kind == IMPLEMENTS) {
3659             nextToken();
3660             implementing = typeList();
3661         }
3662 
3663         List&lt;JCTree&gt; defs = enumBody(name);
3664         mods.flags |= Flags.ENUM;
3665         JCClassDecl result = toP(F.at(pos).
3666             ClassDef(mods, name, List.nil(),
3667                      null, implementing, defs));
3668         attach(result, dc);
3669         return result;
3670     }
3671 
3672     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3673      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3674      */
3675     List&lt;JCTree&gt; enumBody(Name enumName) {
3676         accept(LBRACE);
3677         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();



3678         if (token.kind == COMMA) {
3679             nextToken();
<span class="line-modified">3680         } else if (token.kind != RBRACE &amp;&amp; token.kind != SEMI) {</span>
<span class="line-modified">3681             defs.append(enumeratorDeclaration(enumName));</span>
<span class="line-removed">3682             while (token.kind == COMMA) {</span>
<span class="line-removed">3683                 nextToken();</span>
<span class="line-removed">3684                 if (token.kind == RBRACE || token.kind == SEMI) break;</span>
<span class="line-removed">3685                 defs.append(enumeratorDeclaration(enumName));</span>
<span class="line-removed">3686             }</span>
<span class="line-removed">3687             if (token.kind != SEMI &amp;&amp; token.kind != RBRACE) {</span>
<span class="line-removed">3688                 defs.append(syntaxError(token.pos, Errors.Expected3(COMMA, RBRACE, SEMI)));</span>
3689                 nextToken();




3690             }
3691         }
<span class="line-modified">3692         if (token.kind == SEMI) {</span>
<span class="line-modified">3693             nextToken();</span>
<span class="line-modified">3694             while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {</span>
<span class="line-modified">3695                 defs.appendList(classOrInterfaceBodyDeclaration(enumName,</span>
<span class="line-modified">3696                                                                 false));</span>




































3697                 if (token.pos &lt;= endPosTable.errorEndPos) {
3698                     // error recovery
3699                    skip(false, true, true, false);
3700                 }
3701             }
3702         }
3703         accept(RBRACE);
3704         return defs.toList();
3705     }
3706 






















3707     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3708      */
3709     JCTree enumeratorDeclaration(Name enumName) {
3710         Comment dc = token.comment(CommentStyle.JAVADOC);
3711         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3712         if (token.deprecatedFlag()) {
3713             flags |= Flags.DEPRECATED;
3714         }
3715         int pos = token.pos;
3716         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3717         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3718         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
3719         int identPos = token.pos;
3720         Name name = ident();
3721         int createPos = token.pos;
3722         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
3723             ? arguments() : List.nil();
3724         JCClassDecl body = null;
3725         if (token.kind == LBRACE) {
3726             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
<span class="line-modified">3727             List&lt;JCTree&gt; defs = classOrInterfaceBody(names.empty, false);</span>
3728             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
3729         }
3730         if (args.isEmpty() &amp;&amp; body == null)
3731             createPos = identPos;
3732         JCIdent ident = F.at(identPos).Ident(enumName);
3733         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
3734         if (createPos != identPos)
3735             storeEnd(create, S.prevToken().endPos);
3736         ident = F.at(identPos).Ident(enumName);
3737         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
3738         attach(result, dc);
3739         return result;
3740     }
3741 
3742     /** TypeList = Type {&quot;,&quot; Type}
3743      */
3744     List&lt;JCExpression&gt; typeList() {
3745         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
3746         ts.append(parseType());
3747         while (token.kind == COMMA) {
3748             nextToken();
3749             ts.append(parseType());
3750         }
3751         return ts.toList();
3752     }
3753 
3754     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
3755      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
3756      */
<span class="line-modified">3757     List&lt;JCTree&gt; classOrInterfaceBody(Name className, boolean isInterface) {</span>
3758         accept(LBRACE);
3759         if (token.pos &lt;= endPosTable.errorEndPos) {
3760             // error recovery
3761             skip(false, true, false, false);
3762             if (token.kind == LBRACE)
3763                 nextToken();
3764         }
3765         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3766         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
<span class="line-modified">3767             defs.appendList(classOrInterfaceBodyDeclaration(className, isInterface));</span>
3768             if (token.pos &lt;= endPosTable.errorEndPos) {
3769                // error recovery
3770                skip(false, true, true, false);
3771            }
3772         }
3773         accept(RBRACE);
3774         return defs.toList();
3775     }
3776 
3777     /** ClassBodyDeclaration =
3778      *      &quot;;&quot;
3779      *    | [STATIC] Block
3780      *    | ModifiersOpt
3781      *      ( Type Ident
3782      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
3783      *      | VOID Ident VoidMethodDeclaratorRest
3784      *      | TypeParameters [Annotations]
3785      *        ( Type Ident MethodDeclaratorRest
3786      *        | VOID Ident VoidMethodDeclaratorRest
3787      *        )
3788      *      | Ident ConstructorDeclaratorRest
3789      *      | TypeParameters Ident ConstructorDeclaratorRest
3790      *      | ClassOrInterfaceOrEnumDeclaration
3791      *      )
3792      *  InterfaceBodyDeclaration =
3793      *      &quot;;&quot;
3794      *    | ModifiersOpt
3795      *      ( Type Ident
3796      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
3797      *      | VOID Ident MethodDeclaratorRest
3798      *      | TypeParameters [Annotations]
3799      *        ( Type Ident MethodDeclaratorRest
3800      *        | VOID Ident VoidMethodDeclaratorRest
3801      *        )
3802      *      | ClassOrInterfaceOrEnumDeclaration
3803      *      )
3804      *
3805      */
<span class="line-modified">3806     protected List&lt;JCTree&gt; classOrInterfaceBodyDeclaration(Name className, boolean isInterface) {</span>
3807         if (token.kind == SEMI) {
3808             nextToken();
3809             return List.nil();
3810         } else {
3811             Comment dc = token.comment(CommentStyle.JAVADOC);
3812             int pos = token.pos;
3813             JCModifiers mods = modifiersOpt();
3814             if (token.kind == CLASS ||

3815                 token.kind == INTERFACE ||
3816                 token.kind == ENUM) {
<span class="line-modified">3817                 return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</span>
3818             } else if (token.kind == LBRACE &amp;&amp;
3819                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
3820                        mods.annotations.isEmpty()) {
3821                 if (isInterface) {
3822                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);


3823                 }
3824                 return List.of(block(pos, mods.flags));
3825             } else {
3826                 pos = token.pos;
3827                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3828                 // if there are type parameters but no modifiers, save the start
3829                 // position of the method in the modifiers.
3830                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
3831                     mods.pos = pos;
3832                     storeEnd(mods, pos);
3833                 }
3834                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
3835 
3836                 if (annosAfterParams.nonEmpty()) {
3837                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
3838                     mods.annotations = mods.annotations.appendList(annosAfterParams);
3839                     if (mods.pos == Position.NOPOS)
3840                         mods.pos = mods.annotations.head.pos;
3841                 }
3842 
3843                 Token tk = token;
3844                 pos = token.pos;
3845                 JCExpression type;
3846                 boolean isVoid = token.kind == VOID;
3847                 if (isVoid) {
3848                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
3849                     nextToken();
3850                 } else {
3851                     // method returns types are un-annotated types
3852                     type = unannotatedType(false);
3853                 }
<span class="line-modified">3854                 if (token.kind == LPAREN &amp;&amp; !isInterface &amp;&amp; type.hasTag(IDENT)) {</span>

3855                     if (isInterface || tk.name() != className)
3856                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
3857                     else if (annosAfterParams.nonEmpty())
3858                         illegal(annosAfterParams.head.pos);



3859                     return List.of(methodDeclaratorRest(
3860                         pos, mods, null, names.init, typarams,
<span class="line-modified">3861                         isInterface, true, dc));</span>











3862                 } else {
3863                     pos = token.pos;
3864                     Name name = ident();
3865                     if (token.kind == LPAREN) {
3866                         return List.of(methodDeclaratorRest(
3867                             pos, mods, type, name, typarams,
<span class="line-modified">3868                             isInterface, isVoid, dc));</span>
3869                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {

3870                         List&lt;JCTree&gt; defs =
3871                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
3872                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
3873                         accept(SEMI);
3874                         storeEnd(defs.last(), S.prevToken().endPos);
3875                         return defs;







3876                     } else {
3877                         pos = token.pos;
3878                         List&lt;JCTree&gt; err;
3879                         if (isVoid || typarams.nonEmpty()) {
3880                             JCMethodDecl m =
3881                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
3882                                                             List.nil(), List.nil(), null, null));
3883                             attach(m, dc);
3884                             err = List.of(m);
3885                         } else {
3886                             err = List.nil();
3887                         }
3888                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
3889                     }
3890                 }
3891             }
3892         }
3893     }
3894 












3895     /** MethodDeclaratorRest =
3896      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
3897      *  VoidMethodDeclaratorRest =
3898      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
3899      *  ConstructorDeclaratorRest =
3900      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
3901      */
3902     protected JCTree methodDeclaratorRest(int pos,
3903                               JCModifiers mods,
3904                               JCExpression type,
3905                               Name name,
3906                               List&lt;JCTypeParameter&gt; typarams,
3907                               boolean isInterface, boolean isVoid,

3908                               Comment dc) {
3909         if (isInterface) {
3910             if ((mods.flags &amp; Flags.STATIC) != 0) {
3911                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
3912             }
3913             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
3914                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
3915             }
3916         }
3917         JCVariableDecl prevReceiverParam = this.receiverParam;
3918         try {
3919             this.receiverParam = null;
3920             // Parsing formalParameters sets the receiverParam, if present
<span class="line-modified">3921             List&lt;JCVariableDecl&gt; params = formalParameters();</span>
<span class="line-removed">3922             if (!isVoid) type = bracketsOpt(type);</span>
3923             List&lt;JCExpression&gt; thrown = List.nil();
<span class="line-modified">3924             if (token.kind == THROWS) {</span>
<span class="line-modified">3925                 nextToken();</span>
<span class="line-modified">3926                 thrown = qualidentList(true);</span>




3927             }
3928             JCBlock body = null;
3929             JCExpression defaultValue;
3930             if (token.kind == LBRACE) {
3931                 body = block();
3932                 defaultValue = null;
3933             } else {
3934                 if (token.kind == DEFAULT) {
3935                     accept(DEFAULT);
3936                     defaultValue = annotationValue();
3937                 } else {
3938                     defaultValue = null;
3939                 }
3940                 accept(SEMI);
3941                 if (token.pos &lt;= endPosTable.errorEndPos) {
3942                     // error recovery
3943                     skip(false, true, false, false);
3944                     if (token.kind == LBRACE) {
3945                         body = block();
3946                     }
</pre>
<hr />
<pre>
4018         int pos = token.pos;
4019         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4020         Name name = typeName();
4021         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4022         if (token.kind == EXTENDS) {
4023             nextToken();
4024             bounds.append(parseType());
4025             while (token.kind == AMP) {
4026                 nextToken();
4027                 bounds.append(parseType());
4028             }
4029         }
4030         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4031     }
4032 
4033     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4034      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4035      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4036      */
4037     List&lt;JCVariableDecl&gt; formalParameters() {
<span class="line-modified">4038         return formalParameters(false);</span>
4039     }
<span class="line-modified">4040     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters) {</span>
4041         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4042         JCVariableDecl lastParam;
4043         accept(LPAREN);
4044         if (token.kind != RPAREN) {
<span class="line-modified">4045             this.allowThisIdent = !lambdaParameters;</span>
<span class="line-modified">4046             lastParam = formalParameter(lambdaParameters);</span>
4047             if (lastParam.nameexpr != null) {
4048                 this.receiverParam = lastParam;
4049             } else {
4050                 params.append(lastParam);
4051             }
4052             this.allowThisIdent = false;
4053             while (token.kind == COMMA) {
4054                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4055                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4056                 }
4057                 nextToken();
<span class="line-modified">4058                 params.append(lastParam = formalParameter(lambdaParameters));</span>
4059             }
4060         }
4061         if (token.kind == RPAREN) {
4062             nextToken();
4063         } else {
4064             setErrorEndPos(token.pos);
4065             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4066         }
4067         return params.toList();
4068     }
4069 
4070     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4071         if (hasParens) {
4072             accept(LPAREN);
4073         }
4074         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4075         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4076             params.append(implicitParameter());
4077             while (token.kind == COMMA) {
4078                 nextToken();
</pre>
<hr />
<pre>
4149             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4150                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4151             } else {
4152                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4153                 mostInnerTypeToReturn = mostInnerType;
4154             }
4155         }
4156 
4157         if (mostInnerArrayType == null) {
4158             return mostInnerTypeToReturn;
4159         } else {
4160             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4161             storeEnd(type, origEndPos);
4162             return type;
4163         }
4164     }
4165 
4166     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4167      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4168      */
<span class="line-modified">4169     protected JCVariableDecl formalParameter() {</span>
<span class="line-modified">4170         return formalParameter(false);</span>
<span class="line-modified">4171     }</span>
<span class="line-modified">4172     protected JCVariableDecl formalParameter(boolean lambdaParameter) {</span>
<span class="line-modified">4173         JCModifiers mods = optFinal(Flags.PARAMETER);</span>



4174         // need to distinguish between vararg annos and array annos
4175         // look at typeAnnotationsPushedBack comment
4176         this.permitTypeAnnotationsPushBack = true;
4177         JCExpression type = parseType(lambdaParameter);
4178         this.permitTypeAnnotationsPushBack = false;
4179 
4180         if (token.kind == ELLIPSIS) {
4181             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4182             typeAnnotationsPushedBack = List.nil();
4183             mods.flags |= Flags.VARARGS;
4184             // insert var arg type annotations
4185             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4186             nextToken();
4187         } else {
4188             // if not a var arg, then typeAnnotationsPushedBack should be null
4189             if (typeAnnotationsPushedBack.nonEmpty()) {
4190                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4191             }
4192             typeAnnotationsPushedBack = List.nil();
4193         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
<span class="line-modified">  32 import com.sun.source.tree.CaseTree;</span>
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
</pre>
<hr />
<pre>
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
<span class="line-added"> 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);</span>
<span class="line-added"> 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 188                 Feature.RECORDS.allowedInSource(source);</span>
 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 
 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
<span class="line-added"> 218     /** Switch: is yield statement allowed in this source level?</span>
<span class="line-added"> 219      */</span>
<span class="line-added"> 220     boolean allowYieldStatement;</span>
<span class="line-added"> 221 </span>
<span class="line-added"> 222     /** Switch: are records allowed in this source level?</span>
<span class="line-added"> 223      */</span>
<span class="line-added"> 224     boolean allowRecords;</span>
<span class="line-added"> 225 </span>
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
 236      */
 237     protected static final int EXPR = 0x1;
 238     protected static final int TYPE = 0x2;
 239     protected static final int NOPARAMS = 0x4;
 240     protected static final int TYPEARG = 0x8;
 241     protected static final int DIAMOND = 0x10;
 242     protected static final int NOLAMBDA = 0x20;
 243 
 244     protected void selectExprMode() {
 245         mode = (mode &amp; NOLAMBDA) | EXPR;
</pre>
<hr />
<pre>
 764         return parseType(false);
 765     }
 766 
 767     public JCExpression parseType(boolean allowVar) {
 768         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 769         return parseType(allowVar, annotations);
 770     }
 771 
 772     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 773         JCExpression result = unannotatedType(allowVar);
 774 
 775         if (annotations.nonEmpty()) {
 776             result = insertAnnotationsToMostInner(result, annotations, false);
 777         }
 778 
 779         return result;
 780     }
 781 
 782     public JCExpression unannotatedType(boolean allowVar) {
 783         JCExpression result = term(TYPE);
<span class="line-added"> 784         Name restrictedTypeName = restrictedTypeName(result, !allowVar);</span>
 785 
<span class="line-modified"> 786         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {</span>
<span class="line-modified"> 787             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));</span>
 788         }
 789 
 790         return result;
 791     }
 792 
 793 
 794 
 795     protected JCExpression term(int newmode) {
 796         int prevmode = mode;
 797         mode = newmode;
 798         JCExpression t = term();
 799         lastmode = mode;
 800         mode = prevmode;
 801         return t;
 802     }
 803 
 804     /**
 805      *  {@literal
 806      *  Expression = Expression1 [ExpressionRest]
 807      *  ExpressionRest = [AssignmentOperator Expression1]
</pre>
<hr />
<pre>
 882             return t;
 883         }
 884     }
 885 
 886     /** Expression2   = Expression3 [Expression2Rest]
 887      *  Type2         = Type3
 888      *  TypeNoParams2 = TypeNoParams3
 889      */
 890     JCExpression term2() {
 891         JCExpression t = term3();
 892         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 893             selectExprMode();
 894             return term2Rest(t, TreeInfo.orPrec);
 895         } else {
 896             return t;
 897         }
 898     }
 899 
 900     /*  Expression2Rest = {infixop Expression3}
 901      *                  | Expression3 instanceof Type
<span class="line-added"> 902      *                  | Expression3 instanceof Pattern</span>
 903      *  infixop         = &quot;||&quot;
 904      *                  | &quot;&amp;&amp;&quot;
 905      *                  | &quot;|&quot;
 906      *                  | &quot;^&quot;
 907      *                  | &quot;&amp;&quot;
 908      *                  | &quot;==&quot; | &quot;!=&quot;
 909      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 910      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 911      *                  | &quot;+&quot; | &quot;-&quot;
 912      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 913      */
 914     JCExpression term2Rest(JCExpression t, int minprec) {
 915         JCExpression[] odStack = newOdStack();
 916         Token[] opStack = newOpStack();
 917 
 918         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 919         int top = 0;
 920         odStack[0] = t;
 921         int startPos = token.pos;
 922         Token topOp = Tokens.DUMMY;
 923         while (prec(token.kind) &gt;= minprec) {
 924             opStack[top] = topOp;
<span class="line-modified"> 925 </span>
<span class="line-modified"> 926             if (token.kind == INSTANCEOF) {</span>
<span class="line-modified"> 927                 int pos = token.pos;</span>
<span class="line-modified"> 928                 nextToken();</span>
<span class="line-added"> 929                 JCTree pattern = parseType();</span>
<span class="line-added"> 930                 if (token.kind == IDENTIFIER) {</span>
<span class="line-added"> 931                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);</span>
<span class="line-added"> 932                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));</span>
<span class="line-added"> 933                 }</span>
<span class="line-added"> 934                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);</span>
<span class="line-added"> 935             } else {</span>
<span class="line-added"> 936                 topOp = token;</span>
<span class="line-added"> 937                 nextToken();</span>
<span class="line-added"> 938                 top++;</span>
<span class="line-added"> 939                 odStack[top] = term3();</span>
<span class="line-added"> 940             }</span>
 941             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
<span class="line-modified"> 942                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);</span>

 943                 top--;
 944                 topOp = opStack[top];
 945             }
 946         }
 947         Assert.check(top == 0);
 948         t = odStack[0];
 949 
 950         if (t.hasTag(JCTree.Tag.PLUS)) {
 951             t = foldStrings(t);
 952         }
 953 
 954         odStackSupply.add(odStack);
 955         opStackSupply.add(opStack);
 956         return t;
 957     }
 958     //where













 959         /** If tree is a concatenation of string literals, replace it
 960          *  by a single literal representing the concatenated string.
 961          */
 962         protected JCExpression foldStrings(JCExpression tree) {
 963             if (!allowStringFolding)
 964                 return tree;
 965             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
 966             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
 967             boolean needsFolding = false;
 968             JCExpression curr = tree;
 969             while (true) {
 970                 if (curr.hasTag(JCTree.Tag.PLUS)) {
 971                     JCBinary op = (JCBinary)curr;
 972                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
 973                     curr = op.lhs;
 974                 } else {
 975                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
 976                     break; //last one!
 977                 }
 978             }
</pre>
<hr />
<pre>
1372             if ((mode &amp; EXPR) != 0) {
1373                 nextToken();
1374                 if (token.kind == DOT) {
1375                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1376                     t = bracketsSuffix(ti);
1377                 } else {
1378                     return illegal(pos);
1379                 }
1380             } else {
1381                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1382                 // a void type (like other primitive types) to the next phase.
1383                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1384                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1385                 nextToken();
1386                 return ti;
1387                 //return illegal();
1388             }
1389             break;
1390         case SWITCH:
1391             checkSourceLevel(Feature.SWITCH_EXPRESSION);
<span class="line-added">1392             allowYieldStatement = true;</span>
1393             int switchPos = token.pos;
1394             nextToken();
1395             JCExpression selector = parExpression();
1396             accept(LBRACE);
1397             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1398             while (true) {
1399                 pos = token.pos;
1400                 switch (token.kind) {
1401                 case CASE:
1402                 case DEFAULT:
1403                     cases.appendList(switchExpressionStatementGroup());
1404                     break;
1405                 case RBRACE: case EOF:
1406                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1407                                                                                cases.toList()));
1408                     e.endpos = token.pos;
1409                     accept(RBRACE);
1410                     return e;
1411                 default:
1412                     nextToken(); // to ensure progress
</pre>
<hr />
<pre>
1420     }
1421 
1422     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1423         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1424         int casePos = token.pos;
1425         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1426 
1427         if (token.kind == DEFAULT) {
1428             nextToken();
1429         } else {
1430             accept(CASE);
1431             while (true) {
1432                 pats.append(term(EXPR | NOLAMBDA));
1433                 if (token.kind != COMMA) break;
1434                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1435                 nextToken();
1436             };
1437         }
1438         List&lt;JCStatement&gt; stats = null;
1439         JCTree body = null;
<span class="line-modified">1440         CaseTree.CaseKind kind;</span>

1441         switch (token.kind) {
1442             case ARROW:
1443                 checkSourceLevel(Feature.SWITCH_RULE);
1444                 nextToken();
1445                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1446                     stats = List.of(parseStatement());
1447                     body = stats.head;
1448                     kind = JCCase.RULE;
1449                 } else {
1450                     JCExpression value = parseExpression();
<span class="line-modified">1451                     stats = List.of(to(F.at(value).Yield(value)));</span>
1452                     body = value;
1453                     kind = JCCase.RULE;
1454                     accept(SEMI);
1455                 }
1456                 break;
1457             default:
1458                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1459                 stats = blockStatements();
1460                 kind = JCCase.STATEMENT;
1461                 break;
1462         }
1463         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1464         return caseExprs.toList();
1465     }
1466 
1467     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1468         if (typeArgs != null) illegal();
1469         while (true) {
1470             int pos1 = token.pos;
1471             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
</pre>
<hr />
<pre>
1602                             nextKind == TokenKind.LBRACKET ||
1603                             nextKind == TokenKind.COLCOL;
1604                     }
1605                     break;
1606                 default:
1607                     return false;
1608             }
1609         }
1610     }
1611 
1612     /**
1613      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1614      * method reference or a binary expression. To disambiguate, look for a
1615      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1616      */
1617     @SuppressWarnings(&quot;fallthrough&quot;)
1618     ParensResult analyzeParens() {
1619         int depth = 0;
1620         boolean type = false;
1621         ParensResult defaultResult = ParensResult.PARENS;
<span class="line-modified">1622         outer: for (int lookahead = 0; ; lookahead++) {</span>
1623             TokenKind tk = S.token(lookahead).kind;
1624             switch (tk) {
1625                 case COMMA:
1626                     type = true;
1627                 case EXTENDS: case SUPER: case DOT: case AMP:
1628                     //skip
1629                     break;
1630                 case QUES:
1631                     if (peekToken(lookahead, EXTENDS) ||
1632                             peekToken(lookahead, SUPER)) {
1633                         //wildcards
1634                         type = true;
1635                     }
1636                     break;
1637                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1638                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1639                     if (peekToken(lookahead, RPAREN)) {
1640                         //Type, &#39;)&#39; -&gt; cast
1641                         return ParensResult.CAST;
1642                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
</pre>
<hr />
<pre>
1650                         return ParensResult.PARENS;
1651                     } else if (peekToken(lookahead, RPAREN)) {
1652                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1653                         return ParensResult.EXPLICIT_LAMBDA;
1654                     }
1655                     break;
1656                 case RPAREN:
1657                     // if we have seen something that looks like a type,
1658                     // then it&#39;s a cast expression
1659                     if (type) return ParensResult.CAST;
1660                     // otherwise, disambiguate cast vs. parenthesized expression
1661                     // based on subsequent token.
1662                     switch (S.token(lookahead + 1).kind) {
1663                         /*case PLUSPLUS: case SUBSUB: */
1664                         case BANG: case TILDE:
1665                         case LPAREN: case THIS: case SUPER:
1666                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1667                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1668                         case TRUE: case FALSE: case NULL:
1669                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
<span class="line-added">1670                         case SWITCH:</span>
1671                         case BYTE: case SHORT: case CHAR: case INT:
1672                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1673                             return ParensResult.CAST;
1674                         default:
1675                             return defaultResult;
1676                     }
1677                 case UNDERSCORE:
1678                 case ASSERT:
1679                 case ENUM:
1680                 case IDENTIFIER:
1681                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1682                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1683                         return ParensResult.EXPLICIT_LAMBDA;
1684                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1685                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1686                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1687                                                       : ParensResult.PARENS;
1688                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1689                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1690                     }
</pre>
<hr />
<pre>
1772                     break;
1773                 default:
1774                     //this includes EOF
1775                     return defaultResult;
1776             }
1777         }
1778     }
1779 
1780     /** Accepts all identifier-like tokens */
1781     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1782 
1783     enum ParensResult {
1784         CAST,
1785         EXPLICIT_LAMBDA,
1786         IMPLICIT_LAMBDA,
1787         PARENS
1788     }
1789 
1790     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1791         List&lt;JCVariableDecl&gt; params = explicitParams ?
<span class="line-modified">1792                 formalParameters(true, false) :</span>
1793                 implicitParameters(hasParens);
1794         if (explicitParams) {
1795             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1796             for (JCVariableDecl param: params) {
<span class="line-added">1797                 Name restrictedTypeName;</span>
1798                 if (param.vartype != null &amp;&amp;
<span class="line-modified">1799                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;</span>
1800                         param.vartype.hasTag(TYPEARRAY)) {
1801                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1802                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
<span class="line-modified">1803                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));</span>
1804                 }
1805                 lambdaClassifier.addParameter(param);
1806                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1807                     break;
1808                 }
1809             }
1810             if (lambdaClassifier.diagFragment != null) {
1811                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1812             }
1813             for (JCVariableDecl param: params) {
1814                 if (param.vartype != null
<span class="line-modified">1815                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {</span>
1816                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1817                     param.startPos = TreeInfo.getStartPos(param.vartype);
1818                     param.vartype = null;
1819                 }
1820             }
1821         }
1822         return lambdaExpressionOrStatementRest(params, pos);
1823     }
1824 
1825     enum LambdaParameterKind {
1826         VAR(0),
1827         EXPLICIT(1),
1828         IMPLICIT(2),
1829         ERROR(-1);
1830 
1831         private final int index;
1832 
1833         LambdaParameterKind(int index) {
1834             this.index = index;
1835         }
1836     }
1837 
1838     private final static Fragment[][] decisionTable = new Fragment[][] {
1839         /*              VAR                              EXPLICIT                         IMPLICIT  */
1840         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1841         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1842         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1843     };
1844 
1845     class LambdaClassifier {
1846 
1847         LambdaParameterKind kind;
1848         Fragment diagFragment;
1849         List&lt;JCVariableDecl&gt; params;
1850 
1851         void addParameter(JCVariableDecl param) {
1852             if (param.vartype != null &amp;&amp; param.name != names.empty) {
<span class="line-modified">1853                 if (restrictedTypeName(param.vartype, false) != null) {</span>
1854                     reduce(LambdaParameterKind.VAR);
1855                 } else {
1856                     reduce(LambdaParameterKind.EXPLICIT);
1857                 }
1858             }
1859             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1860                 param.vartype != null &amp;&amp; param.name == names.empty) {
1861                 reduce(LambdaParameterKind.IMPLICIT);
1862             }
1863         }
1864 
1865         private void reduce(LambdaParameterKind newKind) {
1866             if (kind == null) {
1867                 kind = newKind;
1868             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1869                 LambdaParameterKind currentKind = kind;
1870                 kind = LambdaParameterKind.ERROR;
1871                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1872                         newKind.index == LambdaParameterKind.VAR.index;
1873                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
</pre>
<hr />
<pre>
1940     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1941      */
1942     List&lt;JCExpression&gt; arguments() {
1943         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1944         if (token.kind == LPAREN) {
1945             nextToken();
1946             if (token.kind != RPAREN) {
1947                 args.append(parseExpression());
1948                 while (token.kind == COMMA) {
1949                     nextToken();
1950                     args.append(parseExpression());
1951                 }
1952             }
1953             accept(RPAREN);
1954         } else {
1955             syntaxError(token.pos, Errors.Expected(LPAREN));
1956         }
1957         return args.toList();
1958     }
1959 
<span class="line-modified">1960     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {</span>
1961         int pos = token.pos;
1962         List&lt;JCExpression&gt; args = arguments();
<span class="line-modified">1963         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);</span>
<span class="line-added">1964         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,</span>
<span class="line-added">1965                                                                     ((JCIdent) t).name)) {</span>
<span class="line-added">1966             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);</span>
<span class="line-added">1967             mi = F.Erroneous(List.of(mi));</span>
<span class="line-added">1968         }</span>
<span class="line-added">1969         return toP(mi);</span>
<span class="line-added">1970     }</span>
<span class="line-added">1971 </span>
<span class="line-added">1972     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {</span>
<span class="line-added">1973         if (name == names.yield) {</span>
<span class="line-added">1974             if (allowYieldStatement) {</span>
<span class="line-added">1975                 return true;</span>
<span class="line-added">1976             } else {</span>
<span class="line-added">1977                 log.warning(pos, Warnings.InvalidYield);</span>
<span class="line-added">1978             }</span>
<span class="line-added">1979         }</span>
<span class="line-added">1980         return false;</span>
1981     }
1982 
1983     /**  TypeArgumentsOpt = [ TypeArguments ]
1984      */
1985     JCExpression typeArgumentsOpt(JCExpression t) {
1986         if (token.kind == LT &amp;&amp;
1987             (mode &amp; TYPE) != 0 &amp;&amp;
1988             (mode &amp; NOPARAMS) == 0) {
1989             selectTypeMode();
1990             return typeArguments(t, false);
1991         } else {
1992             return t;
1993         }
1994     }
1995     List&lt;JCExpression&gt; typeArgumentsOpt() {
1996         return typeArgumentsOpt(TYPE);
1997     }
1998 
1999     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2000         if (token.kind == LT) {
</pre>
<hr />
<pre>
2387 
2388             if (elems != null) {
2389                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2390             }
2391 
2392             return na;
2393         }
2394     }
2395 
2396     /** ClassCreatorRest = Arguments [ClassBody]
2397      */
2398     JCNewClass classCreatorRest(int newpos,
2399                                   JCExpression encl,
2400                                   List&lt;JCExpression&gt; typeArgs,
2401                                   JCExpression t)
2402     {
2403         List&lt;JCExpression&gt; args = arguments();
2404         JCClassDecl body = null;
2405         if (token.kind == LBRACE) {
2406             int pos = token.pos;
<span class="line-modified">2407             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);</span>
2408             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2409             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2410         }
2411         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2412     }
2413 
2414     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2415      */
2416     JCExpression arrayInitializer(int newpos, JCExpression t) {
2417         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2418         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2419     }
2420 
2421     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2422         accept(LBRACE);
2423         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2424         if (token.kind == COMMA) {
2425             nextToken();
2426         } else if (token.kind != RBRACE) {
2427             elems.append(variableInitializer());
</pre>
<hr />
<pre>
2519             Error error = null;
2520             switch (first.getTag()) {
2521             case CLASSDEF:
2522                 error = Errors.ClassNotAllowed;
2523                 break;
2524             case VARDEF:
2525                 error = Errors.VariableNotAllowed;
2526                 break;
2527             }
2528             if (error != null) {
2529                 log.error(DiagnosticFlag.SYNTAX, first, error);
2530                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2531                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2532             }
2533             return first;
2534         }
2535     }
2536 
2537     /**This method parses a statement appearing inside a block.
2538      */
<span class="line-added">2539     @SuppressWarnings(&quot;fallthrough&quot;)</span>
2540     List&lt;JCStatement&gt; blockStatement() {
2541         //todo: skip to anchor on error(?)
<span class="line-added">2542         Comment dc;</span>
2543         int pos = token.pos;
2544         switch (token.kind) {
2545         case RBRACE: case CASE: case DEFAULT: case EOF:
2546             return List.nil();
2547         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2548         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2549         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2550         case ASSERT:
2551             return List.of(parseSimpleStatement());
2552         case MONKEYS_AT:
2553         case FINAL: {
<span class="line-modified">2554             dc = token.comment(CommentStyle.JAVADOC);</span>
2555             JCModifiers mods = modifiersOpt();
2556             if (token.kind == INTERFACE ||
2557                 token.kind == CLASS ||
<span class="line-modified">2558                 token.kind == ENUM ||</span>
<span class="line-modified">2559                 isRecordStart()) {</span>
<span class="line-added">2560                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));</span>
2561             } else {
2562                 JCExpression t = parseType(true);
2563                 return localVariableDeclarations(mods, t);
2564             }
2565         }
2566         case ABSTRACT: case STRICTFP: {
<span class="line-modified">2567             dc = token.comment(CommentStyle.JAVADOC);</span>
2568             JCModifiers mods = modifiersOpt();
<span class="line-modified">2569             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));</span>
2570         }
2571         case INTERFACE:
2572         case CLASS:
<span class="line-modified">2573             dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="line-modified">2574             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
2575         case ENUM:
2576             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2577             dc = token.comment(CommentStyle.JAVADOC);
<span class="line-modified">2578             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
<span class="line-modified">2579         case IDENTIFIER:</span>
<span class="line-added">2580             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {</span>
<span class="line-added">2581                 Token next = S.token(1);</span>
<span class="line-added">2582                 boolean isYieldStatement;</span>
<span class="line-added">2583                 switch (next.kind) {</span>
<span class="line-added">2584                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:</span>
<span class="line-added">2585                     case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
<span class="line-added">2586                     case NULL: case IDENTIFIER: case TRUE: case FALSE:</span>
<span class="line-added">2587                     case NEW: case SWITCH: case THIS: case SUPER:</span>
<span class="line-added">2588                         isYieldStatement = true;</span>
<span class="line-added">2589                         break;</span>
<span class="line-added">2590                     case PLUSPLUS: case SUBSUB:</span>
<span class="line-added">2591                         isYieldStatement = S.token(2).kind != SEMI;</span>
<span class="line-added">2592                         break;</span>
<span class="line-added">2593                     case LPAREN:</span>
<span class="line-added">2594                         int lookahead = 2;</span>
<span class="line-added">2595                         int balance = 1;</span>
<span class="line-added">2596                         boolean hasComma = false;</span>
<span class="line-added">2597                         Token l;</span>
<span class="line-added">2598                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {</span>
<span class="line-added">2599                             switch (l.kind) {</span>
<span class="line-added">2600                                 case LPAREN: balance++; break;</span>
<span class="line-added">2601                                 case RPAREN: balance--; break;</span>
<span class="line-added">2602                                 case COMMA: if (balance == 1) hasComma = true; break;</span>
<span class="line-added">2603                             }</span>
<span class="line-added">2604                             lookahead++;</span>
<span class="line-added">2605                         }</span>
<span class="line-added">2606                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;</span>
<span class="line-added">2607                         break;</span>
<span class="line-added">2608                     case SEMI: //error recovery - this is not a valid statement:</span>
<span class="line-added">2609                         isYieldStatement = true;</span>
<span class="line-added">2610                         break;</span>
<span class="line-added">2611                     default:</span>
<span class="line-added">2612                         isYieldStatement = false;</span>
<span class="line-added">2613                         break;</span>
<span class="line-added">2614                 }</span>
<span class="line-added">2615 </span>
<span class="line-added">2616                 if (isYieldStatement) {</span>
<span class="line-added">2617                     nextToken();</span>
<span class="line-added">2618                     JCExpression t = term(EXPR);</span>
<span class="line-added">2619                     accept(SEMI);</span>
<span class="line-added">2620                     return List.of(toP(F.at(pos).Yield(t)));</span>
<span class="line-added">2621                 }</span>
<span class="line-added">2622 </span>
<span class="line-added">2623                 //else intentional fall-through</span>
<span class="line-added">2624             }</span>
<span class="line-added">2625         }</span>
<span class="line-added">2626         if (isRecordStart() &amp;&amp; allowRecords) {</span>
<span class="line-added">2627             dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="line-added">2628             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));</span>
<span class="line-added">2629         } else {</span>
2630             Token prevToken = token;
2631             JCExpression t = term(EXPR | TYPE);
2632             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2633                 nextToken();
2634                 JCStatement stat = parseStatementAsBlock();
2635                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2636             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2637                 pos = token.pos;
2638                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2639                 F.at(pos);
2640                 return localVariableDeclarations(mods, t);
2641             } else {
2642                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2643                 t = checkExprStat(t);
2644                 accept(SEMI);
2645                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2646                 return List.of(expr);
2647             }
2648         }
2649     }
</pre>
<hr />
<pre>
2768             JCExpression lock = parExpression();
2769             JCBlock body = block();
2770             return F.at(pos).Synchronized(lock, body);
2771         }
2772         case RETURN: {
2773             nextToken();
2774             JCExpression result = token.kind == SEMI ? null : parseExpression();
2775             accept(SEMI);
2776             JCReturn t = toP(F.at(pos).Return(result));
2777             return t;
2778         }
2779         case THROW: {
2780             nextToken();
2781             JCExpression exc = parseExpression();
2782             accept(SEMI);
2783             JCThrow t = toP(F.at(pos).Throw(exc));
2784             return t;
2785         }
2786         case BREAK: {
2787             nextToken();
<span class="line-modified">2788             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;</span>
2789             accept(SEMI);
<span class="line-modified">2790             JCBreak t = toP(F.at(pos).Break(label));</span>
2791             return t;
2792         }
2793         case CONTINUE: {
2794             nextToken();
2795             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2796             accept(SEMI);
2797             JCContinue t =  toP(F.at(pos).Continue(label));
2798             return t;
2799         }
2800         case SEMI:
2801             nextToken();
2802             return toP(F.at(pos).Skip());
2803         case ELSE:
2804             int elsePos = token.pos;
2805             nextToken();
2806             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2807         case FINALLY:
2808             int finallyPos = token.pos;
2809             nextToken();
2810             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
</pre>
<hr />
<pre>
2890                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2891             }
2892         }
2893     }
2894 
2895     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2896         int pos = token.pos;
2897         List&lt;JCStatement&gt; stats;
2898         JCCase c;
2899         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2900         switch (token.kind) {
2901         case CASE: {
2902             nextToken();
2903             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2904             while (true) {
2905                 pats.append(term(EXPR | NOLAMBDA));
2906                 if (token.kind != COMMA) break;
2907                 nextToken();
2908                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2909             };
<span class="line-modified">2910             CaseTree.CaseKind caseKind;</span>

2911             JCTree body = null;
2912             if (token.kind == ARROW) {
2913                 checkSourceLevel(Feature.SWITCH_RULE);
2914                 accept(ARROW);
2915                 caseKind = JCCase.RULE;
2916                 JCStatement statement = parseStatementAsBlock();
2917                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2918                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2919                 }
2920                 stats = List.of(statement);
2921                 body = stats.head;
2922             } else {
2923                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2924                 caseKind = JCCase.STATEMENT;
2925                 stats = blockStatements();
2926             }
2927             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2928             if (stats.isEmpty())
2929                 storeEnd(c, S.prevToken().endPos);
2930             return cases.append(c).toList();
2931         }
2932         case DEFAULT: {
2933             nextToken();
<span class="line-modified">2934             CaseTree.CaseKind caseKind;</span>

2935             JCTree body = null;
2936             if (token.kind == ARROW) {
2937                 checkSourceLevel(Feature.SWITCH_RULE);
2938                 accept(ARROW);
2939                 caseKind = JCCase.RULE;
2940                 JCStatement statement = parseStatementAsBlock();
2941                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2942                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2943                 }
2944                 stats = List.of(statement);
2945                 body = stats.head;
2946             } else {
2947                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2948                 caseKind = JCCase.STATEMENT;
2949                 stats = blockStatements();
2950             }
2951             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
2952             if (stats.isEmpty())
2953                 storeEnd(c, S.prevToken().endPos);
2954             return cases.append(c).toList();
</pre>
<hr />
<pre>
3245 
3246     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3247      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3248      *
3249      *  @param reqInit  Is an initializer always required?
3250      *  @param dc       The documentation comment for the variable declarations, or null.
3251      */
3252     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3253                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3254         type = bracketsOpt(type);
3255         JCExpression init = null;
3256         if (token.kind == EQ) {
3257             nextToken();
3258             init = variableInitializer();
3259         }
3260         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3261         JCTree elemType = TreeInfo.innermostType(type, true);
3262         int startPos = Position.NOPOS;
3263         if (elemType.hasTag(IDENT)) {
3264             Name typeName = ((JCIdent)elemType).name;
<span class="line-modified">3265             if (isRestrictedTypeName(typeName, pos, !compound &amp;&amp; localDecl)) {</span>
3266                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3267                     //error - &#39;var&#39; and arrays
<span class="line-modified">3268                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));</span>
3269                 } else {
3270                     if(compound)
3271                         //error - &#39;var&#39; in compound local var decl
<span class="line-modified">3272                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));</span>
3273                     startPos = TreeInfo.getStartPos(mods);
3274                     if (startPos == Position.NOPOS)
3275                         startPos = TreeInfo.getStartPos(type);
3276                     //implicit type
3277                     type = null;
3278                 }
3279             }
3280         }
3281         JCVariableDecl result =
3282             toP(F.at(pos).VarDef(mods, name, type, init));
3283         attach(result, dc);
3284         result.startPos = startPos;
3285         return result;
3286     }
3287 
<span class="line-modified">3288     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {</span>
3289         switch (e.getTag()) {
3290             case IDENT:
<span class="line-modified">3291                 return isRestrictedTypeName(((JCIdent)e).name, e.pos, shouldWarn) ? ((JCIdent)e).name : null;</span>
3292             case TYPEARRAY:
<span class="line-modified">3293                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);</span>
3294             default:
<span class="line-modified">3295                 return null;</span>
3296         }
3297     }
3298 
<span class="line-modified">3299     boolean isRestrictedTypeName(Name name, int pos, boolean shouldWarn) {</span>
3300         if (name == names.var) {
3301             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3302                 return true;
3303             } else if (shouldWarn) {
<span class="line-modified">3304                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));</span>
<span class="line-added">3305             }</span>
<span class="line-added">3306         }</span>
<span class="line-added">3307         if (name == names.yield) {</span>
<span class="line-added">3308             if (allowYieldStatement) {</span>
<span class="line-added">3309                 return true;</span>
<span class="line-added">3310             } else if (shouldWarn) {</span>
<span class="line-added">3311                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));</span>
<span class="line-added">3312             }</span>
<span class="line-added">3313         }</span>
<span class="line-added">3314         if (name == names.record) {</span>
<span class="line-added">3315             if (allowRecords) {</span>
<span class="line-added">3316                 return true;</span>
<span class="line-added">3317             } else if (shouldWarn) {</span>
<span class="line-added">3318                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));</span>
3319             }
3320         }
3321         return false;
3322     }
3323 
3324     /** VariableDeclaratorId = Ident BracketsOpt
3325      */
3326     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3327         return variableDeclaratorId(mods, type, false);
3328     }
3329     //where
3330     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3331         int pos = token.pos;
3332         Name name;
3333         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3334             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3335             name = token.name();
3336             nextToken();
3337         } else {
3338             if (allowThisIdent ||
</pre>
<hr />
<pre>
3356                         }
3357                     }
3358                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3359                 }
3360             } else {
3361                 /** if it is a lambda parameter and the token kind is not an identifier,
3362                  *  and there are no modifiers or annotations, then this means that the compiler
3363                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3364                  *  var or explicit parameters. So we assign the error name to the parameter name
3365                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3366                  *  a higher level.
3367                  */
3368                 name = names.empty;
3369             }
3370         }
3371         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3372                 token.kind == LBRACKET) {
3373             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3374         }
3375         type = bracketsOpt(type);
<span class="line-added">3376 </span>
3377         return toP(F.at(pos).VarDef(mods, name, type, null));
3378     }
3379 
3380     /** Resources = Resource { &quot;;&quot; Resources }
3381      */
3382     List&lt;JCTree&gt; resources() {
3383         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3384         defs.append(resource());
3385         while (token.kind == SEMI) {
3386             // All but last of multiple declarators must subsume a semicolon
3387             storeEnd(defs.last(), token.endPos);
3388             int semiColonPos = token.pos;
3389             nextToken();
3390             if (token.kind == RPAREN) { // Optional trailing semicolon
3391                                        // after last resource
3392                 break;
3393             }
3394             defs.append(resource());
3395         }
3396         return defs.toList();
</pre>
<hr />
<pre>
3626                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3627                 nextToken();
3628                 break;
3629             } else {
3630                 pid = toP(F.at(pos1).Select(pid, ident()));
3631             }
3632         } while (token.kind == DOT);
3633         accept(SEMI);
3634         return toP(F.at(pos).Import(pid, importStatic));
3635     }
3636 
3637     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3638      *                  | &quot;;&quot;
3639      */
3640     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3641         int pos = token.pos;
3642         if (mods == null &amp;&amp; token.kind == SEMI) {
3643             nextToken();
3644             return toP(F.at(pos).Skip());
3645         } else {
<span class="line-modified">3646             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);</span>
3647         }
3648     }
3649 
3650     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3651      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3652      *  @param mods     Any modifiers starting the class or interface declaration
3653      *  @param dc       The documentation comment for the class, or null.
3654      */
<span class="line-modified">3655     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {</span>
3656         if (token.kind == CLASS) {
3657             return classDeclaration(mods, dc);
<span class="line-added">3658         } if (isRecordStart()) {</span>
<span class="line-added">3659             return recordDeclaration(mods, dc);</span>
3660         } else if (token.kind == INTERFACE) {
3661             return interfaceDeclaration(mods, dc);
3662         } else if (token.kind == ENUM) {
3663             return enumDeclaration(mods, dc);
3664         } else {
3665             int pos = token.pos;
3666             List&lt;JCTree&gt; errs;
<span class="line-modified">3667             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {</span>
<span class="line-modified">3668                 checkSourceLevel(Feature.RECORDS);</span>
<span class="line-modified">3669                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);</span>
<span class="line-modified">3670                 return toP(F.Exec(erroneousTree));</span>





3671             } else {
<span class="line-modified">3672                 if (LAX_IDENTIFIER.accepts(token.kind)) {</span>
<span class="line-added">3673                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));</span>
<span class="line-added">3674                     setErrorEndPos(token.pos);</span>
<span class="line-added">3675                 } else {</span>
<span class="line-added">3676                     errs = List.of(mods);</span>
<span class="line-added">3677                 }</span>
<span class="line-added">3678                 final JCErroneous erroneousTree;</span>
<span class="line-added">3679                 if (parseModuleInfo) {</span>
<span class="line-added">3680                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);</span>
<span class="line-added">3681                 } else {</span>
<span class="line-added">3682                     if (allowRecords) {</span>
<span class="line-added">3683                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));</span>
<span class="line-added">3684                     } else {</span>
<span class="line-added">3685                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));</span>
<span class="line-added">3686                     }</span>
<span class="line-added">3687                 }</span>
<span class="line-added">3688                 return toP(F.Exec(erroneousTree));</span>
3689             }

3690         }
3691     }
3692 
3693     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3694      *                     [IMPLEMENTS TypeList] ClassBody
3695      *  @param mods    The modifiers starting the class declaration
3696      *  @param dc       The documentation comment for the class, or null.
3697      */
3698     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3699         int pos = token.pos;
3700         accept(CLASS);
3701         Name name = typeName();
3702 
3703         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3704 
3705         JCExpression extending = null;
3706         if (token.kind == EXTENDS) {
3707             nextToken();
3708             extending = parseType();
3709         }
3710         List&lt;JCExpression&gt; implementing = List.nil();
3711         if (token.kind == IMPLEMENTS) {
3712             nextToken();
3713             implementing = typeList();
3714         }
<span class="line-modified">3715         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);</span>
3716         JCClassDecl result = toP(F.at(pos).ClassDef(
3717             mods, name, typarams, extending, implementing, defs));
3718         attach(result, dc);
3719         return result;
3720     }
3721 
<span class="line-added">3722     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {</span>
<span class="line-added">3723         int pos = token.pos;</span>
<span class="line-added">3724         nextToken();</span>
<span class="line-added">3725         mods.flags |= Flags.RECORD;</span>
<span class="line-added">3726         Name name = typeName();</span>
<span class="line-added">3727 </span>
<span class="line-added">3728         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();</span>
<span class="line-added">3729 </span>
<span class="line-added">3730         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);</span>
<span class="line-added">3731 </span>
<span class="line-added">3732         List&lt;JCExpression&gt; implementing = List.nil();</span>
<span class="line-added">3733         if (token.kind == IMPLEMENTS) {</span>
<span class="line-added">3734             nextToken();</span>
<span class="line-added">3735             implementing = typeList();</span>
<span class="line-added">3736         }</span>
<span class="line-added">3737         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);</span>
<span class="line-added">3738         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="line-added">3739         for (JCVariableDecl field : headerFields) {</span>
<span class="line-added">3740             fields.add(field);</span>
<span class="line-added">3741         }</span>
<span class="line-added">3742         for (JCTree def : defs) {</span>
<span class="line-added">3743             if (def.hasTag(METHODDEF)) {</span>
<span class="line-added">3744                 JCMethodDecl methDef = (JCMethodDecl) def;</span>
<span class="line-added">3745                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {</span>
<span class="line-added">3746                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();</span>
<span class="line-added">3747                     for (JCVariableDecl param : headerFields) {</span>
<span class="line-added">3748                         tmpParams.add(F.at(param)</span>
<span class="line-added">3749                                 // we will get flags plus annotations from the record component</span>
<span class="line-added">3750                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),</span>
<span class="line-added">3751                                 param.name, param.vartype, null));</span>
<span class="line-added">3752                     }</span>
<span class="line-added">3753                     methDef.params = tmpParams.toList();</span>
<span class="line-added">3754                 }</span>
<span class="line-added">3755             }</span>
<span class="line-added">3756         }</span>
<span class="line-added">3757         for (int i = fields.size() - 1; i &gt;= 0; i--) {</span>
<span class="line-added">3758             JCVariableDecl field = fields.get(i);</span>
<span class="line-added">3759             defs = defs.prepend(field);</span>
<span class="line-added">3760         }</span>
<span class="line-added">3761         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));</span>
<span class="line-added">3762         attach(result, dc);</span>
<span class="line-added">3763         return result;</span>
<span class="line-added">3764     }</span>
<span class="line-added">3765 </span>
3766     Name typeName() {
3767         int pos = token.pos;
3768         Name name = ident();
<span class="line-modified">3769         if (isRestrictedTypeName(name, pos, true)) {</span>
<span class="line-modified">3770             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, name == names.var ? Source.JDK10 : Source.JDK13));</span>
3771         }
3772         return name;
3773     }
3774 
3775     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3776      *                         [EXTENDS TypeList] InterfaceBody
3777      *  @param mods    The modifiers starting the interface declaration
3778      *  @param dc       The documentation comment for the interface, or null.
3779      */
3780     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3781         int pos = token.pos;
3782         accept(INTERFACE);
3783 
3784         Name name = typeName();
3785 
3786         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3787 
3788         List&lt;JCExpression&gt; extending = List.nil();
3789         if (token.kind == EXTENDS) {
3790             nextToken();
3791             extending = typeList();
3792         }
<span class="line-modified">3793         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);</span>
3794         JCClassDecl result = toP(F.at(pos).ClassDef(
3795             mods, name, typarams, null, extending, defs));
3796         attach(result, dc);
3797         return result;
3798     }
3799 
3800     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3801      *  @param mods    The modifiers starting the enum declaration
3802      *  @param dc       The documentation comment for the enum, or null.
3803      */
3804     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3805         int pos = token.pos;
3806         accept(ENUM);
3807 
3808         Name name = typeName();
3809 
3810         List&lt;JCExpression&gt; implementing = List.nil();
3811         if (token.kind == IMPLEMENTS) {
3812             nextToken();
3813             implementing = typeList();
3814         }
3815 
3816         List&lt;JCTree&gt; defs = enumBody(name);
3817         mods.flags |= Flags.ENUM;
3818         JCClassDecl result = toP(F.at(pos).
3819             ClassDef(mods, name, List.nil(),
3820                      null, implementing, defs));
3821         attach(result, dc);
3822         return result;
3823     }
3824 
3825     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3826      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3827      */
3828     List&lt;JCTree&gt; enumBody(Name enumName) {
3829         accept(LBRACE);
3830         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
<span class="line-added">3831         boolean wasSemi = false;</span>
<span class="line-added">3832         boolean hasStructuralErrors = false;</span>
<span class="line-added">3833         boolean wasError = false;</span>
3834         if (token.kind == COMMA) {
3835             nextToken();
<span class="line-modified">3836             if (token.kind == SEMI) {</span>
<span class="line-modified">3837                 wasSemi = true;</span>







3838                 nextToken();
<span class="line-added">3839             } else if (token.kind != RBRACE) {</span>
<span class="line-added">3840                 reportSyntaxError(S.prevToken().endPos,</span>
<span class="line-added">3841                                   Errors.Expected2(RBRACE, SEMI));</span>
<span class="line-added">3842                 wasError = true;</span>
3843             }
3844         }
<span class="line-modified">3845         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {</span>
<span class="line-modified">3846             if (token.kind == SEMI) {</span>
<span class="line-modified">3847                 accept(SEMI);</span>
<span class="line-modified">3848                 wasSemi = true;</span>
<span class="line-modified">3849                 if (token.kind == RBRACE || token.kind == EOF) break;</span>
<span class="line-added">3850             }</span>
<span class="line-added">3851             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);</span>
<span class="line-added">3852             if (memberType == EnumeratorEstimate.UNKNOWN) {</span>
<span class="line-added">3853                 memberType = wasSemi ? EnumeratorEstimate.MEMBER</span>
<span class="line-added">3854                                      : EnumeratorEstimate.ENUMERATOR;</span>
<span class="line-added">3855             }</span>
<span class="line-added">3856             if (memberType == EnumeratorEstimate.ENUMERATOR) {</span>
<span class="line-added">3857                 wasError = false;</span>
<span class="line-added">3858                 if (wasSemi &amp;&amp; !hasStructuralErrors) {</span>
<span class="line-added">3859                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);</span>
<span class="line-added">3860                     hasStructuralErrors = true;</span>
<span class="line-added">3861                 }</span>
<span class="line-added">3862                 defs.append(enumeratorDeclaration(enumName));</span>
<span class="line-added">3863                 if (token.pos &lt;= endPosTable.errorEndPos) {</span>
<span class="line-added">3864                     // error recovery</span>
<span class="line-added">3865                    skip(false, true, true, false);</span>
<span class="line-added">3866                 } else {</span>
<span class="line-added">3867                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {</span>
<span class="line-added">3868                         if (token.kind == COMMA) {</span>
<span class="line-added">3869                             nextToken();</span>
<span class="line-added">3870                         } else {</span>
<span class="line-added">3871                             setErrorEndPos(token.pos);</span>
<span class="line-added">3872                             reportSyntaxError(S.prevToken().endPos,</span>
<span class="line-added">3873                                               Errors.Expected3(COMMA, RBRACE, SEMI));</span>
<span class="line-added">3874                             wasError = true;</span>
<span class="line-added">3875                         }</span>
<span class="line-added">3876                     }</span>
<span class="line-added">3877                 }</span>
<span class="line-added">3878             } else {</span>
<span class="line-added">3879                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {</span>
<span class="line-added">3880                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);</span>
<span class="line-added">3881                     hasStructuralErrors = true;</span>
<span class="line-added">3882                 }</span>
<span class="line-added">3883                 wasError = false;</span>
<span class="line-added">3884                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,</span>
<span class="line-added">3885                                                                 false, false));</span>
3886                 if (token.pos &lt;= endPosTable.errorEndPos) {
3887                     // error recovery
3888                    skip(false, true, true, false);
3889                 }
3890             }
3891         }
3892         accept(RBRACE);
3893         return defs.toList();
3894     }
3895 
<span class="line-added">3896     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {</span>
<span class="line-added">3897         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {</span>
<span class="line-added">3898             Token next = S.token(1);</span>
<span class="line-added">3899             switch (next.kind) {</span>
<span class="line-added">3900                 case LPAREN: case LBRACE: case COMMA: case SEMI:</span>
<span class="line-added">3901                     return EnumeratorEstimate.ENUMERATOR;</span>
<span class="line-added">3902             }</span>
<span class="line-added">3903         }</span>
<span class="line-added">3904         switch (token.kind) {</span>
<span class="line-added">3905             case IDENTIFIER: case MONKEYS_AT: case LT:</span>
<span class="line-added">3906                 return EnumeratorEstimate.UNKNOWN;</span>
<span class="line-added">3907             default:</span>
<span class="line-added">3908                 return EnumeratorEstimate.MEMBER;</span>
<span class="line-added">3909         }</span>
<span class="line-added">3910     }</span>
<span class="line-added">3911 </span>
<span class="line-added">3912     private enum EnumeratorEstimate {</span>
<span class="line-added">3913         ENUMERATOR,</span>
<span class="line-added">3914         MEMBER,</span>
<span class="line-added">3915         UNKNOWN;</span>
<span class="line-added">3916     }</span>
<span class="line-added">3917 </span>
3918     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3919      */
3920     JCTree enumeratorDeclaration(Name enumName) {
3921         Comment dc = token.comment(CommentStyle.JAVADOC);
3922         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3923         if (token.deprecatedFlag()) {
3924             flags |= Flags.DEPRECATED;
3925         }
3926         int pos = token.pos;
3927         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3928         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3929         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
3930         int identPos = token.pos;
3931         Name name = ident();
3932         int createPos = token.pos;
3933         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
3934             ? arguments() : List.nil();
3935         JCClassDecl body = null;
3936         if (token.kind == LBRACE) {
3937             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
<span class="line-modified">3938             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);</span>
3939             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
3940         }
3941         if (args.isEmpty() &amp;&amp; body == null)
3942             createPos = identPos;
3943         JCIdent ident = F.at(identPos).Ident(enumName);
3944         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
3945         if (createPos != identPos)
3946             storeEnd(create, S.prevToken().endPos);
3947         ident = F.at(identPos).Ident(enumName);
3948         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
3949         attach(result, dc);
3950         return result;
3951     }
3952 
3953     /** TypeList = Type {&quot;,&quot; Type}
3954      */
3955     List&lt;JCExpression&gt; typeList() {
3956         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
3957         ts.append(parseType());
3958         while (token.kind == COMMA) {
3959             nextToken();
3960             ts.append(parseType());
3961         }
3962         return ts.toList();
3963     }
3964 
3965     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
3966      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
3967      */
<span class="line-modified">3968     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {</span>
3969         accept(LBRACE);
3970         if (token.pos &lt;= endPosTable.errorEndPos) {
3971             // error recovery
3972             skip(false, true, false, false);
3973             if (token.kind == LBRACE)
3974                 nextToken();
3975         }
3976         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3977         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
<span class="line-modified">3978             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));</span>
3979             if (token.pos &lt;= endPosTable.errorEndPos) {
3980                // error recovery
3981                skip(false, true, true, false);
3982            }
3983         }
3984         accept(RBRACE);
3985         return defs.toList();
3986     }
3987 
3988     /** ClassBodyDeclaration =
3989      *      &quot;;&quot;
3990      *    | [STATIC] Block
3991      *    | ModifiersOpt
3992      *      ( Type Ident
3993      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
3994      *      | VOID Ident VoidMethodDeclaratorRest
3995      *      | TypeParameters [Annotations]
3996      *        ( Type Ident MethodDeclaratorRest
3997      *        | VOID Ident VoidMethodDeclaratorRest
3998      *        )
3999      *      | Ident ConstructorDeclaratorRest
4000      *      | TypeParameters Ident ConstructorDeclaratorRest
4001      *      | ClassOrInterfaceOrEnumDeclaration
4002      *      )
4003      *  InterfaceBodyDeclaration =
4004      *      &quot;;&quot;
4005      *    | ModifiersOpt
4006      *      ( Type Ident
4007      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4008      *      | VOID Ident MethodDeclaratorRest
4009      *      | TypeParameters [Annotations]
4010      *        ( Type Ident MethodDeclaratorRest
4011      *        | VOID Ident VoidMethodDeclaratorRest
4012      *        )
4013      *      | ClassOrInterfaceOrEnumDeclaration
4014      *      )
4015      *
4016      */
<span class="line-modified">4017     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {</span>
4018         if (token.kind == SEMI) {
4019             nextToken();
4020             return List.nil();
4021         } else {
4022             Comment dc = token.comment(CommentStyle.JAVADOC);
4023             int pos = token.pos;
4024             JCModifiers mods = modifiersOpt();
4025             if (token.kind == CLASS ||
<span class="line-added">4026                 allowRecords &amp;&amp; isRecordStart() ||</span>
4027                 token.kind == INTERFACE ||
4028                 token.kind == ENUM) {
<span class="line-modified">4029                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));</span>
4030             } else if (token.kind == LBRACE &amp;&amp;
4031                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4032                        mods.annotations.isEmpty()) {
4033                 if (isInterface) {
4034                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
<span class="line-added">4035                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {</span>
<span class="line-added">4036                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);</span>
4037                 }
4038                 return List.of(block(pos, mods.flags));
4039             } else {
4040                 pos = token.pos;
4041                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4042                 // if there are type parameters but no modifiers, save the start
4043                 // position of the method in the modifiers.
4044                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4045                     mods.pos = pos;
4046                     storeEnd(mods, pos);
4047                 }
4048                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4049 
4050                 if (annosAfterParams.nonEmpty()) {
4051                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4052                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4053                     if (mods.pos == Position.NOPOS)
4054                         mods.pos = mods.annotations.head.pos;
4055                 }
4056 
4057                 Token tk = token;
4058                 pos = token.pos;
4059                 JCExpression type;
4060                 boolean isVoid = token.kind == VOID;
4061                 if (isVoid) {
4062                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4063                     nextToken();
4064                 } else {
4065                     // method returns types are un-annotated types
4066                     type = unannotatedType(false);
4067                 }
<span class="line-modified">4068                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||</span>
<span class="line-added">4069                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {</span>
4070                     if (isInterface || tk.name() != className)
4071                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4072                     else if (annosAfterParams.nonEmpty())
4073                         illegal(annosAfterParams.head.pos);
<span class="line-added">4074                     if (isRecord &amp;&amp; token.kind == LBRACE) {</span>
<span class="line-added">4075                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;</span>
<span class="line-added">4076                     }</span>
4077                     return List.of(methodDeclaratorRest(
4078                         pos, mods, null, names.init, typarams,
<span class="line-modified">4079                         isInterface, true, isRecord, dc));</span>
<span class="line-added">4080                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {</span>
<span class="line-added">4081                     // trying to define a compact constructor with a throws clause</span>
<span class="line-added">4082                     log.error(DiagnosticFlag.SYNTAX, token.pos,</span>
<span class="line-added">4083                             Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="line-added">4084                                     Fragments.Compact,</span>
<span class="line-added">4085                                     className,</span>
<span class="line-added">4086                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));</span>
<span class="line-added">4087                     skip(false, true, false, false);</span>
<span class="line-added">4088                     return List.of(methodDeclaratorRest(</span>
<span class="line-added">4089                             pos, mods, null, names.init, typarams,</span>
<span class="line-added">4090                             isInterface, true, isRecord, dc));</span>
4091                 } else {
4092                     pos = token.pos;
4093                     Name name = ident();
4094                     if (token.kind == LPAREN) {
4095                         return List.of(methodDeclaratorRest(
4096                             pos, mods, type, name, typarams,
<span class="line-modified">4097                             isInterface, isVoid, false, dc));</span>
4098                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
<span class="line-added">4099                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {</span>
4100                         List&lt;JCTree&gt; defs =
4101                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4102                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4103                         accept(SEMI);
4104                         storeEnd(defs.last(), S.prevToken().endPos);
4105                         return defs;
<span class="line-added">4106                     } else {</span>
<span class="line-added">4107                             int errPos = pos;</span>
<span class="line-added">4108                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,</span>
<span class="line-added">4109                                     new ListBuffer&lt;JCTree&gt;(), false).toList();</span>
<span class="line-added">4110                             accept(SEMI);</span>
<span class="line-added">4111                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));</span>
<span class="line-added">4112                         }</span>
4113                     } else {
4114                         pos = token.pos;
4115                         List&lt;JCTree&gt; err;
4116                         if (isVoid || typarams.nonEmpty()) {
4117                             JCMethodDecl m =
4118                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4119                                                             List.nil(), List.nil(), null, null));
4120                             attach(m, dc);
4121                             err = List.of(m);
4122                         } else {
4123                             err = List.nil();
4124                         }
4125                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4126                     }
4127                 }
4128             }
4129         }
4130     }
4131 
<span class="line-added">4132     protected boolean isRecordStart() {</span>
<span class="line-added">4133      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
<span class="line-added">4134             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||</span>
<span class="line-added">4135              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||</span>
<span class="line-added">4136              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {</span>
<span class="line-added">4137           checkSourceLevel(Feature.RECORDS);</span>
<span class="line-added">4138           return true;</span>
<span class="line-added">4139     } else {</span>
<span class="line-added">4140        return false;</span>
<span class="line-added">4141    }</span>
<span class="line-added">4142 }</span>
<span class="line-added">4143 </span>
4144     /** MethodDeclaratorRest =
4145      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4146      *  VoidMethodDeclaratorRest =
4147      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4148      *  ConstructorDeclaratorRest =
4149      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4150      */
4151     protected JCTree methodDeclaratorRest(int pos,
4152                               JCModifiers mods,
4153                               JCExpression type,
4154                               Name name,
4155                               List&lt;JCTypeParameter&gt; typarams,
4156                               boolean isInterface, boolean isVoid,
<span class="line-added">4157                               boolean isRecord,</span>
4158                               Comment dc) {
4159         if (isInterface) {
4160             if ((mods.flags &amp; Flags.STATIC) != 0) {
4161                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4162             }
4163             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4164                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4165             }
4166         }
4167         JCVariableDecl prevReceiverParam = this.receiverParam;
4168         try {
4169             this.receiverParam = null;
4170             // Parsing formalParameters sets the receiverParam, if present
<span class="line-modified">4171             List&lt;JCVariableDecl&gt; params = List.nil();</span>

4172             List&lt;JCExpression&gt; thrown = List.nil();
<span class="line-modified">4173             if (!isRecord || name != names.init || token.kind == LPAREN) {</span>
<span class="line-modified">4174                 params = formalParameters();</span>
<span class="line-modified">4175                 if (!isVoid) type = bracketsOpt(type);</span>
<span class="line-added">4176                 if (token.kind == THROWS) {</span>
<span class="line-added">4177                     nextToken();</span>
<span class="line-added">4178                     thrown = qualidentList(true);</span>
<span class="line-added">4179                 }</span>
4180             }
4181             JCBlock body = null;
4182             JCExpression defaultValue;
4183             if (token.kind == LBRACE) {
4184                 body = block();
4185                 defaultValue = null;
4186             } else {
4187                 if (token.kind == DEFAULT) {
4188                     accept(DEFAULT);
4189                     defaultValue = annotationValue();
4190                 } else {
4191                     defaultValue = null;
4192                 }
4193                 accept(SEMI);
4194                 if (token.pos &lt;= endPosTable.errorEndPos) {
4195                     // error recovery
4196                     skip(false, true, false, false);
4197                     if (token.kind == LBRACE) {
4198                         body = block();
4199                     }
</pre>
<hr />
<pre>
4271         int pos = token.pos;
4272         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4273         Name name = typeName();
4274         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4275         if (token.kind == EXTENDS) {
4276             nextToken();
4277             bounds.append(parseType());
4278             while (token.kind == AMP) {
4279                 nextToken();
4280                 bounds.append(parseType());
4281             }
4282         }
4283         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4284     }
4285 
4286     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4287      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4288      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4289      */
4290     List&lt;JCVariableDecl&gt; formalParameters() {
<span class="line-modified">4291         return formalParameters(false, false);</span>
4292     }
<span class="line-modified">4293     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {</span>
4294         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4295         JCVariableDecl lastParam;
4296         accept(LPAREN);
4297         if (token.kind != RPAREN) {
<span class="line-modified">4298             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;</span>
<span class="line-modified">4299             lastParam = formalParameter(lambdaParameters, recordComponents);</span>
4300             if (lastParam.nameexpr != null) {
4301                 this.receiverParam = lastParam;
4302             } else {
4303                 params.append(lastParam);
4304             }
4305             this.allowThisIdent = false;
4306             while (token.kind == COMMA) {
4307                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4308                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4309                 }
4310                 nextToken();
<span class="line-modified">4311                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));</span>
4312             }
4313         }
4314         if (token.kind == RPAREN) {
4315             nextToken();
4316         } else {
4317             setErrorEndPos(token.pos);
4318             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4319         }
4320         return params.toList();
4321     }
4322 
4323     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4324         if (hasParens) {
4325             accept(LPAREN);
4326         }
4327         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4328         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4329             params.append(implicitParameter());
4330             while (token.kind == COMMA) {
4331                 nextToken();
</pre>
<hr />
<pre>
4402             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4403                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4404             } else {
4405                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4406                 mostInnerTypeToReturn = mostInnerType;
4407             }
4408         }
4409 
4410         if (mostInnerArrayType == null) {
4411             return mostInnerTypeToReturn;
4412         } else {
4413             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4414             storeEnd(type, origEndPos);
4415             return type;
4416         }
4417     }
4418 
4419     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4420      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4421      */
<span class="line-modified">4422     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {</span>
<span class="line-modified">4423         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();</span>
<span class="line-modified">4424         if (recordComponent &amp;&amp; mods.flags != 0) {</span>
<span class="line-modified">4425             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);</span>
<span class="line-modified">4426         }</span>
<span class="line-added">4427         if (recordComponent) {</span>
<span class="line-added">4428             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;</span>
<span class="line-added">4429         }</span>
4430         // need to distinguish between vararg annos and array annos
4431         // look at typeAnnotationsPushedBack comment
4432         this.permitTypeAnnotationsPushBack = true;
4433         JCExpression type = parseType(lambdaParameter);
4434         this.permitTypeAnnotationsPushBack = false;
4435 
4436         if (token.kind == ELLIPSIS) {
4437             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4438             typeAnnotationsPushedBack = List.nil();
4439             mods.flags |= Flags.VARARGS;
4440             // insert var arg type annotations
4441             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4442             nextToken();
4443         } else {
4444             // if not a var arg, then typeAnnotationsPushedBack should be null
4445             if (typeAnnotationsPushedBack.nonEmpty()) {
4446                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4447             }
4448             typeAnnotationsPushedBack = List.nil();
4449         }
</pre>
</td>
</tr>
</table>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
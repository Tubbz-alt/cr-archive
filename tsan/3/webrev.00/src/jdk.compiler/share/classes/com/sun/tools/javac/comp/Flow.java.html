<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
  33 import java.util.stream.Collectors;
  34 
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
  55 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  56 
  57 /** This pass implements dataflow analysis for Java programs though
  58  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  59  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  60  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  61  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  62  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  63  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  64  *  determines that local variables accessed within the scope of an inner class/lambda
  65  *  are either final or effectively-final.
  66  *
  67  *  &lt;p&gt;The JLS has a number of problems in the
  68  *  specification of these flow analysis problems. This implementation
  69  *  attempts to address those issues.
  70  *
  71  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  72  *  complete normally. For liveness analysis, an intervening finally
  73  *  clause can cause a break, continue, or return not to reach its
  74  *  target.  For exception analysis, an intervening finally clause can
  75  *  cause any exception to be &quot;caught&quot;.  For DA/DU analysis, the finally
  76  *  clause can prevent a transfer of control from propagating DA/DU
  77  *  state to the target.  In addition, code in the finally clause can
  78  *  affect the DA/DU status of variables.
  79  *
  80  *  &lt;p&gt;For try statements, we introduce the idea of a variable being
  81  *  definitely unassigned &quot;everywhere&quot; in a block.  A variable V is
  82  *  &quot;unassigned everywhere&quot; in a block iff it is unassigned at the
  83  *  beginning of the block and there is no reachable assignment to V
  84  *  in the block.  An assignment V=e is reachable iff V is not DA
  85  *  after e.  Then we can say that V is DU at the beginning of the
  86  *  catch block iff V is DU everywhere in the try block.  Similarly, V
  87  *  is DU at the beginning of the finally block iff V is DU everywhere
  88  *  in the try block and in every catch block.  Specifically, the
  89  *  following bullet is added to 16.2.2
  90  *  &lt;pre&gt;
  91  *      V is &lt;em&gt;unassigned everywhere&lt;/em&gt; in a block if it is
  92  *      unassigned before the block and there is no reachable
  93  *      assignment to V within the block.
  94  *  &lt;/pre&gt;
  95  *  &lt;p&gt;In 16.2.15, the third bullet (and all of its sub-bullets) for all
  96  *  try blocks is changed to
  97  *  &lt;pre&gt;
  98  *      V is definitely unassigned before a catch block iff V is
  99  *      definitely unassigned everywhere in the try block.
 100  *  &lt;/pre&gt;
 101  *  &lt;p&gt;The last bullet (and all of its sub-bullets) for try blocks that
 102  *  have a finally block is changed to
 103  *  &lt;pre&gt;
 104  *      V is definitely unassigned before the finally block iff
 105  *      V is definitely unassigned everywhere in the try block
 106  *      and everywhere in each catch block of the try statement.
 107  *  &lt;/pre&gt;
 108  *  &lt;p&gt;In addition,
 109  *  &lt;pre&gt;
 110  *      V is definitely assigned at the end of a constructor iff
 111  *      V is definitely assigned after the block that is the body
 112  *      of the constructor and V is definitely assigned at every
 113  *      return that can return from the constructor.
 114  *  &lt;/pre&gt;
 115  *  &lt;p&gt;In addition, each continue statement with the loop as its target
 116  *  is treated as a jump to the end of the loop body, and &quot;intervening&quot;
 117  *  finally clauses are treated as follows: V is DA &quot;due to the
 118  *  continue&quot; iff V is DA before the continue statement or V is DA at
 119  *  the end of any intervening finally block.  V is DU &quot;due to the
 120  *  continue&quot; iff any intervening finally cannot complete normally or V
 121  *  is DU at the end of every intervening finally block.  This &quot;due to
 122  *  the continue&quot; concept is then used in the spec for the loops.
 123  *
 124  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 125  *  blocks.  For liveness analysis, a break statement for which any
 126  *  intervening finally cannot complete normally is not considered to
 127  *  cause the target statement to be able to complete normally. Then
 128  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 129  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 130  *  to the break&quot; iff any intervening finally cannot complete normally
 131  *  or V is DU at the break and at the end of every intervening
 132  *  finally block.  (I suspect this latter condition can be
 133  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 134  *  all statements that can be &quot;broken&quot;.
 135  *
 136  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 137  *  return statement&quot; iff V is DA before the return statement or V is
 138  *  DA at the end of any intervening finally block.  Note that we
 139  *  don&#39;t have to worry about the return expression because this
 140  *  concept is only used for constructors.
 141  *
 142  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 143  *  assigned at the end of a constructor, which is needed for final
 144  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 145  *  of the constructor iff it is DA and the end of the body of the
 146  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 147  *
 148  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 149  *  intervening finally that cannot complete normally allows us to ignore
 150  *  an otherwise uncaught exception.
 151  *
 152  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 153  *  nonlocal transfers (break, continue, return, throw, method call that
 154  *  can throw a checked exception, and a constructor invocation that can
 155  *  thrown a checked exception) are recorded in a queue, and removed
 156  *  from the queue when we complete processing the target of the
 157  *  nonlocal transfer.  This allows us to modify the queue in accordance
 158  *  with the above rules when we encounter a finally clause.  The only
 159  *  exception to this [no pun intended] is that checked exceptions that
 160  *  are known to be caught or declared to be caught in the enclosing
 161  *  method are not recorded in the queue, but instead are recorded in a
 162  *  global variable &quot;{@code Set&lt;Type&gt; thrown}&quot; that records the type of all
 163  *  exceptions that can be thrown.
 164  *
 165  *  &lt;p&gt;Other minor issues the treatment of members of other classes
 166  *  (always considered DA except that within an anonymous class
 167  *  constructor, where DA status from the enclosing scope is
 168  *  preserved), treatment of the case expression (V is DA before the
 169  *  case expression iff V is DA after the switch expression),
 170  *  treatment of variables declared in a switch block (the implied
 171  *  DA/DU status after the switch expression is DU and not DA for
 172  *  variables defined in a switch block), the treatment of boolean ?:
 173  *  expressions (The JLS rules only handle b and c non-boolean; the
 174  *  new rule is that if b and c are boolean valued, then V is
 175  *  (un)assigned after a?b:c when true/false iff V is (un)assigned
 176  *  after b when true/false and V is (un)assigned after c when
 177  *  true/false).
 178  *
 179  *  &lt;p&gt;There is the remaining question of what syntactic forms constitute a
 180  *  reference to a variable.  It is conventional to allow this.x on the
 181  *  left-hand-side to initialize a final instance field named x, yet
 182  *  this.x isn&#39;t considered a &quot;use&quot; when appearing on a right-hand-side
 183  *  in most implementations.  Should parentheses affect what is
 184  *  considered a variable reference?  The simplest rule would be to
 185  *  allow unqualified forms only, parentheses optional, and phase out
 186  *  support for assigning to a final field via this.x.
 187  *
 188  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 189  *  If you write code that depends on this, you do so at your own risk.
 190  *  This code and its internal interfaces are subject to change or
 191  *  deletion without notice.&lt;/b&gt;
 192  */
 193 public class Flow {
 194     protected static final Context.Key&lt;Flow&gt; flowKey = new Context.Key&lt;&gt;();
 195 
 196     private final Names names;
 197     private final Log log;
 198     private final Symtab syms;
 199     private final Types types;
 200     private final Check chk;
 201     private       TreeMaker make;
 202     private final Resolve rs;
 203     private final JCDiagnostic.Factory diags;
 204     private Env&lt;AttrContext&gt; attrEnv;
 205     private       Lint lint;
 206     private final boolean allowEffectivelyFinalInInnerClasses;
 207 
 208     public static Flow instance(Context context) {
 209         Flow instance = context.get(flowKey);
 210         if (instance == null)
 211             instance = new Flow(context);
 212         return instance;
 213     }
 214 
 215     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 216         new AliveAnalyzer().analyzeTree(env, make);
 217         new AssignAnalyzer().analyzeTree(env, make);
 218         new FlowAnalyzer().analyzeTree(env, make);
 219         new CaptureAnalyzer().analyzeTree(env, make);
 220     }
 221 
 222     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 223         Log.DiagnosticHandler diagHandler = null;
 224         //we need to disable diagnostics temporarily; the problem is that if
 225         //a lambda expression contains e.g. an unreachable statement, an error
 226         //message will be reported and will cause compilation to skip the flow analysis
 227         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 228         //related errors, which will allow for more errors to be detected
 229         if (!speculative) {
 230             diagHandler = new Log.DiscardDiagnosticHandler(log);
 231         }
 232         try {
 233             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 234         } finally {
 235             if (!speculative) {
 236                 log.popDiagnosticHandler(diagHandler);
 237             }
 238         }
 239     }
 240 
 241     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 242             JCLambda that, TreeMaker make) {
 243         //we need to disable diagnostics temporarily; the problem is that if
 244         //a lambda expression contains e.g. an unreachable statement, an error
 245         //message will be reported and will cause compilation to skip the flow analysis
 246         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 247         //related errors, which will allow for more errors to be detected
 248         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 249         try {
 250             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 251             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 252             flowAnalyzer.analyzeTree(env, that, make);
 253             return flowAnalyzer.inferredThrownTypes;
 254         } finally {
 255             log.popDiagnosticHandler(diagHandler);
 256         }
 257     }
 258 
 259     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {
 260         //we need to disable diagnostics temporarily; the problem is that if
 261         //&quot;that&quot; contains e.g. an unreachable statement, an error
 262         //message will be reported and will cause compilation to skip the flow analysis
 263         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 264         //related errors, which will allow for more errors to be detected
 265         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 266         try {
 267             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();
 268 
 269             analyzer.analyzeTree(env, that, make);
 270             return analyzer.isAlive();
 271         } finally {
 272             log.popDiagnosticHandler(diagHandler);
 273         }
 274     }
 275 
 276     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {
 277         //we need to disable diagnostics temporarily; the problem is that if
 278         //&quot;that&quot; contains e.g. an unreachable statement, an error
 279         //message will be reported and will cause compilation to skip the flow analysis
 280         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 281         //related errors, which will allow for more errors to be detected
 282         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 283         try {
 284             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();
 285 
 286             analyzer.analyzeTree(env, body, make);
 287             return analyzer.breaksOut();
 288         } finally {
 289             log.popDiagnosticHandler(diagHandler);
 290         }
 291     }
 292 
 293     /**
 294      * Definite assignment scan mode
 295      */
 296     enum FlowKind {
 297         /**
 298          * This is the normal DA/DU analysis mode
 299          */
 300         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 301         /**
 302          * This is the speculative DA/DU analysis mode used to speculatively
 303          * derive assertions within loop bodies
 304          */
 305         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 306 
 307         final String errKey;
 308         final boolean isFinal;
 309 
 310         FlowKind(String errKey, boolean isFinal) {
 311             this.errKey = errKey;
 312             this.isFinal = isFinal;
 313         }
 314 
 315         boolean isFinal() {
 316             return isFinal;
 317         }
 318     }
 319 
 320     protected Flow(Context context) {
 321         context.put(flowKey, this);
 322         names = Names.instance(context);
 323         log = Log.instance(context);
 324         syms = Symtab.instance(context);
 325         types = Types.instance(context);
 326         chk = Check.instance(context);
 327         lint = Lint.instance(context);
 328         rs = Resolve.instance(context);
 329         diags = JCDiagnostic.Factory.instance(context);
 330         Source source = Source.instance(context);
 331         allowEffectivelyFinalInInnerClasses = Feature.EFFECTIVELY_FINAL_IN_INNER_CLASSES.allowedInSource(source);
 332     }
 333 
 334     /**
 335      * Base visitor class for all visitors implementing dataflow analysis logic.
 336      * This class define the shared logic for handling jumps (break/continue statements).
 337      */
 338     static abstract class BaseAnalyzer extends TreeScanner {
 339 
 340         enum JumpKind {
 341             BREAK(JCTree.Tag.BREAK) {
 342                 @Override
 343                 JCTree getTarget(JCTree tree) {
 344                     return ((JCBreak)tree).target;
 345                 }
 346             },
 347             CONTINUE(JCTree.Tag.CONTINUE) {
 348                 @Override
 349                 JCTree getTarget(JCTree tree) {
 350                     return ((JCContinue)tree).target;
 351                 }
 352             },
 353             YIELD(JCTree.Tag.YIELD) {
 354                 @Override
 355                 JCTree getTarget(JCTree tree) {
 356                     return ((JCYield)tree).target;
 357                 }
 358             };
 359 
 360             final JCTree.Tag treeTag;
 361 
 362             private JumpKind(Tag treeTag) {
 363                 this.treeTag = treeTag;
 364             }
 365 
 366             abstract JCTree getTarget(JCTree tree);
 367         }
 368 
 369         /** The currently pending exits that go from current inner blocks
 370          *  to an enclosing block, in source order.
 371          */
 372         ListBuffer&lt;PendingExit&gt; pendingExits;
 373 
 374         /** A pending exit.  These are the statements return, break, and
 375          *  continue.  In addition, exception-throwing expressions or
 376          *  statements are put here when not known to be caught.  This
 377          *  will typically result in an error unless it is within a
 378          *  try-finally whose finally block cannot complete normally.
 379          */
 380         static class PendingExit {
 381             JCTree tree;
 382 
 383             PendingExit(JCTree tree) {
 384                 this.tree = tree;
 385             }
 386 
 387             void resolveJump() {
 388                 //do nothing
 389             }
 390         }
 391 
 392         abstract void markDead();
 393 
 394         /** Record an outward transfer of control. */
 395         void recordExit(PendingExit pe) {
 396             pendingExits.append(pe);
 397             markDead();
 398         }
 399 
 400         /** Resolve all jumps of this statement. */
 401         private Liveness resolveJump(JCTree tree,
 402                          ListBuffer&lt;PendingExit&gt; oldPendingExits,
 403                          JumpKind jk) {
 404             boolean resolved = false;
 405             List&lt;PendingExit&gt; exits = pendingExits.toList();
 406             pendingExits = oldPendingExits;
 407             for (; exits.nonEmpty(); exits = exits.tail) {
 408                 PendingExit exit = exits.head;
 409                 if (exit.tree.hasTag(jk.treeTag) &amp;&amp;
 410                         jk.getTarget(exit.tree) == tree) {
 411                     exit.resolveJump();
 412                     resolved = true;
 413                 } else {
 414                     pendingExits.append(exit);
 415                 }
 416             }
 417             return Liveness.from(resolved);
 418         }
 419 
 420         /** Resolve all continues of this statement. */
 421         Liveness resolveContinues(JCTree tree) {
 422             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 423         }
 424 
 425         /** Resolve all breaks of this statement. */
 426         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 427             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 428         }
 429 
 430         /** Resolve all yields of this statement. */
 431         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 432             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);
 433         }
 434 
 435         @Override
 436         public void scan(JCTree tree) {
 437             if (tree != null &amp;&amp; (
 438                     tree.type == null ||
 439                     tree.type != Type.stuckType)) {
 440                 super.scan(tree);
 441             }
 442         }
 443 
 444         public void visitPackageDef(JCPackageDecl tree) {
 445             // Do nothing for PackageDecl
 446         }
 447 
 448         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
 449             if (swtch.hasTag(SWITCH_EXPRESSION)) {
 450                 JCYield brk = make.at(Position.NOPOS).Yield(null);
 451                 brk.target = swtch;
 452                 scan(brk);
 453             } else {
 454                 JCBreak brk = make.at(Position.NOPOS).Break(null);
 455                 brk.target = swtch;
 456                 scan(brk);
 457             }
 458         }
 459     }
 460 
 461     /**
 462      * This pass implements the first step of the dataflow analysis, namely
 463      * the liveness analysis check. This checks that every statement is reachable.
 464      * The output of this analysis pass are used by other analyzers. This analyzer
 465      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 466      */
 467     class AliveAnalyzer extends BaseAnalyzer {
 468 
 469         /** A flag that indicates whether the last statement could
 470          *  complete normally.
 471          */
 472         private Liveness alive;
 473 
 474         @Override
 475         void markDead() {
 476             alive = Liveness.DEAD;
 477         }
 478 
 479     /*************************************************************************
 480      * Visitor methods for statements and definitions
 481      *************************************************************************/
 482 
 483         /** Analyze a definition.
 484          */
 485         void scanDef(JCTree tree) {
 486             scanStat(tree);
 487             if (tree != null &amp;&amp; tree.hasTag(JCTree.Tag.BLOCK) &amp;&amp; alive == Liveness.DEAD) {
 488                 log.error(tree.pos(),
 489                           Errors.InitializerMustBeAbleToCompleteNormally);
 490             }
 491         }
 492 
 493         /** Analyze a statement. Check that statement is reachable.
 494          */
 495         void scanStat(JCTree tree) {
 496             if (alive == Liveness.DEAD &amp;&amp; tree != null) {
 497                 log.error(tree.pos(), Errors.UnreachableStmt);
 498                 if (!tree.hasTag(SKIP)) alive = Liveness.RECOVERY;
 499             }
 500             scan(tree);
 501         }
 502 
 503         /** Analyze list of statements.
 504          */
 505         void scanStats(List&lt;? extends JCStatement&gt; trees) {
 506             if (trees != null)
 507                 for (List&lt;? extends JCStatement&gt; l = trees; l.nonEmpty(); l = l.tail)
 508                     scanStat(l.head);
 509         }
 510 
 511         /* ------------ Visitor methods for various sorts of trees -------------*/
 512 
 513         public void visitClassDef(JCClassDecl tree) {
 514             if (tree.sym == null) return;
 515             Liveness alivePrev = alive;
 516             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 517             Lint lintPrev = lint;
 518 
 519             pendingExits = new ListBuffer&lt;&gt;();
 520             lint = lint.augment(tree.sym);
 521 
 522             try {
 523                 // process all the static initializers
 524                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 525                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 526                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 527                         scanDef(l.head);
 528                     }
 529                 }
 530 
 531                 // process all the instance initializers
 532                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 533                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 534                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 535                         scanDef(l.head);
 536                     }
 537                 }
 538 
 539                 // process all the methods
 540                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 541                     if (l.head.hasTag(METHODDEF)) {
 542                         scan(l.head);
 543                     }
 544                 }
 545             } finally {
 546                 pendingExits = pendingExitsPrev;
 547                 alive = alivePrev;
 548                 lint = lintPrev;
 549             }
 550         }
 551 
 552         public void visitMethodDef(JCMethodDecl tree) {
 553             if (tree.body == null) return;
 554             Lint lintPrev = lint;
 555 
 556             lint = lint.augment(tree.sym);
 557 
 558             Assert.check(pendingExits.isEmpty());
 559 
 560             try {
 561                 alive = Liveness.ALIVE;
 562                 scanStat(tree.body);
 563                 tree.completesNormally = alive != Liveness.DEAD;
 564 
 565                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 566                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 567 
 568                 List&lt;PendingExit&gt; exits = pendingExits.toList();
 569                 pendingExits = new ListBuffer&lt;&gt;();
 570                 while (exits.nonEmpty()) {
 571                     PendingExit exit = exits.head;
 572                     exits = exits.tail;
 573                     Assert.check(exit.tree.hasTag(RETURN) ||
 574                                     log.hasErrorOn(exit.tree.pos()));
 575                 }
 576             } finally {
 577                 lint = lintPrev;
 578             }
 579         }
 580 
 581         public void visitVarDef(JCVariableDecl tree) {
 582             if (tree.init != null) {
 583                 Lint lintPrev = lint;
 584                 lint = lint.augment(tree.sym);
 585                 try{
 586                     scan(tree.init);
 587                 } finally {
 588                     lint = lintPrev;
 589                 }
 590             }
 591         }
 592 
 593         public void visitBlock(JCBlock tree) {
 594             scanStats(tree.stats);
 595         }
 596 
 597         public void visitDoLoop(JCDoWhileLoop tree) {
 598             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 599             pendingExits = new ListBuffer&lt;&gt;();
 600             scanStat(tree.body);
 601             alive = alive.or(resolveContinues(tree));
 602             scan(tree.cond);
 603             alive = alive.and(!tree.cond.type.isTrue());
 604             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 605         }
 606 
 607         public void visitWhileLoop(JCWhileLoop tree) {
 608             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 609             pendingExits = new ListBuffer&lt;&gt;();
 610             scan(tree.cond);
 611             alive = Liveness.from(!tree.cond.type.isFalse());
 612             scanStat(tree.body);
 613             alive = alive.or(resolveContinues(tree));
 614             alive = resolveBreaks(tree, prevPendingExits).or(
 615                 !tree.cond.type.isTrue());
 616         }
 617 
 618         public void visitForLoop(JCForLoop tree) {
 619             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 620             scanStats(tree.init);
 621             pendingExits = new ListBuffer&lt;&gt;();
 622             if (tree.cond != null) {
 623                 scan(tree.cond);
 624                 alive = Liveness.from(!tree.cond.type.isFalse());
 625             } else {
 626                 alive = Liveness.ALIVE;
 627             }
 628             scanStat(tree.body);
 629             alive = alive.or(resolveContinues(tree));
 630             scan(tree.step);
 631             alive = resolveBreaks(tree, prevPendingExits).or(
 632                 tree.cond != null &amp;&amp; !tree.cond.type.isTrue());
 633         }
 634 
 635         public void visitForeachLoop(JCEnhancedForLoop tree) {
 636             visitVarDef(tree.var);
 637             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 638             scan(tree.expr);
 639             pendingExits = new ListBuffer&lt;&gt;();
 640             scanStat(tree.body);
 641             alive = alive.or(resolveContinues(tree));
 642             resolveBreaks(tree, prevPendingExits);
 643             alive = Liveness.ALIVE;
 644         }
 645 
 646         public void visitLabelled(JCLabeledStatement tree) {
 647             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 648             pendingExits = new ListBuffer&lt;&gt;();
 649             scanStat(tree.body);
 650             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 651         }
 652 
 653         public void visitSwitch(JCSwitch tree) {
 654             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 655             pendingExits = new ListBuffer&lt;&gt;();
 656             scan(tree.selector);
 657             boolean hasDefault = false;
 658             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 659                 alive = Liveness.ALIVE;
 660                 JCCase c = l.head;
 661                 if (c.pats.isEmpty())
 662                     hasDefault = true;
 663                 else {
 664                     for (JCExpression pat : c.pats) {
 665                         scan(pat);
 666                     }
 667                 }
 668                 scanStats(c.stats);
 669                 c.completesNormally = alive != Liveness.DEAD;
 670                 if (alive != Liveness.DEAD &amp;&amp; c.caseKind == JCCase.RULE) {
 671                     scanSyntheticBreak(make, tree);
 672                     alive = Liveness.DEAD;
 673                 }
 674                 // Warn about fall-through if lint switch fallthrough enabled.
 675                 if (alive == Liveness.ALIVE &amp;&amp;
 676                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 677                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 678                     log.warning(Lint.LintCategory.FALLTHROUGH,
 679                                 l.tail.head.pos(),
 680                                 Warnings.PossibleFallThroughIntoCase);
 681             }
 682             if (!hasDefault) {
 683                 alive = Liveness.ALIVE;
 684             }
 685             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 686         }
 687 
 688         @Override
 689         public void visitSwitchExpression(JCSwitchExpression tree) {
 690             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 691             pendingExits = new ListBuffer&lt;&gt;();
 692             scan(tree.selector);
 693             Set&lt;Object&gt; constants = null;
 694             if ((tree.selector.type.tsym.flags() &amp; ENUM) != 0) {
 695                 constants = new HashSet&lt;&gt;();
 696                 for (Symbol s : tree.selector.type.tsym.members().getSymbols(s -&gt; (s.flags() &amp; ENUM) != 0)) {
 697                     constants.add(s.name);
 698                 }
 699             }
 700             boolean hasDefault = false;
 701             Liveness prevAlive = alive;
 702             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 703                 alive = Liveness.ALIVE;
 704                 JCCase c = l.head;
 705                 if (c.pats.isEmpty())
 706                     hasDefault = true;
 707                 else {
 708                     for (JCExpression pat : c.pats) {
 709                         scan(pat);
 710                         if (constants != null) {
 711                             if (pat.hasTag(IDENT))
 712                                 constants.remove(((JCIdent) pat).name);
 713                             if (pat.type != null)
 714                                 constants.remove(pat.type.constValue());
 715                         }
 716                     }
 717                 }
 718                 scanStats(c.stats);
 719                 if (alive == Liveness.ALIVE) {
 720                     if (c.caseKind == JCCase.RULE) {
 721                         log.error(TreeInfo.diagEndPos(c.body),
 722                                   Errors.RuleCompletesNormally);
 723                     } else if (l.tail.isEmpty()) {
 724                         log.error(TreeInfo.diagEndPos(tree),
 725                                   Errors.SwitchExpressionCompletesNormally);
 726                     }
 727                 }
 728                 c.completesNormally = alive != Liveness.DEAD;
 729             }
 730             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 731                 log.error(tree, Errors.NotExhaustive);
 732             }
 733             alive = prevAlive;
 734             alive = alive.or(resolveYields(tree, prevPendingExits));
 735         }
 736 
 737         public void visitTry(JCTry tree) {
 738             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 739             pendingExits = new ListBuffer&lt;&gt;();
 740             for (JCTree resource : tree.resources) {
 741                 if (resource instanceof JCVariableDecl) {
 742                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 743                     visitVarDef(vdecl);
 744                 } else if (resource instanceof JCExpression) {
 745                     scan((JCExpression) resource);
 746                 } else {
 747                     throw new AssertionError(tree);  // parser error
 748                 }
 749             }
 750 
 751             scanStat(tree.body);
 752             Liveness aliveEnd = alive;
 753 
 754             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
 755                 alive = Liveness.ALIVE;
 756                 JCVariableDecl param = l.head.param;
 757                 scan(param);
 758                 scanStat(l.head.body);
 759                 aliveEnd = aliveEnd.or(alive);
 760             }
 761             if (tree.finalizer != null) {
 762                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 763                 pendingExits = prevPendingExits;
 764                 alive = Liveness.ALIVE;
 765                 scanStat(tree.finalizer);
 766                 tree.finallyCanCompleteNormally = alive != Liveness.DEAD;
 767                 if (alive == Liveness.DEAD) {
 768                     if (lint.isEnabled(Lint.LintCategory.FINALLY)) {
 769                         log.warning(Lint.LintCategory.FINALLY,
 770                                 TreeInfo.diagEndPos(tree.finalizer),
 771                                 Warnings.FinallyCannotComplete);
 772                     }
 773                 } else {
 774                     while (exits.nonEmpty()) {
 775                         pendingExits.append(exits.next());
 776                     }
 777                     alive = aliveEnd;
 778                 }
 779             } else {
 780                 alive = aliveEnd;
 781                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 782                 pendingExits = prevPendingExits;
 783                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 784             }
 785         }
 786 
 787         @Override
 788         public void visitIf(JCIf tree) {
 789             scan(tree.cond);
 790             scanStat(tree.thenpart);
 791             if (tree.elsepart != null) {
 792                 Liveness aliveAfterThen = alive;
 793                 alive = Liveness.ALIVE;
 794                 scanStat(tree.elsepart);
 795                 alive = alive.or(aliveAfterThen);
 796             } else {
 797                 alive = Liveness.ALIVE;
 798             }
 799         }
 800 
 801         public void visitBreak(JCBreak tree) {
 802             recordExit(new PendingExit(tree));
 803         }
 804 
 805         @Override
 806         public void visitYield(JCYield tree) {
 807             scan(tree.value);
 808             recordExit(new PendingExit(tree));
 809         }
 810 
 811         public void visitContinue(JCContinue tree) {
 812             recordExit(new PendingExit(tree));
 813         }
 814 
 815         public void visitReturn(JCReturn tree) {
 816             scan(tree.expr);
 817             recordExit(new PendingExit(tree));
 818         }
 819 
 820         public void visitThrow(JCThrow tree) {
 821             scan(tree.expr);
 822             markDead();
 823         }
 824 
 825         public void visitApply(JCMethodInvocation tree) {
 826             scan(tree.meth);
 827             scan(tree.args);
 828         }
 829 
 830         public void visitNewClass(JCNewClass tree) {
 831             scan(tree.encl);
 832             scan(tree.args);
 833             if (tree.def != null) {
 834                 scan(tree.def);
 835             }
 836         }
 837 
 838         @Override
 839         public void visitLambda(JCLambda tree) {
 840             if (tree.type != null &amp;&amp;
 841                     tree.type.isErroneous()) {
 842                 return;
 843             }
 844 
 845             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
 846             Liveness prevAlive = alive;
 847             try {
 848                 pendingExits = new ListBuffer&lt;&gt;();
 849                 alive = Liveness.ALIVE;
 850                 scanStat(tree.body);
 851                 tree.canCompleteNormally = alive != Liveness.DEAD;
 852             }
 853             finally {
 854                 pendingExits = prevPending;
 855                 alive = prevAlive;
 856             }
 857         }
 858 
 859         public void visitModuleDef(JCModuleDecl tree) {
 860             // Do nothing for modules
 861         }
 862 
 863     /**************************************************************************
 864      * main method
 865      *************************************************************************/
 866 
 867         /** Perform definite assignment/unassignment analysis on a tree.
 868          */
 869         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 870             analyzeTree(env, env.tree, make);
 871         }
 872         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
 873             try {
 874                 attrEnv = env;
 875                 Flow.this.make = make;
 876                 pendingExits = new ListBuffer&lt;&gt;();
 877                 alive = Liveness.ALIVE;
 878                 scan(tree);
 879             } finally {
 880                 pendingExits = null;
 881                 Flow.this.make = null;
 882             }
 883         }
 884     }
 885 
 886     /**
 887      * This pass implements the second step of the dataflow analysis, namely
 888      * the exception analysis. This is to ensure that every checked exception that is
 889      * thrown is declared or caught. The analyzer uses some info that has been set by
 890      * the liveliness analyzer.
 891      */
 892     class FlowAnalyzer extends BaseAnalyzer {
 893 
 894         /** A flag that indicates whether the last statement could
 895          *  complete normally.
 896          */
 897         HashMap&lt;Symbol, List&lt;Type&gt;&gt; preciseRethrowTypes;
 898 
 899         /** The current class being defined.
 900          */
 901         JCClassDecl classDef;
 902 
 903         /** The list of possibly thrown declarable exceptions.
 904          */
 905         List&lt;Type&gt; thrown;
 906 
 907         /** The list of exceptions that are either caught or declared to be
 908          *  thrown.
 909          */
 910         List&lt;Type&gt; caught;
 911 
 912         class ThrownPendingExit extends BaseAnalyzer.PendingExit {
 913 
 914             Type thrown;
 915 
 916             ThrownPendingExit(JCTree tree, Type thrown) {
 917                 super(tree);
 918                 this.thrown = thrown;
 919             }
 920         }
 921 
 922         @Override
 923         void markDead() {
 924             //do nothing
 925         }
 926 
 927         /*-------------------- Exceptions ----------------------*/
 928 
 929         /** Complain that pending exceptions are not caught.
 930          */
 931         void errorUncaught() {
 932             for (PendingExit exit = pendingExits.next();
 933                  exit != null;
 934                  exit = pendingExits.next()) {
 935                 Assert.check(exit instanceof ThrownPendingExit);
 936                 ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
 937                 if (classDef != null &amp;&amp;
 938                     classDef.pos == exit.tree.pos) {
 939                     log.error(exit.tree.pos(),
 940                               Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
 941                 } else if (exit.tree.hasTag(VARDEF) &amp;&amp;
 942                         ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
 943                     log.error(exit.tree.pos(),
 944                               Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
 945                                                                       ((JCVariableDecl)exit.tree).sym.name));
 946                 } else {
 947                     log.error(exit.tree.pos(),
 948                               Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
 949                 }
 950             }
 951         }
 952 
 953         /** Record that exception is potentially thrown and check that it
 954          *  is caught.
 955          */
 956         void markThrown(JCTree tree, Type exc) {
 957             if (!chk.isUnchecked(tree.pos(), exc)) {
 958                 if (!chk.isHandled(exc, caught)) {
 959                     pendingExits.append(new ThrownPendingExit(tree, exc));
 960                 }
 961                 thrown = chk.incl(exc, thrown);
 962             }
 963         }
 964 
 965     /*************************************************************************
 966      * Visitor methods for statements and definitions
 967      *************************************************************************/
 968 
 969         /* ------------ Visitor methods for various sorts of trees -------------*/
 970 
 971         public void visitClassDef(JCClassDecl tree) {
 972             if (tree.sym == null) return;
 973 
 974             JCClassDecl classDefPrev = classDef;
 975             List&lt;Type&gt; thrownPrev = thrown;
 976             List&lt;Type&gt; caughtPrev = caught;
 977             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 978             Lint lintPrev = lint;
 979             boolean anonymousClass = tree.name == names.empty;
 980             pendingExits = new ListBuffer&lt;&gt;();
 981             if (!anonymousClass) {
 982                 caught = List.nil();
 983             }
 984             classDef = tree;
 985             thrown = List.nil();
 986             lint = lint.augment(tree.sym);
 987 
 988             try {
 989                 // process all the static initializers
 990                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 991                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 992                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 993                         scan(l.head);
 994                         errorUncaught();
 995                     }
 996                 }
 997 
 998                 // add intersection of all thrown clauses of initial constructors
 999                 // to set of caught exceptions, unless class is anonymous.
1000                 if (!anonymousClass) {
1001                     boolean firstConstructor = true;
1002                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1003                         if (TreeInfo.isInitialConstructor(l.head)) {
1004                             List&lt;Type&gt; mthrown =
1005                                 ((JCMethodDecl) l.head).sym.type.getThrownTypes();
1006                             if (firstConstructor) {
1007                                 caught = mthrown;
1008                                 firstConstructor = false;
1009                             } else {
1010                                 caught = chk.intersect(mthrown, caught);
1011                             }
1012                         }
1013                     }
1014                 }
1015 
1016                 // process all the instance initializers
1017                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1018                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1019                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
1020                         scan(l.head);
1021                         errorUncaught();
1022                     }
1023                 }
1024 
1025                 // in an anonymous class, add the set of thrown exceptions to
1026                 // the throws clause of the synthetic constructor and propagate
1027                 // outwards.
1028                 // Changing the throws clause on the fly is okay here because
1029                 // the anonymous constructor can&#39;t be invoked anywhere else,
1030                 // and its type hasn&#39;t been cached.
1031                 if (anonymousClass) {
1032                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1033                         if (TreeInfo.isConstructor(l.head)) {
1034                             JCMethodDecl mdef = (JCMethodDecl)l.head;
1035                             scan(mdef);
1036                             mdef.thrown = make.Types(thrown);
1037                             mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
1038                         }
1039                     }
1040                     thrownPrev = chk.union(thrown, thrownPrev);
1041                 }
1042 
1043                 // process all the methods
1044                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1045                     if (anonymousClass &amp;&amp; TreeInfo.isConstructor(l.head))
1046                         continue; // there can never be an uncaught exception.
1047                     if (l.head.hasTag(METHODDEF)) {
1048                         scan(l.head);
1049                         errorUncaught();
1050                     }
1051                 }
1052 
1053                 thrown = thrownPrev;
1054             } finally {
1055                 pendingExits = pendingExitsPrev;
1056                 caught = caughtPrev;
1057                 classDef = classDefPrev;
1058                 lint = lintPrev;
1059             }
1060         }
1061 
1062         public void visitMethodDef(JCMethodDecl tree) {
1063             if (tree.body == null) return;
1064 
1065             List&lt;Type&gt; caughtPrev = caught;
1066             List&lt;Type&gt; mthrown = tree.sym.type.getThrownTypes();
1067             Lint lintPrev = lint;
1068 
1069             lint = lint.augment(tree.sym);
1070 
1071             Assert.check(pendingExits.isEmpty());
1072 
1073             try {
1074                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1075                     JCVariableDecl def = l.head;
1076                     scan(def);
1077                 }
1078                 if (TreeInfo.isInitialConstructor(tree))
1079                     caught = chk.union(caught, mthrown);
1080                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1081                     caught = mthrown;
1082                 // else we are in an instance initializer block;
1083                 // leave caught unchanged.
1084 
1085                 scan(tree.body);
1086 
1087                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1088                 pendingExits = new ListBuffer&lt;&gt;();
1089                 while (exits.nonEmpty()) {
1090                     PendingExit exit = exits.head;
1091                     exits = exits.tail;
1092                     if (!(exit instanceof ThrownPendingExit)) {
1093                         Assert.check(exit.tree.hasTag(RETURN) ||
1094                                          log.hasErrorOn(exit.tree.pos()));
1095                     } else {
1096                         // uncaught throws will be reported later
1097                         pendingExits.append(exit);
1098                     }
1099                 }
1100             } finally {
1101                 caught = caughtPrev;
1102                 lint = lintPrev;
1103             }
1104         }
1105 
1106         public void visitVarDef(JCVariableDecl tree) {
1107             if (tree.init != null) {
1108                 Lint lintPrev = lint;
1109                 lint = lint.augment(tree.sym);
1110                 try{
1111                     scan(tree.init);
1112                 } finally {
1113                     lint = lintPrev;
1114                 }
1115             }
1116         }
1117 
1118         public void visitBlock(JCBlock tree) {
1119             scan(tree.stats);
1120         }
1121 
1122         public void visitDoLoop(JCDoWhileLoop tree) {
1123             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1124             pendingExits = new ListBuffer&lt;&gt;();
1125             scan(tree.body);
1126             resolveContinues(tree);
1127             scan(tree.cond);
1128             resolveBreaks(tree, prevPendingExits);
1129         }
1130 
1131         public void visitWhileLoop(JCWhileLoop tree) {
1132             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1133             pendingExits = new ListBuffer&lt;&gt;();
1134             scan(tree.cond);
1135             scan(tree.body);
1136             resolveContinues(tree);
1137             resolveBreaks(tree, prevPendingExits);
1138         }
1139 
1140         public void visitForLoop(JCForLoop tree) {
1141             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1142             scan(tree.init);
1143             pendingExits = new ListBuffer&lt;&gt;();
1144             if (tree.cond != null) {
1145                 scan(tree.cond);
1146             }
1147             scan(tree.body);
1148             resolveContinues(tree);
1149             scan(tree.step);
1150             resolveBreaks(tree, prevPendingExits);
1151         }
1152 
1153         public void visitForeachLoop(JCEnhancedForLoop tree) {
1154             visitVarDef(tree.var);
1155             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1156             scan(tree.expr);
1157             pendingExits = new ListBuffer&lt;&gt;();
1158             scan(tree.body);
1159             resolveContinues(tree);
1160             resolveBreaks(tree, prevPendingExits);
1161         }
1162 
1163         public void visitLabelled(JCLabeledStatement tree) {
1164             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1165             pendingExits = new ListBuffer&lt;&gt;();
1166             scan(tree.body);
1167             resolveBreaks(tree, prevPendingExits);
1168         }
1169 
1170         public void visitSwitch(JCSwitch tree) {
1171             handleSwitch(tree, tree.selector, tree.cases);
1172         }
1173 
1174         @Override
1175         public void visitSwitchExpression(JCSwitchExpression tree) {
1176             handleSwitch(tree, tree.selector, tree.cases);
1177         }
1178 
1179         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1180             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1181             pendingExits = new ListBuffer&lt;&gt;();
1182             scan(selector);
1183             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1184                 JCCase c = l.head;
1185                 scan(c.pats);
1186                 scan(c.stats);
1187             }
1188             if (tree.hasTag(SWITCH_EXPRESSION)) {
1189                 resolveYields(tree, prevPendingExits);
1190             } else {
1191                 resolveBreaks(tree, prevPendingExits);
1192             }
1193         }
1194 
1195         public void visitTry(JCTry tree) {
1196             List&lt;Type&gt; caughtPrev = caught;
1197             List&lt;Type&gt; thrownPrev = thrown;
1198             thrown = List.nil();
1199             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1200                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1201                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1202                         List.of(l.head.param.vartype);
1203                 for (JCExpression ct : subClauses) {
1204                     caught = chk.incl(ct.type, caught);
1205                 }
1206             }
1207 
1208             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1209             pendingExits = new ListBuffer&lt;&gt;();
1210             for (JCTree resource : tree.resources) {
1211                 if (resource instanceof JCVariableDecl) {
1212                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1213                     visitVarDef(vdecl);
1214                 } else if (resource instanceof JCExpression) {
1215                     scan((JCExpression) resource);
1216                 } else {
1217                     throw new AssertionError(tree);  // parser error
1218                 }
1219             }
1220             for (JCTree resource : tree.resources) {
1221                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1222                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1223                     List.of(resource.type);
1224                 for (Type sup : closeableSupertypes) {
1225                     if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {
1226                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1227                                 attrEnv,
1228                                 types.skipTypeVars(sup, false),
1229                                 names.close,
1230                                 List.nil(),
1231                                 List.nil());
1232                         Type mt = types.memberType(resource.type, closeMethod);
1233                         if (closeMethod.kind == MTH) {
1234                             for (Type t : mt.getThrownTypes()) {
1235                                 markThrown(resource, t);
1236                             }
1237                         }
1238                     }
1239                 }
1240             }
1241             scan(tree.body);
1242             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1243             thrown = thrownPrev;
1244             caught = caughtPrev;
1245 
1246             List&lt;Type&gt; caughtInTry = List.nil();
1247             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1248                 JCVariableDecl param = l.head.param;
1249                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1250                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1251                         List.of(l.head.param.vartype);
1252                 List&lt;Type&gt; ctypes = List.nil();
1253                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1254                 for (JCExpression ct : subClauses) {
1255                     Type exc = ct.type;
1256                     if (exc != syms.unknownType) {
1257                         ctypes = ctypes.append(exc);
1258                         if (types.isSameType(exc, syms.objectType))
1259                             continue;
1260                         checkCaughtType(l.head.pos(), exc, thrownInTry, caughtInTry);
1261                         caughtInTry = chk.incl(exc, caughtInTry);
1262                     }
1263                 }
1264                 scan(param);
1265                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1266                 scan(l.head.body);
1267                 preciseRethrowTypes.remove(param.sym);
1268             }
1269             if (tree.finalizer != null) {
1270                 List&lt;Type&gt; savedThrown = thrown;
1271                 thrown = List.nil();
1272                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1273                 pendingExits = prevPendingExits;
1274                 scan(tree.finalizer);
1275                 if (!tree.finallyCanCompleteNormally) {
1276                     // discard exits and exceptions from try and finally
1277                     thrown = chk.union(thrown, thrownPrev);
1278                 } else {
1279                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1280                     thrown = chk.union(thrown, savedThrown);
1281                     // FIX: this doesn&#39;t preserve source order of exits in catch
1282                     // versus finally!
1283                     while (exits.nonEmpty()) {
1284                         pendingExits.append(exits.next());
1285                     }
1286                 }
1287             } else {
1288                 thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1289                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1290                 pendingExits = prevPendingExits;
1291                 while (exits.nonEmpty()) pendingExits.append(exits.next());
1292             }
1293         }
1294 
1295         @Override
1296         public void visitIf(JCIf tree) {
1297             scan(tree.cond);
1298             scan(tree.thenpart);
1299             if (tree.elsepart != null) {
1300                 scan(tree.elsepart);
1301             }
1302         }
1303 
1304         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1305             if (chk.subset(exc, caughtInTry)) {
1306                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1307             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1308                     !isExceptionOrThrowable(exc) &amp;&amp;
1309                     !chk.intersects(exc, thrownInTry)) {
1310                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1311             } else {
1312                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
1313                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an
1314                 // unchecked exception, the result list would not be empty, as the augmented
1315                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1316                 // exception, that would have been covered in the branch above
1317                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1318                         !isExceptionOrThrowable(exc)) {
1319                     Warning key = catchableThrownTypes.length() == 1 ?
1320                             Warnings.UnreachableCatch(catchableThrownTypes) :
1321                             Warnings.UnreachableCatch1(catchableThrownTypes);
1322                     log.warning(pos, key);
1323                 }
1324             }
1325         }
1326         //where
1327             private boolean isExceptionOrThrowable(Type exc) {
1328                 return exc.tsym == syms.throwableType.tsym ||
1329                     exc.tsym == syms.exceptionType.tsym;
1330             }
1331 
1332         public void visitBreak(JCBreak tree) {
1333             recordExit(new PendingExit(tree));
1334         }
1335 
1336         public void visitYield(JCYield tree) {
1337             scan(tree.value);
1338             recordExit(new PendingExit(tree));
1339         }
1340 
1341         public void visitContinue(JCContinue tree) {
1342             recordExit(new PendingExit(tree));
1343         }
1344 
1345         public void visitReturn(JCReturn tree) {
1346             scan(tree.expr);
1347             recordExit(new PendingExit(tree));
1348         }
1349 
1350         public void visitThrow(JCThrow tree) {
1351             scan(tree.expr);
1352             Symbol sym = TreeInfo.symbol(tree.expr);
1353             if (sym != null &amp;&amp;
1354                 sym.kind == VAR &amp;&amp;
1355                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1356                 preciseRethrowTypes.get(sym) != null) {
1357                 for (Type t : preciseRethrowTypes.get(sym)) {
1358                     markThrown(tree, t);
1359                 }
1360             }
1361             else {
1362                 markThrown(tree, tree.expr.type);
1363             }
1364             markDead();
1365         }
1366 
1367         public void visitApply(JCMethodInvocation tree) {
1368             scan(tree.meth);
1369             scan(tree.args);
1370             for (List&lt;Type&gt; l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
1371                 markThrown(tree, l.head);
1372         }
1373 
1374         public void visitNewClass(JCNewClass tree) {
1375             scan(tree.encl);
1376             scan(tree.args);
1377            // scan(tree.def);
1378             for (List&lt;Type&gt; l = tree.constructorType.getThrownTypes();
1379                  l.nonEmpty();
1380                  l = l.tail) {
1381                 markThrown(tree, l.head);
1382             }
1383             List&lt;Type&gt; caughtPrev = caught;
1384             try {
1385                 // If the new class expression defines an anonymous class,
1386                 // analysis of the anonymous constructor may encounter thrown
1387                 // types which are unsubstituted type variables.
1388                 // However, since the constructor&#39;s actual thrown types have
1389                 // already been marked as thrown, it is safe to simply include
1390                 // each of the constructor&#39;s formal thrown types in the set of
1391                 // &#39;caught/declared to be thrown&#39; types, for the duration of
1392                 // the class def analysis.
1393                 if (tree.def != null)
1394                     for (List&lt;Type&gt; l = tree.constructor.type.getThrownTypes();
1395                          l.nonEmpty();
1396                          l = l.tail) {
1397                         caught = chk.incl(l.head, caught);
1398                     }
1399                 scan(tree.def);
1400             }
1401             finally {
1402                 caught = caughtPrev;
1403             }
1404         }
1405 
1406         @Override
1407         public void visitLambda(JCLambda tree) {
1408             if (tree.type != null &amp;&amp;
1409                     tree.type.isErroneous()) {
1410                 return;
1411             }
1412             List&lt;Type&gt; prevCaught = caught;
1413             List&lt;Type&gt; prevThrown = thrown;
1414             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1415             try {
1416                 pendingExits = new ListBuffer&lt;&gt;();
1417                 caught = tree.getDescriptorType(types).getThrownTypes();
1418                 thrown = List.nil();
1419                 scan(tree.body);
1420                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1421                 pendingExits = new ListBuffer&lt;&gt;();
1422                 while (exits.nonEmpty()) {
1423                     PendingExit exit = exits.head;
1424                     exits = exits.tail;
1425                     if (!(exit instanceof ThrownPendingExit)) {
1426                         Assert.check(exit.tree.hasTag(RETURN) ||
1427                                         log.hasErrorOn(exit.tree.pos()));
1428                     } else {
1429                         // uncaught throws will be reported later
1430                         pendingExits.append(exit);
1431                     }
1432                 }
1433 
1434                 errorUncaught();
1435             } finally {
1436                 pendingExits = prevPending;
1437                 caught = prevCaught;
1438                 thrown = prevThrown;
1439             }
1440         }
1441 
1442         public void visitModuleDef(JCModuleDecl tree) {
1443             // Do nothing for modules
1444         }
1445 
1446     /**************************************************************************
1447      * main method
1448      *************************************************************************/
1449 
1450         /** Perform definite assignment/unassignment analysis on a tree.
1451          */
1452         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
1453             analyzeTree(env, env.tree, make);
1454         }
1455         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
1456             try {
1457                 attrEnv = env;
1458                 Flow.this.make = make;
1459                 pendingExits = new ListBuffer&lt;&gt;();
1460                 preciseRethrowTypes = new HashMap&lt;&gt;();
1461                 this.thrown = this.caught = null;
1462                 this.classDef = null;
1463                 scan(tree);
1464             } finally {
1465                 pendingExits = null;
1466                 Flow.this.make = null;
1467                 this.thrown = this.caught = null;
1468                 this.classDef = null;
1469             }
1470         }
1471     }
1472 
1473     /**
1474      * Specialized pass that performs reachability analysis on a lambda
1475      */
1476     class LambdaAliveAnalyzer extends AliveAnalyzer {
1477 
1478         boolean inLambda;
1479 
1480         @Override
1481         public void visitReturn(JCReturn tree) {
1482             //ignore lambda return expression (which might not even be attributed)
1483             recordExit(new PendingExit(tree));
1484         }
1485 
1486         @Override
1487         public void visitLambda(JCLambda tree) {
1488             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1489                 return;
1490             }
1491             inLambda = true;
1492             try {
1493                 super.visitLambda(tree);
1494             } finally {
1495                 inLambda = false;
1496             }
1497         }
1498 
1499         @Override
1500         public void visitClassDef(JCClassDecl tree) {
1501             //skip
1502         }
1503     }
1504 
1505     /**
1506      * Determine if alive after the given tree.
1507      */
1508     class SnippetAliveAnalyzer extends AliveAnalyzer {
1509         @Override
1510         public void visitClassDef(JCClassDecl tree) {
1511             //skip
1512         }
1513         public boolean isAlive() {
1514             return super.alive != Liveness.DEAD;
1515         }
1516     }
1517 
1518     class SnippetBreakAnalyzer extends AliveAnalyzer {
1519         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();
1520         private boolean breaksOut;
1521 
1522         public SnippetBreakAnalyzer() {
1523         }
1524 
1525         @Override
1526         public void visitLabelled(JCTree.JCLabeledStatement tree) {
1527             seenTrees.add(tree);
1528             super.visitLabelled(tree);
1529         }
1530 
1531         @Override
1532         public void visitWhileLoop(JCTree.JCWhileLoop tree) {
1533             seenTrees.add(tree);
1534             super.visitWhileLoop(tree);
1535         }
1536 
1537         @Override
1538         public void visitForLoop(JCTree.JCForLoop tree) {
1539             seenTrees.add(tree);
1540             super.visitForLoop(tree);
1541         }
1542 
1543         @Override
1544         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {
1545             seenTrees.add(tree);
1546             super.visitForeachLoop(tree);
1547         }
1548 
1549         @Override
1550         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {
1551             seenTrees.add(tree);
1552             super.visitDoLoop(tree);
1553         }
1554 
1555         @Override
1556         public void visitBreak(JCBreak tree) {
1557             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;
1558                           !seenTrees.contains(tree.target));
1559             super.visitBreak(tree);
1560         }
1561 
1562         public boolean breaksOut() {
1563             return breaksOut;
1564         }
1565     }
1566 
1567     /**
1568      * Specialized pass that performs DA/DU on a lambda
1569      */
1570     class LambdaAssignAnalyzer extends AssignAnalyzer {
1571         WriteableScope enclosedSymbols;
1572         boolean inLambda;
1573 
1574         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1575             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1576         }
1577 
1578         @Override
1579         public void visitLambda(JCLambda tree) {
1580             if (inLambda) {
1581                 return;
1582             }
1583             inLambda = true;
1584             try {
1585                 super.visitLambda(tree);
1586             } finally {
1587                 inLambda = false;
1588             }
1589         }
1590 
1591         @Override
1592         public void visitVarDef(JCVariableDecl tree) {
1593             enclosedSymbols.enter(tree.sym);
1594             super.visitVarDef(tree);
1595         }
1596         @Override
1597         protected boolean trackable(VarSymbol sym) {
1598             return enclosedSymbols.includes(sym) &amp;&amp;
1599                    sym.owner.kind == MTH;
1600         }
1601 
1602         @Override
1603         public void visitClassDef(JCClassDecl tree) {
1604             //skip
1605         }
1606     }
1607 
1608     /**
1609      * Specialized pass that performs inference of thrown types for lambdas.
1610      */
1611     class LambdaFlowAnalyzer extends FlowAnalyzer {
1612         List&lt;Type&gt; inferredThrownTypes;
1613         boolean inLambda;
1614         @Override
1615         public void visitLambda(JCLambda tree) {
1616             if ((tree.type != null &amp;&amp;
1617                     tree.type.isErroneous()) || inLambda) {
1618                 return;
1619             }
1620             List&lt;Type&gt; prevCaught = caught;
1621             List&lt;Type&gt; prevThrown = thrown;
1622             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1623             inLambda = true;
1624             try {
1625                 pendingExits = new ListBuffer&lt;&gt;();
1626                 caught = List.of(syms.throwableType);
1627                 thrown = List.nil();
1628                 scan(tree.body);
1629                 inferredThrownTypes = thrown;
1630             } finally {
1631                 pendingExits = prevPending;
1632                 caught = prevCaught;
1633                 thrown = prevThrown;
1634                 inLambda = false;
1635             }
1636         }
1637         @Override
1638         public void visitClassDef(JCClassDecl tree) {
1639             //skip
1640         }
1641     }
1642 
1643     /**
1644      * This pass implements (i) definite assignment analysis, which ensures that
1645      * each variable is assigned when used and (ii) definite unassignment analysis,
1646      * which ensures that no final variable is assigned more than once. This visitor
1647      * depends on the results of the liveliness analyzer. This pass is also used to mark
1648      * effectively-final local variables/parameters.
1649      */
1650 
1651     public class AssignAnalyzer extends BaseAnalyzer {
1652 
1653         /** The set of definitely assigned variables.
1654          */
1655         final Bits inits;
1656 
1657         /** The set of definitely unassigned variables.
1658          */
1659         final Bits uninits;
1660 
1661         /** The set of variables that are definitely unassigned everywhere
1662          *  in current try block. This variable is maintained lazily; it is
1663          *  updated only when something gets removed from uninits,
1664          *  typically by being assigned in reachable code.  To obtain the
1665          *  correct set of variables which are definitely unassigned
1666          *  anywhere in current try block, intersect uninitsTry and
1667          *  uninits.
1668          */
1669         final Bits uninitsTry;
1670 
1671         /** When analyzing a condition, inits and uninits are null.
1672          *  Instead we have:
1673          */
1674         final Bits initsWhenTrue;
1675         final Bits initsWhenFalse;
1676         final Bits uninitsWhenTrue;
1677         final Bits uninitsWhenFalse;
1678 
1679         /** A mapping from addresses to variable symbols.
1680          */
1681         protected JCVariableDecl[] vardecls;
1682 
1683         /** The current class being defined.
1684          */
1685         JCClassDecl classDef;
1686 
1687         /** The first variable sequence number in this class definition.
1688          */
1689         int firstadr;
1690 
1691         /** The next available variable sequence number.
1692          */
1693         protected int nextadr;
1694 
1695         /** The first variable sequence number in a block that can return.
1696          */
1697         protected int returnadr;
1698 
1699         /** The list of unreferenced automatic resources.
1700          */
1701         WriteableScope unrefdResources;
1702 
1703         /** Modified when processing a loop body the second time for DU analysis. */
1704         FlowKind flowKind = FlowKind.NORMAL;
1705 
1706         /** The starting position of the analyzed tree */
1707         int startPos;
1708 
1709         public class AssignPendingExit extends BaseAnalyzer.PendingExit {
1710 
1711             final Bits inits;
1712             final Bits uninits;
1713             final Bits exit_inits = new Bits(true);
1714             final Bits exit_uninits = new Bits(true);
1715 
1716             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1717                 super(tree);
1718                 this.inits = inits;
1719                 this.uninits = uninits;
1720                 this.exit_inits.assign(inits);
1721                 this.exit_uninits.assign(uninits);
1722             }
1723 
1724             @Override
1725             public void resolveJump() {
1726                 inits.andSet(exit_inits);
1727                 uninits.andSet(exit_uninits);
1728             }
1729         }
1730 
1731         public AssignAnalyzer() {
1732             this.inits = new Bits();
1733             uninits = new Bits();
1734             uninitsTry = new Bits();
1735             initsWhenTrue = new Bits(true);
1736             initsWhenFalse = new Bits(true);
1737             uninitsWhenTrue = new Bits(true);
1738             uninitsWhenFalse = new Bits(true);
1739         }
1740 
1741         private boolean isInitialConstructor = false;
1742 
1743         @Override
1744         protected void markDead() {
1745             if (!isInitialConstructor) {
1746                 inits.inclRange(returnadr, nextadr);
1747             } else {
1748                 for (int address = returnadr; address &lt; nextadr; address++) {
1749                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1750                         inits.incl(address);
1751                     }
1752                 }
1753             }
1754             uninits.inclRange(returnadr, nextadr);
1755         }
1756 
1757         /*-------------- Processing variables ----------------------*/
1758 
1759         /** Do we need to track init/uninit state of this symbol?
1760          *  I.e. is symbol either a local or a blank final variable?
1761          */
1762         protected boolean trackable(VarSymbol sym) {
1763             return
1764                 sym.pos &gt;= startPos &amp;&amp;
1765                 ((sym.owner.kind == MTH || sym.owner.kind == VAR ||
1766                 isFinalUninitializedField(sym)));
1767         }
1768 
1769         boolean isFinalUninitializedField(VarSymbol sym) {
1770             return sym.owner.kind == TYP &amp;&amp;
1771                    ((sym.flags() &amp; (FINAL | HASINIT | PARAMETER)) == FINAL &amp;&amp;
1772                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner));
1773         }
1774 
1775         boolean isFinalUninitializedStaticField(VarSymbol sym) {
1776             return isFinalUninitializedField(sym) &amp;&amp; sym.isStatic();
1777         }
1778 
1779         /** Initialize new trackable variable by setting its address field
1780          *  to the next available sequence number and entering it under that
1781          *  index into the vars array.
1782          */
1783         void newVar(JCVariableDecl varDecl) {
1784             VarSymbol sym = varDecl.sym;
1785             vardecls = ArrayUtils.ensureCapacity(vardecls, nextadr);
1786             if ((sym.flags() &amp; FINAL) == 0) {
1787                 sym.flags_field |= EFFECTIVELY_FINAL;
1788             }
1789             sym.adr = nextadr;
1790             vardecls[nextadr] = varDecl;
1791             inits.excl(nextadr);
1792             uninits.incl(nextadr);
1793             nextadr++;
1794         }
1795 
1796         /** Record an initialization of a trackable variable.
1797          */
1798         void letInit(DiagnosticPosition pos, VarSymbol sym) {
1799             if (sym.adr &gt;= firstadr &amp;&amp; trackable(sym)) {
1800                 if ((sym.flags() &amp; EFFECTIVELY_FINAL) != 0) {
1801                     if (!uninits.isMember(sym.adr)) {
1802                         //assignment targeting an effectively final variable
1803                         //makes the variable lose its status of effectively final
1804                         //if the variable is _not_ definitively unassigned
1805                         sym.flags_field &amp;= ~EFFECTIVELY_FINAL;
1806                     } else {
1807                         uninit(sym);
1808                     }
1809                 }
1810                 else if ((sym.flags() &amp; FINAL) != 0) {
1811                     if ((sym.flags() &amp; PARAMETER) != 0) {
1812                         if ((sym.flags() &amp; UNION) != 0) { //multi-catch parameter
1813                             log.error(pos, Errors.MulticatchParameterMayNotBeAssigned(sym));
1814                         }
1815                         else {
1816                             log.error(pos,
1817                                       Errors.FinalParameterMayNotBeAssigned(sym));
1818                         }
1819                     } else if (!uninits.isMember(sym.adr)) {
1820                         log.error(pos, diags.errorKey(flowKind.errKey, sym));
1821                     } else {
1822                         uninit(sym);
1823                     }
1824                 }
1825                 inits.incl(sym.adr);
1826             } else if ((sym.flags() &amp; FINAL) != 0) {
1827                 log.error(pos, Errors.VarMightAlreadyBeAssigned(sym));
1828             }
1829         }
1830         //where
1831             void uninit(VarSymbol sym) {
1832                 if (!inits.isMember(sym.adr)) {
1833                     // reachable assignment
1834                     uninits.excl(sym.adr);
1835                     uninitsTry.excl(sym.adr);
1836                 } else {
1837                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1838                     uninits.excl(sym.adr);
1839                 }
1840             }
1841 
1842         /** If tree is either a simple name or of the form this.name or
1843          *  C.this.name, and tree represents a trackable variable,
1844          *  record an initialization of the variable.
1845          */
1846         void letInit(JCTree tree) {
1847             tree = TreeInfo.skipParens(tree);
1848             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1849                 Symbol sym = TreeInfo.symbol(tree);
1850                 if (sym.kind == VAR) {
1851                     letInit(tree.pos(), (VarSymbol)sym);
1852                 }
1853             }
1854         }
1855 
1856         /** Check that trackable variable is initialized.
1857          */
1858         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1859             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1860         }
1861 
1862         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1863             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1864                 trackable(sym) &amp;&amp;
1865                 !inits.isMember(sym.adr)) {
1866                     log.error(pos, errkey);
1867                 inits.incl(sym.adr);
1868             }
1869         }
1870 
1871         /** Utility method to reset several Bits instances.
1872          */
1873         private void resetBits(Bits... bits) {
1874             for (Bits b : bits) {
1875                 b.reset();
1876             }
1877         }
1878 
1879         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1880          */
1881         void split(boolean setToNull) {
1882             initsWhenFalse.assign(inits);
1883             uninitsWhenFalse.assign(uninits);
1884             initsWhenTrue.assign(inits);
1885             uninitsWhenTrue.assign(uninits);
1886             if (setToNull) {
1887                 resetBits(inits, uninits);
1888             }
1889         }
1890 
1891         /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
1892          */
1893         protected void merge() {
1894             inits.assign(initsWhenFalse.andSet(initsWhenTrue));
1895             uninits.assign(uninitsWhenFalse.andSet(uninitsWhenTrue));
1896         }
1897 
1898     /* ************************************************************************
1899      * Visitor methods for statements and definitions
1900      *************************************************************************/
1901 
1902         /** Analyze an expression. Make sure to set (un)inits rather than
1903          *  (un)initsWhenTrue(WhenFalse) on exit.
1904          */
1905         void scanExpr(JCTree tree) {
1906             if (tree != null) {
1907                 scan(tree);
1908                 if (inits.isReset()) {
1909                     merge();
1910                 }
1911             }
1912         }
1913 
1914         /** Analyze a list of expressions.
1915          */
1916         void scanExprs(List&lt;? extends JCExpression&gt; trees) {
1917             if (trees != null)
1918                 for (List&lt;? extends JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
1919                     scanExpr(l.head);
1920         }
1921 
1922         /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
1923          *  rather than (un)inits on exit.
1924          */
1925         void scanCond(JCTree tree) {
1926             if (tree.type.isFalse()) {
1927                 if (inits.isReset()) merge();
1928                 initsWhenTrue.assign(inits);
1929                 initsWhenTrue.inclRange(firstadr, nextadr);
1930                 uninitsWhenTrue.assign(uninits);
1931                 uninitsWhenTrue.inclRange(firstadr, nextadr);
1932                 initsWhenFalse.assign(inits);
1933                 uninitsWhenFalse.assign(uninits);
1934             } else if (tree.type.isTrue()) {
1935                 if (inits.isReset()) merge();
1936                 initsWhenFalse.assign(inits);
1937                 initsWhenFalse.inclRange(firstadr, nextadr);
1938                 uninitsWhenFalse.assign(uninits);
1939                 uninitsWhenFalse.inclRange(firstadr, nextadr);
1940                 initsWhenTrue.assign(inits);
1941                 uninitsWhenTrue.assign(uninits);
1942             } else {
1943                 scan(tree);
1944                 if (!inits.isReset())
1945                     split(tree.type != syms.unknownType);
1946             }
1947             if (tree.type != syms.unknownType) {
1948                 resetBits(inits, uninits);
1949             }
1950         }
1951 
1952         /* ------------ Visitor methods for various sorts of trees -------------*/
1953 
1954         public void visitClassDef(JCClassDecl tree) {
1955             if (tree.sym == null) {
1956                 return;
1957             }
1958 
1959             Lint lintPrev = lint;
1960             lint = lint.augment(tree.sym);
1961             try {
1962                 if (tree.sym == null) {
1963                     return;
1964                 }
1965 
1966                 JCClassDecl classDefPrev = classDef;
1967                 int firstadrPrev = firstadr;
1968                 int nextadrPrev = nextadr;
1969                 ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
1970 
1971                 pendingExits = new ListBuffer&lt;&gt;();
1972                 if (tree.name != names.empty) {
1973                     firstadr = nextadr;
1974                 }
1975                 classDef = tree;
1976                 try {
1977                     // define all the static fields
1978                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1979                         if (l.head.hasTag(VARDEF)) {
1980                             JCVariableDecl def = (JCVariableDecl)l.head;
1981                             if ((def.mods.flags &amp; STATIC) != 0) {
1982                                 VarSymbol sym = def.sym;
1983                                 if (trackable(sym)) {
1984                                     newVar(def);
1985                                 }
1986                             }
1987                         }
1988                     }
1989 
1990                     // process all the static initializers
1991                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1992                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
1993                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
1994                             scan(l.head);
1995                         }
1996                     }
1997 
1998                     // define all the instance fields
1999                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2000                         if (l.head.hasTag(VARDEF)) {
2001                             JCVariableDecl def = (JCVariableDecl)l.head;
2002                             if ((def.mods.flags &amp; STATIC) == 0) {
2003                                 VarSymbol sym = def.sym;
2004                                 if (trackable(sym)) {
2005                                     newVar(def);
2006                                 }
2007                             }
2008                         }
2009                     }
2010 
2011                     // process all the instance initializers
2012                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2013                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2014                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2015                             scan(l.head);
2016                         }
2017                     }
2018 
2019                     // process all the methods
2020                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2021                         if (l.head.hasTag(METHODDEF)) {
2022                             scan(l.head);
2023                         }
2024                     }
2025                 } finally {
2026                     pendingExits = pendingExitsPrev;
2027                     nextadr = nextadrPrev;
2028                     firstadr = firstadrPrev;
2029                     classDef = classDefPrev;
2030                 }
2031             } finally {
2032                 lint = lintPrev;
2033             }
2034         }
2035 
2036         public void visitMethodDef(JCMethodDecl tree) {
2037             if (tree.body == null) {
2038                 return;
2039             }
2040 
2041             /*  MemberEnter can generate synthetic methods ignore them
2042              */
2043             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2044                 return;
2045             }
2046 
2047             Lint lintPrev = lint;
2048             lint = lint.augment(tree.sym);
2049             try {
2050                 if (tree.body == null) {
2051                     return;
2052                 }
2053                 /*  Ignore synthetic methods, except for translated lambda methods.
2054                  */
2055                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2056                     return;
2057                 }
2058 
2059                 final Bits initsPrev = new Bits(inits);
2060                 final Bits uninitsPrev = new Bits(uninits);
2061                 int nextadrPrev = nextadr;
2062                 int firstadrPrev = firstadr;
2063                 int returnadrPrev = returnadr;
2064 
2065                 Assert.check(pendingExits.isEmpty());
2066                 boolean lastInitialConstructor = isInitialConstructor;
2067                 try {
2068                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2069 
2070                     if (!isInitialConstructor) {
2071                         firstadr = nextadr;
2072                     }
2073                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2074                         JCVariableDecl def = l.head;
2075                         scan(def);
2076                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2077                         /*  If we are executing the code from Gen, then there can be
2078                          *  synthetic or mandated variables, ignore them.
2079                          */
2080                         initParam(def);
2081                     }
2082                     // else we are in an instance initializer block;
2083                     // leave caught unchanged.
2084                     scan(tree.body);
2085 
2086                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2087                     if (isInitialConstructor) {
2088                         boolean isSynthesized = (tree.sym.flags() &amp;
2089                                                  GENERATEDCONSTR) != 0;
2090                         for (int i = firstadr; i &lt; nextadr; i++) {
2091                             JCVariableDecl vardecl = vardecls[i];
2092                             VarSymbol var = vardecl.sym;
2093                             if (var.owner == classDef.sym) {
2094                                 // choose the diagnostic position based on whether
2095                                 // the ctor is default(synthesized) or not
2096                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {
2097                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
2098                                             var, Errors.VarNotInitializedInDefaultConstructor(var));
2099                                 } else if (isCompactConstructor) {
2100                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;
2101                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2102                                             !var.isStatic() &amp;&amp;
2103                                             var.owner.kind == TYP;
2104                                     if (isInstanceRecordField) {
2105                                         boolean notInitialized = !inits.isMember(var.adr);
2106                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2107                                         /*  this way we indicate Lower that it should generate an initialization for this field
2108                                          *  in the compact constructor
2109                                          */
2110                                             var.flags_field |= UNINITIALIZED_FIELD;
2111                                         } else {
2112                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2113                                         }
2114                                     } else {
2115                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2116                                     }
2117                                 } else {
2118                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2119                                 }
2120                             }
2121                         }
2122                     }
2123                     List&lt;PendingExit&gt; exits = pendingExits.toList();
2124                     pendingExits = new ListBuffer&lt;&gt;();
2125                     while (exits.nonEmpty()) {
2126                         PendingExit exit = exits.head;
2127                         exits = exits.tail;
2128                         Assert.check(exit.tree.hasTag(RETURN) ||
2129                                          log.hasErrorOn(exit.tree.pos()),
2130                                      exit.tree);
2131                         if (isInitialConstructor) {
2132                             Assert.check(exit instanceof AssignPendingExit);
2133                             inits.assign(((AssignPendingExit) exit).exit_inits);
2134                             for (int i = firstadr; i &lt; nextadr; i++) {
2135                                 checkInit(exit.tree.pos(), vardecls[i].sym);
2136                             }
2137                         }
2138                     }
2139                 } finally {
2140                     inits.assign(initsPrev);
2141                     uninits.assign(uninitsPrev);
2142                     nextadr = nextadrPrev;
2143                     firstadr = firstadrPrev;
2144                     returnadr = returnadrPrev;
2145                     isInitialConstructor = lastInitialConstructor;
2146                 }
2147             } finally {
2148                 lint = lintPrev;
2149             }
2150         }
2151 
2152         protected void initParam(JCVariableDecl def) {
2153             inits.incl(def.sym.adr);
2154             uninits.excl(def.sym.adr);
2155         }
2156 
2157         public void visitVarDef(JCVariableDecl tree) {
2158             Lint lintPrev = lint;
2159             lint = lint.augment(tree.sym);
2160             try{
2161                 boolean track = trackable(tree.sym);
2162                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2163                     newVar(tree);
2164                 }
2165                 if (tree.init != null) {
2166                     scanExpr(tree.init);
2167                     if (track) {
2168                         letInit(tree.pos(), tree.sym);
2169                     }
2170                 }
2171             } finally {
2172                 lint = lintPrev;
2173             }
2174         }
2175 
2176         public void visitBlock(JCBlock tree) {
2177             int nextadrPrev = nextadr;
2178             scan(tree.stats);
2179             nextadr = nextadrPrev;
2180         }
2181 
2182         public void visitDoLoop(JCDoWhileLoop tree) {
2183             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2184             FlowKind prevFlowKind = flowKind;
2185             flowKind = FlowKind.NORMAL;
2186             final Bits initsSkip = new Bits(true);
2187             final Bits uninitsSkip = new Bits(true);
2188             pendingExits = new ListBuffer&lt;&gt;();
2189             int prevErrors = log.nerrors;
2190             do {
2191                 final Bits uninitsEntry = new Bits(uninits);
2192                 uninitsEntry.excludeFrom(nextadr);
2193                 scan(tree.body);
2194                 resolveContinues(tree);
2195                 scanCond(tree.cond);
2196                 if (!flowKind.isFinal()) {
2197                     initsSkip.assign(initsWhenFalse);
2198                     uninitsSkip.assign(uninitsWhenFalse);
2199                 }
2200                 if (log.nerrors !=  prevErrors ||
2201                     flowKind.isFinal() ||
2202                     new Bits(uninitsEntry).diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
2203                     break;
2204                 inits.assign(initsWhenTrue);
2205                 uninits.assign(uninitsEntry.andSet(uninitsWhenTrue));
2206                 flowKind = FlowKind.SPECULATIVE_LOOP;
2207             } while (true);
2208             flowKind = prevFlowKind;
2209             inits.assign(initsSkip);
2210             uninits.assign(uninitsSkip);
2211             resolveBreaks(tree, prevPendingExits);
2212         }
2213 
2214         public void visitWhileLoop(JCWhileLoop tree) {
2215             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2216             FlowKind prevFlowKind = flowKind;
2217             flowKind = FlowKind.NORMAL;
2218             final Bits initsSkip = new Bits(true);
2219             final Bits uninitsSkip = new Bits(true);
2220             pendingExits = new ListBuffer&lt;&gt;();
2221             int prevErrors = log.nerrors;
2222             final Bits uninitsEntry = new Bits(uninits);
2223             uninitsEntry.excludeFrom(nextadr);
2224             do {
2225                 scanCond(tree.cond);
2226                 if (!flowKind.isFinal()) {
2227                     initsSkip.assign(initsWhenFalse) ;
2228                     uninitsSkip.assign(uninitsWhenFalse);
2229                 }
2230                 inits.assign(initsWhenTrue);
2231                 uninits.assign(uninitsWhenTrue);
2232                 scan(tree.body);
2233                 resolveContinues(tree);
2234                 if (log.nerrors != prevErrors ||
2235                     flowKind.isFinal() ||
2236                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1) {
2237                     break;
2238                 }
2239                 uninits.assign(uninitsEntry.andSet(uninits));
2240                 flowKind = FlowKind.SPECULATIVE_LOOP;
2241             } while (true);
2242             flowKind = prevFlowKind;
2243             //a variable is DA/DU after the while statement, if it&#39;s DA/DU assuming the
2244             //branch is not taken AND if it&#39;s DA/DU before any break statement
2245             inits.assign(initsSkip);
2246             uninits.assign(uninitsSkip);
2247             resolveBreaks(tree, prevPendingExits);
2248         }
2249 
2250         public void visitForLoop(JCForLoop tree) {
2251             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2252             FlowKind prevFlowKind = flowKind;
2253             flowKind = FlowKind.NORMAL;
2254             int nextadrPrev = nextadr;
2255             scan(tree.init);
2256             final Bits initsSkip = new Bits(true);
2257             final Bits uninitsSkip = new Bits(true);
2258             pendingExits = new ListBuffer&lt;&gt;();
2259             int prevErrors = log.nerrors;
2260             do {
2261                 final Bits uninitsEntry = new Bits(uninits);
2262                 uninitsEntry.excludeFrom(nextadr);
2263                 if (tree.cond != null) {
2264                     scanCond(tree.cond);
2265                     if (!flowKind.isFinal()) {
2266                         initsSkip.assign(initsWhenFalse);
2267                         uninitsSkip.assign(uninitsWhenFalse);
2268                     }
2269                     inits.assign(initsWhenTrue);
2270                     uninits.assign(uninitsWhenTrue);
2271                 } else if (!flowKind.isFinal()) {
2272                     initsSkip.assign(inits);
2273                     initsSkip.inclRange(firstadr, nextadr);
2274                     uninitsSkip.assign(uninits);
2275                     uninitsSkip.inclRange(firstadr, nextadr);
2276                 }
2277                 scan(tree.body);
2278                 resolveContinues(tree);
2279                 scan(tree.step);
2280                 if (log.nerrors != prevErrors ||
2281                     flowKind.isFinal() ||
2282                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2283                     break;
2284                 uninits.assign(uninitsEntry.andSet(uninits));
2285                 flowKind = FlowKind.SPECULATIVE_LOOP;
2286             } while (true);
2287             flowKind = prevFlowKind;
2288             //a variable is DA/DU after a for loop, if it&#39;s DA/DU assuming the
2289             //branch is not taken AND if it&#39;s DA/DU before any break statement
2290             inits.assign(initsSkip);
2291             uninits.assign(uninitsSkip);
2292             resolveBreaks(tree, prevPendingExits);
2293             nextadr = nextadrPrev;
2294         }
2295 
2296         public void visitForeachLoop(JCEnhancedForLoop tree) {
2297             visitVarDef(tree.var);
2298 
2299             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2300             FlowKind prevFlowKind = flowKind;
2301             flowKind = FlowKind.NORMAL;
2302             int nextadrPrev = nextadr;
2303             scan(tree.expr);
2304             final Bits initsStart = new Bits(inits);
2305             final Bits uninitsStart = new Bits(uninits);
2306 
2307             letInit(tree.pos(), tree.var.sym);
2308             pendingExits = new ListBuffer&lt;&gt;();
2309             int prevErrors = log.nerrors;
2310             do {
2311                 final Bits uninitsEntry = new Bits(uninits);
2312                 uninitsEntry.excludeFrom(nextadr);
2313                 scan(tree.body);
2314                 resolveContinues(tree);
2315                 if (log.nerrors != prevErrors ||
2316                     flowKind.isFinal() ||
2317                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2318                     break;
2319                 uninits.assign(uninitsEntry.andSet(uninits));
2320                 flowKind = FlowKind.SPECULATIVE_LOOP;
2321             } while (true);
2322             flowKind = prevFlowKind;
2323             inits.assign(initsStart);
2324             uninits.assign(uninitsStart.andSet(uninits));
2325             resolveBreaks(tree, prevPendingExits);
2326             nextadr = nextadrPrev;
2327         }
2328 
2329         public void visitLabelled(JCLabeledStatement tree) {
2330             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2331             pendingExits = new ListBuffer&lt;&gt;();
2332             scan(tree.body);
2333             resolveBreaks(tree, prevPendingExits);
2334         }
2335 
2336         public void visitSwitch(JCSwitch tree) {
2337             handleSwitch(tree, tree.selector, tree.cases);
2338         }
2339 
2340         public void visitSwitchExpression(JCSwitchExpression tree) {
2341             handleSwitch(tree, tree.selector, tree.cases);
2342         }
2343 
2344         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
2345             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2346             pendingExits = new ListBuffer&lt;&gt;();
2347             int nextadrPrev = nextadr;
2348             scanExpr(selector);
2349             final Bits initsSwitch = new Bits(inits);
2350             final Bits uninitsSwitch = new Bits(uninits);
2351             boolean hasDefault = false;
2352             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
2353                 inits.assign(initsSwitch);
2354                 uninits.assign(uninits.andSet(uninitsSwitch));
2355                 JCCase c = l.head;
2356                 if (c.pats.isEmpty()) {
2357                     hasDefault = true;
2358                 } else {
2359                     for (JCExpression pat : c.pats) {
2360                         scanExpr(pat);
2361                     }
2362                 }
2363                 if (hasDefault) {
2364                     inits.assign(initsSwitch);
2365                     uninits.assign(uninits.andSet(uninitsSwitch));
2366                 }
2367                 scan(c.stats);
2368                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2369                     scanSyntheticBreak(make, tree);
2370                 }
2371                 addVars(c.stats, initsSwitch, uninitsSwitch);
2372                 if (!hasDefault) {
2373                     inits.assign(initsSwitch);
2374                     uninits.assign(uninits.andSet(uninitsSwitch));
2375                 }
2376                 // Warn about fall-through if lint switch fallthrough enabled.
2377             }
2378             if (!hasDefault) {
2379                 if (tree.hasTag(SWITCH_EXPRESSION)) {
2380                     markDead();
2381                 } else {
2382                     inits.andSet(initsSwitch);
2383                 }
2384             }
2385             if (tree.hasTag(SWITCH_EXPRESSION)) {
2386                 resolveYields(tree, prevPendingExits);
2387             } else {
2388                 resolveBreaks(tree, prevPendingExits);
2389             }
2390             nextadr = nextadrPrev;
2391         }
2392         // where
2393             /** Add any variables defined in stats to inits and uninits. */
2394             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2395                                         final Bits uninits) {
2396                 for (;stats.nonEmpty(); stats = stats.tail) {
2397                     JCTree stat = stats.head;
2398                     if (stat.hasTag(VARDEF)) {
2399                         int adr = ((JCVariableDecl) stat).sym.adr;
2400                         inits.excl(adr);
2401                         uninits.incl(adr);
2402                     }
2403                 }
2404             }
2405 
2406         public void visitTry(JCTry tree) {
2407             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2408             final Bits uninitsTryPrev = new Bits(uninitsTry);
2409             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2410             pendingExits = new ListBuffer&lt;&gt;();
2411             final Bits initsTry = new Bits(inits);
2412             uninitsTry.assign(uninits);
2413             for (JCTree resource : tree.resources) {
2414                 if (resource instanceof JCVariableDecl) {
2415                     JCVariableDecl vdecl = (JCVariableDecl) resource;
2416                     visitVarDef(vdecl);
2417                     unrefdResources.enter(vdecl.sym);
2418                     resourceVarDecls.append(vdecl);
2419                 } else if (resource instanceof JCExpression) {
2420                     scanExpr((JCExpression) resource);
2421                 } else {
2422                     throw new AssertionError(tree);  // parser error
2423                 }
2424             }
2425             scan(tree.body);
2426             uninitsTry.andSet(uninits);
2427             final Bits initsEnd = new Bits(inits);
2428             final Bits uninitsEnd = new Bits(uninits);
2429             int nextadrCatch = nextadr;
2430 
2431             if (!resourceVarDecls.isEmpty() &amp;&amp;
2432                     lint.isEnabled(Lint.LintCategory.TRY)) {
2433                 for (JCVariableDecl resVar : resourceVarDecls) {
2434                     if (unrefdResources.includes(resVar.sym)) {
2435                         log.warning(Lint.LintCategory.TRY, resVar.pos(),
2436                                     Warnings.TryResourceNotReferenced(resVar.sym));
2437                         unrefdResources.remove(resVar.sym);
2438                     }
2439                 }
2440             }
2441 
2442             /*  The analysis of each catch should be independent.
2443              *  Each one should have the same initial values of inits and
2444              *  uninits.
2445              */
2446             final Bits initsCatchPrev = new Bits(initsTry);
2447             final Bits uninitsCatchPrev = new Bits(uninitsTry);
2448 
2449             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
2450                 JCVariableDecl param = l.head.param;
2451                 inits.assign(initsCatchPrev);
2452                 uninits.assign(uninitsCatchPrev);
2453                 scan(param);
2454                 /* If this is a TWR and we are executing the code from Gen,
2455                  * then there can be synthetic variables, ignore them.
2456                  */
2457                 initParam(param);
2458                 scan(l.head.body);
2459                 initsEnd.andSet(inits);
2460                 uninitsEnd.andSet(uninits);
2461                 nextadr = nextadrCatch;
2462             }
2463             if (tree.finalizer != null) {
2464                 inits.assign(initsTry);
2465                 uninits.assign(uninitsTry);
2466                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2467                 pendingExits = prevPendingExits;
2468                 scan(tree.finalizer);
2469                 if (!tree.finallyCanCompleteNormally) {
2470                     // discard exits and exceptions from try and finally
2471                 } else {
2472                     uninits.andSet(uninitsEnd);
2473                     // FIX: this doesn&#39;t preserve source order of exits in catch
2474                     // versus finally!
2475                     while (exits.nonEmpty()) {
2476                         PendingExit exit = exits.next();
2477                         if (exit instanceof AssignPendingExit) {
2478                             ((AssignPendingExit) exit).exit_inits.orSet(inits);
2479                             ((AssignPendingExit) exit).exit_uninits.andSet(uninits);
2480                         }
2481                         pendingExits.append(exit);
2482                     }
2483                     inits.orSet(initsEnd);
2484                 }
2485             } else {
2486                 inits.assign(initsEnd);
2487                 uninits.assign(uninitsEnd);
2488                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2489                 pendingExits = prevPendingExits;
2490                 while (exits.nonEmpty()) pendingExits.append(exits.next());
2491             }
2492             uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
2493         }
2494 
2495         public void visitConditional(JCConditional tree) {
2496             scanCond(tree.cond);
2497             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2498             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2499             inits.assign(initsWhenTrue);
2500             uninits.assign(uninitsWhenTrue);
2501             if (tree.truepart.type.hasTag(BOOLEAN) &amp;&amp;
2502                 tree.falsepart.type.hasTag(BOOLEAN)) {
2503                 // if b and c are boolean valued, then
2504                 // v is (un)assigned after a?b:c when true iff
2505                 //    v is (un)assigned after b when true and
2506                 //    v is (un)assigned after c when true
2507                 scanCond(tree.truepart);
2508                 final Bits initsAfterThenWhenTrue = new Bits(initsWhenTrue);
2509                 final Bits initsAfterThenWhenFalse = new Bits(initsWhenFalse);
2510                 final Bits uninitsAfterThenWhenTrue = new Bits(uninitsWhenTrue);
2511                 final Bits uninitsAfterThenWhenFalse = new Bits(uninitsWhenFalse);
2512                 inits.assign(initsBeforeElse);
2513                 uninits.assign(uninitsBeforeElse);
2514                 scanCond(tree.falsepart);
2515                 initsWhenTrue.andSet(initsAfterThenWhenTrue);
2516                 initsWhenFalse.andSet(initsAfterThenWhenFalse);
2517                 uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
2518                 uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
2519             } else {
2520                 scanExpr(tree.truepart);
2521                 final Bits initsAfterThen = new Bits(inits);
2522                 final Bits uninitsAfterThen = new Bits(uninits);
2523                 inits.assign(initsBeforeElse);
2524                 uninits.assign(uninitsBeforeElse);
2525                 scanExpr(tree.falsepart);
2526                 inits.andSet(initsAfterThen);
2527                 uninits.andSet(uninitsAfterThen);
2528             }
2529         }
2530 
2531         public void visitIf(JCIf tree) {
2532             scanCond(tree.cond);
2533             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2534             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2535             inits.assign(initsWhenTrue);
2536             uninits.assign(uninitsWhenTrue);
2537             scan(tree.thenpart);
2538             if (tree.elsepart != null) {
2539                 final Bits initsAfterThen = new Bits(inits);
2540                 final Bits uninitsAfterThen = new Bits(uninits);
2541                 inits.assign(initsBeforeElse);
2542                 uninits.assign(uninitsBeforeElse);
2543                 scan(tree.elsepart);
2544                 inits.andSet(initsAfterThen);
2545                 uninits.andSet(uninitsAfterThen);
2546             } else {
2547                 inits.andSet(initsBeforeElse);
2548                 uninits.andSet(uninitsBeforeElse);
2549             }
2550         }
2551 
2552         @Override
2553         public void visitBreak(JCBreak tree) {
2554             recordExit(new AssignPendingExit(tree, inits, uninits));
2555         }
2556 
2557         @Override
2558         public void visitYield(JCYield tree) {
2559             JCSwitchExpression expr = (JCSwitchExpression) tree.target;
2560             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {
2561                 scanCond(tree.value);
2562                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);
2563                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);
2564                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);
2565                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);
2566                 PendingExit exit = new PendingExit(tree) {
2567                     @Override
2568                     void resolveJump() {
2569                         if (!inits.isReset()) {
2570                             split(true);
2571                         }
2572                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);
2573                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);
2574                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);
2575                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);
2576                     }
2577                 };
2578                 merge();
2579                 recordExit(exit);
2580                 return ;
2581             } else {
2582                 scanExpr(tree.value);
2583                 recordExit(new AssignPendingExit(tree, inits, uninits));
2584             }
2585         }
2586 
2587         @Override
2588         public void visitContinue(JCContinue tree) {
2589             recordExit(new AssignPendingExit(tree, inits, uninits));
2590         }
2591 
2592         @Override
2593         public void visitReturn(JCReturn tree) {
2594             scanExpr(tree.expr);
2595             recordExit(new AssignPendingExit(tree, inits, uninits));
2596         }
2597 
2598         public void visitThrow(JCThrow tree) {
2599             scanExpr(tree.expr);
2600             markDead();
2601         }
2602 
2603         public void visitApply(JCMethodInvocation tree) {
2604             scanExpr(tree.meth);
2605             scanExprs(tree.args);
2606         }
2607 
2608         public void visitNewClass(JCNewClass tree) {
2609             scanExpr(tree.encl);
2610             scanExprs(tree.args);
2611             scan(tree.def);
2612         }
2613 
2614         @Override
2615         public void visitLambda(JCLambda tree) {
2616             final Bits prevUninits = new Bits(uninits);
2617             final Bits prevInits = new Bits(inits);
2618             int returnadrPrev = returnadr;
2619             int nextadrPrev = nextadr;
2620             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2621             try {
2622                 returnadr = nextadr;
2623                 pendingExits = new ListBuffer&lt;&gt;();
2624                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2625                     JCVariableDecl def = l.head;
2626                     scan(def);
2627                     inits.incl(def.sym.adr);
2628                     uninits.excl(def.sym.adr);
2629                 }
2630                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2631                     scanExpr(tree.body);
2632                 } else {
2633                     scan(tree.body);
2634                 }
2635             }
2636             finally {
2637                 returnadr = returnadrPrev;
2638                 uninits.assign(prevUninits);
2639                 inits.assign(prevInits);
2640                 pendingExits = prevPending;
2641                 nextadr = nextadrPrev;
2642             }
2643         }
2644 
2645         public void visitNewArray(JCNewArray tree) {
2646             scanExprs(tree.dims);
2647             scanExprs(tree.elems);
2648         }
2649 
2650         public void visitAssert(JCAssert tree) {
2651             final Bits initsExit = new Bits(inits);
2652             final Bits uninitsExit = new Bits(uninits);
2653             scanCond(tree.cond);
2654             uninitsExit.andSet(uninitsWhenTrue);
2655             if (tree.detail != null) {
2656                 inits.assign(initsWhenFalse);
2657                 uninits.assign(uninitsWhenFalse);
2658                 scanExpr(tree.detail);
2659             }
2660             inits.assign(initsExit);
2661             uninits.assign(uninitsExit);
2662         }
2663 
2664         public void visitAssign(JCAssign tree) {
2665             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2666                 scanExpr(tree.lhs);
2667             scanExpr(tree.rhs);
2668             letInit(tree.lhs);
2669         }
2670 
2671         // check fields accessed through this.&lt;field&gt; are definitely
2672         // assigned before reading their value
2673         public void visitSelect(JCFieldAccess tree) {
2674             super.visitSelect(tree);
2675             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2676                 tree.sym.kind == VAR) {
2677                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2678             }
2679         }
2680 
2681         public void visitAssignop(JCAssignOp tree) {
2682             scanExpr(tree.lhs);
2683             scanExpr(tree.rhs);
2684             letInit(tree.lhs);
2685         }
2686 
2687         public void visitUnary(JCUnary tree) {
2688             switch (tree.getTag()) {
2689             case NOT:
2690                 scanCond(tree.arg);
2691                 final Bits t = new Bits(initsWhenFalse);
2692                 initsWhenFalse.assign(initsWhenTrue);
2693                 initsWhenTrue.assign(t);
2694                 t.assign(uninitsWhenFalse);
2695                 uninitsWhenFalse.assign(uninitsWhenTrue);
2696                 uninitsWhenTrue.assign(t);
2697                 break;
2698             case PREINC: case POSTINC:
2699             case PREDEC: case POSTDEC:
2700                 scanExpr(tree.arg);
2701                 letInit(tree.arg);
2702                 break;
2703             default:
2704                 scanExpr(tree.arg);
2705             }
2706         }
2707 
2708         public void visitBinary(JCBinary tree) {
2709             switch (tree.getTag()) {
2710             case AND:
2711                 scanCond(tree.lhs);
2712                 final Bits initsWhenFalseLeft = new Bits(initsWhenFalse);
2713                 final Bits uninitsWhenFalseLeft = new Bits(uninitsWhenFalse);
2714                 inits.assign(initsWhenTrue);
2715                 uninits.assign(uninitsWhenTrue);
2716                 scanCond(tree.rhs);
2717                 initsWhenFalse.andSet(initsWhenFalseLeft);
2718                 uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
2719                 break;
2720             case OR:
2721                 scanCond(tree.lhs);
2722                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2723                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2724                 inits.assign(initsWhenFalse);
2725                 uninits.assign(uninitsWhenFalse);
2726                 scanCond(tree.rhs);
2727                 initsWhenTrue.andSet(initsWhenTrueLeft);
2728                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2729                 break;
2730             default:
2731                 scanExpr(tree.lhs);
2732                 scanExpr(tree.rhs);
2733             }
2734         }
2735 
2736         public void visitIdent(JCIdent tree) {
2737             if (tree.sym.kind == VAR) {
2738                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2739                 referenced(tree.sym);
2740             }
2741         }
2742 
2743         void referenced(Symbol sym) {
2744             unrefdResources.remove(sym);
2745         }
2746 
2747         public void visitAnnotatedType(JCAnnotatedType tree) {
2748             // annotations don&#39;t get scanned
2749             tree.underlyingType.accept(this);
2750         }
2751 
2752         public void visitModuleDef(JCModuleDecl tree) {
2753             // Do nothing for modules
2754         }
2755 
2756     /**************************************************************************
2757      * main method
2758      *************************************************************************/
2759 
2760         /** Perform definite assignment/unassignment analysis on a tree.
2761          */
2762         public void analyzeTree(Env&lt;?&gt; env, TreeMaker make) {
2763             analyzeTree(env, env.tree, make);
2764          }
2765 
2766         public void analyzeTree(Env&lt;?&gt; env, JCTree tree, TreeMaker make) {
2767             try {
2768                 startPos = tree.pos().getStartPosition();
2769 
2770                 if (vardecls == null)
2771                     vardecls = new JCVariableDecl[32];
2772                 else
2773                     for (int i=0; i&lt;vardecls.length; i++)
2774                         vardecls[i] = null;
2775                 firstadr = 0;
2776                 nextadr = 0;
2777                 Flow.this.make = make;
2778                 pendingExits = new ListBuffer&lt;&gt;();
2779                 this.classDef = null;
2780                 unrefdResources = WriteableScope.create(env.enclClass.sym);
2781                 scan(tree);
2782             } finally {
2783                 // note that recursive invocations of this method fail hard
2784                 startPos = -1;
2785                 resetBits(inits, uninits, uninitsTry, initsWhenTrue,
2786                         initsWhenFalse, uninitsWhenTrue, uninitsWhenFalse);
2787                 if (vardecls != null) {
2788                     for (int i=0; i&lt;vardecls.length; i++)
2789                         vardecls[i] = null;
2790                 }
2791                 firstadr = 0;
2792                 nextadr = 0;
2793                 Flow.this.make = null;
2794                 pendingExits = null;
2795                 this.classDef = null;
2796                 unrefdResources = null;
2797             }
2798         }
2799     }
2800 
2801     /**
2802      * This pass implements the last step of the dataflow analysis, namely
2803      * the effectively-final analysis check. This checks that every local variable
2804      * reference from a lambda body/local inner class is either final or effectively final.
2805      * Additional this also checks that every variable that is used as an operand to
2806      * try-with-resources is final or effectively final.
2807      * As effectively final variables are marked as such during DA/DU, this pass must run after
2808      * AssignAnalyzer.
2809      */
2810     class CaptureAnalyzer extends BaseAnalyzer {
2811 
2812         JCTree currentTree; //local class or lambda
2813 
2814         @Override
2815         void markDead() {
2816             //do nothing
2817         }
2818 
2819         @SuppressWarnings(&quot;fallthrough&quot;)
2820         void checkEffectivelyFinal(DiagnosticPosition pos, VarSymbol sym) {
2821             if (currentTree != null &amp;&amp;
2822                     sym.owner.kind == MTH &amp;&amp;
2823                     sym.pos &lt; currentTree.getStartPosition()) {
2824                 switch (currentTree.getTag()) {
2825                     case CLASSDEF:
2826                         if (!allowEffectivelyFinalInInnerClasses) {
2827                             if ((sym.flags() &amp; FINAL) == 0) {
2828                                 reportInnerClsNeedsFinalError(pos, sym);
2829                             }
2830                             break;
2831                         }
2832                     case LAMBDA:
2833                         if ((sym.flags() &amp; (EFFECTIVELY_FINAL | FINAL)) == 0) {
2834                            reportEffectivelyFinalError(pos, sym);
2835                         }
2836                 }
2837             }
2838         }
2839 
2840         @SuppressWarnings(&quot;fallthrough&quot;)
2841         void letInit(JCTree tree) {
2842             tree = TreeInfo.skipParens(tree);
2843             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
2844                 Symbol sym = TreeInfo.symbol(tree);
2845                 if (currentTree != null &amp;&amp;
2846                         sym.kind == VAR &amp;&amp;
2847                         sym.owner.kind == MTH &amp;&amp;
2848                         ((VarSymbol)sym).pos &lt; currentTree.getStartPosition()) {
2849                     switch (currentTree.getTag()) {
2850                         case CLASSDEF:
2851                             if (!allowEffectivelyFinalInInnerClasses) {
2852                                 reportInnerClsNeedsFinalError(tree, sym);
2853                                 break;
2854                             }
2855                         case LAMBDA:
2856                             reportEffectivelyFinalError(tree, sym);
2857                     }
2858                 }
2859             }
2860         }
2861 
2862         void reportEffectivelyFinalError(DiagnosticPosition pos, Symbol sym) {
2863             String subKey = currentTree.hasTag(LAMBDA) ?
2864                   &quot;lambda&quot;  : &quot;inner.cls&quot;;
2865             log.error(pos, Errors.CantRefNonEffectivelyFinalVar(sym, diags.fragment(subKey)));
2866         }
2867 
2868         void reportInnerClsNeedsFinalError(DiagnosticPosition pos, Symbol sym) {
2869             log.error(pos,
2870                       Errors.LocalVarAccessedFromIclsNeedsFinal(sym));
2871         }
2872 
2873     /*************************************************************************
2874      * Visitor methods for statements and definitions
2875      *************************************************************************/
2876 
2877         /* ------------ Visitor methods for various sorts of trees -------------*/
2878 
2879         public void visitClassDef(JCClassDecl tree) {
2880             JCTree prevTree = currentTree;
2881             try {
2882                 currentTree = tree.sym.isLocal() ? tree : null;
2883                 super.visitClassDef(tree);
2884             } finally {
2885                 currentTree = prevTree;
2886             }
2887         }
2888 
2889         @Override
2890         public void visitLambda(JCLambda tree) {
2891             JCTree prevTree = currentTree;
2892             try {
2893                 currentTree = tree;
2894                 super.visitLambda(tree);
2895             } finally {
2896                 currentTree = prevTree;
2897             }
2898         }
2899 
2900         @Override
2901         public void visitIdent(JCIdent tree) {
2902             if (tree.sym.kind == VAR) {
2903                 checkEffectivelyFinal(tree, (VarSymbol)tree.sym);
2904             }
2905         }
2906 
2907         public void visitAssign(JCAssign tree) {
2908             JCTree lhs = TreeInfo.skipParens(tree.lhs);
2909             if (!(lhs instanceof JCIdent)) {
2910                 scan(lhs);
2911             }
2912             scan(tree.rhs);
2913             letInit(lhs);
2914         }
2915 
2916         public void visitAssignop(JCAssignOp tree) {
2917             scan(tree.lhs);
2918             scan(tree.rhs);
2919             letInit(tree.lhs);
2920         }
2921 
2922         public void visitUnary(JCUnary tree) {
2923             switch (tree.getTag()) {
2924                 case PREINC: case POSTINC:
2925                 case PREDEC: case POSTDEC:
2926                     scan(tree.arg);
2927                     letInit(tree.arg);
2928                     break;
2929                 default:
2930                     scan(tree.arg);
2931             }
2932         }
2933 
2934         public void visitTry(JCTry tree) {
2935             for (JCTree resource : tree.resources) {
2936                 if (!resource.hasTag(VARDEF)) {
2937                     Symbol var = TreeInfo.symbol(resource);
2938                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
2939                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
2940                     }
2941                 }
2942             }
2943             super.visitTry(tree);
2944         }
2945 
2946         @Override
2947         public void visitYield(JCYield tree) {
2948             scan(tree.value);
2949         }
2950 
2951         public void visitModuleDef(JCModuleDecl tree) {
2952             // Do nothing for modules
2953         }
2954 
2955     /**************************************************************************
2956      * main method
2957      *************************************************************************/
2958 
2959         /** Perform definite assignment/unassignment analysis on a tree.
2960          */
2961         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
2962             analyzeTree(env, env.tree, make);
2963         }
2964         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
2965             try {
2966                 attrEnv = env;
2967                 Flow.this.make = make;
2968                 pendingExits = new ListBuffer&lt;&gt;();
2969                 scan(tree);
2970             } finally {
2971                 pendingExits = null;
2972                 Flow.this.make = null;
2973             }
2974         }
2975     }
2976 
2977     enum Liveness {
2978         ALIVE {
2979             @Override
2980             public Liveness or(Liveness other) {
2981                 return this;
2982             }
2983             @Override
2984             public Liveness and(Liveness other) {
2985                 return other;
2986             }
2987         },
2988         DEAD {
2989             @Override
2990             public Liveness or(Liveness other) {
2991                 return other;
2992             }
2993             @Override
2994             public Liveness and(Liveness other) {
2995                 return this;
2996             }
2997         },
2998         RECOVERY {
2999             @Override
3000             public Liveness or(Liveness other) {
3001                 if (other == ALIVE) {
3002                     return ALIVE;
3003                 } else {
3004                     return this;
3005                 }
3006             }
3007             @Override
3008             public Liveness and(Liveness other) {
3009                 if (other == DEAD) {
3010                     return DEAD;
3011                 } else {
3012                     return this;
3013                 }
3014             }
3015         };
3016 
3017         public abstract Liveness or(Liveness other);
3018         public abstract Liveness and(Liveness other);
3019         public Liveness or(boolean value) {
3020             return or(from(value));
3021         }
3022         public Liveness and(boolean value) {
3023             return and(from(value));
3024         }
3025         public static Liveness from(boolean value) {
3026             return value ? ALIVE : DEAD;
3027         }
3028     }
3029 
3030 }
    </pre>
  </body>
</html>
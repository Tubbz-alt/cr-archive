<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LambdaToMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemberEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Lower.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
<span class="line-modified">  29 import java.util.Map.Entry;</span>
<span class="line-removed">  30 import java.util.function.Function;</span>
<span class="line-removed">  31 import java.util.stream.Stream;</span>
  32 
<span class="line-removed">  33 import com.sun.source.tree.CaseTree.CaseKind;</span>
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Kinds.KindSelector;
  36 import com.sun.tools.javac.code.Scope.WriteableScope;
  37 import com.sun.tools.javac.jvm.*;

  38 import com.sun.tools.javac.main.Option.PkgInfo;
  39 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  40 import com.sun.tools.javac.tree.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  43 import com.sun.tools.javac.util.List;
  44 
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;
  47 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.code.Type.*;
  50 
  51 import com.sun.tools.javac.jvm.Target;
  52 import com.sun.tools.javac.tree.EndPosTable;
  53 
  54 import static com.sun.tools.javac.code.Flags.*;
  55 import static com.sun.tools.javac.code.Flags.BLOCK;
  56 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  57 import static com.sun.tools.javac.code.TypeTag.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
<span class="line-removed">  59 import static com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode.DEREF;</span>
  60 import static com.sun.tools.javac.jvm.ByteCodes.*;
  61 import com.sun.tools.javac.tree.JCTree.JCBreak;
  62 import com.sun.tools.javac.tree.JCTree.JCCase;
  63 import com.sun.tools.javac.tree.JCTree.JCExpression;
  64 import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;
  65 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;
  66 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;
  67 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  68 
  69 /** This pass translates away some syntactic sugar: inner classes,
  70  *  class literals, assertions, foreach loops, etc.
  71  *
  72  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  73  *  If you write code that depends on this, you do so at your own risk.
  74  *  This code and its internal interfaces are subject to change or
  75  *  deletion without notice.&lt;/b&gt;
  76  */
  77 public class Lower extends TreeTranslator {
  78     protected static final Context.Key&lt;Lower&gt; lowerKey = new Context.Key&lt;&gt;();
  79 
  80     public static Lower instance(Context context) {
  81         Lower instance = context.get(lowerKey);
  82         if (instance == null)
  83             instance = new Lower(context);
  84         return instance;
  85     }
  86 
  87     private final Names names;
  88     private final Log log;
  89     private final Symtab syms;
  90     private final Resolve rs;
  91     private final Operators operators;
  92     private final Check chk;
  93     private final Attr attr;
  94     private TreeMaker make;
  95     private DiagnosticPosition make_pos;
<span class="line-removed">  96     private final ClassWriter writer;</span>
  97     private final ConstFold cfolder;
  98     private final Target target;
  99     private final Source source;
 100     private final TypeEnvs typeEnvs;
 101     private final Name dollarAssertionsDisabled;
 102     private final Name classDollar;
 103     private final Name dollarCloseResource;
 104     private final Types types;
 105     private final boolean debugLower;
 106     private final boolean disableProtectedAccessors; // experimental
 107     private final PkgInfo pkginfoOpt;
 108 
 109     protected Lower(Context context) {
 110         context.put(lowerKey, this);
 111         names = Names.instance(context);
 112         log = Log.instance(context);
 113         syms = Symtab.instance(context);
 114         rs = Resolve.instance(context);
 115         operators = Operators.instance(context);
 116         chk = Check.instance(context);
 117         attr = Attr.instance(context);
 118         make = TreeMaker.instance(context);
<span class="line-removed"> 119         writer = ClassWriter.instance(context);</span>
 120         cfolder = ConstFold.instance(context);
 121         target = Target.instance(context);
 122         source = Source.instance(context);
 123         typeEnvs = TypeEnvs.instance(context);
 124         dollarAssertionsDisabled = names.
 125             fromString(target.syntheticNameChar() + &quot;assertionsDisabled&quot;);
 126         classDollar = names.
 127             fromString(&quot;class&quot; + target.syntheticNameChar());
 128         dollarCloseResource = names.
 129             fromString(target.syntheticNameChar() + &quot;closeResource&quot;);
 130 
 131         types = Types.instance(context);
 132         Options options = Options.instance(context);
 133         debugLower = options.isSet(&quot;debuglower&quot;);
 134         pkginfoOpt = PkgInfo.get(options);
 135         disableProtectedAccessors = options.isSet(&quot;disableProtectedAccessors&quot;);
 136     }
 137 
 138     /** The currently enclosing class.
 139      */
</pre>
<hr />
<pre>
 257         /** If tree refers to a class instance creation expression
 258          *  add all free variables of the freshly created class.
 259          */
 260         public void visitNewClass(JCNewClass tree) {
 261             ClassSymbol c = (ClassSymbol)tree.constructor.owner;
 262             addFreeVars(c);
 263             super.visitNewClass(tree);
 264         }
 265 
 266         /** If tree refers to a superclass constructor call,
 267          *  add all free variables of the superclass.
 268          */
 269         public void visitApply(JCMethodInvocation tree) {
 270             if (TreeInfo.name(tree.meth) == names._super) {
 271                 addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);
 272             }
 273             super.visitApply(tree);
 274         }
 275 
 276         @Override
<span class="line-modified"> 277         public void visitBreak(JCBreak tree) {</span>
<span class="line-modified"> 278             if (tree.isValueBreak())</span>
<span class="line-removed"> 279                 scan(tree.value);</span>
 280         }
 281 
 282     }
 283 
 284     /**
 285      * Lower-specific subclass of {@code BasicFreeVarCollector}.
 286      */
 287     class FreeVarCollector extends BasicFreeVarCollector {
 288 
 289         /** The owner of the local class.
 290          */
 291         Symbol owner;
 292 
 293         /** The local class.
 294          */
 295         ClassSymbol clazz;
 296 
 297         /** The list of owner&#39;s variables accessed from within the local class,
 298          *  without any duplicates.
 299          */
</pre>
<hr />
<pre>
 458      *  &lt;pre&gt;
 459      *          class Outer$0 {
 460      *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 461      *              static {
 462      *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 463      *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 464      *              }
 465      *          }
 466      *  &lt;/pre&gt;
 467      *  class EnumMapping provides mapping data and support methods for this translation.
 468      */
 469     class EnumMapping {
 470         EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {
 471             this.forEnum = forEnum;
 472             this.values = new LinkedHashMap&lt;&gt;();
 473             this.pos = pos;
 474             Name varName = names
 475                 .fromString(target.syntheticNameChar() +
 476                             &quot;SwitchMap&quot; +
 477                             target.syntheticNameChar() +
<span class="line-modified"> 478                             writer.xClassName(forEnum.type).toString()</span>
 479                             .replace(&#39;/&#39;, &#39;.&#39;)
 480                             .replace(&#39;.&#39;, target.syntheticNameChar()));
 481             ClassSymbol outerCacheClass = outerCacheClass();
 482             this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,
 483                                         varName,
 484                                         new ArrayType(syms.intType, syms.arrayClass),
 485                                         outerCacheClass);
 486             enterSynthetic(pos, mapVar, outerCacheClass.members());
 487         }
 488 
 489         DiagnosticPosition pos = null;
 490 
 491         // the next value to use
 492         int next = 1; // 0 (unused map elements) go to the default label
 493 
 494         // the enum for which this is a map
 495         final TypeSymbol forEnum;
 496 
 497         // the field containing the map
 498         final VarSymbol mapVar;
</pre>
<hr />
<pre>
 790         }
 791     };
 792 
 793     /** Look up a synthetic name in a given scope.
 794      *  @param s            The scope.
 795      *  @param name         The name.
 796      */
 797     private Symbol lookupSynthetic(Name name, Scope s) {
 798         Symbol sym = s.findFirst(name);
 799         return (sym==null || (sym.flags()&amp;SYNTHETIC)==0) ? null : sym;
 800     }
 801 
 802     /** Look up a method in a given scope.
 803      */
 804     private MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List&lt;Type&gt; args) {
 805         return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());
 806     }
 807 
 808     /** Anon inner classes are used as access constructor tags.
 809      * accessConstructorTag will use an existing anon class if one is available,
<span class="line-modified"> 810      * and synthethise a class (with makeEmptyClass) if one is not available.</span>
 811      * However, there is a small possibility that an existing class will not
 812      * be generated as expected if it is inside a conditional with a constant
 813      * expression. If that is found to be the case, create an empty class tree here.
 814      */
 815     private void checkAccessConstructorTags() {
 816         for (List&lt;ClassSymbol&gt; l = accessConstrTags; l.nonEmpty(); l = l.tail) {
 817             ClassSymbol c = l.head;
 818             if (isTranslatedClassAvailable(c))
 819                 continue;
 820             // Create class definition tree.
 821             JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,
 822                     c.outermostClass(), c.flatname, false);
 823             swapAccessConstructorTag(c, cdec.sym);
 824             translated.append(cdec);
 825         }
 826     }
 827     // where
 828     private boolean isTranslatedClassAvailable(ClassSymbol c) {
 829         for (JCTree tree: translated) {
 830             if (tree.hasTag(CLASSDEF)
</pre>
<hr />
<pre>
1326      */
1327     JCTree accessDef(int pos, Symbol vsym, MethodSymbol accessor, int acode) {
1328 //      System.err.println(&quot;access &quot; + vsym + &quot; with &quot; + accessor);//DEBUG
1329         currentClass = vsym.owner.enclClass();
1330         make.at(pos);
1331         JCMethodDecl md = make.MethodDef(accessor, null);
1332 
1333         // Find actual symbol
1334         Symbol sym = actualSymbols.get(vsym);
1335         if (sym == null) sym = vsym;
1336 
1337         JCExpression ref;           // The tree referencing the private symbol.
1338         List&lt;JCExpression&gt; args;    // Any additional arguments to be passed along.
1339         if ((sym.flags() &amp; STATIC) != 0) {
1340             ref = make.Ident(sym);
1341             args = make.Idents(md.params);
1342         } else {
1343             JCExpression site = make.Ident(md.params.head);
1344             if (acode % 2 != 0) {
1345                 //odd access codes represent qualified super accesses - need to
<span class="line-modified">1346                 //emit reference to the direct superclass, even if the refered</span>
1347                 //member is from an indirect superclass (JLS 13.1)
1348                 site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));
1349             }
1350             ref = make.Select(site, sym);
1351             args = make.Idents(md.params.tail);
1352         }
1353         JCStatement stat;          // The statement accessing the private symbol.
1354         if (sym.kind == VAR) {
1355             // Normalize out all odd access codes by taking floor modulo 2:
1356             int acode1 = acode - (acode &amp; 1);
1357 
1358             JCExpression expr;      // The access method&#39;s return value.
1359             AccessCode aCode = AccessCode.getFromCode(acode1);
1360             switch (aCode) {
1361             case DEREF:
1362                 expr = ref;
1363                 break;
1364             case ASSIGN:
1365                 expr = make.Assign(ref, args.head);
1366                 break;
</pre>
<hr />
<pre>
1872         Symbol funcsym = lookupMethod(make_pos, name, left.type,
1873                                       TreeInfo.types(args));
1874         return make.App(make.Select(left, funcsym), args);
1875     }
1876 
1877     /** The tree simulating a T.class expression.
1878      *  @param clazz      The tree identifying type T.
1879      */
1880     private JCExpression classOf(JCTree clazz) {
1881         return classOfType(clazz.type, clazz.pos());
1882     }
1883 
1884     private JCExpression classOfType(Type type, DiagnosticPosition pos) {
1885         switch (type.getTag()) {
1886         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1887         case DOUBLE: case BOOLEAN: case VOID:
1888             // replace with &lt;BoxedClass&gt;.TYPE
1889             ClassSymbol c = types.boxedClass(type);
1890             Symbol typeSym =
1891                 rs.accessBase(
<span class="line-modified">1892                     rs.findIdentInType(attrEnv, c.type, names.TYPE, KindSelector.VAR),</span>
1893                     pos, c.type, names.TYPE, true);
1894             if (typeSym.kind == VAR)
1895                 ((VarSymbol)typeSym).getConstValue(); // ensure initializer is evaluated
1896             return make.QualIdent(typeSym);
1897         case CLASS: case ARRAY:
1898                 VarSymbol sym = new VarSymbol(
1899                         STATIC | PUBLIC | FINAL, names._class,
1900                         syms.classType, type.tsym);
1901                 return make_at(pos).Select(make.Type(type), sym);
1902         default:
1903             throw new AssertionError();
1904         }
1905     }
1906 
1907 /**************************************************************************
1908  * Code for enabling/disabling assertions.
1909  *************************************************************************/
1910 
1911     private ClassSymbol assertionsDisabledClassCache;
1912 
</pre>
<hr />
<pre>
2174         ClassSymbol currentClassPrev = currentClass;
2175         MethodSymbol currentMethodSymPrev = currentMethodSym;
2176 
2177         currentClass = tree.sym;
2178         currentMethodSym = null;
2179         attrEnv = typeEnvs.remove(currentClass);
2180         if (attrEnv == null)
2181             attrEnv = prevEnv;
2182 
2183         classdefs.put(currentClass, tree);
2184 
2185         Map&lt;Symbol, Symbol&gt; prevProxies = proxies;
2186         proxies = new HashMap&lt;&gt;(proxies);
2187         List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;
2188 
2189         // If this is an enum definition
2190         if ((tree.mods.flags &amp; ENUM) != 0 &amp;&amp;
2191             (types.supertype(currentClass.type).tsym.flags() &amp; ENUM) == 0)
2192             visitEnumDef(tree);
2193 




2194         // If this is a nested class, define a this$n field for
2195         // it and add to proxies.
2196         JCVariableDecl otdef = null;
2197         if (currentClass.hasOuterInstance())
2198             otdef = outerThisDef(tree.pos, currentClass);
2199 
2200         // If this is a local class, define proxies for all its free variables.
2201         List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(
2202             tree.pos, freevars(currentClass), currentClass);
2203 
2204         // Recursively translate superclass, interfaces.
2205         tree.extending = translate(tree.extending);
2206         tree.implementing = translate(tree.implementing);
2207 
2208         if (currentClass.isLocal()) {
2209             ClassSymbol encl = currentClass.owner.enclClass();
2210             if (encl.trans_local == null) {
2211                 encl.trans_local = List.nil();
2212             }
2213             encl.trans_local = encl.trans_local.prepend(currentClass);
</pre>
<hr />
<pre>
2243         }
2244         if (currentClass.hasOuterInstance()) {
2245             tree.defs = tree.defs.prepend(otdef);
2246             enterSynthetic(tree.pos(), otdef.sym, currentClass.members());
2247         }
2248 
2249         proxies = prevProxies;
2250         outerThisStack = prevOuterThisStack;
2251 
2252         // Append translated tree to `translated&#39; queue.
2253         translated.append(tree);
2254 
2255         attrEnv = prevEnv;
2256         currentClass = currentClassPrev;
2257         currentMethodSym = currentMethodSymPrev;
2258 
2259         // Return empty block {} as a placeholder for an inner class.
2260         result = make_at(tree.pos()).Block(SYNTHETIC, List.nil());
2261     }
2262 













2263     /** Translate an enum class. */
2264     private void visitEnumDef(JCClassDecl tree) {
2265         make_at(tree.pos());
2266 
2267         // add the supertype, if needed
2268         if (tree.extending == null)
2269             tree.extending = make.Type(types.supertype(tree.type));
2270 
2271         // classOfType adds a cache field to tree.defs
2272         JCExpression e_class = classOfType(tree.sym.type, tree.pos()).
2273             setType(types.erasure(syms.classType));
2274 
2275         // process each enumeration constant, adding implicit constructor parameters
2276         int nextOrdinal = 0;
2277         ListBuffer&lt;JCExpression&gt; values = new ListBuffer&lt;&gt;();
2278         ListBuffer&lt;JCTree&gt; enumDefs = new ListBuffer&lt;&gt;();
2279         ListBuffer&lt;JCTree&gt; otherDefs = new ListBuffer&lt;&gt;();
2280         for (List&lt;JCTree&gt; defs = tree.defs;
2281              defs.nonEmpty();
2282              defs=defs.tail) {
</pre>
<hr />
<pre>
2398     }
2399         // where
2400         private MethodSymbol systemArraycopyMethod;
2401         private boolean useClone() {
2402             try {
2403                 return syms.objectType.tsym.members().findFirst(names.clone) != null;
2404             }
2405             catch (CompletionFailure e) {
2406                 return false;
2407             }
2408         }
2409 
2410     /** Translate an enumeration constant and its initializer. */
2411     private void visitEnumConstantDef(JCVariableDecl var, int ordinal) {
2412         JCNewClass varDef = (JCNewClass)var.init;
2413         varDef.args = varDef.args.
2414             prepend(makeLit(syms.intType, ordinal)).
2415             prepend(makeLit(syms.stringType, var.name.toString()));
2416     }
2417 













































































































































































2418     public void visitMethodDef(JCMethodDecl tree) {
2419         if (tree.name == names.init &amp;&amp; (currentClass.flags_field&amp;ENUM) != 0) {
2420             // Add &quot;String $enum$name, int $enum$ordinal&quot; to the beginning of the
2421             // argument list for each constructor of an enum.
2422             JCVariableDecl nameParam = make_at(tree.pos()).
2423                 Param(names.fromString(target.syntheticNameChar() +
2424                                        &quot;enum&quot; + target.syntheticNameChar() + &quot;name&quot;),
2425                       syms.stringType, tree.sym);
2426             nameParam.mods.flags |= SYNTHETIC; nameParam.sym.flags_field |= SYNTHETIC;
2427             JCVariableDecl ordParam = make.
2428                 Param(names.fromString(target.syntheticNameChar() +
2429                                        &quot;enum&quot; + target.syntheticNameChar() +
2430                                        &quot;ordinal&quot;),
2431                       syms.intType, tree.sym);
2432             ordParam.mods.flags |= SYNTHETIC; ordParam.sym.flags_field |= SYNTHETIC;
2433 
2434             MethodSymbol m = tree.sym;
2435             tree.params = tree.params.prepend(ordParam).prepend(nameParam);
2436 
2437             m.extraParams = m.extraParams.prepend(ordParam.sym);
</pre>
<hr />
<pre>
2525             // pop local variables from proxy stack
2526             proxies = prevProxies;
2527 
2528             // recursively translate following local statements and
2529             // combine with this- or super-call
2530             List&lt;JCStatement&gt; stats = translate(tree.body.stats.tail);
2531             tree.body.stats = stats.prepend(selfCall).prependList(added);
2532             outerThisStack = prevOuterThisStack;
2533         } else {
2534             Map&lt;Symbol, Symbol&gt; prevLambdaTranslationMap =
2535                     lambdaTranslationMap;
2536             try {
2537                 lambdaTranslationMap = (tree.sym.flags() &amp; SYNTHETIC) != 0 &amp;&amp;
2538                         tree.sym.name.startsWith(names.lambda) ?
2539                         makeTranslationMap(tree) : null;
2540                 super.visitMethodDef(tree);
2541             } finally {
2542                 lambdaTranslationMap = prevLambdaTranslationMap;
2543             }
2544         }





















2545         result = tree;
2546     }
2547     //where
2548         private Map&lt;Symbol, Symbol&gt; makeTranslationMap(JCMethodDecl tree) {
2549             Map&lt;Symbol, Symbol&gt; translationMap = new HashMap&lt;&gt;();
2550             for (JCVariableDecl vd : tree.params) {
2551                 Symbol p = vd.sym;
2552                 if (p != p.baseSymbol()) {
2553                     translationMap.put(p.baseSymbol(), p);
2554                 }
2555             }
2556             return translationMap;
2557         }
2558 
2559     public void visitTypeCast(JCTypeCast tree) {
2560         tree.clazz = translate(tree.clazz);
2561         if (tree.type.isPrimitive() != tree.expr.type.isPrimitive())
2562             tree.expr = translate(tree.expr, tree.type);
2563         else
2564             tree.expr = translate(tree.expr);
</pre>
<hr />
<pre>
3209                                                   tree.var.vartype,
3210                                                   loopvarinit).setType(tree.var.type);
3211             loopvardef.sym = tree.var.sym;
3212             JCBlock body = make.
3213                 Block(0, List.of(loopvardef, tree.body));
3214 
3215             result = translate(make.
3216                                ForLoop(loopinit,
3217                                        cond,
3218                                        List.of(step),
3219                                        body));
3220             patchTargets(body, tree, result);
3221         }
3222         /** Patch up break and continue targets. */
3223         private void patchTargets(JCTree body, final JCTree src, final JCTree dest) {
3224             class Patcher extends TreeScanner {
3225                 public void visitBreak(JCBreak tree) {
3226                     if (tree.target == src)
3227                         tree.target = dest;
3228                 }





3229                 public void visitContinue(JCContinue tree) {
3230                     if (tree.target == src)
3231                         tree.target = dest;
3232                 }
3233                 public void visitClassDef(JCClassDecl tree) {}
3234             }
3235             new Patcher().scan(body);
3236         }
3237         /**
3238          * A statement of the form
3239          *
3240          * &lt;pre&gt;
3241          *     for ( T v : coll ) stmt ;
3242          * &lt;/pre&gt;
3243          *
3244          * (where coll implements {@code Iterable&lt;? extends T&gt;}) gets translated to
3245          *
3246          * &lt;pre&gt;{@code
3247          *     for ( Iterator&lt;? extends T&gt; #i = coll.iterator(); #i.hasNext(); ) {
3248          *         T v = (T) #i.next();
</pre>
<hr />
<pre>
3661                 JCSwitchExpression switch2 = make.SwitchExpression(make.Ident(dollar_tmp), lb.toList());
3662 
3663                 // Rewire up old unlabeled break statements to the
3664                 // replacement switch being created.
3665                 patchTargets(switch2, tree, switch2);
3666 
3667                 switch2.setType(tree.type);
3668 
3669                 LetExpr res = make.LetExpr(stmtList.toList(), switch2);
3670 
3671                 res.needsCond = true;
3672                 res.setType(tree.type);
3673 
3674                 return res;
3675             }
3676         }
3677     }
3678 
3679     @Override
3680     public void visitBreak(JCBreak tree) {
<span class="line-modified">3681         if (tree.isValueBreak()) {</span>
<span class="line-modified">3682             tree.value = translate(tree.value, tree.target.type);</span>
<span class="line-modified">3683         }</span>



3684         result = tree;
3685     }
3686 
3687     public void visitNewArray(JCNewArray tree) {
3688         tree.elemtype = translate(tree.elemtype);
3689         for (List&lt;JCExpression&gt; t = tree.dims; t.tail != null; t = t.tail)
3690             if (t.head != null) t.head = translate(t.head, syms.intType);
3691         tree.elems = translate(tree.elems, types.elemtype(tree.type));
3692         result = tree;
3693     }
3694 
3695     public void visitSelect(JCFieldAccess tree) {
3696         // need to special case-access of the form C.super.x
3697         // these will always need an access method, unless C
3698         // is a default interface subclassed by the current class.
3699         boolean qualifiedSuperAccess =
3700             tree.selected.hasTag(SELECT) &amp;&amp;
3701             TreeInfo.name(tree.selected) == names._super &amp;&amp;
3702             !types.isDirectSuperInterface(((JCFieldAccess)tree.selected).selected.type.tsym, currentClass);
3703         tree.selected = translate(tree.selected);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
<span class="line-modified">  29 import java.util.stream.Collectors;</span>


  30 

  31 import com.sun.tools.javac.code.*;
  32 import com.sun.tools.javac.code.Kinds.KindSelector;
  33 import com.sun.tools.javac.code.Scope.WriteableScope;
  34 import com.sun.tools.javac.jvm.*;
<span class="line-added">  35 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
  36 import com.sun.tools.javac.main.Option.PkgInfo;
  37 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  38 import com.sun.tools.javac.tree.*;
  39 import com.sun.tools.javac.util.*;
  40 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  41 import com.sun.tools.javac.util.List;
  42 
  43 import com.sun.tools.javac.code.Symbol.*;
  44 import com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode;
  45 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  46 import com.sun.tools.javac.tree.JCTree.*;
  47 import com.sun.tools.javac.code.Type.*;
  48 
  49 import com.sun.tools.javac.jvm.Target;
  50 import com.sun.tools.javac.tree.EndPosTable;
  51 
  52 import static com.sun.tools.javac.code.Flags.*;
  53 import static com.sun.tools.javac.code.Flags.BLOCK;
  54 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  55 import static com.sun.tools.javac.code.TypeTag.*;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;

  57 import static com.sun.tools.javac.jvm.ByteCodes.*;
  58 import com.sun.tools.javac.tree.JCTree.JCBreak;
  59 import com.sun.tools.javac.tree.JCTree.JCCase;
  60 import com.sun.tools.javac.tree.JCTree.JCExpression;
  61 import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;
  62 import static com.sun.tools.javac.tree.JCTree.JCOperatorExpression.OperandPos.LEFT;
  63 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;
  64 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  65 
  66 /** This pass translates away some syntactic sugar: inner classes,
  67  *  class literals, assertions, foreach loops, etc.
  68  *
  69  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  70  *  If you write code that depends on this, you do so at your own risk.
  71  *  This code and its internal interfaces are subject to change or
  72  *  deletion without notice.&lt;/b&gt;
  73  */
  74 public class Lower extends TreeTranslator {
  75     protected static final Context.Key&lt;Lower&gt; lowerKey = new Context.Key&lt;&gt;();
  76 
  77     public static Lower instance(Context context) {
  78         Lower instance = context.get(lowerKey);
  79         if (instance == null)
  80             instance = new Lower(context);
  81         return instance;
  82     }
  83 
  84     private final Names names;
  85     private final Log log;
  86     private final Symtab syms;
  87     private final Resolve rs;
  88     private final Operators operators;
  89     private final Check chk;
  90     private final Attr attr;
  91     private TreeMaker make;
  92     private DiagnosticPosition make_pos;

  93     private final ConstFold cfolder;
  94     private final Target target;
  95     private final Source source;
  96     private final TypeEnvs typeEnvs;
  97     private final Name dollarAssertionsDisabled;
  98     private final Name classDollar;
  99     private final Name dollarCloseResource;
 100     private final Types types;
 101     private final boolean debugLower;
 102     private final boolean disableProtectedAccessors; // experimental
 103     private final PkgInfo pkginfoOpt;
 104 
 105     protected Lower(Context context) {
 106         context.put(lowerKey, this);
 107         names = Names.instance(context);
 108         log = Log.instance(context);
 109         syms = Symtab.instance(context);
 110         rs = Resolve.instance(context);
 111         operators = Operators.instance(context);
 112         chk = Check.instance(context);
 113         attr = Attr.instance(context);
 114         make = TreeMaker.instance(context);

 115         cfolder = ConstFold.instance(context);
 116         target = Target.instance(context);
 117         source = Source.instance(context);
 118         typeEnvs = TypeEnvs.instance(context);
 119         dollarAssertionsDisabled = names.
 120             fromString(target.syntheticNameChar() + &quot;assertionsDisabled&quot;);
 121         classDollar = names.
 122             fromString(&quot;class&quot; + target.syntheticNameChar());
 123         dollarCloseResource = names.
 124             fromString(target.syntheticNameChar() + &quot;closeResource&quot;);
 125 
 126         types = Types.instance(context);
 127         Options options = Options.instance(context);
 128         debugLower = options.isSet(&quot;debuglower&quot;);
 129         pkginfoOpt = PkgInfo.get(options);
 130         disableProtectedAccessors = options.isSet(&quot;disableProtectedAccessors&quot;);
 131     }
 132 
 133     /** The currently enclosing class.
 134      */
</pre>
<hr />
<pre>
 252         /** If tree refers to a class instance creation expression
 253          *  add all free variables of the freshly created class.
 254          */
 255         public void visitNewClass(JCNewClass tree) {
 256             ClassSymbol c = (ClassSymbol)tree.constructor.owner;
 257             addFreeVars(c);
 258             super.visitNewClass(tree);
 259         }
 260 
 261         /** If tree refers to a superclass constructor call,
 262          *  add all free variables of the superclass.
 263          */
 264         public void visitApply(JCMethodInvocation tree) {
 265             if (TreeInfo.name(tree.meth) == names._super) {
 266                 addFreeVars((ClassSymbol) TreeInfo.symbol(tree.meth).owner);
 267             }
 268             super.visitApply(tree);
 269         }
 270 
 271         @Override
<span class="line-modified"> 272         public void visitYield(JCYield tree) {</span>
<span class="line-modified"> 273             scan(tree.value);</span>

 274         }
 275 
 276     }
 277 
 278     /**
 279      * Lower-specific subclass of {@code BasicFreeVarCollector}.
 280      */
 281     class FreeVarCollector extends BasicFreeVarCollector {
 282 
 283         /** The owner of the local class.
 284          */
 285         Symbol owner;
 286 
 287         /** The local class.
 288          */
 289         ClassSymbol clazz;
 290 
 291         /** The list of owner&#39;s variables accessed from within the local class,
 292          *  without any duplicates.
 293          */
</pre>
<hr />
<pre>
 452      *  &lt;pre&gt;
 453      *          class Outer$0 {
 454      *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 455      *              static {
 456      *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 457      *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 458      *              }
 459      *          }
 460      *  &lt;/pre&gt;
 461      *  class EnumMapping provides mapping data and support methods for this translation.
 462      */
 463     class EnumMapping {
 464         EnumMapping(DiagnosticPosition pos, TypeSymbol forEnum) {
 465             this.forEnum = forEnum;
 466             this.values = new LinkedHashMap&lt;&gt;();
 467             this.pos = pos;
 468             Name varName = names
 469                 .fromString(target.syntheticNameChar() +
 470                             &quot;SwitchMap&quot; +
 471                             target.syntheticNameChar() +
<span class="line-modified"> 472                             names.fromUtf(ClassWriter.externalize(forEnum.type.tsym.flatName())).toString()</span>
 473                             .replace(&#39;/&#39;, &#39;.&#39;)
 474                             .replace(&#39;.&#39;, target.syntheticNameChar()));
 475             ClassSymbol outerCacheClass = outerCacheClass();
 476             this.mapVar = new VarSymbol(STATIC | SYNTHETIC | FINAL,
 477                                         varName,
 478                                         new ArrayType(syms.intType, syms.arrayClass),
 479                                         outerCacheClass);
 480             enterSynthetic(pos, mapVar, outerCacheClass.members());
 481         }
 482 
 483         DiagnosticPosition pos = null;
 484 
 485         // the next value to use
 486         int next = 1; // 0 (unused map elements) go to the default label
 487 
 488         // the enum for which this is a map
 489         final TypeSymbol forEnum;
 490 
 491         // the field containing the map
 492         final VarSymbol mapVar;
</pre>
<hr />
<pre>
 784         }
 785     };
 786 
 787     /** Look up a synthetic name in a given scope.
 788      *  @param s            The scope.
 789      *  @param name         The name.
 790      */
 791     private Symbol lookupSynthetic(Name name, Scope s) {
 792         Symbol sym = s.findFirst(name);
 793         return (sym==null || (sym.flags()&amp;SYNTHETIC)==0) ? null : sym;
 794     }
 795 
 796     /** Look up a method in a given scope.
 797      */
 798     private MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List&lt;Type&gt; args) {
 799         return rs.resolveInternalMethod(pos, attrEnv, qual, name, args, List.nil());
 800     }
 801 
 802     /** Anon inner classes are used as access constructor tags.
 803      * accessConstructorTag will use an existing anon class if one is available,
<span class="line-modified"> 804      * and synthesize a class (with makeEmptyClass) if one is not available.</span>
 805      * However, there is a small possibility that an existing class will not
 806      * be generated as expected if it is inside a conditional with a constant
 807      * expression. If that is found to be the case, create an empty class tree here.
 808      */
 809     private void checkAccessConstructorTags() {
 810         for (List&lt;ClassSymbol&gt; l = accessConstrTags; l.nonEmpty(); l = l.tail) {
 811             ClassSymbol c = l.head;
 812             if (isTranslatedClassAvailable(c))
 813                 continue;
 814             // Create class definition tree.
 815             JCClassDecl cdec = makeEmptyClass(STATIC | SYNTHETIC,
 816                     c.outermostClass(), c.flatname, false);
 817             swapAccessConstructorTag(c, cdec.sym);
 818             translated.append(cdec);
 819         }
 820     }
 821     // where
 822     private boolean isTranslatedClassAvailable(ClassSymbol c) {
 823         for (JCTree tree: translated) {
 824             if (tree.hasTag(CLASSDEF)
</pre>
<hr />
<pre>
1320      */
1321     JCTree accessDef(int pos, Symbol vsym, MethodSymbol accessor, int acode) {
1322 //      System.err.println(&quot;access &quot; + vsym + &quot; with &quot; + accessor);//DEBUG
1323         currentClass = vsym.owner.enclClass();
1324         make.at(pos);
1325         JCMethodDecl md = make.MethodDef(accessor, null);
1326 
1327         // Find actual symbol
1328         Symbol sym = actualSymbols.get(vsym);
1329         if (sym == null) sym = vsym;
1330 
1331         JCExpression ref;           // The tree referencing the private symbol.
1332         List&lt;JCExpression&gt; args;    // Any additional arguments to be passed along.
1333         if ((sym.flags() &amp; STATIC) != 0) {
1334             ref = make.Ident(sym);
1335             args = make.Idents(md.params);
1336         } else {
1337             JCExpression site = make.Ident(md.params.head);
1338             if (acode % 2 != 0) {
1339                 //odd access codes represent qualified super accesses - need to
<span class="line-modified">1340                 //emit reference to the direct superclass, even if the referred</span>
1341                 //member is from an indirect superclass (JLS 13.1)
1342                 site.setType(types.erasure(types.supertype(vsym.owner.enclClass().type)));
1343             }
1344             ref = make.Select(site, sym);
1345             args = make.Idents(md.params.tail);
1346         }
1347         JCStatement stat;          // The statement accessing the private symbol.
1348         if (sym.kind == VAR) {
1349             // Normalize out all odd access codes by taking floor modulo 2:
1350             int acode1 = acode - (acode &amp; 1);
1351 
1352             JCExpression expr;      // The access method&#39;s return value.
1353             AccessCode aCode = AccessCode.getFromCode(acode1);
1354             switch (aCode) {
1355             case DEREF:
1356                 expr = ref;
1357                 break;
1358             case ASSIGN:
1359                 expr = make.Assign(ref, args.head);
1360                 break;
</pre>
<hr />
<pre>
1866         Symbol funcsym = lookupMethod(make_pos, name, left.type,
1867                                       TreeInfo.types(args));
1868         return make.App(make.Select(left, funcsym), args);
1869     }
1870 
1871     /** The tree simulating a T.class expression.
1872      *  @param clazz      The tree identifying type T.
1873      */
1874     private JCExpression classOf(JCTree clazz) {
1875         return classOfType(clazz.type, clazz.pos());
1876     }
1877 
1878     private JCExpression classOfType(Type type, DiagnosticPosition pos) {
1879         switch (type.getTag()) {
1880         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1881         case DOUBLE: case BOOLEAN: case VOID:
1882             // replace with &lt;BoxedClass&gt;.TYPE
1883             ClassSymbol c = types.boxedClass(type);
1884             Symbol typeSym =
1885                 rs.accessBase(
<span class="line-modified">1886                     rs.findIdentInType(pos, attrEnv, c.type, names.TYPE, KindSelector.VAR),</span>
1887                     pos, c.type, names.TYPE, true);
1888             if (typeSym.kind == VAR)
1889                 ((VarSymbol)typeSym).getConstValue(); // ensure initializer is evaluated
1890             return make.QualIdent(typeSym);
1891         case CLASS: case ARRAY:
1892                 VarSymbol sym = new VarSymbol(
1893                         STATIC | PUBLIC | FINAL, names._class,
1894                         syms.classType, type.tsym);
1895                 return make_at(pos).Select(make.Type(type), sym);
1896         default:
1897             throw new AssertionError();
1898         }
1899     }
1900 
1901 /**************************************************************************
1902  * Code for enabling/disabling assertions.
1903  *************************************************************************/
1904 
1905     private ClassSymbol assertionsDisabledClassCache;
1906 
</pre>
<hr />
<pre>
2168         ClassSymbol currentClassPrev = currentClass;
2169         MethodSymbol currentMethodSymPrev = currentMethodSym;
2170 
2171         currentClass = tree.sym;
2172         currentMethodSym = null;
2173         attrEnv = typeEnvs.remove(currentClass);
2174         if (attrEnv == null)
2175             attrEnv = prevEnv;
2176 
2177         classdefs.put(currentClass, tree);
2178 
2179         Map&lt;Symbol, Symbol&gt; prevProxies = proxies;
2180         proxies = new HashMap&lt;&gt;(proxies);
2181         List&lt;VarSymbol&gt; prevOuterThisStack = outerThisStack;
2182 
2183         // If this is an enum definition
2184         if ((tree.mods.flags &amp; ENUM) != 0 &amp;&amp;
2185             (types.supertype(currentClass.type).tsym.flags() &amp; ENUM) == 0)
2186             visitEnumDef(tree);
2187 
<span class="line-added">2188         if ((tree.mods.flags &amp; RECORD) != 0) {</span>
<span class="line-added">2189             visitRecordDef(tree);</span>
<span class="line-added">2190         }</span>
<span class="line-added">2191 </span>
2192         // If this is a nested class, define a this$n field for
2193         // it and add to proxies.
2194         JCVariableDecl otdef = null;
2195         if (currentClass.hasOuterInstance())
2196             otdef = outerThisDef(tree.pos, currentClass);
2197 
2198         // If this is a local class, define proxies for all its free variables.
2199         List&lt;JCVariableDecl&gt; fvdefs = freevarDefs(
2200             tree.pos, freevars(currentClass), currentClass);
2201 
2202         // Recursively translate superclass, interfaces.
2203         tree.extending = translate(tree.extending);
2204         tree.implementing = translate(tree.implementing);
2205 
2206         if (currentClass.isLocal()) {
2207             ClassSymbol encl = currentClass.owner.enclClass();
2208             if (encl.trans_local == null) {
2209                 encl.trans_local = List.nil();
2210             }
2211             encl.trans_local = encl.trans_local.prepend(currentClass);
</pre>
<hr />
<pre>
2241         }
2242         if (currentClass.hasOuterInstance()) {
2243             tree.defs = tree.defs.prepend(otdef);
2244             enterSynthetic(tree.pos(), otdef.sym, currentClass.members());
2245         }
2246 
2247         proxies = prevProxies;
2248         outerThisStack = prevOuterThisStack;
2249 
2250         // Append translated tree to `translated&#39; queue.
2251         translated.append(tree);
2252 
2253         attrEnv = prevEnv;
2254         currentClass = currentClassPrev;
2255         currentMethodSym = currentMethodSymPrev;
2256 
2257         // Return empty block {} as a placeholder for an inner class.
2258         result = make_at(tree.pos()).Block(SYNTHETIC, List.nil());
2259     }
2260 
<span class="line-added">2261     List&lt;JCTree&gt; generateMandatedAccessors(JCClassDecl tree) {</span>
<span class="line-added">2262         List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);</span>
<span class="line-added">2263         return tree.sym.getRecordComponents().stream()</span>
<span class="line-added">2264                 .filter(rc -&gt; (rc.accessor.flags() &amp; Flags.GENERATED_MEMBER) != 0)</span>
<span class="line-added">2265                 .map(rc -&gt; {</span>
<span class="line-added">2266                     // we need to return the field not the record component</span>
<span class="line-added">2267                     JCVariableDecl field = fields.stream().filter(f -&gt; f.name == rc.name).findAny().get();</span>
<span class="line-added">2268                     make_at(tree.pos());</span>
<span class="line-added">2269                     return make.MethodDef(rc.accessor, make.Block(0,</span>
<span class="line-added">2270                             List.of(make.Return(make.Ident(field)))));</span>
<span class="line-added">2271                 }).collect(List.collector());</span>
<span class="line-added">2272     }</span>
<span class="line-added">2273 </span>
2274     /** Translate an enum class. */
2275     private void visitEnumDef(JCClassDecl tree) {
2276         make_at(tree.pos());
2277 
2278         // add the supertype, if needed
2279         if (tree.extending == null)
2280             tree.extending = make.Type(types.supertype(tree.type));
2281 
2282         // classOfType adds a cache field to tree.defs
2283         JCExpression e_class = classOfType(tree.sym.type, tree.pos()).
2284             setType(types.erasure(syms.classType));
2285 
2286         // process each enumeration constant, adding implicit constructor parameters
2287         int nextOrdinal = 0;
2288         ListBuffer&lt;JCExpression&gt; values = new ListBuffer&lt;&gt;();
2289         ListBuffer&lt;JCTree&gt; enumDefs = new ListBuffer&lt;&gt;();
2290         ListBuffer&lt;JCTree&gt; otherDefs = new ListBuffer&lt;&gt;();
2291         for (List&lt;JCTree&gt; defs = tree.defs;
2292              defs.nonEmpty();
2293              defs=defs.tail) {
</pre>
<hr />
<pre>
2409     }
2410         // where
2411         private MethodSymbol systemArraycopyMethod;
2412         private boolean useClone() {
2413             try {
2414                 return syms.objectType.tsym.members().findFirst(names.clone) != null;
2415             }
2416             catch (CompletionFailure e) {
2417                 return false;
2418             }
2419         }
2420 
2421     /** Translate an enumeration constant and its initializer. */
2422     private void visitEnumConstantDef(JCVariableDecl var, int ordinal) {
2423         JCNewClass varDef = (JCNewClass)var.init;
2424         varDef.args = varDef.args.
2425             prepend(makeLit(syms.intType, ordinal)).
2426             prepend(makeLit(syms.stringType, var.name.toString()));
2427     }
2428 
<span class="line-added">2429     private List&lt;VarSymbol&gt; recordVars(Type t) {</span>
<span class="line-added">2430         List&lt;VarSymbol&gt; vars = List.nil();</span>
<span class="line-added">2431         while (!t.hasTag(NONE)) {</span>
<span class="line-added">2432             if (t.hasTag(CLASS)) {</span>
<span class="line-added">2433                 for (Symbol s : t.tsym.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; (s.flags() &amp; RECORD) != 0)) {</span>
<span class="line-added">2434                     vars = vars.prepend((VarSymbol)s);</span>
<span class="line-added">2435                 }</span>
<span class="line-added">2436             }</span>
<span class="line-added">2437             t = types.supertype(t);</span>
<span class="line-added">2438         }</span>
<span class="line-added">2439         return vars;</span>
<span class="line-added">2440     }</span>
<span class="line-added">2441 </span>
<span class="line-added">2442     /** Translate a record. */</span>
<span class="line-added">2443     private void visitRecordDef(JCClassDecl tree) {</span>
<span class="line-added">2444         make_at(tree.pos());</span>
<span class="line-added">2445         List&lt;VarSymbol&gt; vars = recordVars(tree.type);</span>
<span class="line-added">2446         MethodHandleSymbol[] getterMethHandles = new MethodHandleSymbol[vars.size()];</span>
<span class="line-added">2447         int index = 0;</span>
<span class="line-added">2448         for (VarSymbol var : vars) {</span>
<span class="line-added">2449             if (var.owner != tree.sym) {</span>
<span class="line-added">2450                 var = new VarSymbol(var.flags_field, var.name, var.type, tree.sym);</span>
<span class="line-added">2451             }</span>
<span class="line-added">2452             getterMethHandles[index] = var.asMethodHandle(true);</span>
<span class="line-added">2453             index++;</span>
<span class="line-added">2454         }</span>
<span class="line-added">2455 </span>
<span class="line-added">2456         tree.defs = tree.defs.appendList(generateMandatedAccessors(tree));</span>
<span class="line-added">2457         tree.defs = tree.defs.appendList(List.of(</span>
<span class="line-added">2458                 generateRecordMethod(tree, names.toString, vars, getterMethHandles),</span>
<span class="line-added">2459                 generateRecordMethod(tree, names.hashCode, vars, getterMethHandles),</span>
<span class="line-added">2460                 generateRecordMethod(tree, names.equals, vars, getterMethHandles)</span>
<span class="line-added">2461         ));</span>
<span class="line-added">2462     }</span>
<span class="line-added">2463 </span>
<span class="line-added">2464     JCTree generateRecordMethod(JCClassDecl tree, Name name, List&lt;VarSymbol&gt; vars, MethodHandleSymbol[] getterMethHandles) {</span>
<span class="line-added">2465         make_at(tree.pos());</span>
<span class="line-added">2466         boolean isEquals = name == names.equals;</span>
<span class="line-added">2467         MethodSymbol msym = lookupMethod(tree.pos(),</span>
<span class="line-added">2468                 name,</span>
<span class="line-added">2469                 tree.sym.type,</span>
<span class="line-added">2470                 isEquals ? List.of(syms.objectType) : List.nil());</span>
<span class="line-added">2471         // compiler generated methods have the record flag set, user defined ones dont</span>
<span class="line-added">2472         if ((msym.flags() &amp; RECORD) != 0) {</span>
<span class="line-added">2473             /* class java.lang.runtime.ObjectMethods provides a common bootstrap that provides a customized implementation</span>
<span class="line-added">2474              * for methods: toString, hashCode and equals. Here we just need to generate and indy call to:</span>
<span class="line-added">2475              * java.lang.runtime.ObjectMethods::bootstrap and provide: the record class, the record component names and</span>
<span class="line-added">2476              * the accessors.</span>
<span class="line-added">2477              */</span>
<span class="line-added">2478             Name bootstrapName = names.bootstrap;</span>
<span class="line-added">2479             LoadableConstant[] staticArgsValues = new LoadableConstant[2 + getterMethHandles.length];</span>
<span class="line-added">2480             staticArgsValues[0] = (ClassType)tree.sym.type;</span>
<span class="line-added">2481             String concatNames = vars.stream()</span>
<span class="line-added">2482                     .map(v -&gt; v.name)</span>
<span class="line-added">2483                     .collect(Collectors.joining(&quot;;&quot;, &quot;&quot;, &quot;&quot;));</span>
<span class="line-added">2484             staticArgsValues[1] = LoadableConstant.String(concatNames);</span>
<span class="line-added">2485             int index = 2;</span>
<span class="line-added">2486             for (MethodHandleSymbol mho : getterMethHandles) {</span>
<span class="line-added">2487                 staticArgsValues[index] = mho;</span>
<span class="line-added">2488                 index++;</span>
<span class="line-added">2489             }</span>
<span class="line-added">2490 </span>
<span class="line-added">2491             List&lt;Type&gt; staticArgTypes = List.of(syms.classType,</span>
<span class="line-added">2492                     syms.stringType,</span>
<span class="line-added">2493                     new ArrayType(syms.methodHandleType, syms.arrayClass));</span>
<span class="line-added">2494 </span>
<span class="line-added">2495             JCFieldAccess qualifier = makeIndyQualifier(syms.objectMethodsType, tree, msym,</span>
<span class="line-added">2496                     List.of(syms.methodHandleLookupType,</span>
<span class="line-added">2497                             syms.stringType,</span>
<span class="line-added">2498                             syms.typeDescriptorType).appendList(staticArgTypes),</span>
<span class="line-added">2499                     staticArgsValues, bootstrapName, name, false);</span>
<span class="line-added">2500 </span>
<span class="line-added">2501             VarSymbol _this = new VarSymbol(SYNTHETIC, names._this, tree.sym.type, tree.sym);</span>
<span class="line-added">2502 </span>
<span class="line-added">2503             JCMethodInvocation proxyCall;</span>
<span class="line-added">2504             if (!isEquals) {</span>
<span class="line-added">2505                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this)));</span>
<span class="line-added">2506             } else {</span>
<span class="line-added">2507                 VarSymbol o = msym.params.head;</span>
<span class="line-added">2508                 o.adr = 0;</span>
<span class="line-added">2509                 proxyCall = make.Apply(List.nil(), qualifier, List.of(make.Ident(_this), make.Ident(o)));</span>
<span class="line-added">2510             }</span>
<span class="line-added">2511             proxyCall.type = qualifier.type;</span>
<span class="line-added">2512             return make.MethodDef(msym, make.Block(0, List.of(make.Return(proxyCall))));</span>
<span class="line-added">2513         } else {</span>
<span class="line-added">2514             return make.Block(SYNTHETIC, List.nil());</span>
<span class="line-added">2515         }</span>
<span class="line-added">2516     }</span>
<span class="line-added">2517 </span>
<span class="line-added">2518     private String argsTypeSig(List&lt;Type&gt; typeList) {</span>
<span class="line-added">2519         LowerSignatureGenerator sg = new LowerSignatureGenerator();</span>
<span class="line-added">2520         sg.assembleSig(typeList);</span>
<span class="line-added">2521         return sg.toString();</span>
<span class="line-added">2522     }</span>
<span class="line-added">2523 </span>
<span class="line-added">2524     /**</span>
<span class="line-added">2525      * Signature Generation</span>
<span class="line-added">2526      */</span>
<span class="line-added">2527     private class LowerSignatureGenerator extends Types.SignatureGenerator {</span>
<span class="line-added">2528 </span>
<span class="line-added">2529         /**</span>
<span class="line-added">2530          * An output buffer for type signatures.</span>
<span class="line-added">2531          */</span>
<span class="line-added">2532         StringBuilder sb = new StringBuilder();</span>
<span class="line-added">2533 </span>
<span class="line-added">2534         LowerSignatureGenerator() {</span>
<span class="line-added">2535             super(types);</span>
<span class="line-added">2536         }</span>
<span class="line-added">2537 </span>
<span class="line-added">2538         @Override</span>
<span class="line-added">2539         protected void append(char ch) {</span>
<span class="line-added">2540             sb.append(ch);</span>
<span class="line-added">2541         }</span>
<span class="line-added">2542 </span>
<span class="line-added">2543         @Override</span>
<span class="line-added">2544         protected void append(byte[] ba) {</span>
<span class="line-added">2545             sb.append(new String(ba));</span>
<span class="line-added">2546         }</span>
<span class="line-added">2547 </span>
<span class="line-added">2548         @Override</span>
<span class="line-added">2549         protected void append(Name name) {</span>
<span class="line-added">2550             sb.append(name.toString());</span>
<span class="line-added">2551         }</span>
<span class="line-added">2552 </span>
<span class="line-added">2553         @Override</span>
<span class="line-added">2554         public String toString() {</span>
<span class="line-added">2555             return sb.toString();</span>
<span class="line-added">2556         }</span>
<span class="line-added">2557     }</span>
<span class="line-added">2558 </span>
<span class="line-added">2559     /**</span>
<span class="line-added">2560      * Creates an indy qualifier, helpful to be part of an indy invocation</span>
<span class="line-added">2561      * @param site                the site</span>
<span class="line-added">2562      * @param tree                a class declaration tree</span>
<span class="line-added">2563      * @param msym                the method symbol</span>
<span class="line-added">2564      * @param staticArgTypes      the static argument types</span>
<span class="line-added">2565      * @param staticArgValues     the static argument values</span>
<span class="line-added">2566      * @param bootstrapName       the bootstrap name to look for</span>
<span class="line-added">2567      * @param argName             normally bootstraps receives a method name as second argument, if you want that name</span>
<span class="line-added">2568      *                            to be different to that of the bootstrap name pass a different name here</span>
<span class="line-added">2569      * @param isStatic            is it static or not</span>
<span class="line-added">2570      * @return                    a field access tree</span>
<span class="line-added">2571      */</span>
<span class="line-added">2572     JCFieldAccess makeIndyQualifier(</span>
<span class="line-added">2573             Type site,</span>
<span class="line-added">2574             JCClassDecl tree,</span>
<span class="line-added">2575             MethodSymbol msym,</span>
<span class="line-added">2576             List&lt;Type&gt; staticArgTypes,</span>
<span class="line-added">2577             LoadableConstant[] staticArgValues,</span>
<span class="line-added">2578             Name bootstrapName,</span>
<span class="line-added">2579             Name argName,</span>
<span class="line-added">2580             boolean isStatic) {</span>
<span class="line-added">2581         Symbol bsm = rs.resolveInternalMethod(tree.pos(), attrEnv, site,</span>
<span class="line-added">2582                 bootstrapName, staticArgTypes, List.nil());</span>
<span class="line-added">2583 </span>
<span class="line-added">2584         MethodType indyType = msym.type.asMethodType();</span>
<span class="line-added">2585         indyType = new MethodType(</span>
<span class="line-added">2586                 isStatic ? List.nil() : indyType.argtypes.prepend(tree.sym.type),</span>
<span class="line-added">2587                 indyType.restype,</span>
<span class="line-added">2588                 indyType.thrown,</span>
<span class="line-added">2589                 syms.methodClass</span>
<span class="line-added">2590         );</span>
<span class="line-added">2591         DynamicMethodSymbol dynSym = new DynamicMethodSymbol(argName,</span>
<span class="line-added">2592                 syms.noSymbol,</span>
<span class="line-added">2593                 ((MethodSymbol)bsm).asHandle(),</span>
<span class="line-added">2594                 indyType,</span>
<span class="line-added">2595                 staticArgValues);</span>
<span class="line-added">2596         JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), argName);</span>
<span class="line-added">2597         qualifier.sym = dynSym;</span>
<span class="line-added">2598         qualifier.type = msym.type.asMethodType().restype;</span>
<span class="line-added">2599         return qualifier;</span>
<span class="line-added">2600     }</span>
<span class="line-added">2601 </span>
2602     public void visitMethodDef(JCMethodDecl tree) {
2603         if (tree.name == names.init &amp;&amp; (currentClass.flags_field&amp;ENUM) != 0) {
2604             // Add &quot;String $enum$name, int $enum$ordinal&quot; to the beginning of the
2605             // argument list for each constructor of an enum.
2606             JCVariableDecl nameParam = make_at(tree.pos()).
2607                 Param(names.fromString(target.syntheticNameChar() +
2608                                        &quot;enum&quot; + target.syntheticNameChar() + &quot;name&quot;),
2609                       syms.stringType, tree.sym);
2610             nameParam.mods.flags |= SYNTHETIC; nameParam.sym.flags_field |= SYNTHETIC;
2611             JCVariableDecl ordParam = make.
2612                 Param(names.fromString(target.syntheticNameChar() +
2613                                        &quot;enum&quot; + target.syntheticNameChar() +
2614                                        &quot;ordinal&quot;),
2615                       syms.intType, tree.sym);
2616             ordParam.mods.flags |= SYNTHETIC; ordParam.sym.flags_field |= SYNTHETIC;
2617 
2618             MethodSymbol m = tree.sym;
2619             tree.params = tree.params.prepend(ordParam).prepend(nameParam);
2620 
2621             m.extraParams = m.extraParams.prepend(ordParam.sym);
</pre>
<hr />
<pre>
2709             // pop local variables from proxy stack
2710             proxies = prevProxies;
2711 
2712             // recursively translate following local statements and
2713             // combine with this- or super-call
2714             List&lt;JCStatement&gt; stats = translate(tree.body.stats.tail);
2715             tree.body.stats = stats.prepend(selfCall).prependList(added);
2716             outerThisStack = prevOuterThisStack;
2717         } else {
2718             Map&lt;Symbol, Symbol&gt; prevLambdaTranslationMap =
2719                     lambdaTranslationMap;
2720             try {
2721                 lambdaTranslationMap = (tree.sym.flags() &amp; SYNTHETIC) != 0 &amp;&amp;
2722                         tree.sym.name.startsWith(names.lambda) ?
2723                         makeTranslationMap(tree) : null;
2724                 super.visitMethodDef(tree);
2725             } finally {
2726                 lambdaTranslationMap = prevLambdaTranslationMap;
2727             }
2728         }
<span class="line-added">2729         if (tree.name == names.init &amp;&amp; (tree.sym.flags_field &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {</span>
<span class="line-added">2730             // lets find out if there is any field waiting to be initialized</span>
<span class="line-added">2731             ListBuffer&lt;VarSymbol&gt; fields = new ListBuffer&lt;&gt;();</span>
<span class="line-added">2732             for (Symbol sym : currentClass.getEnclosedElements()) {</span>
<span class="line-added">2733                 if (sym.kind == Kinds.Kind.VAR &amp;&amp; ((sym.flags() &amp; RECORD) != 0))</span>
<span class="line-added">2734                     fields.append((VarSymbol) sym);</span>
<span class="line-added">2735             }</span>
<span class="line-added">2736             for (VarSymbol field: fields) {</span>
<span class="line-added">2737                 if ((field.flags_field &amp; Flags.UNINITIALIZED_FIELD) != 0) {</span>
<span class="line-added">2738                     VarSymbol param = tree.params.stream().filter(p -&gt; p.name == field.name).findFirst().get().sym;</span>
<span class="line-added">2739                     make.at(tree.pos);</span>
<span class="line-added">2740                     tree.body.stats = tree.body.stats.append(</span>
<span class="line-added">2741                             make.Exec(</span>
<span class="line-added">2742                                     make.Assign(</span>
<span class="line-added">2743                                             make.Select(make.This(field.owner.erasure(types)), field),</span>
<span class="line-added">2744                                             make.Ident(param)).setType(field.erasure(types))));</span>
<span class="line-added">2745                     // we don&#39;t need the flag at the field anymore</span>
<span class="line-added">2746                     field.flags_field &amp;= ~Flags.UNINITIALIZED_FIELD;</span>
<span class="line-added">2747                 }</span>
<span class="line-added">2748             }</span>
<span class="line-added">2749         }</span>
2750         result = tree;
2751     }
2752     //where
2753         private Map&lt;Symbol, Symbol&gt; makeTranslationMap(JCMethodDecl tree) {
2754             Map&lt;Symbol, Symbol&gt; translationMap = new HashMap&lt;&gt;();
2755             for (JCVariableDecl vd : tree.params) {
2756                 Symbol p = vd.sym;
2757                 if (p != p.baseSymbol()) {
2758                     translationMap.put(p.baseSymbol(), p);
2759                 }
2760             }
2761             return translationMap;
2762         }
2763 
2764     public void visitTypeCast(JCTypeCast tree) {
2765         tree.clazz = translate(tree.clazz);
2766         if (tree.type.isPrimitive() != tree.expr.type.isPrimitive())
2767             tree.expr = translate(tree.expr, tree.type);
2768         else
2769             tree.expr = translate(tree.expr);
</pre>
<hr />
<pre>
3414                                                   tree.var.vartype,
3415                                                   loopvarinit).setType(tree.var.type);
3416             loopvardef.sym = tree.var.sym;
3417             JCBlock body = make.
3418                 Block(0, List.of(loopvardef, tree.body));
3419 
3420             result = translate(make.
3421                                ForLoop(loopinit,
3422                                        cond,
3423                                        List.of(step),
3424                                        body));
3425             patchTargets(body, tree, result);
3426         }
3427         /** Patch up break and continue targets. */
3428         private void patchTargets(JCTree body, final JCTree src, final JCTree dest) {
3429             class Patcher extends TreeScanner {
3430                 public void visitBreak(JCBreak tree) {
3431                     if (tree.target == src)
3432                         tree.target = dest;
3433                 }
<span class="line-added">3434                 public void visitYield(JCYield tree) {</span>
<span class="line-added">3435                     if (tree.target == src)</span>
<span class="line-added">3436                         tree.target = dest;</span>
<span class="line-added">3437                     scan(tree.value);</span>
<span class="line-added">3438                 }</span>
3439                 public void visitContinue(JCContinue tree) {
3440                     if (tree.target == src)
3441                         tree.target = dest;
3442                 }
3443                 public void visitClassDef(JCClassDecl tree) {}
3444             }
3445             new Patcher().scan(body);
3446         }
3447         /**
3448          * A statement of the form
3449          *
3450          * &lt;pre&gt;
3451          *     for ( T v : coll ) stmt ;
3452          * &lt;/pre&gt;
3453          *
3454          * (where coll implements {@code Iterable&lt;? extends T&gt;}) gets translated to
3455          *
3456          * &lt;pre&gt;{@code
3457          *     for ( Iterator&lt;? extends T&gt; #i = coll.iterator(); #i.hasNext(); ) {
3458          *         T v = (T) #i.next();
</pre>
<hr />
<pre>
3871                 JCSwitchExpression switch2 = make.SwitchExpression(make.Ident(dollar_tmp), lb.toList());
3872 
3873                 // Rewire up old unlabeled break statements to the
3874                 // replacement switch being created.
3875                 patchTargets(switch2, tree, switch2);
3876 
3877                 switch2.setType(tree.type);
3878 
3879                 LetExpr res = make.LetExpr(stmtList.toList(), switch2);
3880 
3881                 res.needsCond = true;
3882                 res.setType(tree.type);
3883 
3884                 return res;
3885             }
3886         }
3887     }
3888 
3889     @Override
3890     public void visitBreak(JCBreak tree) {
<span class="line-modified">3891         result = tree;</span>
<span class="line-modified">3892     }</span>
<span class="line-modified">3893 </span>
<span class="line-added">3894     @Override</span>
<span class="line-added">3895     public void visitYield(JCYield tree) {</span>
<span class="line-added">3896         tree.value = translate(tree.value, tree.target.type);</span>
3897         result = tree;
3898     }
3899 
3900     public void visitNewArray(JCNewArray tree) {
3901         tree.elemtype = translate(tree.elemtype);
3902         for (List&lt;JCExpression&gt; t = tree.dims; t.tail != null; t = t.tail)
3903             if (t.head != null) t.head = translate(t.head, syms.intType);
3904         tree.elems = translate(tree.elems, types.elemtype(tree.type));
3905         result = tree;
3906     }
3907 
3908     public void visitSelect(JCFieldAccess tree) {
3909         // need to special case-access of the form C.super.x
3910         // these will always need an access method, unless C
3911         // is a default interface subclassed by the current class.
3912         boolean qualifiedSuperAccess =
3913             tree.selected.hasTag(SELECT) &amp;&amp;
3914             TreeInfo.name(tree.selected) == names._super &amp;&amp;
3915             !types.isDirectSuperInterface(((JCFieldAccess)tree.selected).selected.type.tsym, currentClass);
3916         tree.selected = translate(tree.selected);
</pre>
</td>
</tr>
</table>
<center><a href="LambdaToMethod.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemberEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
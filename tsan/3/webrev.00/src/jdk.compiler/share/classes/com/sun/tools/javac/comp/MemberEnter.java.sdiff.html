<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/MemberEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Lower.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Modules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/MemberEnter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 
 28 import java.util.EnumSet;
 29 import java.util.Set;
 30 
 31 import com.sun.tools.javac.code.*;
 32 import com.sun.tools.javac.code.Scope.WriteableScope;
 33 import com.sun.tools.javac.tree.*;
 34 import com.sun.tools.javac.util.*;
 35 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 36 import com.sun.tools.javac.util.JCDiagnostic.Error;
 37 
 38 import com.sun.tools.javac.code.Symbol.*;
 39 import com.sun.tools.javac.code.Type.*;
 40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 41 import com.sun.tools.javac.tree.JCTree.*;
 42 
 43 import static com.sun.tools.javac.code.Flags.*;
 44 import static com.sun.tools.javac.code.Kinds.*;
 45 import static com.sun.tools.javac.code.Kinds.Kind.*;
 46 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;

 47 
 48 /** Resolves field, method and constructor header, and constructs corresponding Symbols.
 49  *
 50  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 51  *  If you write code that depends on this, you do so at your own risk.
 52  *  This code and its internal interfaces are subject to change or
 53  *  deletion without notice.&lt;/b&gt;
 54  */
 55 public class MemberEnter extends JCTree.Visitor {
 56     protected static final Context.Key&lt;MemberEnter&gt; memberEnterKey = new Context.Key&lt;&gt;();
 57 
 58     private final Enter enter;
 59     private final Log log;
 60     private final Check chk;
 61     private final Attr attr;
 62     private final Symtab syms;
 63     private final Annotate annotate;
 64     private final Types types;
 65     private final DeferredLintHandler deferredLintHandler;
 66 
</pre>
<hr />
<pre>
228         if (tree.defaultValue != null) {
229             m.defaultValue = annotate.unfinishedDefaultValue(); // set it to temporary sentinel for now
230             annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree.pos());
231         }
232     }
233 
234     /** Create a fresh environment for method bodies.
235      *  @param tree     The method definition.
236      *  @param env      The environment current outside of the method definition.
237      */
238     Env&lt;AttrContext&gt; methodEnv(JCMethodDecl tree, Env&lt;AttrContext&gt; env) {
239         Env&lt;AttrContext&gt; localEnv =
240             env.dup(tree, env.info.dup(env.info.scope.dupUnshared(tree.sym)));
241         localEnv.enclMethod = tree;
242         if (tree.sym.type != null) {
243             //when this is called in the enter stage, there&#39;s no type to be set
244             localEnv.info.returnResult = attr.new ResultInfo(KindSelector.VAL,
245                                                              tree.sym.type.getReturnType());
246         }
247         if ((tree.mods.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
<span class="line-modified">248         localEnv.info.breakResult = null;</span>
249         return localEnv;
250     }
251 
252     public void visitVarDef(JCVariableDecl tree) {
253         Env&lt;AttrContext&gt; localEnv = env;
254         if ((tree.mods.flags &amp; STATIC) != 0 ||
255             (env.info.scope.owner.flags() &amp; INTERFACE) != 0) {
256             localEnv = env.dup(tree, env.info.dup());
257             localEnv.info.staticLevel++;
258         }
259         DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
260 
261         try {
262             if (TreeInfo.isEnumInit(tree)) {
263                 attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);
264             } else if (!tree.isImplicitlyTyped()) {
265                 attr.attribType(tree.vartype, localEnv);
266                 if (TreeInfo.isReceiverParam(tree))
267                     checkReceiver(tree, localEnv);
268             }
</pre>
<hr />
<pre>
282         }
283         WriteableScope enclScope = enter.enterScope(env);
284         Type vartype = tree.isImplicitlyTyped()
285                 ? env.info.scope.owner.kind == MTH ? Type.noType : syms.errType
286                 : tree.vartype.type;
287         VarSymbol v = new VarSymbol(0, tree.name, vartype, enclScope.owner);
288         v.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, v, tree);
289         tree.sym = v;
290         if (tree.init != null) {
291             v.flags_field |= HASINIT;
292             if ((v.flags_field &amp; FINAL) != 0 &amp;&amp;
293                 needsLazyConstValue(tree.init)) {
294                 Env&lt;AttrContext&gt; initEnv = getInitEnv(tree, env);
295                 initEnv.info.enclVar = v;
296                 v.setLazyConstValue(initEnv(tree, initEnv), attr, tree);
297             }
298         }
299         if (chk.checkUnique(tree.pos(), v, enclScope)) {
300             chk.checkTransparentVar(tree.pos(), v, enclScope);
301             enclScope.enter(v);



302         }
303 
304         annotate.annotateLater(tree.mods.annotations, localEnv, v, tree.pos());
305         if (!tree.isImplicitlyTyped()) {
306             annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree.pos());
307         }
308 
309         v.pos = tree.pos;
310     }
311     // where
312     void checkType(JCTree tree, Type type, Error errorKey) {
313         if (!tree.type.isErroneous() &amp;&amp; !types.isSameType(tree.type, type)) {
314             log.error(tree, errorKey);
315         }
316     }
317     void checkReceiver(JCVariableDecl tree, Env&lt;AttrContext&gt; localEnv) {
318         attr.attribExpr(tree.nameexpr, localEnv);
319         MethodSymbol m = localEnv.enclMethod.sym;
320         if (m.isConstructor()) {
321             Type outertype = m.owner.owner.type;
</pre>
</td>
<td>
<hr />
<pre>
 27 
 28 import java.util.EnumSet;
 29 import java.util.Set;
 30 
 31 import com.sun.tools.javac.code.*;
 32 import com.sun.tools.javac.code.Scope.WriteableScope;
 33 import com.sun.tools.javac.tree.*;
 34 import com.sun.tools.javac.util.*;
 35 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 36 import com.sun.tools.javac.util.JCDiagnostic.Error;
 37 
 38 import com.sun.tools.javac.code.Symbol.*;
 39 import com.sun.tools.javac.code.Type.*;
 40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 41 import com.sun.tools.javac.tree.JCTree.*;
 42 
 43 import static com.sun.tools.javac.code.Flags.*;
 44 import static com.sun.tools.javac.code.Kinds.*;
 45 import static com.sun.tools.javac.code.Kinds.Kind.*;
 46 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
<span class="line-added"> 47 import static com.sun.tools.javac.tree.JCTree.Tag.VARDEF;</span>
 48 
 49 /** Resolves field, method and constructor header, and constructs corresponding Symbols.
 50  *
 51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 52  *  If you write code that depends on this, you do so at your own risk.
 53  *  This code and its internal interfaces are subject to change or
 54  *  deletion without notice.&lt;/b&gt;
 55  */
 56 public class MemberEnter extends JCTree.Visitor {
 57     protected static final Context.Key&lt;MemberEnter&gt; memberEnterKey = new Context.Key&lt;&gt;();
 58 
 59     private final Enter enter;
 60     private final Log log;
 61     private final Check chk;
 62     private final Attr attr;
 63     private final Symtab syms;
 64     private final Annotate annotate;
 65     private final Types types;
 66     private final DeferredLintHandler deferredLintHandler;
 67 
</pre>
<hr />
<pre>
229         if (tree.defaultValue != null) {
230             m.defaultValue = annotate.unfinishedDefaultValue(); // set it to temporary sentinel for now
231             annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree.pos());
232         }
233     }
234 
235     /** Create a fresh environment for method bodies.
236      *  @param tree     The method definition.
237      *  @param env      The environment current outside of the method definition.
238      */
239     Env&lt;AttrContext&gt; methodEnv(JCMethodDecl tree, Env&lt;AttrContext&gt; env) {
240         Env&lt;AttrContext&gt; localEnv =
241             env.dup(tree, env.info.dup(env.info.scope.dupUnshared(tree.sym)));
242         localEnv.enclMethod = tree;
243         if (tree.sym.type != null) {
244             //when this is called in the enter stage, there&#39;s no type to be set
245             localEnv.info.returnResult = attr.new ResultInfo(KindSelector.VAL,
246                                                              tree.sym.type.getReturnType());
247         }
248         if ((tree.mods.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
<span class="line-modified">249         localEnv.info.yieldResult = null;</span>
250         return localEnv;
251     }
252 
253     public void visitVarDef(JCVariableDecl tree) {
254         Env&lt;AttrContext&gt; localEnv = env;
255         if ((tree.mods.flags &amp; STATIC) != 0 ||
256             (env.info.scope.owner.flags() &amp; INTERFACE) != 0) {
257             localEnv = env.dup(tree, env.info.dup());
258             localEnv.info.staticLevel++;
259         }
260         DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
261 
262         try {
263             if (TreeInfo.isEnumInit(tree)) {
264                 attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);
265             } else if (!tree.isImplicitlyTyped()) {
266                 attr.attribType(tree.vartype, localEnv);
267                 if (TreeInfo.isReceiverParam(tree))
268                     checkReceiver(tree, localEnv);
269             }
</pre>
<hr />
<pre>
283         }
284         WriteableScope enclScope = enter.enterScope(env);
285         Type vartype = tree.isImplicitlyTyped()
286                 ? env.info.scope.owner.kind == MTH ? Type.noType : syms.errType
287                 : tree.vartype.type;
288         VarSymbol v = new VarSymbol(0, tree.name, vartype, enclScope.owner);
289         v.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, v, tree);
290         tree.sym = v;
291         if (tree.init != null) {
292             v.flags_field |= HASINIT;
293             if ((v.flags_field &amp; FINAL) != 0 &amp;&amp;
294                 needsLazyConstValue(tree.init)) {
295                 Env&lt;AttrContext&gt; initEnv = getInitEnv(tree, env);
296                 initEnv.info.enclVar = v;
297                 v.setLazyConstValue(initEnv(tree, initEnv), attr, tree);
298             }
299         }
300         if (chk.checkUnique(tree.pos(), v, enclScope)) {
301             chk.checkTransparentVar(tree.pos(), v, enclScope);
302             enclScope.enter(v);
<span class="line-added">303         } else if (v.owner.kind == MTH || (v.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0) {</span>
<span class="line-added">304             // if this is a parameter or a field obtained from a record component, enter it</span>
<span class="line-added">305             enclScope.enter(v);</span>
306         }
307 
308         annotate.annotateLater(tree.mods.annotations, localEnv, v, tree.pos());
309         if (!tree.isImplicitlyTyped()) {
310             annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree.pos());
311         }
312 
313         v.pos = tree.pos;
314     }
315     // where
316     void checkType(JCTree tree, Type type, Error errorKey) {
317         if (!tree.type.isErroneous() &amp;&amp; !types.isSameType(tree.type, type)) {
318             log.error(tree, errorKey);
319         }
320     }
321     void checkReceiver(JCVariableDecl tree, Env&lt;AttrContext&gt; localEnv) {
322         attr.attribExpr(tree.nameexpr, localEnv);
323         MethodSymbol m = localEnv.enclMethod.sym;
324         if (m.isConstructor()) {
325             Type outertype = m.owner.owner.type;
</pre>
</td>
</tr>
</table>
<center><a href="Lower.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Modules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
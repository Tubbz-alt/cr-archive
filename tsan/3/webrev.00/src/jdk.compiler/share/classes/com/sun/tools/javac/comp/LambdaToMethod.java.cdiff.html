<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InferenceContext.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lower.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 23,11 ***</span>
<span class="line-new-header">--- 23,13 ---</span>
   * questions.
   */
  
  package com.sun.tools.javac.comp;
  
<span class="line-added">+ import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;</span>
  import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
<span class="line-added">+ import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
  import com.sun.tools.javac.resources.CompilerProperties.Errors;
  import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  import com.sun.tools.javac.tree.*;
  import com.sun.tools.javac.tree.JCTree.*;
  import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,28 ***</span>
  import java.util.EnumMap;
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.LinkedHashMap;
  import java.util.Map;
<span class="line-removed">- import java.util.Objects;</span>
  import java.util.Optional;
  import java.util.Set;
  import java.util.function.Consumer;
  import java.util.function.Supplier;
  
  import static com.sun.tools.javac.comp.LambdaToMethod.LambdaSymbolKind.*;
  import static com.sun.tools.javac.code.Flags.*;
  import static com.sun.tools.javac.code.Kinds.Kind.*;
  import static com.sun.tools.javac.code.TypeTag.*;
  import static com.sun.tools.javac.tree.JCTree.Tag.*;
<span class="line-removed">- import static com.sun.tools.javac.jvm.Pool.DynamicMethod;</span>
  
  import javax.lang.model.element.ElementKind;
  import javax.lang.model.type.TypeKind;
  
<span class="line-removed">- import com.sun.tools.javac.code.Type.IntersectionClassType;</span>
<span class="line-removed">- import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;</span>
  import com.sun.tools.javac.main.Option;
  
  /**
   * This pass desugars lambda expressions into static methods
   *
<span class="line-new-header">--- 59,24 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,11 ***</span>
           */
          private ListBuffer&lt;JCTree&gt; appendedMethodList;
  
          private Map&lt;DedupedLambda, DedupedLambda&gt; dedupedLambdas;
  
<span class="line-modified">!         private Map&lt;DynamicMethod, DynamicMethodSymbol&gt; dynMethSyms = new HashMap&lt;&gt;();</span>
  
          /**
           * list of deserialization cases
           */
          private final Map&lt;String, ListBuffer&lt;JCStatement&gt;&gt; deserializeCases;
<span class="line-new-header">--- 210,11 ---</span>
           */
          private ListBuffer&lt;JCTree&gt; appendedMethodList;
  
          private Map&lt;DedupedLambda, DedupedLambda&gt; dedupedLambdas;
  
<span class="line-modified">!         private Map&lt;Object, DynamicMethodSymbol&gt; dynMethSyms = new HashMap&lt;&gt;();</span>
  
          /**
           * list of deserialization cases
           */
          private final Map&lt;String, ListBuffer&lt;JCStatement&gt;&gt; deserializeCases;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,11 ***</span>
          lambdaDecl.type = lambdaType;
  
          //translate lambda body
          //As the lambda body is translated, all references to lambda locals,
          //captured variables, enclosing members are adjusted accordingly
<span class="line-modified">!         //to refer to the static method parameters (rather than i.e. acessing to</span>
          //captured members directly).
          lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));
  
          boolean dedupe = false;
          if (deduplicateLambdas &amp;&amp; !debugLinesOrVars &amp;&amp; !localContext.isSerializable()) {
<span class="line-new-header">--- 379,11 ---</span>
          lambdaDecl.type = lambdaType;
  
          //translate lambda body
          //As the lambda body is translated, all references to lambda locals,
          //captured variables, enclosing members are adjusted accordingly
<span class="line-modified">!         //to refer to the static method parameters (rather than i.e. accessing</span>
          //captured members directly).
          lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));
  
          boolean dedupe = false;
          if (deduplicateLambdas &amp;&amp; !debugLinesOrVars &amp;&amp; !localContext.isSerializable()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,15 ***</span>
          }
  
          //then, determine the arguments to the indy call
          List&lt;JCExpression&gt; indy_args = translate(syntheticInits.toList(), localContext.prev);
  
<span class="line-removed">-         //build a sam instance using an indy call to the meta-factory</span>
<span class="line-removed">-         int refKind = referenceKind(sym);</span>
<span class="line-removed">- </span>
          //convert to an invokedynamic call
<span class="line-modified">!         result = makeMetafactoryIndyCall(context, refKind, sym, indy_args);</span>
      }
  
      // where
          // Reassign type annotations from the source that should really belong to the lambda
          private void apportionTypeAnnotations(JCLambda tree,
<span class="line-new-header">--- 435,12 ---</span>
          }
  
          //then, determine the arguments to the indy call
          List&lt;JCExpression&gt; indy_args = translate(syntheticInits.toList(), localContext.prev);
  
          //convert to an invokedynamic call
<span class="line-modified">!         result = makeMetafactoryIndyCall(context, sym.asHandle(), indy_args);</span>
      }
  
      // where
          // Reassign type annotations from the source that should really belong to the lambda
          private void apportionTypeAnnotations(JCLambda tree,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,11 ***</span>
      public void visitReference(JCMemberReference tree) {
          ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;
  
          //first determine the method symbol to be used to generate the sam instance
          //this is either the method reference symbol, or the bridged reference symbol
<span class="line-modified">!         Symbol refSym = tree.sym;</span>
  
          //the qualifying expression is treated as a special captured arg
          JCExpression init;
          switch(tree.kind) {
  
<span class="line-new-header">--- 481,11 ---</span>
      public void visitReference(JCMemberReference tree) {
          ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;
  
          //first determine the method symbol to be used to generate the sam instance
          //this is either the method reference symbol, or the bridged reference symbol
<span class="line-modified">!         MethodSymbol refSym = (MethodSymbol)tree.sym;</span>
  
          //the qualifying expression is treated as a special captured arg
          JCExpression init;
          switch(tree.kind) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,11 ***</span>
  
          List&lt;JCExpression&gt; indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);
  
  
          //build a sam instance using an indy call to the meta-factory
<span class="line-modified">!         result = makeMetafactoryIndyCall(localContext, localContext.referenceKind(), refSym, indy_args);</span>
      }
  
      /**
       * Translate identifiers within a lambda to the mapped identifier
       * @param tree
<span class="line-new-header">--- 515,11 ---</span>
  
          List&lt;JCExpression&gt; indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);
  
  
          //build a sam instance using an indy call to the meta-factory
<span class="line-modified">!         result = makeMetafactoryIndyCall(localContext, refSym.asHandle(), indy_args);</span>
      }
  
      /**
       * Translate identifiers within a lambda to the mapped identifier
       * @param tree
</pre>
<hr />
<pre>
<span class="line-old-header">*** 606,25 ***</span>
          LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context;
          if (context != null &amp;&amp; lambdaContext.getSymbolMap(LOCAL_VAR).containsKey(tree.sym)) {
              tree.init = translate(tree.init);
              tree.sym = (VarSymbol) lambdaContext.getSymbolMap(LOCAL_VAR).get(tree.sym);
              result = tree;
<span class="line-removed">-         } else if (context != null &amp;&amp; lambdaContext.getSymbolMap(TYPE_VAR).containsKey(tree.sym)) {</span>
<span class="line-removed">-             JCExpression init = translate(tree.init);</span>
<span class="line-removed">-             VarSymbol xsym = (VarSymbol)lambdaContext.getSymbolMap(TYPE_VAR).get(tree.sym);</span>
<span class="line-removed">-             int prevPos = make.pos;</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 result = make.at(tree).VarDef(xsym, init);</span>
<span class="line-removed">-             } finally {</span>
<span class="line-removed">-                 make.at(prevPos);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             // Replace the entered symbol for this variable</span>
<span class="line-removed">-             WriteableScope sc = tree.sym.owner.members();</span>
<span class="line-removed">-             if (sc != null) {</span>
<span class="line-removed">-                 sc.remove(tree.sym);</span>
<span class="line-removed">-                 sc.enter(xsym);</span>
<span class="line-removed">-             }</span>
          } else {
              super.visitVarDef(tree);
          }
      }
  
<span class="line-new-header">--- 601,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 763,20 ***</span>
      JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
          return makeNewClass(ctype, args,
                  rs.resolveConstructor(null, attrEnv, ctype, TreeInfo.types(args), List.nil()));
       }
  
<span class="line-modified">!     private void addDeserializationCase(int implMethodKind, Symbol refSym, Type targetType, MethodSymbol samSym,</span>
<span class="line-modified">!             DiagnosticPosition pos, List&lt;Object&gt; staticArgs, MethodType indyType) {</span>
          String functionalInterfaceClass = classSig(targetType);
          String functionalInterfaceMethodName = samSym.getSimpleName().toString();
          String functionalInterfaceMethodSignature = typeSig(types.erasure(samSym.type));
          String implClass = classSig(types.erasure(refSym.owner.type));
          String implMethodName = refSym.getQualifiedName().toString();
          String implMethodSignature = typeSig(types.erasure(refSym.type));
  
<span class="line-modified">!         JCExpression kindTest = eqTest(syms.intType, deserGetter(&quot;getImplMethodKind&quot;, syms.intType), make.Literal(implMethodKind));</span>
          ListBuffer&lt;JCExpression&gt; serArgs = new ListBuffer&lt;&gt;();
          int i = 0;
          for (Type t : indyType.getParameterTypes()) {
              List&lt;JCExpression&gt; indexAsArg = new ListBuffer&lt;JCExpression&gt;().append(make.Literal(i)).toList();
              List&lt;Type&gt; argTypes = new ListBuffer&lt;Type&gt;().append(syms.intType).toList();
<span class="line-new-header">--- 743,21 ---</span>
      JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
          return makeNewClass(ctype, args,
                  rs.resolveConstructor(null, attrEnv, ctype, TreeInfo.types(args), List.nil()));
       }
  
<span class="line-modified">!     private void addDeserializationCase(MethodHandleSymbol refSym, Type targetType, MethodSymbol samSym,</span>
<span class="line-modified">!                                         DiagnosticPosition pos, List&lt;LoadableConstant&gt; staticArgs, MethodType indyType) {</span>
          String functionalInterfaceClass = classSig(targetType);
          String functionalInterfaceMethodName = samSym.getSimpleName().toString();
          String functionalInterfaceMethodSignature = typeSig(types.erasure(samSym.type));
          String implClass = classSig(types.erasure(refSym.owner.type));
          String implMethodName = refSym.getQualifiedName().toString();
          String implMethodSignature = typeSig(types.erasure(refSym.type));
  
<span class="line-modified">!         JCExpression kindTest = eqTest(syms.intType, deserGetter(&quot;getImplMethodKind&quot;, syms.intType),</span>
<span class="line-added">+                 make.Literal(refSym.referenceKind()));</span>
          ListBuffer&lt;JCExpression&gt; serArgs = new ListBuffer&lt;&gt;();
          int i = 0;
          for (Type t : indyType.getParameterTypes()) {
              List&lt;JCExpression&gt; indexAsArg = new ListBuffer&lt;JCExpression&gt;().append(make.Literal(i)).toList();
              List&lt;Type&gt; argTypes = new ListBuffer&lt;Type&gt;().append(syms.intType).toList();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 980,11 ***</span>
              // the implementation method parameters is not obscured.
              // Note: in this loop, the lists implPTypes, samPTypes, and descPTypes
              // are used as pointers to the current parameter type information
              // and are thus not usable afterwards.
              for (int i = 0; implPTypes.nonEmpty() &amp;&amp; i &lt; last; ++i) {
<span class="line-modified">!                 // By default use the implementation method parmeter type</span>
                  Type parmType = implPTypes.head;
                  // If the unerased parameter type is a type variable whose
                  // bound is an intersection (eg. &lt;T extends A &amp; B&gt;) then
                  // use the SAM parameter type
                  if (checkForIntersection &amp;&amp; descPTypes.head.getKind() == TypeKind.TYPEVAR) {
<span class="line-new-header">--- 961,11 ---</span>
              // the implementation method parameters is not obscured.
              // Note: in this loop, the lists implPTypes, samPTypes, and descPTypes
              // are used as pointers to the current parameter type information
              // and are thus not usable afterwards.
              for (int i = 0; implPTypes.nonEmpty() &amp;&amp; i &lt; last; ++i) {
<span class="line-modified">!                 // By default use the implementation method parameter type</span>
                  Type parmType = implPTypes.head;
                  // If the unerased parameter type is a type variable whose
                  // bound is an intersection (eg. &lt;T extends A &amp; B&gt;) then
                  // use the SAM parameter type
                  if (checkForIntersection &amp;&amp; descPTypes.head.getKind() == TypeKind.TYPEVAR) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1104,17 ***</span>
  
      /**
       * Generate an indy method call to the meta factory
       */
      private JCExpression makeMetafactoryIndyCall(TranslationContext&lt;?&gt; context,
<span class="line-modified">!             int refKind, Symbol refSym, List&lt;JCExpression&gt; indy_args) {</span>
          JCFunctionalExpression tree = context.tree;
          //determine the static bsm args
          MethodSymbol samSym = (MethodSymbol) types.findDescriptorSymbol(tree.target.tsym);
<span class="line-modified">!         List&lt;Object&gt; staticArgs = List.of(</span>
                  typeToMethodType(samSym.type),
<span class="line-modified">!                 new Pool.MethodHandle(refKind, refSym, types),</span>
                  typeToMethodType(tree.getDescriptorType(types)));
  
          //computed indy arg types
          ListBuffer&lt;Type&gt; indy_args_types = new ListBuffer&lt;&gt;();
          for (JCExpression arg : indy_args) {
<span class="line-new-header">--- 1085,17 ---</span>
  
      /**
       * Generate an indy method call to the meta factory
       */
      private JCExpression makeMetafactoryIndyCall(TranslationContext&lt;?&gt; context,
<span class="line-modified">!             MethodHandleSymbol refSym, List&lt;JCExpression&gt; indy_args) {</span>
          JCFunctionalExpression tree = context.tree;
          //determine the static bsm args
          MethodSymbol samSym = (MethodSymbol) types.findDescriptorSymbol(tree.target.tsym);
<span class="line-modified">!         List&lt;LoadableConstant&gt; staticArgs = List.of(</span>
                  typeToMethodType(samSym.type),
<span class="line-modified">!                 refSym.asHandle(),</span>
                  typeToMethodType(tree.getDescriptorType(types)));
  
          //computed indy arg types
          ListBuffer&lt;Type&gt; indy_args_types = new ListBuffer&lt;&gt;();
          for (JCExpression arg : indy_args) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1129,20 ***</span>
  
          Name metafactoryName = context.needsAltMetafactory() ?
                  names.altMetafactory : names.metafactory;
  
          if (context.needsAltMetafactory()) {
<span class="line-modified">!             ListBuffer&lt;Object&gt; markers = new ListBuffer&lt;&gt;();</span>
              List&lt;Type&gt; targets = tree.target.isIntersection() ?
                      types.directSupertypes(tree.target) :
                      List.nil();
              for (Type t : targets) {
                  t = types.erasure(t);
                  if (t.tsym != syms.serializableType.tsym &amp;&amp;
                      t.tsym != tree.type.tsym &amp;&amp;
                      t.tsym != syms.objectType.tsym) {
<span class="line-modified">!                     markers.append(t.tsym);</span>
                  }
              }
              int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;
              boolean hasMarkers = markers.nonEmpty();
              boolean hasBridges = context.bridges.nonEmpty();
<span class="line-new-header">--- 1110,20 ---</span>
  
          Name metafactoryName = context.needsAltMetafactory() ?
                  names.altMetafactory : names.metafactory;
  
          if (context.needsAltMetafactory()) {
<span class="line-modified">!             ListBuffer&lt;Type&gt; markers = new ListBuffer&lt;&gt;();</span>
              List&lt;Type&gt; targets = tree.target.isIntersection() ?
                      types.directSupertypes(tree.target) :
                      List.nil();
              for (Type t : targets) {
                  t = types.erasure(t);
                  if (t.tsym != syms.serializableType.tsym &amp;&amp;
                      t.tsym != tree.type.tsym &amp;&amp;
                      t.tsym != syms.objectType.tsym) {
<span class="line-modified">!                     markers.append(t);</span>
                  }
              }
              int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;
              boolean hasMarkers = markers.nonEmpty();
              boolean hasBridges = context.bridges.nonEmpty();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1150,29 ***</span>
                  flags |= FLAG_MARKERS;
              }
              if (hasBridges) {
                  flags |= FLAG_BRIDGES;
              }
<span class="line-modified">!             staticArgs = staticArgs.append(flags);</span>
              if (hasMarkers) {
<span class="line-modified">!                 staticArgs = staticArgs.append(markers.length());</span>
<span class="line-modified">!                 staticArgs = staticArgs.appendList(markers.toList());</span>
              }
              if (hasBridges) {
<span class="line-modified">!                 staticArgs = staticArgs.append(context.bridges.length() - 1);</span>
                  for (Symbol s : context.bridges) {
                      Type s_erasure = s.erasure(types);
                      if (!types.isSameType(s_erasure, samSym.erasure(types))) {
<span class="line-modified">!                         staticArgs = staticArgs.append(s.erasure(types));</span>
                      }
                  }
              }
              if (context.isSerializable()) {
                  int prevPos = make.pos;
                  try {
                      make.at(kInfo.clazz);
<span class="line-modified">!                     addDeserializationCase(refKind, refSym, tree.type, samSym,</span>
                              tree, staticArgs, indyType);
                  } finally {
                      make.at(prevPos);
                  }
              }
<span class="line-new-header">--- 1131,29 ---</span>
                  flags |= FLAG_MARKERS;
              }
              if (hasBridges) {
                  flags |= FLAG_BRIDGES;
              }
<span class="line-modified">!             staticArgs = staticArgs.append(LoadableConstant.Int(flags));</span>
              if (hasMarkers) {
<span class="line-modified">!                 staticArgs = staticArgs.append(LoadableConstant.Int(markers.length()));</span>
<span class="line-modified">!                 staticArgs = staticArgs.appendList(List.convert(LoadableConstant.class, markers.toList()));</span>
              }
              if (hasBridges) {
<span class="line-modified">!                 staticArgs = staticArgs.append(LoadableConstant.Int(context.bridges.length() - 1));</span>
                  for (Symbol s : context.bridges) {
                      Type s_erasure = s.erasure(types);
                      if (!types.isSameType(s_erasure, samSym.erasure(types))) {
<span class="line-modified">!                         staticArgs = staticArgs.append(((MethodType)s.erasure(types)));</span>
                      }
                  }
              }
              if (context.isSerializable()) {
                  int prevPos = make.pos;
                  try {
                      make.at(kInfo.clazz);
<span class="line-modified">!                     addDeserializationCase(refSym, tree.type, samSym,</span>
                              tree, staticArgs, indyType);
                  } finally {
                      make.at(prevPos);
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1184,95 ***</span>
      /**
       * Generate an indy method call with given name, type and static bootstrap
       * arguments types
       */
      private JCExpression makeIndyCall(DiagnosticPosition pos, Type site, Name bsmName,
<span class="line-modified">!             List&lt;Object&gt; staticArgs, MethodType indyType, List&lt;JCExpression&gt; indyArgs,</span>
<span class="line-modified">!             Name methName) {</span>
          int prevPos = make.pos;
          try {
              make.at(pos);
              List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
<span class="line-modified">!                     syms.stringType,</span>
<span class="line-modified">!                     syms.methodTypeType).appendList(bsmStaticArgToTypes(staticArgs));</span>
  
              Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,
                      bsmName, bsm_staticArgs, List.nil());
  
              DynamicMethodSymbol dynSym =
                      new DynamicMethodSymbol(methName,
                                              syms.noSymbol,
<span class="line-modified">!                                             bsm.isStatic() ?</span>
<span class="line-removed">-                                                 ClassFile.REF_invokeStatic :</span>
<span class="line-removed">-                                                 ClassFile.REF_invokeVirtual,</span>
<span class="line-removed">-                                             (MethodSymbol)bsm,</span>
                                              indyType,
<span class="line-modified">!                                             staticArgs.toArray());</span>
              JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), bsmName);
              DynamicMethodSymbol existing = kInfo.dynMethSyms.putIfAbsent(
<span class="line-modified">!                     new DynamicMethod(dynSym, types), dynSym);</span>
              qualifier.sym = existing != null ? existing : dynSym;
              qualifier.type = indyType.getReturnType();
  
              JCMethodInvocation proxyCall = make.Apply(List.nil(), qualifier, indyArgs);
              proxyCall.type = indyType.getReturnType();
              return proxyCall;
          } finally {
              make.at(prevPos);
          }
      }
<span class="line-removed">-     //where</span>
<span class="line-removed">-     private List&lt;Type&gt; bsmStaticArgToTypes(List&lt;Object&gt; args) {</span>
<span class="line-removed">-         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();</span>
<span class="line-removed">-         for (Object arg : args) {</span>
<span class="line-removed">-             argtypes.append(bsmStaticArgToType(arg));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return argtypes.toList();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private Type bsmStaticArgToType(Object arg) {</span>
<span class="line-removed">-         Assert.checkNonNull(arg);</span>
<span class="line-removed">-         if (arg instanceof ClassSymbol) {</span>
<span class="line-removed">-             return syms.classType;</span>
<span class="line-removed">-         } else if (arg instanceof Integer) {</span>
<span class="line-removed">-             return syms.intType;</span>
<span class="line-removed">-         } else if (arg instanceof Long) {</span>
<span class="line-removed">-             return syms.longType;</span>
<span class="line-removed">-         } else if (arg instanceof Float) {</span>
<span class="line-removed">-             return syms.floatType;</span>
<span class="line-removed">-         } else if (arg instanceof Double) {</span>
<span class="line-removed">-             return syms.doubleType;</span>
<span class="line-removed">-         } else if (arg instanceof String) {</span>
<span class="line-removed">-             return syms.stringType;</span>
<span class="line-removed">-         } else if (arg instanceof Pool.MethodHandle) {</span>
<span class="line-removed">-             return syms.methodHandleType;</span>
<span class="line-removed">-         } else if (arg instanceof MethodType) {</span>
<span class="line-removed">-             return syms.methodTypeType;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             Assert.error(&quot;bad static arg &quot; + arg.getClass());</span>
<span class="line-removed">-             return null;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Get the opcode associated with this method reference</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private int referenceKind(Symbol refSym) {</span>
<span class="line-removed">-         if (refSym.isConstructor()) {</span>
<span class="line-removed">-             return ClassFile.REF_newInvokeSpecial;</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             if (refSym.isStatic()) {</span>
<span class="line-removed">-                 return ClassFile.REF_invokeStatic;</span>
<span class="line-removed">-             } else if ((refSym.flags() &amp; PRIVATE) != 0) {</span>
<span class="line-removed">-                 return ClassFile.REF_invokeSpecial;</span>
<span class="line-removed">-             } else if (refSym.enclClass().isInterface()) {</span>
<span class="line-removed">-                 return ClassFile.REF_invokeInterface;</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 return ClassFile.REF_invokeVirtual;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
  
      // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Lambda/reference analyzer&quot;&gt;
      /**
       * This visitor collects information about translation of a lambda expression.
       * More specifically, it keeps track of the enclosing contexts and captured locals
<span class="line-new-header">--- 1165,41 ---</span>
      /**
       * Generate an indy method call with given name, type and static bootstrap
       * arguments types
       */
      private JCExpression makeIndyCall(DiagnosticPosition pos, Type site, Name bsmName,
<span class="line-modified">!                                       List&lt;LoadableConstant&gt; staticArgs, MethodType indyType, List&lt;JCExpression&gt; indyArgs,</span>
<span class="line-modified">!                                       Name methName) {</span>
          int prevPos = make.pos;
          try {
              make.at(pos);
              List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
<span class="line-modified">!                 syms.stringType,</span>
<span class="line-modified">!                 syms.methodTypeType).appendList(staticArgs.map(types::constantType));</span>
  
              Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,
                      bsmName, bsm_staticArgs, List.nil());
  
              DynamicMethodSymbol dynSym =
                      new DynamicMethodSymbol(methName,
                                              syms.noSymbol,
<span class="line-modified">!                                             ((MethodSymbol)bsm).asHandle(),</span>
                                              indyType,
<span class="line-modified">!                                             staticArgs.toArray(new LoadableConstant[staticArgs.length()]));</span>
              JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), bsmName);
              DynamicMethodSymbol existing = kInfo.dynMethSyms.putIfAbsent(
<span class="line-modified">!                     dynSym.poolKey(types), dynSym);</span>
              qualifier.sym = existing != null ? existing : dynSym;
              qualifier.type = indyType.getReturnType();
  
              JCMethodInvocation proxyCall = make.Apply(List.nil(), qualifier, indyArgs);
              proxyCall.type = indyType.getReturnType();
              return proxyCall;
          } finally {
              make.at(prevPos);
          }
      }
  
      // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Lambda/reference analyzer&quot;&gt;
      /**
       * This visitor collects information about translation of a lambda expression.
       * More specifically, it keeps track of the enclosing contexts and captured locals
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1628,13 ***</span>
                      ltc.addSymbol(tree.sym, LOCAL_VAR);
                  }
                  // Check for type variables (including as type arguments).
                  // If they occur within class nested in a lambda, mark for erasure
                  Type type = tree.sym.asType();
<span class="line-removed">-                 if (inClassWithinLambda() &amp;&amp; !types.isSameType(types.erasure(type), type)) {</span>
<span class="line-removed">-                     ltc.addSymbol(tree.sym, TYPE_VAR);</span>
<span class="line-removed">-                 }</span>
              }
  
              List&lt;Frame&gt; prevStack = frameStack;
              try {
                  if (tree.sym.owner.kind == MTH) {
<span class="line-new-header">--- 1555,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1783,12 ***</span>
                          if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {
                              return currentDepth &gt; depth ? null : block.tree;
                          }
                          break;
                      case VARDEF:
<span class="line-modified">!                         if (((JCVariableDecl)block.tree).sym == sym &amp;&amp;</span>
<span class="line-modified">!                                 sym.owner.kind == MTH) { //only locals are captured</span>
                              return currentDepth &gt; depth ? null : block.tree;
                          }
                          break;
                      case BLOCK:
                      case METHODDEF:
<span class="line-new-header">--- 1707,13 ---</span>
                          if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {
                              return currentDepth &gt; depth ? null : block.tree;
                          }
                          break;
                      case VARDEF:
<span class="line-modified">!                         if ((((JCVariableDecl)block.tree).sym == sym &amp;&amp;</span>
<span class="line-modified">!                                 sym.owner.kind == MTH) || //only locals are captured</span>
<span class="line-added">+                             (block.locals != null &amp;&amp; block.locals.contains(sym))) {</span>
                              return currentDepth &gt; depth ? null : block.tree;
                          }
                          break;
                      case BLOCK:
                      case METHODDEF:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2000,20 ***</span>
                          assignedTo = self = null;
                          break;
                   }
  
                  // This symbol will be filled-in in complete
<span class="line-modified">!                 this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());</span>
<span class="line-modified">! </span>
                  translatedSymbols = new EnumMap&lt;&gt;(LambdaSymbolKind.class);
  
                  translatedSymbols.put(PARAM, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(LOCAL_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
<span class="line-removed">-                 translatedSymbols.put(TYPE_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());</span>
  
                  freeVarProcessedLocalClasses = new HashSet&lt;&gt;();
              }
  
               /**
<span class="line-new-header">--- 1925,28 ---</span>
                          assignedTo = self = null;
                          break;
                   }
  
                  // This symbol will be filled-in in complete
<span class="line-modified">!                 if (owner.kind == MTH) {</span>
<span class="line-modified">!                     final MethodSymbol originalOwner = (MethodSymbol)owner.clone(owner.owner);</span>
<span class="line-added">+                     this.translatedSym = new MethodSymbol(SYNTHETIC | PRIVATE, null, null, owner.enclClass()) {</span>
<span class="line-added">+                         @Override</span>
<span class="line-added">+                         public MethodSymbol originalEnclosingMethod() {</span>
<span class="line-added">+                             return originalOwner;</span>
<span class="line-added">+                         }</span>
<span class="line-added">+                     };</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());</span>
<span class="line-added">+                 }</span>
                  translatedSymbols = new EnumMap&lt;&gt;(LambdaSymbolKind.class);
  
                  translatedSymbols.put(PARAM, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(LOCAL_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
                  translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
  
                  freeVarProcessedLocalClasses = new HashSet&lt;&gt;();
              }
  
               /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2102,20 ***</span>
                  Symbol ret;
                  switch (skind) {
                      case CAPTURED_THIS:
                          ret = sym;  // self represented
                          break;
<span class="line-removed">-                     case TYPE_VAR:</span>
<span class="line-removed">-                         // Just erase the type var</span>
<span class="line-removed">-                         ret = new VarSymbol(sym.flags(), sym.name,</span>
<span class="line-removed">-                                 types.erasure(sym.type), sym.owner);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                         /* this information should also be kept for LVT generation at Gen</span>
<span class="line-removed">-                          * a Symbol with pos &lt; startPos won&#39;t be tracked.</span>
<span class="line-removed">-                          */</span>
<span class="line-removed">-                         ((VarSymbol)ret).pos = ((VarSymbol)sym).pos;</span>
<span class="line-removed">-                         break;</span>
                      case CAPTURED_VAR:
                          ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, sym.name, types.erasure(sym.type), translatedSym) {
                              @Override
                              public Symbol baseSymbol() {
                                  //keep mapping with original captured symbol
<span class="line-new-header">--- 2035,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2310,17 ***</span>
              ReferenceTranslationContext(JCMemberReference tree) {
                  super(tree);
                  this.isSuper = tree.hasKind(ReferenceKind.SUPER);
              }
  
<span class="line-removed">-             /**</span>
<span class="line-removed">-              * Get the opcode associated with this method reference</span>
<span class="line-removed">-              */</span>
<span class="line-removed">-             int referenceKind() {</span>
<span class="line-removed">-                 return LambdaToMethod.this.referenceKind(tree.sym);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
              boolean needsVarArgsConversion() {
                  return tree.varargsElement != null;
              }
  
              /**
<span class="line-new-header">--- 2233,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2348,12 ***</span>
                                types.erasure(owner.enclClass().asType()));
              }
  
              boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
                  return ((tree.sym.flags() &amp; PROTECTED) != 0 &amp;&amp;
<span class="line-modified">!                         tree.sym.packge() != owner.packge() &amp;&amp;</span>
<span class="line-removed">-                         !owner.enclClass().isSubClass(tree.sym.owner, types));</span>
              }
  
              /**
               * Erasure destroys the implementation parameter subtype
               * relationship for intersection types.
<span class="line-new-header">--- 2264,11 ---</span>
                                types.erasure(owner.enclClass().asType()));
              }
  
              boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
                  return ((tree.sym.flags() &amp; PROTECTED) != 0 &amp;&amp;
<span class="line-modified">!                         tree.sym.packge() != owner.packge());</span>
              }
  
              /**
               * Erasure destroys the implementation parameter subtype
               * relationship for intersection types.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2415,12 ***</span>
      enum LambdaSymbolKind {
          PARAM,          // original to translated lambda parameters
          LOCAL_VAR,      // original to translated lambda locals
          CAPTURED_VAR,   // variables in enclosing scope to translated synthetic parameters
          CAPTURED_THIS,  // class symbols to translated synthetic parameters (for captured member access)
<span class="line-modified">!         CAPTURED_OUTER_THIS, // used when `this&#39; capture is illegal, but outer this capture is legit (JDK-8129740)</span>
<span class="line-removed">-         TYPE_VAR;      // original to translated lambda type variables</span>
  
          boolean propagateAnnotations() {
              switch (this) {
                  case CAPTURED_VAR:
                  case CAPTURED_THIS:
<span class="line-new-header">--- 2330,11 ---</span>
      enum LambdaSymbolKind {
          PARAM,          // original to translated lambda parameters
          LOCAL_VAR,      // original to translated lambda locals
          CAPTURED_VAR,   // variables in enclosing scope to translated synthetic parameters
          CAPTURED_THIS,  // class symbols to translated synthetic parameters (for captured member access)
<span class="line-modified">!         CAPTURED_OUTER_THIS; // used when `this&#39; capture is illegal, but outer this capture is legit (JDK-8129740)</span>
  
          boolean propagateAnnotations() {
              switch (this) {
                  case CAPTURED_VAR:
                  case CAPTURED_THIS:
</pre>
<center><a href="InferenceContext.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lower.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
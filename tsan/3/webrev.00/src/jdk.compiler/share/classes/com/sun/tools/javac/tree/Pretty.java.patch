diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/tree/Pretty.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,11 +25,10 @@
 
 package com.sun.tools.javac.tree;
 
 import java.io.*;
 
-import com.sun.source.tree.CaseTree.CaseKind;
 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
 import com.sun.source.tree.ModuleTree.ModuleKind;
 import com.sun.tools.javac.code.*;
 import com.sun.tools.javac.tree.JCTree.*;
 import com.sun.tools.javac.util.*;
@@ -169,11 +168,11 @@
 
     /**************************************************************************
      * Traversal methods
      *************************************************************************/
 
-    /** Exception to propogate IOException through visitXXX methods */
+    /** Exception to propagate IOException through visitXXX methods */
     private static class UncheckedIOException extends Error {
         static final long serialVersionUID = -4032692679158424751L;
         UncheckedIOException(IOException e) {
             super(e.getMessage(), e);
         }
@@ -233,10 +232,18 @@
      */
     public <T extends JCTree> void printExprs(List<T> trees) throws IOException {
         printExprs(trees, ", ");
     }
 
+
+    /** Derived visitor method: print pattern.
+     */
+
+    public void printPattern(JCTree tree) throws IOException {
+        printExpr(tree);
+    }
+
     /** Derived visitor method: print list of statements, each on a separate line.
      */
     public void printStats(List<? extends JCTree> trees) throws IOException {
         for (List<? extends JCTree> l = trees; l.nonEmpty(); l = l.tail) {
             align();
@@ -876,10 +883,20 @@
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
 
+    public void visitBindingPattern(JCBindingPattern patt) {
+        try {
+            printExpr(patt.vartype);
+            print(" ");
+            print(patt.name);
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
     public void visitSynchronized(JCSynchronized tree) {
         try {
             print("synchronized ");
             if (tree.lock.hasTag(PARENS)) {
                 printExpr(tree.lock);
@@ -980,11 +997,22 @@
     }
 
     public void visitBreak(JCBreak tree) {
         try {
             print("break");
-            if (tree.value != null) print(" " + tree.value);
+            if (tree.label != null) print(" " + tree.label);
+            print(";");
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
+        }
+    }
+
+    public void visitYield(JCYield tree) {
+        try {
+            print("yield");
+            print(" ");
+            printExpr(tree.value);
             print(";");
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
@@ -1271,11 +1299,15 @@
     public void visitTypeTest(JCInstanceOf tree) {
         try {
             open(prec, TreeInfo.ordPrec);
             printExpr(tree.expr, TreeInfo.ordPrec);
             print(" instanceof ");
-            printExpr(tree.clazz, TreeInfo.ordPrec + 1);
+            if (tree.pattern instanceof JCPattern) {
+                printPattern(tree.pattern);
+            } else {
+                printExpr(tree.getType(), TreeInfo.ordPrec + 1);
+            }
             close(prec, TreeInfo.ordPrec);
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }

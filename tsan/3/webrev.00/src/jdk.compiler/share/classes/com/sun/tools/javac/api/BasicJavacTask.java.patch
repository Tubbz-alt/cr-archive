diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/api/BasicJavacTask.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/api/BasicJavacTask.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/api/BasicJavacTask.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/api/BasicJavacTask.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,13 +41,15 @@
 import javax.tools.JavaFileObject;
 
 import com.sun.source.tree.CompilationUnitTree;
 import com.sun.source.tree.Tree;
 import com.sun.source.util.JavacTask;
+import com.sun.source.util.ParameterNameProvider;
 import com.sun.source.util.Plugin;
 import com.sun.source.util.TaskListener;
 import com.sun.tools.doclint.DocLint;
+import com.sun.tools.javac.code.MissingInfoHandler;
 import com.sun.tools.javac.main.JavaCompiler;
 import com.sun.tools.javac.model.JavacElements;
 import com.sun.tools.javac.model.JavacTypes;
 import com.sun.tools.javac.platform.PlatformDescription;
 import com.sun.tools.javac.platform.PlatformDescription.PluginInfo;
@@ -57,10 +59,12 @@
 import com.sun.tools.javac.util.Context;
 import com.sun.tools.javac.util.DefinedBy;
 import com.sun.tools.javac.util.DefinedBy.Api;
 import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.Log;
+import com.sun.tools.javac.util.ModuleHelper;
+import com.sun.tools.javac.util.Options;
 import com.sun.tools.javac.util.PropagatedException;
 
 /**
  * Provides basic functionality for implementations of JavacTask.
  *
@@ -69,10 +73,11 @@
  * risk.  This code and its internal interfaces are subject to change
  * or deletion without notice.</b></p>
  */
 public class BasicJavacTask extends JavacTask {
     protected Context context;
+    protected Options options;
     private TaskListener taskListener;
 
     public static JavacTask instance(Context context) {
         JavacTask instance = context.get(JavacTask.class);
         if (instance == null)
@@ -80,10 +85,11 @@
         return instance;
     }
 
     public BasicJavacTask(Context c, boolean register) {
         context = c;
+        options = Options.instance(c);
         if (register)
             context.put(JavacTask.class, this);
     }
 
     @Override @DefinedBy(Api.COMPILER_TREE)
@@ -121,10 +127,15 @@
     public void removeTaskListener(TaskListener taskListener) {
         MultiTaskListener mtl = MultiTaskListener.instance(context);
         mtl.remove(taskListener);
     }
 
+    @Override
+    public void setParameterNameProvider(ParameterNameProvider handler) {
+        MissingInfoHandler.instance(context).setDelegate(handler);
+    }
+
     public Collection<TaskListener> getTaskListeners() {
         MultiTaskListener mtl = MultiTaskListener.instance(context);
         return mtl.getTaskListeners();
     }
 
@@ -189,42 +200,60 @@
 
         if (platformProvider != null) {
             for (PluginInfo<Plugin> pluginDesc : platformProvider.getPlugins()) {
                 java.util.List<String> options =
                         pluginDesc.getOptions().entrySet().stream()
-                                                          .map(e -> e.getKey() + "=" + e.getValue())
-                                                          .collect(Collectors.toList());
+                                .map(e -> e.getKey() + "=" + e.getValue())
+                                .collect(Collectors.toList());
                 try {
-                    pluginDesc.getPlugin().init(this, options.toArray(new String[options.size()]));
+                    initPlugin(pluginDesc.getPlugin(), options.toArray(new String[options.size()]));
                 } catch (RuntimeException ex) {
                     throw new PropagatedException(ex);
                 }
             }
         }
 
-        if (pluginOpts.isEmpty())
-            return;
-
         Set<List<String>> pluginsToCall = new LinkedHashSet<>(pluginOpts);
         JavacProcessingEnvironment pEnv = JavacProcessingEnvironment.instance(context);
         ServiceLoader<Plugin> sl = pEnv.getServiceLoader(Plugin.class);
+        Set<Plugin> autoStart = new LinkedHashSet<>();
         for (Plugin plugin : sl) {
+            if (plugin.autoStart()) {
+                autoStart.add(plugin);
+            }
             for (List<String> p : pluginsToCall) {
                 if (plugin.getName().equals(p.head)) {
                     pluginsToCall.remove(p);
+                    autoStart.remove(plugin);
                     try {
-                        plugin.init(this, p.tail.toArray(new String[p.tail.size()]));
+                        initPlugin(plugin, p.tail.toArray(new String[p.tail.size()]));
                     } catch (RuntimeException ex) {
                         throw new PropagatedException(ex);
                     }
                     break;
                 }
             }
         }
-        for (List<String> p: pluginsToCall) {
+        for (List<String> p : pluginsToCall) {
             Log.instance(context).error(Errors.PluginNotFound(p.head));
         }
+        for (Plugin plugin : autoStart) {
+            try {
+                initPlugin(plugin, new String[0]);
+            } catch (RuntimeException ex) {
+                throw new PropagatedException(ex);
+            }
+
+        }
+    }
+
+    private void initPlugin(Plugin p, String... args) {
+        Module m = p.getClass().getModule();
+        if (m.isNamed() && options.isSet("accessInternalAPI")) {
+            ModuleHelper.addExports(getClass().getModule(), m);
+        }
+        p.init(this, args);
     }
 
     public void initDocLint(List<String> docLintOpts) {
         if (docLintOpts.isEmpty())
             return;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FSInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Locations.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.file;
  27 
  28 import java.io.File;
  29 import java.io.IOException;

  30 import java.lang.module.Configuration;
  31 import java.lang.module.ModuleFinder;
  32 import java.net.MalformedURLException;
  33 import java.net.URI;
  34 import java.net.URISyntaxException;
  35 import java.net.URL;
  36 import java.nio.CharBuffer;
  37 import java.nio.charset.Charset;
  38 import java.nio.file.FileSystem;
  39 import java.nio.file.FileSystems;
  40 import java.nio.file.FileVisitOption;
  41 import java.nio.file.FileVisitResult;
  42 import java.nio.file.Files;
  43 import java.nio.file.InvalidPathException;
  44 import java.nio.file.LinkOption;
  45 import java.nio.file.Path;
  46 import java.nio.file.Paths;
  47 import java.nio.file.ProviderNotFoundException;
  48 import java.nio.file.SimpleFileVisitor;
  49 import java.nio.file.attribute.BasicFileAttributes;
</pre>
<hr />
<pre>
  54 import java.util.Collections;
  55 import java.util.Comparator;
  56 import java.util.EnumSet;
  57 import java.util.HashMap;
  58 import java.util.Iterator;
  59 import java.util.Map;
  60 import java.util.Objects;
  61 import java.util.ServiceLoader;
  62 import java.util.Set;
  63 import java.util.stream.Collectors;
  64 import java.util.stream.Stream;
  65 
  66 import javax.lang.model.SourceVersion;
  67 import javax.tools.FileObject;
  68 import javax.tools.JavaFileManager;
  69 import javax.tools.JavaFileObject;
  70 import javax.tools.StandardJavaFileManager;
  71 
  72 import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
  73 import com.sun.tools.javac.file.RelativePath.RelativeFile;

  74 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  75 import com.sun.tools.javac.util.Assert;
  76 import com.sun.tools.javac.util.Context;
  77 import com.sun.tools.javac.util.Context.Factory;
  78 import com.sun.tools.javac.util.DefinedBy;
  79 import com.sun.tools.javac.util.DefinedBy.Api;
  80 import com.sun.tools.javac.util.List;
  81 import com.sun.tools.javac.util.ListBuffer;
  82 
  83 import static java.nio.file.FileVisitOption.FOLLOW_LINKS;
  84 
  85 import static javax.tools.StandardLocation.*;
  86 
  87 /**
  88  * This class provides access to the source, class and other files
  89  * used by the compiler and related tools.
  90  *
  91  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  92  * If you write code that depends on this, you do so at your own risk.
  93  * This code and its internal interfaces are subject to change or
</pre>
<hr />
<pre>
 111 
 112     private PathFactory pathFactory = Paths::get;
 113 
 114     protected enum SortFiles implements Comparator&lt;Path&gt; {
 115         FORWARD {
 116             @Override
 117             public int compare(Path f1, Path f2) {
 118                 return f1.getFileName().compareTo(f2.getFileName());
 119             }
 120         },
 121         REVERSE {
 122             @Override
 123             public int compare(Path f1, Path f2) {
 124                 return -f1.getFileName().compareTo(f2.getFileName());
 125             }
 126         }
 127     }
 128 
 129     protected SortFiles sortFiles;
 130 













 131     /**
 132      * Register a Context.Factory to create a JavacFileManager.
 133      */
 134     public static void preRegister(Context context) {
 135         context.put(JavaFileManager.class,
 136                 (Factory&lt;JavaFileManager&gt;)c -&gt; new JavacFileManager(c, true, null));
 137     }
 138 
 139     /**
 140      * Create a JavacFileManager using a given context, optionally registering
 141      * it as the JavaFileManager for that context.
 142      */
 143     public JavacFileManager(Context context, boolean register, Charset charset) {
 144         super(charset);
 145         if (register)
 146             context.put(JavaFileManager.class, this);
 147         setContext(context);
 148     }
 149 
 150     /**
</pre>
<hr />
<pre>
 321         }
 322 
 323         containers.put(realPath, fs);
 324         containers.put(path, fs);
 325 
 326         return fs;
 327     }
 328 
 329     private interface Container {
 330         /**
 331          * Insert all files in subdirectory subdirectory of container which
 332          * match fileKinds into resultList
 333          */
 334         public abstract void list(Path userPath,
 335                                   RelativeDirectory subdirectory,
 336                                   Set&lt;JavaFileObject.Kind&gt; fileKinds,
 337                                   boolean recurse,
 338                                   ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException;
 339         public abstract JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException;
 340         public abstract void close() throws IOException;







 341     }
 342 
 343     private static final Container MISSING_CONTAINER =  new Container() {
 344         @Override
 345         public void list(Path userPath,
 346                          RelativeDirectory subdirectory,
 347                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 348                          boolean recurse,
 349                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 350         }
 351         @Override
 352         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 353             return null;
 354         }
 355         @Override
 356         public void close() throws IOException {}








 357     };
 358 
 359     private final class JRTImageContainer implements Container {
 360 
 361         /**
 362          * Insert all files in a subdirectory of the platform image
 363          * which match fileKinds into resultList.
 364          */
 365         @Override
 366         public void list(Path userPath,
 367                          RelativeDirectory subdirectory,
 368                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 369                          boolean recurse,
 370                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 371             try {
 372                 JRTIndex.Entry e = getJRTIndex().getEntry(subdirectory);
 373                 if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 374                     return;
 375                 for (Path file: e.files.values()) {
 376                     if (fileKinds.contains(getKind(file))) {
</pre>
<hr />
<pre>
 390                 log.error(Errors.ErrorReadingFile(userPath, getMessage(ex)));
 391             }
 392         }
 393 
 394         @Override
 395         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 396             JRTIndex.Entry e = getJRTIndex().getEntry(name.dirname());
 397             if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 398                 return null;
 399             Path p = e.files.get(name.basename());
 400             if (p != null) {
 401                 return PathFileObject.forJRTPath(JavacFileManager.this, p);
 402             } else {
 403                 return null;
 404             }
 405         }
 406 
 407         @Override
 408         public void close() throws IOException {
 409         }










 410     }
 411 
 412     private synchronized JRTIndex getJRTIndex() {
 413         if (jrtIndex == null)
 414             jrtIndex = JRTIndex.getSharedInstance();
 415         return jrtIndex;
 416     }
 417 
 418     private JRTIndex jrtIndex;
 419 
 420     private final class DirectoryContainer implements Container {
 421         private final Path directory;
 422 
 423         public DirectoryContainer(Path directory) {
 424             this.directory = directory;
 425         }
 426 
 427         /**
 428          * Insert all files in subdirectory subdirectory of directory userPath
 429          * which match fileKinds into resultList
</pre>
<hr />
<pre>
 481                     }
 482                 }
 483             }
 484         }
 485 
 486         @Override
 487         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 488             try {
 489                 Path f = name.resolveAgainst(userPath);
 490                 if (Files.exists(f))
 491                     return PathFileObject.forSimplePath(JavacFileManager.this,
 492                             fsInfo.getCanonicalFile(f), f);
 493             } catch (InvalidPathException ignore) {
 494             }
 495             return null;
 496         }
 497 
 498         @Override
 499         public void close() throws IOException {
 500         }










 501     }
 502 
 503     private static final Set&lt;FileVisitOption&gt; NO_FILE_VISIT_OPTIONS = Set.of();
 504     private static final Set&lt;FileVisitOption&gt; FOLLOW_LINKS_OPTIONS = Set.of(FOLLOW_LINKS);
 505 
 506     private final class ArchiveContainer implements Container {
 507         private final Path archivePath;
 508         private final FileSystem fileSystem;
<span class="line-modified"> 509         private final Map&lt;RelativePath, Path&gt; packages;</span>
 510 
 511         public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {
 512             this.archivePath = archivePath;
 513             if (multiReleaseValue != null &amp;&amp; archivePath.toString().endsWith(&quot;.jar&quot;)) {
 514                 Map&lt;String,String&gt; env = Collections.singletonMap(&quot;multi-release&quot;, multiReleaseValue);
 515                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();
 516                 Assert.checkNonNull(jarFSProvider, &quot;should have been caught before!&quot;);
 517                 this.fileSystem = jarFSProvider.newFileSystem(archivePath, env);
 518             } else {
<span class="line-modified"> 519                 this.fileSystem = FileSystems.newFileSystem(archivePath, null);</span>
 520             }
 521             packages = new HashMap&lt;&gt;();
 522             for (Path root : fileSystem.getRootDirectories()) {
 523                 Files.walkFileTree(root, NO_FILE_VISIT_OPTIONS, Integer.MAX_VALUE,
 524                         new SimpleFileVisitor&lt;Path&gt;() {
 525                             @Override
 526                             public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
 527                                 if (isValid(dir.getFileName())) {
 528                                     packages.put(new RelativeDirectory(root.relativize(dir).toString()), dir);
 529                                     return FileVisitResult.CONTINUE;
 530                                 } else {
 531                                     return FileVisitResult.SKIP_SUBTREE;
 532                                 }
 533                             }
 534                         });
 535             }
 536         }
 537 
 538         /**
 539          * Insert all files in subdirectory subdirectory of this archive
</pre>
<hr />
<pre>
 587             }
 588         }
 589 
 590         @Override
 591         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 592             RelativeDirectory root = name.dirname();
 593             Path packagepath = packages.get(root);
 594             if (packagepath != null) {
 595                 Path relpath = packagepath.resolve(name.basename());
 596                 if (Files.exists(relpath)) {
 597                     return PathFileObject.forJarPath(JavacFileManager.this, relpath, userPath);
 598                 }
 599             }
 600             return null;
 601         }
 602 
 603         @Override
 604         public void close() throws IOException {
 605             fileSystem.close();
 606         }










 607     }
 608 
 609     /**
 610      * container is a directory, a zip file, or a non-existent path.
 611      */
 612     private boolean isValidFile(String s, Set&lt;JavaFileObject.Kind&gt; fileKinds) {
 613         JavaFileObject.Kind kind = getKind(s);
 614         return fileKinds.contains(kind);
 615     }
 616 
 617     private static final boolean fileSystemIsCaseSensitive =
 618         File.separatorChar == &#39;/&#39;;
 619 
 620     /** Hack to make Windows case sensitive. Test whether given path
 621      *  ends in a string of characters with the same case as given name.
 622      *  Ignore file separators in both path and name.
 623      */
 624     private boolean caseMapCheck(Path f, RelativePath name) {
 625         if (fileSystemIsCaseSensitive) return true;
 626         // Note that toRealPath() returns the case-sensitive
</pre>
<hr />
<pre>
 637         char[] ncs = name.path.toCharArray();
 638         int i = pcs.length - 1;
 639         int j = ncs.length - 1;
 640         while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 641             while (i &gt;= 0 &amp;&amp; pcs[i] == sep) i--;
 642             while (j &gt;= 0 &amp;&amp; ncs[j] == &#39;/&#39;) j--;
 643             if (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 644                 if (pcs[i] != ncs[j]) return false;
 645                 i--;
 646                 j--;
 647             }
 648         }
 649         return j &lt; 0;
 650     }
 651 
 652     /** Flush any output resources.
 653      */
 654     @Override @DefinedBy(Api.COMPILER)
 655     public void flush() {
 656         contentCache.clear();


 657     }
 658 
 659     /**
 660      * Close the JavaFileManager, releasing resources.
 661      */
 662     @Override @DefinedBy(Api.COMPILER)
 663     public void close() throws IOException {
 664         if (deferredCloseTimeout &gt; 0) {
 665             deferredClose();
 666             return;
 667         }
 668 
 669         locations.close();
 670         for (Container container: containers.values()) {
 671             container.close();
 672         }
 673         containers.clear();


 674         contentCache.clear();
 675     }
 676 
 677     @Override @DefinedBy(Api.COMPILER)
 678     public ClassLoader getClassLoader(Location location) {
 679         checkNotModuleOrientedLocation(location);
 680         Iterable&lt;? extends File&gt; path = getLocation(location);
 681         if (path == null)
 682             return null;
 683         ListBuffer&lt;URL&gt; lb = new ListBuffer&lt;&gt;();
 684         for (File f: path) {
 685             try {
 686                 lb.append(f.toURI().toURL());
 687             } catch (MalformedURLException e) {
 688                 throw new AssertionError(e);
 689             }
 690         }
 691 
 692         return getClassLoader(lb.toArray(new URL[lb.size()]));
 693     }
 694 
 695     @Override @DefinedBy(Api.COMPILER)
 696     public Iterable&lt;JavaFileObject&gt; list(Location location,
 697                                          String packageName,
 698                                          Set&lt;JavaFileObject.Kind&gt; kinds,
 699                                          boolean recurse)
 700         throws IOException
 701     {
 702         checkNotModuleOrientedLocation(location);
 703         // validatePackageName(packageName);
 704         nullCheck(packageName);
 705         nullCheck(kinds);
 706 
<span class="line-removed"> 707         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);</span>
<span class="line-removed"> 708         if (path == null)</span>
<span class="line-removed"> 709             return List.nil();</span>
 710         RelativeDirectory subdirectory = RelativeDirectory.forPackage(packageName);
 711         ListBuffer&lt;JavaFileObject&gt; results = new ListBuffer&lt;&gt;();
 712 
<span class="line-modified"> 713         for (Path directory : path) {</span>
<span class="line-modified"> 714             Container container = getContainer(directory);</span>
<span class="line-modified"> 715 </span>
 716             container.list(directory, subdirectory, kinds, recurse, results);
 717         }
 718 
 719         return results.toList();
 720     }
 721 
 722     @Override @DefinedBy(Api.COMPILER)
 723     public String inferBinaryName(Location location, JavaFileObject file) {
 724         checkNotModuleOrientedLocation(location);
 725         Objects.requireNonNull(file);
 726         // Need to match the path semantics of list(location, ...)
 727         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);
 728         if (path == null) {
 729             return null;
 730         }
 731 
 732         if (file instanceof PathFileObject) {
 733             return ((PathFileObject) file).inferBinaryName(path);
 734         } else
 735             throw new IllegalArgumentException(file.getClass().getName());
</pre>
<hr />
<pre>
 880     @Override @DefinedBy(Api.COMPILER)
 881     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromFiles(
 882         Iterable&lt;? extends File&gt; files)
 883     {
 884         ArrayList&lt;PathFileObject&gt; result;
 885         if (files instanceof Collection&lt;?&gt;)
 886             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)files).size());
 887         else
 888             result = new ArrayList&lt;&gt;();
 889         for (File f: files) {
 890             Objects.requireNonNull(f);
 891             Path p = f.toPath();
 892             result.add(PathFileObject.forSimplePath(this,
 893                     fsInfo.getCanonicalFile(p), p));
 894         }
 895         return result;
 896     }
 897 
 898     @Override @DefinedBy(Api.COMPILER)
 899     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(
<span class="line-modified"> 900         Iterable&lt;? extends Path&gt; paths)</span>
 901     {
 902         ArrayList&lt;PathFileObject&gt; result;
 903         if (paths instanceof Collection&lt;?&gt;)
 904             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)paths).size());
 905         else
 906             result = new ArrayList&lt;&gt;();
 907         for (Path p: paths)
 908             result.add(PathFileObject.forSimplePath(this,
 909                     fsInfo.getCanonicalFile(p), p));
 910         return result;
 911     }
 912 
 913     @Override @DefinedBy(Api.COMPILER)
 914     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(File... files) {
 915         return getJavaFileObjectsFromFiles(Arrays.asList(nullCheck(files)));
 916     }
 917 
 918     @Override @DefinedBy(Api.COMPILER)
 919     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(Path... paths) {
 920         return getJavaFileObjectsFromPaths(Arrays.asList(nullCheck(paths)));
 921     }
 922 
 923     @Override @DefinedBy(Api.COMPILER)
 924     public void setLocation(Location location,
 925                             Iterable&lt;? extends File&gt; searchpath)
 926         throws IOException
 927     {
 928         nullCheck(location);
 929         locations.setLocation(location, asPaths(searchpath));

 930     }
 931 
 932     @Override @DefinedBy(Api.COMPILER)
 933     public void setLocationFromPaths(Location location,
 934                             Collection&lt;? extends Path&gt; searchpath)
 935         throws IOException
 936     {
 937         nullCheck(location);
 938         locations.setLocation(location, nullCheck(searchpath));

 939     }
 940 
 941     @Override @DefinedBy(Api.COMPILER)
 942     public Iterable&lt;? extends File&gt; getLocation(Location location) {
 943         nullCheck(location);
 944         return asFiles(locations.getLocation(location));
 945     }
 946 
 947     @Override @DefinedBy(Api.COMPILER)
<span class="line-modified"> 948     public Iterable&lt;? extends Path&gt; getLocationAsPaths(Location location) {</span>
 949         nullCheck(location);
 950         return locations.getLocation(location);
 951     }
 952 






































































































 953     @Override @DefinedBy(Api.COMPILER)
 954     public boolean contains(Location location, FileObject fo) throws IOException {
 955         nullCheck(location);
 956         nullCheck(fo);
 957         Path p = asPath(fo);
 958         return locations.contains(location, p);
 959     }
 960 
 961     private Path getClassOutDir() {
 962         return locations.getOutputLocation(CLASS_OUTPUT);
 963     }
 964 
 965     private Path getSourceOutDir() {
 966         return locations.getOutputLocation(SOURCE_OUTPUT);
 967     }
 968 
 969     @Override @DefinedBy(Api.COMPILER)
 970     public Location getLocationForModule(Location location, String moduleName) throws IOException {
 971         checkModuleOrientedOrOutputLocation(location);
 972         nullCheck(moduleName);
</pre>
<hr />
<pre>
 991             return ServiceLoader.load(service, getClassLoader(location));
 992         }
 993     }
 994 
 995     @Override @DefinedBy(Api.COMPILER)
 996     public Location getLocationForModule(Location location, JavaFileObject fo) throws IOException {
 997         checkModuleOrientedOrOutputLocation(location);
 998         if (!(fo instanceof PathFileObject))
 999             return null;
1000         Path p = Locations.normalize(((PathFileObject) fo).path);
1001             // need to find p in location
1002         return locations.getLocationForModule(location, p);
1003     }
1004 
1005     @Override @DefinedBy(Api.COMPILER)
1006     public void setLocationForModule(Location location, String moduleName, Collection&lt;? extends Path&gt; paths)
1007             throws IOException {
1008         nullCheck(location);
1009         checkModuleOrientedOrOutputLocation(location);
1010         locations.setLocationForModule(location, nullCheck(moduleName), nullCheck(paths));

1011     }
1012 
1013     @Override @DefinedBy(Api.COMPILER)
1014     public String inferModuleName(Location location) {
1015         checkNotModuleOrientedLocation(location);
1016         return locations.inferModuleName(location);
1017     }
1018 
1019     @Override @DefinedBy(Api.COMPILER)
1020     public Iterable&lt;Set&lt;Location&gt;&gt; listLocationsForModules(Location location) throws IOException {
1021         checkModuleOrientedOrOutputLocation(location);
1022         return locations.listLocationsForModules(location);
1023     }
1024 
1025     @Override @DefinedBy(Api.COMPILER)
1026     public Path asPath(FileObject file) {
1027         if (file instanceof PathFileObject) {
1028             return ((PathFileObject) file).path;
1029         } else
1030             throw new IllegalArgumentException(file.getName());
</pre>
<hr />
<pre>
1066      * used.
1067      * @param file a relative file name
1068      * @return a relative URI
1069      * @throws IllegalArgumentException if the file name is not
1070      * relative according to the definition given in {@link
1071      * javax.tools.JavaFileManager#getFileForInput}
1072      */
1073     public static String getRelativeName(File file) {
1074         if (!file.isAbsolute()) {
1075             String result = file.getPath().replace(File.separatorChar, &#39;/&#39;);
1076             if (isRelativeUri(result))
1077                 return result;
1078         }
1079         throw new IllegalArgumentException(&quot;Invalid relative path: &quot; + file);
1080     }
1081 
1082     /**
1083      * Get a detail message from an IOException.
1084      * Most, but not all, instances of IOException provide a non-null result
1085      * for getLocalizedMessage().  But some instances return null: in these
<span class="line-modified">1086      * cases, fallover to getMessage(), and if even that is null, return the</span>
1087      * name of the exception itself.
1088      * @param e an IOException
1089      * @return a string to include in a compiler diagnostic
1090      */
1091     public static String getMessage(IOException e) {
1092         String s = e.getLocalizedMessage();
1093         if (s != null)
1094             return s;
1095         s = e.getMessage();
1096         if (s != null)
1097             return s;
1098         return e.toString();
1099     }
1100 
1101     private void checkOutputLocation(Location location) {
1102         Objects.requireNonNull(location);
1103         if (!location.isOutputLocation())
1104             throw new IllegalArgumentException(&quot;location is not an output location: &quot; + location.getName());
1105     }
1106 
</pre>
<hr />
<pre>
1146             return null;
1147 
1148         return () -&gt; new Iterator&lt;File&gt;() {
1149             Iterator&lt;? extends Path&gt; iter = paths.iterator();
1150 
1151             @Override
1152             public boolean hasNext() {
1153                 return iter.hasNext();
1154             }
1155 
1156             @Override
1157             public File next() {
1158                 try {
1159                     return iter.next().toFile();
1160                 } catch (UnsupportedOperationException e) {
1161                     throw new IllegalStateException(e);
1162                 }
1163             }
1164         };
1165     }















1166 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.file;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
<span class="line-added">  30 import java.io.UncheckedIOException;</span>
  31 import java.lang.module.Configuration;
  32 import java.lang.module.ModuleFinder;
  33 import java.net.MalformedURLException;
  34 import java.net.URI;
  35 import java.net.URISyntaxException;
  36 import java.net.URL;
  37 import java.nio.CharBuffer;
  38 import java.nio.charset.Charset;
  39 import java.nio.file.FileSystem;
  40 import java.nio.file.FileSystems;
  41 import java.nio.file.FileVisitOption;
  42 import java.nio.file.FileVisitResult;
  43 import java.nio.file.Files;
  44 import java.nio.file.InvalidPathException;
  45 import java.nio.file.LinkOption;
  46 import java.nio.file.Path;
  47 import java.nio.file.Paths;
  48 import java.nio.file.ProviderNotFoundException;
  49 import java.nio.file.SimpleFileVisitor;
  50 import java.nio.file.attribute.BasicFileAttributes;
</pre>
<hr />
<pre>
  55 import java.util.Collections;
  56 import java.util.Comparator;
  57 import java.util.EnumSet;
  58 import java.util.HashMap;
  59 import java.util.Iterator;
  60 import java.util.Map;
  61 import java.util.Objects;
  62 import java.util.ServiceLoader;
  63 import java.util.Set;
  64 import java.util.stream.Collectors;
  65 import java.util.stream.Stream;
  66 
  67 import javax.lang.model.SourceVersion;
  68 import javax.tools.FileObject;
  69 import javax.tools.JavaFileManager;
  70 import javax.tools.JavaFileObject;
  71 import javax.tools.StandardJavaFileManager;
  72 
  73 import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
  74 import com.sun.tools.javac.file.RelativePath.RelativeFile;
<span class="line-added">  75 import com.sun.tools.javac.main.Option;</span>
  76 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  77 import com.sun.tools.javac.util.Assert;
  78 import com.sun.tools.javac.util.Context;
  79 import com.sun.tools.javac.util.Context.Factory;
  80 import com.sun.tools.javac.util.DefinedBy;
  81 import com.sun.tools.javac.util.DefinedBy.Api;
  82 import com.sun.tools.javac.util.List;
  83 import com.sun.tools.javac.util.ListBuffer;
  84 
  85 import static java.nio.file.FileVisitOption.FOLLOW_LINKS;
  86 
  87 import static javax.tools.StandardLocation.*;
  88 
  89 /**
  90  * This class provides access to the source, class and other files
  91  * used by the compiler and related tools.
  92  *
  93  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  94  * If you write code that depends on this, you do so at your own risk.
  95  * This code and its internal interfaces are subject to change or
</pre>
<hr />
<pre>
 113 
 114     private PathFactory pathFactory = Paths::get;
 115 
 116     protected enum SortFiles implements Comparator&lt;Path&gt; {
 117         FORWARD {
 118             @Override
 119             public int compare(Path f1, Path f2) {
 120                 return f1.getFileName().compareTo(f2.getFileName());
 121             }
 122         },
 123         REVERSE {
 124             @Override
 125             public int compare(Path f1, Path f2) {
 126                 return -f1.getFileName().compareTo(f2.getFileName());
 127             }
 128         }
 129     }
 130 
 131     protected SortFiles sortFiles;
 132 
<span class="line-added"> 133     /**</span>
<span class="line-added"> 134      * We use a two-layered map instead of a map with a complex key because we don&#39;t want to reindex</span>
<span class="line-added"> 135      * the values for every Location+RelativeDirectory pair. Once the PathsAndContainers are needed</span>
<span class="line-added"> 136      * for a single Location, we should know all valid RelativeDirectory mappings. Because the</span>
<span class="line-added"> 137      * indexing is costly for very large classpaths, this can result in a significant savings.</span>
<span class="line-added"> 138      */</span>
<span class="line-added"> 139     private Map&lt;Location, Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt;&gt;</span>
<span class="line-added"> 140         pathsAndContainersByLocationAndRelativeDirectory = new HashMap&lt;&gt;();</span>
<span class="line-added"> 141 </span>
<span class="line-added"> 142     /** Containers that have no indexing by {@link RelativeDirectory}, keyed by {@link Location}. */</span>
<span class="line-added"> 143     private Map&lt;Location, java.util.List&lt;PathAndContainer&gt;&gt; nonIndexingContainersByLocation =</span>
<span class="line-added"> 144         new HashMap&lt;&gt;();</span>
<span class="line-added"> 145 </span>
 146     /**
 147      * Register a Context.Factory to create a JavacFileManager.
 148      */
 149     public static void preRegister(Context context) {
 150         context.put(JavaFileManager.class,
 151                 (Factory&lt;JavaFileManager&gt;)c -&gt; new JavacFileManager(c, true, null));
 152     }
 153 
 154     /**
 155      * Create a JavacFileManager using a given context, optionally registering
 156      * it as the JavaFileManager for that context.
 157      */
 158     public JavacFileManager(Context context, boolean register, Charset charset) {
 159         super(charset);
 160         if (register)
 161             context.put(JavaFileManager.class, this);
 162         setContext(context);
 163     }
 164 
 165     /**
</pre>
<hr />
<pre>
 336         }
 337 
 338         containers.put(realPath, fs);
 339         containers.put(path, fs);
 340 
 341         return fs;
 342     }
 343 
 344     private interface Container {
 345         /**
 346          * Insert all files in subdirectory subdirectory of container which
 347          * match fileKinds into resultList
 348          */
 349         public abstract void list(Path userPath,
 350                                   RelativeDirectory subdirectory,
 351                                   Set&lt;JavaFileObject.Kind&gt; fileKinds,
 352                                   boolean recurse,
 353                                   ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException;
 354         public abstract JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException;
 355         public abstract void close() throws IOException;
<span class="line-added"> 356         public abstract boolean maintainsDirectoryIndex();</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358         /**</span>
<span class="line-added"> 359          * The directories this container indexes if {@link #maintainsDirectoryIndex()}, otherwise</span>
<span class="line-added"> 360          * an empty iterable.</span>
<span class="line-added"> 361          */</span>
<span class="line-added"> 362         public abstract Iterable&lt;RelativeDirectory&gt; indexedDirectories();</span>
 363     }
 364 
 365     private static final Container MISSING_CONTAINER =  new Container() {
 366         @Override
 367         public void list(Path userPath,
 368                          RelativeDirectory subdirectory,
 369                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 370                          boolean recurse,
 371                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 372         }
 373         @Override
 374         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 375             return null;
 376         }
 377         @Override
 378         public void close() throws IOException {}
<span class="line-added"> 379         @Override</span>
<span class="line-added"> 380         public boolean maintainsDirectoryIndex() {</span>
<span class="line-added"> 381             return false;</span>
<span class="line-added"> 382         }</span>
<span class="line-added"> 383         @Override</span>
<span class="line-added"> 384         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="line-added"> 385             return List.nil();</span>
<span class="line-added"> 386         }</span>
 387     };
 388 
 389     private final class JRTImageContainer implements Container {
 390 
 391         /**
 392          * Insert all files in a subdirectory of the platform image
 393          * which match fileKinds into resultList.
 394          */
 395         @Override
 396         public void list(Path userPath,
 397                          RelativeDirectory subdirectory,
 398                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 399                          boolean recurse,
 400                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 401             try {
 402                 JRTIndex.Entry e = getJRTIndex().getEntry(subdirectory);
 403                 if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 404                     return;
 405                 for (Path file: e.files.values()) {
 406                     if (fileKinds.contains(getKind(file))) {
</pre>
<hr />
<pre>
 420                 log.error(Errors.ErrorReadingFile(userPath, getMessage(ex)));
 421             }
 422         }
 423 
 424         @Override
 425         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 426             JRTIndex.Entry e = getJRTIndex().getEntry(name.dirname());
 427             if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 428                 return null;
 429             Path p = e.files.get(name.basename());
 430             if (p != null) {
 431                 return PathFileObject.forJRTPath(JavacFileManager.this, p);
 432             } else {
 433                 return null;
 434             }
 435         }
 436 
 437         @Override
 438         public void close() throws IOException {
 439         }
<span class="line-added"> 440 </span>
<span class="line-added"> 441         @Override</span>
<span class="line-added"> 442         public boolean maintainsDirectoryIndex() {</span>
<span class="line-added"> 443             return false;</span>
<span class="line-added"> 444         }</span>
<span class="line-added"> 445 </span>
<span class="line-added"> 446         @Override</span>
<span class="line-added"> 447         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="line-added"> 448             return List.nil();</span>
<span class="line-added"> 449         }</span>
 450     }
 451 
 452     private synchronized JRTIndex getJRTIndex() {
 453         if (jrtIndex == null)
 454             jrtIndex = JRTIndex.getSharedInstance();
 455         return jrtIndex;
 456     }
 457 
 458     private JRTIndex jrtIndex;
 459 
 460     private final class DirectoryContainer implements Container {
 461         private final Path directory;
 462 
 463         public DirectoryContainer(Path directory) {
 464             this.directory = directory;
 465         }
 466 
 467         /**
 468          * Insert all files in subdirectory subdirectory of directory userPath
 469          * which match fileKinds into resultList
</pre>
<hr />
<pre>
 521                     }
 522                 }
 523             }
 524         }
 525 
 526         @Override
 527         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 528             try {
 529                 Path f = name.resolveAgainst(userPath);
 530                 if (Files.exists(f))
 531                     return PathFileObject.forSimplePath(JavacFileManager.this,
 532                             fsInfo.getCanonicalFile(f), f);
 533             } catch (InvalidPathException ignore) {
 534             }
 535             return null;
 536         }
 537 
 538         @Override
 539         public void close() throws IOException {
 540         }
<span class="line-added"> 541 </span>
<span class="line-added"> 542         @Override</span>
<span class="line-added"> 543         public boolean maintainsDirectoryIndex() {</span>
<span class="line-added"> 544             return false;</span>
<span class="line-added"> 545         }</span>
<span class="line-added"> 546 </span>
<span class="line-added"> 547         @Override</span>
<span class="line-added"> 548         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="line-added"> 549             return List.nil();</span>
<span class="line-added"> 550         }</span>
 551     }
 552 
 553     private static final Set&lt;FileVisitOption&gt; NO_FILE_VISIT_OPTIONS = Set.of();
 554     private static final Set&lt;FileVisitOption&gt; FOLLOW_LINKS_OPTIONS = Set.of(FOLLOW_LINKS);
 555 
 556     private final class ArchiveContainer implements Container {
 557         private final Path archivePath;
 558         private final FileSystem fileSystem;
<span class="line-modified"> 559         private final Map&lt;RelativeDirectory, Path&gt; packages;</span>
 560 
 561         public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {
 562             this.archivePath = archivePath;
 563             if (multiReleaseValue != null &amp;&amp; archivePath.toString().endsWith(&quot;.jar&quot;)) {
 564                 Map&lt;String,String&gt; env = Collections.singletonMap(&quot;multi-release&quot;, multiReleaseValue);
 565                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();
 566                 Assert.checkNonNull(jarFSProvider, &quot;should have been caught before!&quot;);
 567                 this.fileSystem = jarFSProvider.newFileSystem(archivePath, env);
 568             } else {
<span class="line-modified"> 569                 this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);</span>
 570             }
 571             packages = new HashMap&lt;&gt;();
 572             for (Path root : fileSystem.getRootDirectories()) {
 573                 Files.walkFileTree(root, NO_FILE_VISIT_OPTIONS, Integer.MAX_VALUE,
 574                         new SimpleFileVisitor&lt;Path&gt;() {
 575                             @Override
 576                             public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
 577                                 if (isValid(dir.getFileName())) {
 578                                     packages.put(new RelativeDirectory(root.relativize(dir).toString()), dir);
 579                                     return FileVisitResult.CONTINUE;
 580                                 } else {
 581                                     return FileVisitResult.SKIP_SUBTREE;
 582                                 }
 583                             }
 584                         });
 585             }
 586         }
 587 
 588         /**
 589          * Insert all files in subdirectory subdirectory of this archive
</pre>
<hr />
<pre>
 637             }
 638         }
 639 
 640         @Override
 641         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 642             RelativeDirectory root = name.dirname();
 643             Path packagepath = packages.get(root);
 644             if (packagepath != null) {
 645                 Path relpath = packagepath.resolve(name.basename());
 646                 if (Files.exists(relpath)) {
 647                     return PathFileObject.forJarPath(JavacFileManager.this, relpath, userPath);
 648                 }
 649             }
 650             return null;
 651         }
 652 
 653         @Override
 654         public void close() throws IOException {
 655             fileSystem.close();
 656         }
<span class="line-added"> 657 </span>
<span class="line-added"> 658         @Override</span>
<span class="line-added"> 659         public boolean maintainsDirectoryIndex() {</span>
<span class="line-added"> 660             return true;</span>
<span class="line-added"> 661         }</span>
<span class="line-added"> 662 </span>
<span class="line-added"> 663         @Override</span>
<span class="line-added"> 664         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {</span>
<span class="line-added"> 665             return packages.keySet();</span>
<span class="line-added"> 666         }</span>
 667     }
 668 
 669     /**
 670      * container is a directory, a zip file, or a non-existent path.
 671      */
 672     private boolean isValidFile(String s, Set&lt;JavaFileObject.Kind&gt; fileKinds) {
 673         JavaFileObject.Kind kind = getKind(s);
 674         return fileKinds.contains(kind);
 675     }
 676 
 677     private static final boolean fileSystemIsCaseSensitive =
 678         File.separatorChar == &#39;/&#39;;
 679 
 680     /** Hack to make Windows case sensitive. Test whether given path
 681      *  ends in a string of characters with the same case as given name.
 682      *  Ignore file separators in both path and name.
 683      */
 684     private boolean caseMapCheck(Path f, RelativePath name) {
 685         if (fileSystemIsCaseSensitive) return true;
 686         // Note that toRealPath() returns the case-sensitive
</pre>
<hr />
<pre>
 697         char[] ncs = name.path.toCharArray();
 698         int i = pcs.length - 1;
 699         int j = ncs.length - 1;
 700         while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 701             while (i &gt;= 0 &amp;&amp; pcs[i] == sep) i--;
 702             while (j &gt;= 0 &amp;&amp; ncs[j] == &#39;/&#39;) j--;
 703             if (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 704                 if (pcs[i] != ncs[j]) return false;
 705                 i--;
 706                 j--;
 707             }
 708         }
 709         return j &lt; 0;
 710     }
 711 
 712     /** Flush any output resources.
 713      */
 714     @Override @DefinedBy(Api.COMPILER)
 715     public void flush() {
 716         contentCache.clear();
<span class="line-added"> 717         pathsAndContainersByLocationAndRelativeDirectory.clear();</span>
<span class="line-added"> 718         nonIndexingContainersByLocation.clear();</span>
 719     }
 720 
 721     /**
 722      * Close the JavaFileManager, releasing resources.
 723      */
 724     @Override @DefinedBy(Api.COMPILER)
 725     public void close() throws IOException {
 726         if (deferredCloseTimeout &gt; 0) {
 727             deferredClose();
 728             return;
 729         }
 730 
 731         locations.close();
 732         for (Container container: containers.values()) {
 733             container.close();
 734         }
 735         containers.clear();
<span class="line-added"> 736         pathsAndContainersByLocationAndRelativeDirectory.clear();</span>
<span class="line-added"> 737         nonIndexingContainersByLocation.clear();</span>
 738         contentCache.clear();
 739     }
 740 
 741     @Override @DefinedBy(Api.COMPILER)
 742     public ClassLoader getClassLoader(Location location) {
 743         checkNotModuleOrientedLocation(location);
 744         Iterable&lt;? extends File&gt; path = getLocation(location);
 745         if (path == null)
 746             return null;
 747         ListBuffer&lt;URL&gt; lb = new ListBuffer&lt;&gt;();
 748         for (File f: path) {
 749             try {
 750                 lb.append(f.toURI().toURL());
 751             } catch (MalformedURLException e) {
 752                 throw new AssertionError(e);
 753             }
 754         }
 755 
 756         return getClassLoader(lb.toArray(new URL[lb.size()]));
 757     }
 758 
 759     @Override @DefinedBy(Api.COMPILER)
 760     public Iterable&lt;JavaFileObject&gt; list(Location location,
 761                                          String packageName,
 762                                          Set&lt;JavaFileObject.Kind&gt; kinds,
 763                                          boolean recurse)
 764         throws IOException
 765     {
 766         checkNotModuleOrientedLocation(location);
 767         // validatePackageName(packageName);
 768         nullCheck(packageName);
 769         nullCheck(kinds);
 770 



 771         RelativeDirectory subdirectory = RelativeDirectory.forPackage(packageName);
 772         ListBuffer&lt;JavaFileObject&gt; results = new ListBuffer&lt;&gt;();
 773 
<span class="line-modified"> 774         for (PathAndContainer pathAndContainer : pathsAndContainers(location, subdirectory)) {</span>
<span class="line-modified"> 775             Path directory = pathAndContainer.path;</span>
<span class="line-modified"> 776             Container container = pathAndContainer.container;</span>
 777             container.list(directory, subdirectory, kinds, recurse, results);
 778         }
 779 
 780         return results.toList();
 781     }
 782 
 783     @Override @DefinedBy(Api.COMPILER)
 784     public String inferBinaryName(Location location, JavaFileObject file) {
 785         checkNotModuleOrientedLocation(location);
 786         Objects.requireNonNull(file);
 787         // Need to match the path semantics of list(location, ...)
 788         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);
 789         if (path == null) {
 790             return null;
 791         }
 792 
 793         if (file instanceof PathFileObject) {
 794             return ((PathFileObject) file).inferBinaryName(path);
 795         } else
 796             throw new IllegalArgumentException(file.getClass().getName());
</pre>
<hr />
<pre>
 941     @Override @DefinedBy(Api.COMPILER)
 942     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromFiles(
 943         Iterable&lt;? extends File&gt; files)
 944     {
 945         ArrayList&lt;PathFileObject&gt; result;
 946         if (files instanceof Collection&lt;?&gt;)
 947             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)files).size());
 948         else
 949             result = new ArrayList&lt;&gt;();
 950         for (File f: files) {
 951             Objects.requireNonNull(f);
 952             Path p = f.toPath();
 953             result.add(PathFileObject.forSimplePath(this,
 954                     fsInfo.getCanonicalFile(p), p));
 955         }
 956         return result;
 957     }
 958 
 959     @Override @DefinedBy(Api.COMPILER)
 960     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(
<span class="line-modified"> 961         Collection&lt;? extends Path&gt; paths)</span>
 962     {
 963         ArrayList&lt;PathFileObject&gt; result;
 964         if (paths instanceof Collection&lt;?&gt;)
 965             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)paths).size());
 966         else
 967             result = new ArrayList&lt;&gt;();
 968         for (Path p: paths)
 969             result.add(PathFileObject.forSimplePath(this,
 970                     fsInfo.getCanonicalFile(p), p));
 971         return result;
 972     }
 973 
 974     @Override @DefinedBy(Api.COMPILER)
 975     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(File... files) {
 976         return getJavaFileObjectsFromFiles(Arrays.asList(nullCheck(files)));
 977     }
 978 
 979     @Override @DefinedBy(Api.COMPILER)
 980     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(Path... paths) {
 981         return getJavaFileObjectsFromPaths(Arrays.asList(nullCheck(paths)));
 982     }
 983 
 984     @Override @DefinedBy(Api.COMPILER)
 985     public void setLocation(Location location,
 986                             Iterable&lt;? extends File&gt; searchpath)
 987         throws IOException
 988     {
 989         nullCheck(location);
 990         locations.setLocation(location, asPaths(searchpath));
<span class="line-added"> 991         clearCachesForLocation(location);</span>
 992     }
 993 
 994     @Override @DefinedBy(Api.COMPILER)
 995     public void setLocationFromPaths(Location location,
 996                             Collection&lt;? extends Path&gt; searchpath)
 997         throws IOException
 998     {
 999         nullCheck(location);
1000         locations.setLocation(location, nullCheck(searchpath));
<span class="line-added">1001         clearCachesForLocation(location);</span>
1002     }
1003 
1004     @Override @DefinedBy(Api.COMPILER)
1005     public Iterable&lt;? extends File&gt; getLocation(Location location) {
1006         nullCheck(location);
1007         return asFiles(locations.getLocation(location));
1008     }
1009 
1010     @Override @DefinedBy(Api.COMPILER)
<span class="line-modified">1011     public Collection&lt;? extends Path&gt; getLocationAsPaths(Location location) {</span>
1012         nullCheck(location);
1013         return locations.getLocation(location);
1014     }
1015 
<span class="line-added">1016     private java.util.List&lt;PathAndContainer&gt; pathsAndContainers(</span>
<span class="line-added">1017             Location location, RelativeDirectory relativeDirectory) throws IOException {</span>
<span class="line-added">1018         try {</span>
<span class="line-added">1019             return pathsAndContainersByLocationAndRelativeDirectory.computeIfAbsent(</span>
<span class="line-added">1020                     location, this::indexPathsAndContainersByRelativeDirectory)</span>
<span class="line-added">1021                 .computeIfAbsent(</span>
<span class="line-added">1022                     relativeDirectory, d -&gt; nonIndexingContainersByLocation.get(location));</span>
<span class="line-added">1023         } catch (UncheckedIOException e) {</span>
<span class="line-added">1024             throw e.getCause();</span>
<span class="line-added">1025         }</span>
<span class="line-added">1026     }</span>
<span class="line-added">1027 </span>
<span class="line-added">1028     private Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt; indexPathsAndContainersByRelativeDirectory(</span>
<span class="line-added">1029             Location location) {</span>
<span class="line-added">1030         Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt; result = new HashMap&lt;&gt;();</span>
<span class="line-added">1031         java.util.List&lt;PathAndContainer&gt; allPathsAndContainers = pathsAndContainers(location);</span>
<span class="line-added">1032 </span>
<span class="line-added">1033         // First collect all of the containers that don&#39;t maintain their own index on</span>
<span class="line-added">1034         // RelativeDirectory. These need to always be included for all mappings</span>
<span class="line-added">1035         java.util.List&lt;PathAndContainer&gt; nonIndexingContainers = new ArrayList&lt;&gt;();</span>
<span class="line-added">1036         for (PathAndContainer pathAndContainer : allPathsAndContainers) {</span>
<span class="line-added">1037             if (!pathAndContainer.container.maintainsDirectoryIndex()) {</span>
<span class="line-added">1038                 nonIndexingContainers.add(pathAndContainer);</span>
<span class="line-added">1039             }</span>
<span class="line-added">1040         }</span>
<span class="line-added">1041 </span>
<span class="line-added">1042         // Next, use the container that do maintain their own RelativeDirectory index to create a</span>
<span class="line-added">1043         // single master index.</span>
<span class="line-added">1044         for (PathAndContainer pathAndContainer : allPathsAndContainers) {</span>
<span class="line-added">1045             Container container = pathAndContainer.container;</span>
<span class="line-added">1046             if (container.maintainsDirectoryIndex()) {</span>
<span class="line-added">1047                 for (RelativeDirectory directory : container.indexedDirectories()) {</span>
<span class="line-added">1048                     result.computeIfAbsent(directory, d -&gt; new ArrayList&lt;&gt;(nonIndexingContainers))</span>
<span class="line-added">1049                           .add(pathAndContainer);</span>
<span class="line-added">1050                 }</span>
<span class="line-added">1051             }</span>
<span class="line-added">1052         }</span>
<span class="line-added">1053         nonIndexingContainersByLocation.put(location, nonIndexingContainers);</span>
<span class="line-added">1054 </span>
<span class="line-added">1055         // Sorting preserves the search order used in the uncached Location path, which has</span>
<span class="line-added">1056         // maintains consistency with the classpath order</span>
<span class="line-added">1057         result.values().forEach(pathAndContainerList -&gt; Collections.sort(pathAndContainerList));</span>
<span class="line-added">1058 </span>
<span class="line-added">1059         return result;</span>
<span class="line-added">1060     }</span>
<span class="line-added">1061 </span>
<span class="line-added">1062     /**</span>
<span class="line-added">1063      * For each {@linkplain #getLocationAsPaths(Location) path of the location}, compute the</span>
<span class="line-added">1064      * corresponding {@link Container}.</span>
<span class="line-added">1065      */</span>
<span class="line-added">1066     private java.util.List&lt;PathAndContainer&gt; pathsAndContainers(Location location) {</span>
<span class="line-added">1067         Collection&lt;? extends Path&gt; paths = getLocationAsPaths(location);</span>
<span class="line-added">1068         if (paths == null) {</span>
<span class="line-added">1069             return List.nil();</span>
<span class="line-added">1070         }</span>
<span class="line-added">1071         java.util.List&lt;PathAndContainer&gt; pathsAndContainers =</span>
<span class="line-added">1072             new ArrayList&lt;&gt;(paths.size());</span>
<span class="line-added">1073         for (Path path : paths) {</span>
<span class="line-added">1074             Container container;</span>
<span class="line-added">1075             try {</span>
<span class="line-added">1076                 container = getContainer(path);</span>
<span class="line-added">1077             } catch (IOException e) {</span>
<span class="line-added">1078                 throw new UncheckedIOException(e);</span>
<span class="line-added">1079             }</span>
<span class="line-added">1080             pathsAndContainers.add(new PathAndContainer(path, container, pathsAndContainers.size()));</span>
<span class="line-added">1081         }</span>
<span class="line-added">1082         return pathsAndContainers;</span>
<span class="line-added">1083     }</span>
<span class="line-added">1084 </span>
<span class="line-added">1085     private static class PathAndContainer implements Comparable&lt;PathAndContainer&gt; {</span>
<span class="line-added">1086         private final Path path;</span>
<span class="line-added">1087         private final Container container;</span>
<span class="line-added">1088         private final int index;</span>
<span class="line-added">1089 </span>
<span class="line-added">1090         PathAndContainer(Path path, Container container, int index) {</span>
<span class="line-added">1091             this.path = path;</span>
<span class="line-added">1092             this.container = container;</span>
<span class="line-added">1093             this.index = index;</span>
<span class="line-added">1094         }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096         @Override</span>
<span class="line-added">1097         public int compareTo(PathAndContainer other) {</span>
<span class="line-added">1098             return index - other.index;</span>
<span class="line-added">1099         }</span>
<span class="line-added">1100 </span>
<span class="line-added">1101         @Override</span>
<span class="line-added">1102         public boolean equals(Object o) {</span>
<span class="line-added">1103           if (o == null || !(o instanceof PathAndContainer)) {</span>
<span class="line-added">1104             return false;</span>
<span class="line-added">1105           }</span>
<span class="line-added">1106           PathAndContainer that = (PathAndContainer) o;</span>
<span class="line-added">1107           return path.equals(that.path)</span>
<span class="line-added">1108               &amp;&amp; container.equals(that.container)</span>
<span class="line-added">1109               &amp;&amp; index == this.index;</span>
<span class="line-added">1110         }</span>
<span class="line-added">1111 </span>
<span class="line-added">1112         @Override</span>
<span class="line-added">1113         public int hashCode() {</span>
<span class="line-added">1114           return Objects.hash(path, container, index);</span>
<span class="line-added">1115         }</span>
<span class="line-added">1116     }</span>
<span class="line-added">1117 </span>
1118     @Override @DefinedBy(Api.COMPILER)
1119     public boolean contains(Location location, FileObject fo) throws IOException {
1120         nullCheck(location);
1121         nullCheck(fo);
1122         Path p = asPath(fo);
1123         return locations.contains(location, p);
1124     }
1125 
1126     private Path getClassOutDir() {
1127         return locations.getOutputLocation(CLASS_OUTPUT);
1128     }
1129 
1130     private Path getSourceOutDir() {
1131         return locations.getOutputLocation(SOURCE_OUTPUT);
1132     }
1133 
1134     @Override @DefinedBy(Api.COMPILER)
1135     public Location getLocationForModule(Location location, String moduleName) throws IOException {
1136         checkModuleOrientedOrOutputLocation(location);
1137         nullCheck(moduleName);
</pre>
<hr />
<pre>
1156             return ServiceLoader.load(service, getClassLoader(location));
1157         }
1158     }
1159 
1160     @Override @DefinedBy(Api.COMPILER)
1161     public Location getLocationForModule(Location location, JavaFileObject fo) throws IOException {
1162         checkModuleOrientedOrOutputLocation(location);
1163         if (!(fo instanceof PathFileObject))
1164             return null;
1165         Path p = Locations.normalize(((PathFileObject) fo).path);
1166             // need to find p in location
1167         return locations.getLocationForModule(location, p);
1168     }
1169 
1170     @Override @DefinedBy(Api.COMPILER)
1171     public void setLocationForModule(Location location, String moduleName, Collection&lt;? extends Path&gt; paths)
1172             throws IOException {
1173         nullCheck(location);
1174         checkModuleOrientedOrOutputLocation(location);
1175         locations.setLocationForModule(location, nullCheck(moduleName), nullCheck(paths));
<span class="line-added">1176         clearCachesForLocation(location);</span>
1177     }
1178 
1179     @Override @DefinedBy(Api.COMPILER)
1180     public String inferModuleName(Location location) {
1181         checkNotModuleOrientedLocation(location);
1182         return locations.inferModuleName(location);
1183     }
1184 
1185     @Override @DefinedBy(Api.COMPILER)
1186     public Iterable&lt;Set&lt;Location&gt;&gt; listLocationsForModules(Location location) throws IOException {
1187         checkModuleOrientedOrOutputLocation(location);
1188         return locations.listLocationsForModules(location);
1189     }
1190 
1191     @Override @DefinedBy(Api.COMPILER)
1192     public Path asPath(FileObject file) {
1193         if (file instanceof PathFileObject) {
1194             return ((PathFileObject) file).path;
1195         } else
1196             throw new IllegalArgumentException(file.getName());
</pre>
<hr />
<pre>
1232      * used.
1233      * @param file a relative file name
1234      * @return a relative URI
1235      * @throws IllegalArgumentException if the file name is not
1236      * relative according to the definition given in {@link
1237      * javax.tools.JavaFileManager#getFileForInput}
1238      */
1239     public static String getRelativeName(File file) {
1240         if (!file.isAbsolute()) {
1241             String result = file.getPath().replace(File.separatorChar, &#39;/&#39;);
1242             if (isRelativeUri(result))
1243                 return result;
1244         }
1245         throw new IllegalArgumentException(&quot;Invalid relative path: &quot; + file);
1246     }
1247 
1248     /**
1249      * Get a detail message from an IOException.
1250      * Most, but not all, instances of IOException provide a non-null result
1251      * for getLocalizedMessage().  But some instances return null: in these
<span class="line-modified">1252      * cases, fall back to getMessage(), and if even that is null, return the</span>
1253      * name of the exception itself.
1254      * @param e an IOException
1255      * @return a string to include in a compiler diagnostic
1256      */
1257     public static String getMessage(IOException e) {
1258         String s = e.getLocalizedMessage();
1259         if (s != null)
1260             return s;
1261         s = e.getMessage();
1262         if (s != null)
1263             return s;
1264         return e.toString();
1265     }
1266 
1267     private void checkOutputLocation(Location location) {
1268         Objects.requireNonNull(location);
1269         if (!location.isOutputLocation())
1270             throw new IllegalArgumentException(&quot;location is not an output location: &quot; + location.getName());
1271     }
1272 
</pre>
<hr />
<pre>
1312             return null;
1313 
1314         return () -&gt; new Iterator&lt;File&gt;() {
1315             Iterator&lt;? extends Path&gt; iter = paths.iterator();
1316 
1317             @Override
1318             public boolean hasNext() {
1319                 return iter.hasNext();
1320             }
1321 
1322             @Override
1323             public File next() {
1324                 try {
1325                     return iter.next().toFile();
1326                 } catch (UnsupportedOperationException e) {
1327                     throw new IllegalStateException(e);
1328                 }
1329             }
1330         };
1331     }
<span class="line-added">1332 </span>
<span class="line-added">1333     @Override</span>
<span class="line-added">1334     public boolean handleOption(Option option, String value) {</span>
<span class="line-added">1335         if (javacFileManagerOptions.contains(option)) {</span>
<span class="line-added">1336             pathsAndContainersByLocationAndRelativeDirectory.clear();</span>
<span class="line-added">1337             nonIndexingContainersByLocation.clear();</span>
<span class="line-added">1338         }</span>
<span class="line-added">1339         return super.handleOption(option, value);</span>
<span class="line-added">1340     }</span>
<span class="line-added">1341 </span>
<span class="line-added">1342     private void clearCachesForLocation(Location location) {</span>
<span class="line-added">1343         nullCheck(location);</span>
<span class="line-added">1344         pathsAndContainersByLocationAndRelativeDirectory.remove(location);</span>
<span class="line-added">1345         nonIndexingContainersByLocation.remove(location);</span>
<span class="line-added">1346     }</span>
1347 }
</pre>
</td>
</tr>
</table>
<center><a href="FSInfo.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Locations.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AttrContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CompileStates.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  package com.sun.tools.javac.comp;
  
  import java.util.*;
  import java.util.function.Supplier;
  
<span class="udiff-line-added">+ import javax.lang.model.element.ElementKind;</span>
  import javax.tools.JavaFileManager;
  
  import com.sun.tools.javac.code.*;
  import com.sun.tools.javac.code.Attribute.Compound;
  import com.sun.tools.javac.code.Directive.ExportsDirective;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53,11 +54,10 @@</span>
  import com.sun.tools.javac.code.Lint.LintCategory;
  import com.sun.tools.javac.code.Scope.WriteableScope;
  import com.sun.tools.javac.code.Type.*;
  import com.sun.tools.javac.code.Symbol.*;
  import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
<span class="udiff-line-removed">- import com.sun.tools.javac.comp.Infer.FreeTypeListener;</span>
  import com.sun.tools.javac.tree.JCTree.*;
  
  import static com.sun.tools.javac.code.Flags.*;
  import static com.sun.tools.javac.code.Flags.ANNOTATION;
  import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -91,10 +91,11 @@</span>
      private final JCDiagnostic.Factory diags;
      private final JavaFileManager fileManager;
      private final Source source;
      private final Target target;
      private final Profile profile;
<span class="udiff-line-added">+     private final Preview preview;</span>
      private final boolean warnOnAnyAccessToMembers;
  
      // The set of lint options currently in effect. It is initialized
      // from the context, and then is set/reset as needed by Attr as it
      // visits all the various parts of the trees during attribution.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -114,11 +115,11 @@</span>
      protected Check(Context context) {
          context.put(checkKey, this);
  
          names = Names.instance(context);
          dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
<span class="udiff-line-modified-removed">-             names.FIELD, names.METHOD, names.CONSTRUCTOR,</span>
<span class="udiff-line-modified-added">+             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,</span>
              names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
          log = Log.instance(context);
          rs = Resolve.instance(context);
          syms = Symtab.instance(context);
          enter = Enter.instance(context);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137,10 +138,11 @@</span>
  
          Target target = Target.instance(context);
          syntheticNameChar = target.syntheticNameChar();
  
          profile = Profile.instance(context);
<span class="udiff-line-added">+         preview = Preview.instance(context);</span>
  
          boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
          boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
          boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
          boolean enforceMandatoryWarnings = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,10 +224,27 @@</span>
                  deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
              }
          }
      }
  
<span class="udiff-line-added">+     /** Warn about deprecated symbol.</span>
<span class="udiff-line-added">+      *  @param pos        Position to be used for error reporting.</span>
<span class="udiff-line-added">+      *  @param sym        The deprecated symbol.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     void warnPreview(DiagnosticPosition pos, Symbol sym) {</span>
<span class="udiff-line-added">+         warnPreview(pos, Warnings.IsPreview(sym));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Log a preview warning.</span>
<span class="udiff-line-added">+      *  @param pos        Position to be used for error reporting.</span>
<span class="udiff-line-added">+      *  @param msg        A Warning describing the problem.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {</span>
<span class="udiff-line-added">+         if (!lint.isSuppressed(LintCategory.PREVIEW))</span>
<span class="udiff-line-added">+             preview.reportPreviewWarning(pos, warnKey);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** Warn about unchecked operation.
       *  @param pos        Position to be used for error reporting.
       *  @param msg        A string describing the problem.
       */
      public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -312,15 +331,22 @@</span>
                                                          sym,
                                                          kindName(sym.location()),
                                                          kindName(sym.location().enclClass()),
                                                          sym.location().enclClass()));
              } else {
<span class="udiff-line-modified-removed">-                 log.error(pos,</span>
<span class="udiff-line-modified-removed">-                           Errors.AlreadyDefined(kindName(sym),</span>
<span class="udiff-line-modified-removed">-                                                 sym,</span>
<span class="udiff-line-modified-removed">-                                                 kindName(sym.location()),</span>
<span class="udiff-line-modified-removed">-                                                 sym.location()));</span>
<span class="udiff-line-modified-added">+                 /* dont error if this is a duplicated parameter of a generated canonical constructor</span>
<span class="udiff-line-modified-added">+                  * as we should have issued an error for the duplicated fields</span>
<span class="udiff-line-modified-added">+                  */</span>
<span class="udiff-line-modified-added">+                 if (location.kind != MTH ||</span>
<span class="udiff-line-modified-added">+                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||</span>
<span class="udiff-line-added">+                         ((sym.owner.flags_field &amp; RECORD) == 0)) {</span>
<span class="udiff-line-added">+                     log.error(pos,</span>
<span class="udiff-line-added">+                             Errors.AlreadyDefined(kindName(sym),</span>
<span class="udiff-line-added">+                                     sym,</span>
<span class="udiff-line-added">+                                     kindName(sym.location()),</span>
<span class="udiff-line-added">+                                     sym.location()));</span>
<span class="udiff-line-added">+                 }</span>
              }
          }
      }
  
      /** Report array/varargs duplicate declaration
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,11 +431,11 @@</span>
       *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
       *  where
       *    enclClass is the flat name of the enclosing class,
       *    classname is the simple name of the local class
       */
<span class="udiff-line-modified-removed">-     Name localClassName(ClassSymbol c) {</span>
<span class="udiff-line-modified-added">+     public Name localClassName(ClassSymbol c) {</span>
          Name enclFlatname = c.owner.enclClass().flatname;
          String enclFlatnameStr = enclFlatname.toString();
          Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
          Integer index = localClassNameIndexes.get(key);
          for (int i = (index == null) ? 1 : index; ; i++) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -420,11 +446,11 @@</span>
                  return flatname;
              }
          }
      }
  
<span class="udiff-line-modified-removed">-     void clearLocalClassNameIndexes(ClassSymbol c) {</span>
<span class="udiff-line-modified-added">+     public void clearLocalClassNameIndexes(ClassSymbol c) {</span>
          if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
              localClassNameIndexes.remove(new Pair&lt;&gt;(
                      c.owner.enclClass().flatname, c.name));
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -432,10 +458,17 @@</span>
      public void newRound() {
          compiled.clear();
          localClassNameIndexes.clear();
      }
  
<span class="udiff-line-added">+     public void clear() {</span>
<span class="udiff-line-added">+         deprecationHandler.clear();</span>
<span class="udiff-line-added">+         removalHandler.clear();</span>
<span class="udiff-line-added">+         uncheckedHandler.clear();</span>
<span class="udiff-line-added">+         sunApiHandler.clear();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public void putCompiled(ClassSymbol csym) {
          compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
      }
  
      public ClassSymbol getCompiled(ClassSymbol csym) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1157,33 +1190,45 @@</span>
                          implicit |= ABSTRACT;
                      }
                  } else {
                      mask = implicit = InterfaceMethodFlags;
                  }
<span class="udiff-line-added">+             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {</span>
<span class="udiff-line-added">+                 mask = RecordMethodFlags;</span>
              } else {
                  mask = MethodFlags;
              }
              // Imply STRICTFP if owner has STRICTFP set.
              if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
                  ((flags) &amp; Flags.DEFAULT) != 0)
                  implicit |= sym.owner.flags_field &amp; STRICTFP;
              break;
          case TYP:
              if (sym.isLocal()) {
<span class="udiff-line-modified-removed">-                 mask = LocalClassFlags;</span>
<span class="udiff-line-modified-added">+                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;</span>
<span class="udiff-line-added">+                 if ((flags &amp; RECORD) != 0) {</span>
<span class="udiff-line-added">+                     implicit = STATIC;</span>
<span class="udiff-line-added">+                     if (sym.owner.kind == TYP) {</span>
<span class="udiff-line-added">+                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
                  if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
<span class="udiff-line-modified-removed">-                     (flags &amp; ENUM) != 0)</span>
<span class="udiff-line-modified-added">+                     (flags &amp; ENUM) != 0) {</span>
                      log.error(pos, Errors.EnumsMustBeStatic);
<span class="udiff-line-added">+                 }</span>
              } else if (sym.owner.kind == TYP) {
<span class="udiff-line-modified-removed">-                 mask = MemberClassFlags;</span>
<span class="udiff-line-modified-added">+                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;</span>
                  if (sym.owner.owner.kind == PCK ||
                      (sym.owner.flags_field &amp; STATIC) != 0)
                      mask |= STATIC;
<span class="udiff-line-modified-removed">-                 else if ((flags &amp; ENUM) != 0)</span>
<span class="udiff-line-modified-added">+                 else if ((flags &amp; ENUM) != 0) {</span>
                      log.error(pos, Errors.EnumsMustBeStatic);
<span class="udiff-line-added">+                 } else if ((flags &amp; RECORD) != 0) {</span>
<span class="udiff-line-added">+                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);</span>
<span class="udiff-line-added">+                 }</span>
                  // Nested interfaces and enums are always STATIC (Spec ???)
<span class="udiff-line-modified-removed">-                 if ((flags &amp; (INTERFACE | ENUM)) != 0 ) implicit = STATIC;</span>
<span class="udiff-line-modified-added">+                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;</span>
              } else {
                  mask = ClassFlags;
              }
              // Interfaces are always ABSTRACT
              if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1191,10 +1236,15 @@</span>
              if ((flags &amp; ENUM) != 0) {
                  // enums can&#39;t be declared abstract or final
                  mask &amp;= ~(ABSTRACT | FINAL);
                  implicit |= implicitEnumFinalFlag(tree);
              }
<span class="udiff-line-added">+             if ((flags &amp; RECORD) != 0) {</span>
<span class="udiff-line-added">+                 // records can&#39;t be declared abstract</span>
<span class="udiff-line-added">+                 mask &amp;= ~ABSTRACT;</span>
<span class="udiff-line-added">+                 implicit |= FINAL;</span>
<span class="udiff-line-added">+             }</span>
              // Imply STRICTFP if owner has STRICTFP set.
              implicit |= sym.owner.flags_field &amp; STRICTFP;
              break;
          default:
              throw new AssertionError();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1247,13 +1297,13 @@</span>
      }
  
  
      /** Determine if this enum should be implicitly final.
       *
<span class="udiff-line-modified-removed">-      *  If the enum has no specialized enum contants, it is final.</span>
<span class="udiff-line-modified-added">+      *  If the enum has no specialized enum constants, it is final.</span>
       *
<span class="udiff-line-modified-removed">-      *  If the enum does have specialized enum contants, it is</span>
<span class="udiff-line-modified-added">+      *  If the enum does have specialized enum constants, it is</span>
       *  &lt;i&gt;not&lt;/i&gt; final.
       */
      private long implicitEnumFinalFlag(JCTree tree) {
          if (!tree.hasTag(CLASSDEF)) return 0;
          class SpecialTreeVisitor extends JCTree.Visitor {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1809,11 +1859,11 @@</span>
              // If the method, m, is defined in an interface, then ignore the issue if the method
              // is only inherited via a supertype and also implemented in the supertype,
              // because in that case, we will rediscover the issue when examining the method
              // in the supertype.
              // If the method, m, is not defined in an interface, then the only time we need to
<span class="udiff-line-modified-removed">-             // address the issue is when the method is the supertype implemementation: any other</span>
<span class="udiff-line-modified-added">+             // address the issue is when the method is the supertype implementation: any other</span>
              // case, we will have dealt with when examining the supertype classes
              ClassSymbol mc = m.enclClass();
              Type st = types.supertype(origin.type);
              if (!st.hasTag(CLASS))
                  return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1900,11 +1950,11 @@</span>
       *  but different return types in two given interfaces, or null if none
       *  exists.
       *  @param t1     The first type.
       *  @param t2     The second type.
       *  @param site   The most derived type.
<span class="udiff-line-modified-removed">-      *  @returns symbol from t2 that conflicts with one in t1.</span>
<span class="udiff-line-modified-added">+      *  @return symbol from t2 that conflicts with one in t1.</span>
       */
      private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
          Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
          closure(t1, interfaces1);
          Map&lt;TypeSymbol,Type&gt; interfaces2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1930,11 +1980,11 @@</span>
              for (Type i : types.interfaces(t))
                  closure(i, typeMap);
          }
      }
  
<span class="udiff-line-modified-removed">-     /** Compute all the supertypes of t, indexed by type symbol (except thise in typesSkip). */</span>
<span class="udiff-line-modified-added">+     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */</span>
      private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
          if (!t.hasTag(CLASS)) return;
          if (typesSkip.get(t.tsym) != null) return;
          if (typeMap.put(t.tsym, t) == null) {
              closure(types.supertype(t), typesSkip, typeMap);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2419,11 +2469,13 @@</span>
          //for each method m1 that is overridden (directly or indirectly)
          //by method &#39;sym&#39; in &#39;site&#39;...
  
          List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
          boolean overridesAny = false;
<span class="udiff-line-modified-removed">-         for (Symbol m1 : types.membersClosure(site, false).getSymbolsByName(sym.name, cf)) {</span>
<span class="udiff-line-modified-added">+         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);</span>
<span class="udiff-line-added">+         for (Symbol m1 : symbolsByName) {</span>
              if (!sym.overrides(m1, site.tsym, types, false)) {
                  if (m1 == sym) {
                      continue;
                  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2437,11 +2489,11 @@</span>
                  overridesAny = true;
                  potentiallyAmbiguousList = List.nil();
              }
  
              //...check each method m2 that is a member of &#39;site&#39;
<span class="udiff-line-modified-removed">-             for (Symbol m2 : types.membersClosure(site, false).getSymbolsByName(sym.name, cf)) {</span>
<span class="udiff-line-modified-added">+             for (Symbol m2 : symbolsByName) {</span>
                  if (m2 == m1) continue;
                  //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
                  //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
                  if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
                          types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2624,11 +2676,11 @@</span>
                  args1 = args1.tail;
                  args2 = args2.tail;
              }
              if (potentiallyAmbiguous) {
                  //we found two incompatible functional interfaces with same arity
<span class="udiff-line-modified-removed">-                 //this means a call site passing an implicit lambda would be ambigiuous</span>
<span class="udiff-line-modified-added">+                 //this means a call site passing an implicit lambda would be ambiguous</span>
                  msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
                  msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
                  log.warning(LintCategory.OVERLOADS, pos,
                              Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
                                                                    msym2, msym2.location()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2809,13 +2861,13 @@</span>
          }
      }
  
      /** Check the annotations of a symbol.
       */
<span class="udiff-line-modified-removed">-     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol s) {</span>
<span class="udiff-line-modified-added">+     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {</span>
          for (JCAnnotation a : annotations)
<span class="udiff-line-modified-removed">-             validateAnnotation(a, s);</span>
<span class="udiff-line-modified-added">+             validateAnnotation(a, declarationTree, s);</span>
      }
  
      /** Check the type annotations.
       */
      public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2823,15 +2875,139 @@</span>
              validateTypeAnnotation(a, isTypeParameter);
      }
  
      /** Check an annotation of a symbol.
       */
<span class="udiff-line-modified-removed">-     private void validateAnnotation(JCAnnotation a, Symbol s) {</span>
<span class="udiff-line-modified-added">+     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {</span>
          validateAnnotationTree(a);
<span class="udiff-line-added">+         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         boolean isRecordField = isRecordMember &amp;&amp;</span>
<span class="udiff-line-added">+                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;</span>
<span class="udiff-line-added">+                 declarationTree.hasTag(VARDEF) &amp;&amp;</span>
<span class="udiff-line-added">+                 s.owner.kind == TYP;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (isRecordField) {</span>
<span class="udiff-line-added">+             // first we need to check if the annotation is applicable to records</span>
<span class="udiff-line-added">+             Name[] targets = getTargetNames(a);</span>
<span class="udiff-line-added">+             boolean appliesToRecords = false;</span>
<span class="udiff-line-added">+             for (Name target : targets) {</span>
<span class="udiff-line-added">+                 appliesToRecords =</span>
<span class="udiff-line-added">+                                 target == names.FIELD ||</span>
<span class="udiff-line-added">+                                 target == names.PARAMETER ||</span>
<span class="udiff-line-added">+                                 target == names.METHOD ||</span>
<span class="udiff-line-added">+                                 target == names.TYPE_USE ||</span>
<span class="udiff-line-added">+                                 target == names.RECORD_COMPONENT;</span>
<span class="udiff-line-added">+                 if (appliesToRecords) {</span>
<span class="udiff-line-added">+                     break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (!appliesToRecords) {</span>
<span class="udiff-line-added">+                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 /* lets now find the annotations in the field that are targeted to record components and append them to</span>
<span class="udiff-line-added">+                  * the corresponding record component</span>
<span class="udiff-line-added">+                  */</span>
<span class="udiff-line-added">+                 ClassSymbol recordClass = (ClassSymbol) s.owner;</span>
<span class="udiff-line-added">+                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);</span>
<span class="udiff-line-added">+                 SymbolMetadata metadata = rc.getMetadata();</span>
<span class="udiff-line-added">+                 if (metadata == null || metadata.isEmpty()) {</span>
<span class="udiff-line-added">+                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied</span>
<span class="udiff-line-added">+                      * to the record component declaration</span>
<span class="udiff-line-added">+                      */</span>
<span class="udiff-line-added">+                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;</span>
<span class="udiff-line-added">+                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)</span>
<span class="udiff-line-added">+                     ).collect(List.collector()));</span>
<span class="udiff-line-added">+                     rc.setTypeAttributes(s.getRawTypeAttributes());</span>
<span class="udiff-line-added">+                     // to get all the type annotations applied to the type</span>
<span class="udiff-line-added">+                     rc.type = s.type;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-         if (a.type.tsym.isAnnotationType() &amp;&amp; !annotationApplicable(a, s))</span>
<span class="udiff-line-modified-removed">-             log.error(a.pos(), Errors.AnnotationTypeNotApplicable);</span>
<span class="udiff-line-modified-added">+         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding</span>
<span class="udiff-line-modified-added">+          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has</span>
<span class="udiff-line-added">+          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated</span>
<span class="udiff-line-added">+          * there is no enough information to propagate only the right annotations. So all the annotations are propagated</span>
<span class="udiff-line-added">+          * to all the possible locations.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * At this point we need to remove all the annotations that are not in place before going on with the annotation</span>
<span class="udiff-line-added">+          * party. On top of the above there is the issue that there is no AST representing record components, just symbols</span>
<span class="udiff-line-added">+          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it</span>
<span class="udiff-line-added">+          * was both a field and a record component.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers</span>
<span class="udiff-line-added">+          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could</span>
<span class="udiff-line-added">+          * be see by annotation processors.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t</span>
<span class="udiff-line-added">+          * need to care about type annotations, they are all in the right place. But we could need to remove declaration</span>
<span class="udiff-line-added">+          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type</span>
<span class="udiff-line-added">+          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not</span>
<span class="udiff-line-added">+          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for</span>
<span class="udiff-line-added">+          * further inspection by annotation processors.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * For example:</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          *     import java.lang.annotation.*;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})</span>
<span class="udiff-line-added">+          *     @Retention(RetentionPolicy.RUNTIME)</span>
<span class="udiff-line-added">+          *     @interface Anno { }</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          *     record R(@Anno String s) {}</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * at this point we will have for the case of the generated field:</span>
<span class="udiff-line-added">+          *   - @Anno in the modifier</span>
<span class="udiff-line-added">+          *   - @Anno as a type annotation</span>
<span class="udiff-line-added">+          *   - @Anno as a declaration annotation</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * the last one should be removed because the annotation has not FIELD as target but it was applied as a</span>
<span class="udiff-line-added">+          * declaration annotation because the field was being treated both as a field and as a record component</span>
<span class="udiff-line-added">+          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold</span>
<span class="udiff-line-added">+          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it</span>
<span class="udiff-line-added">+          * is applicable as a type annotation to the type of the field.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (a.type.tsym.isAnnotationType()) {</span>
<span class="udiff-line-added">+             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);</span>
<span class="udiff-line-added">+             if (!applicableTargetsOp.isEmpty()) {</span>
<span class="udiff-line-added">+                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();</span>
<span class="udiff-line-added">+                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||</span>
<span class="udiff-line-added">+                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);</span>
<span class="udiff-line-added">+                 boolean isRecordMemberWithNonApplicableDeclAnno =</span>
<span class="udiff-line-added">+                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {</span>
<span class="udiff-line-added">+                     if (isRecordMemberWithNonApplicableDeclAnno) {</span>
<span class="udiff-line-added">+                             /* so we have found an annotation that is not applicable to a record member that was generated by the</span>
<span class="udiff-line-added">+                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations</span>
<span class="udiff-line-added">+                              * that are not applicable to the given record member</span>
<span class="udiff-line-added">+                              */</span>
<span class="udiff-line-added">+                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);</span>
<span class="udiff-line-added">+                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as</span>
<span class="udiff-line-added">+                              * it could be a type annotation</span>
<span class="udiff-line-added">+                              */</span>
<span class="udiff-line-added">+                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {</span>
<span class="udiff-line-added">+                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();</span>
<span class="udiff-line-added">+                             for (JCAnnotation anno : modifiers.annotations) {</span>
<span class="udiff-line-added">+                                 if (anno != a) {</span>
<span class="udiff-line-added">+                                     newAnnotations.add(anno);</span>
<span class="udiff-line-added">+                                 }</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             modifiers.annotations = newAnnotations.toList();</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         // now lets remove it from the symbol</span>
<span class="udiff-line-added">+                         s.getMetadata().removeDeclarationMetadata(a.attribute);</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
  
          if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
              if (s.kind != TYP) {
                  log.error(a.pos(), Errors.BadFunctionalIntfAnno);
              } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2986,10 +3162,11 @@</span>
          if (defaultTargets == null) {
              Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
              targets.add(names.ANNOTATION_TYPE);
              targets.add(names.CONSTRUCTOR);
              targets.add(names.FIELD);
<span class="udiff-line-added">+             targets.add(names.RECORD_COMPONENT);</span>
              targets.add(names.LOCAL_VARIABLE);
              targets.add(names.METHOD);
              targets.add(names.PACKAGE);
              targets.add(names.PARAMETER);
              targets.add(names.TYPE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3077,89 +3254,128 @@</span>
              return (e.value.name == names.TYPE_USE ||
                      (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
          }
  
      /** Is the annotation applicable to the symbol? */
<span class="udiff-line-added">+     Name[] getTargetNames(JCAnnotation a) {</span>
<span class="udiff-line-added">+         return getTargetNames(a.annotationType.type.tsym);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     public Name[] getTargetNames(TypeSymbol annoSym) {</span>
<span class="udiff-line-added">+         Attribute.Array arr = getAttributeTargetAttribute(annoSym);</span>
<span class="udiff-line-added">+         Name[] targets;</span>
<span class="udiff-line-added">+         if (arr == null) {</span>
<span class="udiff-line-added">+             targets = defaultTargetMetaInfo();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             // TODO: can we optimize this?</span>
<span class="udiff-line-added">+             targets = new Name[arr.values.length];</span>
<span class="udiff-line-added">+             for (int i=0; i&lt;arr.values.length; ++i) {</span>
<span class="udiff-line-added">+                 Attribute app = arr.values[i];</span>
<span class="udiff-line-added">+                 if (!(app instanceof Attribute.Enum)) {</span>
<span class="udiff-line-added">+                     return new Name[0];</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 Attribute.Enum e = (Attribute.Enum) app;</span>
<span class="udiff-line-added">+                 targets[i] = e.value.name;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return targets;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      boolean annotationApplicable(JCAnnotation a, Symbol s) {
<span class="udiff-line-added">+         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);</span>
<span class="udiff-line-added">+         /* the optional could be emtpy if the annotation is unknown in that case</span>
<span class="udiff-line-added">+          * we return that it is applicable and if it is erroneous that should imply</span>
<span class="udiff-line-added">+          * an error at the declaration site</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="udiff-line-added">+     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {</span>
          Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
          Name[] targets;
<span class="udiff-line-added">+         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();</span>
  
          if (arr == null) {
<span class="udiff-line-modified-removed">-             targets = defaultTargetMetaInfo(a, s);</span>
<span class="udiff-line-modified-added">+             targets = defaultTargetMetaInfo();</span>
          } else {
              // TODO: can we optimize this?
              targets = new Name[arr.values.length];
              for (int i=0; i&lt;arr.values.length; ++i) {
                  Attribute app = arr.values[i];
                  if (!(app instanceof Attribute.Enum)) {
<span class="udiff-line-modified-removed">-                     return true; // recovery</span>
<span class="udiff-line-modified-added">+                     // recovery</span>
<span class="udiff-line-added">+                     return Optional.empty();</span>
                  }
                  Attribute.Enum e = (Attribute.Enum) app;
                  targets[i] = e.value.name;
              }
          }
          for (Name target : targets) {
              if (target == names.TYPE) {
                  if (s.kind == TYP)
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.TYPE);</span>
              } else if (target == names.FIELD) {
                  if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.FIELD);</span>
<span class="udiff-line-added">+             } else if (target == names.RECORD_COMPONENT) {</span>
<span class="udiff-line-added">+                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {</span>
<span class="udiff-line-added">+                     applicableTargets.add(names.RECORD_COMPONENT);</span>
<span class="udiff-line-added">+                 }</span>
              } else if (target == names.METHOD) {
                  if (s.kind == MTH &amp;&amp; !s.isConstructor())
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.METHOD);</span>
              } else if (target == names.PARAMETER) {
<span class="udiff-line-modified-removed">-                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                       (s.flags() &amp; PARAMETER) != 0) {</span>
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                 if (s.kind == VAR &amp;&amp;</span>
<span class="udiff-line-modified-added">+                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.PARAMETER);</span>
                  }
              } else if (target == names.CONSTRUCTOR) {
                  if (s.kind == MTH &amp;&amp; s.isConstructor())
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.CONSTRUCTOR);</span>
              } else if (target == names.LOCAL_VARIABLE) {
                  if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
                        (s.flags() &amp; PARAMETER) == 0) {
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.LOCAL_VARIABLE);</span>
                  }
              } else if (target == names.ANNOTATION_TYPE) {
                  if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.ANNOTATION_TYPE);</span>
                  }
              } else if (target == names.PACKAGE) {
                  if (s.kind == PCK)
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.PACKAGE);</span>
              } else if (target == names.TYPE_USE) {
                  if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
<span class="udiff-line-modified-removed">-                     //cannot type annotate implictly typed locals</span>
<span class="udiff-line-modified-removed">-                     return false;</span>
<span class="udiff-line-modified-added">+                     //cannot type annotate implicitly typed locals</span>
<span class="udiff-line-modified-added">+                     continue;</span>
                  } else if (s.kind == TYP || s.kind == VAR ||
                          (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
                                  !s.type.getReturnType().hasTag(VOID)) ||
                          (s.kind == MTH &amp;&amp; s.isConstructor())) {
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.TYPE_USE);</span>
                  }
              } else if (target == names.TYPE_PARAMETER) {
                  if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
<span class="udiff-line-modified-removed">-                     return true;</span>
<span class="udiff-line-modified-added">+                     applicableTargets.add(names.TYPE_PARAMETER);</span>
              } else
<span class="udiff-line-modified-removed">-                 return true; // Unknown ElementType. This should be an error at declaration site,</span>
<span class="udiff-line-modified-removed">-                              // assume applicable.</span>
<span class="udiff-line-modified-added">+                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,</span>
<span class="udiff-line-modified-added">+                                          // assume applicable.</span>
          }
<span class="udiff-line-modified-removed">-         return false;</span>
<span class="udiff-line-modified-added">+         return Optional.of(applicableTargets);</span>
      }
  
<span class="udiff-line-removed">- </span>
      Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
          Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
          if (atTarget == null) return null; // ok, is applicable
          Attribute atValue = atTarget.member(names.value);
          if (!(atValue instanceof Attribute.Array)) return null; // error recovery
          return (Attribute.Array) atValue;
      }
  
<span class="udiff-line-modified-removed">-     private final Name[] dfltTargetMeta;</span>
<span class="udiff-line-modified-removed">-     private Name[] defaultTargetMetaInfo(JCAnnotation a, Symbol s) {</span>
<span class="udiff-line-modified-added">+     public final Name[] dfltTargetMeta;</span>
<span class="udiff-line-modified-added">+     private Name[] defaultTargetMetaInfo() {</span>
          return dfltTargetMeta;
      }
  
      /** Check an annotation value.
       *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3286,10 +3502,20 @@</span>
          if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
              log.error(pos, Errors.NotInProfile(s, profile));
          }
      }
  
<span class="udiff-line-added">+     void checkPreview(DiagnosticPosition pos, Symbol s) {</span>
<span class="udiff-line-added">+         if ((s.flags() &amp; PREVIEW_API) != 0) {</span>
<span class="udiff-line-added">+             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {</span>
<span class="udiff-line-added">+                 log.error(pos, Errors.IsPreview(s));</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
  /* *************************************************************************
   * Check for recursive annotation elements.
   **************************************************************************/
  
      /** Check for cycles in the graph of annotation elements.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3446,10 +3672,18 @@</span>
                      return true;
                  } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
                      duplicateErasureError(pos, sym, byName);
                      sym.flags_field |= CLASH;
                      return true;
<span class="udiff-line-added">+                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;</span>
<span class="udiff-line-added">+                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;</span>
<span class="udiff-line-added">+                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {</span>
<span class="udiff-line-added">+                     if (!sym.type.isErroneous()) {</span>
<span class="udiff-line-added">+                         log.error(pos, Errors.MatchBindingExists);</span>
<span class="udiff-line-added">+                         sym.flags_field |= CLASH;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     return false;</span>
                  } else {
                      duplicateError(pos, byName);
                      return false;
                  }
              }
</pre>
<center><a href="AttrContext.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CompileStates.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
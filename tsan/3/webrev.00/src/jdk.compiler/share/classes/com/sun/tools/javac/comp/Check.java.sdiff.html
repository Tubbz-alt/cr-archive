<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AttrContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CompileStates.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 

  31 import javax.tools.JavaFileManager;
  32 
  33 import com.sun.tools.javac.code.*;
  34 import com.sun.tools.javac.code.Attribute.Compound;
  35 import com.sun.tools.javac.code.Directive.ExportsDirective;
  36 import com.sun.tools.javac.code.Directive.RequiresDirective;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  39 import com.sun.tools.javac.jvm.*;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.util.*;
  45 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  50 import com.sun.tools.javac.util.List;
  51 
  52 import com.sun.tools.javac.code.Lint;
  53 import com.sun.tools.javac.code.Lint.LintCategory;
  54 import com.sun.tools.javac.code.Scope.WriteableScope;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.code.Symbol.*;
  57 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
<span class="line-removed">  58 import com.sun.tools.javac.comp.Infer.FreeTypeListener;</span>
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;

  96     private final boolean warnOnAnyAccessToMembers;
  97 
  98     // The set of lint options currently in effect. It is initialized
  99     // from the context, and then is set/reset as needed by Attr as it
 100     // visits all the various parts of the trees during attribution.
 101     private Lint lint;
 102 
 103     // The method being analyzed in Attr - it is set/reset as needed by
 104     // Attr as it visits new method declarations.
 105     private MethodSymbol method;
 106 
 107     public static Check instance(Context context) {
 108         Check instance = context.get(checkKey);
 109         if (instance == null)
 110             instance = new Check(context);
 111         return instance;
 112     }
 113 
 114     protected Check(Context context) {
 115         context.put(checkKey, this);
 116 
 117         names = Names.instance(context);
 118         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
<span class="line-modified"> 119             names.FIELD, names.METHOD, names.CONSTRUCTOR,</span>
 120             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 121         log = Log.instance(context);
 122         rs = Resolve.instance(context);
 123         syms = Symtab.instance(context);
 124         enter = Enter.instance(context);
 125         deferredAttr = DeferredAttr.instance(context);
 126         infer = Infer.instance(context);
 127         types = Types.instance(context);
 128         typeAnnotations = TypeAnnotations.instance(context);
 129         diags = JCDiagnostic.Factory.instance(context);
 130         Options options = Options.instance(context);
 131         lint = Lint.instance(context);
 132         fileManager = context.get(JavaFileManager.class);
 133 
 134         source = Source.instance(context);
 135         target = Target.instance(context);
 136         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
 137 
 138         Target target = Target.instance(context);
 139         syntheticNameChar = target.syntheticNameChar();
 140 
 141         profile = Profile.instance(context);

 142 
 143         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 144         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 145         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 146         boolean enforceMandatoryWarnings = true;
 147 
 148         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 149                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 150         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 151                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 152         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 153                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 154         sunApiHandler = new MandatoryWarningHandler(log, false,
 155                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 156 
 157         deferredLintHandler = DeferredLintHandler.instance(context);
 158     }
 159 
 160     /** Character for synthetic names
 161      */
</pre>
<hr />
<pre>
 207      *  @param sym        The deprecated symbol.
 208      */
 209     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 210         if (sym.isDeprecatedForRemoval()) {
 211             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 212                 if (sym.kind == MDL) {
 213                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 214                 } else {
 215                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 216                 }
 217             }
 218         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 219             if (sym.kind == MDL) {
 220                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 221             } else {
 222                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 223             }
 224         }
 225     }
 226 

















 227     /** Warn about unchecked operation.
 228      *  @param pos        Position to be used for error reporting.
 229      *  @param msg        A string describing the problem.
 230      */
 231     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 232         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 233             uncheckedHandler.report(pos, warnKey);
 234     }
 235 
 236     /** Warn about unsafe vararg method decl.
 237      *  @param pos        Position to be used for error reporting.
 238      */
 239     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 240         if (lint.isEnabled(LintCategory.VARARGS))
 241             log.warning(LintCategory.VARARGS, pos, warnKey);
 242     }
 243 
 244     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 245         if (lint.isEnabled(LintCategory.STATIC))
 246             log.warning(LintCategory.STATIC, pos, warnKey);
</pre>
<hr />
<pre>
 297      *  @param sym        The referenced symbol.
 298      */
 299     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 300         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 301     }
 302 
 303     /** Report duplicate declaration error.
 304      */
 305     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 306         if (!sym.type.isErroneous()) {
 307             Symbol location = sym.location();
 308             if (location.kind == MTH &amp;&amp;
 309                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 310                 log.error(pos,
 311                           Errors.AlreadyDefinedInClinit(kindName(sym),
 312                                                         sym,
 313                                                         kindName(sym.location()),
 314                                                         kindName(sym.location().enclClass()),
 315                                                         sym.location().enclClass()));
 316             } else {
<span class="line-modified"> 317                 log.error(pos,</span>
<span class="line-modified"> 318                           Errors.AlreadyDefined(kindName(sym),</span>
<span class="line-modified"> 319                                                 sym,</span>
<span class="line-modified"> 320                                                 kindName(sym.location()),</span>
<span class="line-modified"> 321                                                 sym.location()));</span>







 322             }
 323         }
 324     }
 325 
 326     /** Report array/varargs duplicate declaration
 327      */
 328     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 329         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 330             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 331         }
 332     }
 333 
 334 /* ************************************************************************
 335  * duplicate declaration checking
 336  *************************************************************************/
 337 
 338     /** Check that variable does not hide variable with same name in
 339      *  immediately enclosing local scope.
 340      *  @param pos           Position for error reporting.
 341      *  @param v             The symbol.
</pre>
<hr />
<pre>
 390                 duplicateError(pos, sym);
 391                 return true;
 392             }
 393         }
 394         return true;
 395     }
 396 
 397 /* *************************************************************************
 398  * Class name generation
 399  **************************************************************************/
 400 
 401 
 402     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 403 
 404     /** Return name of local class.
 405      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 406      *  where
 407      *    enclClass is the flat name of the enclosing class,
 408      *    classname is the simple name of the local class
 409      */
<span class="line-modified"> 410     Name localClassName(ClassSymbol c) {</span>
 411         Name enclFlatname = c.owner.enclClass().flatname;
 412         String enclFlatnameStr = enclFlatname.toString();
 413         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 414         Integer index = localClassNameIndexes.get(key);
 415         for (int i = (index == null) ? 1 : index; ; i++) {
 416             Name flatname = names.fromString(enclFlatnameStr
 417                     + syntheticNameChar + i + c.name);
 418             if (getCompiled(c.packge().modle, flatname) == null) {
 419                 localClassNameIndexes.put(key, i + 1);
 420                 return flatname;
 421             }
 422         }
 423     }
 424 
<span class="line-modified"> 425     void clearLocalClassNameIndexes(ClassSymbol c) {</span>
 426         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 427             localClassNameIndexes.remove(new Pair&lt;&gt;(
 428                     c.owner.enclClass().flatname, c.name));
 429         }
 430     }
 431 
 432     public void newRound() {
 433         compiled.clear();
 434         localClassNameIndexes.clear();
 435     }
 436 







 437     public void putCompiled(ClassSymbol csym) {
 438         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 439     }
 440 
 441     public ClassSymbol getCompiled(ClassSymbol csym) {
 442         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 443     }
 444 
 445     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 446         return compiled.get(Pair.of(msym, flatname));
 447     }
 448 
 449     public void removeCompiled(ClassSymbol csym) {
 450         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 451     }
 452 
 453 /* *************************************************************************
 454  * Type Checking
 455  **************************************************************************/
 456 
</pre>
<hr />
<pre>
1142                     // enum constructors cannot be declared public or
1143                     // protected and must be implicitly or explicitly
1144                     // private
1145                     implicit = PRIVATE;
1146                     mask = PRIVATE;
1147                 } else
1148                     mask = ConstructorFlags;
1149             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1150                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1151                     mask = AnnotationTypeElementMask;
1152                     implicit = PUBLIC | ABSTRACT;
1153                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1154                     mask = InterfaceMethodMask;
1155                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1156                     if ((flags &amp; DEFAULT) != 0) {
1157                         implicit |= ABSTRACT;
1158                     }
1159                 } else {
1160                     mask = implicit = InterfaceMethodFlags;
1161                 }


1162             } else {
1163                 mask = MethodFlags;
1164             }
1165             // Imply STRICTFP if owner has STRICTFP set.
1166             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1167                 ((flags) &amp; Flags.DEFAULT) != 0)
1168                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1169             break;
1170         case TYP:
1171             if (sym.isLocal()) {
<span class="line-modified">1172                 mask = LocalClassFlags;</span>






1173                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
<span class="line-modified">1174                     (flags &amp; ENUM) != 0)</span>
1175                     log.error(pos, Errors.EnumsMustBeStatic);

1176             } else if (sym.owner.kind == TYP) {
<span class="line-modified">1177                 mask = MemberClassFlags;</span>
1178                 if (sym.owner.owner.kind == PCK ||
1179                     (sym.owner.flags_field &amp; STATIC) != 0)
1180                     mask |= STATIC;
<span class="line-modified">1181                 else if ((flags &amp; ENUM) != 0)</span>
1182                     log.error(pos, Errors.EnumsMustBeStatic);



1183                 // Nested interfaces and enums are always STATIC (Spec ???)
<span class="line-modified">1184                 if ((flags &amp; (INTERFACE | ENUM)) != 0 ) implicit = STATIC;</span>
1185             } else {
1186                 mask = ClassFlags;
1187             }
1188             // Interfaces are always ABSTRACT
1189             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1190 
1191             if ((flags &amp; ENUM) != 0) {
1192                 // enums can&#39;t be declared abstract or final
1193                 mask &amp;= ~(ABSTRACT | FINAL);
1194                 implicit |= implicitEnumFinalFlag(tree);
1195             }





1196             // Imply STRICTFP if owner has STRICTFP set.
1197             implicit |= sym.owner.flags_field &amp; STRICTFP;
1198             break;
1199         default:
1200             throw new AssertionError();
1201         }
1202         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1203         if (illegal != 0) {
1204             if ((illegal &amp; INTERFACE) != 0) {
1205                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1206                 mask |= INTERFACE;
1207             }
1208             else {
1209                 log.error(pos,
1210                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1211             }
1212         }
1213         else if ((sym.kind == TYP ||
1214                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1215                   // in the presence of inner classes. Should it be deleted here?
</pre>
<hr />
<pre>
1232                  checkDisjoint(pos, flags,
1233                                PRIVATE,
1234                                PUBLIC | PROTECTED)
1235                  &amp;&amp;
1236                  checkDisjoint(pos, flags,
1237                                FINAL,
1238                                VOLATILE)
1239                  &amp;&amp;
1240                  (sym.kind == TYP ||
1241                   checkDisjoint(pos, flags,
1242                                 ABSTRACT | NATIVE,
1243                                 STRICTFP))) {
1244             // skip
1245         }
1246         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1247     }
1248 
1249 
1250     /** Determine if this enum should be implicitly final.
1251      *
<span class="line-modified">1252      *  If the enum has no specialized enum contants, it is final.</span>
1253      *
<span class="line-modified">1254      *  If the enum does have specialized enum contants, it is</span>
1255      *  &lt;i&gt;not&lt;/i&gt; final.
1256      */
1257     private long implicitEnumFinalFlag(JCTree tree) {
1258         if (!tree.hasTag(CLASSDEF)) return 0;
1259         class SpecialTreeVisitor extends JCTree.Visitor {
1260             boolean specialized;
1261             SpecialTreeVisitor() {
1262                 this.specialized = false;
1263             }
1264 
1265             @Override
1266             public void visitTree(JCTree tree) { /* no-op */ }
1267 
1268             @Override
1269             public void visitVarDef(JCVariableDecl tree) {
1270                 if ((tree.mods.flags &amp; ENUM) != 0) {
1271                     if (tree.init instanceof JCNewClass &amp;&amp;
1272                         ((JCNewClass) tree.init).def != null) {
1273                         specialized = true;
1274                     }
</pre>
<hr />
<pre>
1794                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
1795         }
1796 
1797         // Warn if a deprecated method overridden by a non-deprecated one.
1798         if (!isDeprecatedOverrideIgnorable(other, origin)) {
1799             Lint prevLint = setLint(lint.augment(m));
1800             try {
1801                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
1802             } finally {
1803                 setLint(prevLint);
1804             }
1805         }
1806     }
1807     // where
1808         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
1809             // If the method, m, is defined in an interface, then ignore the issue if the method
1810             // is only inherited via a supertype and also implemented in the supertype,
1811             // because in that case, we will rediscover the issue when examining the method
1812             // in the supertype.
1813             // If the method, m, is not defined in an interface, then the only time we need to
<span class="line-modified">1814             // address the issue is when the method is the supertype implemementation: any other</span>
1815             // case, we will have dealt with when examining the supertype classes
1816             ClassSymbol mc = m.enclClass();
1817             Type st = types.supertype(origin.type);
1818             if (!st.hasTag(CLASS))
1819                 return true;
1820             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
1821 
1822             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
1823                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
1824                 return (intfs.contains(mc.type) ? false : (stimpl != null));
1825             }
1826             else
1827                 return (stimpl != m);
1828         }
1829 
1830 
1831     // used to check if there were any unchecked conversions
1832     Warner overrideWarner = new Warner();
1833 
1834     /** Check that a class does not inherit two concrete methods
</pre>
<hr />
<pre>
1885      *  @param t2           The second argument type.
1886      */
1887     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
1888                                             Type t1,
1889                                             Type t2,
1890                                             Type site) {
1891         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
1892             // special case for intersections: need to eliminate wildcards in supertypes
1893             t1 = types.capture(t1);
1894             t2 = types.capture(t2);
1895         }
1896         return firstIncompatibility(pos, t1, t2, site) == null;
1897     }
1898 
1899     /** Return the first method which is defined with same args
1900      *  but different return types in two given interfaces, or null if none
1901      *  exists.
1902      *  @param t1     The first type.
1903      *  @param t2     The second type.
1904      *  @param site   The most derived type.
<span class="line-modified">1905      *  @returns symbol from t2 that conflicts with one in t1.</span>
1906      */
1907     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
1908         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
1909         closure(t1, interfaces1);
1910         Map&lt;TypeSymbol,Type&gt; interfaces2;
1911         if (t1 == t2)
1912             interfaces2 = interfaces1;
1913         else
1914             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
1915 
1916         for (Type t3 : interfaces1.values()) {
1917             for (Type t4 : interfaces2.values()) {
1918                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
1919                 if (s != null) return s;
1920             }
1921         }
1922         return null;
1923     }
1924 
1925     /** Compute all the supertypes of t, indexed by type symbol. */
1926     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
1927         if (!t.hasTag(CLASS)) return;
1928         if (typeMap.put(t.tsym, t) == null) {
1929             closure(types.supertype(t), typeMap);
1930             for (Type i : types.interfaces(t))
1931                 closure(i, typeMap);
1932         }
1933     }
1934 
<span class="line-modified">1935     /** Compute all the supertypes of t, indexed by type symbol (except thise in typesSkip). */</span>
1936     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
1937         if (!t.hasTag(CLASS)) return;
1938         if (typesSkip.get(t.tsym) != null) return;
1939         if (typeMap.put(t.tsym, t) == null) {
1940             closure(types.supertype(t), typesSkip, typeMap);
1941             for (Type i : types.interfaces(t))
1942                 closure(i, typesSkip, typeMap);
1943         }
1944     }
1945 
1946     /** Return the first method in t2 that conflicts with a method from t1. */
1947     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
1948         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
1949             Type st1 = null;
1950             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
1951                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
1952             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
1953             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
1954             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
1955                 if (s1 == s2) continue;
</pre>
<hr />
<pre>
2404                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2405                     return;
2406         }
2407         checkCompatibleConcretes(pos, c);
2408     }
2409 
2410     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2411      *  are mutually compatible (JLS 8.4.8/9.4.1).
2412      *
2413      *  @param pos  Position to be used for error reporting.
2414      *  @param site The class whose methods are checked.
2415      *  @param sym  The method symbol to be checked.
2416      */
2417     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2418          ClashFilter cf = new ClashFilter(site);
2419         //for each method m1 that is overridden (directly or indirectly)
2420         //by method &#39;sym&#39; in &#39;site&#39;...
2421 
2422         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2423         boolean overridesAny = false;
<span class="line-modified">2424         for (Symbol m1 : types.membersClosure(site, false).getSymbolsByName(sym.name, cf)) {</span>


2425             if (!sym.overrides(m1, site.tsym, types, false)) {
2426                 if (m1 == sym) {
2427                     continue;
2428                 }
2429 
2430                 if (!overridesAny) {
2431                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2432                 }
2433                 continue;
2434             }
2435 
2436             if (m1 != sym) {
2437                 overridesAny = true;
2438                 potentiallyAmbiguousList = List.nil();
2439             }
2440 
2441             //...check each method m2 that is a member of &#39;site&#39;
<span class="line-modified">2442             for (Symbol m2 : types.membersClosure(site, false).getSymbolsByName(sym.name, cf)) {</span>
2443                 if (m2 == m1) continue;
2444                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2445                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2446                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2447                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2448                     sym.flags_field |= CLASH;
2449                     if (m1 == sym) {
2450                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2451                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2452                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2453                     } else {
2454                         ClassType ct = (ClassType)site;
2455                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2456                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2457                             kind,
2458                             ct.tsym.name,
2459                             m1.name,
2460                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2461                             m1.location(),
2462                             m2.name,
</pre>
<hr />
<pre>
2609             if (args1.length() != args2.length()) return;
2610             boolean potentiallyAmbiguous = false;
2611             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2612                 Type s = args1.head;
2613                 Type t = args2.head;
2614                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2615                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2616                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2617                             types.findDescriptorType(s).getParameterTypes().length() ==
2618                             types.findDescriptorType(t).getParameterTypes().length()) {
2619                         potentiallyAmbiguous = true;
2620                     } else {
2621                         break;
2622                     }
2623                 }
2624                 args1 = args1.tail;
2625                 args2 = args2.tail;
2626             }
2627             if (potentiallyAmbiguous) {
2628                 //we found two incompatible functional interfaces with same arity
<span class="line-modified">2629                 //this means a call site passing an implicit lambda would be ambigiuous</span>
2630                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2631                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2632                 log.warning(LintCategory.OVERLOADS, pos,
2633                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2634                                                                   msym2, msym2.location()));
2635                 return;
2636             }
2637         }
2638     }
2639 
2640     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2641         if (warnOnAnyAccessToMembers ||
2642             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2643             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2644             isLambda)) {
2645             Symbol sym = TreeInfo.symbol(tree);
2646             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2647                 return;
2648             }
2649 
</pre>
<hr />
<pre>
2794      * annotation type has a signature that is override-equivalent to
2795      * that of any public or protected method declared in class Object
2796      * or in the interface annotation.Annotation.&quot;
2797      *
2798      * @jls 9.6 Annotation Types
2799      */
2800     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
2801         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
2802             Scope s = sup.tsym.members();
2803             for (Symbol sym : s.getSymbolsByName(m.name)) {
2804                 if (sym.kind == MTH &amp;&amp;
2805                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
2806                     types.overrideEquivalent(m.type, sym.type))
2807                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
2808             }
2809         }
2810     }
2811 
2812     /** Check the annotations of a symbol.
2813      */
<span class="line-modified">2814     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol s) {</span>
2815         for (JCAnnotation a : annotations)
<span class="line-modified">2816             validateAnnotation(a, s);</span>
2817     }
2818 
2819     /** Check the type annotations.
2820      */
2821     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
2822         for (JCAnnotation a : annotations)
2823             validateTypeAnnotation(a, isTypeParameter);
2824     }
2825 
2826     /** Check an annotation of a symbol.
2827      */
<span class="line-modified">2828     private void validateAnnotation(JCAnnotation a, Symbol s) {</span>
2829         validateAnnotationTree(a);












































2830 
<span class="line-modified">2831         if (a.type.tsym.isAnnotationType() &amp;&amp; !annotationApplicable(a, s))</span>
<span class="line-modified">2832             log.error(a.pos(), Errors.AnnotationTypeNotApplicable);</span>
















































































2833 
2834         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
2835             if (s.kind != TYP) {
2836                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
2837             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
2838                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
2839             }
2840         }
2841     }
2842 
2843     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
2844         Assert.checkNonNull(a.type);
2845         validateAnnotationTree(a);
2846 
2847         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
2848                 !a.annotationType.type.isErroneous() &amp;&amp;
2849                 !isTypeAnnotation(a, isTypeParameter)) {
2850             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
2851         }
2852     }
</pre>
<hr />
<pre>
2971                 if (!(app instanceof Attribute.Enum)) {
2972                     continue; // recovery
2973                 }
2974                 Attribute.Enum e = (Attribute.Enum)app;
2975                 containedTargets.add(e.value.name);
2976             }
2977         }
2978 
2979         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
2980             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
2981         }
2982     }
2983 
2984     /* get a set of names for the default target */
2985     private Set&lt;Name&gt; getDefaultTargetSet() {
2986         if (defaultTargets == null) {
2987             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
2988             targets.add(names.ANNOTATION_TYPE);
2989             targets.add(names.CONSTRUCTOR);
2990             targets.add(names.FIELD);

2991             targets.add(names.LOCAL_VARIABLE);
2992             targets.add(names.METHOD);
2993             targets.add(names.PACKAGE);
2994             targets.add(names.PARAMETER);
2995             targets.add(names.TYPE);
2996 
2997             defaultTargets = java.util.Collections.unmodifiableSet(targets);
2998         }
2999 
3000         return defaultTargets;
3001     }
3002     private Set&lt;Name&gt; defaultTargets;
3003 
3004 
3005     /** Checks that s is a subset of t, with respect to ElementType
3006      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3007      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3008      * TYPE_PARAMETER}.
3009      */
3010     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
</pre>
<hr />
<pre>
3062         }
3063         return false;
3064     }
3065 
3066     /** Is the annotation applicable to types? */
3067     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3068         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3069         return (targets == null) ?
3070                 false :
3071                 targets.stream()
3072                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3073     }
3074     //where
3075         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3076             Attribute.Enum e = (Attribute.Enum)a;
3077             return (e.value.name == names.TYPE_USE ||
3078                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3079         }
3080 
3081     /** Is the annotation applicable to the symbol? */
























3082     boolean annotationApplicable(JCAnnotation a, Symbol s) {










3083         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3084         Name[] targets;

3085 
3086         if (arr == null) {
<span class="line-modified">3087             targets = defaultTargetMetaInfo(a, s);</span>
3088         } else {
3089             // TODO: can we optimize this?
3090             targets = new Name[arr.values.length];
3091             for (int i=0; i&lt;arr.values.length; ++i) {
3092                 Attribute app = arr.values[i];
3093                 if (!(app instanceof Attribute.Enum)) {
<span class="line-modified">3094                     return true; // recovery</span>

3095                 }
3096                 Attribute.Enum e = (Attribute.Enum) app;
3097                 targets[i] = e.value.name;
3098             }
3099         }
3100         for (Name target : targets) {
3101             if (target == names.TYPE) {
3102                 if (s.kind == TYP)
<span class="line-modified">3103                     return true;</span>
3104             } else if (target == names.FIELD) {
3105                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
<span class="line-modified">3106                     return true;</span>




3107             } else if (target == names.METHOD) {
3108                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
<span class="line-modified">3109                     return true;</span>
3110             } else if (target == names.PARAMETER) {
<span class="line-modified">3111                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;</span>
<span class="line-modified">3112                       (s.flags() &amp; PARAMETER) != 0) {</span>
<span class="line-modified">3113                     return true;</span>
3114                 }
3115             } else if (target == names.CONSTRUCTOR) {
3116                 if (s.kind == MTH &amp;&amp; s.isConstructor())
<span class="line-modified">3117                     return true;</span>
3118             } else if (target == names.LOCAL_VARIABLE) {
3119                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3120                       (s.flags() &amp; PARAMETER) == 0) {
<span class="line-modified">3121                     return true;</span>
3122                 }
3123             } else if (target == names.ANNOTATION_TYPE) {
3124                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
<span class="line-modified">3125                     return true;</span>
3126                 }
3127             } else if (target == names.PACKAGE) {
3128                 if (s.kind == PCK)
<span class="line-modified">3129                     return true;</span>
3130             } else if (target == names.TYPE_USE) {
3131                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
<span class="line-modified">3132                     //cannot type annotate implictly typed locals</span>
<span class="line-modified">3133                     return false;</span>
3134                 } else if (s.kind == TYP || s.kind == VAR ||
3135                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3136                                 !s.type.getReturnType().hasTag(VOID)) ||
3137                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
<span class="line-modified">3138                     return true;</span>
3139                 }
3140             } else if (target == names.TYPE_PARAMETER) {
3141                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
<span class="line-modified">3142                     return true;</span>
3143             } else
<span class="line-modified">3144                 return true; // Unknown ElementType. This should be an error at declaration site,</span>
<span class="line-modified">3145                              // assume applicable.</span>
3146         }
<span class="line-modified">3147         return false;</span>
3148     }
3149 
<span class="line-removed">3150 </span>
3151     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3152         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3153         if (atTarget == null) return null; // ok, is applicable
3154         Attribute atValue = atTarget.member(names.value);
3155         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3156         return (Attribute.Array) atValue;
3157     }
3158 
<span class="line-modified">3159     private final Name[] dfltTargetMeta;</span>
<span class="line-modified">3160     private Name[] defaultTargetMetaInfo(JCAnnotation a, Symbol s) {</span>
3161         return dfltTargetMeta;
3162     }
3163 
3164     /** Check an annotation value.
3165      *
3166      * @param a The annotation tree to check
3167      * @return true if this annotation tree is valid, otherwise false
3168      */
3169     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3170         boolean res = false;
3171         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3172         try {
3173             res = validateAnnotation(a);
3174         } finally {
3175             log.popDiagnosticHandler(diagHandler);
3176         }
3177         return res;
3178     }
3179 
3180     private boolean validateAnnotation(JCAnnotation a) {
</pre>
<hr />
<pre>
3271                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3272                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3273             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3274         }
3275     }
3276 
3277     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3278         if ((s.flags() &amp; PROPRIETARY) != 0) {
3279             deferredLintHandler.report(() -&gt; {
3280                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3281             });
3282         }
3283     }
3284 
3285     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3286         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3287             log.error(pos, Errors.NotInProfile(s, profile));
3288         }
3289     }
3290 










3291 /* *************************************************************************
3292  * Check for recursive annotation elements.
3293  **************************************************************************/
3294 
3295     /** Check for cycles in the graph of annotation elements.
3296      */
3297     void checkNonCyclicElements(JCClassDecl tree) {
3298         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3299         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3300         try {
3301             tree.sym.flags_field |= LOCKED;
3302             for (JCTree def : tree.defs) {
3303                 if (!def.hasTag(METHODDEF)) continue;
3304                 JCMethodDecl meth = (JCMethodDecl)def;
3305                 checkAnnotationResType(meth.pos(), meth.restype.type);
3306             }
3307         } finally {
3308             tree.sym.flags_field &amp;= ~LOCKED;
3309             tree.sym.flags_field |= ACYCLIC_ANN;
3310         }
</pre>
<hr />
<pre>
3431     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3432         if (sym.type.isErroneous())
3433             return true;
3434         if (sym.owner.name == names.any) return false;
3435         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3436             if (sym != byName &amp;&amp;
3437                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3438                     sym.kind == byName.kind &amp;&amp;
3439                     sym.name != names.error &amp;&amp;
3440                     (sym.kind != MTH ||
3441                      types.hasSameArgs(sym.type, byName.type) ||
3442                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3443                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3444                     sym.flags_field |= CLASH;
3445                     varargsDuplicateError(pos, sym, byName);
3446                     return true;
3447                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3448                     duplicateErasureError(pos, sym, byName);
3449                     sym.flags_field |= CLASH;
3450                     return true;








3451                 } else {
3452                     duplicateError(pos, byName);
3453                     return false;
3454                 }
3455             }
3456         }
3457         return true;
3458     }
3459 
3460     /** Report duplicate declaration error.
3461      */
3462     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3463         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3464             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3465         }
3466     }
3467 
3468     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3469      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3470      * types without an error on the imports.
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
<span class="line-added">  31 import javax.lang.model.element.ElementKind;</span>
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;

  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
<span class="line-added">  96     private final Preview preview;</span>
  97     private final boolean warnOnAnyAccessToMembers;
  98 
  99     // The set of lint options currently in effect. It is initialized
 100     // from the context, and then is set/reset as needed by Attr as it
 101     // visits all the various parts of the trees during attribution.
 102     private Lint lint;
 103 
 104     // The method being analyzed in Attr - it is set/reset as needed by
 105     // Attr as it visits new method declarations.
 106     private MethodSymbol method;
 107 
 108     public static Check instance(Context context) {
 109         Check instance = context.get(checkKey);
 110         if (instance == null)
 111             instance = new Check(context);
 112         return instance;
 113     }
 114 
 115     protected Check(Context context) {
 116         context.put(checkKey, this);
 117 
 118         names = Names.instance(context);
 119         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
<span class="line-modified"> 120             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,</span>
 121             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 122         log = Log.instance(context);
 123         rs = Resolve.instance(context);
 124         syms = Symtab.instance(context);
 125         enter = Enter.instance(context);
 126         deferredAttr = DeferredAttr.instance(context);
 127         infer = Infer.instance(context);
 128         types = Types.instance(context);
 129         typeAnnotations = TypeAnnotations.instance(context);
 130         diags = JCDiagnostic.Factory.instance(context);
 131         Options options = Options.instance(context);
 132         lint = Lint.instance(context);
 133         fileManager = context.get(JavaFileManager.class);
 134 
 135         source = Source.instance(context);
 136         target = Target.instance(context);
 137         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
 138 
 139         Target target = Target.instance(context);
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
<span class="line-added"> 143         preview = Preview.instance(context);</span>
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
 159         deferredLintHandler = DeferredLintHandler.instance(context);
 160     }
 161 
 162     /** Character for synthetic names
 163      */
</pre>
<hr />
<pre>
 209      *  @param sym        The deprecated symbol.
 210      */
 211     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 212         if (sym.isDeprecatedForRemoval()) {
 213             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 214                 if (sym.kind == MDL) {
 215                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 216                 } else {
 217                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 218                 }
 219             }
 220         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 221             if (sym.kind == MDL) {
 222                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 223             } else {
 224                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 225             }
 226         }
 227     }
 228 
<span class="line-added"> 229     /** Warn about deprecated symbol.</span>
<span class="line-added"> 230      *  @param pos        Position to be used for error reporting.</span>
<span class="line-added"> 231      *  @param sym        The deprecated symbol.</span>
<span class="line-added"> 232      */</span>
<span class="line-added"> 233     void warnPreview(DiagnosticPosition pos, Symbol sym) {</span>
<span class="line-added"> 234         warnPreview(pos, Warnings.IsPreview(sym));</span>
<span class="line-added"> 235     }</span>
<span class="line-added"> 236 </span>
<span class="line-added"> 237     /** Log a preview warning.</span>
<span class="line-added"> 238      *  @param pos        Position to be used for error reporting.</span>
<span class="line-added"> 239      *  @param msg        A Warning describing the problem.</span>
<span class="line-added"> 240      */</span>
<span class="line-added"> 241     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {</span>
<span class="line-added"> 242         if (!lint.isSuppressed(LintCategory.PREVIEW))</span>
<span class="line-added"> 243             preview.reportPreviewWarning(pos, warnKey);</span>
<span class="line-added"> 244     }</span>
<span class="line-added"> 245 </span>
 246     /** Warn about unchecked operation.
 247      *  @param pos        Position to be used for error reporting.
 248      *  @param msg        A string describing the problem.
 249      */
 250     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 251         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 252             uncheckedHandler.report(pos, warnKey);
 253     }
 254 
 255     /** Warn about unsafe vararg method decl.
 256      *  @param pos        Position to be used for error reporting.
 257      */
 258     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 259         if (lint.isEnabled(LintCategory.VARARGS))
 260             log.warning(LintCategory.VARARGS, pos, warnKey);
 261     }
 262 
 263     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 264         if (lint.isEnabled(LintCategory.STATIC))
 265             log.warning(LintCategory.STATIC, pos, warnKey);
</pre>
<hr />
<pre>
 316      *  @param sym        The referenced symbol.
 317      */
 318     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 319         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 320     }
 321 
 322     /** Report duplicate declaration error.
 323      */
 324     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 325         if (!sym.type.isErroneous()) {
 326             Symbol location = sym.location();
 327             if (location.kind == MTH &amp;&amp;
 328                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 329                 log.error(pos,
 330                           Errors.AlreadyDefinedInClinit(kindName(sym),
 331                                                         sym,
 332                                                         kindName(sym.location()),
 333                                                         kindName(sym.location().enclClass()),
 334                                                         sym.location().enclClass()));
 335             } else {
<span class="line-modified"> 336                 /* dont error if this is a duplicated parameter of a generated canonical constructor</span>
<span class="line-modified"> 337                  * as we should have issued an error for the duplicated fields</span>
<span class="line-modified"> 338                  */</span>
<span class="line-modified"> 339                 if (location.kind != MTH ||</span>
<span class="line-modified"> 340                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||</span>
<span class="line-added"> 341                         ((sym.owner.flags_field &amp; RECORD) == 0)) {</span>
<span class="line-added"> 342                     log.error(pos,</span>
<span class="line-added"> 343                             Errors.AlreadyDefined(kindName(sym),</span>
<span class="line-added"> 344                                     sym,</span>
<span class="line-added"> 345                                     kindName(sym.location()),</span>
<span class="line-added"> 346                                     sym.location()));</span>
<span class="line-added"> 347                 }</span>
 348             }
 349         }
 350     }
 351 
 352     /** Report array/varargs duplicate declaration
 353      */
 354     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 355         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 356             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 357         }
 358     }
 359 
 360 /* ************************************************************************
 361  * duplicate declaration checking
 362  *************************************************************************/
 363 
 364     /** Check that variable does not hide variable with same name in
 365      *  immediately enclosing local scope.
 366      *  @param pos           Position for error reporting.
 367      *  @param v             The symbol.
</pre>
<hr />
<pre>
 416                 duplicateError(pos, sym);
 417                 return true;
 418             }
 419         }
 420         return true;
 421     }
 422 
 423 /* *************************************************************************
 424  * Class name generation
 425  **************************************************************************/
 426 
 427 
 428     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 429 
 430     /** Return name of local class.
 431      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 432      *  where
 433      *    enclClass is the flat name of the enclosing class,
 434      *    classname is the simple name of the local class
 435      */
<span class="line-modified"> 436     public Name localClassName(ClassSymbol c) {</span>
 437         Name enclFlatname = c.owner.enclClass().flatname;
 438         String enclFlatnameStr = enclFlatname.toString();
 439         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 440         Integer index = localClassNameIndexes.get(key);
 441         for (int i = (index == null) ? 1 : index; ; i++) {
 442             Name flatname = names.fromString(enclFlatnameStr
 443                     + syntheticNameChar + i + c.name);
 444             if (getCompiled(c.packge().modle, flatname) == null) {
 445                 localClassNameIndexes.put(key, i + 1);
 446                 return flatname;
 447             }
 448         }
 449     }
 450 
<span class="line-modified"> 451     public void clearLocalClassNameIndexes(ClassSymbol c) {</span>
 452         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 453             localClassNameIndexes.remove(new Pair&lt;&gt;(
 454                     c.owner.enclClass().flatname, c.name));
 455         }
 456     }
 457 
 458     public void newRound() {
 459         compiled.clear();
 460         localClassNameIndexes.clear();
 461     }
 462 
<span class="line-added"> 463     public void clear() {</span>
<span class="line-added"> 464         deprecationHandler.clear();</span>
<span class="line-added"> 465         removalHandler.clear();</span>
<span class="line-added"> 466         uncheckedHandler.clear();</span>
<span class="line-added"> 467         sunApiHandler.clear();</span>
<span class="line-added"> 468     }</span>
<span class="line-added"> 469 </span>
 470     public void putCompiled(ClassSymbol csym) {
 471         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 472     }
 473 
 474     public ClassSymbol getCompiled(ClassSymbol csym) {
 475         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 476     }
 477 
 478     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 479         return compiled.get(Pair.of(msym, flatname));
 480     }
 481 
 482     public void removeCompiled(ClassSymbol csym) {
 483         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 484     }
 485 
 486 /* *************************************************************************
 487  * Type Checking
 488  **************************************************************************/
 489 
</pre>
<hr />
<pre>
1175                     // enum constructors cannot be declared public or
1176                     // protected and must be implicitly or explicitly
1177                     // private
1178                     implicit = PRIVATE;
1179                     mask = PRIVATE;
1180                 } else
1181                     mask = ConstructorFlags;
1182             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1183                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1184                     mask = AnnotationTypeElementMask;
1185                     implicit = PUBLIC | ABSTRACT;
1186                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1187                     mask = InterfaceMethodMask;
1188                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1189                     if ((flags &amp; DEFAULT) != 0) {
1190                         implicit |= ABSTRACT;
1191                     }
1192                 } else {
1193                     mask = implicit = InterfaceMethodFlags;
1194                 }
<span class="line-added">1195             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {</span>
<span class="line-added">1196                 mask = RecordMethodFlags;</span>
1197             } else {
1198                 mask = MethodFlags;
1199             }
1200             // Imply STRICTFP if owner has STRICTFP set.
1201             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1202                 ((flags) &amp; Flags.DEFAULT) != 0)
1203                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1204             break;
1205         case TYP:
1206             if (sym.isLocal()) {
<span class="line-modified">1207                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;</span>
<span class="line-added">1208                 if ((flags &amp; RECORD) != 0) {</span>
<span class="line-added">1209                     implicit = STATIC;</span>
<span class="line-added">1210                     if (sym.owner.kind == TYP) {</span>
<span class="line-added">1211                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);</span>
<span class="line-added">1212                     }</span>
<span class="line-added">1213                 }</span>
1214                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
<span class="line-modified">1215                     (flags &amp; ENUM) != 0) {</span>
1216                     log.error(pos, Errors.EnumsMustBeStatic);
<span class="line-added">1217                 }</span>
1218             } else if (sym.owner.kind == TYP) {
<span class="line-modified">1219                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;</span>
1220                 if (sym.owner.owner.kind == PCK ||
1221                     (sym.owner.flags_field &amp; STATIC) != 0)
1222                     mask |= STATIC;
<span class="line-modified">1223                 else if ((flags &amp; ENUM) != 0) {</span>
1224                     log.error(pos, Errors.EnumsMustBeStatic);
<span class="line-added">1225                 } else if ((flags &amp; RECORD) != 0) {</span>
<span class="line-added">1226                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);</span>
<span class="line-added">1227                 }</span>
1228                 // Nested interfaces and enums are always STATIC (Spec ???)
<span class="line-modified">1229                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;</span>
1230             } else {
1231                 mask = ClassFlags;
1232             }
1233             // Interfaces are always ABSTRACT
1234             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1235 
1236             if ((flags &amp; ENUM) != 0) {
1237                 // enums can&#39;t be declared abstract or final
1238                 mask &amp;= ~(ABSTRACT | FINAL);
1239                 implicit |= implicitEnumFinalFlag(tree);
1240             }
<span class="line-added">1241             if ((flags &amp; RECORD) != 0) {</span>
<span class="line-added">1242                 // records can&#39;t be declared abstract</span>
<span class="line-added">1243                 mask &amp;= ~ABSTRACT;</span>
<span class="line-added">1244                 implicit |= FINAL;</span>
<span class="line-added">1245             }</span>
1246             // Imply STRICTFP if owner has STRICTFP set.
1247             implicit |= sym.owner.flags_field &amp; STRICTFP;
1248             break;
1249         default:
1250             throw new AssertionError();
1251         }
1252         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1253         if (illegal != 0) {
1254             if ((illegal &amp; INTERFACE) != 0) {
1255                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1256                 mask |= INTERFACE;
1257             }
1258             else {
1259                 log.error(pos,
1260                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1261             }
1262         }
1263         else if ((sym.kind == TYP ||
1264                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1265                   // in the presence of inner classes. Should it be deleted here?
</pre>
<hr />
<pre>
1282                  checkDisjoint(pos, flags,
1283                                PRIVATE,
1284                                PUBLIC | PROTECTED)
1285                  &amp;&amp;
1286                  checkDisjoint(pos, flags,
1287                                FINAL,
1288                                VOLATILE)
1289                  &amp;&amp;
1290                  (sym.kind == TYP ||
1291                   checkDisjoint(pos, flags,
1292                                 ABSTRACT | NATIVE,
1293                                 STRICTFP))) {
1294             // skip
1295         }
1296         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1297     }
1298 
1299 
1300     /** Determine if this enum should be implicitly final.
1301      *
<span class="line-modified">1302      *  If the enum has no specialized enum constants, it is final.</span>
1303      *
<span class="line-modified">1304      *  If the enum does have specialized enum constants, it is</span>
1305      *  &lt;i&gt;not&lt;/i&gt; final.
1306      */
1307     private long implicitEnumFinalFlag(JCTree tree) {
1308         if (!tree.hasTag(CLASSDEF)) return 0;
1309         class SpecialTreeVisitor extends JCTree.Visitor {
1310             boolean specialized;
1311             SpecialTreeVisitor() {
1312                 this.specialized = false;
1313             }
1314 
1315             @Override
1316             public void visitTree(JCTree tree) { /* no-op */ }
1317 
1318             @Override
1319             public void visitVarDef(JCVariableDecl tree) {
1320                 if ((tree.mods.flags &amp; ENUM) != 0) {
1321                     if (tree.init instanceof JCNewClass &amp;&amp;
1322                         ((JCNewClass) tree.init).def != null) {
1323                         specialized = true;
1324                     }
</pre>
<hr />
<pre>
1844                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
1845         }
1846 
1847         // Warn if a deprecated method overridden by a non-deprecated one.
1848         if (!isDeprecatedOverrideIgnorable(other, origin)) {
1849             Lint prevLint = setLint(lint.augment(m));
1850             try {
1851                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
1852             } finally {
1853                 setLint(prevLint);
1854             }
1855         }
1856     }
1857     // where
1858         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
1859             // If the method, m, is defined in an interface, then ignore the issue if the method
1860             // is only inherited via a supertype and also implemented in the supertype,
1861             // because in that case, we will rediscover the issue when examining the method
1862             // in the supertype.
1863             // If the method, m, is not defined in an interface, then the only time we need to
<span class="line-modified">1864             // address the issue is when the method is the supertype implementation: any other</span>
1865             // case, we will have dealt with when examining the supertype classes
1866             ClassSymbol mc = m.enclClass();
1867             Type st = types.supertype(origin.type);
1868             if (!st.hasTag(CLASS))
1869                 return true;
1870             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
1871 
1872             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
1873                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
1874                 return (intfs.contains(mc.type) ? false : (stimpl != null));
1875             }
1876             else
1877                 return (stimpl != m);
1878         }
1879 
1880 
1881     // used to check if there were any unchecked conversions
1882     Warner overrideWarner = new Warner();
1883 
1884     /** Check that a class does not inherit two concrete methods
</pre>
<hr />
<pre>
1935      *  @param t2           The second argument type.
1936      */
1937     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
1938                                             Type t1,
1939                                             Type t2,
1940                                             Type site) {
1941         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
1942             // special case for intersections: need to eliminate wildcards in supertypes
1943             t1 = types.capture(t1);
1944             t2 = types.capture(t2);
1945         }
1946         return firstIncompatibility(pos, t1, t2, site) == null;
1947     }
1948 
1949     /** Return the first method which is defined with same args
1950      *  but different return types in two given interfaces, or null if none
1951      *  exists.
1952      *  @param t1     The first type.
1953      *  @param t2     The second type.
1954      *  @param site   The most derived type.
<span class="line-modified">1955      *  @return symbol from t2 that conflicts with one in t1.</span>
1956      */
1957     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
1958         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
1959         closure(t1, interfaces1);
1960         Map&lt;TypeSymbol,Type&gt; interfaces2;
1961         if (t1 == t2)
1962             interfaces2 = interfaces1;
1963         else
1964             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
1965 
1966         for (Type t3 : interfaces1.values()) {
1967             for (Type t4 : interfaces2.values()) {
1968                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
1969                 if (s != null) return s;
1970             }
1971         }
1972         return null;
1973     }
1974 
1975     /** Compute all the supertypes of t, indexed by type symbol. */
1976     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
1977         if (!t.hasTag(CLASS)) return;
1978         if (typeMap.put(t.tsym, t) == null) {
1979             closure(types.supertype(t), typeMap);
1980             for (Type i : types.interfaces(t))
1981                 closure(i, typeMap);
1982         }
1983     }
1984 
<span class="line-modified">1985     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */</span>
1986     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
1987         if (!t.hasTag(CLASS)) return;
1988         if (typesSkip.get(t.tsym) != null) return;
1989         if (typeMap.put(t.tsym, t) == null) {
1990             closure(types.supertype(t), typesSkip, typeMap);
1991             for (Type i : types.interfaces(t))
1992                 closure(i, typesSkip, typeMap);
1993         }
1994     }
1995 
1996     /** Return the first method in t2 that conflicts with a method from t1. */
1997     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
1998         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
1999             Type st1 = null;
2000             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2001                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2002             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2003             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2004             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2005                 if (s1 == s2) continue;
</pre>
<hr />
<pre>
2454                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2455                     return;
2456         }
2457         checkCompatibleConcretes(pos, c);
2458     }
2459 
2460     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2461      *  are mutually compatible (JLS 8.4.8/9.4.1).
2462      *
2463      *  @param pos  Position to be used for error reporting.
2464      *  @param site The class whose methods are checked.
2465      *  @param sym  The method symbol to be checked.
2466      */
2467     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2468          ClashFilter cf = new ClashFilter(site);
2469         //for each method m1 that is overridden (directly or indirectly)
2470         //by method &#39;sym&#39; in &#39;site&#39;...
2471 
2472         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2473         boolean overridesAny = false;
<span class="line-modified">2474         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();</span>
<span class="line-added">2475         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);</span>
<span class="line-added">2476         for (Symbol m1 : symbolsByName) {</span>
2477             if (!sym.overrides(m1, site.tsym, types, false)) {
2478                 if (m1 == sym) {
2479                     continue;
2480                 }
2481 
2482                 if (!overridesAny) {
2483                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2484                 }
2485                 continue;
2486             }
2487 
2488             if (m1 != sym) {
2489                 overridesAny = true;
2490                 potentiallyAmbiguousList = List.nil();
2491             }
2492 
2493             //...check each method m2 that is a member of &#39;site&#39;
<span class="line-modified">2494             for (Symbol m2 : symbolsByName) {</span>
2495                 if (m2 == m1) continue;
2496                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2497                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2498                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2499                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2500                     sym.flags_field |= CLASH;
2501                     if (m1 == sym) {
2502                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2503                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2504                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2505                     } else {
2506                         ClassType ct = (ClassType)site;
2507                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2508                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2509                             kind,
2510                             ct.tsym.name,
2511                             m1.name,
2512                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2513                             m1.location(),
2514                             m2.name,
</pre>
<hr />
<pre>
2661             if (args1.length() != args2.length()) return;
2662             boolean potentiallyAmbiguous = false;
2663             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2664                 Type s = args1.head;
2665                 Type t = args2.head;
2666                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2667                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2668                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2669                             types.findDescriptorType(s).getParameterTypes().length() ==
2670                             types.findDescriptorType(t).getParameterTypes().length()) {
2671                         potentiallyAmbiguous = true;
2672                     } else {
2673                         break;
2674                     }
2675                 }
2676                 args1 = args1.tail;
2677                 args2 = args2.tail;
2678             }
2679             if (potentiallyAmbiguous) {
2680                 //we found two incompatible functional interfaces with same arity
<span class="line-modified">2681                 //this means a call site passing an implicit lambda would be ambiguous</span>
2682                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2683                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2684                 log.warning(LintCategory.OVERLOADS, pos,
2685                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2686                                                                   msym2, msym2.location()));
2687                 return;
2688             }
2689         }
2690     }
2691 
2692     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2693         if (warnOnAnyAccessToMembers ||
2694             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2695             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2696             isLambda)) {
2697             Symbol sym = TreeInfo.symbol(tree);
2698             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2699                 return;
2700             }
2701 
</pre>
<hr />
<pre>
2846      * annotation type has a signature that is override-equivalent to
2847      * that of any public or protected method declared in class Object
2848      * or in the interface annotation.Annotation.&quot;
2849      *
2850      * @jls 9.6 Annotation Types
2851      */
2852     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
2853         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
2854             Scope s = sup.tsym.members();
2855             for (Symbol sym : s.getSymbolsByName(m.name)) {
2856                 if (sym.kind == MTH &amp;&amp;
2857                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
2858                     types.overrideEquivalent(m.type, sym.type))
2859                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
2860             }
2861         }
2862     }
2863 
2864     /** Check the annotations of a symbol.
2865      */
<span class="line-modified">2866     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {</span>
2867         for (JCAnnotation a : annotations)
<span class="line-modified">2868             validateAnnotation(a, declarationTree, s);</span>
2869     }
2870 
2871     /** Check the type annotations.
2872      */
2873     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
2874         for (JCAnnotation a : annotations)
2875             validateTypeAnnotation(a, isTypeParameter);
2876     }
2877 
2878     /** Check an annotation of a symbol.
2879      */
<span class="line-modified">2880     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {</span>
2881         validateAnnotationTree(a);
<span class="line-added">2882         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();</span>
<span class="line-added">2883 </span>
<span class="line-added">2884         boolean isRecordField = isRecordMember &amp;&amp;</span>
<span class="line-added">2885                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;</span>
<span class="line-added">2886                 declarationTree.hasTag(VARDEF) &amp;&amp;</span>
<span class="line-added">2887                 s.owner.kind == TYP;</span>
<span class="line-added">2888 </span>
<span class="line-added">2889         if (isRecordField) {</span>
<span class="line-added">2890             // first we need to check if the annotation is applicable to records</span>
<span class="line-added">2891             Name[] targets = getTargetNames(a);</span>
<span class="line-added">2892             boolean appliesToRecords = false;</span>
<span class="line-added">2893             for (Name target : targets) {</span>
<span class="line-added">2894                 appliesToRecords =</span>
<span class="line-added">2895                                 target == names.FIELD ||</span>
<span class="line-added">2896                                 target == names.PARAMETER ||</span>
<span class="line-added">2897                                 target == names.METHOD ||</span>
<span class="line-added">2898                                 target == names.TYPE_USE ||</span>
<span class="line-added">2899                                 target == names.RECORD_COMPONENT;</span>
<span class="line-added">2900                 if (appliesToRecords) {</span>
<span class="line-added">2901                     break;</span>
<span class="line-added">2902                 }</span>
<span class="line-added">2903             }</span>
<span class="line-added">2904             if (!appliesToRecords) {</span>
<span class="line-added">2905                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);</span>
<span class="line-added">2906             } else {</span>
<span class="line-added">2907                 /* lets now find the annotations in the field that are targeted to record components and append them to</span>
<span class="line-added">2908                  * the corresponding record component</span>
<span class="line-added">2909                  */</span>
<span class="line-added">2910                 ClassSymbol recordClass = (ClassSymbol) s.owner;</span>
<span class="line-added">2911                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);</span>
<span class="line-added">2912                 SymbolMetadata metadata = rc.getMetadata();</span>
<span class="line-added">2913                 if (metadata == null || metadata.isEmpty()) {</span>
<span class="line-added">2914                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied</span>
<span class="line-added">2915                      * to the record component declaration</span>
<span class="line-added">2916                      */</span>
<span class="line-added">2917                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;</span>
<span class="line-added">2918                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)</span>
<span class="line-added">2919                     ).collect(List.collector()));</span>
<span class="line-added">2920                     rc.setTypeAttributes(s.getRawTypeAttributes());</span>
<span class="line-added">2921                     // to get all the type annotations applied to the type</span>
<span class="line-added">2922                     rc.type = s.type;</span>
<span class="line-added">2923                 }</span>
<span class="line-added">2924             }</span>
<span class="line-added">2925         }</span>
2926 
<span class="line-modified">2927         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding</span>
<span class="line-modified">2928          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has</span>
<span class="line-added">2929          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated</span>
<span class="line-added">2930          * there is no enough information to propagate only the right annotations. So all the annotations are propagated</span>
<span class="line-added">2931          * to all the possible locations.</span>
<span class="line-added">2932          *</span>
<span class="line-added">2933          * At this point we need to remove all the annotations that are not in place before going on with the annotation</span>
<span class="line-added">2934          * party. On top of the above there is the issue that there is no AST representing record components, just symbols</span>
<span class="line-added">2935          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it</span>
<span class="line-added">2936          * was both a field and a record component.</span>
<span class="line-added">2937          *</span>
<span class="line-added">2938          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers</span>
<span class="line-added">2939          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could</span>
<span class="line-added">2940          * be see by annotation processors.</span>
<span class="line-added">2941          *</span>
<span class="line-added">2942          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t</span>
<span class="line-added">2943          * need to care about type annotations, they are all in the right place. But we could need to remove declaration</span>
<span class="line-added">2944          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type</span>
<span class="line-added">2945          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not</span>
<span class="line-added">2946          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.</span>
<span class="line-added">2947          *</span>
<span class="line-added">2948          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for</span>
<span class="line-added">2949          * further inspection by annotation processors.</span>
<span class="line-added">2950          *</span>
<span class="line-added">2951          * For example:</span>
<span class="line-added">2952          *</span>
<span class="line-added">2953          *     import java.lang.annotation.*;</span>
<span class="line-added">2954          *</span>
<span class="line-added">2955          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})</span>
<span class="line-added">2956          *     @Retention(RetentionPolicy.RUNTIME)</span>
<span class="line-added">2957          *     @interface Anno { }</span>
<span class="line-added">2958          *</span>
<span class="line-added">2959          *     record R(@Anno String s) {}</span>
<span class="line-added">2960          *</span>
<span class="line-added">2961          * at this point we will have for the case of the generated field:</span>
<span class="line-added">2962          *   - @Anno in the modifier</span>
<span class="line-added">2963          *   - @Anno as a type annotation</span>
<span class="line-added">2964          *   - @Anno as a declaration annotation</span>
<span class="line-added">2965          *</span>
<span class="line-added">2966          * the last one should be removed because the annotation has not FIELD as target but it was applied as a</span>
<span class="line-added">2967          * declaration annotation because the field was being treated both as a field and as a record component</span>
<span class="line-added">2968          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold</span>
<span class="line-added">2969          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it</span>
<span class="line-added">2970          * is applicable as a type annotation to the type of the field.</span>
<span class="line-added">2971          */</span>
<span class="line-added">2972 </span>
<span class="line-added">2973         if (a.type.tsym.isAnnotationType()) {</span>
<span class="line-added">2974             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);</span>
<span class="line-added">2975             if (!applicableTargetsOp.isEmpty()) {</span>
<span class="line-added">2976                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();</span>
<span class="line-added">2977                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||</span>
<span class="line-added">2978                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);</span>
<span class="line-added">2979                 boolean isRecordMemberWithNonApplicableDeclAnno =</span>
<span class="line-added">2980                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;</span>
<span class="line-added">2981 </span>
<span class="line-added">2982                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {</span>
<span class="line-added">2983                     if (isRecordMemberWithNonApplicableDeclAnno) {</span>
<span class="line-added">2984                             /* so we have found an annotation that is not applicable to a record member that was generated by the</span>
<span class="line-added">2985                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations</span>
<span class="line-added">2986                              * that are not applicable to the given record member</span>
<span class="line-added">2987                              */</span>
<span class="line-added">2988                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);</span>
<span class="line-added">2989                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as</span>
<span class="line-added">2990                              * it could be a type annotation</span>
<span class="line-added">2991                              */</span>
<span class="line-added">2992                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {</span>
<span class="line-added">2993                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();</span>
<span class="line-added">2994                             for (JCAnnotation anno : modifiers.annotations) {</span>
<span class="line-added">2995                                 if (anno != a) {</span>
<span class="line-added">2996                                     newAnnotations.add(anno);</span>
<span class="line-added">2997                                 }</span>
<span class="line-added">2998                             }</span>
<span class="line-added">2999                             modifiers.annotations = newAnnotations.toList();</span>
<span class="line-added">3000                         }</span>
<span class="line-added">3001                         // now lets remove it from the symbol</span>
<span class="line-added">3002                         s.getMetadata().removeDeclarationMetadata(a.attribute);</span>
<span class="line-added">3003                     } else {</span>
<span class="line-added">3004                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);</span>
<span class="line-added">3005                     }</span>
<span class="line-added">3006                 }</span>
<span class="line-added">3007             }</span>
<span class="line-added">3008         }</span>
3009 
3010         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3011             if (s.kind != TYP) {
3012                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3013             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3014                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3015             }
3016         }
3017     }
3018 
3019     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3020         Assert.checkNonNull(a.type);
3021         validateAnnotationTree(a);
3022 
3023         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3024                 !a.annotationType.type.isErroneous() &amp;&amp;
3025                 !isTypeAnnotation(a, isTypeParameter)) {
3026             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3027         }
3028     }
</pre>
<hr />
<pre>
3147                 if (!(app instanceof Attribute.Enum)) {
3148                     continue; // recovery
3149                 }
3150                 Attribute.Enum e = (Attribute.Enum)app;
3151                 containedTargets.add(e.value.name);
3152             }
3153         }
3154 
3155         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3156             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3157         }
3158     }
3159 
3160     /* get a set of names for the default target */
3161     private Set&lt;Name&gt; getDefaultTargetSet() {
3162         if (defaultTargets == null) {
3163             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3164             targets.add(names.ANNOTATION_TYPE);
3165             targets.add(names.CONSTRUCTOR);
3166             targets.add(names.FIELD);
<span class="line-added">3167             targets.add(names.RECORD_COMPONENT);</span>
3168             targets.add(names.LOCAL_VARIABLE);
3169             targets.add(names.METHOD);
3170             targets.add(names.PACKAGE);
3171             targets.add(names.PARAMETER);
3172             targets.add(names.TYPE);
3173 
3174             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3175         }
3176 
3177         return defaultTargets;
3178     }
3179     private Set&lt;Name&gt; defaultTargets;
3180 
3181 
3182     /** Checks that s is a subset of t, with respect to ElementType
3183      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3184      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3185      * TYPE_PARAMETER}.
3186      */
3187     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
</pre>
<hr />
<pre>
3239         }
3240         return false;
3241     }
3242 
3243     /** Is the annotation applicable to types? */
3244     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3245         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3246         return (targets == null) ?
3247                 false :
3248                 targets.stream()
3249                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3250     }
3251     //where
3252         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3253             Attribute.Enum e = (Attribute.Enum)a;
3254             return (e.value.name == names.TYPE_USE ||
3255                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3256         }
3257 
3258     /** Is the annotation applicable to the symbol? */
<span class="line-added">3259     Name[] getTargetNames(JCAnnotation a) {</span>
<span class="line-added">3260         return getTargetNames(a.annotationType.type.tsym);</span>
<span class="line-added">3261     }</span>
<span class="line-added">3262 </span>
<span class="line-added">3263     public Name[] getTargetNames(TypeSymbol annoSym) {</span>
<span class="line-added">3264         Attribute.Array arr = getAttributeTargetAttribute(annoSym);</span>
<span class="line-added">3265         Name[] targets;</span>
<span class="line-added">3266         if (arr == null) {</span>
<span class="line-added">3267             targets = defaultTargetMetaInfo();</span>
<span class="line-added">3268         } else {</span>
<span class="line-added">3269             // TODO: can we optimize this?</span>
<span class="line-added">3270             targets = new Name[arr.values.length];</span>
<span class="line-added">3271             for (int i=0; i&lt;arr.values.length; ++i) {</span>
<span class="line-added">3272                 Attribute app = arr.values[i];</span>
<span class="line-added">3273                 if (!(app instanceof Attribute.Enum)) {</span>
<span class="line-added">3274                     return new Name[0];</span>
<span class="line-added">3275                 }</span>
<span class="line-added">3276                 Attribute.Enum e = (Attribute.Enum) app;</span>
<span class="line-added">3277                 targets[i] = e.value.name;</span>
<span class="line-added">3278             }</span>
<span class="line-added">3279         }</span>
<span class="line-added">3280         return targets;</span>
<span class="line-added">3281     }</span>
<span class="line-added">3282 </span>
3283     boolean annotationApplicable(JCAnnotation a, Symbol s) {
<span class="line-added">3284         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);</span>
<span class="line-added">3285         /* the optional could be emtpy if the annotation is unknown in that case</span>
<span class="line-added">3286          * we return that it is applicable and if it is erroneous that should imply</span>
<span class="line-added">3287          * an error at the declaration site</span>
<span class="line-added">3288          */</span>
<span class="line-added">3289         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();</span>
<span class="line-added">3290     }</span>
<span class="line-added">3291 </span>
<span class="line-added">3292     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added">3293     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {</span>
3294         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3295         Name[] targets;
<span class="line-added">3296         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();</span>
3297 
3298         if (arr == null) {
<span class="line-modified">3299             targets = defaultTargetMetaInfo();</span>
3300         } else {
3301             // TODO: can we optimize this?
3302             targets = new Name[arr.values.length];
3303             for (int i=0; i&lt;arr.values.length; ++i) {
3304                 Attribute app = arr.values[i];
3305                 if (!(app instanceof Attribute.Enum)) {
<span class="line-modified">3306                     // recovery</span>
<span class="line-added">3307                     return Optional.empty();</span>
3308                 }
3309                 Attribute.Enum e = (Attribute.Enum) app;
3310                 targets[i] = e.value.name;
3311             }
3312         }
3313         for (Name target : targets) {
3314             if (target == names.TYPE) {
3315                 if (s.kind == TYP)
<span class="line-modified">3316                     applicableTargets.add(names.TYPE);</span>
3317             } else if (target == names.FIELD) {
3318                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
<span class="line-modified">3319                     applicableTargets.add(names.FIELD);</span>
<span class="line-added">3320             } else if (target == names.RECORD_COMPONENT) {</span>
<span class="line-added">3321                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {</span>
<span class="line-added">3322                     applicableTargets.add(names.RECORD_COMPONENT);</span>
<span class="line-added">3323                 }</span>
3324             } else if (target == names.METHOD) {
3325                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
<span class="line-modified">3326                     applicableTargets.add(names.METHOD);</span>
3327             } else if (target == names.PARAMETER) {
<span class="line-modified">3328                 if (s.kind == VAR &amp;&amp;</span>
<span class="line-modified">3329                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {</span>
<span class="line-modified">3330                     applicableTargets.add(names.PARAMETER);</span>
3331                 }
3332             } else if (target == names.CONSTRUCTOR) {
3333                 if (s.kind == MTH &amp;&amp; s.isConstructor())
<span class="line-modified">3334                     applicableTargets.add(names.CONSTRUCTOR);</span>
3335             } else if (target == names.LOCAL_VARIABLE) {
3336                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3337                       (s.flags() &amp; PARAMETER) == 0) {
<span class="line-modified">3338                     applicableTargets.add(names.LOCAL_VARIABLE);</span>
3339                 }
3340             } else if (target == names.ANNOTATION_TYPE) {
3341                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
<span class="line-modified">3342                     applicableTargets.add(names.ANNOTATION_TYPE);</span>
3343                 }
3344             } else if (target == names.PACKAGE) {
3345                 if (s.kind == PCK)
<span class="line-modified">3346                     applicableTargets.add(names.PACKAGE);</span>
3347             } else if (target == names.TYPE_USE) {
3348                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
<span class="line-modified">3349                     //cannot type annotate implicitly typed locals</span>
<span class="line-modified">3350                     continue;</span>
3351                 } else if (s.kind == TYP || s.kind == VAR ||
3352                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3353                                 !s.type.getReturnType().hasTag(VOID)) ||
3354                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
<span class="line-modified">3355                     applicableTargets.add(names.TYPE_USE);</span>
3356                 }
3357             } else if (target == names.TYPE_PARAMETER) {
3358                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
<span class="line-modified">3359                     applicableTargets.add(names.TYPE_PARAMETER);</span>
3360             } else
<span class="line-modified">3361                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,</span>
<span class="line-modified">3362                                          // assume applicable.</span>
3363         }
<span class="line-modified">3364         return Optional.of(applicableTargets);</span>
3365     }
3366 

3367     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3368         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3369         if (atTarget == null) return null; // ok, is applicable
3370         Attribute atValue = atTarget.member(names.value);
3371         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3372         return (Attribute.Array) atValue;
3373     }
3374 
<span class="line-modified">3375     public final Name[] dfltTargetMeta;</span>
<span class="line-modified">3376     private Name[] defaultTargetMetaInfo() {</span>
3377         return dfltTargetMeta;
3378     }
3379 
3380     /** Check an annotation value.
3381      *
3382      * @param a The annotation tree to check
3383      * @return true if this annotation tree is valid, otherwise false
3384      */
3385     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3386         boolean res = false;
3387         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3388         try {
3389             res = validateAnnotation(a);
3390         } finally {
3391             log.popDiagnosticHandler(diagHandler);
3392         }
3393         return res;
3394     }
3395 
3396     private boolean validateAnnotation(JCAnnotation a) {
</pre>
<hr />
<pre>
3487                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3488                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3489             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3490         }
3491     }
3492 
3493     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3494         if ((s.flags() &amp; PROPRIETARY) != 0) {
3495             deferredLintHandler.report(() -&gt; {
3496                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3497             });
3498         }
3499     }
3500 
3501     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3502         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3503             log.error(pos, Errors.NotInProfile(s, profile));
3504         }
3505     }
3506 
<span class="line-added">3507     void checkPreview(DiagnosticPosition pos, Symbol s) {</span>
<span class="line-added">3508         if ((s.flags() &amp; PREVIEW_API) != 0) {</span>
<span class="line-added">3509             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {</span>
<span class="line-added">3510                 log.error(pos, Errors.IsPreview(s));</span>
<span class="line-added">3511             } else {</span>
<span class="line-added">3512                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));</span>
<span class="line-added">3513             }</span>
<span class="line-added">3514         }</span>
<span class="line-added">3515     }</span>
<span class="line-added">3516 </span>
3517 /* *************************************************************************
3518  * Check for recursive annotation elements.
3519  **************************************************************************/
3520 
3521     /** Check for cycles in the graph of annotation elements.
3522      */
3523     void checkNonCyclicElements(JCClassDecl tree) {
3524         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3525         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3526         try {
3527             tree.sym.flags_field |= LOCKED;
3528             for (JCTree def : tree.defs) {
3529                 if (!def.hasTag(METHODDEF)) continue;
3530                 JCMethodDecl meth = (JCMethodDecl)def;
3531                 checkAnnotationResType(meth.pos(), meth.restype.type);
3532             }
3533         } finally {
3534             tree.sym.flags_field &amp;= ~LOCKED;
3535             tree.sym.flags_field |= ACYCLIC_ANN;
3536         }
</pre>
<hr />
<pre>
3657     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3658         if (sym.type.isErroneous())
3659             return true;
3660         if (sym.owner.name == names.any) return false;
3661         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3662             if (sym != byName &amp;&amp;
3663                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3664                     sym.kind == byName.kind &amp;&amp;
3665                     sym.name != names.error &amp;&amp;
3666                     (sym.kind != MTH ||
3667                      types.hasSameArgs(sym.type, byName.type) ||
3668                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3669                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3670                     sym.flags_field |= CLASH;
3671                     varargsDuplicateError(pos, sym, byName);
3672                     return true;
3673                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3674                     duplicateErasureError(pos, sym, byName);
3675                     sym.flags_field |= CLASH;
3676                     return true;
<span class="line-added">3677                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;</span>
<span class="line-added">3678                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;</span>
<span class="line-added">3679                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {</span>
<span class="line-added">3680                     if (!sym.type.isErroneous()) {</span>
<span class="line-added">3681                         log.error(pos, Errors.MatchBindingExists);</span>
<span class="line-added">3682                         sym.flags_field |= CLASH;</span>
<span class="line-added">3683                     }</span>
<span class="line-added">3684                     return false;</span>
3685                 } else {
3686                     duplicateError(pos, byName);
3687                     return false;
3688                 }
3689             }
3690         }
3691         return true;
3692     }
3693 
3694     /** Report duplicate declaration error.
3695      */
3696     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3697         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3698             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3699         }
3700     }
3701 
3702     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3703      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3704      * types without an error on the imports.
</pre>
</td>
</tr>
</table>
<center><a href="AttrContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CompileStates.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
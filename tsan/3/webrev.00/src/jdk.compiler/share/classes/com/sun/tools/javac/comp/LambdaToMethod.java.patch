diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
@@ -23,11 +23,13 @@
  * questions.
  */
 
 package com.sun.tools.javac.comp;
 
+import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;
 import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
 import com.sun.tools.javac.tree.*;
 import com.sun.tools.javac.tree.JCTree.*;
 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
@@ -57,28 +59,24 @@
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 
 import static com.sun.tools.javac.comp.LambdaToMethod.LambdaSymbolKind.*;
 import static com.sun.tools.javac.code.Flags.*;
 import static com.sun.tools.javac.code.Kinds.Kind.*;
 import static com.sun.tools.javac.code.TypeTag.*;
 import static com.sun.tools.javac.tree.JCTree.Tag.*;
-import static com.sun.tools.javac.jvm.Pool.DynamicMethod;
 
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.type.TypeKind;
 
-import com.sun.tools.javac.code.Type.IntersectionClassType;
-import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
 import com.sun.tools.javac.main.Option;
 
 /**
  * This pass desugars lambda expressions into static methods
  *
@@ -212,11 +210,11 @@
          */
         private ListBuffer<JCTree> appendedMethodList;
 
         private Map<DedupedLambda, DedupedLambda> dedupedLambdas;
 
-        private Map<DynamicMethod, DynamicMethodSymbol> dynMethSyms = new HashMap<>();
+        private Map<Object, DynamicMethodSymbol> dynMethSyms = new HashMap<>();
 
         /**
          * list of deserialization cases
          */
         private final Map<String, ListBuffer<JCStatement>> deserializeCases;
@@ -381,11 +379,11 @@
         lambdaDecl.type = lambdaType;
 
         //translate lambda body
         //As the lambda body is translated, all references to lambda locals,
         //captured variables, enclosing members are adjusted accordingly
-        //to refer to the static method parameters (rather than i.e. acessing to
+        //to refer to the static method parameters (rather than i.e. accessing
         //captured members directly).
         lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));
 
         boolean dedupe = false;
         if (deduplicateLambdas && !debugLinesOrVars && !localContext.isSerializable()) {
@@ -437,15 +435,12 @@
         }
 
         //then, determine the arguments to the indy call
         List<JCExpression> indy_args = translate(syntheticInits.toList(), localContext.prev);
 
-        //build a sam instance using an indy call to the meta-factory
-        int refKind = referenceKind(sym);
-
         //convert to an invokedynamic call
-        result = makeMetafactoryIndyCall(context, refKind, sym, indy_args);
+        result = makeMetafactoryIndyCall(context, sym.asHandle(), indy_args);
     }
 
     // where
         // Reassign type annotations from the source that should really belong to the lambda
         private void apportionTypeAnnotations(JCLambda tree,
@@ -486,11 +481,11 @@
     public void visitReference(JCMemberReference tree) {
         ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;
 
         //first determine the method symbol to be used to generate the sam instance
         //this is either the method reference symbol, or the bridged reference symbol
-        Symbol refSym = tree.sym;
+        MethodSymbol refSym = (MethodSymbol)tree.sym;
 
         //the qualifying expression is treated as a special captured arg
         JCExpression init;
         switch(tree.kind) {
 
@@ -520,11 +515,11 @@
 
         List<JCExpression> indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);
 
 
         //build a sam instance using an indy call to the meta-factory
-        result = makeMetafactoryIndyCall(localContext, localContext.referenceKind(), refSym, indy_args);
+        result = makeMetafactoryIndyCall(localContext, refSym.asHandle(), indy_args);
     }
 
     /**
      * Translate identifiers within a lambda to the mapped identifier
      * @param tree
@@ -606,25 +601,10 @@
         LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context;
         if (context != null && lambdaContext.getSymbolMap(LOCAL_VAR).containsKey(tree.sym)) {
             tree.init = translate(tree.init);
             tree.sym = (VarSymbol) lambdaContext.getSymbolMap(LOCAL_VAR).get(tree.sym);
             result = tree;
-        } else if (context != null && lambdaContext.getSymbolMap(TYPE_VAR).containsKey(tree.sym)) {
-            JCExpression init = translate(tree.init);
-            VarSymbol xsym = (VarSymbol)lambdaContext.getSymbolMap(TYPE_VAR).get(tree.sym);
-            int prevPos = make.pos;
-            try {
-                result = make.at(tree).VarDef(xsym, init);
-            } finally {
-                make.at(prevPos);
-            }
-            // Replace the entered symbol for this variable
-            WriteableScope sc = tree.sym.owner.members();
-            if (sc != null) {
-                sc.remove(tree.sym);
-                sc.enter(xsym);
-            }
         } else {
             super.visitVarDef(tree);
         }
     }
 
@@ -763,20 +743,21 @@
     JCNewClass makeNewClass(Type ctype, List<JCExpression> args) {
         return makeNewClass(ctype, args,
                 rs.resolveConstructor(null, attrEnv, ctype, TreeInfo.types(args), List.nil()));
      }
 
-    private void addDeserializationCase(int implMethodKind, Symbol refSym, Type targetType, MethodSymbol samSym,
-            DiagnosticPosition pos, List<Object> staticArgs, MethodType indyType) {
+    private void addDeserializationCase(MethodHandleSymbol refSym, Type targetType, MethodSymbol samSym,
+                                        DiagnosticPosition pos, List<LoadableConstant> staticArgs, MethodType indyType) {
         String functionalInterfaceClass = classSig(targetType);
         String functionalInterfaceMethodName = samSym.getSimpleName().toString();
         String functionalInterfaceMethodSignature = typeSig(types.erasure(samSym.type));
         String implClass = classSig(types.erasure(refSym.owner.type));
         String implMethodName = refSym.getQualifiedName().toString();
         String implMethodSignature = typeSig(types.erasure(refSym.type));
 
-        JCExpression kindTest = eqTest(syms.intType, deserGetter("getImplMethodKind", syms.intType), make.Literal(implMethodKind));
+        JCExpression kindTest = eqTest(syms.intType, deserGetter("getImplMethodKind", syms.intType),
+                make.Literal(refSym.referenceKind()));
         ListBuffer<JCExpression> serArgs = new ListBuffer<>();
         int i = 0;
         for (Type t : indyType.getParameterTypes()) {
             List<JCExpression> indexAsArg = new ListBuffer<JCExpression>().append(make.Literal(i)).toList();
             List<Type> argTypes = new ListBuffer<Type>().append(syms.intType).toList();
@@ -980,11 +961,11 @@
             // the implementation method parameters is not obscured.
             // Note: in this loop, the lists implPTypes, samPTypes, and descPTypes
             // are used as pointers to the current parameter type information
             // and are thus not usable afterwards.
             for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {
-                // By default use the implementation method parmeter type
+                // By default use the implementation method parameter type
                 Type parmType = implPTypes.head;
                 // If the unerased parameter type is a type variable whose
                 // bound is an intersection (eg. <T extends A & B>) then
                 // use the SAM parameter type
                 if (checkForIntersection && descPTypes.head.getKind() == TypeKind.TYPEVAR) {
@@ -1104,17 +1085,17 @@
 
     /**
      * Generate an indy method call to the meta factory
      */
     private JCExpression makeMetafactoryIndyCall(TranslationContext<?> context,
-            int refKind, Symbol refSym, List<JCExpression> indy_args) {
+            MethodHandleSymbol refSym, List<JCExpression> indy_args) {
         JCFunctionalExpression tree = context.tree;
         //determine the static bsm args
         MethodSymbol samSym = (MethodSymbol) types.findDescriptorSymbol(tree.target.tsym);
-        List<Object> staticArgs = List.of(
+        List<LoadableConstant> staticArgs = List.of(
                 typeToMethodType(samSym.type),
-                new Pool.MethodHandle(refKind, refSym, types),
+                refSym.asHandle(),
                 typeToMethodType(tree.getDescriptorType(types)));
 
         //computed indy arg types
         ListBuffer<Type> indy_args_types = new ListBuffer<>();
         for (JCExpression arg : indy_args) {
@@ -1129,20 +1110,20 @@
 
         Name metafactoryName = context.needsAltMetafactory() ?
                 names.altMetafactory : names.metafactory;
 
         if (context.needsAltMetafactory()) {
-            ListBuffer<Object> markers = new ListBuffer<>();
+            ListBuffer<Type> markers = new ListBuffer<>();
             List<Type> targets = tree.target.isIntersection() ?
                     types.directSupertypes(tree.target) :
                     List.nil();
             for (Type t : targets) {
                 t = types.erasure(t);
                 if (t.tsym != syms.serializableType.tsym &&
                     t.tsym != tree.type.tsym &&
                     t.tsym != syms.objectType.tsym) {
-                    markers.append(t.tsym);
+                    markers.append(t);
                 }
             }
             int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;
             boolean hasMarkers = markers.nonEmpty();
             boolean hasBridges = context.bridges.nonEmpty();
@@ -1150,29 +1131,29 @@
                 flags |= FLAG_MARKERS;
             }
             if (hasBridges) {
                 flags |= FLAG_BRIDGES;
             }
-            staticArgs = staticArgs.append(flags);
+            staticArgs = staticArgs.append(LoadableConstant.Int(flags));
             if (hasMarkers) {
-                staticArgs = staticArgs.append(markers.length());
-                staticArgs = staticArgs.appendList(markers.toList());
+                staticArgs = staticArgs.append(LoadableConstant.Int(markers.length()));
+                staticArgs = staticArgs.appendList(List.convert(LoadableConstant.class, markers.toList()));
             }
             if (hasBridges) {
-                staticArgs = staticArgs.append(context.bridges.length() - 1);
+                staticArgs = staticArgs.append(LoadableConstant.Int(context.bridges.length() - 1));
                 for (Symbol s : context.bridges) {
                     Type s_erasure = s.erasure(types);
                     if (!types.isSameType(s_erasure, samSym.erasure(types))) {
-                        staticArgs = staticArgs.append(s.erasure(types));
+                        staticArgs = staticArgs.append(((MethodType)s.erasure(types)));
                     }
                 }
             }
             if (context.isSerializable()) {
                 int prevPos = make.pos;
                 try {
                     make.at(kInfo.clazz);
-                    addDeserializationCase(refKind, refSym, tree.type, samSym,
+                    addDeserializationCase(refSym, tree.type, samSym,
                             tree, staticArgs, indyType);
                 } finally {
                     make.at(prevPos);
                 }
             }
@@ -1184,95 +1165,41 @@
     /**
      * Generate an indy method call with given name, type and static bootstrap
      * arguments types
      */
     private JCExpression makeIndyCall(DiagnosticPosition pos, Type site, Name bsmName,
-            List<Object> staticArgs, MethodType indyType, List<JCExpression> indyArgs,
-            Name methName) {
+                                      List<LoadableConstant> staticArgs, MethodType indyType, List<JCExpression> indyArgs,
+                                      Name methName) {
         int prevPos = make.pos;
         try {
             make.at(pos);
             List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,
-                    syms.stringType,
-                    syms.methodTypeType).appendList(bsmStaticArgToTypes(staticArgs));
+                syms.stringType,
+                syms.methodTypeType).appendList(staticArgs.map(types::constantType));
 
             Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,
                     bsmName, bsm_staticArgs, List.nil());
 
             DynamicMethodSymbol dynSym =
                     new DynamicMethodSymbol(methName,
                                             syms.noSymbol,
-                                            bsm.isStatic() ?
-                                                ClassFile.REF_invokeStatic :
-                                                ClassFile.REF_invokeVirtual,
-                                            (MethodSymbol)bsm,
+                                            ((MethodSymbol)bsm).asHandle(),
                                             indyType,
-                                            staticArgs.toArray());
+                                            staticArgs.toArray(new LoadableConstant[staticArgs.length()]));
             JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), bsmName);
             DynamicMethodSymbol existing = kInfo.dynMethSyms.putIfAbsent(
-                    new DynamicMethod(dynSym, types), dynSym);
+                    dynSym.poolKey(types), dynSym);
             qualifier.sym = existing != null ? existing : dynSym;
             qualifier.type = indyType.getReturnType();
 
             JCMethodInvocation proxyCall = make.Apply(List.nil(), qualifier, indyArgs);
             proxyCall.type = indyType.getReturnType();
             return proxyCall;
         } finally {
             make.at(prevPos);
         }
     }
-    //where
-    private List<Type> bsmStaticArgToTypes(List<Object> args) {
-        ListBuffer<Type> argtypes = new ListBuffer<>();
-        for (Object arg : args) {
-            argtypes.append(bsmStaticArgToType(arg));
-        }
-        return argtypes.toList();
-    }
-
-    private Type bsmStaticArgToType(Object arg) {
-        Assert.checkNonNull(arg);
-        if (arg instanceof ClassSymbol) {
-            return syms.classType;
-        } else if (arg instanceof Integer) {
-            return syms.intType;
-        } else if (arg instanceof Long) {
-            return syms.longType;
-        } else if (arg instanceof Float) {
-            return syms.floatType;
-        } else if (arg instanceof Double) {
-            return syms.doubleType;
-        } else if (arg instanceof String) {
-            return syms.stringType;
-        } else if (arg instanceof Pool.MethodHandle) {
-            return syms.methodHandleType;
-        } else if (arg instanceof MethodType) {
-            return syms.methodTypeType;
-        } else {
-            Assert.error("bad static arg " + arg.getClass());
-            return null;
-        }
-    }
-
-    /**
-     * Get the opcode associated with this method reference
-     */
-    private int referenceKind(Symbol refSym) {
-        if (refSym.isConstructor()) {
-            return ClassFile.REF_newInvokeSpecial;
-        } else {
-            if (refSym.isStatic()) {
-                return ClassFile.REF_invokeStatic;
-            } else if ((refSym.flags() & PRIVATE) != 0) {
-                return ClassFile.REF_invokeSpecial;
-            } else if (refSym.enclClass().isInterface()) {
-                return ClassFile.REF_invokeInterface;
-            } else {
-                return ClassFile.REF_invokeVirtual;
-            }
-        }
-    }
 
     // <editor-fold defaultstate="collapsed" desc="Lambda/reference analyzer">
     /**
      * This visitor collects information about translation of a lambda expression.
      * More specifically, it keeps track of the enclosing contexts and captured locals
@@ -1628,13 +1555,10 @@
                     ltc.addSymbol(tree.sym, LOCAL_VAR);
                 }
                 // Check for type variables (including as type arguments).
                 // If they occur within class nested in a lambda, mark for erasure
                 Type type = tree.sym.asType();
-                if (inClassWithinLambda() && !types.isSameType(types.erasure(type), type)) {
-                    ltc.addSymbol(tree.sym, TYPE_VAR);
-                }
             }
 
             List<Frame> prevStack = frameStack;
             try {
                 if (tree.sym.owner.kind == MTH) {
@@ -1783,12 +1707,13 @@
                         if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {
                             return currentDepth > depth ? null : block.tree;
                         }
                         break;
                     case VARDEF:
-                        if (((JCVariableDecl)block.tree).sym == sym &&
-                                sym.owner.kind == MTH) { //only locals are captured
+                        if ((((JCVariableDecl)block.tree).sym == sym &&
+                                sym.owner.kind == MTH) || //only locals are captured
+                            (block.locals != null && block.locals.contains(sym))) {
                             return currentDepth > depth ? null : block.tree;
                         }
                         break;
                     case BLOCK:
                     case METHODDEF:
@@ -2000,20 +1925,28 @@
                         assignedTo = self = null;
                         break;
                  }
 
                 // This symbol will be filled-in in complete
-                this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());
-
+                if (owner.kind == MTH) {
+                    final MethodSymbol originalOwner = (MethodSymbol)owner.clone(owner.owner);
+                    this.translatedSym = new MethodSymbol(SYNTHETIC | PRIVATE, null, null, owner.enclClass()) {
+                        @Override
+                        public MethodSymbol originalEnclosingMethod() {
+                            return originalOwner;
+                        }
+                    };
+                } else {
+                    this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());
+                }
                 translatedSymbols = new EnumMap<>(LambdaSymbolKind.class);
 
                 translatedSymbols.put(PARAM, new LinkedHashMap<Symbol, Symbol>());
                 translatedSymbols.put(LOCAL_VAR, new LinkedHashMap<Symbol, Symbol>());
                 translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap<Symbol, Symbol>());
                 translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap<Symbol, Symbol>());
                 translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap<Symbol, Symbol>());
-                translatedSymbols.put(TYPE_VAR, new LinkedHashMap<Symbol, Symbol>());
 
                 freeVarProcessedLocalClasses = new HashSet<>();
             }
 
              /**
@@ -2102,20 +2035,10 @@
                 Symbol ret;
                 switch (skind) {
                     case CAPTURED_THIS:
                         ret = sym;  // self represented
                         break;
-                    case TYPE_VAR:
-                        // Just erase the type var
-                        ret = new VarSymbol(sym.flags(), sym.name,
-                                types.erasure(sym.type), sym.owner);
-
-                        /* this information should also be kept for LVT generation at Gen
-                         * a Symbol with pos < startPos won't be tracked.
-                         */
-                        ((VarSymbol)ret).pos = ((VarSymbol)sym).pos;
-                        break;
                     case CAPTURED_VAR:
                         ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, sym.name, types.erasure(sym.type), translatedSym) {
                             @Override
                             public Symbol baseSymbol() {
                                 //keep mapping with original captured symbol
@@ -2310,17 +2233,10 @@
             ReferenceTranslationContext(JCMemberReference tree) {
                 super(tree);
                 this.isSuper = tree.hasKind(ReferenceKind.SUPER);
             }
 
-            /**
-             * Get the opcode associated with this method reference
-             */
-            int referenceKind() {
-                return LambdaToMethod.this.referenceKind(tree.sym);
-            }
-
             boolean needsVarArgsConversion() {
                 return tree.varargsElement != null;
             }
 
             /**
@@ -2348,12 +2264,11 @@
                               types.erasure(owner.enclClass().asType()));
             }
 
             boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
                 return ((tree.sym.flags() & PROTECTED) != 0 &&
-                        tree.sym.packge() != owner.packge() &&
-                        !owner.enclClass().isSubClass(tree.sym.owner, types));
+                        tree.sym.packge() != owner.packge());
             }
 
             /**
              * Erasure destroys the implementation parameter subtype
              * relationship for intersection types.
@@ -2415,12 +2330,11 @@
     enum LambdaSymbolKind {
         PARAM,          // original to translated lambda parameters
         LOCAL_VAR,      // original to translated lambda locals
         CAPTURED_VAR,   // variables in enclosing scope to translated synthetic parameters
         CAPTURED_THIS,  // class symbols to translated synthetic parameters (for captured member access)
-        CAPTURED_OUTER_THIS, // used when `this' capture is illegal, but outer this capture is legit (JDK-8129740)
-        TYPE_VAR;      // original to translated lambda type variables
+        CAPTURED_OUTER_THIS; // used when `this' capture is illegal, but outer this capture is legit (JDK-8129740)
 
         boolean propagateAnnotations() {
             switch (this) {
                 case CAPTURED_VAR:
                 case CAPTURED_THIS:

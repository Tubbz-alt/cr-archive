<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeHasher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../file/BaseFileManager.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  38 import com.sun.tools.javac.code.Scope.StarImportScope;
  39 import com.sun.tools.javac.code.Scope.WriteableScope;
  40 import com.sun.tools.javac.code.Source.Feature;
  41 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  42 import com.sun.tools.javac.tree.*;
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import com.sun.tools.javac.code.Symbol.*;
  47 import com.sun.tools.javac.code.Type.*;
  48 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  49 import com.sun.tools.javac.tree.JCTree.*;
  50 
  51 import static com.sun.tools.javac.code.Flags.*;
  52 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  53 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  54 import static com.sun.tools.javac.code.Kinds.Kind.*;
  55 import static com.sun.tools.javac.code.TypeTag.CLASS;
  56 import static com.sun.tools.javac.code.TypeTag.ERROR;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;



  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  61 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  62 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  63 
  64 /** This is the second phase of Enter, in which classes are completed
  65  *  by resolving their headers and entering their members in the into
  66  *  the class scope. See Enter for an overall overview.
  67  *
  68  *  This class uses internal phases to process the classes. When a phase
  69  *  processes classes, the lower phases are not invoked until all classes
  70  *  pass through the current phase. Note that it is possible that upper phases
  71  *  are run due to recursive completion. The internal phases are:
  72  *  - ImportPhase: shallow pass through imports, adds information about imports
  73  *                 the NamedImportScope and StarImportScope, but avoids queries
  74  *                 about class hierarchy.
  75  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  76  *                    type parameters of the class or type argument of the supertypes.
  77  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
</pre>
<hr />
<pre>
 416                 else
 417                     importAll(tree, p, env);
 418             } else {
 419                 // Named type import.
 420                 if (tree.staticImport) {
 421                     importNamedStatic(tree, p, name, localEnv);
 422                     chk.checkCanonical(imp.selected);
 423                 } else {
 424                     Type importedType = attribImportType(imp, localEnv);
 425                     Type originalType = importedType.getOriginalType();
 426                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 427                     chk.checkCanonical(imp);
 428                     importNamed(tree.pos(), c, env, tree);
 429                 }
 430             }
 431         }
 432 
 433         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 434             Assert.check(completionEnabled);
 435             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
<span class="line-modified"> 436                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL));</span>
 437             try {
 438                 // To prevent deep recursion, suppress completion of some
 439                 // types.
 440                 completionEnabled = false;
 441                 return attr.attribType(tree, env);
 442             } finally {
 443                 completionEnabled = true;
 444                 chk.setLint(prevLint);
 445             }
 446         }
 447 
 448         /** Import all classes of a class or package on demand.
 449          *  @param imp           The import that is being handled.
 450          *  @param tsym          The class or package the members of which are imported.
 451          *  @param env           The env in which the imported classes will be entered.
 452          */
 453         private void importAll(JCImport imp,
 454                                final TypeSymbol tsym,
 455                                Env&lt;AttrContext&gt; env) {
 456             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
</pre>
<hr />
<pre>
 661                         for (int i = n; i &gt; 0; i--) {
 662                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 663                                                     syms.botType);
 664                             ct.typarams_field = ct.typarams_field.prepend(v);
 665                         }
 666                     }
 667                 }
 668             }
 669 
 670         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 671             JCClassDecl tree = env.enclClass;
 672             ClassSymbol sym = tree.sym;
 673             ClassType ct = (ClassType)sym.type;
 674             // Determine supertype.
 675             Type supertype;
 676             JCExpression extending;
 677 
 678             if (tree.extending != null) {
 679                 extending = clearTypeParams(tree.extending);
 680                 supertype = attr.attribBase(extending, baseEnv, true, false, true);



 681             } else {
 682                 extending = null;
 683                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 684                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 685                                   true, false, false)
 686                 : (sym.fullname == names.java_lang_Object)
 687                 ? Type.noType
<span class="line-modified"> 688                 : syms.objectType;</span>
 689             }
 690             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 691 
 692             // Determine interfaces.
 693             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 694             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 695             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 696             for (JCExpression iface : interfaceTrees) {
 697                 iface = clearTypeParams(iface);
 698                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 699                 if (it.hasTag(CLASS)) {
 700                     interfaces.append(it);
 701                     if (all_interfaces != null) all_interfaces.append(it);
 702                 } else {
 703                     if (all_interfaces == null)
 704                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 705                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 706                 }
 707             }
 708 
</pre>
<hr />
<pre>
 784         public void complete(Symbol sym) throws CompletionFailure {
 785             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 786                          (topLevelPhase == this));
 787 
 788             if (topLevelPhase != this) {
 789                 //only do the processing based on dependencies in the HierarchyPhase:
 790                 sym.completer = this;
 791                 return ;
 792             }
 793 
 794             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 795 
 796             super.doCompleteEnvs(List.of(env));
 797         }
 798 
 799     }
 800 
 801     private final class HeaderPhase extends AbstractHeaderPhase {
 802 
 803         public HeaderPhase() {
<span class="line-modified"> 804             super(CompletionCause.HEADER_PHASE, new MembersPhase());</span>
 805         }
 806 
 807         @Override
 808         protected void runPhase(Env&lt;AttrContext&gt; env) {
 809             JCClassDecl tree = env.enclClass;
 810             ClassSymbol sym = tree.sym;
 811             ClassType ct = (ClassType)sym.type;
 812 
 813             // create an environment for evaluating the base clauses
 814             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 815 
 816             if (tree.extending != null)
 817                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 818             for (JCExpression impl : tree.implementing)
 819                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 820             annotate.flush();
 821 
 822             attribSuperTypes(env, baseEnv);
 823 
 824             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
</pre>
<hr />
<pre>
 834             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 835 
 836             for (JCTypeParameter tp : tree.typarams)
 837                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 838 
 839             // check that no package exists with same fully qualified name,
 840             // but admit classes in the unnamed package which have the same
 841             // name as a top-level package.
 842             if (checkClash &amp;&amp;
 843                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 844                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 845                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 846             }
 847             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 848                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 849                 sym.flags_field |= AUXILIARY;
 850             }
 851         }
 852     }
 853 
<span class="line-modified"> 854     /** Enter member fields and methods of a class</span>
<span class="line-removed"> 855      */</span>
<span class="line-removed"> 856     private final class MembersPhase extends Phase {</span>
 857 
<span class="line-modified"> 858         public MembersPhase() {</span>
<span class="line-modified"> 859             super(CompletionCause.MEMBERS_PHASE, null);</span>
 860         }
 861 
 862         private boolean completing;
 863         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 864 
 865         @Override
 866         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 867             todo = todo.prependList(envs);
 868             if (completing) {
 869                 return ; //the top-level invocation will handle all envs
 870             }
 871             boolean prevCompleting = completing;
 872             completing = true;
 873             try {
 874                 while (todo.nonEmpty()) {
 875                     Env&lt;AttrContext&gt; head = todo.head;
 876                     todo = todo.tail;
 877                     super.doCompleteEnvs(List.of(head));
 878                 }
 879             } finally {
 880                 completing = prevCompleting;
 881             }
 882         }
 883 
<span class="line-modified"> 884         @Override</span>
<span class="line-removed"> 885         protected void runPhase(Env&lt;AttrContext&gt; env) {</span>
<span class="line-removed"> 886             JCClassDecl tree = env.enclClass;</span>
<span class="line-removed"> 887             ClassSymbol sym = tree.sym;</span>
 888             ClassType ct = (ClassType)sym.type;
<span class="line-removed"> 889 </span>
<span class="line-removed"> 890             // Add default constructor if needed.</span>
<span class="line-removed"> 891             if ((sym.flags() &amp; INTERFACE) == 0 &amp;&amp;</span>
<span class="line-removed"> 892                 !TreeInfo.hasConstructors(tree.defs)) {</span>
<span class="line-removed"> 893                 List&lt;Type&gt; argtypes = List.nil();</span>
<span class="line-removed"> 894                 List&lt;Type&gt; typarams = List.nil();</span>
<span class="line-removed"> 895                 List&lt;Type&gt; thrown = List.nil();</span>
<span class="line-removed"> 896                 long ctorFlags = 0;</span>
<span class="line-removed"> 897                 boolean based = false;</span>
<span class="line-removed"> 898                 boolean addConstructor = true;</span>
<span class="line-removed"> 899                 JCNewClass nc = null;</span>
<span class="line-removed"> 900                 if (sym.name.isEmpty()) {</span>
<span class="line-removed"> 901                     nc = (JCNewClass)env.next.tree;</span>
<span class="line-removed"> 902                     if (nc.constructor != null) {</span>
<span class="line-removed"> 903                         addConstructor = nc.constructor.kind != ERR;</span>
<span class="line-removed"> 904                         Type superConstrType = types.memberType(sym.type,</span>
<span class="line-removed"> 905                                                                 nc.constructor);</span>
<span class="line-removed"> 906                         argtypes = superConstrType.getParameterTypes();</span>
<span class="line-removed"> 907                         typarams = superConstrType.getTypeArguments();</span>
<span class="line-removed"> 908                         ctorFlags = nc.constructor.flags() &amp; VARARGS;</span>
<span class="line-removed"> 909                         if (nc.encl != null) {</span>
<span class="line-removed"> 910                             argtypes = argtypes.prepend(nc.encl.type);</span>
<span class="line-removed"> 911                             based = true;</span>
<span class="line-removed"> 912                         }</span>
<span class="line-removed"> 913                         thrown = superConstrType.getThrownTypes();</span>
<span class="line-removed"> 914                     }</span>
<span class="line-removed"> 915                 }</span>
<span class="line-removed"> 916                 if (addConstructor) {</span>
<span class="line-removed"> 917                     MethodSymbol basedConstructor = nc != null ?</span>
<span class="line-removed"> 918                             (MethodSymbol)nc.constructor : null;</span>
<span class="line-removed"> 919                     JCTree constrDef = DefaultConstructor(make.at(tree.pos), sym,</span>
<span class="line-removed"> 920                                                         basedConstructor,</span>
<span class="line-removed"> 921                                                         typarams, argtypes, thrown,</span>
<span class="line-removed"> 922                                                         ctorFlags, based);</span>
<span class="line-removed"> 923                     tree.defs = tree.defs.prepend(constrDef);</span>
<span class="line-removed"> 924                 }</span>
<span class="line-removed"> 925             }</span>
<span class="line-removed"> 926 </span>
 927             // enter symbols for &#39;this&#39; into current scope.
 928             VarSymbol thisSym =
<span class="line-modified"> 929                 new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);</span>
 930             thisSym.pos = Position.FIRSTPOS;
 931             env.info.scope.enter(thisSym);
 932             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 933             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 934                     ct.supertype_field.hasTag(CLASS)) {
 935                 VarSymbol superSym =
<span class="line-modified"> 936                     new VarSymbol(FINAL | HASINIT, names._super,</span>
<span class="line-modified"> 937                                   ct.supertype_field, sym);</span>
 938                 superSym.pos = Position.FIRSTPOS;
 939                 env.info.scope.enter(superSym);
 940             }























































 941 
 942             if (!tree.typarams.isEmpty()) {
 943                 for (JCTypeParameter tvar : tree.typarams) {
 944                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
 945                 }
 946             }
 947 
 948             finishClass(tree, env);
 949 
 950             if (allowTypeAnnos) {
 951                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 952                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 953             }
 954         }
 955 































 956         /** Enter members for a class.
 957          */
 958         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 959             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
 960                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
 961                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
 962                 addEnumMembers(tree, env);
 963             }
<span class="line-modified"> 964             memberEnter.memberEnter(tree.defs, env);</span>
<span class="line-modified"> 965 </span>














 966             if (tree.sym.isAnnotationType()) {
 967                 Assert.check(tree.sym.isCompleted());
 968                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
 969             }
 970         }
 971 
































 972         /** Add the implicit members for an enum type
 973          *  to the symbol table.
 974          */
 975         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 976             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
 977 
<span class="line-removed"> 978             // public static T[] values() { return ???; }</span>
 979             JCMethodDecl values = make.
 980                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
 981                           names.values,
 982                           valuesType,
 983                           List.nil(),
 984                           List.nil(),
<span class="line-modified"> 985                           List.nil(), // thrown</span>
<span class="line-modified"> 986                           null, //make.Block(0, Tree.emptyList.prepend(make.Return(make.Ident(names._null)))),</span>
 987                           null);
 988             memberEnter.memberEnter(values, env);
 989 
<span class="line-removed"> 990             // public static T valueOf(String name) { return ???; }</span>
 991             JCMethodDecl valueOf = make.
 992                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
 993                           names.valueOf,
 994                           make.Type(tree.sym.type),
 995                           List.nil(),
 996                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
 997                                                              Flags.MANDATED),
 998                                                 names.fromString(&quot;name&quot;),
 999                                                 make.Type(syms.stringType), null)),
<span class="line-modified">1000                           List.nil(), // thrown</span>
<span class="line-modified">1001                           null, //make.Block(0, Tree.emptyList.prepend(make.Return(make.Ident(names._null)))),</span>
1002                           null);
1003             memberEnter.memberEnter(valueOf, env);
1004         }
1005 

















































































1006     }
1007 
1008 /* ***************************************************************************
1009  * tree building
1010  ****************************************************************************/
1011 
<span class="line-modified">1012     /** Generate default constructor for given class. For classes different</span>
<span class="line-modified">1013      *  from java.lang.Object, this is:</span>
<span class="line-modified">1014      *</span>
<span class="line-modified">1015      *    c(argtype_0 x_0, ..., argtype_n x_n) throws thrown {</span>
<span class="line-modified">1016      *      super(x_0, ..., x_n)</span>
<span class="line-modified">1017      *    }</span>
<span class="line-modified">1018      *</span>
<span class="line-modified">1019      *  or, if based == true:</span>
<span class="line-modified">1020      *</span>
<span class="line-modified">1021      *    c(argtype_0 x_0, ..., argtype_n x_n) throws thrown {</span>
<span class="line-modified">1022      *      x_0.super(x_1, ..., x_n)</span>
<span class="line-modified">1023      *    }</span>
<span class="line-modified">1024      *</span>
<span class="line-modified">1025      *  @param make     The tree factory.</span>
<span class="line-modified">1026      *  @param c        The class owning the default constructor.</span>
<span class="line-modified">1027      *  @param argtypes The parameter types of the constructor.</span>
<span class="line-modified">1028      *  @param thrown   The thrown exceptions of the constructor.</span>
<span class="line-modified">1029      *  @param based    Is first parameter a this$n?</span>
<span class="line-modified">1030      */</span>
<span class="line-modified">1031     JCTree DefaultConstructor(TreeMaker make,</span>
<span class="line-modified">1032                             ClassSymbol c,</span>
<span class="line-modified">1033                             MethodSymbol baseInit,</span>
<span class="line-modified">1034                             List&lt;Type&gt; typarams,</span>
<span class="line-modified">1035                             List&lt;Type&gt; argtypes,</span>
<span class="line-modified">1036                             List&lt;Type&gt; thrown,</span>
<span class="line-modified">1037                             long flags,</span>
<span class="line-modified">1038                             boolean based) {</span>
<span class="line-modified">1039         JCTree result;</span>
<span class="line-modified">1040         if ((c.flags() &amp; ENUM) != 0 &amp;&amp;</span>
<span class="line-modified">1041             (types.supertype(c.type).tsym == syms.enumSym)) {</span>
<span class="line-modified">1042             // constructors of true enums are private</span>
<span class="line-modified">1043             flags = (flags &amp; ~AccessFlags) | PRIVATE | GENERATEDCONSTR;</span>
<span class="line-modified">1044         } else</span>
<span class="line-modified">1045             flags |= (c.flags() &amp; AccessFlags) | GENERATEDCONSTR;</span>
<span class="line-modified">1046         if (c.name.isEmpty()) {</span>
<span class="line-modified">1047             flags |= ANONCONSTR;</span>





































1048         }
<span class="line-modified">1049         if (based) {</span>
<span class="line-modified">1050             flags |= ANONCONSTR_BASED;</span>










1051         }
<span class="line-modified">1052         Type mType = new MethodType(argtypes, null, thrown, c);</span>
<span class="line-modified">1053         Type initType = typarams.nonEmpty() ?</span>
<span class="line-modified">1054             new ForAll(typarams, mType) :</span>
<span class="line-modified">1055             mType;</span>
<span class="line-modified">1056         MethodSymbol init = new MethodSymbol(flags, names.init,</span>
<span class="line-modified">1057                 initType, c);</span>
<span class="line-modified">1058         init.params = createDefaultConstructorParams(make, baseInit, init,</span>
<span class="line-modified">1059                 argtypes, based);</span>
<span class="line-modified">1060         List&lt;JCVariableDecl&gt; params = make.Params(argtypes, init);</span>
<span class="line-modified">1061         List&lt;JCStatement&gt; stats = List.nil();</span>
<span class="line-modified">1062         if (c.type != syms.objectType) {</span>
<span class="line-modified">1063             stats = stats.prepend(SuperCall(make, typarams, params, based));</span>






















1064         }
<span class="line-removed">1065         result = make.MethodDef(init, make.Block(0, stats));</span>
<span class="line-removed">1066         return result;</span>
1067     }
1068 
<span class="line-modified">1069     private List&lt;VarSymbol&gt; createDefaultConstructorParams(</span>
<span class="line-modified">1070             TreeMaker make,</span>
<span class="line-modified">1071             MethodSymbol baseInit,</span>
<span class="line-modified">1072             MethodSymbol init,</span>
<span class="line-modified">1073             List&lt;Type&gt; argtypes,</span>
<span class="line-modified">1074             boolean based) {</span>
<span class="line-modified">1075         List&lt;VarSymbol&gt; initParams = null;</span>
<span class="line-modified">1076         List&lt;Type&gt; argTypesList = argtypes;</span>
<span class="line-modified">1077         if (based) {</span>
<span class="line-modified">1078             /*  In this case argtypes will have an extra type, compared to baseInit,</span>
<span class="line-modified">1079              *  corresponding to the type of the enclosing instance i.e.:</span>
<span class="line-modified">1080              *</span>
<span class="line-modified">1081              *  Inner i = outer.new Inner(1){}</span>
<span class="line-modified">1082              *</span>
<span class="line-modified">1083              *  in the above example argtypes will be (Outer, int) and baseInit</span>
<span class="line-modified">1084              *  will have parameter&#39;s types (int). So in this case we have to add</span>
<span class="line-modified">1085              *  first the extra type in argtypes and then get the names of the</span>
<span class="line-modified">1086              *  parameters from baseInit.</span>







1087              */
<span class="line-modified">1088             initParams = List.nil();</span>
<span class="line-modified">1089             VarSymbol param = new VarSymbol(PARAMETER, make.paramName(0), argtypes.head, init);</span>
<span class="line-modified">1090             initParams = initParams.append(param);</span>
<span class="line-modified">1091             argTypesList = argTypesList.tail;</span>




1092         }
<span class="line-modified">1093         if (baseInit != null &amp;&amp; baseInit.params != null &amp;&amp;</span>
<span class="line-modified">1094             baseInit.params.nonEmpty() &amp;&amp; argTypesList.nonEmpty()) {</span>
<span class="line-modified">1095             initParams = (initParams == null) ? List.nil() : initParams;</span>
<span class="line-modified">1096             List&lt;VarSymbol&gt; baseInitParams = baseInit.params;</span>
<span class="line-modified">1097             while (baseInitParams.nonEmpty() &amp;&amp; argTypesList.nonEmpty()) {</span>
<span class="line-modified">1098                 VarSymbol param = new VarSymbol(baseInitParams.head.flags() | PARAMETER,</span>
<span class="line-modified">1099                         baseInitParams.head.name, argTypesList.head, init);</span>
<span class="line-modified">1100                 initParams = initParams.append(param);</span>
<span class="line-modified">1101                 baseInitParams = baseInitParams.tail;</span>
<span class="line-modified">1102                 argTypesList = argTypesList.tail;</span>


1103             }

1104         }
<span class="line-removed">1105         return initParams;</span>
1106     }
1107 
<span class="line-modified">1108     /** Generate call to superclass constructor. This is:</span>
<span class="line-modified">1109      *</span>
<span class="line-modified">1110      *    super(id_0, ..., id_n)</span>
<span class="line-modified">1111      *</span>
<span class="line-modified">1112      * or, if based == true</span>
<span class="line-modified">1113      *</span>
<span class="line-modified">1114      *    id_0.super(id_1,...,id_n)</span>
<span class="line-modified">1115      *</span>
<span class="line-modified">1116      *  where id_0, ..., id_n are the names of the given parameters.</span>
<span class="line-modified">1117      *</span>
<span class="line-modified">1118      *  @param make    The tree factory</span>
<span class="line-modified">1119      *  @param params  The parameters that need to be passed to super</span>
<span class="line-modified">1120      *  @param typarams  The type parameters that need to be passed to super</span>
<span class="line-modified">1121      *  @param based   Is first parameter a this$n?</span>
<span class="line-modified">1122      */</span>
<span class="line-removed">1123     JCExpressionStatement SuperCall(TreeMaker make,</span>
<span class="line-removed">1124                    List&lt;Type&gt; typarams,</span>
<span class="line-removed">1125                    List&lt;JCVariableDecl&gt; params,</span>
<span class="line-removed">1126                    boolean based) {</span>
<span class="line-removed">1127         JCExpression meth;</span>
<span class="line-removed">1128         if (based) {</span>
<span class="line-removed">1129             meth = make.Select(make.Ident(params.head), names._super);</span>
<span class="line-removed">1130             params = params.tail;</span>
<span class="line-removed">1131         } else {</span>
<span class="line-removed">1132             meth = make.Ident(names._super);</span>
1133         }
<span class="line-modified">1134         List&lt;JCExpression&gt; typeargs = typarams.nonEmpty() ? make.Types(typarams) : null;</span>
<span class="line-modified">1135         return make.Exec(make.Apply(typeargs, meth, make.Idents(params)));</span>
1136     }
1137 
1138     /**
1139      * Mark sym deprecated if annotations contain @Deprecated annotation.
1140      */
1141     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1142         // In general, we cannot fully process annotations yet,  but we
1143         // can attribute the annotation types and then check to see if the
1144         // @Deprecated annotation is present.
1145         attr.attribAnnotationTypes(annotations, env);
1146         handleDeprecatedAnnotations(annotations, sym);
1147     }
1148 
1149     /**
1150      * If a list of annotations contains a reference to java.lang.Deprecated,
1151      * set the DEPRECATED flag.
1152      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1153      **/
1154     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1155         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1156             JCAnnotation a = al.head;
1157             if (a.annotationType.type == syms.deprecatedType) {
1158                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
<span class="line-modified">1159                 a.args.stream()</span>
<span class="line-modified">1160                         .filter(e -&gt; e.hasTag(ASSIGN))</span>
<span class="line-modified">1161                         .map(e -&gt; (JCAssign) e)</span>
<span class="line-modified">1162                         .filter(assign -&gt; TreeInfo.name(assign.lhs) == names.forRemoval)</span>
<span class="line-removed">1163                         .findFirst()</span>
<span class="line-removed">1164                         .ifPresent(assign -&gt; {</span>
<span class="line-removed">1165                             JCExpression rhs = TreeInfo.skipParens(assign.rhs);</span>
<span class="line-removed">1166                             if (rhs.hasTag(LITERAL)</span>
<span class="line-removed">1167                                     &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {</span>
<span class="line-removed">1168                                 sym.flags_field |= DEPRECATED_REMOVAL;</span>
<span class="line-removed">1169                             }</span>
<span class="line-removed">1170                         });</span>
1171             }
1172         }
1173     }















1174 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  38 import com.sun.tools.javac.code.Scope.StarImportScope;
  39 import com.sun.tools.javac.code.Scope.WriteableScope;
  40 import com.sun.tools.javac.code.Source.Feature;
  41 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  42 import com.sun.tools.javac.tree.*;
  43 import com.sun.tools.javac.util.*;
  44 import com.sun.tools.javac.util.DefinedBy.Api;
  45 
  46 import com.sun.tools.javac.code.Symbol.*;
  47 import com.sun.tools.javac.code.Type.*;
  48 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  49 import com.sun.tools.javac.tree.JCTree.*;
  50 
  51 import static com.sun.tools.javac.code.Flags.*;
  52 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  53 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  54 import static com.sun.tools.javac.code.Kinds.Kind.*;
  55 import static com.sun.tools.javac.code.TypeTag.CLASS;
  56 import static com.sun.tools.javac.code.TypeTag.ERROR;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
<span class="line-added">  58 </span>
<span class="line-added">  59 import static com.sun.tools.javac.code.TypeTag.*;</span>
<span class="line-added">  60 import static com.sun.tools.javac.code.TypeTag.BOT;</span>
  61 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  62 
  63 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  66 
  67 /** This is the second phase of Enter, in which classes are completed
  68  *  by resolving their headers and entering their members in the into
  69  *  the class scope. See Enter for an overall overview.
  70  *
  71  *  This class uses internal phases to process the classes. When a phase
  72  *  processes classes, the lower phases are not invoked until all classes
  73  *  pass through the current phase. Note that it is possible that upper phases
  74  *  are run due to recursive completion. The internal phases are:
  75  *  - ImportPhase: shallow pass through imports, adds information about imports
  76  *                 the NamedImportScope and StarImportScope, but avoids queries
  77  *                 about class hierarchy.
  78  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  79  *                    type parameters of the class or type argument of the supertypes.
  80  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
</pre>
<hr />
<pre>
 419                 else
 420                     importAll(tree, p, env);
 421             } else {
 422                 // Named type import.
 423                 if (tree.staticImport) {
 424                     importNamedStatic(tree, p, name, localEnv);
 425                     chk.checkCanonical(imp.selected);
 426                 } else {
 427                     Type importedType = attribImportType(imp, localEnv);
 428                     Type originalType = importedType.getOriginalType();
 429                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 430                     chk.checkCanonical(imp);
 431                     importNamed(tree.pos(), c, env, tree);
 432                 }
 433             }
 434         }
 435 
 436         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 437             Assert.check(completionEnabled);
 438             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
<span class="line-modified"> 439                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));</span>
 440             try {
 441                 // To prevent deep recursion, suppress completion of some
 442                 // types.
 443                 completionEnabled = false;
 444                 return attr.attribType(tree, env);
 445             } finally {
 446                 completionEnabled = true;
 447                 chk.setLint(prevLint);
 448             }
 449         }
 450 
 451         /** Import all classes of a class or package on demand.
 452          *  @param imp           The import that is being handled.
 453          *  @param tsym          The class or package the members of which are imported.
 454          *  @param env           The env in which the imported classes will be entered.
 455          */
 456         private void importAll(JCImport imp,
 457                                final TypeSymbol tsym,
 458                                Env&lt;AttrContext&gt; env) {
 459             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
</pre>
<hr />
<pre>
 664                         for (int i = n; i &gt; 0; i--) {
 665                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 666                                                     syms.botType);
 667                             ct.typarams_field = ct.typarams_field.prepend(v);
 668                         }
 669                     }
 670                 }
 671             }
 672 
 673         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 674             JCClassDecl tree = env.enclClass;
 675             ClassSymbol sym = tree.sym;
 676             ClassType ct = (ClassType)sym.type;
 677             // Determine supertype.
 678             Type supertype;
 679             JCExpression extending;
 680 
 681             if (tree.extending != null) {
 682                 extending = clearTypeParams(tree.extending);
 683                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
<span class="line-added"> 684                 if (supertype == syms.recordType) {</span>
<span class="line-added"> 685                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));</span>
<span class="line-added"> 686                 }</span>
 687             } else {
 688                 extending = null;
 689                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 690                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 691                                   true, false, false)
 692                 : (sym.fullname == names.java_lang_Object)
 693                 ? Type.noType
<span class="line-modified"> 694                 : sym.isRecord() ? syms.recordType : syms.objectType;</span>
 695             }
 696             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 697 
 698             // Determine interfaces.
 699             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 700             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 701             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 702             for (JCExpression iface : interfaceTrees) {
 703                 iface = clearTypeParams(iface);
 704                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 705                 if (it.hasTag(CLASS)) {
 706                     interfaces.append(it);
 707                     if (all_interfaces != null) all_interfaces.append(it);
 708                 } else {
 709                     if (all_interfaces == null)
 710                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 711                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 712                 }
 713             }
 714 
</pre>
<hr />
<pre>
 790         public void complete(Symbol sym) throws CompletionFailure {
 791             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 792                          (topLevelPhase == this));
 793 
 794             if (topLevelPhase != this) {
 795                 //only do the processing based on dependencies in the HierarchyPhase:
 796                 sym.completer = this;
 797                 return ;
 798             }
 799 
 800             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 801 
 802             super.doCompleteEnvs(List.of(env));
 803         }
 804 
 805     }
 806 
 807     private final class HeaderPhase extends AbstractHeaderPhase {
 808 
 809         public HeaderPhase() {
<span class="line-modified"> 810             super(CompletionCause.HEADER_PHASE, new RecordPhase());</span>
 811         }
 812 
 813         @Override
 814         protected void runPhase(Env&lt;AttrContext&gt; env) {
 815             JCClassDecl tree = env.enclClass;
 816             ClassSymbol sym = tree.sym;
 817             ClassType ct = (ClassType)sym.type;
 818 
 819             // create an environment for evaluating the base clauses
 820             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 821 
 822             if (tree.extending != null)
 823                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 824             for (JCExpression impl : tree.implementing)
 825                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 826             annotate.flush();
 827 
 828             attribSuperTypes(env, baseEnv);
 829 
 830             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
</pre>
<hr />
<pre>
 840             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 841 
 842             for (JCTypeParameter tp : tree.typarams)
 843                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 844 
 845             // check that no package exists with same fully qualified name,
 846             // but admit classes in the unnamed package which have the same
 847             // name as a top-level package.
 848             if (checkClash &amp;&amp;
 849                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 850                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 851                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 852             }
 853             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 854                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 855                 sym.flags_field |= AUXILIARY;
 856             }
 857         }
 858     }
 859 
<span class="line-modified"> 860     private abstract class AbstractMembersPhase extends Phase {</span>


 861 
<span class="line-modified"> 862         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {</span>
<span class="line-modified"> 863             super(completionCause, next);</span>
 864         }
 865 
 866         private boolean completing;
 867         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 868 
 869         @Override
 870         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 871             todo = todo.prependList(envs);
 872             if (completing) {
 873                 return ; //the top-level invocation will handle all envs
 874             }
 875             boolean prevCompleting = completing;
 876             completing = true;
 877             try {
 878                 while (todo.nonEmpty()) {
 879                     Env&lt;AttrContext&gt; head = todo.head;
 880                     todo = todo.tail;
 881                     super.doCompleteEnvs(List.of(head));
 882                 }
 883             } finally {
 884                 completing = prevCompleting;
 885             }
 886         }
 887 
<span class="line-modified"> 888         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {</span>



 889             ClassType ct = (ClassType)sym.type;






































 890             // enter symbols for &#39;this&#39; into current scope.
 891             VarSymbol thisSym =
<span class="line-modified"> 892                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);</span>
 893             thisSym.pos = Position.FIRSTPOS;
 894             env.info.scope.enter(thisSym);
 895             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 896             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 897                     ct.supertype_field.hasTag(CLASS)) {
 898                 VarSymbol superSym =
<span class="line-modified"> 899                         new VarSymbol(FINAL | HASINIT, names._super,</span>
<span class="line-modified"> 900                                 ct.supertype_field, sym);</span>
 901                 superSym.pos = Position.FIRSTPOS;
 902                 env.info.scope.enter(superSym);
 903             }
<span class="line-added"> 904         }</span>
<span class="line-added"> 905     }</span>
<span class="line-added"> 906 </span>
<span class="line-added"> 907     private final class RecordPhase extends AbstractMembersPhase {</span>
<span class="line-added"> 908 </span>
<span class="line-added"> 909         public RecordPhase() {</span>
<span class="line-added"> 910             super(CompletionCause.RECORD_PHASE, new MembersPhase());</span>
<span class="line-added"> 911         }</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913         @Override</span>
<span class="line-added"> 914         protected void runPhase(Env&lt;AttrContext&gt; env) {</span>
<span class="line-added"> 915             JCClassDecl tree = env.enclClass;</span>
<span class="line-added"> 916             ClassSymbol sym = tree.sym;</span>
<span class="line-added"> 917             if ((sym.flags_field &amp; RECORD) != 0) {</span>
<span class="line-added"> 918                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);</span>
<span class="line-added"> 919                 memberEnter.memberEnter(fields, env);</span>
<span class="line-added"> 920                 for (JCVariableDecl field : fields) {</span>
<span class="line-added"> 921                     sym.getRecordComponent(field, true);</span>
<span class="line-added"> 922                 }</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924                 enterThisAndSuper(sym, env);</span>
<span class="line-added"> 925 </span>
<span class="line-added"> 926                 // lets enter all constructors</span>
<span class="line-added"> 927                 for (JCTree def : tree.defs) {</span>
<span class="line-added"> 928                     if (TreeInfo.isConstructor(def)) {</span>
<span class="line-added"> 929                         memberEnter.memberEnter(def, env);</span>
<span class="line-added"> 930                     }</span>
<span class="line-added"> 931                 }</span>
<span class="line-added"> 932             }</span>
<span class="line-added"> 933         }</span>
<span class="line-added"> 934     }</span>
<span class="line-added"> 935 </span>
<span class="line-added"> 936     /** Enter member fields and methods of a class</span>
<span class="line-added"> 937      */</span>
<span class="line-added"> 938     private final class MembersPhase extends AbstractMembersPhase {</span>
<span class="line-added"> 939 </span>
<span class="line-added"> 940         public MembersPhase() {</span>
<span class="line-added"> 941             super(CompletionCause.MEMBERS_PHASE, null);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943 </span>
<span class="line-added"> 944         @Override</span>
<span class="line-added"> 945         protected void runPhase(Env&lt;AttrContext&gt; env) {</span>
<span class="line-added"> 946             JCClassDecl tree = env.enclClass;</span>
<span class="line-added"> 947             ClassSymbol sym = tree.sym;</span>
<span class="line-added"> 948             ClassType ct = (ClassType)sym.type;</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950             // Add default constructor if needed.</span>
<span class="line-added"> 951             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);</span>
<span class="line-added"> 952             if (helper != null) {</span>
<span class="line-added"> 953                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);</span>
<span class="line-added"> 954                 tree.defs = tree.defs.prepend(constrDef);</span>
<span class="line-added"> 955             }</span>
<span class="line-added"> 956             if (!sym.isRecord()) {</span>
<span class="line-added"> 957                 enterThisAndSuper(sym, env);</span>
<span class="line-added"> 958             }</span>
 959 
 960             if (!tree.typarams.isEmpty()) {
 961                 for (JCTypeParameter tvar : tree.typarams) {
 962                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
 963                 }
 964             }
 965 
 966             finishClass(tree, env);
 967 
 968             if (allowTypeAnnos) {
 969                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 970                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
 971             }
 972         }
 973 
<span class="line-added"> 974         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {</span>
<span class="line-added"> 975             JCClassDecl tree = env.enclClass;</span>
<span class="line-added"> 976             ClassSymbol sym = tree.sym;</span>
<span class="line-added"> 977             DefaultConstructorHelper helper = null;</span>
<span class="line-added"> 978             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);</span>
<span class="line-added"> 979             boolean isRecord = sym.isRecord();</span>
<span class="line-added"> 980             if (isClassWithoutInit &amp;&amp; !isRecord) {</span>
<span class="line-added"> 981                 helper = new BasicConstructorHelper(sym);</span>
<span class="line-added"> 982                 if (sym.name.isEmpty()) {</span>
<span class="line-added"> 983                     JCNewClass nc = (JCNewClass)env.next.tree;</span>
<span class="line-added"> 984                     if (nc.constructor != null) {</span>
<span class="line-added"> 985                         if (nc.constructor.kind != ERR) {</span>
<span class="line-added"> 986                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);</span>
<span class="line-added"> 987                         } else {</span>
<span class="line-added"> 988                             helper = null;</span>
<span class="line-added"> 989                         }</span>
<span class="line-added"> 990                     }</span>
<span class="line-added"> 991                 }</span>
<span class="line-added"> 992             }</span>
<span class="line-added"> 993             if (isRecord) {</span>
<span class="line-added"> 994                 JCMethodDecl canonicalInit = null;</span>
<span class="line-added"> 995                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {</span>
<span class="line-added"> 996                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));</span>
<span class="line-added"> 997                 }</span>
<span class="line-added"> 998                 if (canonicalInit != null) {</span>
<span class="line-added"> 999                     canonicalInit.sym.flags_field |= Flags.RECORD;</span>
<span class="line-added">1000                 }</span>
<span class="line-added">1001             }</span>
<span class="line-added">1002             return helper;</span>
<span class="line-added">1003         }</span>
<span class="line-added">1004 </span>
1005         /** Enter members for a class.
1006          */
1007         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1008             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
1009                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
1010                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
1011                 addEnumMembers(tree, env);
1012             }
<span class="line-modified">1013             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;</span>
<span class="line-modified">1014             List&lt;JCTree&gt; alreadyEntered = null;</span>
<span class="line-added">1015             if (isRecord) {</span>
<span class="line-added">1016                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));</span>
<span class="line-added">1017                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()</span>
<span class="line-added">1018                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;</span>
<span class="line-added">1019                                 ((JCMethodDecl)t).sym != null &amp;&amp;</span>
<span class="line-added">1020                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));</span>
<span class="line-added">1021             }</span>
<span class="line-added">1022             List&lt;JCTree&gt; defsToEnter = isRecord ?</span>
<span class="line-added">1023                     tree.defs.diff(alreadyEntered) : tree.defs;</span>
<span class="line-added">1024             memberEnter.memberEnter(defsToEnter, env);</span>
<span class="line-added">1025             List&lt;JCTree&gt; defsBeforeAddingNewMembers = tree.defs;</span>
<span class="line-added">1026             if (isRecord) {</span>
<span class="line-added">1027                 addRecordMembersIfNeeded(tree, env);</span>
<span class="line-added">1028             }</span>
1029             if (tree.sym.isAnnotationType()) {
1030                 Assert.check(tree.sym.isCompleted());
1031                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1032             }
1033         }
1034 
<span class="line-added">1035         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {</span>
<span class="line-added">1036             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());</span>
<span class="line-added">1037             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);</span>
<span class="line-added">1038             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {</span>
<span class="line-added">1039                 /* here we are pushing the annotations present in the corresponding field down to the accessor</span>
<span class="line-added">1040                  * it could be that some of those annotations are not applicable to the accessor, they will be striped</span>
<span class="line-added">1041                  * away later at Check::validateAnnotation</span>
<span class="line-added">1042                  */</span>
<span class="line-added">1043                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos();</span>
<span class="line-added">1044                 JCMethodDecl getter = make.at(tree.pos).</span>
<span class="line-added">1045                         MethodDef(</span>
<span class="line-added">1046                                 make.Modifiers(Flags.PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),</span>
<span class="line-added">1047                           tree.sym.name,</span>
<span class="line-added">1048                           /* we need to special case for the case when the user declared the type as an ident</span>
<span class="line-added">1049                            * if we don&#39;t do that then we can have issues if type annotations are applied to the</span>
<span class="line-added">1050                            * return type: javac issues an error if a type annotation is applied to java.lang.String</span>
<span class="line-added">1051                            * but applying a type annotation to String is kosher</span>
<span class="line-added">1052                            */</span>
<span class="line-added">1053                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),</span>
<span class="line-added">1054                           List.nil(),</span>
<span class="line-added">1055                           List.nil(),</span>
<span class="line-added">1056                           List.nil(), // thrown</span>
<span class="line-added">1057                           null,</span>
<span class="line-added">1058                           null);</span>
<span class="line-added">1059                 memberEnter.memberEnter(getter, env);</span>
<span class="line-added">1060                 rec.accessor = getter.sym;</span>
<span class="line-added">1061                 rec.accessorMeth = getter;</span>
<span class="line-added">1062             } else if (implSym != null) {</span>
<span class="line-added">1063                 rec.accessor = implSym;</span>
<span class="line-added">1064             }</span>
<span class="line-added">1065         }</span>
<span class="line-added">1066 </span>
1067         /** Add the implicit members for an enum type
1068          *  to the symbol table.
1069          */
1070         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1071             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
1072 

1073             JCMethodDecl values = make.
1074                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1075                           names.values,
1076                           valuesType,
1077                           List.nil(),
1078                           List.nil(),
<span class="line-modified">1079                           List.nil(),</span>
<span class="line-modified">1080                           null,</span>
1081                           null);
1082             memberEnter.memberEnter(values, env);
1083 

1084             JCMethodDecl valueOf = make.
1085                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1086                           names.valueOf,
1087                           make.Type(tree.sym.type),
1088                           List.nil(),
1089                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
1090                                                              Flags.MANDATED),
1091                                                 names.fromString(&quot;name&quot;),
1092                                                 make.Type(syms.stringType), null)),
<span class="line-modified">1093                           List.nil(),</span>
<span class="line-modified">1094                           null,</span>
1095                           null);
1096             memberEnter.memberEnter(valueOf, env);
1097         }
1098 
<span class="line-added">1099         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {</span>
<span class="line-added">1100             // let&#39;s check if there is a constructor with exactly the same arguments as the record components</span>
<span class="line-added">1101             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));</span>
<span class="line-added">1102             JCMethodDecl canonicalDecl = null;</span>
<span class="line-added">1103             for (JCTree def : tree.defs) {</span>
<span class="line-added">1104                 if (TreeInfo.isConstructor(def)) {</span>
<span class="line-added">1105                     JCMethodDecl mdecl = (JCMethodDecl)def;</span>
<span class="line-added">1106                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {</span>
<span class="line-added">1107                         canonicalDecl = mdecl;</span>
<span class="line-added">1108                         break;</span>
<span class="line-added">1109                     }</span>
<span class="line-added">1110                 }</span>
<span class="line-added">1111             }</span>
<span class="line-added">1112             return canonicalDecl;</span>
<span class="line-added">1113         }</span>
<span class="line-added">1114 </span>
<span class="line-added">1115         /** Add the implicit members for a record</span>
<span class="line-added">1116          *  to the symbol table.</span>
<span class="line-added">1117          */</span>
<span class="line-added">1118         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {</span>
<span class="line-added">1119             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {</span>
<span class="line-added">1120                 JCMethodDecl toString = make.</span>
<span class="line-added">1121                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.GENERATED_MEMBER),</span>
<span class="line-added">1122                               names.toString,</span>
<span class="line-added">1123                               make.Type(syms.stringType),</span>
<span class="line-added">1124                               List.nil(),</span>
<span class="line-added">1125                               List.nil(),</span>
<span class="line-added">1126                               List.nil(),</span>
<span class="line-added">1127                               null,</span>
<span class="line-added">1128                               null);</span>
<span class="line-added">1129                 memberEnter.memberEnter(toString, env);</span>
<span class="line-added">1130             }</span>
<span class="line-added">1131 </span>
<span class="line-added">1132             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {</span>
<span class="line-added">1133                 JCMethodDecl hashCode = make.</span>
<span class="line-added">1134                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),</span>
<span class="line-added">1135                               names.hashCode,</span>
<span class="line-added">1136                               make.Type(syms.intType),</span>
<span class="line-added">1137                               List.nil(),</span>
<span class="line-added">1138                               List.nil(),</span>
<span class="line-added">1139                               List.nil(),</span>
<span class="line-added">1140                               null,</span>
<span class="line-added">1141                               null);</span>
<span class="line-added">1142                 memberEnter.memberEnter(hashCode, env);</span>
<span class="line-added">1143             }</span>
<span class="line-added">1144 </span>
<span class="line-added">1145             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {</span>
<span class="line-added">1146                 JCMethodDecl equals = make.</span>
<span class="line-added">1147                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),</span>
<span class="line-added">1148                               names.equals,</span>
<span class="line-added">1149                               make.Type(syms.booleanType),</span>
<span class="line-added">1150                               List.nil(),</span>
<span class="line-added">1151                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),</span>
<span class="line-added">1152                                                 names.fromString(&quot;o&quot;),</span>
<span class="line-added">1153                                                 make.Type(syms.objectType), null)),</span>
<span class="line-added">1154                               List.nil(),</span>
<span class="line-added">1155                               null,</span>
<span class="line-added">1156                               null);</span>
<span class="line-added">1157                 memberEnter.memberEnter(equals, env);</span>
<span class="line-added">1158             }</span>
<span class="line-added">1159 </span>
<span class="line-added">1160             // fields can&#39;t be varargs, lets remove the flag</span>
<span class="line-added">1161             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);</span>
<span class="line-added">1162             for (JCVariableDecl field: recordFields) {</span>
<span class="line-added">1163                 field.mods.flags &amp;= ~Flags.VARARGS;</span>
<span class="line-added">1164                 field.sym.flags_field &amp;= ~Flags.VARARGS;</span>
<span class="line-added">1165             }</span>
<span class="line-added">1166             // now lets add the accessors</span>
<span class="line-added">1167             recordFields.stream()</span>
<span class="line-added">1168                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))</span>
<span class="line-added">1169                     .forEach(vd -&gt; addAccessor(vd, env));</span>
<span class="line-added">1170         }</span>
<span class="line-added">1171     }</span>
<span class="line-added">1172 </span>
<span class="line-added">1173     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {</span>
<span class="line-added">1174         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {</span>
<span class="line-added">1175             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {</span>
<span class="line-added">1176                 return (MethodSymbol) s;</span>
<span class="line-added">1177             }</span>
<span class="line-added">1178         }</span>
<span class="line-added">1179         return null;</span>
1180     }
1181 
1182 /* ***************************************************************************
1183  * tree building
1184  ****************************************************************************/
1185 
<span class="line-modified">1186     interface DefaultConstructorHelper {</span>
<span class="line-modified">1187        Type constructorType();</span>
<span class="line-modified">1188        MethodSymbol constructorSymbol();</span>
<span class="line-modified">1189        Type enclosingType();</span>
<span class="line-modified">1190        TypeSymbol owner();</span>
<span class="line-modified">1191        List&lt;Name&gt; superArgs();</span>
<span class="line-modified">1192        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }</span>
<span class="line-modified">1193     }</span>
<span class="line-modified">1194 </span>
<span class="line-modified">1195     class BasicConstructorHelper implements DefaultConstructorHelper {</span>
<span class="line-modified">1196 </span>
<span class="line-modified">1197         TypeSymbol owner;</span>
<span class="line-modified">1198         Type constructorType;</span>
<span class="line-modified">1199         MethodSymbol constructorSymbol;</span>
<span class="line-modified">1200 </span>
<span class="line-modified">1201         BasicConstructorHelper(TypeSymbol owner) {</span>
<span class="line-modified">1202             this.owner = owner;</span>
<span class="line-modified">1203         }</span>
<span class="line-modified">1204 </span>
<span class="line-modified">1205         @Override</span>
<span class="line-modified">1206         public Type constructorType() {</span>
<span class="line-modified">1207             if (constructorType == null) {</span>
<span class="line-modified">1208                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);</span>
<span class="line-modified">1209             }</span>
<span class="line-modified">1210             return constructorType;</span>
<span class="line-modified">1211         }</span>
<span class="line-modified">1212 </span>
<span class="line-modified">1213         @Override</span>
<span class="line-modified">1214         public MethodSymbol constructorSymbol() {</span>
<span class="line-modified">1215             if (constructorSymbol == null) {</span>
<span class="line-modified">1216                 long flags;</span>
<span class="line-modified">1217                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;</span>
<span class="line-modified">1218                     (types.supertype(owner().type).tsym == syms.enumSym)) {</span>
<span class="line-modified">1219                     // constructors of true enums are private</span>
<span class="line-modified">1220                     flags = PRIVATE | GENERATEDCONSTR;</span>
<span class="line-modified">1221                 } else if ((owner().flags_field &amp; RECORD) != 0) {</span>
<span class="line-added">1222                     // record constructors are public</span>
<span class="line-added">1223                     flags = PUBLIC | GENERATEDCONSTR;</span>
<span class="line-added">1224                 } else {</span>
<span class="line-added">1225                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;</span>
<span class="line-added">1226                 }</span>
<span class="line-added">1227                 constructorSymbol = new MethodSymbol(flags, names.init,</span>
<span class="line-added">1228                     constructorType(), owner());</span>
<span class="line-added">1229             }</span>
<span class="line-added">1230             return constructorSymbol;</span>
<span class="line-added">1231         }</span>
<span class="line-added">1232 </span>
<span class="line-added">1233         @Override</span>
<span class="line-added">1234         public Type enclosingType() {</span>
<span class="line-added">1235             return Type.noType;</span>
<span class="line-added">1236     }</span>
<span class="line-added">1237 </span>
<span class="line-added">1238         @Override</span>
<span class="line-added">1239         public TypeSymbol owner() {</span>
<span class="line-added">1240             return owner;</span>
<span class="line-added">1241         }</span>
<span class="line-added">1242 </span>
<span class="line-added">1243         @Override</span>
<span class="line-added">1244         public List&lt;Name&gt; superArgs() {</span>
<span class="line-added">1245             return List.nil();</span>
<span class="line-added">1246             }</span>
<span class="line-added">1247     }</span>
<span class="line-added">1248 </span>
<span class="line-added">1249     class AnonClassConstructorHelper extends BasicConstructorHelper {</span>
<span class="line-added">1250 </span>
<span class="line-added">1251         MethodSymbol constr;</span>
<span class="line-added">1252         Type encl;</span>
<span class="line-added">1253         boolean based = false;</span>
<span class="line-added">1254 </span>
<span class="line-added">1255         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {</span>
<span class="line-added">1256             super(owner);</span>
<span class="line-added">1257             this.constr = constr;</span>
<span class="line-added">1258             this.encl = encl != null ? encl.type : Type.noType;</span>
1259         }
<span class="line-modified">1260 </span>
<span class="line-modified">1261         @Override</span>
<span class="line-added">1262         public Type constructorType() {</span>
<span class="line-added">1263             if (constructorType == null) {</span>
<span class="line-added">1264                 Type ctype = types.memberType(owner.type, constr);</span>
<span class="line-added">1265                 if (!enclosingType().hasTag(NONE)) {</span>
<span class="line-added">1266                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));</span>
<span class="line-added">1267                     based = true;</span>
<span class="line-added">1268                 }</span>
<span class="line-added">1269                 constructorType = ctype;</span>
<span class="line-added">1270             }</span>
<span class="line-added">1271             return constructorType;</span>
1272         }
<span class="line-modified">1273 </span>
<span class="line-modified">1274         @Override</span>
<span class="line-modified">1275         public MethodSymbol constructorSymbol() {</span>
<span class="line-modified">1276             MethodSymbol csym = super.constructorSymbol();</span>
<span class="line-modified">1277             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);</span>
<span class="line-modified">1278             csym.flags_field |= based ? ANONCONSTR_BASED : 0;</span>
<span class="line-modified">1279             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">1280             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();</span>
<span class="line-modified">1281             if (!enclosingType().hasTag(NONE)) {</span>
<span class="line-modified">1282                 argtypes = argtypes.tail;</span>
<span class="line-modified">1283                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));</span>
<span class="line-modified">1284             }</span>
<span class="line-added">1285             if (constr.params != null) {</span>
<span class="line-added">1286                 for (VarSymbol p : constr.params) {</span>
<span class="line-added">1287                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));</span>
<span class="line-added">1288                     argtypes = argtypes.tail;</span>
<span class="line-added">1289                 }</span>
<span class="line-added">1290             }</span>
<span class="line-added">1291             csym.params = params.toList();</span>
<span class="line-added">1292             return csym;</span>
<span class="line-added">1293         }</span>
<span class="line-added">1294 </span>
<span class="line-added">1295         @Override</span>
<span class="line-added">1296         public Type enclosingType() {</span>
<span class="line-added">1297             return encl;</span>
<span class="line-added">1298         }</span>
<span class="line-added">1299 </span>
<span class="line-added">1300         @Override</span>
<span class="line-added">1301         public List&lt;Name&gt; superArgs() {</span>
<span class="line-added">1302             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());</span>
<span class="line-added">1303             if (!enclosingType().hasTag(NONE)) {</span>
<span class="line-added">1304                 params = params.tail;</span>
<span class="line-added">1305             }</span>
<span class="line-added">1306             return params.map(vd -&gt; vd.name);</span>
1307         }


1308     }
1309 
<span class="line-modified">1310     class RecordConstructorHelper extends BasicConstructorHelper {</span>
<span class="line-modified">1311 </span>
<span class="line-modified">1312         List&lt;VarSymbol&gt; recordFieldSymbols;</span>
<span class="line-modified">1313         List&lt;JCVariableDecl&gt; recordFieldDecls;</span>
<span class="line-modified">1314 </span>
<span class="line-modified">1315         RecordConstructorHelper(TypeSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {</span>
<span class="line-modified">1316             super(owner);</span>
<span class="line-modified">1317             this.recordFieldDecls = recordFieldDecls;</span>
<span class="line-modified">1318             this.recordFieldSymbols = recordFieldDecls.map(vd -&gt; vd.sym);</span>
<span class="line-modified">1319         }</span>
<span class="line-modified">1320 </span>
<span class="line-modified">1321         @Override</span>
<span class="line-modified">1322         public Type constructorType() {</span>
<span class="line-modified">1323             if (constructorType == null) {</span>
<span class="line-modified">1324                 List&lt;Type&gt; argtypes = recordFieldSymbols.map(v -&gt; (v.flags_field &amp; Flags.VARARGS) != 0 ? types.elemtype(v.type) : v.type);</span>
<span class="line-modified">1325                 constructorType = new MethodType(argtypes, syms.voidType, List.nil(), syms.methodClass);</span>
<span class="line-modified">1326             }</span>
<span class="line-modified">1327             return constructorType;</span>
<span class="line-added">1328         }</span>
<span class="line-added">1329 </span>
<span class="line-added">1330         @Override</span>
<span class="line-added">1331         public MethodSymbol constructorSymbol() {</span>
<span class="line-added">1332             MethodSymbol csym = super.constructorSymbol();</span>
<span class="line-added">1333             /* if we have to generate a default constructor for records we will treat it as the compact one</span>
<span class="line-added">1334              * to trigger field initialization later on</span>
1335              */
<span class="line-modified">1336             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;</span>
<span class="line-modified">1337             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">1338             for (VarSymbol p : recordFieldSymbols) {</span>
<span class="line-modified">1339                 params.add(new VarSymbol(GENERATED_MEMBER | PARAMETER | RECORD | ((p.flags_field &amp; Flags.VARARGS) != 0 ? Flags.VARARGS : 0), p.name, p.type, csym));</span>
<span class="line-added">1340             }</span>
<span class="line-added">1341             csym.params = params.toList();</span>
<span class="line-added">1342             csym.flags_field |= RECORD | PUBLIC;</span>
<span class="line-added">1343             return csym;</span>
1344         }
<span class="line-modified">1345 </span>
<span class="line-modified">1346         @Override</span>
<span class="line-modified">1347         public JCMethodDecl finalAdjustment(JCMethodDecl md) {</span>
<span class="line-modified">1348             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;</span>
<span class="line-modified">1349             for (JCVariableDecl arg : md.params) {</span>
<span class="line-modified">1350                 /* at this point we are passing all the annotations in the field to the corresponding</span>
<span class="line-modified">1351                  * parameter in the constructor.</span>
<span class="line-modified">1352                  */</span>
<span class="line-modified">1353                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);</span>
<span class="line-modified">1354                 arg.mods.annotations = rc.getOriginalAnnos();</span>
<span class="line-added">1355                 arg.vartype = tmpRecordFieldDecls.head.vartype;</span>
<span class="line-added">1356                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;</span>
1357             }
<span class="line-added">1358             return md;</span>
1359         }

1360     }
1361 
<span class="line-modified">1362     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {</span>
<span class="line-modified">1363         Type initType = helper.constructorType();</span>
<span class="line-modified">1364         MethodSymbol initSym = helper.constructorSymbol();</span>
<span class="line-modified">1365         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();</span>
<span class="line-modified">1366         if (helper.owner().type != syms.objectType) {</span>
<span class="line-modified">1367             JCExpression meth;</span>
<span class="line-modified">1368             if (!helper.enclosingType().hasTag(NONE)) {</span>
<span class="line-modified">1369                 meth = make.Select(make.Ident(initSym.params.head), names._super);</span>
<span class="line-modified">1370             } else {</span>
<span class="line-modified">1371                 meth = make.Ident(names._super);</span>
<span class="line-modified">1372             }</span>
<span class="line-modified">1373             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?</span>
<span class="line-modified">1374                     make.Types(initType.getTypeArguments()) : null;</span>
<span class="line-modified">1375             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));</span>
<span class="line-modified">1376             stats.add(superCall);</span>










1377         }
<span class="line-modified">1378         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));</span>
<span class="line-modified">1379         return helper.finalAdjustment(result);</span>
1380     }
1381 
1382     /**
1383      * Mark sym deprecated if annotations contain @Deprecated annotation.
1384      */
1385     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1386         // In general, we cannot fully process annotations yet,  but we
1387         // can attribute the annotation types and then check to see if the
1388         // @Deprecated annotation is present.
1389         attr.attribAnnotationTypes(annotations, env);
1390         handleDeprecatedAnnotations(annotations, sym);
1391     }
1392 
1393     /**
1394      * If a list of annotations contains a reference to java.lang.Deprecated,
1395      * set the DEPRECATED flag.
1396      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1397      **/
1398     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1399         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1400             JCAnnotation a = al.head;
1401             if (a.annotationType.type == syms.deprecatedType) {
1402                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
<span class="line-modified">1403                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);</span>
<span class="line-modified">1404             } else if (a.annotationType.type == syms.previewFeatureType) {</span>
<span class="line-modified">1405                 sym.flags_field |= Flags.PREVIEW_API;</span>
<span class="line-modified">1406                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);</span>








1407             }
1408         }
1409     }
<span class="line-added">1410     //where:</span>
<span class="line-added">1411         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {</span>
<span class="line-added">1412             a.args.stream()</span>
<span class="line-added">1413                     .filter(e -&gt; e.hasTag(ASSIGN))</span>
<span class="line-added">1414                     .map(e -&gt; (JCAssign) e)</span>
<span class="line-added">1415                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)</span>
<span class="line-added">1416                     .findFirst()</span>
<span class="line-added">1417                     .ifPresent(assign -&gt; {</span>
<span class="line-added">1418                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);</span>
<span class="line-added">1419                         if (rhs.hasTag(LITERAL)</span>
<span class="line-added">1420                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {</span>
<span class="line-added">1421                             sym.flags_field |= flag;</span>
<span class="line-added">1422                         }</span>
<span class="line-added">1423                     });</span>
<span class="line-added">1424         }</span>
1425 }
</pre>
</td>
</tr>
</table>
<center><a href="TreeHasher.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../file/BaseFileManager.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
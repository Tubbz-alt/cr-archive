<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/sjavac/pubapi/PubApi.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.sjavac.pubapi;
 27 
 28 
 29 import static com.sun.tools.sjavac.Util.union;
 30 
 31 import java.io.Serializable;
 32 import java.util.ArrayList;
 33 import java.util.Collection;
 34 import java.util.Collections;
 35 import java.util.Comparator;
 36 import java.util.HashMap;
 37 import java.util.HashSet;
 38 import java.util.List;
 39 import java.util.Map;
 40 import java.util.Optional;
 41 import java.util.Set;
 42 import java.util.regex.Matcher;
 43 import java.util.regex.Pattern;
 44 import java.util.stream.Collectors;
 45 import java.util.stream.Stream;
 46 
 47 import javax.lang.model.element.Modifier;
 48 
 49 import com.sun.tools.javac.util.Assert;
 50 import com.sun.tools.javac.util.StringUtils;
 51 
 52 public class PubApi implements Serializable {
 53 
 54     private static final long serialVersionUID = 5926627347801986850L;
 55 
 56     // Used to have Set here. Problem is that the objects are mutated during
 57     // javac_state loading, causing them to change hash codes. We could probably
 58     // change back to Set once javac_state loading is cleaned up.
 59     public final Map&lt;String, PubType&gt; types = new HashMap&lt;&gt;();
 60     public final Map&lt;String, PubVar&gt; variables = new HashMap&lt;&gt;();
 61     public final Map&lt;String, PubMethod&gt; methods = new HashMap&lt;&gt;();
<a name="2" id="anc2"></a>
 62 
 63     public PubApi() {
 64     }
 65 
 66     public PubApi(Collection&lt;PubType&gt; types,
 67                   Collection&lt;PubVar&gt; variables,
 68                   Collection&lt;PubMethod&gt; methods) {
 69         types.forEach(this::addPubType);
 70         variables.forEach(this::addPubVar);
 71         methods.forEach(this::addPubMethod);
 72     }
 73 
 74     // Currently this is implemented as equality. This is far from optimal. It
 75     // should preferably make sure that all previous methods are still available
 76     // and no abstract methods are added. It should also be aware of inheritance
 77     // of course.
 78     public boolean isBackwardCompatibleWith(PubApi older) {
 79         return equals(older);
 80     }
 81 
 82     private static String typeLine(PubType type) {
 83         if (type.fqName.isEmpty())
 84             throw new RuntimeException(&quot;empty class name &quot; + type);
 85         return String.format(&quot;TYPE %s%s&quot;, asString(type.modifiers), type.fqName);
 86     }
 87 
 88     private static String varLine(PubVar var) {
 89         return String.format(&quot;VAR %s%s %s%s&quot;,
 90                              asString(var.modifiers),
 91                              TypeDesc.encodeAsString(var.type),
 92                              var.identifier,
 93                              var.getConstValue().map(v -&gt; &quot; = &quot; + v).orElse(&quot;&quot;));
 94     }
 95 
 96     private static String methodLine(PubMethod method) {
 97         return String.format(&quot;METHOD %s%s%s %s(%s)%s&quot;,
 98                              asString(method.modifiers),
 99                              method.typeParams.isEmpty() ? &quot;&quot; : (&quot;&lt;&quot; + method.typeParams.stream().map(PubApiTypeParam::asString).collect(Collectors.joining(&quot;,&quot;)) + &quot;&gt; &quot;),
100                              TypeDesc.encodeAsString(method.returnType),
101                              method.identifier,
102                              commaSeparated(method.paramTypes),
103                              method.throwDecls.isEmpty()
104                                  ? &quot;&quot;
105                                  : &quot; throws &quot; + commaSeparated(method.throwDecls));
106     }
107 
108     public List&lt;String&gt; asListOfStrings() {
109         List&lt;String&gt; lines = new ArrayList&lt;&gt;();
110 
111         // Types
112         types.values()
113              .stream()
114              .sorted(Comparator.comparing(PubApi::typeLine))
115              .forEach(type -&gt; {
116                  lines.add(typeLine(type));
117                  for (String subline : type.pubApi.asListOfStrings())
118                      lines.add(&quot;  &quot; + subline);
119              });
120 
121         // Variables
122         variables.values()
123                  .stream()
124                  .map(PubApi::varLine)
125                  .sorted()
126                  .forEach(lines::add);
127 
128         // Methods
129         methods.values()
130                .stream()
131                .map(PubApi::methodLine)
132                .sorted()
133                .forEach(lines::add);
134 
135         return lines;
136     }
137 
138     @Override
139     public boolean equals(Object obj) {
140         if (getClass() != obj.getClass())
141             return false;
142         PubApi other = (PubApi) obj;
143         return types.equals(other.types)
144             &amp;&amp; variables.equals(other.variables)
145             &amp;&amp; methods.equals(other.methods);
146     }
147 
148     @Override
149     public int hashCode() {
150         return types.keySet().hashCode()
151              ^ variables.keySet().hashCode()
152              ^ methods.keySet().hashCode();
153     }
154 
155     private static String commaSeparated(List&lt;TypeDesc&gt; typeDescs) {
156         return typeDescs.stream()
157                         .map(TypeDesc::encodeAsString)
158                         .collect(Collectors.joining(&quot;,&quot;));
159     }
160 
161     // Create space separated list of modifiers (with a trailing space)
162     private static String asString(Set&lt;Modifier&gt; modifiers) {
163         return modifiers.stream()
164                         .map(mod -&gt; mod + &quot; &quot;)
165                         .sorted()
166                         .collect(Collectors.joining());
167     }
168 
169     // Used to combine class PubApis to package level PubApis
170     public static PubApi mergeTypes(PubApi api1, PubApi api2) {
171         Assert.check(api1.methods.isEmpty(), &quot;Can only merge types.&quot;);
172         Assert.check(api2.methods.isEmpty(), &quot;Can only merge types.&quot;);
173         Assert.check(api1.variables.isEmpty(), &quot;Can only merge types.&quot;);
174         Assert.check(api2.variables.isEmpty(), &quot;Can only merge types.&quot;);
175         PubApi merged = new PubApi();
176         merged.types.putAll(api1.types);
177         merged.types.putAll(api2.types);
178         return merged;
179     }
180 
181 
182     // Used for line-by-line parsing
183     private PubType lastInsertedType = null;
184 
185     private final static String MODIFIERS = Stream.of(Modifier.values())
186                                                   .map(Modifier::name)
187                                                   .map(StringUtils::toLowerCase)
188                                                   .collect(Collectors.joining(&quot;|&quot;, &quot;(&quot;, &quot;)&quot;));
189 
190     private final static Pattern MOD_PATTERN = Pattern.compile(&quot;(&quot; + MODIFIERS + &quot; )*&quot;);
191     private final static Pattern METHOD_PATTERN = Pattern.compile(&quot;(?&lt;ret&gt;.+?) (?&lt;name&gt;\\S+)\\((?&lt;params&gt;.*)\\)( throws (?&lt;throws&gt;.*))?&quot;);
192     private final static Pattern VAR_PATTERN = Pattern.compile(&quot;VAR (?&lt;modifiers&gt;(&quot;+MODIFIERS+&quot; )*)(?&lt;type&gt;.+?) (?&lt;id&gt;\\S+)( = (?&lt;val&gt;.*))?&quot;);
193     private final static Pattern TYPE_PATTERN = Pattern.compile(&quot;TYPE (?&lt;modifiers&gt;(&quot;+MODIFIERS+&quot; )*)(?&lt;fullyQualified&gt;\\S+)&quot;);
194 
195     public void appendItem(String l) {
196         try {
197             if (l.startsWith(&quot;  &quot;)) {
198                 lastInsertedType.pubApi.appendItem(l.substring(2));
199                 return;
200             }
201 
202             if (l.startsWith(&quot;METHOD&quot;)) {
203                 l = l.substring(&quot;METHOD &quot;.length());
204                 Set&lt;Modifier&gt; modifiers = new HashSet&lt;&gt;();
205                 Matcher modMatcher = MOD_PATTERN.matcher(l);
206                 if (modMatcher.find()) {
207                     String modifiersStr = modMatcher.group();
208                     modifiers.addAll(parseModifiers(modifiersStr));
209                     l = l.substring(modifiersStr.length());
210                 }
211                 List&lt;PubApiTypeParam&gt; typeParams = new ArrayList&lt;&gt;();
212                 if (l.startsWith(&quot;&lt;&quot;)) {
213                     int closingPos = findClosingTag(l, 0);
214                     String str = l.substring(1, closingPos);
215                     l = l.substring(closingPos+1);
216                     typeParams.addAll(parseTypeParams(splitOnTopLevelCommas(str)));
217                 }
218                 Matcher mm = METHOD_PATTERN.matcher(l);
219                 if (!mm.matches())
220                     throw new AssertionError(&quot;Could not parse return type, identifier, parameter types or throws declaration of method: &quot; + l);
221 
222                 List&lt;String&gt; params = splitOnTopLevelCommas(mm.group(&quot;params&quot;));
223                 String th = Optional.ofNullable(mm.group(&quot;throws&quot;)).orElse(&quot;&quot;);
224                 List&lt;String&gt; throwz = splitOnTopLevelCommas(th);
225                 PubMethod m = new PubMethod(modifiers,
226                                             typeParams,
227                                             TypeDesc.decodeString(mm.group(&quot;ret&quot;)),
228                                             mm.group(&quot;name&quot;),
229                                             parseTypeDescs(params),
230                                             parseTypeDescs(throwz));
231                 addPubMethod(m);
232                 return;
233             }
234 
235             Matcher vm = VAR_PATTERN.matcher(l);
236             if (vm.matches()) {
237                 addPubVar(new PubVar(parseModifiers(vm.group(&quot;modifiers&quot;)),
238                                      TypeDesc.decodeString(vm.group(&quot;type&quot;)),
239                                      vm.group(&quot;id&quot;),
240                                      vm.group(&quot;val&quot;)));
241                 return;
242             }
243 
244             Matcher tm = TYPE_PATTERN.matcher(l);
245             if (tm.matches()) {
246                 addPubType(new PubType(parseModifiers(tm.group(&quot;modifiers&quot;)),
247                                        tm.group(&quot;fullyQualified&quot;),
248                                        new PubApi()));
249                 return;
250             }
251 
252             throw new AssertionError(&quot;No matching line pattern.&quot;);
253         } catch (Throwable e) {
254             throw new AssertionError(&quot;Could not parse API line: &quot; + l, e);
255         }
256     }
257 
258     public void addPubType(PubType t) {
259         types.put(t.fqName, t);
260         lastInsertedType = t;
261     }
262 
263     public void addPubVar(PubVar v) {
264         variables.put(v.identifier, v);
265     }
266 
267     public void addPubMethod(PubMethod m) {
268         methods.put(m.asSignatureString(), m);
269     }
270 
271     private static List&lt;TypeDesc&gt; parseTypeDescs(List&lt;String&gt; strs) {
272         return strs.stream()
273                    .map(TypeDesc::decodeString)
274                    .collect(Collectors.toList());
275     }
276 
277     private static List&lt;PubApiTypeParam&gt; parseTypeParams(List&lt;String&gt; strs) {
278         return strs.stream().map(PubApi::parseTypeParam).collect(Collectors.toList());
279     }
280 
281     // Parse a type parameter string. Example input:
282     //     identifier
283     //     identifier extends Type (&amp; Type)*
284     private static PubApiTypeParam parseTypeParam(String typeParamString) {
285         int extPos = typeParamString.indexOf(&quot; extends &quot;);
286         if (extPos == -1)
287             return new PubApiTypeParam(typeParamString, Collections.emptyList());
288         String identifier = typeParamString.substring(0, extPos);
289         String rest = typeParamString.substring(extPos + &quot; extends &quot;.length());
290         List&lt;TypeDesc&gt; bounds = parseTypeDescs(splitOnTopLevelChars(rest, &#39;&amp;&#39;));
291         return new PubApiTypeParam(identifier, bounds);
292     }
293 
294     public Set&lt;Modifier&gt; parseModifiers(String modifiers) {
295         if (modifiers == null)
296             return Collections.emptySet();
297         return Stream.of(modifiers.split(&quot; &quot;))
298                      .map(String::trim)
299                      .map(StringUtils::toUpperCase)
300                      .filter(s -&gt; !s.isEmpty())
301                      .map(Modifier::valueOf)
302                      .collect(Collectors.toSet());
303     }
304 
305     // Find closing tag of the opening tag at the given &#39;pos&#39;.
306     private static int findClosingTag(String l, int pos) {
307         while (true) {
308             pos = pos + 1;
309             if (l.charAt(pos) == &#39;&gt;&#39;)
310                 return pos;
311             if (l.charAt(pos) == &#39;&lt;&#39;)
312                 pos = findClosingTag(l, pos);
313         }
314     }
315 
316     public List&lt;String&gt; splitOnTopLevelCommas(String s) {
317         return splitOnTopLevelChars(s, &#39;,&#39;);
318     }
319 
320     public static List&lt;String&gt; splitOnTopLevelChars(String s, char split) {
321         if (s.isEmpty())
322             return Collections.emptyList();
323         List&lt;String&gt; result = new ArrayList&lt;&gt;();
324         StringBuilder buf = new StringBuilder();
325         int depth = 0;
326         for (char c : s.toCharArray()) {
327             if (c == split &amp;&amp; depth == 0) {
328                 result.add(buf.toString().trim());
329                 buf = new StringBuilder();
330             } else {
331                 if (c == &#39;&lt;&#39;) depth++;
332                 if (c == &#39;&gt;&#39;) depth--;
333                 buf.append(c);
334             }
335         }
336         result.add(buf.toString().trim());
337         return result;
338     }
339 
340     public boolean isEmpty() {
341         return types.isEmpty() &amp;&amp; variables.isEmpty() &amp;&amp; methods.isEmpty();
342     }
343 
344     // Used for descriptive debug messages when figuring out what triggers
345     // recompilation.
346     public List&lt;String&gt; diff(PubApi prevApi) {
347         return diff(&quot;&quot;, prevApi);
348     }
349     private List&lt;String&gt; diff(String scopePrefix, PubApi prevApi) {
350 
351         List&lt;String&gt; diffs = new ArrayList&lt;&gt;();
352 
353         for (String typeKey : union(types.keySet(), prevApi.types.keySet())) {
354             PubType type = types.get(typeKey);
355             PubType prevType = prevApi.types.get(typeKey);
356             if (prevType == null) {
357                 diffs.add(&quot;Type &quot; + scopePrefix + typeKey + &quot; was added&quot;);
358             } else if (type == null) {
359                 diffs.add(&quot;Type &quot; + scopePrefix + typeKey + &quot; was removed&quot;);
360             } else {
361                 // Check modifiers
362                 if (!type.modifiers.equals(prevType.modifiers)) {
363                     diffs.add(&quot;Modifiers for type &quot; + scopePrefix + typeKey
364                             + &quot; changed from &quot; + prevType.modifiers + &quot; to &quot;
365                             + type.modifiers);
366                 }
367 
368                 // Recursively check types pub API
369                 diffs.addAll(type.pubApi.diff(prevType.pubApi));
370             }
371         }
372 
373         for (String varKey : union(variables.keySet(), prevApi.variables.keySet())) {
374             PubVar var = variables.get(varKey);
375             PubVar prevVar = prevApi.variables.get(varKey);
376             if (prevVar == null) {
377                 diffs.add(&quot;Variable &quot; + scopePrefix + varKey + &quot; was added&quot;);
378             } else if (var == null) {
379                 diffs.add(&quot;Variable &quot; + scopePrefix + varKey + &quot; was removed&quot;);
380             } else {
381                 if (!var.modifiers.equals(prevVar.modifiers)) {
382                     diffs.add(&quot;Modifiers for var &quot; + scopePrefix + varKey
383                             + &quot; changed from &quot; + prevVar.modifiers + &quot; to &quot;
384                             + var.modifiers);
385                 }
386                 if (!var.type.equals(prevVar.type)) {
387                     diffs.add(&quot;Type of &quot; + scopePrefix + varKey
388                             + &quot; changed from &quot; + prevVar.type + &quot; to &quot;
389                             + var.type);
390                 }
391                 if (!var.getConstValue().equals(prevVar.getConstValue())) {
392                     diffs.add(&quot;Const value of &quot; + scopePrefix + varKey
393                             + &quot; changed from &quot; + prevVar.getConstValue().orElse(&quot;&lt;none&gt;&quot;)
394                             + &quot; to &quot; + var.getConstValue().orElse(&quot;&lt;none&gt;&quot;));
395                 }
396             }
397         }
398 
399         for (String methodKey : union(methods.keySet(), prevApi.methods.keySet())) {
400             PubMethod method = methods.get(methodKey);
401             PubMethod prevMethod = prevApi.methods.get(methodKey);
402             if (prevMethod == null) {
403                 diffs.add(&quot;Method &quot; + scopePrefix + methodKey + &quot; was added&quot;);
404             } else if (method == null) {
405                 diffs.add(&quot;Method &quot; + scopePrefix + methodKey + &quot; was removed&quot;);
406             } else {
407                 if (!method.modifiers.equals(prevMethod.modifiers)) {
408                     diffs.add(&quot;Modifiers for method &quot; + scopePrefix + methodKey
409                             + &quot; changed from &quot; + prevMethod.modifiers + &quot; to &quot;
410                             + method.modifiers);
411                 }
412                 if (!method.typeParams.equals(prevMethod.typeParams)) {
413                     diffs.add(&quot;Type parameters for method &quot; + scopePrefix
414                             + methodKey + &quot; changed from &quot; + prevMethod.typeParams
415                             + &quot; to &quot; + method.typeParams);
416                 }
417                 if (!method.throwDecls.equals(prevMethod.throwDecls)) {
418                     diffs.add(&quot;Throw decl for method &quot; + scopePrefix + methodKey
419                             + &quot; changed from &quot; + prevMethod.throwDecls + &quot; to &quot;
420                             + &quot; to &quot; + method.throwDecls);
421                 }
422             }
423         }
424 
425         return diffs;
426     }
427 
428     public String toString() {
429         return String.format(&quot;%s[types: %s, variables: %s, methods: %s]&quot;,
430                              getClass().getSimpleName(),
431                              types.values(),
432                              variables.values(),
433                              methods.values());
434     }
435 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
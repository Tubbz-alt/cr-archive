<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.util.Iterator;
  29 
  30 import com.sun.source.tree.CaseTree;
  31 import com.sun.source.tree.ModuleTree.ModuleKind;
  32 import com.sun.tools.javac.code.*;
  33 import com.sun.tools.javac.code.Attribute.UnresolvedClass;
  34 import com.sun.tools.javac.code.Symbol.*;
  35 import com.sun.tools.javac.code.Type.*;
  36 import com.sun.tools.javac.util.*;
  37 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  38 
  39 import com.sun.tools.javac.tree.JCTree.*;
  40 
  41 import static com.sun.tools.javac.code.Flags.*;
  42 import static com.sun.tools.javac.code.Kinds.Kind.*;
  43 import static com.sun.tools.javac.code.TypeTag.*;
  44 
  45 /** Factory class for trees.
  46  *
  47  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  48  *  If you write code that depends on this, you do so at your own risk.
  49  *  This code and its internal interfaces are subject to change or
  50  *  deletion without notice.&lt;/b&gt;
  51  */
  52 public class TreeMaker implements JCTree.Factory {
  53 
  54     /** The context key for the tree factory. */
  55     protected static final Context.Key&lt;TreeMaker&gt; treeMakerKey = new Context.Key&lt;&gt;();
  56 
  57     /** Get the TreeMaker instance. */
  58     public static TreeMaker instance(Context context) {
  59         TreeMaker instance = context.get(treeMakerKey);
  60         if (instance == null)
  61             instance = new TreeMaker(context);
  62         return instance;
  63     }
  64 
  65     /** The position at which subsequent trees will be created.
  66      */
  67     public int pos = Position.NOPOS;
  68 
  69     /** The toplevel tree to which created trees belong.
  70      */
  71     public JCCompilationUnit toplevel;
  72 
  73     /** The current name table. */
  74     Names names;
  75 
  76     Types types;
  77 
  78     /** The current symbol table. */
  79     Symtab syms;
  80 
  81     /** Create a tree maker with null toplevel and NOPOS as initial position.
  82      */
  83     protected TreeMaker(Context context) {
  84         context.put(treeMakerKey, this);
  85         this.pos = Position.NOPOS;
  86         this.toplevel = null;
  87         this.names = Names.instance(context);
  88         this.syms = Symtab.instance(context);
  89         this.types = Types.instance(context);
  90     }
  91 
  92     /** Create a tree maker with a given toplevel and FIRSTPOS as initial position.
  93      */
  94     protected TreeMaker(JCCompilationUnit toplevel, Names names, Types types, Symtab syms) {
  95         this.pos = Position.FIRSTPOS;
  96         this.toplevel = toplevel;
  97         this.names = names;
  98         this.types = types;
  99         this.syms = syms;
 100     }
 101 
 102     /** Create a new tree maker for a given toplevel.
 103      */
 104     public TreeMaker forToplevel(JCCompilationUnit toplevel) {
 105         return new TreeMaker(toplevel, names, types, syms);
 106     }
 107 
 108     /** Reassign current position.
 109      */
 110     public TreeMaker at(int pos) {
 111         this.pos = pos;
 112         return this;
 113     }
 114 
 115     /** Reassign current position.
 116      */
 117     public TreeMaker at(DiagnosticPosition pos) {
 118         this.pos = (pos == null ? Position.NOPOS : pos.getStartPosition());
 119         return this;
 120     }
 121 
 122     /**
 123      * Create given tree node at current position.
 124      * @param defs a list of PackageDef, ClassDef, Import, and Skip
 125      */
 126     public JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs) {
 127         for (JCTree node : defs)
 128             Assert.check(node instanceof JCClassDecl
 129                 || node instanceof JCPackageDecl
 130                 || node instanceof JCImport
 131                 || node instanceof JCModuleDecl
 132                 || node instanceof JCSkip
 133                 || node instanceof JCErroneous
 134                 || (node instanceof JCExpressionStatement
 135                     &amp;&amp; ((JCExpressionStatement)node).expr instanceof JCErroneous),
 136                     () -&gt; node.getClass().getSimpleName());
 137         JCCompilationUnit tree = new JCCompilationUnit(defs);
 138         tree.pos = pos;
 139         return tree;
 140     }
 141 
 142     public JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
 143                                      JCExpression pid) {
 144         Assert.checkNonNull(annotations);
 145         Assert.checkNonNull(pid);
 146         JCPackageDecl tree = new JCPackageDecl(annotations, pid);
 147         tree.pos = pos;
 148         return tree;
 149     }
 150 
 151     public JCImport Import(JCTree qualid, boolean importStatic) {
 152         JCImport tree = new JCImport(qualid, importStatic);
 153         tree.pos = pos;
 154         return tree;
 155     }
 156 
 157     public JCClassDecl ClassDef(JCModifiers mods,
 158                                 Name name,
 159                                 List&lt;JCTypeParameter&gt; typarams,
 160                                 JCExpression extending,
 161                                 List&lt;JCExpression&gt; implementing,
 162                                 List&lt;JCTree&gt; defs)
 163     {
 164         JCClassDecl tree = new JCClassDecl(mods,
 165                                      name,
 166                                      typarams,
 167                                      extending,
 168                                      implementing,
 169                                      defs,
 170                                      null);
 171         tree.pos = pos;
 172         return tree;
 173     }
 174 
 175     public JCMethodDecl MethodDef(JCModifiers mods,
 176                                Name name,
 177                                JCExpression restype,
 178                                List&lt;JCTypeParameter&gt; typarams,
 179                                List&lt;JCVariableDecl&gt; params,
 180                                List&lt;JCExpression&gt; thrown,
 181                                JCBlock body,
 182                                JCExpression defaultValue) {
 183         return MethodDef(
 184                 mods, name, restype, typarams, null, params,
 185                 thrown, body, defaultValue);
 186     }
 187 
 188     public JCMethodDecl MethodDef(JCModifiers mods,
 189                                Name name,
 190                                JCExpression restype,
 191                                List&lt;JCTypeParameter&gt; typarams,
 192                                JCVariableDecl recvparam,
 193                                List&lt;JCVariableDecl&gt; params,
 194                                List&lt;JCExpression&gt; thrown,
 195                                JCBlock body,
 196                                JCExpression defaultValue)
 197     {
 198         JCMethodDecl tree = new JCMethodDecl(mods,
 199                                        name,
 200                                        restype,
 201                                        typarams,
 202                                        recvparam,
 203                                        params,
 204                                        thrown,
 205                                        body,
 206                                        defaultValue,
 207                                        null);
 208         tree.pos = pos;
 209         return tree;
 210     }
 211 
 212     public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init) {
 213         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null);
 214         tree.pos = pos;
 215         return tree;
 216     }
 217 
 218     public JCVariableDecl ReceiverVarDef(JCModifiers mods, JCExpression name, JCExpression vartype) {
 219         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype);
 220         tree.pos = pos;
 221         return tree;
 222     }
 223 
 224     public JCSkip Skip() {
 225         JCSkip tree = new JCSkip();
 226         tree.pos = pos;
 227         return tree;
 228     }
 229 
 230     public JCBlock Block(long flags, List&lt;JCStatement&gt; stats) {
 231         JCBlock tree = new JCBlock(flags, stats);
 232         tree.pos = pos;
 233         return tree;
 234     }
 235 
 236     public JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond) {
 237         JCDoWhileLoop tree = new JCDoWhileLoop(body, cond);
 238         tree.pos = pos;
 239         return tree;
 240     }
 241 
 242     public JCWhileLoop WhileLoop(JCExpression cond, JCStatement body) {
 243         JCWhileLoop tree = new JCWhileLoop(cond, body);
 244         tree.pos = pos;
 245         return tree;
 246     }
 247 
 248     public JCForLoop ForLoop(List&lt;JCStatement&gt; init,
 249                            JCExpression cond,
 250                            List&lt;JCExpressionStatement&gt; step,
 251                            JCStatement body)
 252     {
 253         JCForLoop tree = new JCForLoop(init, cond, step, body);
 254         tree.pos = pos;
 255         return tree;
 256     }
 257 
 258     public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
 259         JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);
 260         tree.pos = pos;
 261         return tree;
 262     }
 263 
 264     public JCLabeledStatement Labelled(Name label, JCStatement body) {
 265         JCLabeledStatement tree = new JCLabeledStatement(label, body);
 266         tree.pos = pos;
 267         return tree;
 268     }
 269 
 270     public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases) {
 271         JCSwitch tree = new JCSwitch(selector, cases);
 272         tree.pos = pos;
 273         return tree;
 274     }
 275 
 276     public JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pats,
 277                        List&lt;JCStatement&gt; stats, JCTree body) {
 278         JCCase tree = new JCCase(caseKind, pats, stats, body);
 279         tree.pos = pos;
 280         return tree;
 281     }
 282 
 283     public JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
 284         JCSwitchExpression tree = new JCSwitchExpression(selector, cases);
 285         tree.pos = pos;
 286         return tree;
 287     }
 288 
 289     public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {
 290         JCSynchronized tree = new JCSynchronized(lock, body);
 291         tree.pos = pos;
 292         return tree;
 293     }
 294 
 295     public JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer) {
 296         return Try(List.nil(), body, catchers, finalizer);
 297     }
 298 
 299     public JCTry Try(List&lt;JCTree&gt; resources,
 300                      JCBlock body,
 301                      List&lt;JCCatch&gt; catchers,
 302                      JCBlock finalizer) {
 303         JCTry tree = new JCTry(resources, body, catchers, finalizer);
 304         tree.pos = pos;
 305         return tree;
 306     }
 307 
 308     public JCCatch Catch(JCVariableDecl param, JCBlock body) {
 309         JCCatch tree = new JCCatch(param, body);
 310         tree.pos = pos;
 311         return tree;
 312     }
 313 
 314     public JCConditional Conditional(JCExpression cond,
 315                                    JCExpression thenpart,
 316                                    JCExpression elsepart)
 317     {
 318         JCConditional tree = new JCConditional(cond, thenpart, elsepart);
 319         tree.pos = pos;
 320         return tree;
 321     }
 322 
 323     public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {
 324         JCIf tree = new JCIf(cond, thenpart, elsepart);
 325         tree.pos = pos;
 326         return tree;
 327     }
 328 
 329     public JCExpressionStatement Exec(JCExpression expr) {
 330         JCExpressionStatement tree = new JCExpressionStatement(expr);
 331         tree.pos = pos;
 332         return tree;
 333     }
 334 
 335     public JCBreak Break(Name label) {
 336         JCBreak tree = new JCBreak(label, null);
 337         tree.pos = pos;
 338         return tree;
 339     }
 340 
 341     public JCYield Yield(JCExpression value) {
 342         JCYield tree = new JCYield(value, null);
 343         tree.pos = pos;
 344         return tree;
 345     }
 346 
 347     public JCContinue Continue(Name label) {
 348         JCContinue tree = new JCContinue(label, null);
 349         tree.pos = pos;
 350         return tree;
 351     }
 352 
 353     public JCReturn Return(JCExpression expr) {
 354         JCReturn tree = new JCReturn(expr);
 355         tree.pos = pos;
 356         return tree;
 357     }
 358 
 359     public JCThrow Throw(JCExpression expr) {
 360         JCThrow tree = new JCThrow(expr);
 361         tree.pos = pos;
 362         return tree;
 363     }
 364 
 365     public JCAssert Assert(JCExpression cond, JCExpression detail) {
 366         JCAssert tree = new JCAssert(cond, detail);
 367         tree.pos = pos;
 368         return tree;
 369     }
 370 
 371     public JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
 372                        JCExpression fn,
 373                        List&lt;JCExpression&gt; args)
 374     {
 375         JCMethodInvocation tree = new JCMethodInvocation(typeargs, fn, args);
 376         tree.pos = pos;
 377         return tree;
 378     }
 379 
 380     public JCNewClass NewClass(JCExpression encl,
 381                              List&lt;JCExpression&gt; typeargs,
 382                              JCExpression clazz,
 383                              List&lt;JCExpression&gt; args,
 384                              JCClassDecl def)
 385     {
 386         return SpeculativeNewClass(encl, typeargs, clazz, args, def, false);
 387     }
 388 
 389     public JCNewClass SpeculativeNewClass(JCExpression encl,
 390                              List&lt;JCExpression&gt; typeargs,
 391                              JCExpression clazz,
 392                              List&lt;JCExpression&gt; args,
 393                              JCClassDecl def,
 394                              boolean classDefRemoved)
 395     {
 396         JCNewClass tree = classDefRemoved ?
 397                 new JCNewClass(encl, typeargs, clazz, args, def) {
 398                     @Override
 399                     public boolean classDeclRemoved() {
 400                         return true;
 401                     }
 402                 } :
 403                 new JCNewClass(encl, typeargs, clazz, args, def);
 404         tree.pos = pos;
 405         return tree;
 406     }
 407 
 408     public JCNewArray NewArray(JCExpression elemtype,
 409                              List&lt;JCExpression&gt; dims,
 410                              List&lt;JCExpression&gt; elems)
 411     {
 412         JCNewArray tree = new JCNewArray(elemtype, dims, elems);
 413         tree.pos = pos;
 414         return tree;
 415     }
 416 
 417     public JCLambda Lambda(List&lt;JCVariableDecl&gt; params,
 418                            JCTree body)
 419     {
 420         JCLambda tree = new JCLambda(params, body);
 421         tree.pos = pos;
 422         return tree;
 423     }
 424 
 425     public JCParens Parens(JCExpression expr) {
 426         JCParens tree = new JCParens(expr);
 427         tree.pos = pos;
 428         return tree;
 429     }
 430 
 431     public JCAssign Assign(JCExpression lhs, JCExpression rhs) {
 432         JCAssign tree = new JCAssign(lhs, rhs);
 433         tree.pos = pos;
 434         return tree;
 435     }
 436 
 437     public JCAssignOp Assignop(JCTree.Tag opcode, JCTree lhs, JCTree rhs) {
 438         JCAssignOp tree = new JCAssignOp(opcode, lhs, rhs, null);
 439         tree.pos = pos;
 440         return tree;
 441     }
 442 
 443     public JCUnary Unary(JCTree.Tag opcode, JCExpression arg) {
 444         JCUnary tree = new JCUnary(opcode, arg);
 445         tree.pos = pos;
 446         return tree;
 447     }
 448 
 449     public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs) {
 450         JCBinary tree = new JCBinary(opcode, lhs, rhs, null);
 451         tree.pos = pos;
 452         return tree;
 453     }
 454 
 455     public JCTypeCast TypeCast(JCTree clazz, JCExpression expr) {
 456         JCTypeCast tree = new JCTypeCast(clazz, expr);
 457         tree.pos = pos;
 458         return tree;
 459     }
 460 
 461     public JCInstanceOf TypeTest(JCExpression expr, JCTree clazz) {
 462         JCInstanceOf tree = new JCInstanceOf(expr, clazz);
 463         tree.pos = pos;
 464         return tree;
 465     }
 466 
 467     public JCBindingPattern BindingPattern(Name name, JCTree vartype) {
 468         JCBindingPattern tree = new JCBindingPattern(name, null, vartype);
 469         tree.pos = pos;
 470         return tree;
 471     }
 472 
 473     public JCArrayAccess Indexed(JCExpression indexed, JCExpression index) {
 474         JCArrayAccess tree = new JCArrayAccess(indexed, index);
 475         tree.pos = pos;
 476         return tree;
 477     }
 478 
 479     public JCFieldAccess Select(JCExpression selected, Name selector) {
 480         JCFieldAccess tree = new JCFieldAccess(selected, selector, null);
 481         tree.pos = pos;
 482         return tree;
 483     }
 484 
 485     public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name,
 486             JCExpression expr, List&lt;JCExpression&gt; typeargs) {
 487         JCMemberReference tree = new JCMemberReference(mode, name, expr, typeargs);
 488         tree.pos = pos;
 489         return tree;
 490     }
 491 
 492     public JCIdent Ident(Name name) {
 493         JCIdent tree = new JCIdent(name, null);
 494         tree.pos = pos;
 495         return tree;
 496     }
 497 
 498     public JCLiteral Literal(TypeTag tag, Object value) {
 499         JCLiteral tree = new JCLiteral(tag, value);
 500         tree.pos = pos;
 501         return tree;
 502     }
 503 
 504     public JCPrimitiveTypeTree TypeIdent(TypeTag typetag) {
 505         JCPrimitiveTypeTree tree = new JCPrimitiveTypeTree(typetag);
 506         tree.pos = pos;
 507         return tree;
 508     }
 509 
 510     public JCArrayTypeTree TypeArray(JCExpression elemtype) {
 511         JCArrayTypeTree tree = new JCArrayTypeTree(elemtype);
 512         tree.pos = pos;
 513         return tree;
 514     }
 515 
 516     public JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
 517         JCTypeApply tree = new JCTypeApply(clazz, arguments);
 518         tree.pos = pos;
 519         return tree;
 520     }
 521 
 522     public JCTypeUnion TypeUnion(List&lt;JCExpression&gt; components) {
 523         JCTypeUnion tree = new JCTypeUnion(components);
 524         tree.pos = pos;
 525         return tree;
 526     }
 527 
 528     public JCTypeIntersection TypeIntersection(List&lt;JCExpression&gt; components) {
 529         JCTypeIntersection tree = new JCTypeIntersection(components);
 530         tree.pos = pos;
 531         return tree;
 532     }
 533 
 534     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds) {
 535         return TypeParameter(name, bounds, List.nil());
 536     }
 537 
 538     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annos) {
 539         JCTypeParameter tree = new JCTypeParameter(name, bounds, annos);
 540         tree.pos = pos;
 541         return tree;
 542     }
 543 
 544     public JCWildcard Wildcard(TypeBoundKind kind, JCTree type) {
 545         JCWildcard tree = new JCWildcard(kind, type);
 546         tree.pos = pos;
 547         return tree;
 548     }
 549 
 550     public TypeBoundKind TypeBoundKind(BoundKind kind) {
 551         TypeBoundKind tree = new TypeBoundKind(kind);
 552         tree.pos = pos;
 553         return tree;
 554     }
 555 
 556     public JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 557         JCAnnotation tree = new JCAnnotation(Tag.ANNOTATION, annotationType, args);
 558         tree.pos = pos;
 559         return tree;
 560     }
 561 
 562     public JCAnnotation TypeAnnotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 563         JCAnnotation tree = new JCAnnotation(Tag.TYPE_ANNOTATION, annotationType, args);
 564         tree.pos = pos;
 565         return tree;
 566     }
 567 
 568     public JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
 569         JCModifiers tree = new JCModifiers(flags, annotations);
 570         boolean noFlags = (flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0;
 571         tree.pos = (noFlags &amp;&amp; annotations.isEmpty()) ? Position.NOPOS : pos;
 572         return tree;
 573     }
 574 
 575     public JCModifiers Modifiers(long flags) {
 576         return Modifiers(flags, List.nil());
 577     }
 578 
 579     @Override
 580     public JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind,
 581             JCExpression qualid, List&lt;JCDirective&gt; directives) {
 582         JCModuleDecl tree = new JCModuleDecl(mods, kind, qualid, directives);
 583         tree.pos = pos;
 584         return tree;
 585     }
 586 
 587     @Override
 588     public JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 589         JCExports tree = new JCExports(qualId, moduleNames);
 590         tree.pos = pos;
 591         return tree;
 592     }
 593 
 594     @Override
 595     public JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 596         JCOpens tree = new JCOpens(qualId, moduleNames);
 597         tree.pos = pos;
 598         return tree;
 599     }
 600 
 601     @Override
 602     public JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
 603         JCProvides tree = new JCProvides(serviceName, implNames);
 604         tree.pos = pos;
 605         return tree;
 606     }
 607 
 608     @Override
 609     public JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId) {
 610         JCRequires tree = new JCRequires(isTransitive, isStaticPhase, qualId);
 611         tree.pos = pos;
 612         return tree;
 613     }
 614 
 615     @Override
 616     public JCUses Uses(JCExpression qualId) {
 617         JCUses tree = new JCUses(qualId);
 618         tree.pos = pos;
 619         return tree;
 620     }
 621 
 622     public JCAnnotatedType AnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
 623         JCAnnotatedType tree = new JCAnnotatedType(annotations, underlyingType);
 624         tree.pos = pos;
 625         return tree;
 626     }
 627 
 628     public JCErroneous Erroneous() {
 629         return Erroneous(List.nil());
 630     }
 631 
 632     public JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs) {
 633         JCErroneous tree = new JCErroneous(errs);
 634         tree.pos = pos;
 635         return tree;
 636     }
 637 
 638     public LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {
 639         LetExpr tree = new LetExpr(defs, expr);
 640         tree.pos = pos;
 641         return tree;
 642     }
 643 
 644 /* ***************************************************************************
 645  * Derived building blocks.
 646  ****************************************************************************/
 647 
 648     public JCClassDecl AnonymousClassDef(JCModifiers mods,
 649                                          List&lt;JCTree&gt; defs)
 650     {
 651         return ClassDef(mods,
 652                         names.empty,
 653                         List.nil(),
 654                         null,
 655                         List.nil(),
 656                         defs);
 657     }
 658 
 659     public LetExpr LetExpr(JCVariableDecl def, JCExpression expr) {
 660         LetExpr tree = new LetExpr(List.of(def), expr);
 661         tree.pos = pos;
 662         return tree;
 663     }
 664 
 665     /** Create an identifier from a symbol.
 666      */
 667     public JCIdent Ident(Symbol sym) {
 668         return (JCIdent)new JCIdent((sym.name != names.empty)
 669                                 ? sym.name
 670                                 : sym.flatName(), sym)
 671             .setPos(pos)
 672             .setType(sym.type);
 673     }
 674 
 675     /** Create a selection node from a qualifier tree and a symbol.
 676      *  @param base   The qualifier tree.
 677      */
 678     public JCExpression Select(JCExpression base, Symbol sym) {
 679         return new JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);
 680     }
 681 
 682     /** Create a qualified identifier from a symbol, adding enough qualifications
 683      *  to make the reference unique.
 684      */
 685     public JCExpression QualIdent(Symbol sym) {
 686         return isUnqualifiable(sym)
 687             ? Ident(sym)
 688             : Select(QualIdent(sym.owner), sym);
 689     }
 690 
 691     /** Create an identifier that refers to the variable declared in given variable
 692      *  declaration.
 693      */
 694     public JCExpression Ident(JCVariableDecl param) {
 695         return Ident(param.sym);
 696     }
 697 
 698     /** Create a list of identifiers referring to the variables declared
 699      *  in given list of variable declarations.
 700      */
 701     public List&lt;JCExpression&gt; Idents(List&lt;JCVariableDecl&gt; params) {
 702         ListBuffer&lt;JCExpression&gt; ids = new ListBuffer&lt;&gt;();
 703         for (List&lt;JCVariableDecl&gt; l = params; l.nonEmpty(); l = l.tail)
 704             ids.append(Ident(l.head));
 705         return ids.toList();
 706     }
 707 
 708     /** Create a tree representing `this&#39;, given its type.
 709      */
 710     public JCExpression This(Type t) {
 711         return Ident(new VarSymbol(FINAL, names._this, t, t.tsym));
 712     }
 713 
 714     /** Create a tree representing qualified `this&#39; given its type
 715      */
 716     public JCExpression QualThis(Type t) {
 717         return Select(Type(t), new VarSymbol(FINAL, names._this, t, t.tsym));
 718     }
 719 
 720     /** Create a tree representing a class literal.
 721      */
 722     public JCExpression ClassLiteral(ClassSymbol clazz) {
 723         return ClassLiteral(clazz.type);
 724     }
 725 
 726     /** Create a tree representing a class literal.
 727      */
 728     public JCExpression ClassLiteral(Type t) {
 729         VarSymbol lit = new VarSymbol(STATIC | PUBLIC | FINAL,
 730                                       names._class,
 731                                       t,
 732                                       t.tsym);
 733         return Select(Type(t), lit);
 734     }
 735 
 736     /** Create a tree representing `super&#39;, given its type and owner.
 737      */
 738     public JCIdent Super(Type t, TypeSymbol owner) {
 739         return Ident(new VarSymbol(FINAL, names._super, t, owner));
 740     }
 741 
 742     /**
 743      * Create a method invocation from a method tree and a list of
 744      * argument trees.
 745      */
 746     public JCMethodInvocation App(JCExpression meth, List&lt;JCExpression&gt; args) {
 747         return Apply(null, meth, args).setType(meth.type.getReturnType());
 748     }
 749 
 750     /**
 751      * Create a no-arg method invocation from a method tree
 752      */
 753     public JCMethodInvocation App(JCExpression meth) {
 754         return Apply(null, meth, List.nil()).setType(meth.type.getReturnType());
 755     }
 756 
 757     /** Create a method invocation from a method tree and a list of argument trees.
 758      */
 759     public JCExpression Create(Symbol ctor, List&lt;JCExpression&gt; args) {
 760         Type t = ctor.owner.erasure(types);
 761         JCNewClass newclass = NewClass(null, null, Type(t), args, null);
 762         newclass.constructor = ctor;
 763         newclass.setType(t);
 764         return newclass;
 765     }
 766 
 767     /** Create a tree representing given type.
 768      */
 769     public JCExpression Type(Type t) {
 770         if (t == null) return null;
 771         JCExpression tp;
 772         switch (t.getTag()) {
 773         case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
 774         case DOUBLE: case BOOLEAN: case VOID:
 775             tp = TypeIdent(t.getTag());
 776             break;
 777         case TYPEVAR:
 778             tp = Ident(t.tsym);
 779             break;
 780         case WILDCARD: {
 781             WildcardType a = ((WildcardType) t);
 782             tp = Wildcard(TypeBoundKind(a.kind), a.kind == BoundKind.UNBOUND ? null : Type(a.type));
 783             break;
 784         }
 785         case CLASS:
 786             switch (t.getKind()) {
 787             case UNION: {
 788                 UnionClassType tu = (UnionClassType)t;
 789                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 790                 for (Type ta : tu.getAlternativeTypes()) {
 791                     la.add(Type(ta));
 792                 }
 793                 tp = TypeUnion(la.toList());
 794                 break;
 795             }
 796             case INTERSECTION: {
 797                 IntersectionClassType it = (IntersectionClassType)t;
 798                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 799                 for (Type ta : it.getExplicitComponents()) {
 800                     la.add(Type(ta));
 801                 }
 802                 tp = TypeIntersection(la.toList());
 803                 break;
 804             }
 805             default: {
 806                 Type outer = t.getEnclosingType();
 807                 JCExpression clazz = outer.hasTag(CLASS) &amp;&amp; t.tsym.owner.kind == TYP
 808                         ? Select(Type(outer), t.tsym)
 809                         : QualIdent(t.tsym);
 810                 tp = t.getTypeArguments().isEmpty()
 811                         ? clazz
 812                         : TypeApply(clazz, Types(t.getTypeArguments()));
 813                 break;
 814             }
 815             }
 816             break;
 817         case ARRAY:
 818             tp = TypeArray(Type(types.elemtype(t)));
 819             break;
 820         case ERROR:
 821             tp = TypeIdent(ERROR);
 822             break;
 823         default:
 824             throw new AssertionError(&quot;unexpected type: &quot; + t);
 825         }
 826         return tp.setType(t);
 827     }
 828 
 829     /** Create a list of trees representing given list of types.
 830      */
 831     public List&lt;JCExpression&gt; Types(List&lt;Type&gt; ts) {
 832         ListBuffer&lt;JCExpression&gt; lb = new ListBuffer&lt;&gt;();
 833         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 834             lb.append(Type(l.head));
 835         return lb.toList();
 836     }
 837 
 838     /** Create a variable definition from a variable symbol and an initializer
 839      *  expression.
 840      */
 841     public JCVariableDecl VarDef(VarSymbol v, JCExpression init) {
 842         return (JCVariableDecl)
 843             new JCVariableDecl(
 844                 Modifiers(v.flags(), Annotations(v.getRawAttributes())),
 845                 v.name,
 846                 Type(v.type),
 847                 init,
 848                 v).setPos(pos).setType(v.type);
 849     }
 850 
 851     /** Create annotation trees from annotations.
 852      */
 853     public List&lt;JCAnnotation&gt; Annotations(List&lt;Attribute.Compound&gt; attributes) {
 854         if (attributes == null) return List.nil();
 855         ListBuffer&lt;JCAnnotation&gt; result = new ListBuffer&lt;&gt;();
 856         for (List&lt;Attribute.Compound&gt; i = attributes; i.nonEmpty(); i=i.tail) {
 857             Attribute a = i.head;
 858             result.append(Annotation(a));
 859         }
 860         return result.toList();
 861     }
 862 
 863     public JCLiteral Literal(Object value) {
 864         JCLiteral result = null;
 865         if (value instanceof String) {
 866             result = Literal(CLASS, value).
 867                 setType(syms.stringType.constType(value));
 868         } else if (value instanceof Integer) {
 869             result = Literal(INT, value).
 870                 setType(syms.intType.constType(value));
 871         } else if (value instanceof Long) {
 872             result = Literal(LONG, value).
 873                 setType(syms.longType.constType(value));
 874         } else if (value instanceof Byte) {
 875             result = Literal(BYTE, value).
 876                 setType(syms.byteType.constType(value));
 877         } else if (value instanceof Character) {
 878             int v = (int) (((Character) value).toString().charAt(0));
 879             result = Literal(CHAR, v).
 880                 setType(syms.charType.constType(v));
 881         } else if (value instanceof Double) {
 882             result = Literal(DOUBLE, value).
 883                 setType(syms.doubleType.constType(value));
 884         } else if (value instanceof Float) {
 885             result = Literal(FLOAT, value).
 886                 setType(syms.floatType.constType(value));
 887         } else if (value instanceof Short) {
 888             result = Literal(SHORT, value).
 889                 setType(syms.shortType.constType(value));
 890         } else if (value instanceof Boolean) {
 891             int v = ((Boolean) value) ? 1 : 0;
 892             result = Literal(BOOLEAN, v).
 893                 setType(syms.booleanType.constType(v));
 894         } else {
 895             throw new AssertionError(value);
 896         }
 897         return result;
 898     }
 899 
 900     class AnnotationBuilder implements Attribute.Visitor {
 901         JCExpression result = null;
 902         public void visitConstant(Attribute.Constant v) {
 903             result = Literal(v.type.getTag(), v.value);
 904         }
 905         public void visitClass(Attribute.Class clazz) {
 906             result = ClassLiteral(clazz.classType).setType(syms.classType);
 907         }
 908         public void visitEnum(Attribute.Enum e) {
 909             result = QualIdent(e.value);
 910         }
 911         public void visitError(Attribute.Error e) {
 912             if (e instanceof UnresolvedClass) {
 913                 result = ClassLiteral(((UnresolvedClass) e).classType).setType(syms.classType);
 914             } else {
 915                 result = Erroneous();
 916             }
 917         }
 918         public void visitCompound(Attribute.Compound compound) {
 919             if (compound instanceof Attribute.TypeCompound) {
 920                 result = visitTypeCompoundInternal((Attribute.TypeCompound) compound);
 921             } else {
 922                 result = visitCompoundInternal(compound);
 923             }
 924         }
 925         public JCAnnotation visitCompoundInternal(Attribute.Compound compound) {
 926             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 927             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 928                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 929                 JCExpression valueTree = translate(pair.snd);
 930                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 931             }
 932             return Annotation(Type(compound.type), args.toList());
 933         }
 934         public JCAnnotation visitTypeCompoundInternal(Attribute.TypeCompound compound) {
 935             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 936             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 937                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 938                 JCExpression valueTree = translate(pair.snd);
 939                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 940             }
 941             return TypeAnnotation(Type(compound.type), args.toList());
 942         }
 943         public void visitArray(Attribute.Array array) {
 944             ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
 945             for (int i = 0; i &lt; array.values.length; i++)
 946                 elems.append(translate(array.values[i]));
 947             result = NewArray(null, List.nil(), elems.toList()).setType(array.type);
 948         }
 949         JCExpression translate(Attribute a) {
 950             a.accept(this);
 951             return result;
 952         }
 953         JCAnnotation translate(Attribute.Compound a) {
 954             return visitCompoundInternal(a);
 955         }
 956         JCAnnotation translate(Attribute.TypeCompound a) {
 957             return visitTypeCompoundInternal(a);
 958         }
 959     }
 960 
 961     AnnotationBuilder annotationBuilder = new AnnotationBuilder();
 962 
 963     /** Create an annotation tree from an attribute.
 964      */
 965     public JCAnnotation Annotation(Attribute a) {
 966         return annotationBuilder.translate((Attribute.Compound)a);
 967     }
 968 
 969     public JCAnnotation TypeAnnotation(Attribute a) {
 970         return annotationBuilder.translate((Attribute.TypeCompound) a);
 971     }
 972 
 973     /** Create a method definition from a method symbol and a method body.
 974      */
 975     public JCMethodDecl MethodDef(MethodSymbol m, JCBlock body) {
 976         return MethodDef(m, m.type, body);
 977     }
 978 
 979     /** Create a method definition from a method symbol, method type
 980      *  and a method body.
 981      */
 982     public JCMethodDecl MethodDef(MethodSymbol m, Type mtype, JCBlock body) {
 983         return (JCMethodDecl)
 984             new JCMethodDecl(
 985                 Modifiers(m.flags(), Annotations(m.getRawAttributes())),
 986                 m.name,
 987                 Type(mtype.getReturnType()),
 988                 TypeParams(mtype.getTypeArguments()),
 989                 null, // receiver type
 990                 Params(mtype.getParameterTypes(), m),
 991                 Types(mtype.getThrownTypes()),
 992                 body,
 993                 null,
 994                 m).setPos(pos).setType(mtype);
 995     }
 996 
 997     /** Create a type parameter tree from its name and type.
 998      */
 999     public JCTypeParameter TypeParam(Name name, TypeVar tvar) {
1000         return (JCTypeParameter)
1001             TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);
1002     }
1003 
1004     /** Create a list of type parameter trees from a list of type variables.
1005      */
1006     public List&lt;JCTypeParameter&gt; TypeParams(List&lt;Type&gt; typarams) {
1007         ListBuffer&lt;JCTypeParameter&gt; tparams = new ListBuffer&lt;&gt;();
1008         for (List&lt;Type&gt; l = typarams; l.nonEmpty(); l = l.tail)
1009             tparams.append(TypeParam(l.head.tsym.name, (TypeVar)l.head));
1010         return tparams.toList();
1011     }
1012 
1013     /** Create a value parameter tree from its name, type, and owner.
1014      */
1015     public JCVariableDecl Param(Name name, Type argtype, Symbol owner) {
1016         return VarDef(new VarSymbol(PARAMETER, name, argtype, owner), null);
1017     }
1018 
1019     /** Create a a list of value parameter trees x0, ..., xn from a list of
1020      *  their types and an their owner.
1021      */
1022     public List&lt;JCVariableDecl&gt; Params(List&lt;Type&gt; argtypes, Symbol owner) {
1023         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
1024         MethodSymbol mth = (owner.kind == MTH) ? ((MethodSymbol)owner) : null;
1025         if (mth != null &amp;&amp; mth.params != null &amp;&amp; argtypes.length() == mth.params.length()) {
1026             for (VarSymbol param : ((MethodSymbol)owner).params)
1027                 params.append(VarDef(param, null));
1028         } else {
1029             int i = 0;
1030             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1031                 params.append(Param(paramName(i++), l.head, owner));
1032         }
1033         return params.toList();
1034     }
1035 
1036     /** Wrap a method invocation in an expression statement or return statement,
1037      *  depending on whether the method invocation expression&#39;s type is void.
1038      */
1039     public JCStatement Call(JCExpression apply) {
1040         return apply.type.hasTag(VOID) ? Exec(apply) : Return(apply);
1041     }
1042 
1043     /** Construct an assignment from a variable symbol and a right hand side.
1044      */
1045     public JCStatement Assignment(Symbol v, JCExpression rhs) {
1046         return Exec(Assign(Ident(v), rhs).setType(v.type));
1047     }
1048 
1049     /** Construct an index expression from a variable and an expression.
1050      */
1051     public JCArrayAccess Indexed(Symbol v, JCExpression index) {
1052         JCArrayAccess tree = new JCArrayAccess(QualIdent(v), index);
1053         tree.type = ((ArrayType)v.type).elemtype;
1054         return tree;
1055     }
1056 
1057     /** Make an attributed type cast expression.
1058      */
1059     public JCTypeCast TypeCast(Type type, JCExpression expr) {
1060         return (JCTypeCast)TypeCast(Type(type), expr).setType(type);
1061     }
1062 
1063 /* ***************************************************************************
1064  * Helper methods.
1065  ****************************************************************************/
1066 
1067     /** Can given symbol be referred to in unqualified form?
1068      */
1069     boolean isUnqualifiable(Symbol sym) {
1070         if (sym.name == names.empty ||
1071             sym.owner == null ||
1072             sym.owner == syms.rootPackage ||
1073             sym.owner.kind == MTH || sym.owner.kind == VAR) {
1074             return true;
1075         } else if (sym.kind == TYP &amp;&amp; toplevel != null) {
1076             Iterator&lt;Symbol&gt; it = toplevel.namedImportScope.getSymbolsByName(sym.name).iterator();
1077             if (it.hasNext()) {
1078                 Symbol s = it.next();
1079                 return
1080                   s == sym &amp;&amp;
1081                   !it.hasNext();
1082             }
1083             it = toplevel.packge.members().getSymbolsByName(sym.name).iterator();
1084             if (it.hasNext()) {
1085                 Symbol s = it.next();
1086                 return
1087                   s == sym &amp;&amp;
1088                   !it.hasNext();
1089             }
1090             it = toplevel.starImportScope.getSymbolsByName(sym.name).iterator();
1091             if (it.hasNext()) {
1092                 Symbol s = it.next();
1093                 return
1094                   s == sym &amp;&amp;
1095                   !it.hasNext();
1096             }
1097         }
1098         return false;
1099     }
1100 
1101     /** The name of synthetic parameter number `i&#39;.
1102      */
1103     public Name paramName(int i)   { return names.fromString(&quot;x&quot; + i); }
1104 
1105     /** The name of synthetic type parameter number `i&#39;.
1106      */
1107     public Name typaramName(int i) { return names.fromString(&quot;A&quot; + i); }
1108 }
    </pre>
  </body>
</html>
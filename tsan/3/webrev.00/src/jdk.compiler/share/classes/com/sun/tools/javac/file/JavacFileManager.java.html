<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/file/JavacFileManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.file;
  27 
  28 import java.io.File;
  29 import java.io.IOException;
  30 import java.io.UncheckedIOException;
  31 import java.lang.module.Configuration;
  32 import java.lang.module.ModuleFinder;
  33 import java.net.MalformedURLException;
  34 import java.net.URI;
  35 import java.net.URISyntaxException;
  36 import java.net.URL;
  37 import java.nio.CharBuffer;
  38 import java.nio.charset.Charset;
  39 import java.nio.file.FileSystem;
  40 import java.nio.file.FileSystems;
  41 import java.nio.file.FileVisitOption;
  42 import java.nio.file.FileVisitResult;
  43 import java.nio.file.Files;
  44 import java.nio.file.InvalidPathException;
  45 import java.nio.file.LinkOption;
  46 import java.nio.file.Path;
  47 import java.nio.file.Paths;
  48 import java.nio.file.ProviderNotFoundException;
  49 import java.nio.file.SimpleFileVisitor;
  50 import java.nio.file.attribute.BasicFileAttributes;
  51 import java.nio.file.spi.FileSystemProvider;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.Collection;
  55 import java.util.Collections;
  56 import java.util.Comparator;
  57 import java.util.EnumSet;
  58 import java.util.HashMap;
  59 import java.util.Iterator;
  60 import java.util.Map;
  61 import java.util.Objects;
  62 import java.util.ServiceLoader;
  63 import java.util.Set;
  64 import java.util.stream.Collectors;
  65 import java.util.stream.Stream;
  66 
  67 import javax.lang.model.SourceVersion;
  68 import javax.tools.FileObject;
  69 import javax.tools.JavaFileManager;
  70 import javax.tools.JavaFileObject;
  71 import javax.tools.StandardJavaFileManager;
  72 
  73 import com.sun.tools.javac.file.RelativePath.RelativeDirectory;
  74 import com.sun.tools.javac.file.RelativePath.RelativeFile;
  75 import com.sun.tools.javac.main.Option;
  76 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  77 import com.sun.tools.javac.util.Assert;
  78 import com.sun.tools.javac.util.Context;
  79 import com.sun.tools.javac.util.Context.Factory;
  80 import com.sun.tools.javac.util.DefinedBy;
  81 import com.sun.tools.javac.util.DefinedBy.Api;
  82 import com.sun.tools.javac.util.List;
  83 import com.sun.tools.javac.util.ListBuffer;
  84 
  85 import static java.nio.file.FileVisitOption.FOLLOW_LINKS;
  86 
  87 import static javax.tools.StandardLocation.*;
  88 
  89 /**
  90  * This class provides access to the source, class and other files
  91  * used by the compiler and related tools.
  92  *
  93  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  94  * If you write code that depends on this, you do so at your own risk.
  95  * This code and its internal interfaces are subject to change or
  96  * deletion without notice.&lt;/b&gt;
  97  */
  98 public class JavacFileManager extends BaseFileManager implements StandardJavaFileManager {
  99 
 100     public static char[] toArray(CharBuffer buffer) {
 101         if (buffer.hasArray())
 102             return buffer.compact().flip().array();
 103         else
 104             return buffer.toString().toCharArray();
 105     }
 106 
 107     private FSInfo fsInfo;
 108 
 109     private static final Set&lt;JavaFileObject.Kind&gt; SOURCE_OR_CLASS =
 110         Set.of(JavaFileObject.Kind.SOURCE, JavaFileObject.Kind.CLASS);
 111 
 112     protected boolean symbolFileEnabled;
 113 
 114     private PathFactory pathFactory = Paths::get;
 115 
 116     protected enum SortFiles implements Comparator&lt;Path&gt; {
 117         FORWARD {
 118             @Override
 119             public int compare(Path f1, Path f2) {
 120                 return f1.getFileName().compareTo(f2.getFileName());
 121             }
 122         },
 123         REVERSE {
 124             @Override
 125             public int compare(Path f1, Path f2) {
 126                 return -f1.getFileName().compareTo(f2.getFileName());
 127             }
 128         }
 129     }
 130 
 131     protected SortFiles sortFiles;
 132 
 133     /**
 134      * We use a two-layered map instead of a map with a complex key because we don&#39;t want to reindex
 135      * the values for every Location+RelativeDirectory pair. Once the PathsAndContainers are needed
 136      * for a single Location, we should know all valid RelativeDirectory mappings. Because the
 137      * indexing is costly for very large classpaths, this can result in a significant savings.
 138      */
 139     private Map&lt;Location, Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt;&gt;
 140         pathsAndContainersByLocationAndRelativeDirectory = new HashMap&lt;&gt;();
 141 
 142     /** Containers that have no indexing by {@link RelativeDirectory}, keyed by {@link Location}. */
 143     private Map&lt;Location, java.util.List&lt;PathAndContainer&gt;&gt; nonIndexingContainersByLocation =
 144         new HashMap&lt;&gt;();
 145 
 146     /**
 147      * Register a Context.Factory to create a JavacFileManager.
 148      */
 149     public static void preRegister(Context context) {
 150         context.put(JavaFileManager.class,
 151                 (Factory&lt;JavaFileManager&gt;)c -&gt; new JavacFileManager(c, true, null));
 152     }
 153 
 154     /**
 155      * Create a JavacFileManager using a given context, optionally registering
 156      * it as the JavaFileManager for that context.
 157      */
 158     public JavacFileManager(Context context, boolean register, Charset charset) {
 159         super(charset);
 160         if (register)
 161             context.put(JavaFileManager.class, this);
 162         setContext(context);
 163     }
 164 
 165     /**
 166      * Set the context for JavacFileManager.
 167      */
 168     @Override
 169     public void setContext(Context context) {
 170         super.setContext(context);
 171 
 172         fsInfo = FSInfo.instance(context);
 173 
 174         symbolFileEnabled = !options.isSet(&quot;ignore.symbol.file&quot;);
 175 
 176         String sf = options.get(&quot;sortFiles&quot;);
 177         if (sf != null) {
 178             sortFiles = (sf.equals(&quot;reverse&quot;) ? SortFiles.REVERSE : SortFiles.FORWARD);
 179         }
 180     }
 181 
 182     @Override @DefinedBy(DefinedBy.Api.COMPILER)
 183     public void setPathFactory(PathFactory f) {
 184         pathFactory = Objects.requireNonNull(f);
 185         locations.setPathFactory(f);
 186     }
 187 
 188     private Path getPath(String first, String... more) {
 189         return pathFactory.getPath(first, more);
 190     }
 191 
 192     /**
 193      * Set whether or not to use ct.sym as an alternate to rt.jar.
 194      */
 195     public void setSymbolFileEnabled(boolean b) {
 196         symbolFileEnabled = b;
 197     }
 198 
 199     public boolean isSymbolFileEnabled() {
 200         return symbolFileEnabled;
 201     }
 202 
 203     // used by tests
 204     public JavaFileObject getJavaFileObject(String name) {
 205         return getJavaFileObjects(name).iterator().next();
 206     }
 207 
 208     // used by tests
 209     public JavaFileObject getJavaFileObject(Path file) {
 210         return getJavaFileObjects(file).iterator().next();
 211     }
 212 
 213     public JavaFileObject getFileForOutput(String classname,
 214                                            JavaFileObject.Kind kind,
 215                                            JavaFileObject sibling)
 216         throws IOException
 217     {
 218         return getJavaFileForOutput(CLASS_OUTPUT, classname, kind, sibling);
 219     }
 220 
 221     @Override @DefinedBy(Api.COMPILER)
 222     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromStrings(Iterable&lt;String&gt; names) {
 223         ListBuffer&lt;Path&gt; paths = new ListBuffer&lt;&gt;();
 224         for (String name : names)
 225             paths.append(getPath(nullCheck(name)));
 226         return getJavaFileObjectsFromPaths(paths.toList());
 227     }
 228 
 229     @Override @DefinedBy(Api.COMPILER)
 230     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(String... names) {
 231         return getJavaFileObjectsFromStrings(Arrays.asList(nullCheck(names)));
 232     }
 233 
 234     private static boolean isValidName(String name) {
 235         // Arguably, isValidName should reject keywords (such as in SourceVersion.isName() ),
 236         // but the set of keywords depends on the source level, and we don&#39;t want
 237         // impls of JavaFileManager to have to be dependent on the source level.
 238         // Therefore we simply check that the argument is a sequence of identifiers
 239         // separated by &quot;.&quot;.
 240         for (String s : name.split(&quot;\\.&quot;, -1)) {
 241             if (!SourceVersion.isIdentifier(s))
 242                 return false;
 243         }
 244         return true;
 245     }
 246 
 247     private static void validateClassName(String className) {
 248         if (!isValidName(className))
 249             throw new IllegalArgumentException(&quot;Invalid class name: &quot; + className);
 250     }
 251 
 252     private static void validatePackageName(String packageName) {
 253         if (packageName.length() &gt; 0 &amp;&amp; !isValidName(packageName))
 254             throw new IllegalArgumentException(&quot;Invalid packageName name: &quot; + packageName);
 255     }
 256 
 257     public static void testName(String name,
 258                                 boolean isValidPackageName,
 259                                 boolean isValidClassName)
 260     {
 261         try {
 262             validatePackageName(name);
 263             if (!isValidPackageName)
 264                 throw new AssertionError(&quot;Invalid package name accepted: &quot; + name);
 265             printAscii(&quot;Valid package name: \&quot;%s\&quot;&quot;, name);
 266         } catch (IllegalArgumentException e) {
 267             if (isValidPackageName)
 268                 throw new AssertionError(&quot;Valid package name rejected: &quot; + name);
 269             printAscii(&quot;Invalid package name: \&quot;%s\&quot;&quot;, name);
 270         }
 271         try {
 272             validateClassName(name);
 273             if (!isValidClassName)
 274                 throw new AssertionError(&quot;Invalid class name accepted: &quot; + name);
 275             printAscii(&quot;Valid class name: \&quot;%s\&quot;&quot;, name);
 276         } catch (IllegalArgumentException e) {
 277             if (isValidClassName)
 278                 throw new AssertionError(&quot;Valid class name rejected: &quot; + name);
 279             printAscii(&quot;Invalid class name: \&quot;%s\&quot;&quot;, name);
 280         }
 281     }
 282 
 283     private static void printAscii(String format, Object... args) {
 284         String message;
 285         try {
 286             final String ascii = &quot;US-ASCII&quot;;
 287             message = new String(String.format(null, format, args).getBytes(ascii), ascii);
 288         } catch (java.io.UnsupportedEncodingException ex) {
 289             throw new AssertionError(ex);
 290         }
 291         System.out.println(message);
 292     }
 293 
 294     private final Map&lt;Path, Container&gt; containers = new HashMap&lt;&gt;();
 295 
 296     synchronized Container getContainer(Path path) throws IOException {
 297         Container fs = containers.get(path);
 298 
 299         if (fs != null) {
 300             return fs;
 301         }
 302 
 303         if (fsInfo.isFile(path) &amp;&amp; path.equals(Locations.thisSystemModules)) {
 304             containers.put(path, fs = new JRTImageContainer());
 305             return fs;
 306         }
 307 
 308         Path realPath = fsInfo.getCanonicalFile(path);
 309 
 310         fs = containers.get(realPath);
 311 
 312         if (fs != null) {
 313             containers.put(path, fs);
 314             return fs;
 315         }
 316 
 317         BasicFileAttributes attr = null;
 318 
 319         try {
 320             attr = Files.readAttributes(realPath, BasicFileAttributes.class);
 321         } catch (IOException ex) {
 322             //non-existing
 323             fs = MISSING_CONTAINER;
 324         }
 325 
 326         if (attr != null) {
 327             if (attr.isDirectory()) {
 328                 fs = new DirectoryContainer(realPath);
 329             } else {
 330                 try {
 331                     fs = new ArchiveContainer(path);
 332                 } catch (ProviderNotFoundException | SecurityException ex) {
 333                     throw new IOException(ex);
 334                 }
 335             }
 336         }
 337 
 338         containers.put(realPath, fs);
 339         containers.put(path, fs);
 340 
 341         return fs;
 342     }
 343 
 344     private interface Container {
 345         /**
 346          * Insert all files in subdirectory subdirectory of container which
 347          * match fileKinds into resultList
 348          */
 349         public abstract void list(Path userPath,
 350                                   RelativeDirectory subdirectory,
 351                                   Set&lt;JavaFileObject.Kind&gt; fileKinds,
 352                                   boolean recurse,
 353                                   ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException;
 354         public abstract JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException;
 355         public abstract void close() throws IOException;
 356         public abstract boolean maintainsDirectoryIndex();
 357 
 358         /**
 359          * The directories this container indexes if {@link #maintainsDirectoryIndex()}, otherwise
 360          * an empty iterable.
 361          */
 362         public abstract Iterable&lt;RelativeDirectory&gt; indexedDirectories();
 363     }
 364 
 365     private static final Container MISSING_CONTAINER =  new Container() {
 366         @Override
 367         public void list(Path userPath,
 368                          RelativeDirectory subdirectory,
 369                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 370                          boolean recurse,
 371                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 372         }
 373         @Override
 374         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 375             return null;
 376         }
 377         @Override
 378         public void close() throws IOException {}
 379         @Override
 380         public boolean maintainsDirectoryIndex() {
 381             return false;
 382         }
 383         @Override
 384         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {
 385             return List.nil();
 386         }
 387     };
 388 
 389     private final class JRTImageContainer implements Container {
 390 
 391         /**
 392          * Insert all files in a subdirectory of the platform image
 393          * which match fileKinds into resultList.
 394          */
 395         @Override
 396         public void list(Path userPath,
 397                          RelativeDirectory subdirectory,
 398                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 399                          boolean recurse,
 400                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 401             try {
 402                 JRTIndex.Entry e = getJRTIndex().getEntry(subdirectory);
 403                 if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 404                     return;
 405                 for (Path file: e.files.values()) {
 406                     if (fileKinds.contains(getKind(file))) {
 407                         JavaFileObject fe
 408                                 = PathFileObject.forJRTPath(JavacFileManager.this, file);
 409                         resultList.append(fe);
 410                     }
 411                 }
 412 
 413                 if (recurse) {
 414                     for (RelativeDirectory rd: e.subdirs) {
 415                         list(userPath, rd, fileKinds, recurse, resultList);
 416                     }
 417                 }
 418             } catch (IOException ex) {
 419                 ex.printStackTrace(System.err);
 420                 log.error(Errors.ErrorReadingFile(userPath, getMessage(ex)));
 421             }
 422         }
 423 
 424         @Override
 425         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 426             JRTIndex.Entry e = getJRTIndex().getEntry(name.dirname());
 427             if (symbolFileEnabled &amp;&amp; e.ctSym.hidden)
 428                 return null;
 429             Path p = e.files.get(name.basename());
 430             if (p != null) {
 431                 return PathFileObject.forJRTPath(JavacFileManager.this, p);
 432             } else {
 433                 return null;
 434             }
 435         }
 436 
 437         @Override
 438         public void close() throws IOException {
 439         }
 440 
 441         @Override
 442         public boolean maintainsDirectoryIndex() {
 443             return false;
 444         }
 445 
 446         @Override
 447         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {
 448             return List.nil();
 449         }
 450     }
 451 
 452     private synchronized JRTIndex getJRTIndex() {
 453         if (jrtIndex == null)
 454             jrtIndex = JRTIndex.getSharedInstance();
 455         return jrtIndex;
 456     }
 457 
 458     private JRTIndex jrtIndex;
 459 
 460     private final class DirectoryContainer implements Container {
 461         private final Path directory;
 462 
 463         public DirectoryContainer(Path directory) {
 464             this.directory = directory;
 465         }
 466 
 467         /**
 468          * Insert all files in subdirectory subdirectory of directory userPath
 469          * which match fileKinds into resultList
 470          */
 471         @Override
 472         public void list(Path userPath,
 473                          RelativeDirectory subdirectory,
 474                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 475                          boolean recurse,
 476                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 477             Path d;
 478             try {
 479                 d = subdirectory.resolveAgainst(userPath);
 480             } catch (InvalidPathException ignore) {
 481                 return ;
 482             }
 483 
 484             if (!Files.exists(d)) {
 485                return;
 486             }
 487 
 488             if (!caseMapCheck(d, subdirectory)) {
 489                 return;
 490             }
 491 
 492             java.util.List&lt;Path&gt; files;
 493             try (Stream&lt;Path&gt; s = Files.list(d)) {
 494                 files = (sortFiles == null ? s : s.sorted(sortFiles)).collect(Collectors.toList());
 495             } catch (IOException ignore) {
 496                 return;
 497             }
 498 
 499             for (Path f: files) {
 500                 String fname = f.getFileName().toString();
 501                 if (fname.endsWith(&quot;/&quot;))
 502                     fname = fname.substring(0, fname.length() - 1);
 503                 if (Files.isDirectory(f)) {
 504                     if (recurse &amp;&amp; SourceVersion.isIdentifier(fname)) {
 505                         list(userPath,
 506                              new RelativeDirectory(subdirectory, fname),
 507                              fileKinds,
 508                              recurse,
 509                              resultList);
 510                     }
 511                 } else {
 512                     if (isValidFile(fname, fileKinds)) {
 513                         try {
 514                             RelativeFile file = new RelativeFile(subdirectory, fname);
 515                             JavaFileObject fe = PathFileObject.forDirectoryPath(JavacFileManager.this,
 516                                     file.resolveAgainst(directory), userPath, file);
 517                             resultList.append(fe);
 518                         } catch (InvalidPathException e) {
 519                             throw new IOException(&quot;error accessing directory &quot; + directory + e);
 520                         }
 521                     }
 522                 }
 523             }
 524         }
 525 
 526         @Override
 527         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 528             try {
 529                 Path f = name.resolveAgainst(userPath);
 530                 if (Files.exists(f))
 531                     return PathFileObject.forSimplePath(JavacFileManager.this,
 532                             fsInfo.getCanonicalFile(f), f);
 533             } catch (InvalidPathException ignore) {
 534             }
 535             return null;
 536         }
 537 
 538         @Override
 539         public void close() throws IOException {
 540         }
 541 
 542         @Override
 543         public boolean maintainsDirectoryIndex() {
 544             return false;
 545         }
 546 
 547         @Override
 548         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {
 549             return List.nil();
 550         }
 551     }
 552 
 553     private static final Set&lt;FileVisitOption&gt; NO_FILE_VISIT_OPTIONS = Set.of();
 554     private static final Set&lt;FileVisitOption&gt; FOLLOW_LINKS_OPTIONS = Set.of(FOLLOW_LINKS);
 555 
 556     private final class ArchiveContainer implements Container {
 557         private final Path archivePath;
 558         private final FileSystem fileSystem;
 559         private final Map&lt;RelativeDirectory, Path&gt; packages;
 560 
 561         public ArchiveContainer(Path archivePath) throws IOException, ProviderNotFoundException, SecurityException {
 562             this.archivePath = archivePath;
 563             if (multiReleaseValue != null &amp;&amp; archivePath.toString().endsWith(&quot;.jar&quot;)) {
 564                 Map&lt;String,String&gt; env = Collections.singletonMap(&quot;multi-release&quot;, multiReleaseValue);
 565                 FileSystemProvider jarFSProvider = fsInfo.getJarFSProvider();
 566                 Assert.checkNonNull(jarFSProvider, &quot;should have been caught before!&quot;);
 567                 this.fileSystem = jarFSProvider.newFileSystem(archivePath, env);
 568             } else {
 569                 this.fileSystem = FileSystems.newFileSystem(archivePath, (ClassLoader)null);
 570             }
 571             packages = new HashMap&lt;&gt;();
 572             for (Path root : fileSystem.getRootDirectories()) {
 573                 Files.walkFileTree(root, NO_FILE_VISIT_OPTIONS, Integer.MAX_VALUE,
 574                         new SimpleFileVisitor&lt;Path&gt;() {
 575                             @Override
 576                             public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
 577                                 if (isValid(dir.getFileName())) {
 578                                     packages.put(new RelativeDirectory(root.relativize(dir).toString()), dir);
 579                                     return FileVisitResult.CONTINUE;
 580                                 } else {
 581                                     return FileVisitResult.SKIP_SUBTREE;
 582                                 }
 583                             }
 584                         });
 585             }
 586         }
 587 
 588         /**
 589          * Insert all files in subdirectory subdirectory of this archive
 590          * which match fileKinds into resultList
 591          */
 592         @Override
 593         public void list(Path userPath,
 594                          RelativeDirectory subdirectory,
 595                          Set&lt;JavaFileObject.Kind&gt; fileKinds,
 596                          boolean recurse,
 597                          ListBuffer&lt;JavaFileObject&gt; resultList) throws IOException {
 598             Path resolvedSubdirectory = packages.get(subdirectory);
 599 
 600             if (resolvedSubdirectory == null)
 601                 return ;
 602 
 603             int maxDepth = (recurse ? Integer.MAX_VALUE : 1);
 604             Files.walkFileTree(resolvedSubdirectory, FOLLOW_LINKS_OPTIONS, maxDepth,
 605                     new SimpleFileVisitor&lt;Path&gt;() {
 606                         @Override
 607                         public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
 608                             if (isValid(dir.getFileName())) {
 609                                 return FileVisitResult.CONTINUE;
 610                             } else {
 611                                 return FileVisitResult.SKIP_SUBTREE;
 612                             }
 613                         }
 614 
 615                         @Override
 616                         public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
 617                             if (attrs.isRegularFile() &amp;&amp; fileKinds.contains(getKind(file.getFileName().toString()))) {
 618                                 JavaFileObject fe = PathFileObject.forJarPath(
 619                                         JavacFileManager.this, file, archivePath);
 620                                 resultList.append(fe);
 621                             }
 622                             return FileVisitResult.CONTINUE;
 623                         }
 624                     });
 625 
 626         }
 627 
 628         private boolean isValid(Path fileName) {
 629             if (fileName == null) {
 630                 return true;
 631             } else {
 632                 String name = fileName.toString();
 633                 if (name.endsWith(&quot;/&quot;)) {
 634                     name = name.substring(0, name.length() - 1);
 635                 }
 636                 return SourceVersion.isIdentifier(name);
 637             }
 638         }
 639 
 640         @Override
 641         public JavaFileObject getFileObject(Path userPath, RelativeFile name) throws IOException {
 642             RelativeDirectory root = name.dirname();
 643             Path packagepath = packages.get(root);
 644             if (packagepath != null) {
 645                 Path relpath = packagepath.resolve(name.basename());
 646                 if (Files.exists(relpath)) {
 647                     return PathFileObject.forJarPath(JavacFileManager.this, relpath, userPath);
 648                 }
 649             }
 650             return null;
 651         }
 652 
 653         @Override
 654         public void close() throws IOException {
 655             fileSystem.close();
 656         }
 657 
 658         @Override
 659         public boolean maintainsDirectoryIndex() {
 660             return true;
 661         }
 662 
 663         @Override
 664         public Iterable&lt;RelativeDirectory&gt; indexedDirectories() {
 665             return packages.keySet();
 666         }
 667     }
 668 
 669     /**
 670      * container is a directory, a zip file, or a non-existent path.
 671      */
 672     private boolean isValidFile(String s, Set&lt;JavaFileObject.Kind&gt; fileKinds) {
 673         JavaFileObject.Kind kind = getKind(s);
 674         return fileKinds.contains(kind);
 675     }
 676 
 677     private static final boolean fileSystemIsCaseSensitive =
 678         File.separatorChar == &#39;/&#39;;
 679 
 680     /** Hack to make Windows case sensitive. Test whether given path
 681      *  ends in a string of characters with the same case as given name.
 682      *  Ignore file separators in both path and name.
 683      */
 684     private boolean caseMapCheck(Path f, RelativePath name) {
 685         if (fileSystemIsCaseSensitive) return true;
 686         // Note that toRealPath() returns the case-sensitive
 687         // spelled file name.
 688         String path;
 689         char sep;
 690         try {
 691             path = f.toRealPath(LinkOption.NOFOLLOW_LINKS).toString();
 692             sep = f.getFileSystem().getSeparator().charAt(0);
 693         } catch (IOException ex) {
 694             return false;
 695         }
 696         char[] pcs = path.toCharArray();
 697         char[] ncs = name.path.toCharArray();
 698         int i = pcs.length - 1;
 699         int j = ncs.length - 1;
 700         while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 701             while (i &gt;= 0 &amp;&amp; pcs[i] == sep) i--;
 702             while (j &gt;= 0 &amp;&amp; ncs[j] == &#39;/&#39;) j--;
 703             if (i &gt;= 0 &amp;&amp; j &gt;= 0) {
 704                 if (pcs[i] != ncs[j]) return false;
 705                 i--;
 706                 j--;
 707             }
 708         }
 709         return j &lt; 0;
 710     }
 711 
 712     /** Flush any output resources.
 713      */
 714     @Override @DefinedBy(Api.COMPILER)
 715     public void flush() {
 716         contentCache.clear();
 717         pathsAndContainersByLocationAndRelativeDirectory.clear();
 718         nonIndexingContainersByLocation.clear();
 719     }
 720 
 721     /**
 722      * Close the JavaFileManager, releasing resources.
 723      */
 724     @Override @DefinedBy(Api.COMPILER)
 725     public void close() throws IOException {
 726         if (deferredCloseTimeout &gt; 0) {
 727             deferredClose();
 728             return;
 729         }
 730 
 731         locations.close();
 732         for (Container container: containers.values()) {
 733             container.close();
 734         }
 735         containers.clear();
 736         pathsAndContainersByLocationAndRelativeDirectory.clear();
 737         nonIndexingContainersByLocation.clear();
 738         contentCache.clear();
 739     }
 740 
 741     @Override @DefinedBy(Api.COMPILER)
 742     public ClassLoader getClassLoader(Location location) {
 743         checkNotModuleOrientedLocation(location);
 744         Iterable&lt;? extends File&gt; path = getLocation(location);
 745         if (path == null)
 746             return null;
 747         ListBuffer&lt;URL&gt; lb = new ListBuffer&lt;&gt;();
 748         for (File f: path) {
 749             try {
 750                 lb.append(f.toURI().toURL());
 751             } catch (MalformedURLException e) {
 752                 throw new AssertionError(e);
 753             }
 754         }
 755 
 756         return getClassLoader(lb.toArray(new URL[lb.size()]));
 757     }
 758 
 759     @Override @DefinedBy(Api.COMPILER)
 760     public Iterable&lt;JavaFileObject&gt; list(Location location,
 761                                          String packageName,
 762                                          Set&lt;JavaFileObject.Kind&gt; kinds,
 763                                          boolean recurse)
 764         throws IOException
 765     {
 766         checkNotModuleOrientedLocation(location);
 767         // validatePackageName(packageName);
 768         nullCheck(packageName);
 769         nullCheck(kinds);
 770 
 771         RelativeDirectory subdirectory = RelativeDirectory.forPackage(packageName);
 772         ListBuffer&lt;JavaFileObject&gt; results = new ListBuffer&lt;&gt;();
 773 
 774         for (PathAndContainer pathAndContainer : pathsAndContainers(location, subdirectory)) {
 775             Path directory = pathAndContainer.path;
 776             Container container = pathAndContainer.container;
 777             container.list(directory, subdirectory, kinds, recurse, results);
 778         }
 779 
 780         return results.toList();
 781     }
 782 
 783     @Override @DefinedBy(Api.COMPILER)
 784     public String inferBinaryName(Location location, JavaFileObject file) {
 785         checkNotModuleOrientedLocation(location);
 786         Objects.requireNonNull(file);
 787         // Need to match the path semantics of list(location, ...)
 788         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);
 789         if (path == null) {
 790             return null;
 791         }
 792 
 793         if (file instanceof PathFileObject) {
 794             return ((PathFileObject) file).inferBinaryName(path);
 795         } else
 796             throw new IllegalArgumentException(file.getClass().getName());
 797     }
 798 
 799     @Override @DefinedBy(Api.COMPILER)
 800     public boolean isSameFile(FileObject a, FileObject b) {
 801         nullCheck(a);
 802         nullCheck(b);
 803         if (a instanceof PathFileObject &amp;&amp; b instanceof PathFileObject)
 804             return ((PathFileObject) a).isSameFile((PathFileObject) b);
 805         return a.equals(b);
 806     }
 807 
 808     @Override @DefinedBy(Api.COMPILER)
 809     public boolean hasLocation(Location location) {
 810         nullCheck(location);
 811         return locations.hasLocation(location);
 812     }
 813 
 814     protected boolean hasExplicitLocation(Location location) {
 815         nullCheck(location);
 816         return locations.hasExplicitLocation(location);
 817     }
 818 
 819     @Override @DefinedBy(Api.COMPILER)
 820     public JavaFileObject getJavaFileForInput(Location location,
 821                                               String className,
 822                                               JavaFileObject.Kind kind)
 823         throws IOException
 824     {
 825         checkNotModuleOrientedLocation(location);
 826         // validateClassName(className);
 827         nullCheck(className);
 828         nullCheck(kind);
 829         if (!SOURCE_OR_CLASS.contains(kind))
 830             throw new IllegalArgumentException(&quot;Invalid kind: &quot; + kind);
 831         return getFileForInput(location, RelativeFile.forClass(className, kind));
 832     }
 833 
 834     @Override @DefinedBy(Api.COMPILER)
 835     public FileObject getFileForInput(Location location,
 836                                       String packageName,
 837                                       String relativeName)
 838         throws IOException
 839     {
 840         checkNotModuleOrientedLocation(location);
 841         // validatePackageName(packageName);
 842         nullCheck(packageName);
 843         if (!isRelativeUri(relativeName))
 844             throw new IllegalArgumentException(&quot;Invalid relative name: &quot; + relativeName);
 845         RelativeFile name = packageName.length() == 0
 846             ? new RelativeFile(relativeName)
 847             : new RelativeFile(RelativeDirectory.forPackage(packageName), relativeName);
 848         return getFileForInput(location, name);
 849     }
 850 
 851     private JavaFileObject getFileForInput(Location location, RelativeFile name) throws IOException {
 852         Iterable&lt;? extends Path&gt; path = getLocationAsPaths(location);
 853         if (path == null)
 854             return null;
 855 
 856         for (Path file: path) {
 857             JavaFileObject fo = getContainer(file).getFileObject(file, name);
 858 
 859             if (fo != null) {
 860                 return fo;
 861             }
 862         }
 863         return null;
 864     }
 865 
 866     @Override @DefinedBy(Api.COMPILER)
 867     public JavaFileObject getJavaFileForOutput(Location location,
 868                                                String className,
 869                                                JavaFileObject.Kind kind,
 870                                                FileObject sibling)
 871         throws IOException
 872     {
 873         checkOutputLocation(location);
 874         // validateClassName(className);
 875         nullCheck(className);
 876         nullCheck(kind);
 877         if (!SOURCE_OR_CLASS.contains(kind))
 878             throw new IllegalArgumentException(&quot;Invalid kind: &quot; + kind);
 879         return getFileForOutput(location, RelativeFile.forClass(className, kind), sibling);
 880     }
 881 
 882     @Override @DefinedBy(Api.COMPILER)
 883     public FileObject getFileForOutput(Location location,
 884                                        String packageName,
 885                                        String relativeName,
 886                                        FileObject sibling)
 887         throws IOException
 888     {
 889         checkOutputLocation(location);
 890         // validatePackageName(packageName);
 891         nullCheck(packageName);
 892         if (!isRelativeUri(relativeName))
 893             throw new IllegalArgumentException(&quot;Invalid relative name: &quot; + relativeName);
 894         RelativeFile name = packageName.length() == 0
 895             ? new RelativeFile(relativeName)
 896             : new RelativeFile(RelativeDirectory.forPackage(packageName), relativeName);
 897         return getFileForOutput(location, name, sibling);
 898     }
 899 
 900     private JavaFileObject getFileForOutput(Location location,
 901                                             RelativeFile fileName,
 902                                             FileObject sibling)
 903         throws IOException
 904     {
 905         Path dir;
 906         if (location == CLASS_OUTPUT) {
 907             if (getClassOutDir() != null) {
 908                 dir = getClassOutDir();
 909             } else {
 910                 String baseName = fileName.basename();
 911                 if (sibling != null &amp;&amp; sibling instanceof PathFileObject) {
 912                     return ((PathFileObject) sibling).getSibling(baseName);
 913                 } else {
 914                     Path p = getPath(baseName);
 915                     Path real = fsInfo.getCanonicalFile(p);
 916                     return PathFileObject.forSimplePath(this, real, p);
 917                 }
 918             }
 919         } else if (location == SOURCE_OUTPUT) {
 920             dir = (getSourceOutDir() != null ? getSourceOutDir() : getClassOutDir());
 921         } else {
 922             Iterable&lt;? extends Path&gt; path = locations.getLocation(location);
 923             dir = null;
 924             for (Path f: path) {
 925                 dir = f;
 926                 break;
 927             }
 928         }
 929 
 930         try {
 931             if (dir == null) {
 932                 dir = getPath(System.getProperty(&quot;user.dir&quot;));
 933             }
 934             Path path = fileName.resolveAgainst(fsInfo.getCanonicalFile(dir));
 935             return PathFileObject.forDirectoryPath(this, path, dir, fileName);
 936         } catch (InvalidPathException e) {
 937             throw new IOException(&quot;bad filename &quot; + fileName, e);
 938         }
 939     }
 940 
 941     @Override @DefinedBy(Api.COMPILER)
 942     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromFiles(
 943         Iterable&lt;? extends File&gt; files)
 944     {
 945         ArrayList&lt;PathFileObject&gt; result;
 946         if (files instanceof Collection&lt;?&gt;)
 947             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)files).size());
 948         else
 949             result = new ArrayList&lt;&gt;();
 950         for (File f: files) {
 951             Objects.requireNonNull(f);
 952             Path p = f.toPath();
 953             result.add(PathFileObject.forSimplePath(this,
 954                     fsInfo.getCanonicalFile(p), p));
 955         }
 956         return result;
 957     }
 958 
 959     @Override @DefinedBy(Api.COMPILER)
 960     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjectsFromPaths(
 961         Collection&lt;? extends Path&gt; paths)
 962     {
 963         ArrayList&lt;PathFileObject&gt; result;
 964         if (paths instanceof Collection&lt;?&gt;)
 965             result = new ArrayList&lt;&gt;(((Collection&lt;?&gt;)paths).size());
 966         else
 967             result = new ArrayList&lt;&gt;();
 968         for (Path p: paths)
 969             result.add(PathFileObject.forSimplePath(this,
 970                     fsInfo.getCanonicalFile(p), p));
 971         return result;
 972     }
 973 
 974     @Override @DefinedBy(Api.COMPILER)
 975     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(File... files) {
 976         return getJavaFileObjectsFromFiles(Arrays.asList(nullCheck(files)));
 977     }
 978 
 979     @Override @DefinedBy(Api.COMPILER)
 980     public Iterable&lt;? extends JavaFileObject&gt; getJavaFileObjects(Path... paths) {
 981         return getJavaFileObjectsFromPaths(Arrays.asList(nullCheck(paths)));
 982     }
 983 
 984     @Override @DefinedBy(Api.COMPILER)
 985     public void setLocation(Location location,
 986                             Iterable&lt;? extends File&gt; searchpath)
 987         throws IOException
 988     {
 989         nullCheck(location);
 990         locations.setLocation(location, asPaths(searchpath));
 991         clearCachesForLocation(location);
 992     }
 993 
 994     @Override @DefinedBy(Api.COMPILER)
 995     public void setLocationFromPaths(Location location,
 996                             Collection&lt;? extends Path&gt; searchpath)
 997         throws IOException
 998     {
 999         nullCheck(location);
1000         locations.setLocation(location, nullCheck(searchpath));
1001         clearCachesForLocation(location);
1002     }
1003 
1004     @Override @DefinedBy(Api.COMPILER)
1005     public Iterable&lt;? extends File&gt; getLocation(Location location) {
1006         nullCheck(location);
1007         return asFiles(locations.getLocation(location));
1008     }
1009 
1010     @Override @DefinedBy(Api.COMPILER)
1011     public Collection&lt;? extends Path&gt; getLocationAsPaths(Location location) {
1012         nullCheck(location);
1013         return locations.getLocation(location);
1014     }
1015 
1016     private java.util.List&lt;PathAndContainer&gt; pathsAndContainers(
1017             Location location, RelativeDirectory relativeDirectory) throws IOException {
1018         try {
1019             return pathsAndContainersByLocationAndRelativeDirectory.computeIfAbsent(
1020                     location, this::indexPathsAndContainersByRelativeDirectory)
1021                 .computeIfAbsent(
1022                     relativeDirectory, d -&gt; nonIndexingContainersByLocation.get(location));
1023         } catch (UncheckedIOException e) {
1024             throw e.getCause();
1025         }
1026     }
1027 
1028     private Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt; indexPathsAndContainersByRelativeDirectory(
1029             Location location) {
1030         Map&lt;RelativeDirectory, java.util.List&lt;PathAndContainer&gt;&gt; result = new HashMap&lt;&gt;();
1031         java.util.List&lt;PathAndContainer&gt; allPathsAndContainers = pathsAndContainers(location);
1032 
1033         // First collect all of the containers that don&#39;t maintain their own index on
1034         // RelativeDirectory. These need to always be included for all mappings
1035         java.util.List&lt;PathAndContainer&gt; nonIndexingContainers = new ArrayList&lt;&gt;();
1036         for (PathAndContainer pathAndContainer : allPathsAndContainers) {
1037             if (!pathAndContainer.container.maintainsDirectoryIndex()) {
1038                 nonIndexingContainers.add(pathAndContainer);
1039             }
1040         }
1041 
1042         // Next, use the container that do maintain their own RelativeDirectory index to create a
1043         // single master index.
1044         for (PathAndContainer pathAndContainer : allPathsAndContainers) {
1045             Container container = pathAndContainer.container;
1046             if (container.maintainsDirectoryIndex()) {
1047                 for (RelativeDirectory directory : container.indexedDirectories()) {
1048                     result.computeIfAbsent(directory, d -&gt; new ArrayList&lt;&gt;(nonIndexingContainers))
1049                           .add(pathAndContainer);
1050                 }
1051             }
1052         }
1053         nonIndexingContainersByLocation.put(location, nonIndexingContainers);
1054 
1055         // Sorting preserves the search order used in the uncached Location path, which has
1056         // maintains consistency with the classpath order
1057         result.values().forEach(pathAndContainerList -&gt; Collections.sort(pathAndContainerList));
1058 
1059         return result;
1060     }
1061 
1062     /**
1063      * For each {@linkplain #getLocationAsPaths(Location) path of the location}, compute the
1064      * corresponding {@link Container}.
1065      */
1066     private java.util.List&lt;PathAndContainer&gt; pathsAndContainers(Location location) {
1067         Collection&lt;? extends Path&gt; paths = getLocationAsPaths(location);
1068         if (paths == null) {
1069             return List.nil();
1070         }
1071         java.util.List&lt;PathAndContainer&gt; pathsAndContainers =
1072             new ArrayList&lt;&gt;(paths.size());
1073         for (Path path : paths) {
1074             Container container;
1075             try {
1076                 container = getContainer(path);
1077             } catch (IOException e) {
1078                 throw new UncheckedIOException(e);
1079             }
1080             pathsAndContainers.add(new PathAndContainer(path, container, pathsAndContainers.size()));
1081         }
1082         return pathsAndContainers;
1083     }
1084 
1085     private static class PathAndContainer implements Comparable&lt;PathAndContainer&gt; {
1086         private final Path path;
1087         private final Container container;
1088         private final int index;
1089 
1090         PathAndContainer(Path path, Container container, int index) {
1091             this.path = path;
1092             this.container = container;
1093             this.index = index;
1094         }
1095 
1096         @Override
1097         public int compareTo(PathAndContainer other) {
1098             return index - other.index;
1099         }
1100 
1101         @Override
1102         public boolean equals(Object o) {
1103           if (o == null || !(o instanceof PathAndContainer)) {
1104             return false;
1105           }
1106           PathAndContainer that = (PathAndContainer) o;
1107           return path.equals(that.path)
1108               &amp;&amp; container.equals(that.container)
1109               &amp;&amp; index == this.index;
1110         }
1111 
1112         @Override
1113         public int hashCode() {
1114           return Objects.hash(path, container, index);
1115         }
1116     }
1117 
1118     @Override @DefinedBy(Api.COMPILER)
1119     public boolean contains(Location location, FileObject fo) throws IOException {
1120         nullCheck(location);
1121         nullCheck(fo);
1122         Path p = asPath(fo);
1123         return locations.contains(location, p);
1124     }
1125 
1126     private Path getClassOutDir() {
1127         return locations.getOutputLocation(CLASS_OUTPUT);
1128     }
1129 
1130     private Path getSourceOutDir() {
1131         return locations.getOutputLocation(SOURCE_OUTPUT);
1132     }
1133 
1134     @Override @DefinedBy(Api.COMPILER)
1135     public Location getLocationForModule(Location location, String moduleName) throws IOException {
1136         checkModuleOrientedOrOutputLocation(location);
1137         nullCheck(moduleName);
1138         if (location == SOURCE_OUTPUT &amp;&amp; getSourceOutDir() == null)
1139             location = CLASS_OUTPUT;
1140         return locations.getLocationForModule(location, moduleName);
1141     }
1142 
1143     @Override @DefinedBy(Api.COMPILER)
1144     public &lt;S&gt; ServiceLoader&lt;S&gt; getServiceLoader(Location location, Class&lt;S&gt; service) throws IOException {
1145         nullCheck(location);
1146         nullCheck(service);
1147         getClass().getModule().addUses(service);
1148         if (location.isModuleOrientedLocation()) {
1149             Collection&lt;Path&gt; paths = locations.getLocation(location);
1150             ModuleFinder finder = ModuleFinder.of(paths.toArray(new Path[paths.size()]));
1151             ModuleLayer bootLayer = ModuleLayer.boot();
1152             Configuration cf = bootLayer.configuration().resolveAndBind(ModuleFinder.of(), finder, Collections.emptySet());
1153             ModuleLayer layer = bootLayer.defineModulesWithOneLoader(cf, ClassLoader.getSystemClassLoader());
1154             return ServiceLoader.load(layer, service);
1155         } else {
1156             return ServiceLoader.load(service, getClassLoader(location));
1157         }
1158     }
1159 
1160     @Override @DefinedBy(Api.COMPILER)
1161     public Location getLocationForModule(Location location, JavaFileObject fo) throws IOException {
1162         checkModuleOrientedOrOutputLocation(location);
1163         if (!(fo instanceof PathFileObject))
1164             return null;
1165         Path p = Locations.normalize(((PathFileObject) fo).path);
1166             // need to find p in location
1167         return locations.getLocationForModule(location, p);
1168     }
1169 
1170     @Override @DefinedBy(Api.COMPILER)
1171     public void setLocationForModule(Location location, String moduleName, Collection&lt;? extends Path&gt; paths)
1172             throws IOException {
1173         nullCheck(location);
1174         checkModuleOrientedOrOutputLocation(location);
1175         locations.setLocationForModule(location, nullCheck(moduleName), nullCheck(paths));
1176         clearCachesForLocation(location);
1177     }
1178 
1179     @Override @DefinedBy(Api.COMPILER)
1180     public String inferModuleName(Location location) {
1181         checkNotModuleOrientedLocation(location);
1182         return locations.inferModuleName(location);
1183     }
1184 
1185     @Override @DefinedBy(Api.COMPILER)
1186     public Iterable&lt;Set&lt;Location&gt;&gt; listLocationsForModules(Location location) throws IOException {
1187         checkModuleOrientedOrOutputLocation(location);
1188         return locations.listLocationsForModules(location);
1189     }
1190 
1191     @Override @DefinedBy(Api.COMPILER)
1192     public Path asPath(FileObject file) {
1193         if (file instanceof PathFileObject) {
1194             return ((PathFileObject) file).path;
1195         } else
1196             throw new IllegalArgumentException(file.getName());
1197     }
1198 
1199     /**
1200      * Enforces the specification of a &quot;relative&quot; name as used in
1201      * {@linkplain #getFileForInput(Location,String,String)
1202      * getFileForInput}.  This method must follow the rules defined in
1203      * that method, do not make any changes without consulting the
1204      * specification.
1205      */
1206     protected static boolean isRelativeUri(URI uri) {
1207         if (uri.isAbsolute())
1208             return false;
1209         String path = uri.normalize().getPath();
1210         if (path.length() == 0 /* isEmpty() is mustang API */)
1211             return false;
1212         if (!path.equals(uri.getPath())) // implicitly checks for embedded . and ..
1213             return false;
1214         if (path.startsWith(&quot;/&quot;) || path.startsWith(&quot;./&quot;) || path.startsWith(&quot;../&quot;))
1215             return false;
1216         return true;
1217     }
1218 
1219     // Convenience method
1220     protected static boolean isRelativeUri(String u) {
1221         try {
1222             return isRelativeUri(new URI(u));
1223         } catch (URISyntaxException e) {
1224             return false;
1225         }
1226     }
1227 
1228     /**
1229      * Converts a relative file name to a relative URI.  This is
1230      * different from File.toURI as this method does not canonicalize
1231      * the file before creating the URI.  Furthermore, no schema is
1232      * used.
1233      * @param file a relative file name
1234      * @return a relative URI
1235      * @throws IllegalArgumentException if the file name is not
1236      * relative according to the definition given in {@link
1237      * javax.tools.JavaFileManager#getFileForInput}
1238      */
1239     public static String getRelativeName(File file) {
1240         if (!file.isAbsolute()) {
1241             String result = file.getPath().replace(File.separatorChar, &#39;/&#39;);
1242             if (isRelativeUri(result))
1243                 return result;
1244         }
1245         throw new IllegalArgumentException(&quot;Invalid relative path: &quot; + file);
1246     }
1247 
1248     /**
1249      * Get a detail message from an IOException.
1250      * Most, but not all, instances of IOException provide a non-null result
1251      * for getLocalizedMessage().  But some instances return null: in these
1252      * cases, fall back to getMessage(), and if even that is null, return the
1253      * name of the exception itself.
1254      * @param e an IOException
1255      * @return a string to include in a compiler diagnostic
1256      */
1257     public static String getMessage(IOException e) {
1258         String s = e.getLocalizedMessage();
1259         if (s != null)
1260             return s;
1261         s = e.getMessage();
1262         if (s != null)
1263             return s;
1264         return e.toString();
1265     }
1266 
1267     private void checkOutputLocation(Location location) {
1268         Objects.requireNonNull(location);
1269         if (!location.isOutputLocation())
1270             throw new IllegalArgumentException(&quot;location is not an output location: &quot; + location.getName());
1271     }
1272 
1273     private void checkModuleOrientedOrOutputLocation(Location location) {
1274         Objects.requireNonNull(location);
1275         if (!location.isModuleOrientedLocation() &amp;&amp; !location.isOutputLocation())
1276             throw new IllegalArgumentException(
1277                     &quot;location is not an output location or a module-oriented location: &quot;
1278                             + location.getName());
1279     }
1280 
1281     private void checkNotModuleOrientedLocation(Location location) {
1282         Objects.requireNonNull(location);
1283         if (location.isModuleOrientedLocation())
1284             throw new IllegalArgumentException(&quot;location is module-oriented: &quot; + location.getName());
1285     }
1286 
1287     /* Converters between files and paths.
1288      * These are temporary until we can update the StandardJavaFileManager API.
1289      */
1290 
1291     private static Iterable&lt;Path&gt; asPaths(final Iterable&lt;? extends File&gt; files) {
1292         if (files == null)
1293             return null;
1294 
1295         return () -&gt; new Iterator&lt;Path&gt;() {
1296             Iterator&lt;? extends File&gt; iter = files.iterator();
1297 
1298             @Override
1299             public boolean hasNext() {
1300                 return iter.hasNext();
1301             }
1302 
1303             @Override
1304             public Path next() {
1305                 return iter.next().toPath();
1306             }
1307         };
1308     }
1309 
1310     private static Iterable&lt;File&gt; asFiles(final Iterable&lt;? extends Path&gt; paths) {
1311         if (paths == null)
1312             return null;
1313 
1314         return () -&gt; new Iterator&lt;File&gt;() {
1315             Iterator&lt;? extends Path&gt; iter = paths.iterator();
1316 
1317             @Override
1318             public boolean hasNext() {
1319                 return iter.hasNext();
1320             }
1321 
1322             @Override
1323             public File next() {
1324                 try {
1325                     return iter.next().toFile();
1326                 } catch (UnsupportedOperationException e) {
1327                     throw new IllegalStateException(e);
1328                 }
1329             }
1330         };
1331     }
1332 
1333     @Override
1334     public boolean handleOption(Option option, String value) {
1335         if (javacFileManagerOptions.contains(option)) {
1336             pathsAndContainersByLocationAndRelativeDirectory.clear();
1337             nonIndexingContainersByLocation.clear();
1338         }
1339         return super.handleOption(option, value);
1340     }
1341 
1342     private void clearCachesForLocation(Location location) {
1343         nullCheck(location);
1344         pathsAndContainersByLocationAndRelativeDirectory.remove(location);
1345         nonIndexingContainersByLocation.remove(location);
1346     }
1347 }
    </pre>
  </body>
</html>
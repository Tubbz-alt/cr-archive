diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/ArgumentAttr.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/ArgumentAttr.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/ArgumentAttr.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/ArgumentAttr.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,11 +41,10 @@
 import com.sun.tools.javac.comp.DeferredAttr.SwitchExpressionScanner;
 import com.sun.tools.javac.comp.Infer.PartiallyInferredMethodType;
 import com.sun.tools.javac.comp.Resolve.MethodResolutionPhase;
 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
 import com.sun.tools.javac.tree.JCTree;
-import com.sun.tools.javac.tree.JCTree.JCBreak;
 import com.sun.tools.javac.tree.JCTree.JCConditional;
 import com.sun.tools.javac.tree.JCTree.JCExpression;
 import com.sun.tools.javac.tree.JCTree.JCLambda;
 import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;
 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
@@ -75,10 +74,11 @@
 import static com.sun.tools.javac.code.TypeTag.ARRAY;
 import static com.sun.tools.javac.code.TypeTag.DEFERRED;
 import static com.sun.tools.javac.code.TypeTag.FORALL;
 import static com.sun.tools.javac.code.TypeTag.METHOD;
 import static com.sun.tools.javac.code.TypeTag.VOID;
+import com.sun.tools.javac.tree.JCTree.JCYield;
 
 /**
  * This class performs attribution of method/constructor arguments when target-typing is enabled
  * (source >= 8); for each argument that is potentially a poly expression, this class builds
  * a rich representation (see {@link ArgumentType} which can then be used for performing fast overload
@@ -89,11 +89,11 @@
  * - if A is potentially a poly expression (i.e. diamond instance creation expression), a speculative
  * pass over A is performed; the results of such speculative attribution are then saved in a special
  * type, so that enclosing overload resolution can be carried by simply checking compatibility against the
  * type determined during this speculative pass.
  *
- * - if A is a standalone expression, regular atributtion takes place.
+ * - if A is a standalone expression, regular attribution takes place.
  *
  * To minimize the speculative work, a cache is used, so that already computed argument types
  * associated with a given unique source location are never recomputed multiple times.
  */
 public class ArgumentAttr extends JCTree.Visitor {
@@ -110,11 +110,11 @@
     private Env<AttrContext> env;
 
     /** Result of method attribution. */
     Type result;
 
-    /** Cache for argument types; behavior is influences by the currrently selected cache policy. */
+    /** Cache for argument types; behavior is influenced by the currently selected cache policy. */
     Map<UniquePos, ArgumentType<?>> argumentTypeCache = new LinkedHashMap<>();
 
     public static ArgumentAttr instance(Context context) {
         ArgumentAttr instance = context.get(methodAttrKey);
         if (instance == null)
@@ -134,11 +134,11 @@
     /**
      * Set the results of method attribution.
      */
     void setResult(JCExpression tree, Type type) {
         result = type;
-        if (env.info.isSpeculative) {
+        if (env.info.attributionMode == DeferredAttr.AttributionMode.SPECULATIVE) {
             //if we are in a speculative branch we can save the type in the tree itself
             //as there's no risk of polluting the original tree.
             tree.type = result;
         }
     }
@@ -363,11 +363,11 @@
                         deferredAttr.basicCompleter.complete(dt, resultInfo, deferredAttrContext) :
                         overloadCheck(resultInfo, deferredAttrContext);
                 speculativeTypes.put(resultInfo, t);
                 return t;
             } else {
-                if (!env.info.isSpeculative) {
+                if (!env.info.attributionMode.isSpeculative) {
                     argumentTypeCache.remove(new UniquePos(dt.tree));
                 }
                 return deferredAttr.basicCompleter.complete(dt, resultInfo, deferredAttrContext);
             }
         }
@@ -466,11 +466,11 @@
     /**
      * Argument type for switch expressions.
      */
     class SwitchExpressionType extends ArgumentType<JCSwitchExpression> {
         /** List of break expressions (lazily populated). */
-        Optional<List<JCBreak>> breakExpressions = Optional.empty();
+        Optional<List<JCYield>> yieldExpressions = Optional.empty();
 
         SwitchExpressionType(JCExpression tree, Env<AttrContext> env, JCSwitchExpression speculativeCond) {
             this(tree, env, speculativeCond, new HashMap<>());
         }
 
@@ -485,31 +485,32 @@
                 //this means we are returning a poly switch expression from void-compatible lambda expression
                 resultInfo.checkContext.report(tree, attr.diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
                 return attr.types.createErrorType(resultInfo.pt);
             } else {
                 //poly
-                for (JCBreak brk : breakExpressions()) {
+                for (JCYield brk : yieldExpressions()) {
                     checkSpeculative(brk.value, brk.value.type, resultInfo);
                 }
                 return localInfo.pt;
             }
         }
 
         /** Compute return expressions (if needed). */
-        List<JCBreak> breakExpressions() {
-            return breakExpressions.orElseGet(() -> {
-                final List<JCBreak> res;
-                ListBuffer<JCBreak> buf = new ListBuffer<>();
+        List<JCYield> yieldExpressions() {
+            return yieldExpressions.orElseGet(() -> {
+                final List<JCYield> res;
+                ListBuffer<JCYield> buf = new ListBuffer<>();
                 new SwitchExpressionScanner() {
                     @Override
-                    public void visitBreak(JCBreak tree) {
+                    public void visitYield(JCYield tree) {
                         if (tree.target == speculativeTree)
                             buf.add(tree);
+                        super.visitYield(tree);
                     }
                 }.scan(speculativeTree.cases);
                 res = buf.toList();
-                breakExpressions = Optional.of(res);
+                yieldExpressions = Optional.of(res);
                 return res;
             });
         }
 
         @Override

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavaTokenizer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -27,11 +27,11 @@</span>
  
  import java.util.*;
  import java.util.function.Function;
  import java.util.stream.Collectors;
  
<span class="udiff-line-modified-removed">- import com.sun.source.tree.CaseTree.CaseKind;</span>
<span class="udiff-line-modified-added">+ import com.sun.source.tree.CaseTree;</span>
  import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  import com.sun.source.tree.ModuleTree.ModuleKind;
  
  import com.sun.tools.javac.code.*;
  import com.sun.tools.javac.code.Source.Feature;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180,10 +180,14 @@</span>
          this.parseModuleInfo = parseModuleInfo;
          docComments = newDocCommentTable(keepDocComments, fac);
          this.keepLineMap = keepLineMap;
          this.errorTree = F.Erroneous();
          endPosTable = newEndPosTable(keepEndPositions);
<span class="udiff-line-added">+         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;</span>
<span class="udiff-line-added">+                 Feature.SWITCH_EXPRESSION.allowedInSource(source);</span>
<span class="udiff-line-added">+         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;</span>
<span class="udiff-line-added">+                 Feature.RECORDS.allowedInSource(source);</span>
      }
  
      protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
          return  keepEndPositions
                  ? new SimpleEndPosTable(this)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -209,10 +213,18 @@</span>
      /** Switch: is &quot;this&quot; allowed as an identifier?
       * This is needed to parse receiver types.
       */
      boolean allowThisIdent;
  
<span class="udiff-line-added">+     /** Switch: is yield statement allowed in this source level?</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     boolean allowYieldStatement;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Switch: are records allowed in this source level?</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     boolean allowRecords;</span>
<span class="udiff-line-added">+ </span>
      /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
       */
      JCVariableDecl receiverParam;
  
      /** When terms are parsed, the mode determines which is expected:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -767,13 +779,14 @@</span>
          return result;
      }
  
      public JCExpression unannotatedType(boolean allowVar) {
          JCExpression result = term(TYPE);
<span class="udiff-line-added">+         Name restrictedTypeName = restrictedTypeName(result, !allowVar);</span>
  
<span class="udiff-line-modified-removed">-         if (!allowVar &amp;&amp; isRestrictedLocalVarTypeName(result, true)) {</span>
<span class="udiff-line-modified-removed">-             syntaxError(result.pos, Errors.VarNotAllowedHere);</span>
<span class="udiff-line-modified-added">+         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {</span>
<span class="udiff-line-modified-added">+             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));</span>
          }
  
          return result;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -884,10 +897,11 @@</span>
          }
      }
  
      /*  Expression2Rest = {infixop Expression3}
       *                  | Expression3 instanceof Type
<span class="udiff-line-added">+      *                  | Expression3 instanceof Pattern</span>
       *  infixop         = &quot;||&quot;
       *                  | &quot;&amp;&amp;&quot;
       *                  | &quot;|&quot;
       *                  | &quot;^&quot;
       *                  | &quot;&amp;&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -906,17 +920,28 @@</span>
          odStack[0] = t;
          int startPos = token.pos;
          Token topOp = Tokens.DUMMY;
          while (prec(token.kind) &gt;= minprec) {
              opStack[top] = topOp;
<span class="udiff-line-modified-removed">-             top++;</span>
<span class="udiff-line-modified-removed">-             topOp = token;</span>
<span class="udiff-line-modified-removed">-             nextToken();</span>
<span class="udiff-line-modified-removed">-             odStack[top] = (topOp.kind == INSTANCEOF) ? parseType() : term3();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             if (token.kind == INSTANCEOF) {</span>
<span class="udiff-line-modified-added">+                 int pos = token.pos;</span>
<span class="udiff-line-modified-added">+                 nextToken();</span>
<span class="udiff-line-added">+                 JCTree pattern = parseType();</span>
<span class="udiff-line-added">+                 if (token.kind == IDENTIFIER) {</span>
<span class="udiff-line-added">+                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);</span>
<span class="udiff-line-added">+                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 topOp = token;</span>
<span class="udiff-line-added">+                 nextToken();</span>
<span class="udiff-line-added">+                 top++;</span>
<span class="udiff-line-added">+                 odStack[top] = term3();</span>
<span class="udiff-line-added">+             }</span>
              while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
<span class="udiff-line-modified-removed">-                 odStack[top-1] = makeOp(topOp.pos, topOp.kind, odStack[top-1],</span>
<span class="udiff-line-removed">-                                         odStack[top]);</span>
<span class="udiff-line-modified-added">+                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);</span>
                  top--;
                  topOp = opStack[top];
              }
          }
          Assert.check(top == 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -929,23 +954,10 @@</span>
          odStackSupply.add(odStack);
          opStackSupply.add(opStack);
          return t;
      }
      //where
<span class="udiff-line-removed">-         /** Construct a binary or type test node.</span>
<span class="udiff-line-removed">-          */</span>
<span class="udiff-line-removed">-         private JCExpression makeOp(int pos,</span>
<span class="udiff-line-removed">-                                     TokenKind topOp,</span>
<span class="udiff-line-removed">-                                     JCExpression od1,</span>
<span class="udiff-line-removed">-                                     JCExpression od2)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             if (topOp == INSTANCEOF) {</span>
<span class="udiff-line-removed">-                 return F.at(pos).TypeTest(od1, od2);</span>
<span class="udiff-line-removed">-             } else {</span>
<span class="udiff-line-removed">-                 return F.at(pos).Binary(optag(topOp), od1, od2);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
          /** If tree is a concatenation of string literals, replace it
           *  by a single literal representing the concatenated string.
           */
          protected JCExpression foldStrings(JCExpression tree) {
              if (!allowStringFolding)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1375,10 +1387,11 @@</span>
                  //return illegal();
              }
              break;
          case SWITCH:
              checkSourceLevel(Feature.SWITCH_EXPRESSION);
<span class="udiff-line-added">+             allowYieldStatement = true;</span>
              int switchPos = token.pos;
              nextToken();
              JCExpression selector = parExpression();
              accept(LBRACE);
              ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1422,23 +1435,22 @@</span>
                  nextToken();
              };
          }
          List&lt;JCStatement&gt; stats = null;
          JCTree body = null;
<span class="udiff-line-modified-removed">-         @SuppressWarnings(&quot;removal&quot;)</span>
<span class="udiff-line-removed">-         CaseKind kind;</span>
<span class="udiff-line-modified-added">+         CaseTree.CaseKind kind;</span>
          switch (token.kind) {
              case ARROW:
                  checkSourceLevel(Feature.SWITCH_RULE);
                  nextToken();
                  if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
                      stats = List.of(parseStatement());
                      body = stats.head;
                      kind = JCCase.RULE;
                  } else {
                      JCExpression value = parseExpression();
<span class="udiff-line-modified-removed">-                     stats = List.of(to(F.at(value).Break(value)));</span>
<span class="udiff-line-modified-added">+                     stats = List.of(to(F.at(value).Yield(value)));</span>
                      body = value;
                      kind = JCCase.RULE;
                      accept(SEMI);
                  }
                  break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1605,11 +1617,11 @@</span>
      @SuppressWarnings(&quot;fallthrough&quot;)
      ParensResult analyzeParens() {
          int depth = 0;
          boolean type = false;
          ParensResult defaultResult = ParensResult.PARENS;
<span class="udiff-line-modified-removed">-         outer: for (int lookahead = 0 ; ; lookahead++) {</span>
<span class="udiff-line-modified-added">+         outer: for (int lookahead = 0; ; lookahead++) {</span>
              TokenKind tk = S.token(lookahead).kind;
              switch (tk) {
                  case COMMA:
                      type = true;
                  case EXTENDS: case SUPER: case DOT: case AMP:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1653,10 +1665,11 @@</span>
                          case LPAREN: case THIS: case SUPER:
                          case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
                          case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
                          case TRUE: case FALSE: case NULL:
                          case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
<span class="udiff-line-added">+                         case SWITCH:</span>
                          case BYTE: case SHORT: case CHAR: case INT:
                          case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
                              return ParensResult.CAST;
                          default:
                              return defaultResult;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1774,21 +1787,22 @@</span>
          PARENS
      }
  
      JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
          List&lt;JCVariableDecl&gt; params = explicitParams ?
<span class="udiff-line-modified-removed">-                 formalParameters(true) :</span>
<span class="udiff-line-modified-added">+                 formalParameters(true, false) :</span>
                  implicitParameters(hasParens);
          if (explicitParams) {
              LambdaClassifier lambdaClassifier = new LambdaClassifier();
              for (JCVariableDecl param: params) {
<span class="udiff-line-added">+                 Name restrictedTypeName;</span>
                  if (param.vartype != null &amp;&amp;
<span class="udiff-line-modified-removed">-                         isRestrictedLocalVarTypeName(param.vartype, false) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;</span>
                          param.vartype.hasTag(TYPEARRAY)) {
                      log.error(DiagnosticFlag.SYNTAX, param.pos,
                          Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
<span class="udiff-line-modified-removed">-                             ? Errors.VarNotAllowedArray : Errors.VarNotAllowedHere);</span>
<span class="udiff-line-modified-added">+                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));</span>
                  }
                  lambdaClassifier.addParameter(param);
                  if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
                      break;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1796,11 +1810,11 @@</span>
              if (lambdaClassifier.diagFragment != null) {
                  log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
              }
              for (JCVariableDecl param: params) {
                  if (param.vartype != null
<span class="udiff-line-modified-removed">-                         &amp;&amp; isRestrictedLocalVarTypeName(param.vartype, true)) {</span>
<span class="udiff-line-modified-added">+                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {</span>
                      checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
                      param.startPos = TreeInfo.getStartPos(param.vartype);
                      param.vartype = null;
                  }
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1834,11 +1848,11 @@</span>
          Fragment diagFragment;
          List&lt;JCVariableDecl&gt; params;
  
          void addParameter(JCVariableDecl param) {
              if (param.vartype != null &amp;&amp; param.name != names.empty) {
<span class="udiff-line-modified-removed">-                 if (isRestrictedLocalVarTypeName(param.vartype, false)) {</span>
<span class="udiff-line-modified-added">+                 if (restrictedTypeName(param.vartype, false) != null) {</span>
                      reduce(LambdaParameterKind.VAR);
                  } else {
                      reduce(LambdaParameterKind.EXPLICIT);
                  }
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1941,14 +1955,31 @@</span>
              syntaxError(token.pos, Errors.Expected(LPAREN));
          }
          return args.toList();
      }
  
<span class="udiff-line-modified-removed">-     JCMethodInvocation arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {</span>
<span class="udiff-line-modified-added">+     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {</span>
          int pos = token.pos;
          List&lt;JCExpression&gt; args = arguments();
<span class="udiff-line-modified-removed">-         return toP(F.at(pos).Apply(typeArgs, t, args));</span>
<span class="udiff-line-modified-added">+         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);</span>
<span class="udiff-line-added">+         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,</span>
<span class="udiff-line-added">+                                                                     ((JCIdent) t).name)) {</span>
<span class="udiff-line-added">+             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);</span>
<span class="udiff-line-added">+             mi = F.Erroneous(List.of(mi));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return toP(mi);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {</span>
<span class="udiff-line-added">+         if (name == names.yield) {</span>
<span class="udiff-line-added">+             if (allowYieldStatement) {</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 log.warning(pos, Warnings.InvalidYield);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return false;</span>
      }
  
      /**  TypeArgumentsOpt = [ TypeArguments ]
       */
      JCExpression typeArgumentsOpt(JCExpression t) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2371,11 +2402,11 @@</span>
      {
          List&lt;JCExpression&gt; args = arguments();
          JCClassDecl body = null;
          if (token.kind == LBRACE) {
              int pos = token.pos;
<span class="udiff-line-modified-removed">-             List&lt;JCTree&gt; defs = classOrInterfaceBody(names.empty, false);</span>
<span class="udiff-line-modified-added">+             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);</span>
              JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
              body = toP(F.at(pos).AnonymousClassDef(mods, defs));
          }
          return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2503,12 +2534,14 @@</span>
          }
      }
  
      /**This method parses a statement appearing inside a block.
       */
<span class="udiff-line-added">+     @SuppressWarnings(&quot;fallthrough&quot;)</span>
      List&lt;JCStatement&gt; blockStatement() {
          //todo: skip to anchor on error(?)
<span class="udiff-line-added">+         Comment dc;</span>
          int pos = token.pos;
          switch (token.kind) {
          case RBRACE: case CASE: case DEFAULT: case EOF:
              return List.nil();
          case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2516,35 +2549,86 @@</span>
          case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
          case ASSERT:
              return List.of(parseSimpleStatement());
          case MONKEYS_AT:
          case FINAL: {
<span class="udiff-line-modified-removed">-             Comment dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="udiff-line-modified-added">+             dc = token.comment(CommentStyle.JAVADOC);</span>
              JCModifiers mods = modifiersOpt();
              if (token.kind == INTERFACE ||
                  token.kind == CLASS ||
<span class="udiff-line-modified-removed">-                 token.kind == ENUM) {</span>
<span class="udiff-line-modified-removed">-                 return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</span>
<span class="udiff-line-modified-added">+                 token.kind == ENUM ||</span>
<span class="udiff-line-modified-added">+                 isRecordStart()) {</span>
<span class="udiff-line-added">+                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));</span>
              } else {
                  JCExpression t = parseType(true);
                  return localVariableDeclarations(mods, t);
              }
          }
          case ABSTRACT: case STRICTFP: {
<span class="udiff-line-modified-removed">-             Comment dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="udiff-line-modified-added">+             dc = token.comment(CommentStyle.JAVADOC);</span>
              JCModifiers mods = modifiersOpt();
<span class="udiff-line-modified-removed">-             return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</span>
<span class="udiff-line-modified-added">+             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));</span>
          }
          case INTERFACE:
          case CLASS:
<span class="udiff-line-modified-removed">-             Comment dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="udiff-line-modified-removed">-             return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
<span class="udiff-line-modified-added">+             dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="udiff-line-modified-added">+             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
          case ENUM:
              log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
              dc = token.comment(CommentStyle.JAVADOC);
<span class="udiff-line-modified-removed">-             return List.of(classOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
<span class="udiff-line-modified-removed">-         default:</span>
<span class="udiff-line-modified-added">+             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));</span>
<span class="udiff-line-modified-added">+         case IDENTIFIER:</span>
<span class="udiff-line-added">+             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {</span>
<span class="udiff-line-added">+                 Token next = S.token(1);</span>
<span class="udiff-line-added">+                 boolean isYieldStatement;</span>
<span class="udiff-line-added">+                 switch (next.kind) {</span>
<span class="udiff-line-added">+                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:</span>
<span class="udiff-line-added">+                     case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
<span class="udiff-line-added">+                     case NULL: case IDENTIFIER: case TRUE: case FALSE:</span>
<span class="udiff-line-added">+                     case NEW: case SWITCH: case THIS: case SUPER:</span>
<span class="udiff-line-added">+                         isYieldStatement = true;</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     case PLUSPLUS: case SUBSUB:</span>
<span class="udiff-line-added">+                         isYieldStatement = S.token(2).kind != SEMI;</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     case LPAREN:</span>
<span class="udiff-line-added">+                         int lookahead = 2;</span>
<span class="udiff-line-added">+                         int balance = 1;</span>
<span class="udiff-line-added">+                         boolean hasComma = false;</span>
<span class="udiff-line-added">+                         Token l;</span>
<span class="udiff-line-added">+                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {</span>
<span class="udiff-line-added">+                             switch (l.kind) {</span>
<span class="udiff-line-added">+                                 case LPAREN: balance++; break;</span>
<span class="udiff-line-added">+                                 case RPAREN: balance--; break;</span>
<span class="udiff-line-added">+                                 case COMMA: if (balance == 1) hasComma = true; break;</span>
<span class="udiff-line-added">+                             }</span>
<span class="udiff-line-added">+                             lookahead++;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     case SEMI: //error recovery - this is not a valid statement:</span>
<span class="udiff-line-added">+                         isYieldStatement = true;</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     default:</span>
<span class="udiff-line-added">+                         isYieldStatement = false;</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (isYieldStatement) {</span>
<span class="udiff-line-added">+                     nextToken();</span>
<span class="udiff-line-added">+                     JCExpression t = term(EXPR);</span>
<span class="udiff-line-added">+                     accept(SEMI);</span>
<span class="udiff-line-added">+                     return List.of(toP(F.at(pos).Yield(t)));</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 //else intentional fall-through</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (isRecordStart() &amp;&amp; allowRecords) {</span>
<span class="udiff-line-added">+             dc = token.comment(CommentStyle.JAVADOC);</span>
<span class="udiff-line-added">+             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));</span>
<span class="udiff-line-added">+         } else {</span>
              Token prevToken = token;
              JCExpression t = term(EXPR | TYPE);
              if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
                  nextToken();
                  JCStatement stat = parseStatementAsBlock();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2699,13 +2783,13 @@</span>
              JCThrow t = toP(F.at(pos).Throw(exc));
              return t;
          }
          case BREAK: {
              nextToken();
<span class="udiff-line-modified-removed">-             JCExpression value = token.kind == SEMI ? null : parseExpression();</span>
<span class="udiff-line-modified-added">+             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;</span>
              accept(SEMI);
<span class="udiff-line-modified-removed">-             JCBreak t = toP(F.at(pos).Break(value));</span>
<span class="udiff-line-modified-added">+             JCBreak t = toP(F.at(pos).Break(label));</span>
              return t;
          }
          case CONTINUE: {
              nextToken();
              Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2821,12 +2905,11 @@</span>
                  pats.append(term(EXPR | NOLAMBDA));
                  if (token.kind != COMMA) break;
                  nextToken();
                  checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
              };
<span class="udiff-line-modified-removed">-             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="udiff-line-removed">-             CaseKind caseKind;</span>
<span class="udiff-line-modified-added">+             CaseTree.CaseKind caseKind;</span>
              JCTree body = null;
              if (token.kind == ARROW) {
                  checkSourceLevel(Feature.SWITCH_RULE);
                  accept(ARROW);
                  caseKind = JCCase.RULE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2846,12 +2929,11 @@</span>
                  storeEnd(c, S.prevToken().endPos);
              return cases.append(c).toList();
          }
          case DEFAULT: {
              nextToken();
<span class="udiff-line-modified-removed">-             @SuppressWarnings(&quot;removal&quot;)</span>
<span class="udiff-line-removed">-             CaseKind caseKind;</span>
<span class="udiff-line-modified-added">+             CaseTree.CaseKind caseKind;</span>
              JCTree body = null;
              if (token.kind == ARROW) {
                  checkSourceLevel(Feature.SWITCH_RULE);
                  accept(ARROW);
                  caseKind = JCCase.RULE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3178,18 +3260,18 @@</span>
          else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
          JCTree elemType = TreeInfo.innermostType(type, true);
          int startPos = Position.NOPOS;
          if (elemType.hasTag(IDENT)) {
              Name typeName = ((JCIdent)elemType).name;
<span class="udiff-line-modified-removed">-             if (isRestrictedLocalVarTypeName(typeName, pos, !compound &amp;&amp; localDecl)) {</span>
<span class="udiff-line-modified-added">+             if (isRestrictedTypeName(typeName, pos, !compound &amp;&amp; localDecl)) {</span>
                  if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
                      //error - &#39;var&#39; and arrays
<span class="udiff-line-modified-removed">-                     reportSyntaxError(pos, Errors.VarNotAllowedArray);</span>
<span class="udiff-line-modified-added">+                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));</span>
                  } else {
                      if(compound)
                          //error - &#39;var&#39; in compound local var decl
<span class="udiff-line-modified-removed">-                         reportSyntaxError(pos, Errors.VarNotAllowedCompound);</span>
<span class="udiff-line-modified-added">+                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));</span>
                      startPos = TreeInfo.getStartPos(mods);
                      if (startPos == Position.NOPOS)
                          startPos = TreeInfo.getStartPos(type);
                      //implicit type
                      type = null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3201,27 +3283,41 @@</span>
          attach(result, dc);
          result.startPos = startPos;
          return result;
      }
  
<span class="udiff-line-modified-removed">-     boolean isRestrictedLocalVarTypeName(JCExpression e, boolean shouldWarn) {</span>
<span class="udiff-line-modified-added">+     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {</span>
          switch (e.getTag()) {
              case IDENT:
<span class="udiff-line-modified-removed">-                 return isRestrictedLocalVarTypeName(((JCIdent)e).name, e.pos, shouldWarn);</span>
<span class="udiff-line-modified-added">+                 return isRestrictedTypeName(((JCIdent)e).name, e.pos, shouldWarn) ? ((JCIdent)e).name : null;</span>
              case TYPEARRAY:
<span class="udiff-line-modified-removed">-                 return isRestrictedLocalVarTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);</span>
<span class="udiff-line-modified-added">+                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);</span>
              default:
<span class="udiff-line-modified-removed">-                 return false;</span>
<span class="udiff-line-modified-added">+                 return null;</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     boolean isRestrictedLocalVarTypeName(Name name, int pos, boolean shouldWarn) {</span>
<span class="udiff-line-modified-added">+     boolean isRestrictedTypeName(Name name, int pos, boolean shouldWarn) {</span>
          if (name == names.var) {
              if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
                  return true;
              } else if (shouldWarn) {
<span class="udiff-line-modified-removed">-                 log.warning(pos, Warnings.VarNotAllowed);</span>
<span class="udiff-line-modified-added">+                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (name == names.yield) {</span>
<span class="udiff-line-added">+             if (allowYieldStatement) {</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             } else if (shouldWarn) {</span>
<span class="udiff-line-added">+                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (name == names.record) {</span>
<span class="udiff-line-added">+             if (allowRecords) {</span>
<span class="udiff-line-added">+                 return true;</span>
<span class="udiff-line-added">+             } else if (shouldWarn) {</span>
<span class="udiff-line-added">+                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));</span>
              }
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3275,10 +3371,11 @@</span>
          if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
                  token.kind == LBRACKET) {
              log.error(token.pos, Errors.VarargsAndOldArraySyntax);
          }
          type = bracketsOpt(type);
<span class="udiff-line-added">+ </span>
          return toP(F.at(pos).VarDef(mods, name, type, null));
      }
  
      /** Resources = Resource { &quot;;&quot; Resources }
       */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3544,42 +3641,54 @@</span>
          int pos = token.pos;
          if (mods == null &amp;&amp; token.kind == SEMI) {
              nextToken();
              return toP(F.at(pos).Skip());
          } else {
<span class="udiff-line-modified-removed">-             return classOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);</span>
<span class="udiff-line-modified-added">+             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);</span>
          }
      }
  
      /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
       *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
       *  @param mods     Any modifiers starting the class or interface declaration
       *  @param dc       The documentation comment for the class, or null.
       */
<span class="udiff-line-modified-removed">-     protected JCStatement classOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {</span>
<span class="udiff-line-modified-added">+     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {</span>
          if (token.kind == CLASS) {
              return classDeclaration(mods, dc);
<span class="udiff-line-added">+         } if (isRecordStart()) {</span>
<span class="udiff-line-added">+             return recordDeclaration(mods, dc);</span>
          } else if (token.kind == INTERFACE) {
              return interfaceDeclaration(mods, dc);
          } else if (token.kind == ENUM) {
              return enumDeclaration(mods, dc);
          } else {
              int pos = token.pos;
              List&lt;JCTree&gt; errs;
<span class="udiff-line-modified-removed">-             if (LAX_IDENTIFIER.accepts(token.kind)) {</span>
<span class="udiff-line-modified-removed">-                 errs = List.of(mods, toP(F.at(pos).Ident(ident())));</span>
<span class="udiff-line-modified-removed">-                 setErrorEndPos(token.pos);</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-removed">-                 errs = List.of(mods);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             final JCErroneous erroneousTree;</span>
<span class="udiff-line-removed">-             if (parseModuleInfo) {</span>
<span class="udiff-line-removed">-                 erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);</span>
<span class="udiff-line-modified-added">+             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {</span>
<span class="udiff-line-modified-added">+                 checkSourceLevel(Feature.RECORDS);</span>
<span class="udiff-line-modified-added">+                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);</span>
<span class="udiff-line-modified-added">+                 return toP(F.Exec(erroneousTree));</span>
              } else {
<span class="udiff-line-modified-removed">-                 erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));</span>
<span class="udiff-line-modified-added">+                 if (LAX_IDENTIFIER.accepts(token.kind)) {</span>
<span class="udiff-line-added">+                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));</span>
<span class="udiff-line-added">+                     setErrorEndPos(token.pos);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     errs = List.of(mods);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 final JCErroneous erroneousTree;</span>
<span class="udiff-line-added">+                 if (parseModuleInfo) {</span>
<span class="udiff-line-added">+                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     if (allowRecords) {</span>
<span class="udiff-line-added">+                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));</span>
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return toP(F.Exec(erroneousTree));</span>
              }
<span class="udiff-line-removed">-             return toP(F.Exec(erroneousTree));</span>
          }
      }
  
      /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
       *                     [IMPLEMENTS TypeList] ClassBody
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3601,22 +3710,66 @@</span>
          List&lt;JCExpression&gt; implementing = List.nil();
          if (token.kind == IMPLEMENTS) {
              nextToken();
              implementing = typeList();
          }
<span class="udiff-line-modified-removed">-         List&lt;JCTree&gt; defs = classOrInterfaceBody(name, false);</span>
<span class="udiff-line-modified-added">+         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);</span>
          JCClassDecl result = toP(F.at(pos).ClassDef(
              mods, name, typarams, extending, implementing, defs));
          attach(result, dc);
          return result;
      }
  
<span class="udiff-line-added">+     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {</span>
<span class="udiff-line-added">+         int pos = token.pos;</span>
<span class="udiff-line-added">+         nextToken();</span>
<span class="udiff-line-added">+         mods.flags |= Flags.RECORD;</span>
<span class="udiff-line-added">+         Name name = typeName();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         List&lt;JCExpression&gt; implementing = List.nil();</span>
<span class="udiff-line-added">+         if (token.kind == IMPLEMENTS) {</span>
<span class="udiff-line-added">+             nextToken();</span>
<span class="udiff-line-added">+             implementing = typeList();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);</span>
<span class="udiff-line-added">+         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-added">+         for (JCVariableDecl field : headerFields) {</span>
<span class="udiff-line-added">+             fields.add(field);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         for (JCTree def : defs) {</span>
<span class="udiff-line-added">+             if (def.hasTag(METHODDEF)) {</span>
<span class="udiff-line-added">+                 JCMethodDecl methDef = (JCMethodDecl) def;</span>
<span class="udiff-line-added">+                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {</span>
<span class="udiff-line-added">+                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();</span>
<span class="udiff-line-added">+                     for (JCVariableDecl param : headerFields) {</span>
<span class="udiff-line-added">+                         tmpParams.add(F.at(param)</span>
<span class="udiff-line-added">+                                 // we will get flags plus annotations from the record component</span>
<span class="udiff-line-added">+                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),</span>
<span class="udiff-line-added">+                                 param.name, param.vartype, null));</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     methDef.params = tmpParams.toList();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         for (int i = fields.size() - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-added">+             JCVariableDecl field = fields.get(i);</span>
<span class="udiff-line-added">+             defs = defs.prepend(field);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));</span>
<span class="udiff-line-added">+         attach(result, dc);</span>
<span class="udiff-line-added">+         return result;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      Name typeName() {
          int pos = token.pos;
          Name name = ident();
<span class="udiff-line-modified-removed">-         if (isRestrictedLocalVarTypeName(name, pos, true)) {</span>
<span class="udiff-line-modified-removed">-             reportSyntaxError(pos, Errors.VarNotAllowed);</span>
<span class="udiff-line-modified-added">+         if (isRestrictedTypeName(name, pos, true)) {</span>
<span class="udiff-line-modified-added">+             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, name == names.var ? Source.JDK10 : Source.JDK13));</span>
          }
          return name;
      }
  
      /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3635,11 +3788,11 @@</span>
          List&lt;JCExpression&gt; extending = List.nil();
          if (token.kind == EXTENDS) {
              nextToken();
              extending = typeList();
          }
<span class="udiff-line-modified-removed">-         List&lt;JCTree&gt; defs = classOrInterfaceBody(name, true);</span>
<span class="udiff-line-modified-added">+         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);</span>
          JCClassDecl result = toP(F.at(pos).ClassDef(
              mods, name, typarams, null, extending, defs));
          attach(result, dc);
          return result;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3673,39 +3826,97 @@</span>
       *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
       */
      List&lt;JCTree&gt; enumBody(Name enumName) {
          accept(LBRACE);
          ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
<span class="udiff-line-added">+         boolean wasSemi = false;</span>
<span class="udiff-line-added">+         boolean hasStructuralErrors = false;</span>
<span class="udiff-line-added">+         boolean wasError = false;</span>
          if (token.kind == COMMA) {
              nextToken();
<span class="udiff-line-modified-removed">-         } else if (token.kind != RBRACE &amp;&amp; token.kind != SEMI) {</span>
<span class="udiff-line-modified-removed">-             defs.append(enumeratorDeclaration(enumName));</span>
<span class="udiff-line-removed">-             while (token.kind == COMMA) {</span>
<span class="udiff-line-removed">-                 nextToken();</span>
<span class="udiff-line-removed">-                 if (token.kind == RBRACE || token.kind == SEMI) break;</span>
<span class="udiff-line-removed">-                 defs.append(enumeratorDeclaration(enumName));</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (token.kind != SEMI &amp;&amp; token.kind != RBRACE) {</span>
<span class="udiff-line-removed">-                 defs.append(syntaxError(token.pos, Errors.Expected3(COMMA, RBRACE, SEMI)));</span>
<span class="udiff-line-modified-added">+             if (token.kind == SEMI) {</span>
<span class="udiff-line-modified-added">+                 wasSemi = true;</span>
                  nextToken();
<span class="udiff-line-added">+             } else if (token.kind != RBRACE) {</span>
<span class="udiff-line-added">+                 reportSyntaxError(S.prevToken().endPos,</span>
<span class="udiff-line-added">+                                   Errors.Expected2(RBRACE, SEMI));</span>
<span class="udiff-line-added">+                 wasError = true;</span>
              }
          }
<span class="udiff-line-modified-removed">-         if (token.kind == SEMI) {</span>
<span class="udiff-line-modified-removed">-             nextToken();</span>
<span class="udiff-line-modified-removed">-             while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {</span>
<span class="udiff-line-modified-removed">-                 defs.appendList(classOrInterfaceBodyDeclaration(enumName,</span>
<span class="udiff-line-modified-removed">-                                                                 false));</span>
<span class="udiff-line-modified-added">+         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {</span>
<span class="udiff-line-modified-added">+             if (token.kind == SEMI) {</span>
<span class="udiff-line-modified-added">+                 accept(SEMI);</span>
<span class="udiff-line-modified-added">+                 wasSemi = true;</span>
<span class="udiff-line-modified-added">+                 if (token.kind == RBRACE || token.kind == EOF) break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);</span>
<span class="udiff-line-added">+             if (memberType == EnumeratorEstimate.UNKNOWN) {</span>
<span class="udiff-line-added">+                 memberType = wasSemi ? EnumeratorEstimate.MEMBER</span>
<span class="udiff-line-added">+                                      : EnumeratorEstimate.ENUMERATOR;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (memberType == EnumeratorEstimate.ENUMERATOR) {</span>
<span class="udiff-line-added">+                 wasError = false;</span>
<span class="udiff-line-added">+                 if (wasSemi &amp;&amp; !hasStructuralErrors) {</span>
<span class="udiff-line-added">+                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);</span>
<span class="udiff-line-added">+                     hasStructuralErrors = true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 defs.append(enumeratorDeclaration(enumName));</span>
<span class="udiff-line-added">+                 if (token.pos &lt;= endPosTable.errorEndPos) {</span>
<span class="udiff-line-added">+                     // error recovery</span>
<span class="udiff-line-added">+                    skip(false, true, true, false);</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {</span>
<span class="udiff-line-added">+                         if (token.kind == COMMA) {</span>
<span class="udiff-line-added">+                             nextToken();</span>
<span class="udiff-line-added">+                         } else {</span>
<span class="udiff-line-added">+                             setErrorEndPos(token.pos);</span>
<span class="udiff-line-added">+                             reportSyntaxError(S.prevToken().endPos,</span>
<span class="udiff-line-added">+                                               Errors.Expected3(COMMA, RBRACE, SEMI));</span>
<span class="udiff-line-added">+                             wasError = true;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {</span>
<span class="udiff-line-added">+                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);</span>
<span class="udiff-line-added">+                     hasStructuralErrors = true;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 wasError = false;</span>
<span class="udiff-line-added">+                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,</span>
<span class="udiff-line-added">+                                                                 false, false));</span>
                  if (token.pos &lt;= endPosTable.errorEndPos) {
                      // error recovery
                     skip(false, true, true, false);
                  }
              }
          }
          accept(RBRACE);
          return defs.toList();
      }
  
<span class="udiff-line-added">+     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {</span>
<span class="udiff-line-added">+         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {</span>
<span class="udiff-line-added">+             Token next = S.token(1);</span>
<span class="udiff-line-added">+             switch (next.kind) {</span>
<span class="udiff-line-added">+                 case LPAREN: case LBRACE: case COMMA: case SEMI:</span>
<span class="udiff-line-added">+                     return EnumeratorEstimate.ENUMERATOR;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         switch (token.kind) {</span>
<span class="udiff-line-added">+             case IDENTIFIER: case MONKEYS_AT: case LT:</span>
<span class="udiff-line-added">+                 return EnumeratorEstimate.UNKNOWN;</span>
<span class="udiff-line-added">+             default:</span>
<span class="udiff-line-added">+                 return EnumeratorEstimate.MEMBER;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private enum EnumeratorEstimate {</span>
<span class="udiff-line-added">+         ENUMERATOR,</span>
<span class="udiff-line-added">+         MEMBER,</span>
<span class="udiff-line-added">+         UNKNOWN;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
       */
      JCTree enumeratorDeclaration(Name enumName) {
          Comment dc = token.comment(CommentStyle.JAVADOC);
          int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3722,11 +3933,11 @@</span>
          List&lt;JCExpression&gt; args = (token.kind == LPAREN)
              ? arguments() : List.nil();
          JCClassDecl body = null;
          if (token.kind == LBRACE) {
              JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
<span class="udiff-line-modified-removed">-             List&lt;JCTree&gt; defs = classOrInterfaceBody(names.empty, false);</span>
<span class="udiff-line-modified-added">+             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);</span>
              body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
          }
          if (args.isEmpty() &amp;&amp; body == null)
              createPos = identPos;
          JCIdent ident = F.at(identPos).Ident(enumName);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3752,21 +3963,21 @@</span>
      }
  
      /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
       *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
       */
<span class="udiff-line-modified-removed">-     List&lt;JCTree&gt; classOrInterfaceBody(Name className, boolean isInterface) {</span>
<span class="udiff-line-modified-added">+     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {</span>
          accept(LBRACE);
          if (token.pos &lt;= endPosTable.errorEndPos) {
              // error recovery
              skip(false, true, false, false);
              if (token.kind == LBRACE)
                  nextToken();
          }
          ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
          while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
<span class="udiff-line-modified-removed">-             defs.appendList(classOrInterfaceBodyDeclaration(className, isInterface));</span>
<span class="udiff-line-modified-added">+             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));</span>
              if (token.pos &lt;= endPosTable.errorEndPos) {
                 // error recovery
                 skip(false, true, true, false);
             }
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3801,27 +4012,30 @@</span>
       *        )
       *      | ClassOrInterfaceOrEnumDeclaration
       *      )
       *
       */
<span class="udiff-line-modified-removed">-     protected List&lt;JCTree&gt; classOrInterfaceBodyDeclaration(Name className, boolean isInterface) {</span>
<span class="udiff-line-modified-added">+     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {</span>
          if (token.kind == SEMI) {
              nextToken();
              return List.nil();
          } else {
              Comment dc = token.comment(CommentStyle.JAVADOC);
              int pos = token.pos;
              JCModifiers mods = modifiersOpt();
              if (token.kind == CLASS ||
<span class="udiff-line-added">+                 allowRecords &amp;&amp; isRecordStart() ||</span>
                  token.kind == INTERFACE ||
                  token.kind == ENUM) {
<span class="udiff-line-modified-removed">-                 return List.of(classOrInterfaceOrEnumDeclaration(mods, dc));</span>
<span class="udiff-line-modified-added">+                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));</span>
              } else if (token.kind == LBRACE &amp;&amp;
                         (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
                         mods.annotations.isEmpty()) {
                  if (isInterface) {
                      log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
<span class="udiff-line-added">+                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {</span>
<span class="udiff-line-added">+                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);</span>
                  }
                  return List.of(block(pos, mods.flags));
              } else {
                  pos = token.pos;
                  List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3849,32 +4063,55 @@</span>
                      nextToken();
                  } else {
                      // method returns types are un-annotated types
                      type = unannotatedType(false);
                  }
<span class="udiff-line-modified-removed">-                 if (token.kind == LPAREN &amp;&amp; !isInterface &amp;&amp; type.hasTag(IDENT)) {</span>
<span class="udiff-line-modified-added">+                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||</span>
<span class="udiff-line-added">+                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {</span>
                      if (isInterface || tk.name() != className)
                          log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
                      else if (annosAfterParams.nonEmpty())
                          illegal(annosAfterParams.head.pos);
<span class="udiff-line-added">+                     if (isRecord &amp;&amp; token.kind == LBRACE) {</span>
<span class="udiff-line-added">+                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;</span>
<span class="udiff-line-added">+                     }</span>
                      return List.of(methodDeclaratorRest(
                          pos, mods, null, names.init, typarams,
<span class="udiff-line-modified-removed">-                         isInterface, true, dc));</span>
<span class="udiff-line-modified-added">+                         isInterface, true, isRecord, dc));</span>
<span class="udiff-line-added">+                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {</span>
<span class="udiff-line-added">+                     // trying to define a compact constructor with a throws clause</span>
<span class="udiff-line-added">+                     log.error(DiagnosticFlag.SYNTAX, token.pos,</span>
<span class="udiff-line-added">+                             Errors.InvalidCanonicalConstructorInRecord(</span>
<span class="udiff-line-added">+                                     Fragments.Compact,</span>
<span class="udiff-line-added">+                                     className,</span>
<span class="udiff-line-added">+                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));</span>
<span class="udiff-line-added">+                     skip(false, true, false, false);</span>
<span class="udiff-line-added">+                     return List.of(methodDeclaratorRest(</span>
<span class="udiff-line-added">+                             pos, mods, null, names.init, typarams,</span>
<span class="udiff-line-added">+                             isInterface, true, isRecord, dc));</span>
                  } else {
                      pos = token.pos;
                      Name name = ident();
                      if (token.kind == LPAREN) {
                          return List.of(methodDeclaratorRest(
                              pos, mods, type, name, typarams,
<span class="udiff-line-modified-removed">-                             isInterface, isVoid, dc));</span>
<span class="udiff-line-modified-added">+                             isInterface, isVoid, false, dc));</span>
                      } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
<span class="udiff-line-added">+                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {</span>
                          List&lt;JCTree&gt; defs =
                              variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
                                                      new ListBuffer&lt;JCTree&gt;(), false).toList();
                          accept(SEMI);
                          storeEnd(defs.last(), S.prevToken().endPos);
                          return defs;
<span class="udiff-line-added">+                     } else {</span>
<span class="udiff-line-added">+                             int errPos = pos;</span>
<span class="udiff-line-added">+                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,</span>
<span class="udiff-line-added">+                                     new ListBuffer&lt;JCTree&gt;(), false).toList();</span>
<span class="udiff-line-added">+                             accept(SEMI);</span>
<span class="udiff-line-added">+                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));</span>
<span class="udiff-line-added">+                         }</span>
                      } else {
                          pos = token.pos;
                          List&lt;JCTree&gt; err;
                          if (isVoid || typarams.nonEmpty()) {
                              JCMethodDecl m =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3890,10 +4127,22 @@</span>
                  }
              }
          }
      }
  
<span class="udiff-line-added">+     protected boolean isRecordStart() {</span>
<span class="udiff-line-added">+      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;</span>
<span class="udiff-line-added">+             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||</span>
<span class="udiff-line-added">+              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||</span>
<span class="udiff-line-added">+              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {</span>
<span class="udiff-line-added">+           checkSourceLevel(Feature.RECORDS);</span>
<span class="udiff-line-added">+           return true;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+        return false;</span>
<span class="udiff-line-added">+    }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
      /** MethodDeclaratorRest =
       *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
       *  VoidMethodDeclaratorRest =
       *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
       *  ConstructorDeclaratorRest =
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3903,10 +4152,11 @@</span>
                                JCModifiers mods,
                                JCExpression type,
                                Name name,
                                List&lt;JCTypeParameter&gt; typarams,
                                boolean isInterface, boolean isVoid,
<span class="udiff-line-added">+                               boolean isRecord,</span>
                                Comment dc) {
          if (isInterface) {
              if ((mods.flags &amp; Flags.STATIC) != 0) {
                  checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3916,16 +4166,19 @@</span>
          }
          JCVariableDecl prevReceiverParam = this.receiverParam;
          try {
              this.receiverParam = null;
              // Parsing formalParameters sets the receiverParam, if present
<span class="udiff-line-modified-removed">-             List&lt;JCVariableDecl&gt; params = formalParameters();</span>
<span class="udiff-line-removed">-             if (!isVoid) type = bracketsOpt(type);</span>
<span class="udiff-line-modified-added">+             List&lt;JCVariableDecl&gt; params = List.nil();</span>
              List&lt;JCExpression&gt; thrown = List.nil();
<span class="udiff-line-modified-removed">-             if (token.kind == THROWS) {</span>
<span class="udiff-line-modified-removed">-                 nextToken();</span>
<span class="udiff-line-modified-removed">-                 thrown = qualidentList(true);</span>
<span class="udiff-line-modified-added">+             if (!isRecord || name != names.init || token.kind == LPAREN) {</span>
<span class="udiff-line-modified-added">+                 params = formalParameters();</span>
<span class="udiff-line-modified-added">+                 if (!isVoid) type = bracketsOpt(type);</span>
<span class="udiff-line-added">+                 if (token.kind == THROWS) {</span>
<span class="udiff-line-added">+                     nextToken();</span>
<span class="udiff-line-added">+                     thrown = qualidentList(true);</span>
<span class="udiff-line-added">+                 }</span>
              }
              JCBlock body = null;
              JCExpression defaultValue;
              if (token.kind == LBRACE) {
                  body = block();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4033,19 +4286,19 @@</span>
      /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
       *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
       *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
       */
      List&lt;JCVariableDecl&gt; formalParameters() {
<span class="udiff-line-modified-removed">-         return formalParameters(false);</span>
<span class="udiff-line-modified-added">+         return formalParameters(false, false);</span>
      }
<span class="udiff-line-modified-removed">-     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters) {</span>
<span class="udiff-line-modified-added">+     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {</span>
          ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
          JCVariableDecl lastParam;
          accept(LPAREN);
          if (token.kind != RPAREN) {
<span class="udiff-line-modified-removed">-             this.allowThisIdent = !lambdaParameters;</span>
<span class="udiff-line-modified-removed">-             lastParam = formalParameter(lambdaParameters);</span>
<span class="udiff-line-modified-added">+             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;</span>
<span class="udiff-line-modified-added">+             lastParam = formalParameter(lambdaParameters, recordComponents);</span>
              if (lastParam.nameexpr != null) {
                  this.receiverParam = lastParam;
              } else {
                  params.append(lastParam);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4053,11 +4306,11 @@</span>
              while (token.kind == COMMA) {
                  if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
                      log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
                  }
                  nextToken();
<span class="udiff-line-modified-removed">-                 params.append(lastParam = formalParameter(lambdaParameters));</span>
<span class="udiff-line-modified-added">+                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));</span>
              }
          }
          if (token.kind == RPAREN) {
              nextToken();
          } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4164,15 +4417,18 @@</span>
      }
  
      /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
       *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
       */
<span class="udiff-line-modified-removed">-     protected JCVariableDecl formalParameter() {</span>
<span class="udiff-line-modified-removed">-         return formalParameter(false);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     protected JCVariableDecl formalParameter(boolean lambdaParameter) {</span>
<span class="udiff-line-modified-removed">-         JCModifiers mods = optFinal(Flags.PARAMETER);</span>
<span class="udiff-line-modified-added">+     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {</span>
<span class="udiff-line-modified-added">+         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();</span>
<span class="udiff-line-modified-added">+         if (recordComponent &amp;&amp; mods.flags != 0) {</span>
<span class="udiff-line-modified-added">+             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-added">+         if (recordComponent) {</span>
<span class="udiff-line-added">+             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;</span>
<span class="udiff-line-added">+         }</span>
          // need to distinguish between vararg annos and array annos
          // look at typeAnnotationsPushedBack comment
          this.permitTypeAnnotationsPushBack = true;
          JCExpression type = parseType(lambdaParameter);
          this.permitTypeAnnotationsPushBack = false;
</pre>
<center><a href="JavaTokenizer.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lexer.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
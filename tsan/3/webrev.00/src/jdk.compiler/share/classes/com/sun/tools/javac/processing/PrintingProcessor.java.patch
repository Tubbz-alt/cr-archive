diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/processing/PrintingProcessor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -37,10 +37,12 @@
 
 import java.io.PrintWriter;
 import java.io.Writer;
 import java.util.*;
 import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
 
 import com.sun.tools.javac.util.DefinedBy;
 import com.sun.tools.javac.util.DefinedBy.Api;
 import com.sun.tools.javac.util.StringUtils;
 
@@ -53,11 +55,11 @@
  * If you write code that depends on this, you do so at your own risk.
  * This code and its internal interfaces are subject to change or
  * deletion without notice.</b>
  */
 @SupportedAnnotationTypes("*")
-@SupportedSourceVersion(SourceVersion.RELEASE_13)
+@SupportedSourceVersion(SourceVersion.RELEASE_15)
 public class PrintingProcessor extends AbstractProcessor {
     PrintWriter writer;
 
     public PrintingProcessor() {
         super();
@@ -86,12 +88,13 @@
     }
 
     /**
      * Used for the -Xprint option and called by Elements.printElements
      */
+    @SuppressWarnings("preview")
     public static class PrintingElementVisitor
-        extends SimpleElementVisitor9<PrintingElementVisitor, Boolean> {
+        extends SimpleElementVisitor14<PrintingElementVisitor, Boolean> {
         int indentation; // Indentation level;
         final PrintWriter writer;
         final Elements elementUtils;
 
         public PrintingElementVisitor(Writer w, Elements elementUtils) {
@@ -108,10 +111,17 @@
             printDocComment(e);
             printModifiers(e);
             return this;
         }
 
+        @Override @DefinedBy(Api.LANGUAGE_MODEL)
+        public PrintingElementVisitor visitRecordComponent(RecordComponentElement e, Boolean p) {
+                // Do nothing; printing of component information done by
+                // printing the record type itself
+            return this;
+        }
+
         @Override @DefinedBy(Api.LANGUAGE_MODEL)
         public PrintingElementVisitor visitExecutable(ExecutableElement e, Boolean p) {
             ElementKind kind = e.getKind();
 
             if (kind != STATIC_INIT &&
@@ -121,11 +131,11 @@
                 // Don't print out the constructor of an anonymous class
                 if (kind == CONSTRUCTOR &&
                     enclosing != null &&
                     NestingKind.ANONYMOUS ==
                     // Use an anonymous class to determine anonymity!
-                    (new SimpleElementVisitor9<NestingKind, Void>() {
+                    (new SimpleElementVisitor14<NestingKind, Void>() {
                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
                         public NestingKind visitType(TypeElement e, Void p) {
                             return e.getNestingKind();
                         }
                     }).visit(enclosing))
@@ -214,10 +224,20 @@
                 writer.print(" ");
                 writer.print(e.getSimpleName());
 
                 printFormalTypeParameters(e, false);
 
+                if (kind == RECORD) {
+                    // Print out record components
+                    writer.print("(");
+                    writer.print(e.getRecordComponents()
+                                 .stream()
+                                 .map(recordDes -> recordDes.asType().toString() + " " + recordDes.getSimpleName())
+                                 .collect(Collectors.joining(", ")));
+                    writer.print(")");
+                }
+
                 // Print superclass information if informative
                 if (kind == CLASS) {
                     TypeMirror supertype = e.getSuperclass();
                     if (supertype.getKind() != TypeKind.NONE) {
                         TypeElement e2 = (TypeElement)
@@ -253,11 +273,17 @@
                 }
 
                 for(Element element : enclosedElements)
                     this.visit(element);
             } else {
-                for(Element element : e.getEnclosedElements())
+                for(Element element :
+                        (kind != RECORD ?
+                         e.getEnclosedElements() :
+                         e.getEnclosedElements()
+                         .stream()
+                         .filter(elt -> elementUtils.getOrigin(elt) == Elements.Origin.EXPLICIT )
+                         .collect(Collectors.toList()) ) )
                     this.visit(element);
             }
 
             indentation--;
             indent();
@@ -422,11 +448,12 @@
         }
 
         private void printModifiers(Element e) {
             ElementKind kind = e.getKind();
             if (kind == PARAMETER) {
-                printAnnotationsInline(e);
+                // Print annotation inline
+                writer.print(annotationsToString(e));
             } else {
                 printAnnotations(e);
                 indent();
             }
 
@@ -445,10 +472,14 @@
             case ENUM:
                 modifiers.remove(Modifier.FINAL);
                 modifiers.remove(Modifier.ABSTRACT);
                 break;
 
+            case RECORD:
+                modifiers.remove(Modifier.FINAL);
+                break;
+
             case METHOD:
             case FIELD:
                 Element enclosingElement = e.getEnclosingElement();
                 if (enclosingElement != null &&
                     enclosingElement.getKind().isInterface()) {
@@ -458,43 +489,36 @@
                     modifiers.remove(Modifier.FINAL);    // only for fields
                 }
                 break;
 
             }
-
-            for(Modifier m: modifiers) {
-                writer.print(m.toString() + " ");
+            if (!modifiers.isEmpty()) {
+                writer.print(modifiers.stream()
+                             .map(Modifier::toString)
+                             .collect(Collectors.joining(" ", "", " ")));
             }
         }
 
         private void printFormalTypeParameters(Parameterizable e,
                                                boolean pad) {
             List<? extends TypeParameterElement> typeParams = e.getTypeParameters();
-            if (typeParams.size() > 0) {
-                writer.print("<");
-
-                boolean first = true;
-                for(TypeParameterElement tpe: typeParams) {
-                    if (!first)
-                        writer.print(", ");
-                    printAnnotationsInline(tpe);
-                    writer.print(tpe.toString());
-                    first = false;
-                }
-
-                writer.print(">");
+            if (!typeParams.isEmpty()) {
+                writer.print(typeParams.stream()
+                             .map(tpe -> annotationsToString(tpe) + tpe.toString())
+                             .collect(Collectors.joining(", ", "<", ">")));
                 if (pad)
                     writer.print(" ");
             }
         }
 
-        private void printAnnotationsInline(Element e) {
-            List<? extends AnnotationMirror> annots = e.getAnnotationMirrors();
-            for(AnnotationMirror annotationMirror : annots) {
-                writer.print(annotationMirror);
-                writer.print(" ");
-            }
+        private String annotationsToString(Element e) {
+            List<? extends AnnotationMirror> annotations = e.getAnnotationMirrors();
+            return annotations.isEmpty() ?
+                "" :
+                annotations.stream()
+                .map(AnnotationMirror::toString)
+                .collect(Collectors.joining(" ", "", " "));
         }
 
         private void printAnnotations(Element e) {
             List<? extends AnnotationMirror> annots = e.getAnnotationMirrors();
             for(AnnotationMirror annotationMirror : annots) {
@@ -567,21 +591,15 @@
         private void printInterfaces(TypeElement e) {
             ElementKind kind = e.getKind();
 
             if(kind != ANNOTATION_TYPE) {
                 List<? extends TypeMirror> interfaces = e.getInterfaces();
-                if (interfaces.size() > 0) {
-                    writer.print((kind.isClass() ? " implements" : " extends"));
-
-                    boolean first = true;
-                    for(TypeMirror interf: interfaces) {
-                        if (!first)
-                            writer.print(",");
-                        writer.print(" ");
-                        writer.print(interf.toString());
-                        first = false;
-                    }
+                if (!interfaces.isEmpty()) {
+                    writer.print((kind.isClass() ? " implements " : " extends "));
+                    writer.print(interfaces.stream()
+                                 .map(TypeMirror::toString)
+                                 .collect(Collectors.joining(", ")));
                 }
             }
         }
 
         private void printThrows(ExecutableElement e) {

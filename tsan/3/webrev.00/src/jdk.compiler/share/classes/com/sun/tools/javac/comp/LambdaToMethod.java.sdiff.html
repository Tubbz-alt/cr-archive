<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InferenceContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lower.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 

  28 import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;

  29 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  30 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  31 import com.sun.tools.javac.tree.*;
  32 import com.sun.tools.javac.tree.JCTree.*;
  33 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  34 import com.sun.tools.javac.tree.TreeMaker;
  35 import com.sun.tools.javac.tree.TreeTranslator;
  36 import com.sun.tools.javac.code.Attribute;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Symbol;
  39 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  40 import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;
  41 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  42 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  43 import com.sun.tools.javac.code.Symbol.VarSymbol;
  44 import com.sun.tools.javac.code.Symtab;
  45 import com.sun.tools.javac.code.Type;
  46 import com.sun.tools.javac.code.Type.MethodType;
  47 import com.sun.tools.javac.code.Type.TypeVar;
  48 import com.sun.tools.javac.code.Types;
  49 import com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.*;
  50 import com.sun.tools.javac.comp.Lower.BasicFreeVarCollector;
  51 import com.sun.tools.javac.resources.CompilerProperties.Notes;
  52 import com.sun.tools.javac.jvm.*;
  53 import com.sun.tools.javac.util.*;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  56 
  57 import java.util.EnumMap;
  58 import java.util.HashMap;
  59 import java.util.HashSet;
  60 import java.util.LinkedHashMap;
  61 import java.util.Map;
<span class="line-removed">  62 import java.util.Objects;</span>
  63 import java.util.Optional;
  64 import java.util.Set;
  65 import java.util.function.Consumer;
  66 import java.util.function.Supplier;
  67 
  68 import static com.sun.tools.javac.comp.LambdaToMethod.LambdaSymbolKind.*;
  69 import static com.sun.tools.javac.code.Flags.*;
  70 import static com.sun.tools.javac.code.Kinds.Kind.*;
  71 import static com.sun.tools.javac.code.TypeTag.*;
  72 import static com.sun.tools.javac.tree.JCTree.Tag.*;
<span class="line-removed">  73 import static com.sun.tools.javac.jvm.Pool.DynamicMethod;</span>
  74 
  75 import javax.lang.model.element.ElementKind;
  76 import javax.lang.model.type.TypeKind;
  77 
<span class="line-removed">  78 import com.sun.tools.javac.code.Type.IntersectionClassType;</span>
<span class="line-removed">  79 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;</span>
  80 import com.sun.tools.javac.main.Option;
  81 
  82 /**
  83  * This pass desugars lambda expressions into static methods
  84  *
  85  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  86  *  If you write code that depends on this, you do so at your own risk.
  87  *  This code and its internal interfaces are subject to change or
  88  *  deletion without notice.&lt;/b&gt;
  89  */
  90 public class LambdaToMethod extends TreeTranslator {
  91 
  92     private Attr attr;
  93     private JCDiagnostic.Factory diags;
  94     private Log log;
  95     private Lower lower;
  96     private Names names;
  97     private Symtab syms;
  98     private Resolve rs;
  99     private Operators operators;
</pre>
<hr />
<pre>
 197         @Override
 198         public boolean equals(Object o) {
 199             if (!(o instanceof DedupedLambda)) {
 200                 return false;
 201             }
 202             DedupedLambda that = (DedupedLambda) o;
 203             return types.isSameType(symbol.asType(), that.symbol.asType())
 204                     &amp;&amp; new TreeDiffer(symbol.params(), that.symbol.params()).scan(tree, that.tree);
 205         }
 206     }
 207 
 208     private class KlassInfo {
 209 
 210         /**
 211          * list of methods to append
 212          */
 213         private ListBuffer&lt;JCTree&gt; appendedMethodList;
 214 
 215         private Map&lt;DedupedLambda, DedupedLambda&gt; dedupedLambdas;
 216 
<span class="line-modified"> 217         private Map&lt;DynamicMethod, DynamicMethodSymbol&gt; dynMethSyms = new HashMap&lt;&gt;();</span>
 218 
 219         /**
 220          * list of deserialization cases
 221          */
 222         private final Map&lt;String, ListBuffer&lt;JCStatement&gt;&gt; deserializeCases;
 223 
 224        /**
 225          * deserialize method symbol
 226          */
 227         private final MethodSymbol deserMethodSym;
 228 
 229         /**
 230          * deserialize method parameter symbol
 231          */
 232         private final VarSymbol deserParamSym;
 233 
 234         private final JCClassDecl clazz;
 235 
 236         private KlassInfo(JCClassDecl clazz) {
 237             this.clazz = clazz;
</pre>
<hr />
<pre>
 366             }
 367         }
 368 
 369         //create the method declaration hoisting the lambda body
 370         JCMethodDecl lambdaDecl = make.MethodDef(make.Modifiers(sym.flags_field),
 371                 sym.name,
 372                 make.QualIdent(lambdaType.getReturnType().tsym),
 373                 List.nil(),
 374                 localContext.syntheticParams,
 375                 lambdaType.getThrownTypes() == null ?
 376                     List.nil() :
 377                     make.Types(lambdaType.getThrownTypes()),
 378                 null,
 379                 null);
 380         lambdaDecl.sym = sym;
 381         lambdaDecl.type = lambdaType;
 382 
 383         //translate lambda body
 384         //As the lambda body is translated, all references to lambda locals,
 385         //captured variables, enclosing members are adjusted accordingly
<span class="line-modified"> 386         //to refer to the static method parameters (rather than i.e. acessing to</span>
 387         //captured members directly).
 388         lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));
 389 
 390         boolean dedupe = false;
 391         if (deduplicateLambdas &amp;&amp; !debugLinesOrVars &amp;&amp; !localContext.isSerializable()) {
 392             DedupedLambda dedupedLambda = new DedupedLambda(lambdaDecl.sym, lambdaDecl.body);
 393             DedupedLambda existing = kInfo.dedupedLambdas.putIfAbsent(dedupedLambda, dedupedLambda);
 394             if (existing != null) {
 395                 sym = existing.symbol;
 396                 dedupe = true;
 397                 if (verboseDeduplication) log.note(tree, Notes.VerboseL2mDeduplicate(sym));
 398             }
 399         }
 400         if (!dedupe) {
 401             //Add the method to the list of methods to be added to this class.
 402             kInfo.addMethod(lambdaDecl);
 403         }
 404 
 405         //now that we have generated a method for the lambda expression,
 406         //we can translate the lambda into a method reference pointing to the newly
</pre>
<hr />
<pre>
 422                     sym.owner.enclClass().asType(),
 423                     localContext.owner.enclClass()));
 424         }
 425 
 426         //add captured locals
 427         for (Symbol fv : localContext.getSymbolMap(CAPTURED_VAR).keySet()) {
 428             if (fv != localContext.self) {
 429                 JCTree captured_local = make.Ident(fv).setType(fv.type);
 430                 syntheticInits.append((JCExpression) captured_local);
 431             }
 432         }
 433         // add captured outer this instances (used only when `this&#39; capture itself is illegal)
 434         for (Symbol fv : localContext.getSymbolMap(CAPTURED_OUTER_THIS).keySet()) {
 435             JCTree captured_local = make.QualThis(fv.type);
 436             syntheticInits.append((JCExpression) captured_local);
 437         }
 438 
 439         //then, determine the arguments to the indy call
 440         List&lt;JCExpression&gt; indy_args = translate(syntheticInits.toList(), localContext.prev);
 441 
<span class="line-removed"> 442         //build a sam instance using an indy call to the meta-factory</span>
<span class="line-removed"> 443         int refKind = referenceKind(sym);</span>
<span class="line-removed"> 444 </span>
 445         //convert to an invokedynamic call
<span class="line-modified"> 446         result = makeMetafactoryIndyCall(context, refKind, sym, indy_args);</span>
 447     }
 448 
 449     // where
 450         // Reassign type annotations from the source that should really belong to the lambda
 451         private void apportionTypeAnnotations(JCLambda tree,
 452                                               Supplier&lt;List&lt;Attribute.TypeCompound&gt;&gt; source,
 453                                               Consumer&lt;List&lt;Attribute.TypeCompound&gt;&gt; owner,
 454                                               Consumer&lt;List&lt;Attribute.TypeCompound&gt;&gt; lambda) {
 455 
 456             ListBuffer&lt;Attribute.TypeCompound&gt; ownerTypeAnnos = new ListBuffer&lt;&gt;();
 457             ListBuffer&lt;Attribute.TypeCompound&gt; lambdaTypeAnnos = new ListBuffer&lt;&gt;();
 458 
 459             for (Attribute.TypeCompound tc : source.get()) {
 460                 if (tc.position.onLambda == tree) {
 461                     lambdaTypeAnnos.append(tc);
 462                 } else {
 463                     ownerTypeAnnos.append(tc);
 464                 }
 465             }
 466             if (lambdaTypeAnnos.nonEmpty()) {
</pre>
<hr />
<pre>
 471 
 472     private JCIdent makeThis(Type type, Symbol owner) {
 473         VarSymbol _this = new VarSymbol(PARAMETER | FINAL | SYNTHETIC,
 474                 names._this,
 475                 type,
 476                 owner);
 477         return make.Ident(_this);
 478     }
 479 
 480     /**
 481      * Translate a method reference into an invokedynamic call to the
 482      * meta-factory.
 483      * @param tree
 484      */
 485     @Override
 486     public void visitReference(JCMemberReference tree) {
 487         ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;
 488 
 489         //first determine the method symbol to be used to generate the sam instance
 490         //this is either the method reference symbol, or the bridged reference symbol
<span class="line-modified"> 491         Symbol refSym = tree.sym;</span>
 492 
 493         //the qualifying expression is treated as a special captured arg
 494         JCExpression init;
 495         switch(tree.kind) {
 496 
 497             case IMPLICIT_INNER:    /** Inner :: new */
 498             case SUPER:             /** super :: instMethod */
 499                 init = makeThis(
 500                     localContext.owner.enclClass().asType(),
 501                     localContext.owner.enclClass());
 502                 break;
 503 
 504             case BOUND:             /** Expr :: instMethod */
 505                 init = transTypes.coerce(attrEnv, tree.getQualifierExpression(),
 506                     types.erasure(tree.sym.owner.type));
 507                 init = attr.makeNullCheck(init);
 508                 break;
 509 
 510             case UNBOUND:           /** Type :: instMethod */
 511             case STATIC:            /** Type :: staticMethod */
 512             case TOPLEVEL:          /** Top level :: new */
 513             case ARRAY_CTOR:        /** ArrayType :: new */
 514                 init = null;
 515                 break;
 516 
 517             default:
 518                 throw new InternalError(&quot;Should not have an invalid kind&quot;);
 519         }
 520 
 521         List&lt;JCExpression&gt; indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);
 522 
 523 
 524         //build a sam instance using an indy call to the meta-factory
<span class="line-modified"> 525         result = makeMetafactoryIndyCall(localContext, localContext.referenceKind(), refSym, indy_args);</span>
 526     }
 527 
 528     /**
 529      * Translate identifiers within a lambda to the mapped identifier
 530      * @param tree
 531      */
 532     @Override
 533     public void visitIdent(JCIdent tree) {
 534         if (context == null || !analyzer.lambdaIdentSymbolFilter(tree.sym)) {
 535             super.visitIdent(tree);
 536         } else {
 537             int prevPos = make.pos;
 538             try {
 539                 make.at(tree);
 540 
 541                 LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;
 542                 JCTree ltree = lambdaContext.translate(tree);
 543                 if (ltree != null) {
 544                     result = ltree;
 545                 } else {
</pre>
<hr />
<pre>
 591             int prevPos = make.pos;
 592             try {
 593                 make.at(tree);
 594 
 595                 LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;
 596                 tree = lambdaContext.translate(tree);
 597                 super.visitNewClass(tree);
 598             } finally {
 599                 make.at(prevPos);
 600             }
 601         }
 602     }
 603 
 604     @Override
 605     public void visitVarDef(JCVariableDecl tree) {
 606         LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context;
 607         if (context != null &amp;&amp; lambdaContext.getSymbolMap(LOCAL_VAR).containsKey(tree.sym)) {
 608             tree.init = translate(tree.init);
 609             tree.sym = (VarSymbol) lambdaContext.getSymbolMap(LOCAL_VAR).get(tree.sym);
 610             result = tree;
<span class="line-removed"> 611         } else if (context != null &amp;&amp; lambdaContext.getSymbolMap(TYPE_VAR).containsKey(tree.sym)) {</span>
<span class="line-removed"> 612             JCExpression init = translate(tree.init);</span>
<span class="line-removed"> 613             VarSymbol xsym = (VarSymbol)lambdaContext.getSymbolMap(TYPE_VAR).get(tree.sym);</span>
<span class="line-removed"> 614             int prevPos = make.pos;</span>
<span class="line-removed"> 615             try {</span>
<span class="line-removed"> 616                 result = make.at(tree).VarDef(xsym, init);</span>
<span class="line-removed"> 617             } finally {</span>
<span class="line-removed"> 618                 make.at(prevPos);</span>
<span class="line-removed"> 619             }</span>
<span class="line-removed"> 620             // Replace the entered symbol for this variable</span>
<span class="line-removed"> 621             WriteableScope sc = tree.sym.owner.members();</span>
<span class="line-removed"> 622             if (sc != null) {</span>
<span class="line-removed"> 623                 sc.remove(tree.sym);</span>
<span class="line-removed"> 624                 sc.enter(xsym);</span>
<span class="line-removed"> 625             }</span>
 626         } else {
 627             super.visitVarDef(tree);
 628         }
 629     }
 630 
 631     // &lt;/editor-fold&gt;
 632 
 633     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Translation helper methods&quot;&gt;
 634 
 635     private JCBlock makeLambdaBody(JCLambda tree, JCMethodDecl lambdaMethodDecl) {
 636         return tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
 637                 makeLambdaExpressionBody((JCExpression)tree.body, lambdaMethodDecl) :
 638                 makeLambdaStatementBody((JCBlock)tree.body, lambdaMethodDecl, tree.canCompleteNormally);
 639     }
 640 
 641     private JCBlock makeLambdaExpressionBody(JCExpression expr, JCMethodDecl lambdaMethodDecl) {
 642         Type restype = lambdaMethodDecl.type.getReturnType();
 643         boolean isLambda_void = expr.type.hasTag(VOID);
 644         boolean isTarget_void = restype.hasTag(VOID);
 645         boolean isTarget_Void = types.isSameType(restype, types.boxedClass(syms.voidType).type);
</pre>
<hr />
<pre>
 748      *  @param args     The constructor arguments.
 749      *  @param cons     The constructor symbol
 750      */
 751     JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args, Symbol cons) {
 752         JCNewClass tree = make.NewClass(null,
 753             null, make.QualIdent(ctype.tsym), args, null);
 754         tree.constructor = cons;
 755         tree.type = ctype;
 756         return tree;
 757     }
 758 
 759     /** Make an attributed class instance creation expression.
 760      *  @param ctype    The class type.
 761      *  @param args     The constructor arguments.
 762      */
 763     JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
 764         return makeNewClass(ctype, args,
 765                 rs.resolveConstructor(null, attrEnv, ctype, TreeInfo.types(args), List.nil()));
 766      }
 767 
<span class="line-modified"> 768     private void addDeserializationCase(int implMethodKind, Symbol refSym, Type targetType, MethodSymbol samSym,</span>
<span class="line-modified"> 769             DiagnosticPosition pos, List&lt;Object&gt; staticArgs, MethodType indyType) {</span>
 770         String functionalInterfaceClass = classSig(targetType);
 771         String functionalInterfaceMethodName = samSym.getSimpleName().toString();
 772         String functionalInterfaceMethodSignature = typeSig(types.erasure(samSym.type));
 773         String implClass = classSig(types.erasure(refSym.owner.type));
 774         String implMethodName = refSym.getQualifiedName().toString();
 775         String implMethodSignature = typeSig(types.erasure(refSym.type));
 776 
<span class="line-modified"> 777         JCExpression kindTest = eqTest(syms.intType, deserGetter(&quot;getImplMethodKind&quot;, syms.intType), make.Literal(implMethodKind));</span>

 778         ListBuffer&lt;JCExpression&gt; serArgs = new ListBuffer&lt;&gt;();
 779         int i = 0;
 780         for (Type t : indyType.getParameterTypes()) {
 781             List&lt;JCExpression&gt; indexAsArg = new ListBuffer&lt;JCExpression&gt;().append(make.Literal(i)).toList();
 782             List&lt;Type&gt; argTypes = new ListBuffer&lt;Type&gt;().append(syms.intType).toList();
 783             serArgs.add(make.TypeCast(types.erasure(t), deserGetter(&quot;getCapturedArg&quot;, syms.objectType, argTypes, indexAsArg)));
 784             ++i;
 785         }
 786         JCStatement stmt = make.If(
 787                 deserTest(deserTest(deserTest(deserTest(deserTest(
 788                     kindTest,
 789                     &quot;getFunctionalInterfaceClass&quot;, functionalInterfaceClass),
 790                     &quot;getFunctionalInterfaceMethodName&quot;, functionalInterfaceMethodName),
 791                     &quot;getFunctionalInterfaceMethodSignature&quot;, functionalInterfaceMethodSignature),
 792                     &quot;getImplClass&quot;, implClass),
 793                     &quot;getImplMethodSignature&quot;, implMethodSignature),
 794                 make.Return(makeIndyCall(
 795                     pos,
 796                     syms.lambdaMetafactory,
 797                     names.altMetafactory,
</pre>
<hr />
<pre>
 965                     rcvr = null;
 966                     break;
 967             }
 968             List&lt;Type&gt; implPTypes = tree.sym.type.getParameterTypes();
 969             int implSize = implPTypes.size();
 970             int samSize = samPTypes.size();
 971             // Last parameter to copy from referenced method, exclude final var args
 972             int last = localContext.needsVarArgsConversion() ? implSize - 1 : implSize;
 973 
 974             // Failsafe -- assure match-up
 975             boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();
 976 
 977             // Use parameter types of the implementation method unless the unerased
 978             // SAM parameter type is an intersection type, in that case use the
 979             // erased SAM parameter type so that the supertype relationship
 980             // the implementation method parameters is not obscured.
 981             // Note: in this loop, the lists implPTypes, samPTypes, and descPTypes
 982             // are used as pointers to the current parameter type information
 983             // and are thus not usable afterwards.
 984             for (int i = 0; implPTypes.nonEmpty() &amp;&amp; i &lt; last; ++i) {
<span class="line-modified"> 985                 // By default use the implementation method parmeter type</span>
 986                 Type parmType = implPTypes.head;
 987                 // If the unerased parameter type is a type variable whose
 988                 // bound is an intersection (eg. &lt;T extends A &amp; B&gt;) then
 989                 // use the SAM parameter type
 990                 if (checkForIntersection &amp;&amp; descPTypes.head.getKind() == TypeKind.TYPEVAR) {
 991                     TypeVar tv = (TypeVar) descPTypes.head;
 992                     if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {
 993                         parmType = samPTypes.head;
 994                     }
 995                 }
 996                 addParameter(&quot;x$&quot; + i, parmType, true);
 997 
 998                 // Advance to the next parameter
 999                 implPTypes = implPTypes.tail;
1000                 samPTypes = samPTypes.tail;
1001                 descPTypes = descPTypes.tail;
1002             }
1003             // Flatten out the var args
1004             for (int i = last; i &lt; samSize; ++i) {
1005                 addParameter(&quot;xva$&quot; + i, tree.varargsElement, true);
</pre>
<hr />
<pre>
1089             params.append(make.VarDef(vsym, null));
1090             if (genArg) {
1091                 args.append(make.Ident(vsym));
1092             }
1093             return vsym;
1094         }
1095     }
1096 
1097     private MethodType typeToMethodType(Type mt) {
1098         Type type = types.erasure(mt);
1099         return new MethodType(type.getParameterTypes(),
1100                         type.getReturnType(),
1101                         type.getThrownTypes(),
1102                         syms.methodClass);
1103     }
1104 
1105     /**
1106      * Generate an indy method call to the meta factory
1107      */
1108     private JCExpression makeMetafactoryIndyCall(TranslationContext&lt;?&gt; context,
<span class="line-modified">1109             int refKind, Symbol refSym, List&lt;JCExpression&gt; indy_args) {</span>
1110         JCFunctionalExpression tree = context.tree;
1111         //determine the static bsm args
1112         MethodSymbol samSym = (MethodSymbol) types.findDescriptorSymbol(tree.target.tsym);
<span class="line-modified">1113         List&lt;Object&gt; staticArgs = List.of(</span>
1114                 typeToMethodType(samSym.type),
<span class="line-modified">1115                 new Pool.MethodHandle(refKind, refSym, types),</span>
1116                 typeToMethodType(tree.getDescriptorType(types)));
1117 
1118         //computed indy arg types
1119         ListBuffer&lt;Type&gt; indy_args_types = new ListBuffer&lt;&gt;();
1120         for (JCExpression arg : indy_args) {
1121             indy_args_types.append(arg.type);
1122         }
1123 
1124         //finally, compute the type of the indy call
1125         MethodType indyType = new MethodType(indy_args_types.toList(),
1126                 tree.type,
1127                 List.nil(),
1128                 syms.methodClass);
1129 
1130         Name metafactoryName = context.needsAltMetafactory() ?
1131                 names.altMetafactory : names.metafactory;
1132 
1133         if (context.needsAltMetafactory()) {
<span class="line-modified">1134             ListBuffer&lt;Object&gt; markers = new ListBuffer&lt;&gt;();</span>
1135             List&lt;Type&gt; targets = tree.target.isIntersection() ?
1136                     types.directSupertypes(tree.target) :
1137                     List.nil();
1138             for (Type t : targets) {
1139                 t = types.erasure(t);
1140                 if (t.tsym != syms.serializableType.tsym &amp;&amp;
1141                     t.tsym != tree.type.tsym &amp;&amp;
1142                     t.tsym != syms.objectType.tsym) {
<span class="line-modified">1143                     markers.append(t.tsym);</span>
1144                 }
1145             }
1146             int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;
1147             boolean hasMarkers = markers.nonEmpty();
1148             boolean hasBridges = context.bridges.nonEmpty();
1149             if (hasMarkers) {
1150                 flags |= FLAG_MARKERS;
1151             }
1152             if (hasBridges) {
1153                 flags |= FLAG_BRIDGES;
1154             }
<span class="line-modified">1155             staticArgs = staticArgs.append(flags);</span>
1156             if (hasMarkers) {
<span class="line-modified">1157                 staticArgs = staticArgs.append(markers.length());</span>
<span class="line-modified">1158                 staticArgs = staticArgs.appendList(markers.toList());</span>
1159             }
1160             if (hasBridges) {
<span class="line-modified">1161                 staticArgs = staticArgs.append(context.bridges.length() - 1);</span>
1162                 for (Symbol s : context.bridges) {
1163                     Type s_erasure = s.erasure(types);
1164                     if (!types.isSameType(s_erasure, samSym.erasure(types))) {
<span class="line-modified">1165                         staticArgs = staticArgs.append(s.erasure(types));</span>
1166                     }
1167                 }
1168             }
1169             if (context.isSerializable()) {
1170                 int prevPos = make.pos;
1171                 try {
1172                     make.at(kInfo.clazz);
<span class="line-modified">1173                     addDeserializationCase(refKind, refSym, tree.type, samSym,</span>
1174                             tree, staticArgs, indyType);
1175                 } finally {
1176                     make.at(prevPos);
1177                 }
1178             }
1179         }
1180 
1181         return makeIndyCall(tree, syms.lambdaMetafactory, metafactoryName, staticArgs, indyType, indy_args, samSym.name);
1182     }
1183 
1184     /**
1185      * Generate an indy method call with given name, type and static bootstrap
1186      * arguments types
1187      */
1188     private JCExpression makeIndyCall(DiagnosticPosition pos, Type site, Name bsmName,
<span class="line-modified">1189             List&lt;Object&gt; staticArgs, MethodType indyType, List&lt;JCExpression&gt; indyArgs,</span>
<span class="line-modified">1190             Name methName) {</span>
1191         int prevPos = make.pos;
1192         try {
1193             make.at(pos);
1194             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
<span class="line-modified">1195                     syms.stringType,</span>
<span class="line-modified">1196                     syms.methodTypeType).appendList(bsmStaticArgToTypes(staticArgs));</span>
1197 
1198             Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,
1199                     bsmName, bsm_staticArgs, List.nil());
1200 
1201             DynamicMethodSymbol dynSym =
1202                     new DynamicMethodSymbol(methName,
1203                                             syms.noSymbol,
<span class="line-modified">1204                                             bsm.isStatic() ?</span>
<span class="line-removed">1205                                                 ClassFile.REF_invokeStatic :</span>
<span class="line-removed">1206                                                 ClassFile.REF_invokeVirtual,</span>
<span class="line-removed">1207                                             (MethodSymbol)bsm,</span>
1208                                             indyType,
<span class="line-modified">1209                                             staticArgs.toArray());</span>
1210             JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), bsmName);
1211             DynamicMethodSymbol existing = kInfo.dynMethSyms.putIfAbsent(
<span class="line-modified">1212                     new DynamicMethod(dynSym, types), dynSym);</span>
1213             qualifier.sym = existing != null ? existing : dynSym;
1214             qualifier.type = indyType.getReturnType();
1215 
1216             JCMethodInvocation proxyCall = make.Apply(List.nil(), qualifier, indyArgs);
1217             proxyCall.type = indyType.getReturnType();
1218             return proxyCall;
1219         } finally {
1220             make.at(prevPos);
1221         }
1222     }
<span class="line-removed">1223     //where</span>
<span class="line-removed">1224     private List&lt;Type&gt; bsmStaticArgToTypes(List&lt;Object&gt; args) {</span>
<span class="line-removed">1225         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();</span>
<span class="line-removed">1226         for (Object arg : args) {</span>
<span class="line-removed">1227             argtypes.append(bsmStaticArgToType(arg));</span>
<span class="line-removed">1228         }</span>
<span class="line-removed">1229         return argtypes.toList();</span>
<span class="line-removed">1230     }</span>
<span class="line-removed">1231 </span>
<span class="line-removed">1232     private Type bsmStaticArgToType(Object arg) {</span>
<span class="line-removed">1233         Assert.checkNonNull(arg);</span>
<span class="line-removed">1234         if (arg instanceof ClassSymbol) {</span>
<span class="line-removed">1235             return syms.classType;</span>
<span class="line-removed">1236         } else if (arg instanceof Integer) {</span>
<span class="line-removed">1237             return syms.intType;</span>
<span class="line-removed">1238         } else if (arg instanceof Long) {</span>
<span class="line-removed">1239             return syms.longType;</span>
<span class="line-removed">1240         } else if (arg instanceof Float) {</span>
<span class="line-removed">1241             return syms.floatType;</span>
<span class="line-removed">1242         } else if (arg instanceof Double) {</span>
<span class="line-removed">1243             return syms.doubleType;</span>
<span class="line-removed">1244         } else if (arg instanceof String) {</span>
<span class="line-removed">1245             return syms.stringType;</span>
<span class="line-removed">1246         } else if (arg instanceof Pool.MethodHandle) {</span>
<span class="line-removed">1247             return syms.methodHandleType;</span>
<span class="line-removed">1248         } else if (arg instanceof MethodType) {</span>
<span class="line-removed">1249             return syms.methodTypeType;</span>
<span class="line-removed">1250         } else {</span>
<span class="line-removed">1251             Assert.error(&quot;bad static arg &quot; + arg.getClass());</span>
<span class="line-removed">1252             return null;</span>
<span class="line-removed">1253         }</span>
<span class="line-removed">1254     }</span>
<span class="line-removed">1255 </span>
<span class="line-removed">1256     /**</span>
<span class="line-removed">1257      * Get the opcode associated with this method reference</span>
<span class="line-removed">1258      */</span>
<span class="line-removed">1259     private int referenceKind(Symbol refSym) {</span>
<span class="line-removed">1260         if (refSym.isConstructor()) {</span>
<span class="line-removed">1261             return ClassFile.REF_newInvokeSpecial;</span>
<span class="line-removed">1262         } else {</span>
<span class="line-removed">1263             if (refSym.isStatic()) {</span>
<span class="line-removed">1264                 return ClassFile.REF_invokeStatic;</span>
<span class="line-removed">1265             } else if ((refSym.flags() &amp; PRIVATE) != 0) {</span>
<span class="line-removed">1266                 return ClassFile.REF_invokeSpecial;</span>
<span class="line-removed">1267             } else if (refSym.enclClass().isInterface()) {</span>
<span class="line-removed">1268                 return ClassFile.REF_invokeInterface;</span>
<span class="line-removed">1269             } else {</span>
<span class="line-removed">1270                 return ClassFile.REF_invokeVirtual;</span>
<span class="line-removed">1271             }</span>
<span class="line-removed">1272         }</span>
<span class="line-removed">1273     }</span>
1274 
1275     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Lambda/reference analyzer&quot;&gt;
1276     /**
1277      * This visitor collects information about translation of a lambda expression.
1278      * More specifically, it keeps track of the enclosing contexts and captured locals
1279      * accessed by the lambda being translated (as well as other useful info).
1280      * It also translates away problems for LambdaToMethod.
1281      */
1282     class LambdaAnalyzerPreprocessor extends TreeTranslator {
1283 
1284         /** the frame stack - used to reconstruct translation info about enclosing scopes */
1285         private List&lt;Frame&gt; frameStack;
1286 
1287         /**
1288          * keep the count of lambda expression (used to generate unambiguous
1289          * names)
1290          */
1291         private int lambdaCount = 0;
1292 
1293         /**
</pre>
<hr />
<pre>
1613                     }
1614                     localContext = localContext.prev;
1615                 }
1616             }
1617             super.visitSelect(tree);
1618         }
1619 
1620         @Override
1621         public void visitVarDef(JCVariableDecl tree) {
1622             TranslationContext&lt;?&gt; context = context();
1623             LambdaTranslationContext ltc = (context != null &amp;&amp; context instanceof LambdaTranslationContext)?
1624                     (LambdaTranslationContext)context :
1625                     null;
1626             if (ltc != null) {
1627                 if (frameStack.head.tree.hasTag(LAMBDA)) {
1628                     ltc.addSymbol(tree.sym, LOCAL_VAR);
1629                 }
1630                 // Check for type variables (including as type arguments).
1631                 // If they occur within class nested in a lambda, mark for erasure
1632                 Type type = tree.sym.asType();
<span class="line-removed">1633                 if (inClassWithinLambda() &amp;&amp; !types.isSameType(types.erasure(type), type)) {</span>
<span class="line-removed">1634                     ltc.addSymbol(tree.sym, TYPE_VAR);</span>
<span class="line-removed">1635                 }</span>
1636             }
1637 
1638             List&lt;Frame&gt; prevStack = frameStack;
1639             try {
1640                 if (tree.sym.owner.kind == MTH) {
1641                     frameStack.head.addLocal(tree.sym);
1642                 }
1643                 frameStack = frameStack.prepend(new Frame(tree));
1644                 super.visitVarDef(tree);
1645             }
1646             finally {
1647                 frameStack = prevStack;
1648             }
1649         }
1650 
1651         /**
1652          * Return a valid owner given the current declaration stack
1653          * (required to skip synthetic lambda symbols)
1654          */
1655         private Symbol owner() {
</pre>
<hr />
<pre>
1768             // No lambda
1769             return false;
1770         }
1771 
1772         /**
1773          * Return the declaration corresponding to a symbol in the enclosing
1774          * scope; the depth parameter is used to filter out symbols defined
1775          * in nested scopes (which do not need to undergo capture).
1776          */
1777         private JCTree capturedDecl(int depth, Symbol sym) {
1778             int currentDepth = frameStack.size() - 1;
1779             for (Frame block : frameStack) {
1780                 switch (block.tree.getTag()) {
1781                     case CLASSDEF:
1782                         ClassSymbol clazz = ((JCClassDecl)block.tree).sym;
1783                         if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {
1784                             return currentDepth &gt; depth ? null : block.tree;
1785                         }
1786                         break;
1787                     case VARDEF:
<span class="line-modified">1788                         if (((JCVariableDecl)block.tree).sym == sym &amp;&amp;</span>
<span class="line-modified">1789                                 sym.owner.kind == MTH) { //only locals are captured</span>

1790                             return currentDepth &gt; depth ? null : block.tree;
1791                         }
1792                         break;
1793                     case BLOCK:
1794                     case METHODDEF:
1795                     case LAMBDA:
1796                         if (block.locals != null &amp;&amp; block.locals.contains(sym)) {
1797                             return currentDepth &gt; depth ? null : block.tree;
1798                         }
1799                         break;
1800                     default:
1801                         Assert.error(&quot;bad decl kind &quot; + block.tree.getTag());
1802                 }
1803                 currentDepth--;
1804             }
1805             return null;
1806         }
1807 
1808         private TranslationContext&lt;?&gt; context() {
1809             for (Frame frame : frameStack) {
</pre>
<hr />
<pre>
1985              */
1986             JCExpression methodReferenceReceiver;
1987 
1988             LambdaTranslationContext(JCLambda tree) {
1989                 super(tree);
1990                 Frame frame = frameStack.head;
1991                 switch (frame.tree.getTag()) {
1992                     case VARDEF:
1993                         assignedTo = self = ((JCVariableDecl) frame.tree).sym;
1994                         break;
1995                     case ASSIGN:
1996                         self = null;
1997                         assignedTo = TreeInfo.symbol(((JCAssign) frame.tree).getVariable());
1998                         break;
1999                     default:
2000                         assignedTo = self = null;
2001                         break;
2002                  }
2003 
2004                 // This symbol will be filled-in in complete
<span class="line-modified">2005                 this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());</span>
<span class="line-modified">2006 </span>









2007                 translatedSymbols = new EnumMap&lt;&gt;(LambdaSymbolKind.class);
2008 
2009                 translatedSymbols.put(PARAM, new LinkedHashMap&lt;Symbol, Symbol&gt;());
2010                 translatedSymbols.put(LOCAL_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
2011                 translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
2012                 translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
2013                 translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
<span class="line-removed">2014                 translatedSymbols.put(TYPE_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());</span>
2015 
2016                 freeVarProcessedLocalClasses = new HashSet&lt;&gt;();
2017             }
2018 
2019              /**
2020              * For a serializable lambda, generate a disambiguating string
2021              * which maximizes stability across deserialization.
2022              *
2023              * @return String to differentiate synthetic lambda method names
2024              */
2025             private String serializedLambdaDisambiguation() {
2026                 StringBuilder buf = new StringBuilder();
2027                 // Append the enclosing method signature to differentiate
2028                 // overloaded enclosing methods.  For lambdas enclosed in
2029                 // lambdas, the generated lambda method will not have type yet,
2030                 // but the enclosing method&#39;s name will have been generated
2031                 // with this same method, so it will be unique and never be
2032                 // overloaded.
2033                 Assert.check(
2034                         owner.type != null ||
</pre>
<hr />
<pre>
2087                 buf.append(Integer.toHexString(disam.hashCode()));
2088                 buf.append(&#39;$&#39;);
2089                 // The above appended name components may not be unique, append
2090                 // a count based on the above name components.
2091                 buf.append(syntheticMethodNameCounts.getIndex(buf));
2092                 String result = buf.toString();
2093                 //System.err.printf(&quot;serializedLambdaName: %s -- %s\n&quot;, result, disam);
2094                 return names.fromString(result);
2095             }
2096 
2097             /**
2098              * Translate a symbol of a given kind into something suitable for the
2099              * synthetic lambda body
2100              */
2101             Symbol translate(final Symbol sym, LambdaSymbolKind skind) {
2102                 Symbol ret;
2103                 switch (skind) {
2104                     case CAPTURED_THIS:
2105                         ret = sym;  // self represented
2106                         break;
<span class="line-removed">2107                     case TYPE_VAR:</span>
<span class="line-removed">2108                         // Just erase the type var</span>
<span class="line-removed">2109                         ret = new VarSymbol(sym.flags(), sym.name,</span>
<span class="line-removed">2110                                 types.erasure(sym.type), sym.owner);</span>
<span class="line-removed">2111 </span>
<span class="line-removed">2112                         /* this information should also be kept for LVT generation at Gen</span>
<span class="line-removed">2113                          * a Symbol with pos &lt; startPos won&#39;t be tracked.</span>
<span class="line-removed">2114                          */</span>
<span class="line-removed">2115                         ((VarSymbol)ret).pos = ((VarSymbol)sym).pos;</span>
<span class="line-removed">2116                         break;</span>
2117                     case CAPTURED_VAR:
2118                         ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, sym.name, types.erasure(sym.type), translatedSym) {
2119                             @Override
2120                             public Symbol baseSymbol() {
2121                                 //keep mapping with original captured symbol
2122                                 return sym;
2123                             }
2124                         };
2125                         break;
2126                     case CAPTURED_OUTER_THIS:
2127                         Name name = names.fromString(new String(sym.flatName().toString().replace(&#39;.&#39;, &#39;$&#39;) + names.dollarThis));
2128                         ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym) {
2129                             @Override
2130                             public Symbol baseSymbol() {
2131                                 //keep mapping with original captured symbol
2132                                 return sym;
2133                             }
2134                         };
2135                         break;
2136                     case LOCAL_VAR:
</pre>
<hr />
<pre>
2295             Type generatedLambdaSig() {
2296                 return types.erasure(tree.getDescriptorType(types));
2297             }
2298         }
2299 
2300         /**
2301          * This class retains all the useful information about a method reference;
2302          * the contents of this class are filled by the LambdaAnalyzer visitor,
2303          * and the used by the main translation routines in order to adjust method
2304          * references (i.e. in case a bridge is needed)
2305          */
2306         final class ReferenceTranslationContext extends TranslationContext&lt;JCMemberReference&gt; {
2307 
2308             final boolean isSuper;
2309 
2310             ReferenceTranslationContext(JCMemberReference tree) {
2311                 super(tree);
2312                 this.isSuper = tree.hasKind(ReferenceKind.SUPER);
2313             }
2314 
<span class="line-removed">2315             /**</span>
<span class="line-removed">2316              * Get the opcode associated with this method reference</span>
<span class="line-removed">2317              */</span>
<span class="line-removed">2318             int referenceKind() {</span>
<span class="line-removed">2319                 return LambdaToMethod.this.referenceKind(tree.sym);</span>
<span class="line-removed">2320             }</span>
<span class="line-removed">2321 </span>
2322             boolean needsVarArgsConversion() {
2323                 return tree.varargsElement != null;
2324             }
2325 
2326             /**
2327              * @return Is this an array operation like clone()
2328              */
2329             boolean isArrayOp() {
2330                 return tree.sym.owner == syms.arrayClass;
2331             }
2332 
2333             boolean receiverAccessible() {
2334                 //hack needed to workaround 292 bug (7087658)
2335                 //when 292 issue is fixed we should remove this and change the backend
2336                 //code to always generate a method handle to an accessible method
2337                 return tree.ownerAccessible;
2338             }
2339 
2340             /**
2341              * The VM does not support access across nested classes (8010319).
2342              * Were that ever to change, this should be removed.
2343              */
2344             boolean isPrivateInOtherClass() {
2345                 return  (tree.sym.flags() &amp; PRIVATE) != 0 &amp;&amp;
2346                         !types.isSameType(
2347                               types.erasure(tree.sym.enclClass().asType()),
2348                               types.erasure(owner.enclClass().asType()));
2349             }
2350 
2351             boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
2352                 return ((tree.sym.flags() &amp; PROTECTED) != 0 &amp;&amp;
<span class="line-modified">2353                         tree.sym.packge() != owner.packge() &amp;&amp;</span>
<span class="line-removed">2354                         !owner.enclClass().isSubClass(tree.sym.owner, types));</span>
2355             }
2356 
2357             /**
2358              * Erasure destroys the implementation parameter subtype
2359              * relationship for intersection types.
2360              * Have similar problems for union types too.
2361              */
2362             boolean interfaceParameterIsIntersectionOrUnionType() {
2363                 List&lt;Type&gt; tl = tree.getDescriptorType(types).getParameterTypes();
2364                 for (; tl.nonEmpty(); tl = tl.tail) {
2365                     Type pt = tl.head;
2366                     return isIntersectionOrUnionType(pt);
2367                 }
2368                 return false;
2369             }
2370 
2371             boolean isIntersectionOrUnionType(Type t) {
2372                 switch (t.getKind()) {
2373                     case INTERSECTION:
2374                     case UNION:
</pre>
<hr />
<pre>
2400             Type generatedRefSig() {
2401                 return types.erasure(tree.sym.type);
2402             }
2403 
2404             Type bridgedRefSig() {
2405                 return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);
2406             }
2407         }
2408     }
2409     // &lt;/editor-fold&gt;
2410 
2411     /*
2412      * These keys provide mappings for various translated lambda symbols
2413      * and the prevailing order must be maintained.
2414      */
2415     enum LambdaSymbolKind {
2416         PARAM,          // original to translated lambda parameters
2417         LOCAL_VAR,      // original to translated lambda locals
2418         CAPTURED_VAR,   // variables in enclosing scope to translated synthetic parameters
2419         CAPTURED_THIS,  // class symbols to translated synthetic parameters (for captured member access)
<span class="line-modified">2420         CAPTURED_OUTER_THIS, // used when `this&#39; capture is illegal, but outer this capture is legit (JDK-8129740)</span>
<span class="line-removed">2421         TYPE_VAR;      // original to translated lambda type variables</span>
2422 
2423         boolean propagateAnnotations() {
2424             switch (this) {
2425                 case CAPTURED_VAR:
2426                 case CAPTURED_THIS:
2427                 case CAPTURED_OUTER_THIS:
2428                     return false;
2429                 default:
2430                     return true;
2431            }
2432         }
2433     }
2434 
2435     /**
2436      * ****************************************************************
2437      * Signature Generation
2438      * ****************************************************************
2439      */
2440 
2441     private String typeSig(Type type) {
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
<span class="line-added">  28 import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;</span>
  29 import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
<span class="line-added">  30 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
  31 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  32 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  33 import com.sun.tools.javac.tree.*;
  34 import com.sun.tools.javac.tree.JCTree.*;
  35 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  36 import com.sun.tools.javac.tree.TreeMaker;
  37 import com.sun.tools.javac.tree.TreeTranslator;
  38 import com.sun.tools.javac.code.Attribute;
  39 import com.sun.tools.javac.code.Scope.WriteableScope;
  40 import com.sun.tools.javac.code.Symbol;
  41 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  42 import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;
  43 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  44 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  45 import com.sun.tools.javac.code.Symbol.VarSymbol;
  46 import com.sun.tools.javac.code.Symtab;
  47 import com.sun.tools.javac.code.Type;
  48 import com.sun.tools.javac.code.Type.MethodType;
  49 import com.sun.tools.javac.code.Type.TypeVar;
  50 import com.sun.tools.javac.code.Types;
  51 import com.sun.tools.javac.comp.LambdaToMethod.LambdaAnalyzerPreprocessor.*;
  52 import com.sun.tools.javac.comp.Lower.BasicFreeVarCollector;
  53 import com.sun.tools.javac.resources.CompilerProperties.Notes;
  54 import com.sun.tools.javac.jvm.*;
  55 import com.sun.tools.javac.util.*;
  56 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  57 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  58 
  59 import java.util.EnumMap;
  60 import java.util.HashMap;
  61 import java.util.HashSet;
  62 import java.util.LinkedHashMap;
  63 import java.util.Map;

  64 import java.util.Optional;
  65 import java.util.Set;
  66 import java.util.function.Consumer;
  67 import java.util.function.Supplier;
  68 
  69 import static com.sun.tools.javac.comp.LambdaToMethod.LambdaSymbolKind.*;
  70 import static com.sun.tools.javac.code.Flags.*;
  71 import static com.sun.tools.javac.code.Kinds.Kind.*;
  72 import static com.sun.tools.javac.code.TypeTag.*;
  73 import static com.sun.tools.javac.tree.JCTree.Tag.*;

  74 
  75 import javax.lang.model.element.ElementKind;
  76 import javax.lang.model.type.TypeKind;
  77 


  78 import com.sun.tools.javac.main.Option;
  79 
  80 /**
  81  * This pass desugars lambda expressions into static methods
  82  *
  83  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  84  *  If you write code that depends on this, you do so at your own risk.
  85  *  This code and its internal interfaces are subject to change or
  86  *  deletion without notice.&lt;/b&gt;
  87  */
  88 public class LambdaToMethod extends TreeTranslator {
  89 
  90     private Attr attr;
  91     private JCDiagnostic.Factory diags;
  92     private Log log;
  93     private Lower lower;
  94     private Names names;
  95     private Symtab syms;
  96     private Resolve rs;
  97     private Operators operators;
</pre>
<hr />
<pre>
 195         @Override
 196         public boolean equals(Object o) {
 197             if (!(o instanceof DedupedLambda)) {
 198                 return false;
 199             }
 200             DedupedLambda that = (DedupedLambda) o;
 201             return types.isSameType(symbol.asType(), that.symbol.asType())
 202                     &amp;&amp; new TreeDiffer(symbol.params(), that.symbol.params()).scan(tree, that.tree);
 203         }
 204     }
 205 
 206     private class KlassInfo {
 207 
 208         /**
 209          * list of methods to append
 210          */
 211         private ListBuffer&lt;JCTree&gt; appendedMethodList;
 212 
 213         private Map&lt;DedupedLambda, DedupedLambda&gt; dedupedLambdas;
 214 
<span class="line-modified"> 215         private Map&lt;Object, DynamicMethodSymbol&gt; dynMethSyms = new HashMap&lt;&gt;();</span>
 216 
 217         /**
 218          * list of deserialization cases
 219          */
 220         private final Map&lt;String, ListBuffer&lt;JCStatement&gt;&gt; deserializeCases;
 221 
 222        /**
 223          * deserialize method symbol
 224          */
 225         private final MethodSymbol deserMethodSym;
 226 
 227         /**
 228          * deserialize method parameter symbol
 229          */
 230         private final VarSymbol deserParamSym;
 231 
 232         private final JCClassDecl clazz;
 233 
 234         private KlassInfo(JCClassDecl clazz) {
 235             this.clazz = clazz;
</pre>
<hr />
<pre>
 364             }
 365         }
 366 
 367         //create the method declaration hoisting the lambda body
 368         JCMethodDecl lambdaDecl = make.MethodDef(make.Modifiers(sym.flags_field),
 369                 sym.name,
 370                 make.QualIdent(lambdaType.getReturnType().tsym),
 371                 List.nil(),
 372                 localContext.syntheticParams,
 373                 lambdaType.getThrownTypes() == null ?
 374                     List.nil() :
 375                     make.Types(lambdaType.getThrownTypes()),
 376                 null,
 377                 null);
 378         lambdaDecl.sym = sym;
 379         lambdaDecl.type = lambdaType;
 380 
 381         //translate lambda body
 382         //As the lambda body is translated, all references to lambda locals,
 383         //captured variables, enclosing members are adjusted accordingly
<span class="line-modified"> 384         //to refer to the static method parameters (rather than i.e. accessing</span>
 385         //captured members directly).
 386         lambdaDecl.body = translate(makeLambdaBody(tree, lambdaDecl));
 387 
 388         boolean dedupe = false;
 389         if (deduplicateLambdas &amp;&amp; !debugLinesOrVars &amp;&amp; !localContext.isSerializable()) {
 390             DedupedLambda dedupedLambda = new DedupedLambda(lambdaDecl.sym, lambdaDecl.body);
 391             DedupedLambda existing = kInfo.dedupedLambdas.putIfAbsent(dedupedLambda, dedupedLambda);
 392             if (existing != null) {
 393                 sym = existing.symbol;
 394                 dedupe = true;
 395                 if (verboseDeduplication) log.note(tree, Notes.VerboseL2mDeduplicate(sym));
 396             }
 397         }
 398         if (!dedupe) {
 399             //Add the method to the list of methods to be added to this class.
 400             kInfo.addMethod(lambdaDecl);
 401         }
 402 
 403         //now that we have generated a method for the lambda expression,
 404         //we can translate the lambda into a method reference pointing to the newly
</pre>
<hr />
<pre>
 420                     sym.owner.enclClass().asType(),
 421                     localContext.owner.enclClass()));
 422         }
 423 
 424         //add captured locals
 425         for (Symbol fv : localContext.getSymbolMap(CAPTURED_VAR).keySet()) {
 426             if (fv != localContext.self) {
 427                 JCTree captured_local = make.Ident(fv).setType(fv.type);
 428                 syntheticInits.append((JCExpression) captured_local);
 429             }
 430         }
 431         // add captured outer this instances (used only when `this&#39; capture itself is illegal)
 432         for (Symbol fv : localContext.getSymbolMap(CAPTURED_OUTER_THIS).keySet()) {
 433             JCTree captured_local = make.QualThis(fv.type);
 434             syntheticInits.append((JCExpression) captured_local);
 435         }
 436 
 437         //then, determine the arguments to the indy call
 438         List&lt;JCExpression&gt; indy_args = translate(syntheticInits.toList(), localContext.prev);
 439 



 440         //convert to an invokedynamic call
<span class="line-modified"> 441         result = makeMetafactoryIndyCall(context, sym.asHandle(), indy_args);</span>
 442     }
 443 
 444     // where
 445         // Reassign type annotations from the source that should really belong to the lambda
 446         private void apportionTypeAnnotations(JCLambda tree,
 447                                               Supplier&lt;List&lt;Attribute.TypeCompound&gt;&gt; source,
 448                                               Consumer&lt;List&lt;Attribute.TypeCompound&gt;&gt; owner,
 449                                               Consumer&lt;List&lt;Attribute.TypeCompound&gt;&gt; lambda) {
 450 
 451             ListBuffer&lt;Attribute.TypeCompound&gt; ownerTypeAnnos = new ListBuffer&lt;&gt;();
 452             ListBuffer&lt;Attribute.TypeCompound&gt; lambdaTypeAnnos = new ListBuffer&lt;&gt;();
 453 
 454             for (Attribute.TypeCompound tc : source.get()) {
 455                 if (tc.position.onLambda == tree) {
 456                     lambdaTypeAnnos.append(tc);
 457                 } else {
 458                     ownerTypeAnnos.append(tc);
 459                 }
 460             }
 461             if (lambdaTypeAnnos.nonEmpty()) {
</pre>
<hr />
<pre>
 466 
 467     private JCIdent makeThis(Type type, Symbol owner) {
 468         VarSymbol _this = new VarSymbol(PARAMETER | FINAL | SYNTHETIC,
 469                 names._this,
 470                 type,
 471                 owner);
 472         return make.Ident(_this);
 473     }
 474 
 475     /**
 476      * Translate a method reference into an invokedynamic call to the
 477      * meta-factory.
 478      * @param tree
 479      */
 480     @Override
 481     public void visitReference(JCMemberReference tree) {
 482         ReferenceTranslationContext localContext = (ReferenceTranslationContext)context;
 483 
 484         //first determine the method symbol to be used to generate the sam instance
 485         //this is either the method reference symbol, or the bridged reference symbol
<span class="line-modified"> 486         MethodSymbol refSym = (MethodSymbol)tree.sym;</span>
 487 
 488         //the qualifying expression is treated as a special captured arg
 489         JCExpression init;
 490         switch(tree.kind) {
 491 
 492             case IMPLICIT_INNER:    /** Inner :: new */
 493             case SUPER:             /** super :: instMethod */
 494                 init = makeThis(
 495                     localContext.owner.enclClass().asType(),
 496                     localContext.owner.enclClass());
 497                 break;
 498 
 499             case BOUND:             /** Expr :: instMethod */
 500                 init = transTypes.coerce(attrEnv, tree.getQualifierExpression(),
 501                     types.erasure(tree.sym.owner.type));
 502                 init = attr.makeNullCheck(init);
 503                 break;
 504 
 505             case UNBOUND:           /** Type :: instMethod */
 506             case STATIC:            /** Type :: staticMethod */
 507             case TOPLEVEL:          /** Top level :: new */
 508             case ARRAY_CTOR:        /** ArrayType :: new */
 509                 init = null;
 510                 break;
 511 
 512             default:
 513                 throw new InternalError(&quot;Should not have an invalid kind&quot;);
 514         }
 515 
 516         List&lt;JCExpression&gt; indy_args = init==null? List.nil() : translate(List.of(init), localContext.prev);
 517 
 518 
 519         //build a sam instance using an indy call to the meta-factory
<span class="line-modified"> 520         result = makeMetafactoryIndyCall(localContext, refSym.asHandle(), indy_args);</span>
 521     }
 522 
 523     /**
 524      * Translate identifiers within a lambda to the mapped identifier
 525      * @param tree
 526      */
 527     @Override
 528     public void visitIdent(JCIdent tree) {
 529         if (context == null || !analyzer.lambdaIdentSymbolFilter(tree.sym)) {
 530             super.visitIdent(tree);
 531         } else {
 532             int prevPos = make.pos;
 533             try {
 534                 make.at(tree);
 535 
 536                 LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;
 537                 JCTree ltree = lambdaContext.translate(tree);
 538                 if (ltree != null) {
 539                     result = ltree;
 540                 } else {
</pre>
<hr />
<pre>
 586             int prevPos = make.pos;
 587             try {
 588                 make.at(tree);
 589 
 590                 LambdaTranslationContext lambdaContext = (LambdaTranslationContext) context;
 591                 tree = lambdaContext.translate(tree);
 592                 super.visitNewClass(tree);
 593             } finally {
 594                 make.at(prevPos);
 595             }
 596         }
 597     }
 598 
 599     @Override
 600     public void visitVarDef(JCVariableDecl tree) {
 601         LambdaTranslationContext lambdaContext = (LambdaTranslationContext)context;
 602         if (context != null &amp;&amp; lambdaContext.getSymbolMap(LOCAL_VAR).containsKey(tree.sym)) {
 603             tree.init = translate(tree.init);
 604             tree.sym = (VarSymbol) lambdaContext.getSymbolMap(LOCAL_VAR).get(tree.sym);
 605             result = tree;















 606         } else {
 607             super.visitVarDef(tree);
 608         }
 609     }
 610 
 611     // &lt;/editor-fold&gt;
 612 
 613     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Translation helper methods&quot;&gt;
 614 
 615     private JCBlock makeLambdaBody(JCLambda tree, JCMethodDecl lambdaMethodDecl) {
 616         return tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
 617                 makeLambdaExpressionBody((JCExpression)tree.body, lambdaMethodDecl) :
 618                 makeLambdaStatementBody((JCBlock)tree.body, lambdaMethodDecl, tree.canCompleteNormally);
 619     }
 620 
 621     private JCBlock makeLambdaExpressionBody(JCExpression expr, JCMethodDecl lambdaMethodDecl) {
 622         Type restype = lambdaMethodDecl.type.getReturnType();
 623         boolean isLambda_void = expr.type.hasTag(VOID);
 624         boolean isTarget_void = restype.hasTag(VOID);
 625         boolean isTarget_Void = types.isSameType(restype, types.boxedClass(syms.voidType).type);
</pre>
<hr />
<pre>
 728      *  @param args     The constructor arguments.
 729      *  @param cons     The constructor symbol
 730      */
 731     JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args, Symbol cons) {
 732         JCNewClass tree = make.NewClass(null,
 733             null, make.QualIdent(ctype.tsym), args, null);
 734         tree.constructor = cons;
 735         tree.type = ctype;
 736         return tree;
 737     }
 738 
 739     /** Make an attributed class instance creation expression.
 740      *  @param ctype    The class type.
 741      *  @param args     The constructor arguments.
 742      */
 743     JCNewClass makeNewClass(Type ctype, List&lt;JCExpression&gt; args) {
 744         return makeNewClass(ctype, args,
 745                 rs.resolveConstructor(null, attrEnv, ctype, TreeInfo.types(args), List.nil()));
 746      }
 747 
<span class="line-modified"> 748     private void addDeserializationCase(MethodHandleSymbol refSym, Type targetType, MethodSymbol samSym,</span>
<span class="line-modified"> 749                                         DiagnosticPosition pos, List&lt;LoadableConstant&gt; staticArgs, MethodType indyType) {</span>
 750         String functionalInterfaceClass = classSig(targetType);
 751         String functionalInterfaceMethodName = samSym.getSimpleName().toString();
 752         String functionalInterfaceMethodSignature = typeSig(types.erasure(samSym.type));
 753         String implClass = classSig(types.erasure(refSym.owner.type));
 754         String implMethodName = refSym.getQualifiedName().toString();
 755         String implMethodSignature = typeSig(types.erasure(refSym.type));
 756 
<span class="line-modified"> 757         JCExpression kindTest = eqTest(syms.intType, deserGetter(&quot;getImplMethodKind&quot;, syms.intType),</span>
<span class="line-added"> 758                 make.Literal(refSym.referenceKind()));</span>
 759         ListBuffer&lt;JCExpression&gt; serArgs = new ListBuffer&lt;&gt;();
 760         int i = 0;
 761         for (Type t : indyType.getParameterTypes()) {
 762             List&lt;JCExpression&gt; indexAsArg = new ListBuffer&lt;JCExpression&gt;().append(make.Literal(i)).toList();
 763             List&lt;Type&gt; argTypes = new ListBuffer&lt;Type&gt;().append(syms.intType).toList();
 764             serArgs.add(make.TypeCast(types.erasure(t), deserGetter(&quot;getCapturedArg&quot;, syms.objectType, argTypes, indexAsArg)));
 765             ++i;
 766         }
 767         JCStatement stmt = make.If(
 768                 deserTest(deserTest(deserTest(deserTest(deserTest(
 769                     kindTest,
 770                     &quot;getFunctionalInterfaceClass&quot;, functionalInterfaceClass),
 771                     &quot;getFunctionalInterfaceMethodName&quot;, functionalInterfaceMethodName),
 772                     &quot;getFunctionalInterfaceMethodSignature&quot;, functionalInterfaceMethodSignature),
 773                     &quot;getImplClass&quot;, implClass),
 774                     &quot;getImplMethodSignature&quot;, implMethodSignature),
 775                 make.Return(makeIndyCall(
 776                     pos,
 777                     syms.lambdaMetafactory,
 778                     names.altMetafactory,
</pre>
<hr />
<pre>
 946                     rcvr = null;
 947                     break;
 948             }
 949             List&lt;Type&gt; implPTypes = tree.sym.type.getParameterTypes();
 950             int implSize = implPTypes.size();
 951             int samSize = samPTypes.size();
 952             // Last parameter to copy from referenced method, exclude final var args
 953             int last = localContext.needsVarArgsConversion() ? implSize - 1 : implSize;
 954 
 955             // Failsafe -- assure match-up
 956             boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();
 957 
 958             // Use parameter types of the implementation method unless the unerased
 959             // SAM parameter type is an intersection type, in that case use the
 960             // erased SAM parameter type so that the supertype relationship
 961             // the implementation method parameters is not obscured.
 962             // Note: in this loop, the lists implPTypes, samPTypes, and descPTypes
 963             // are used as pointers to the current parameter type information
 964             // and are thus not usable afterwards.
 965             for (int i = 0; implPTypes.nonEmpty() &amp;&amp; i &lt; last; ++i) {
<span class="line-modified"> 966                 // By default use the implementation method parameter type</span>
 967                 Type parmType = implPTypes.head;
 968                 // If the unerased parameter type is a type variable whose
 969                 // bound is an intersection (eg. &lt;T extends A &amp; B&gt;) then
 970                 // use the SAM parameter type
 971                 if (checkForIntersection &amp;&amp; descPTypes.head.getKind() == TypeKind.TYPEVAR) {
 972                     TypeVar tv = (TypeVar) descPTypes.head;
 973                     if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {
 974                         parmType = samPTypes.head;
 975                     }
 976                 }
 977                 addParameter(&quot;x$&quot; + i, parmType, true);
 978 
 979                 // Advance to the next parameter
 980                 implPTypes = implPTypes.tail;
 981                 samPTypes = samPTypes.tail;
 982                 descPTypes = descPTypes.tail;
 983             }
 984             // Flatten out the var args
 985             for (int i = last; i &lt; samSize; ++i) {
 986                 addParameter(&quot;xva$&quot; + i, tree.varargsElement, true);
</pre>
<hr />
<pre>
1070             params.append(make.VarDef(vsym, null));
1071             if (genArg) {
1072                 args.append(make.Ident(vsym));
1073             }
1074             return vsym;
1075         }
1076     }
1077 
1078     private MethodType typeToMethodType(Type mt) {
1079         Type type = types.erasure(mt);
1080         return new MethodType(type.getParameterTypes(),
1081                         type.getReturnType(),
1082                         type.getThrownTypes(),
1083                         syms.methodClass);
1084     }
1085 
1086     /**
1087      * Generate an indy method call to the meta factory
1088      */
1089     private JCExpression makeMetafactoryIndyCall(TranslationContext&lt;?&gt; context,
<span class="line-modified">1090             MethodHandleSymbol refSym, List&lt;JCExpression&gt; indy_args) {</span>
1091         JCFunctionalExpression tree = context.tree;
1092         //determine the static bsm args
1093         MethodSymbol samSym = (MethodSymbol) types.findDescriptorSymbol(tree.target.tsym);
<span class="line-modified">1094         List&lt;LoadableConstant&gt; staticArgs = List.of(</span>
1095                 typeToMethodType(samSym.type),
<span class="line-modified">1096                 refSym.asHandle(),</span>
1097                 typeToMethodType(tree.getDescriptorType(types)));
1098 
1099         //computed indy arg types
1100         ListBuffer&lt;Type&gt; indy_args_types = new ListBuffer&lt;&gt;();
1101         for (JCExpression arg : indy_args) {
1102             indy_args_types.append(arg.type);
1103         }
1104 
1105         //finally, compute the type of the indy call
1106         MethodType indyType = new MethodType(indy_args_types.toList(),
1107                 tree.type,
1108                 List.nil(),
1109                 syms.methodClass);
1110 
1111         Name metafactoryName = context.needsAltMetafactory() ?
1112                 names.altMetafactory : names.metafactory;
1113 
1114         if (context.needsAltMetafactory()) {
<span class="line-modified">1115             ListBuffer&lt;Type&gt; markers = new ListBuffer&lt;&gt;();</span>
1116             List&lt;Type&gt; targets = tree.target.isIntersection() ?
1117                     types.directSupertypes(tree.target) :
1118                     List.nil();
1119             for (Type t : targets) {
1120                 t = types.erasure(t);
1121                 if (t.tsym != syms.serializableType.tsym &amp;&amp;
1122                     t.tsym != tree.type.tsym &amp;&amp;
1123                     t.tsym != syms.objectType.tsym) {
<span class="line-modified">1124                     markers.append(t);</span>
1125                 }
1126             }
1127             int flags = context.isSerializable() ? FLAG_SERIALIZABLE : 0;
1128             boolean hasMarkers = markers.nonEmpty();
1129             boolean hasBridges = context.bridges.nonEmpty();
1130             if (hasMarkers) {
1131                 flags |= FLAG_MARKERS;
1132             }
1133             if (hasBridges) {
1134                 flags |= FLAG_BRIDGES;
1135             }
<span class="line-modified">1136             staticArgs = staticArgs.append(LoadableConstant.Int(flags));</span>
1137             if (hasMarkers) {
<span class="line-modified">1138                 staticArgs = staticArgs.append(LoadableConstant.Int(markers.length()));</span>
<span class="line-modified">1139                 staticArgs = staticArgs.appendList(List.convert(LoadableConstant.class, markers.toList()));</span>
1140             }
1141             if (hasBridges) {
<span class="line-modified">1142                 staticArgs = staticArgs.append(LoadableConstant.Int(context.bridges.length() - 1));</span>
1143                 for (Symbol s : context.bridges) {
1144                     Type s_erasure = s.erasure(types);
1145                     if (!types.isSameType(s_erasure, samSym.erasure(types))) {
<span class="line-modified">1146                         staticArgs = staticArgs.append(((MethodType)s.erasure(types)));</span>
1147                     }
1148                 }
1149             }
1150             if (context.isSerializable()) {
1151                 int prevPos = make.pos;
1152                 try {
1153                     make.at(kInfo.clazz);
<span class="line-modified">1154                     addDeserializationCase(refSym, tree.type, samSym,</span>
1155                             tree, staticArgs, indyType);
1156                 } finally {
1157                     make.at(prevPos);
1158                 }
1159             }
1160         }
1161 
1162         return makeIndyCall(tree, syms.lambdaMetafactory, metafactoryName, staticArgs, indyType, indy_args, samSym.name);
1163     }
1164 
1165     /**
1166      * Generate an indy method call with given name, type and static bootstrap
1167      * arguments types
1168      */
1169     private JCExpression makeIndyCall(DiagnosticPosition pos, Type site, Name bsmName,
<span class="line-modified">1170                                       List&lt;LoadableConstant&gt; staticArgs, MethodType indyType, List&lt;JCExpression&gt; indyArgs,</span>
<span class="line-modified">1171                                       Name methName) {</span>
1172         int prevPos = make.pos;
1173         try {
1174             make.at(pos);
1175             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
<span class="line-modified">1176                 syms.stringType,</span>
<span class="line-modified">1177                 syms.methodTypeType).appendList(staticArgs.map(types::constantType));</span>
1178 
1179             Symbol bsm = rs.resolveInternalMethod(pos, attrEnv, site,
1180                     bsmName, bsm_staticArgs, List.nil());
1181 
1182             DynamicMethodSymbol dynSym =
1183                     new DynamicMethodSymbol(methName,
1184                                             syms.noSymbol,
<span class="line-modified">1185                                             ((MethodSymbol)bsm).asHandle(),</span>



1186                                             indyType,
<span class="line-modified">1187                                             staticArgs.toArray(new LoadableConstant[staticArgs.length()]));</span>
1188             JCFieldAccess qualifier = make.Select(make.QualIdent(site.tsym), bsmName);
1189             DynamicMethodSymbol existing = kInfo.dynMethSyms.putIfAbsent(
<span class="line-modified">1190                     dynSym.poolKey(types), dynSym);</span>
1191             qualifier.sym = existing != null ? existing : dynSym;
1192             qualifier.type = indyType.getReturnType();
1193 
1194             JCMethodInvocation proxyCall = make.Apply(List.nil(), qualifier, indyArgs);
1195             proxyCall.type = indyType.getReturnType();
1196             return proxyCall;
1197         } finally {
1198             make.at(prevPos);
1199         }
1200     }



















































1201 
1202     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Lambda/reference analyzer&quot;&gt;
1203     /**
1204      * This visitor collects information about translation of a lambda expression.
1205      * More specifically, it keeps track of the enclosing contexts and captured locals
1206      * accessed by the lambda being translated (as well as other useful info).
1207      * It also translates away problems for LambdaToMethod.
1208      */
1209     class LambdaAnalyzerPreprocessor extends TreeTranslator {
1210 
1211         /** the frame stack - used to reconstruct translation info about enclosing scopes */
1212         private List&lt;Frame&gt; frameStack;
1213 
1214         /**
1215          * keep the count of lambda expression (used to generate unambiguous
1216          * names)
1217          */
1218         private int lambdaCount = 0;
1219 
1220         /**
</pre>
<hr />
<pre>
1540                     }
1541                     localContext = localContext.prev;
1542                 }
1543             }
1544             super.visitSelect(tree);
1545         }
1546 
1547         @Override
1548         public void visitVarDef(JCVariableDecl tree) {
1549             TranslationContext&lt;?&gt; context = context();
1550             LambdaTranslationContext ltc = (context != null &amp;&amp; context instanceof LambdaTranslationContext)?
1551                     (LambdaTranslationContext)context :
1552                     null;
1553             if (ltc != null) {
1554                 if (frameStack.head.tree.hasTag(LAMBDA)) {
1555                     ltc.addSymbol(tree.sym, LOCAL_VAR);
1556                 }
1557                 // Check for type variables (including as type arguments).
1558                 // If they occur within class nested in a lambda, mark for erasure
1559                 Type type = tree.sym.asType();



1560             }
1561 
1562             List&lt;Frame&gt; prevStack = frameStack;
1563             try {
1564                 if (tree.sym.owner.kind == MTH) {
1565                     frameStack.head.addLocal(tree.sym);
1566                 }
1567                 frameStack = frameStack.prepend(new Frame(tree));
1568                 super.visitVarDef(tree);
1569             }
1570             finally {
1571                 frameStack = prevStack;
1572             }
1573         }
1574 
1575         /**
1576          * Return a valid owner given the current declaration stack
1577          * (required to skip synthetic lambda symbols)
1578          */
1579         private Symbol owner() {
</pre>
<hr />
<pre>
1692             // No lambda
1693             return false;
1694         }
1695 
1696         /**
1697          * Return the declaration corresponding to a symbol in the enclosing
1698          * scope; the depth parameter is used to filter out symbols defined
1699          * in nested scopes (which do not need to undergo capture).
1700          */
1701         private JCTree capturedDecl(int depth, Symbol sym) {
1702             int currentDepth = frameStack.size() - 1;
1703             for (Frame block : frameStack) {
1704                 switch (block.tree.getTag()) {
1705                     case CLASSDEF:
1706                         ClassSymbol clazz = ((JCClassDecl)block.tree).sym;
1707                         if (clazz.isSubClass(sym, types) || sym.isMemberOf(clazz, types)) {
1708                             return currentDepth &gt; depth ? null : block.tree;
1709                         }
1710                         break;
1711                     case VARDEF:
<span class="line-modified">1712                         if ((((JCVariableDecl)block.tree).sym == sym &amp;&amp;</span>
<span class="line-modified">1713                                 sym.owner.kind == MTH) || //only locals are captured</span>
<span class="line-added">1714                             (block.locals != null &amp;&amp; block.locals.contains(sym))) {</span>
1715                             return currentDepth &gt; depth ? null : block.tree;
1716                         }
1717                         break;
1718                     case BLOCK:
1719                     case METHODDEF:
1720                     case LAMBDA:
1721                         if (block.locals != null &amp;&amp; block.locals.contains(sym)) {
1722                             return currentDepth &gt; depth ? null : block.tree;
1723                         }
1724                         break;
1725                     default:
1726                         Assert.error(&quot;bad decl kind &quot; + block.tree.getTag());
1727                 }
1728                 currentDepth--;
1729             }
1730             return null;
1731         }
1732 
1733         private TranslationContext&lt;?&gt; context() {
1734             for (Frame frame : frameStack) {
</pre>
<hr />
<pre>
1910              */
1911             JCExpression methodReferenceReceiver;
1912 
1913             LambdaTranslationContext(JCLambda tree) {
1914                 super(tree);
1915                 Frame frame = frameStack.head;
1916                 switch (frame.tree.getTag()) {
1917                     case VARDEF:
1918                         assignedTo = self = ((JCVariableDecl) frame.tree).sym;
1919                         break;
1920                     case ASSIGN:
1921                         self = null;
1922                         assignedTo = TreeInfo.symbol(((JCAssign) frame.tree).getVariable());
1923                         break;
1924                     default:
1925                         assignedTo = self = null;
1926                         break;
1927                  }
1928 
1929                 // This symbol will be filled-in in complete
<span class="line-modified">1930                 if (owner.kind == MTH) {</span>
<span class="line-modified">1931                     final MethodSymbol originalOwner = (MethodSymbol)owner.clone(owner.owner);</span>
<span class="line-added">1932                     this.translatedSym = new MethodSymbol(SYNTHETIC | PRIVATE, null, null, owner.enclClass()) {</span>
<span class="line-added">1933                         @Override</span>
<span class="line-added">1934                         public MethodSymbol originalEnclosingMethod() {</span>
<span class="line-added">1935                             return originalOwner;</span>
<span class="line-added">1936                         }</span>
<span class="line-added">1937                     };</span>
<span class="line-added">1938                 } else {</span>
<span class="line-added">1939                     this.translatedSym = makePrivateSyntheticMethod(0, null, null, owner.enclClass());</span>
<span class="line-added">1940                 }</span>
1941                 translatedSymbols = new EnumMap&lt;&gt;(LambdaSymbolKind.class);
1942 
1943                 translatedSymbols.put(PARAM, new LinkedHashMap&lt;Symbol, Symbol&gt;());
1944                 translatedSymbols.put(LOCAL_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
1945                 translatedSymbols.put(CAPTURED_VAR, new LinkedHashMap&lt;Symbol, Symbol&gt;());
1946                 translatedSymbols.put(CAPTURED_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());
1947                 translatedSymbols.put(CAPTURED_OUTER_THIS, new LinkedHashMap&lt;Symbol, Symbol&gt;());

1948 
1949                 freeVarProcessedLocalClasses = new HashSet&lt;&gt;();
1950             }
1951 
1952              /**
1953              * For a serializable lambda, generate a disambiguating string
1954              * which maximizes stability across deserialization.
1955              *
1956              * @return String to differentiate synthetic lambda method names
1957              */
1958             private String serializedLambdaDisambiguation() {
1959                 StringBuilder buf = new StringBuilder();
1960                 // Append the enclosing method signature to differentiate
1961                 // overloaded enclosing methods.  For lambdas enclosed in
1962                 // lambdas, the generated lambda method will not have type yet,
1963                 // but the enclosing method&#39;s name will have been generated
1964                 // with this same method, so it will be unique and never be
1965                 // overloaded.
1966                 Assert.check(
1967                         owner.type != null ||
</pre>
<hr />
<pre>
2020                 buf.append(Integer.toHexString(disam.hashCode()));
2021                 buf.append(&#39;$&#39;);
2022                 // The above appended name components may not be unique, append
2023                 // a count based on the above name components.
2024                 buf.append(syntheticMethodNameCounts.getIndex(buf));
2025                 String result = buf.toString();
2026                 //System.err.printf(&quot;serializedLambdaName: %s -- %s\n&quot;, result, disam);
2027                 return names.fromString(result);
2028             }
2029 
2030             /**
2031              * Translate a symbol of a given kind into something suitable for the
2032              * synthetic lambda body
2033              */
2034             Symbol translate(final Symbol sym, LambdaSymbolKind skind) {
2035                 Symbol ret;
2036                 switch (skind) {
2037                     case CAPTURED_THIS:
2038                         ret = sym;  // self represented
2039                         break;










2040                     case CAPTURED_VAR:
2041                         ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, sym.name, types.erasure(sym.type), translatedSym) {
2042                             @Override
2043                             public Symbol baseSymbol() {
2044                                 //keep mapping with original captured symbol
2045                                 return sym;
2046                             }
2047                         };
2048                         break;
2049                     case CAPTURED_OUTER_THIS:
2050                         Name name = names.fromString(new String(sym.flatName().toString().replace(&#39;.&#39;, &#39;$&#39;) + names.dollarThis));
2051                         ret = new VarSymbol(SYNTHETIC | FINAL | PARAMETER, name, types.erasure(sym.type), translatedSym) {
2052                             @Override
2053                             public Symbol baseSymbol() {
2054                                 //keep mapping with original captured symbol
2055                                 return sym;
2056                             }
2057                         };
2058                         break;
2059                     case LOCAL_VAR:
</pre>
<hr />
<pre>
2218             Type generatedLambdaSig() {
2219                 return types.erasure(tree.getDescriptorType(types));
2220             }
2221         }
2222 
2223         /**
2224          * This class retains all the useful information about a method reference;
2225          * the contents of this class are filled by the LambdaAnalyzer visitor,
2226          * and the used by the main translation routines in order to adjust method
2227          * references (i.e. in case a bridge is needed)
2228          */
2229         final class ReferenceTranslationContext extends TranslationContext&lt;JCMemberReference&gt; {
2230 
2231             final boolean isSuper;
2232 
2233             ReferenceTranslationContext(JCMemberReference tree) {
2234                 super(tree);
2235                 this.isSuper = tree.hasKind(ReferenceKind.SUPER);
2236             }
2237 







2238             boolean needsVarArgsConversion() {
2239                 return tree.varargsElement != null;
2240             }
2241 
2242             /**
2243              * @return Is this an array operation like clone()
2244              */
2245             boolean isArrayOp() {
2246                 return tree.sym.owner == syms.arrayClass;
2247             }
2248 
2249             boolean receiverAccessible() {
2250                 //hack needed to workaround 292 bug (7087658)
2251                 //when 292 issue is fixed we should remove this and change the backend
2252                 //code to always generate a method handle to an accessible method
2253                 return tree.ownerAccessible;
2254             }
2255 
2256             /**
2257              * The VM does not support access across nested classes (8010319).
2258              * Were that ever to change, this should be removed.
2259              */
2260             boolean isPrivateInOtherClass() {
2261                 return  (tree.sym.flags() &amp; PRIVATE) != 0 &amp;&amp;
2262                         !types.isSameType(
2263                               types.erasure(tree.sym.enclClass().asType()),
2264                               types.erasure(owner.enclClass().asType()));
2265             }
2266 
2267             boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
2268                 return ((tree.sym.flags() &amp; PROTECTED) != 0 &amp;&amp;
<span class="line-modified">2269                         tree.sym.packge() != owner.packge());</span>

2270             }
2271 
2272             /**
2273              * Erasure destroys the implementation parameter subtype
2274              * relationship for intersection types.
2275              * Have similar problems for union types too.
2276              */
2277             boolean interfaceParameterIsIntersectionOrUnionType() {
2278                 List&lt;Type&gt; tl = tree.getDescriptorType(types).getParameterTypes();
2279                 for (; tl.nonEmpty(); tl = tl.tail) {
2280                     Type pt = tl.head;
2281                     return isIntersectionOrUnionType(pt);
2282                 }
2283                 return false;
2284             }
2285 
2286             boolean isIntersectionOrUnionType(Type t) {
2287                 switch (t.getKind()) {
2288                     case INTERSECTION:
2289                     case UNION:
</pre>
<hr />
<pre>
2315             Type generatedRefSig() {
2316                 return types.erasure(tree.sym.type);
2317             }
2318 
2319             Type bridgedRefSig() {
2320                 return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);
2321             }
2322         }
2323     }
2324     // &lt;/editor-fold&gt;
2325 
2326     /*
2327      * These keys provide mappings for various translated lambda symbols
2328      * and the prevailing order must be maintained.
2329      */
2330     enum LambdaSymbolKind {
2331         PARAM,          // original to translated lambda parameters
2332         LOCAL_VAR,      // original to translated lambda locals
2333         CAPTURED_VAR,   // variables in enclosing scope to translated synthetic parameters
2334         CAPTURED_THIS,  // class symbols to translated synthetic parameters (for captured member access)
<span class="line-modified">2335         CAPTURED_OUTER_THIS; // used when `this&#39; capture is illegal, but outer this capture is legit (JDK-8129740)</span>

2336 
2337         boolean propagateAnnotations() {
2338             switch (this) {
2339                 case CAPTURED_VAR:
2340                 case CAPTURED_THIS:
2341                 case CAPTURED_OUTER_THIS:
2342                     return false;
2343                 default:
2344                     return true;
2345            }
2346         }
2347     }
2348 
2349     /**
2350      * ****************************************************************
2351      * Signature Generation
2352      * ****************************************************************
2353      */
2354 
2355     private String typeSig(Type type) {
</pre>
</td>
</tr>
</table>
<center><a href="InferenceContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Lower.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
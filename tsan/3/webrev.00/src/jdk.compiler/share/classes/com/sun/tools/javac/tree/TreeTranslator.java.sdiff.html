<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeTranslator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TreeScanner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../util/AbstractDiagnosticFormatter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeTranslator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
241     public void visitConditional(JCConditional tree) {
242         tree.cond = translate(tree.cond);
243         tree.truepart = translate(tree.truepart);
244         tree.falsepart = translate(tree.falsepart);
245         result = tree;
246     }
247 
248     public void visitIf(JCIf tree) {
249         tree.cond = translate(tree.cond);
250         tree.thenpart = translate(tree.thenpart);
251         tree.elsepart = translate(tree.elsepart);
252         result = tree;
253     }
254 
255     public void visitExec(JCExpressionStatement tree) {
256         tree.expr = translate(tree.expr);
257         result = tree;
258     }
259 
260     public void visitBreak(JCBreak tree) {
<span class="line-modified">261         if (tree.isValueBreak())</span>
<span class="line-modified">262             tree.value = translate(tree.value);</span>



263         result = tree;
264     }
265 
266     public void visitContinue(JCContinue tree) {
267         result = tree;
268     }
269 
270     public void visitReturn(JCReturn tree) {
271         tree.expr = translate(tree.expr);
272         result = tree;
273     }
274 
275     public void visitThrow(JCThrow tree) {
276         tree.expr = translate(tree.expr);
277         result = tree;
278     }
279 
280     public void visitAssert(JCAssert tree) {
281         tree.cond = translate(tree.cond);
282         tree.detail = translate(tree.detail);
</pre>
<hr />
<pre>
334 
335     public void visitUnary(JCUnary tree) {
336         tree.arg = translate(tree.arg);
337         result = tree;
338     }
339 
340     public void visitBinary(JCBinary tree) {
341         tree.lhs = translate(tree.lhs);
342         tree.rhs = translate(tree.rhs);
343         result = tree;
344     }
345 
346     public void visitTypeCast(JCTypeCast tree) {
347         tree.clazz = translate(tree.clazz);
348         tree.expr = translate(tree.expr);
349         result = tree;
350     }
351 
352     public void visitTypeTest(JCInstanceOf tree) {
353         tree.expr = translate(tree.expr);
<span class="line-modified">354         tree.clazz = translate(tree.clazz);</span>





355         result = tree;
356     }
357 
358     public void visitIndexed(JCArrayAccess tree) {
359         tree.indexed = translate(tree.indexed);
360         tree.index = translate(tree.index);
361         result = tree;
362     }
363 
364     public void visitSelect(JCFieldAccess tree) {
365         tree.selected = translate(tree.selected);
366         result = tree;
367     }
368 
369     public void visitReference(JCMemberReference tree) {
370         tree.expr = translate(tree.expr);
371         result = tree;
372     }
373 
374     public void visitIdent(JCIdent tree) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
241     public void visitConditional(JCConditional tree) {
242         tree.cond = translate(tree.cond);
243         tree.truepart = translate(tree.truepart);
244         tree.falsepart = translate(tree.falsepart);
245         result = tree;
246     }
247 
248     public void visitIf(JCIf tree) {
249         tree.cond = translate(tree.cond);
250         tree.thenpart = translate(tree.thenpart);
251         tree.elsepart = translate(tree.elsepart);
252         result = tree;
253     }
254 
255     public void visitExec(JCExpressionStatement tree) {
256         tree.expr = translate(tree.expr);
257         result = tree;
258     }
259 
260     public void visitBreak(JCBreak tree) {
<span class="line-modified">261         result = tree;</span>
<span class="line-modified">262     }</span>
<span class="line-added">263 </span>
<span class="line-added">264     public void visitYield(JCYield tree) {</span>
<span class="line-added">265         tree.value = translate(tree.value);</span>
266         result = tree;
267     }
268 
269     public void visitContinue(JCContinue tree) {
270         result = tree;
271     }
272 
273     public void visitReturn(JCReturn tree) {
274         tree.expr = translate(tree.expr);
275         result = tree;
276     }
277 
278     public void visitThrow(JCThrow tree) {
279         tree.expr = translate(tree.expr);
280         result = tree;
281     }
282 
283     public void visitAssert(JCAssert tree) {
284         tree.cond = translate(tree.cond);
285         tree.detail = translate(tree.detail);
</pre>
<hr />
<pre>
337 
338     public void visitUnary(JCUnary tree) {
339         tree.arg = translate(tree.arg);
340         result = tree;
341     }
342 
343     public void visitBinary(JCBinary tree) {
344         tree.lhs = translate(tree.lhs);
345         tree.rhs = translate(tree.rhs);
346         result = tree;
347     }
348 
349     public void visitTypeCast(JCTypeCast tree) {
350         tree.clazz = translate(tree.clazz);
351         tree.expr = translate(tree.expr);
352         result = tree;
353     }
354 
355     public void visitTypeTest(JCInstanceOf tree) {
356         tree.expr = translate(tree.expr);
<span class="line-modified">357         tree.pattern = translate(tree.pattern);</span>
<span class="line-added">358         result = tree;</span>
<span class="line-added">359     }</span>
<span class="line-added">360 </span>
<span class="line-added">361     public void visitBindingPattern(JCBindingPattern tree) {</span>
<span class="line-added">362         tree.vartype = translate(tree.vartype);</span>
363         result = tree;
364     }
365 
366     public void visitIndexed(JCArrayAccess tree) {
367         tree.indexed = translate(tree.indexed);
368         tree.index = translate(tree.index);
369         result = tree;
370     }
371 
372     public void visitSelect(JCFieldAccess tree) {
373         tree.selected = translate(tree.selected);
374         result = tree;
375     }
376 
377     public void visitReference(JCMemberReference tree) {
378         tree.expr = translate(tree.expr);
379         result = tree;
380     }
381 
382     public void visitIdent(JCIdent tree) {
</pre>
</td>
</tr>
</table>
<center><a href="TreeScanner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../util/AbstractDiagnosticFormatter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
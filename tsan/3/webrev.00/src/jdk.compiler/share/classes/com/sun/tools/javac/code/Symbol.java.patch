diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,22 +27,25 @@
 
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Inherited;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
+import java.util.function.Supplier;
 
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ElementVisitor;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.ModuleElement;
 import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.PackageElement;
+import javax.lang.model.element.RecordComponentElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.tools.JavaFileManager;
 import javax.tools.JavaFileObject;
@@ -52,23 +55,26 @@
 import com.sun.tools.javac.code.Type.*;
 import com.sun.tools.javac.comp.Attr;
 import com.sun.tools.javac.comp.AttrContext;
 import com.sun.tools.javac.comp.Env;
 import com.sun.tools.javac.jvm.*;
+import com.sun.tools.javac.jvm.PoolConstant;
+import com.sun.tools.javac.tree.JCTree;
+import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 import com.sun.tools.javac.tree.JCTree.Tag;
 import com.sun.tools.javac.util.*;
 import com.sun.tools.javac.util.DefinedBy.Api;
+import com.sun.tools.javac.util.List;
 import com.sun.tools.javac.util.Name;
 
 import static com.sun.tools.javac.code.Flags.*;
 import static com.sun.tools.javac.code.Kinds.*;
 import static com.sun.tools.javac.code.Kinds.Kind.*;
 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
 import com.sun.tools.javac.code.Scope.WriteableScope;
-import static com.sun.tools.javac.code.Symbol.OperatorSymbol.AccessCode.FIRSTASGOP;
 import static com.sun.tools.javac.code.TypeTag.CLASS;
 import static com.sun.tools.javac.code.TypeTag.FORALL;
 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
 import static com.sun.tools.javac.jvm.ByteCodes.iadd;
 import static com.sun.tools.javac.jvm.ByteCodes.ishll;
@@ -84,11 +90,11 @@
  *  <p><b>This is NOT part of any supported API.
  *  If you write code that depends on this, you do so at your own risk.
  *  This code and its internal interfaces are subject to change or
  *  deletion without notice.</b>
  */
-public abstract class Symbol extends AnnoConstruct implements Element {
+public abstract class Symbol extends AnnoConstruct implements PoolConstant, Element {
 
     /** The kind of this symbol.
      *  @see Kinds
      */
     public Kind kind;
@@ -279,10 +285,15 @@
         this.completer = Completer.NULL_COMPLETER;
         this.erasure_field = null;
         this.name = name;
     }
 
+    @Override
+    public int poolTag() {
+        throw new AssertionError("Invalid pool entry");
+    }
+
     /** Clone this symbol with new owner.
      *  Legal only for fields and methods.
      */
     public Symbol clone(Symbol newOwner) {
         throw new AssertionError();
@@ -365,10 +376,14 @@
 
     public boolean isDeprecatedForRemoval() {
         return (flags_field & DEPRECATED_REMOVAL) != 0;
     }
 
+    public boolean isPreviewApi() {
+        return (flags_field & PREVIEW_API) != 0;
+    }
+
     public boolean isDeprecatableViaAnnotation() {
         switch (getKind()) {
             case LOCAL_VARIABLE:
             case PACKAGE:
             case PARAMETER:
@@ -389,19 +404,31 @@
 
     public boolean isInterface() {
         return (flags() & INTERFACE) != 0;
     }
 
+    public boolean isAbstract() {
+        return (flags_field & ABSTRACT) != 0;
+    }
+
     public boolean isPrivate() {
         return (flags_field & Flags.AccessFlags) == PRIVATE;
     }
 
+    public boolean isPublic() {
+        return (flags_field & Flags.AccessFlags) == PUBLIC;
+    }
+
     public boolean isEnum() {
         return (flags() & ENUM) != 0;
     }
 
-    /** Is this symbol declared (directly or indirectly) local
+    public boolean isFinal() {
+        return (flags_field & FINAL) != 0;
+    }
+
+   /** Is this symbol declared (directly or indirectly) local
      *  to a method or variable initializer?
      *  Also includes fields of inner classes which are in
      *  turn local to a method or variable initializer.
      */
     public boolean isLocal() {
@@ -421,10 +448,14 @@
      */
     public boolean isConstructor() {
         return name == name.table.names.init;
     }
 
+    public boolean isDynamic() {
+        return false;
+    }
+
     /** The fully qualified name of this symbol.
      *  This is the same as the symbol's name except for class symbols,
      *  which are handled separately.
      */
     public Name getQualifiedName() {
@@ -807,11 +838,11 @@
             }
             return type.hasTag(TYPEVAR);
         }
 
         @Override @DefinedBy(Api.LANGUAGE_MODEL)
-        public java.util.List<Symbol> getEnclosedElements() {
+        public List<Symbol> getEnclosedElements() {
             List<Symbol> list = List.nil();
             if (kind == TYP && type.hasTag(TYPEVAR)) {
                 return list;
             }
             apiComplete();
@@ -964,10 +995,15 @@
             super(MDL, 0, name, null, owner);
             Assert.checkNonNull(name);
             this.type = new ModuleType(this);
         }
 
+        @Override
+        public int poolTag() {
+            return ClassFile.CONSTANT_Module;
+        }
+
         @Override @DefinedBy(Api.LANGUAGE_MODEL)
         public Name getSimpleName() {
             return Convert.shortName(name);
         }
 
@@ -1130,10 +1166,15 @@
         public WriteableScope members() {
             complete();
             return members_field;
         }
 
+        @Override
+        public int poolTag() {
+            return ClassFile.CONSTANT_Package;
+        }
+
         public long flags() {
             complete();
             return flags_field;
         }
 
@@ -1186,10 +1227,20 @@
             metadata = null;
         }
 
     }
 
+    public static class RootPackageSymbol extends PackageSymbol {
+        public final MissingInfoHandler missingInfoHandler;
+
+        public RootPackageSymbol(Name name, Symbol owner, MissingInfoHandler missingInfoHandler) {
+            super(name, owner);
+            this.missingInfoHandler = missingInfoHandler;
+        }
+
+    }
+
     /** A class for class symbols
      */
     public static class ClassSymbol extends TypeSymbol implements TypeElement {
 
         /** a scope for all class members; variables, methods and inner classes
@@ -1220,25 +1271,25 @@
         /** the list of translated local classes (used for generating
          * InnerClasses attribute)
          */
         public List<ClassSymbol> trans_local;
 
-        /** the constant pool of the class
-         */
-        public Pool pool;
-
         /** the annotation metadata attached to this class */
         private AnnotationTypeMetadata annotationTypeMetadata;
 
+        /* the list of any of record components, only non empty if the class is a record
+         * and it has at least one record component
+         */
+        private List<RecordComponent> recordComponents = List.nil();
+
         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
             super(TYP, flags, name, type, owner);
             this.members_field = null;
             this.fullname = formFullName(name, owner);
             this.flatname = formFlatName(name, owner);
             this.sourcefile = null;
             this.classfile = null;
-            this.pool = null;
             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
         }
 
         public ClassSymbol(long flags, Name name, Symbol owner) {
             this(
@@ -1296,10 +1347,22 @@
         @DefinedBy(Api.LANGUAGE_MODEL)
         public Name getQualifiedName() {
             return fullname;
         }
 
+        @Override @DefinedBy(Api.LANGUAGE_MODEL)
+        public List<Symbol> getEnclosedElements() {
+            List<Symbol> result = super.getEnclosedElements();
+            if (!recordComponents.isEmpty()) {
+                List<RecordComponent> reversed = recordComponents.reverse();
+                for (RecordComponent rc : reversed) {
+                    result = result.prepend(rc);
+                }
+            }
+            return result;
+        }
+
         public Name flatName() {
             return flatname;
         }
 
         public boolean isSubClass(Symbol base, Types types) {
@@ -1388,19 +1451,22 @@
                                : sup.getAnnotationsByType(annoType);
         }
 
 
         @DefinedBy(Api.LANGUAGE_MODEL)
+        @SuppressWarnings("preview")
         public ElementKind getKind() {
             apiComplete();
             long flags = flags();
             if ((flags & ANNOTATION) != 0)
                 return ElementKind.ANNOTATION_TYPE;
             else if ((flags & INTERFACE) != 0)
                 return ElementKind.INTERFACE;
             else if ((flags & ENUM) != 0)
                 return ElementKind.ENUM;
+            else if ((flags & RECORD) != 0)
+                return ElementKind.RECORD;
             else
                 return ElementKind.CLASS;
         }
 
         @Override @DefinedBy(Api.LANGUAGE_MODEL)
@@ -1408,10 +1474,38 @@
             apiComplete();
             long flags = flags();
             return Flags.asModifierSet(flags & ~DEFAULT);
         }
 
+        public RecordComponent getRecordComponent(VarSymbol field) {
+            for (RecordComponent rc : recordComponents) {
+                if (rc.name == field.name) {
+                    return rc;
+                }
+            }
+            return null;
+        }
+
+        public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing) {
+            for (RecordComponent rc : recordComponents) {
+                if (rc.name == var.name) {
+                    return rc;
+                }
+            }
+            RecordComponent rc = null;
+            if (addIfMissing) {
+                recordComponents = recordComponents.append(rc = new RecordComponent(var));
+            }
+            return rc;
+        }
+
+        @Override @DefinedBy(Api.LANGUAGE_MODEL)
+        @SuppressWarnings("preview")
+        public List<? extends RecordComponent> getRecordComponents() {
+            return recordComponents;
+        }
+
         @DefinedBy(Api.LANGUAGE_MODEL)
         public NestingKind getNestingKind() {
             apiComplete();
             if (owner.kind == PCK)
                 return NestingKind.TOP_LEVEL;
@@ -1421,11 +1515,10 @@
                 return NestingKind.LOCAL;
             else
                 return NestingKind.MEMBER;
         }
 
-
         @Override
         protected <A extends Annotation> Attribute.Compound getAttribute(final Class<A> annoType) {
 
             Attribute.Compound attrib = super.getAttribute(annoType);
 
@@ -1437,13 +1530,10 @@
             ClassSymbol superType = getSuperClassToSearchForAnnotations();
             return superType == null ? null
                                      : superType.getAttribute(annoType);
         }
 
-
-
-
         @DefinedBy(Api.LANGUAGE_MODEL)
         public <R, P> R accept(ElementVisitor<R, P> v, P p) {
             return v.visitType(this, p);
         }
 
@@ -1498,10 +1588,14 @@
         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
             Assert.checkNonNull(a);
             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
             this.annotationTypeMetadata = a;
         }
+
+        public boolean isRecord() {
+            return (flags_field & RECORD) != 0;
+        }
     }
 
 
     /** A class for variable symbols
      */
@@ -1526,18 +1620,32 @@
          */
         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
             super(VAR, flags, name, type, owner);
         }
 
+        @Override
+        public int poolTag() {
+            return ClassFile.CONSTANT_Fieldref;
+        }
+
+        public MethodHandleSymbol asMethodHandle(boolean getter) {
+            return new MethodHandleSymbol(this, getter);
+        }
+
         /** Clone this symbol with new owner.
          */
         public VarSymbol clone(Symbol newOwner) {
             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
                 @Override
                 public Symbol baseSymbol() {
                     return VarSymbol.this;
                 }
+
+                @Override
+                public Object poolKey(Types types) {
+                    return new Pair<>(newOwner, baseSymbol());
+                }
             };
             v.pos = pos;
             v.adr = adr;
             v.data = data;
 //          System.out.println("clone " + v + " in " + newOwner);//DEBUG
@@ -1564,10 +1672,14 @@
                 return ElementKind.ENUM_CONSTANT;
             } else if (owner.kind == TYP || owner.kind == ERR) {
                 return ElementKind.FIELD;
             } else if (isResourceVariable()) {
                 return ElementKind.RESOURCE_VARIABLE;
+            } else if ((flags & MATCH_BINDING) != 0) {
+                @SuppressWarnings("preview")
+                ElementKind kind = ElementKind.BINDING_VARIABLE;
+                return kind;
             } else {
                 return ElementKind.LOCAL_VARIABLE;
             }
         }
 
@@ -1631,10 +1743,93 @@
         public <R, P> R accept(Symbol.Visitor<R, P> v, P p) {
             return v.visitVarSymbol(this, p);
         }
     }
 
+    @SuppressWarnings("preview")
+    public static class RecordComponent extends VarSymbol implements RecordComponentElement {
+        public MethodSymbol accessor;
+        public JCTree.JCMethodDecl accessorMeth;
+        private final List<JCAnnotation> originalAnnos;
+
+        /**
+         * Construct a record component, given its flags, name, type and owner.
+         */
+        public RecordComponent(JCVariableDecl fieldDecl) {
+            super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);
+            this.originalAnnos = fieldDecl.mods.annotations;
+        }
+
+        public List<JCAnnotation> getOriginalAnnos() { return originalAnnos; }
+
+        @Override @DefinedBy(Api.LANGUAGE_MODEL)
+        @SuppressWarnings("preview")
+        public ElementKind getKind() {
+            return ElementKind.RECORD_COMPONENT;
+        }
+
+        @Override @DefinedBy(Api.LANGUAGE_MODEL)
+        public ExecutableElement getAccessor() {
+            return accessor;
+        }
+
+        @Override @DefinedBy(Api.LANGUAGE_MODEL)
+        @SuppressWarnings("preview")
+        public <R, P> R accept(ElementVisitor<R, P> v, P p) {
+            return v.visitRecordComponent(this, p);
+        }
+    }
+
+    public static class ParamSymbol extends VarSymbol {
+        public ParamSymbol(long flags, Name name, Type type, Symbol owner) {
+            super(flags, name, type, owner);
+        }
+
+        @Override
+        public Name getSimpleName() {
+            if ((flags_field & NAME_FILLED) == 0) {
+                flags_field |= NAME_FILLED;
+                Symbol rootPack = this;
+                while (rootPack != null && !(rootPack instanceof RootPackageSymbol)) {
+                    rootPack = rootPack.owner;
+                }
+                if (rootPack != null) {
+                    Name inferredName =
+                            ((RootPackageSymbol) rootPack).missingInfoHandler.getParameterName(this);
+                    if (inferredName != null) {
+                        this.name = inferredName;
+                    }
+                }
+            }
+            return super.getSimpleName();
+        }
+
+    }
+
+    public static class BindingSymbol extends VarSymbol {
+
+        public BindingSymbol(Name name, Type type, Symbol owner) {
+            super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);
+        }
+
+        public boolean isAliasFor(BindingSymbol b) {
+            return aliases().containsAll(b.aliases());
+        }
+
+        List<BindingSymbol> aliases() {
+            return List.of(this);
+        }
+
+        public void preserveBinding() {
+            flags_field |= Flags.MATCH_BINDING_TO_OUTER;
+        }
+
+        public boolean isPreserved() {
+            return (flags_field & Flags.MATCH_BINDING_TO_OUTER) != 0;
+        }
+    }
+
     /** A class for method symbols.
      */
     public static class MethodSymbol extends Symbol implements ExecutableElement {
 
         /** The code of the method. */
@@ -1668,10 +1863,15 @@
             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
                 @Override
                 public Symbol baseSymbol() {
                     return MethodSymbol.this;
                 }
+
+                @Override
+                public Object poolKey(Types types) {
+                    return new Pair<>(newOwner, baseSymbol());
+                }
             };
             m.code = code;
             return m;
         }
 
@@ -1697,14 +1897,25 @@
                 }
                 return s;
             }
         }
 
-        public boolean isDynamic() {
+        @Override
+        public int poolTag() {
+            return owner.isInterface() ?
+                    ClassFile.CONSTANT_InterfaceMethodref : ClassFile.CONSTANT_Methodref;
+        }
+
+        public boolean isHandle() {
             return false;
         }
 
+
+        public MethodHandleSymbol asHandle() {
+            return new MethodHandleSymbol(this);
+        }
+
         /** find a symbol that this (proxy method) symbol implements.
          *  @param    c       The class whose members are searched for
          *                    implementations
          */
         public Symbol implemented(TypeSymbol c, Types types) {
@@ -1875,10 +2086,17 @@
 
         public boolean isLambdaMethod() {
             return (flags() & LAMBDA_METHOD) == LAMBDA_METHOD;
         }
 
+        /** override this method to point to the original enclosing method if this method symbol represents a synthetic
+         *  lambda method
+         */
+        public MethodSymbol originalEnclosingMethod() {
+            return this;
+        }
+
         /** The implementation of this (abstract) symbol in class origin;
          *  null if none exists. Synthetic methods are not considered
          *  as possible implementations.
          */
         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
@@ -1968,11 +2186,12 @@
             return v.visitMethodSymbol(this, p);
         }
 
         @DefinedBy(Api.LANGUAGE_MODEL)
         public Type getReceiverType() {
-            return asType().getReceiverType();
+            Type result = asType().getReceiverType();
+            return (result == null) ? Type.noType : result;
         }
 
         @DefinedBy(Api.LANGUAGE_MODEL)
         public Type getReturnType() {
             return asType().getReturnType();
@@ -1984,27 +2203,152 @@
         }
     }
 
     /** A class for invokedynamic method calls.
      */
-    public static class DynamicMethodSymbol extends MethodSymbol {
+    public static class DynamicMethodSymbol extends MethodSymbol implements Dynamic {
 
-        public Object[] staticArgs;
-        public Symbol bsm;
-        public int bsmKind;
+        public LoadableConstant[] staticArgs;
+        public MethodHandleSymbol bsm;
 
-        public DynamicMethodSymbol(Name name, Symbol owner, int bsmKind, MethodSymbol bsm, Type type, Object[] staticArgs) {
+        public DynamicMethodSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
             super(0, name, type, owner);
             this.bsm = bsm;
-            this.bsmKind = bsmKind;
             this.staticArgs = staticArgs;
         }
 
         @Override
         public boolean isDynamic() {
             return true;
         }
+
+        @Override
+        public LoadableConstant[] staticArgs() {
+            return staticArgs;
+        }
+
+        @Override
+        public MethodHandleSymbol bootstrapMethod() {
+            return bsm;
+        }
+
+        @Override
+        public int poolTag() {
+            return ClassFile.CONSTANT_InvokeDynamic;
+        }
+
+        @Override
+        public Type dynamicType() {
+            return type;
+        }
+    }
+
+    /** A class for condy.
+     */
+    public static class DynamicVarSymbol extends VarSymbol implements Dynamic, LoadableConstant {
+        public LoadableConstant[] staticArgs;
+        public MethodHandleSymbol bsm;
+
+        public DynamicVarSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
+            super(0, name, type, owner);
+            this.bsm = bsm;
+            this.staticArgs = staticArgs;
+        }
+
+        @Override
+        public boolean isDynamic() {
+            return true;
+        }
+
+        @Override
+        public PoolConstant dynamicType() {
+            return type;
+        }
+
+        @Override
+        public LoadableConstant[] staticArgs() {
+            return staticArgs;
+        }
+
+        @Override
+        public LoadableConstant bootstrapMethod() {
+            return bsm;
+        }
+
+        @Override
+        public int poolTag() {
+            return ClassFile.CONSTANT_Dynamic;
+        }
+    }
+
+    /** A class for method handles.
+     */
+    public static class MethodHandleSymbol extends MethodSymbol implements LoadableConstant {
+
+        private Symbol refSym;
+        private boolean getter;
+
+        public MethodHandleSymbol(Symbol msym) {
+            this(msym, false);
+        }
+
+        public MethodHandleSymbol(Symbol msym, boolean getter) {
+            super(msym.flags_field, msym.name, msym.type, msym.owner);
+            this.refSym = msym;
+            this.getter = getter;
+        }
+
+        /**
+         * Returns the kind associated with this method handle.
+         */
+        public int referenceKind() {
+            if (refSym.kind == VAR) {
+                return getter ?
+                        refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :
+                        refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;
+            } else {
+                if (refSym.isConstructor()) {
+                    return ClassFile.REF_newInvokeSpecial;
+                } else {
+                    if (refSym.isStatic()) {
+                        return ClassFile.REF_invokeStatic;
+                    } else if ((refSym.flags() & PRIVATE) != 0) {
+                        return ClassFile.REF_invokeSpecial;
+                    } else if (refSym.enclClass().isInterface()) {
+                        return ClassFile.REF_invokeInterface;
+                    } else {
+                        return ClassFile.REF_invokeVirtual;
+                    }
+                }
+            }
+        }
+
+        @Override
+        public int poolTag() {
+            return ClassFile.CONSTANT_MethodHandle;
+        }
+
+        @Override
+        public Object poolKey(Types types) {
+            return new Pair<>(baseSymbol(), referenceKind());
+        }
+
+        @Override
+        public MethodHandleSymbol asHandle() {
+            return this;
+        }
+
+        @Override
+        public Symbol baseSymbol() {
+            return refSym;
+        }
+
+
+        @Override
+        public boolean isHandle() {
+            return true;
+        }
     }
 
     /** A class for predefined operators.
      */
     public static class OperatorSymbol extends MethodSymbol {
@@ -2124,43 +2468,53 @@
         }
     }
 
     public static class CompletionFailure extends RuntimeException {
         private static final long serialVersionUID = 0;
-        public final DeferredCompletionFailureHandler dcfh;
-        public Symbol sym;
+        public final transient DeferredCompletionFailureHandler dcfh;
+        public transient Symbol sym;
 
         /** A diagnostic object describing the failure
          */
-        public JCDiagnostic diag;
+        private transient JCDiagnostic diag;
+
+        private transient Supplier<JCDiagnostic> diagSupplier;
 
-        public CompletionFailure(Symbol sym, JCDiagnostic diag, DeferredCompletionFailureHandler dcfh) {
+        public CompletionFailure(Symbol sym, Supplier<JCDiagnostic> diagSupplier, DeferredCompletionFailureHandler dcfh) {
             this.dcfh = dcfh;
             this.sym = sym;
-            this.diag = diag;
+            this.diagSupplier = diagSupplier;
 //          this.printStackTrace();//DEBUG
         }
 
         public JCDiagnostic getDiagnostic() {
+            if (diag == null && diagSupplier != null) {
+                diag = diagSupplier.get();
+            }
             return diag;
         }
 
         @Override
         public String getMessage() {
-            return diag.getMessage(null);
+            return getDiagnostic().getMessage(null);
         }
 
         public JCDiagnostic getDetailValue() {
-            return diag;
+            return getDiagnostic();
         }
 
         @Override
         public CompletionFailure initCause(Throwable cause) {
             super.initCause(cause);
             return this;
         }
 
+        public void resetDiagnostic(Supplier<JCDiagnostic> diagSupplier) {
+            this.diagSupplier = diagSupplier;
+            this.diag = null;
+        }
+
     }
 
     /**
      * A visitor for symbols.  A visitor is used to implement operations
      * (or relations) on symbols.  Most common operations on types are

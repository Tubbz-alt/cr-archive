<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacRoundEnvironment.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacProcessingEnvironment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PrintingProcessor.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/processing/JavacRoundEnvironment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 92      */
 93     @DefinedBy(Api.ANNOTATION_PROCESSING)
 94     public boolean errorRaised() {
 95         return errorRaised;
 96     }
 97 
 98     /**
 99      * Returns the type elements specified by the prior round.
100      *
101      * @return the types elements specified by the prior round, or an
102      * empty set if there were none
103      */
104     @DefinedBy(Api.ANNOTATION_PROCESSING)
105     public Set&lt;? extends Element&gt; getRootElements() {
106         return rootElements;
107     }
108 
109     /**
110      * Returns the elements annotated with the given annotation type.
111      * Only type elements &lt;i&gt;included&lt;/i&gt; in this round of annotation
<span class="line-modified">112      * processing, or declarations of members, parameters, or type</span>
<span class="line-modified">113      * parameters declared within those, are returned.  Included type</span>
<span class="line-modified">114      * elements are {@linkplain #getRootElements specified</span>
115      * types} and any types nested within them.
116      *
117      * @param a  annotation type being requested
118      * @return the elements annotated with the given annotation type,
119      * or an empty set if there are none
120      */
121     @DefinedBy(Api.ANNOTATION_PROCESSING)
122     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a) {
123         throwIfNotAnnotation(a);
124 
125         Set&lt;Element&gt; result = Collections.emptySet();
<span class="line-modified">126         ElementScanner9&lt;Set&lt;Element&gt;, TypeElement&gt; scanner =</span>
<span class="line-modified">127             new AnnotationSetScanner(result);</span>
128 
129         for (Element element : rootElements)
130             result = scanner.scan(element, a);
131 
132         return result;
133     }
134 
135     @DefinedBy(Api.ANNOTATION_PROCESSING)
136     public Set&lt;? extends Element&gt; getElementsAnnotatedWithAny(TypeElement... annotations) {
137         // Don&#39;t bother to special-case annotations.length == 1 as
138         // return getElementsAnnotatedWith(annotations[0]);
139 
140         Set&lt;TypeElement&gt; annotationSet = new LinkedHashSet&lt;&gt;(annotations.length);
141         for (TypeElement annotation : annotations) {
142             throwIfNotAnnotation(annotation);
143             annotationSet.add(annotation);
144         }
145 
146         Set&lt;Element&gt; result = Collections.emptySet();
<span class="line-modified">147         ElementScanner9&lt;Set&lt;Element&gt;, Set&lt;TypeElement&gt;&gt; scanner =</span>
<span class="line-modified">148             new AnnotationSetMultiScanner(result);</span>
149 
150         for (Element element : rootElements)
151             result = scanner.scan(element, annotationSet);
152 
153         return result;
154     }
155 
156     // Could be written as a local class inside getElementsAnnotatedWith

157     private class AnnotationSetScanner extends
<span class="line-modified">158         ElementScanningIncludingTypeParameters&lt;Set&lt;Element&gt;, TypeElement&gt; {</span>
159         // Insertion-order preserving set
160         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
161 
162         AnnotationSetScanner(Set&lt;Element&gt; defaultSet) {
163             super(defaultSet);
164         }
165 
166         @Override @DefinedBy(Api.LANGUAGE_MODEL)
167         public Set&lt;Element&gt; scan(Element e, TypeElement annotation) {
168             for (AnnotationMirror annotMirror :  eltUtils.getAllAnnotationMirrors(e)) {
169                 if (annotation.equals(mirrorAsElement(annotMirror))) {
170                     annotatedElements.add(e);
171                     break;
172                 }
173             }
174             e.accept(this, annotation);
175             return annotatedElements;
176         }
177 
178         @Override @DefinedBy(Api.LANGUAGE_MODEL)
179         public Set&lt;Element&gt; visitModule(ModuleElement e, TypeElement annotation) {
180             // Do not scan a module
181             return annotatedElements;
182         }
183 
184         @Override @DefinedBy(Api.LANGUAGE_MODEL)
185         public Set&lt;Element&gt; visitPackage(PackageElement e, TypeElement annotation) {
186             // Do not scan a package
187             return annotatedElements;
188         }
189     }
190 
191     // Could be written as a local class inside getElementsAnnotatedWithAny

192     private class AnnotationSetMultiScanner extends
<span class="line-modified">193         ElementScanningIncludingTypeParameters&lt;Set&lt;Element&gt;, Set&lt;TypeElement&gt;&gt; {</span>
194         // Insertion-order preserving set
195         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
196 
197         AnnotationSetMultiScanner(Set&lt;Element&gt; defaultSet) {
198             super(defaultSet);
199         }
200 
201         @Override @DefinedBy(Api.LANGUAGE_MODEL)
202         public Set&lt;Element&gt; scan(Element e, Set&lt;TypeElement&gt; annotations) {
203             for (AnnotationMirror annotMirror : eltUtils.getAllAnnotationMirrors(e)) {
204                 if (annotations.contains(mirrorAsElement(annotMirror))) {
205                     annotatedElements.add(e);
206                     break;
207                 }
208             }
209             e.accept(this, annotations);
210             return annotatedElements;
211         }
212 
213         @Override @DefinedBy(Api.LANGUAGE_MODEL)
214         public Set&lt;Element&gt; visitModule(ModuleElement e, Set&lt;TypeElement&gt; annotations) {
215             // Do not scan a module
216             return annotatedElements;
217         }
218 
219         @Override @DefinedBy(Api.LANGUAGE_MODEL)
220         public Set&lt;Element&gt; visitPackage(PackageElement e, Set&lt;TypeElement&gt; annotations) {
221             // Do not scan a package
222             return annotatedElements;
223         }
224     }
225 
<span class="line-removed">226     private static abstract class ElementScanningIncludingTypeParameters&lt;R, P&gt;</span>
<span class="line-removed">227         extends ElementScanner9&lt;R, P&gt; {</span>
<span class="line-removed">228 </span>
<span class="line-removed">229         protected ElementScanningIncludingTypeParameters(R defaultValue) {</span>
<span class="line-removed">230             super(defaultValue);</span>
<span class="line-removed">231         }</span>
<span class="line-removed">232 </span>
<span class="line-removed">233         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-removed">234         public R visitType(TypeElement e, P p) {</span>
<span class="line-removed">235             // Type parameters are not considered to be enclosed by a type</span>
<span class="line-removed">236             scan(e.getTypeParameters(), p);</span>
<span class="line-removed">237             return super.visitType(e, p);</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239 </span>
<span class="line-removed">240         @Override @DefinedBy(Api.LANGUAGE_MODEL)</span>
<span class="line-removed">241         public R visitExecutable(ExecutableElement e, P p) {</span>
<span class="line-removed">242             // Type parameters are not considered to be enclosed by an executable</span>
<span class="line-removed">243             scan(e.getTypeParameters(), p);</span>
<span class="line-removed">244             return super.visitExecutable(e, p);</span>
<span class="line-removed">245         }</span>
<span class="line-removed">246     }</span>
<span class="line-removed">247 </span>
248     /**
249      * {@inheritDoc}
250      */
251     @DefinedBy(Api.ANNOTATION_PROCESSING)
252     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a) {
253         throwIfNotAnnotation(a);
254         String name = a.getCanonicalName();
255 
256         if (name == null)
257             return Collections.emptySet();
258         else {
259             TypeElement annotationType = annotationToElement(a);
260 
261             if (annotationType == null)
262                 return Collections.emptySet();
263             else
264                 return getElementsAnnotatedWith(annotationType);
265         }
266     }
267 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 92      */
 93     @DefinedBy(Api.ANNOTATION_PROCESSING)
 94     public boolean errorRaised() {
 95         return errorRaised;
 96     }
 97 
 98     /**
 99      * Returns the type elements specified by the prior round.
100      *
101      * @return the types elements specified by the prior round, or an
102      * empty set if there were none
103      */
104     @DefinedBy(Api.ANNOTATION_PROCESSING)
105     public Set&lt;? extends Element&gt; getRootElements() {
106         return rootElements;
107     }
108 
109     /**
110      * Returns the elements annotated with the given annotation type.
111      * Only type elements &lt;i&gt;included&lt;/i&gt; in this round of annotation
<span class="line-modified">112      * processing, or declarations of members, parameters, type</span>
<span class="line-modified">113      * parameters, or record components declared within those, are returned.</span>
<span class="line-modified">114      * Included type elements are {@linkplain #getRootElements specified</span>
115      * types} and any types nested within them.
116      *
117      * @param a  annotation type being requested
118      * @return the elements annotated with the given annotation type,
119      * or an empty set if there are none
120      */
121     @DefinedBy(Api.ANNOTATION_PROCESSING)
122     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a) {
123         throwIfNotAnnotation(a);
124 
125         Set&lt;Element&gt; result = Collections.emptySet();
<span class="line-modified">126         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">127         var scanner = new AnnotationSetScanner(result);</span>
128 
129         for (Element element : rootElements)
130             result = scanner.scan(element, a);
131 
132         return result;
133     }
134 
135     @DefinedBy(Api.ANNOTATION_PROCESSING)
136     public Set&lt;? extends Element&gt; getElementsAnnotatedWithAny(TypeElement... annotations) {
137         // Don&#39;t bother to special-case annotations.length == 1 as
138         // return getElementsAnnotatedWith(annotations[0]);
139 
140         Set&lt;TypeElement&gt; annotationSet = new LinkedHashSet&lt;&gt;(annotations.length);
141         for (TypeElement annotation : annotations) {
142             throwIfNotAnnotation(annotation);
143             annotationSet.add(annotation);
144         }
145 
146         Set&lt;Element&gt; result = Collections.emptySet();
<span class="line-modified">147         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-modified">148         var scanner = new AnnotationSetMultiScanner(result);</span>
149 
150         for (Element element : rootElements)
151             result = scanner.scan(element, annotationSet);
152 
153         return result;
154     }
155 
156     // Could be written as a local class inside getElementsAnnotatedWith
<span class="line-added">157     @SuppressWarnings(&quot;preview&quot;)</span>
158     private class AnnotationSetScanner extends
<span class="line-modified">159         ElementScanner14&lt;Set&lt;Element&gt;, TypeElement&gt; {</span>
160         // Insertion-order preserving set
161         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
162 
163         AnnotationSetScanner(Set&lt;Element&gt; defaultSet) {
164             super(defaultSet);
165         }
166 
167         @Override @DefinedBy(Api.LANGUAGE_MODEL)
168         public Set&lt;Element&gt; scan(Element e, TypeElement annotation) {
169             for (AnnotationMirror annotMirror :  eltUtils.getAllAnnotationMirrors(e)) {
170                 if (annotation.equals(mirrorAsElement(annotMirror))) {
171                     annotatedElements.add(e);
172                     break;
173                 }
174             }
175             e.accept(this, annotation);
176             return annotatedElements;
177         }
178 
179         @Override @DefinedBy(Api.LANGUAGE_MODEL)
180         public Set&lt;Element&gt; visitModule(ModuleElement e, TypeElement annotation) {
181             // Do not scan a module
182             return annotatedElements;
183         }
184 
185         @Override @DefinedBy(Api.LANGUAGE_MODEL)
186         public Set&lt;Element&gt; visitPackage(PackageElement e, TypeElement annotation) {
187             // Do not scan a package
188             return annotatedElements;
189         }
190     }
191 
192     // Could be written as a local class inside getElementsAnnotatedWithAny
<span class="line-added">193     @SuppressWarnings(&quot;preview&quot;)</span>
194     private class AnnotationSetMultiScanner extends
<span class="line-modified">195         ElementScanner14&lt;Set&lt;Element&gt;, Set&lt;TypeElement&gt;&gt; {</span>
196         // Insertion-order preserving set
197         private Set&lt;Element&gt; annotatedElements = new LinkedHashSet&lt;&gt;();
198 
199         AnnotationSetMultiScanner(Set&lt;Element&gt; defaultSet) {
200             super(defaultSet);
201         }
202 
203         @Override @DefinedBy(Api.LANGUAGE_MODEL)
204         public Set&lt;Element&gt; scan(Element e, Set&lt;TypeElement&gt; annotations) {
205             for (AnnotationMirror annotMirror : eltUtils.getAllAnnotationMirrors(e)) {
206                 if (annotations.contains(mirrorAsElement(annotMirror))) {
207                     annotatedElements.add(e);
208                     break;
209                 }
210             }
211             e.accept(this, annotations);
212             return annotatedElements;
213         }
214 
215         @Override @DefinedBy(Api.LANGUAGE_MODEL)
216         public Set&lt;Element&gt; visitModule(ModuleElement e, Set&lt;TypeElement&gt; annotations) {
217             // Do not scan a module
218             return annotatedElements;
219         }
220 
221         @Override @DefinedBy(Api.LANGUAGE_MODEL)
222         public Set&lt;Element&gt; visitPackage(PackageElement e, Set&lt;TypeElement&gt; annotations) {
223             // Do not scan a package
224             return annotatedElements;
225         }
226     }
227 






















228     /**
229      * {@inheritDoc}
230      */
231     @DefinedBy(Api.ANNOTATION_PROCESSING)
232     public Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a) {
233         throwIfNotAnnotation(a);
234         String name = a.getCanonicalName();
235 
236         if (name == null)
237             return Collections.emptySet();
238         else {
239             TypeElement annotationType = annotationToElement(a);
240 
241             if (annotationType == null)
242                 return Collections.emptySet();
243             else
244                 return getElementsAnnotatedWith(annotationType);
245         }
246     }
247 
</pre>
</td>
</tr>
</table>
<center><a href="JavacProcessingEnvironment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PrintingProcessor.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
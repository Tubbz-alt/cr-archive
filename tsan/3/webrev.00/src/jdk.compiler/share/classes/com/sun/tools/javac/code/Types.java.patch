diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
@@ -46,10 +46,12 @@
 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
 import com.sun.tools.javac.comp.AttrContext;
 import com.sun.tools.javac.comp.Check;
 import com.sun.tools.javac.comp.Enter;
 import com.sun.tools.javac.comp.Env;
+import com.sun.tools.javac.comp.LambdaToMethod;
+import com.sun.tools.javac.jvm.ClassFile;
 import com.sun.tools.javac.util.*;
 
 import static com.sun.tools.javac.code.BoundKind.*;
 import static com.sun.tools.javac.code.Flags.*;
 import static com.sun.tools.javac.code.Kinds.Kind.*;
@@ -219,11 +221,11 @@
      * and (ii) S is an upper bound of T.
      *
      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
      * and (ii) S is a lower bound of T.
      *
-     * Note that projections are only allowed to touch variables in V. Theferore it is possible for
+     * Note that projections are only allowed to touch variables in V. Therefore, it is possible for
      * a projection to leave its input type unchanged if it does not contain any variables in V.
      *
      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
      * a downwards projection is not always defined.
      *
@@ -635,11 +637,11 @@
      * messages.
      */
     public static class FunctionDescriptorLookupError extends RuntimeException {
         private static final long serialVersionUID = 0;
 
-        JCDiagnostic diagnostic;
+        transient JCDiagnostic diagnostic;
 
         FunctionDescriptorLookupError() {
             this.diagnostic = null;
         }
 
@@ -2729,11 +2731,11 @@
     /**
      * Returns true iff the first signature is a <em>sub
      * signature</em> of the other.  This is <b>not</b> an equivalence
      * relation.
      *
-     * @jls section 8.4.2.
+     * @jls 8.4.2 Method Signature
      * @see #overrideEquivalent(Type t, Type s)
      * @param t first signature (possibly raw).
      * @param s second signature (could be subjected to erasure).
      * @return true if t is a sub signature of s.
      */
@@ -2748,11 +2750,11 @@
     /**
      * Returns true iff these signatures are related by <em>override
      * equivalence</em>.  This is the natural extension of
      * isSubSignature to an equivalence relation.
      *
-     * @jls section 8.4.2.
+     * @jls 8.4.2 Method Signature
      * @see #isSubSignature(Type t, Type s)
      * @param t a signature (possible raw, could be subjected to
      * erasure).
      * @param s a signature (possible raw, could be subjected to
      * erasure).
@@ -3741,16 +3743,13 @@
             return cl2;
         } else if (cl2.isEmpty()) {
             return cl1;
         } else if (shouldSkip.test(cl1.head, cl2.head)) {
             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
-        } else if (cl1.head.tsym.precedes(cl2.head.tsym, this)) {
-            return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
         } else {
-            // unrelated types
             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
         }
     }
 
     public List<Type> union(List<Type> cl1, List<Type> cl2) {
@@ -4210,11 +4209,11 @@
         return covariantReturnType(tres, sres, warner);
     }
 
     /**
      * Return-Type-Substitutable.
-     * @jls section 8.4.5
+     * @jls 8.4.5 Method Result
      */
     public boolean returnTypeSubstitutable(Type r1, Type r2) {
         if (hasSameArgs(r1, r2))
             return resultSubtype(r1, r2, noWarnings);
         else
@@ -4998,11 +4997,11 @@
     public static abstract class SignatureGenerator {
 
         public static class InvalidSignatureException extends RuntimeException {
             private static final long serialVersionUID = 0;
 
-            private final Type type;
+            private final transient Type type;
 
             InvalidSignatureException(Type type) {
                 this.type = type;
             }
 
@@ -5173,16 +5172,41 @@
                 }
             }
             append('>');
         }
 
-        private void assembleSig(List<Type> types) {
+        public void assembleSig(List<Type> types) {
             for (List<Type> ts = types; ts.nonEmpty(); ts = ts.tail) {
                 assembleSig(ts.head);
             }
         }
     }
+
+    public Type constantType(LoadableConstant c) {
+        switch (c.poolTag()) {
+            case ClassFile.CONSTANT_Class:
+                return syms.classType;
+            case ClassFile.CONSTANT_String:
+                return syms.stringType;
+            case ClassFile.CONSTANT_Integer:
+                return syms.intType;
+            case ClassFile.CONSTANT_Float:
+                return syms.floatType;
+            case ClassFile.CONSTANT_Long:
+                return syms.longType;
+            case ClassFile.CONSTANT_Double:
+                return syms.doubleType;
+            case ClassFile.CONSTANT_MethodHandle:
+                return syms.methodHandleType;
+            case ClassFile.CONSTANT_MethodType:
+                return syms.methodTypeType;
+            case ClassFile.CONSTANT_Dynamic:
+                return ((DynamicVarSymbol)c).type;
+            default:
+                throw new AssertionError("Not a loadable constant: " + c.poolTag());
+        }
+    }
     // </editor-fold>
 
     public void newRound() {
         descCache._map.clear();
         isDerivedRawCache.clear();

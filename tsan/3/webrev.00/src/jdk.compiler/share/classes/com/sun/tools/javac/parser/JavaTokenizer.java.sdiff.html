<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocCommentParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 


  28 import com.sun.tools.javac.code.Preview;
  29 import com.sun.tools.javac.code.Source;
  30 import com.sun.tools.javac.code.Source.Feature;
  31 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  32 import com.sun.tools.javac.resources.CompilerProperties.Errors;

  33 import com.sun.tools.javac.util.*;
<span class="line-modified">  34 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;</span>
  35 


  36 import java.nio.CharBuffer;


  37 
  38 import static com.sun.tools.javac.parser.Tokens.*;
  39 import static com.sun.tools.javac.util.LayoutCharacters.*;
  40 
  41 /** The lexical analyzer maps an input stream consisting of
  42  *  ASCII characters and Unicode escapes into a token sequence.
  43  *
  44  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  45  *  If you write code that depends on this, you do so at your own risk.
  46  *  This code and its internal interfaces are subject to change or
  47  *  deletion without notice.&lt;/b&gt;
  48  */
  49 public class JavaTokenizer {
  50 
  51     private static final boolean scannerDebug = false;
  52 
  53     /** The source language setting.
  54      */
  55     private Source source;
  56 
</pre>
<hr />
<pre>
  67     /** The token kind, set by nextToken().
  68      */
  69     protected TokenKind tk;
  70 
  71     /** The token&#39;s radix, set by nextToken().
  72      */
  73     protected int radix;
  74 
  75     /** The token&#39;s name, set by nextToken().
  76      */
  77     protected Name name;
  78 
  79     /** The position where a lexical error occurred;
  80      */
  81     protected int errPos = Position.NOPOS;
  82 
  83     /** The Unicode reader (low-level stream reader).
  84      */
  85     protected UnicodeReader reader;
  86 








  87     protected ScannerFactory fac;
  88 





  89     private static final boolean hexFloatsWork = hexFloatsWork();
  90     private static boolean hexFloatsWork() {
  91         try {
  92             Float.valueOf(&quot;0x1.0p1&quot;);
  93             return true;
  94         } catch (NumberFormatException ex) {
  95             return false;
  96         }
  97     }
  98 
  99     /**
 100      * Create a scanner from the input array.  This method might
 101      * modify the array.  To avoid copying the input array, ensure
 102      * that {@code inputLength &lt; input.length} or
 103      * {@code input[input.length -1]} is a white space character.
 104      *
 105      * @param fac the factory which created this Scanner
 106      * @param buf the input, might be modified
 107      * Must be positive and less than or equal to input.length.
 108      */
 109     protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {
 110         this(fac, new UnicodeReader(fac, buf));
 111     }
 112 
 113     protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {
 114         this(fac, new UnicodeReader(fac, buf, inputLength));
 115     }
 116 
 117     protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {
 118         this.fac = fac;
 119         this.log = fac.log;
 120         this.tokens = fac.tokens;
 121         this.source = fac.source;
 122         this.preview = fac.preview;
 123         this.reader = reader;

 124     }
 125 
 126     protected void checkSourceLevel(int pos, Feature feature) {
 127         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
 128             //preview feature without --preview flag, error
 129             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
 130         } else if (!feature.allowedInSource(source)) {
 131             //incompatible source level, error
 132             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
 133         } else if (preview.isPreview(feature)) {
 134             //use of preview feature, warn
 135             preview.warnPreview(pos, feature);
 136         }
 137     }
 138 
 139     /** Report an error at the given position using the provided arguments.
 140      */
 141     protected void lexError(int pos, JCDiagnostic.Error key) {
 142         log.error(pos, key);
 143         tk = TokenKind.ERROR;
 144         errPos = pos;
 145     }
 146 
 147     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
 148         log.error(flags, pos, key);
 149         tk = TokenKind.ERROR;
 150         errPos = pos;
 151     }
 152 





 153     /** Read next character in character or string literal and copy into sbuf.





 154      */
<span class="line-modified"> 155     private void scanLitChar(int pos) {</span>
<span class="line-modified"> 156         if (reader.ch == &#39;\\&#39;) {</span>
 157             if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {
 158                 reader.skipChar();
<span class="line-modified"> 159                 reader.putChar(&#39;\\&#39;, true);</span>



 160             } else {
<span class="line-modified"> 161                 reader.scanChar();</span>
 162                 switch (reader.ch) {
 163                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
 164                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
 165                     char leadch = reader.ch;
 166                     int oct = reader.digit(pos, 8);
<span class="line-modified"> 167                     reader.scanChar();</span>
 168                     if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 169                         oct = oct * 8 + reader.digit(pos, 8);
<span class="line-modified"> 170                         reader.scanChar();</span>
 171                         if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 172                             oct = oct * 8 + reader.digit(pos, 8);
<span class="line-modified"> 173                             reader.scanChar();</span>
 174                         }
 175                     }
<span class="line-modified"> 176                     reader.putChar((char)oct);</span>


 177                     break;
 178                 case &#39;b&#39;:
<span class="line-modified"> 179                     reader.putChar(&#39;\b&#39;, true); break;</span>
 180                 case &#39;t&#39;:
<span class="line-modified"> 181                     reader.putChar(&#39;\t&#39;, true); break;</span>
 182                 case &#39;n&#39;:
<span class="line-modified"> 183                     reader.putChar(&#39;\n&#39;, true); break;</span>
 184                 case &#39;f&#39;:
<span class="line-modified"> 185                     reader.putChar(&#39;\f&#39;, true); break;</span>
 186                 case &#39;r&#39;:
<span class="line-modified"> 187                     reader.putChar(&#39;\r&#39;, true); break;</span>
 188                 case &#39;\&#39;&#39;:
<span class="line-removed"> 189                     reader.putChar(&#39;\&#39;&#39;, true); break;</span>
 190                 case &#39;\&quot;&#39;:
<span class="line-removed"> 191                     reader.putChar(&#39;\&quot;&#39;, true); break;</span>
 192                 case &#39;\\&#39;:
<span class="line-modified"> 193                     reader.putChar(&#39;\\&#39;, true); break;</span>

















 194                 default:
 195                     lexError(reader.bp, Errors.IllegalEscChar);
 196                 }
 197             }
 198         } else if (reader.bp != reader.buflen) {
 199             reader.putChar(true);
 200         }
 201     }
 202 






















































































































































































































































 203     private void scanDigits(int pos, int digitRadix) {
 204         char saveCh;
 205         int savePos;
 206         do {
 207             if (reader.ch != &#39;_&#39;) {
 208                 reader.putChar(false);
 209             }
 210             saveCh = reader.ch;
 211             savePos = reader.bp;
 212             reader.scanChar();
 213         } while (reader.digit(pos, digitRadix) &gt;= 0 || reader.ch == &#39;_&#39;);
 214         if (saveCh == &#39;_&#39;)
 215             lexError(savePos, Errors.IllegalUnderscore);
 216     }
 217 
 218     /** Read fractional part of hexadecimal floating point number.
 219      */
 220     private void scanHexExponentAndSuffix(int pos) {
 221         if (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;) {
 222             reader.putChar(true);
</pre>
<hr />
<pre>
 607                             reader.scanChar();
 608                             comments = addComment(comments, processComment(pos, reader.bp, style));
 609                             break;
 610                         } else {
 611                             lexError(pos, Errors.UnclosedComment);
 612                             break loop;
 613                         }
 614                     } else if (reader.ch == &#39;=&#39;) {
 615                         tk = TokenKind.SLASHEQ;
 616                         reader.scanChar();
 617                     } else {
 618                         tk = TokenKind.SLASH;
 619                     }
 620                     break loop;
 621                 case &#39;\&#39;&#39;:
 622                     reader.scanChar();
 623                     if (reader.ch == &#39;\&#39;&#39;) {
 624                         lexError(pos, Errors.EmptyCharLit);
 625                         reader.scanChar();
 626                     } else {
<span class="line-modified"> 627                         if (reader.ch == CR || reader.ch == LF)</span>
 628                             lexError(pos, Errors.IllegalLineEndInCharLit);
<span class="line-modified"> 629                         scanLitChar(pos);</span>
 630                         if (reader.ch == &#39;\&#39;&#39;) {
 631                             reader.scanChar();
 632                             tk = TokenKind.CHARLITERAL;
 633                         } else {
 634                             lexError(pos, Errors.UnclosedCharLit);
 635                         }
 636                     }
 637                     break loop;
 638                 case &#39;\&quot;&#39;:
<span class="line-modified"> 639                     reader.scanChar();</span>
<span class="line-removed"> 640                     while (reader.ch != &#39;\&quot;&#39; &amp;&amp; reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen)</span>
<span class="line-removed"> 641                         scanLitChar(pos);</span>
<span class="line-removed"> 642                     if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="line-removed"> 643                         tk = TokenKind.STRINGLITERAL;</span>
<span class="line-removed"> 644                         reader.scanChar();</span>
<span class="line-removed"> 645                     } else {</span>
<span class="line-removed"> 646                         lexError(pos, Errors.UnclosedStrLit);</span>
<span class="line-removed"> 647                     }</span>
 648                     break loop;
<span class="line-modified"> 649                default:</span>
 650                     if (isSpecial(reader.ch)) {
 651                         scanOperator();
 652                     } else {
 653                         boolean isJavaIdentifierStart;
 654                         int codePoint = -1;
 655                         if (reader.ch &lt; &#39;\u0080&#39;) {
 656                             // all ASCII range chars already handled, above
 657                             isJavaIdentifierStart = false;
 658                         } else {
 659                             codePoint = reader.peekSurrogates();
 660                             if (codePoint &gt;= 0) {
 661                                 if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {
 662                                     reader.putChar(true);
 663                                 }
 664                             } else {
 665                                 isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);
 666                             }
 667                         }
 668                         if (isJavaIdentifierStart) {
 669                             scanIdent();
</pre>
<hr />
<pre>
 678                             if (codePoint &gt;= 0) {
 679                                 char high = reader.ch;
 680                                 reader.scanChar();
 681                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) high, (int)reader.ch);
 682                             } else {
 683                                 arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ?
 684                                                 String.format(&quot;%s&quot;, reader.ch) :
 685                                                 String.format(&quot;\\u%04x&quot;, (int)reader.ch);
 686                             }
 687                             lexError(pos, Errors.IllegalChar(arg));
 688                             reader.scanChar();
 689                         }
 690                     }
 691                     break loop;
 692                 }
 693             }
 694             endPos = reader.bp;
 695             switch (tk.tag) {
 696                 case DEFAULT: return new Token(tk, pos, endPos, comments);
 697                 case NAMED: return new NamedToken(tk, pos, endPos, name, comments);
<span class="line-modified"> 698                 case STRING: return new StringToken(tk, pos, endPos, reader.chars(), comments);</span>



































 699                 case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);
 700                 default: throw new AssertionError();
 701             }
 702         }
 703         finally {
 704             if (scannerDebug) {
 705                     System.out.println(&quot;nextToken(&quot; + pos
 706                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
 707                                        new String(reader.getRawCharacters(pos, endPos))
 708                                        + &quot;|&quot;);
 709             }
 710         }
 711     }
 712     //where
 713         List&lt;Comment&gt; addComment(List&lt;Comment&gt; comments, Comment comment) {
 714             return comments == null ?
 715                     List.of(comment) :
 716                     comments.prepend(comment);
 717         }
 718 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
<span class="line-added">  28 import com.sun.tools.javac.code.Lint;</span>
<span class="line-added">  29 import com.sun.tools.javac.code.Lint.LintCategory;</span>
  30 import com.sun.tools.javac.code.Preview;
  31 import com.sun.tools.javac.code.Source;
  32 import com.sun.tools.javac.code.Source.Feature;
  33 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  34 import com.sun.tools.javac.resources.CompilerProperties.Errors;
<span class="line-added">  35 import com.sun.tools.javac.resources.CompilerProperties.Warnings;</span>
  36 import com.sun.tools.javac.util.*;
<span class="line-modified">  37 import com.sun.tools.javac.util.JCDiagnostic.*;</span>
  38 
<span class="line-added">  39 import java.lang.reflect.InvocationTargetException;</span>
<span class="line-added">  40 import java.lang.reflect.Method;</span>
  41 import java.nio.CharBuffer;
<span class="line-added">  42 import java.util.HashSet;</span>
<span class="line-added">  43 import java.util.Set;</span>
  44 
  45 import static com.sun.tools.javac.parser.Tokens.*;
  46 import static com.sun.tools.javac.util.LayoutCharacters.*;
  47 
  48 /** The lexical analyzer maps an input stream consisting of
  49  *  ASCII characters and Unicode escapes into a token sequence.
  50  *
  51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  52  *  If you write code that depends on this, you do so at your own risk.
  53  *  This code and its internal interfaces are subject to change or
  54  *  deletion without notice.&lt;/b&gt;
  55  */
  56 public class JavaTokenizer {
  57 
  58     private static final boolean scannerDebug = false;
  59 
  60     /** The source language setting.
  61      */
  62     private Source source;
  63 
</pre>
<hr />
<pre>
  74     /** The token kind, set by nextToken().
  75      */
  76     protected TokenKind tk;
  77 
  78     /** The token&#39;s radix, set by nextToken().
  79      */
  80     protected int radix;
  81 
  82     /** The token&#39;s name, set by nextToken().
  83      */
  84     protected Name name;
  85 
  86     /** The position where a lexical error occurred;
  87      */
  88     protected int errPos = Position.NOPOS;
  89 
  90     /** The Unicode reader (low-level stream reader).
  91      */
  92     protected UnicodeReader reader;
  93 
<span class="line-added">  94     /** If is a text block</span>
<span class="line-added">  95      */</span>
<span class="line-added">  96     protected boolean isTextBlock;</span>
<span class="line-added">  97 </span>
<span class="line-added">  98     /** If contains escape sequences</span>
<span class="line-added">  99      */</span>
<span class="line-added"> 100     protected boolean hasEscapeSequences;</span>
<span class="line-added"> 101 </span>
 102     protected ScannerFactory fac;
 103 
<span class="line-added"> 104     // The set of lint options currently in effect. It is initialized</span>
<span class="line-added"> 105     // from the context, and then is set/reset as needed by Attr as it</span>
<span class="line-added"> 106     // visits all the various parts of the trees during attribution.</span>
<span class="line-added"> 107     protected Lint lint;</span>
<span class="line-added"> 108 </span>
 109     private static final boolean hexFloatsWork = hexFloatsWork();
 110     private static boolean hexFloatsWork() {
 111         try {
 112             Float.valueOf(&quot;0x1.0p1&quot;);
 113             return true;
 114         } catch (NumberFormatException ex) {
 115             return false;
 116         }
 117     }
 118 
 119     /**
 120      * Create a scanner from the input array.  This method might
 121      * modify the array.  To avoid copying the input array, ensure
 122      * that {@code inputLength &lt; input.length} or
 123      * {@code input[input.length -1]} is a white space character.
 124      *
 125      * @param fac the factory which created this Scanner
 126      * @param buf the input, might be modified
 127      * Must be positive and less than or equal to input.length.
 128      */
 129     protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {
 130         this(fac, new UnicodeReader(fac, buf));
 131     }
 132 
 133     protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {
 134         this(fac, new UnicodeReader(fac, buf, inputLength));
 135     }
 136 
 137     protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {
 138         this.fac = fac;
 139         this.log = fac.log;
 140         this.tokens = fac.tokens;
 141         this.source = fac.source;
 142         this.preview = fac.preview;
 143         this.reader = reader;
<span class="line-added"> 144         this.lint = fac.lint;</span>
 145     }
 146 
 147     protected void checkSourceLevel(int pos, Feature feature) {
 148         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
 149             //preview feature without --preview flag, error
 150             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
 151         } else if (!feature.allowedInSource(source)) {
 152             //incompatible source level, error
 153             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
 154         } else if (preview.isPreview(feature)) {
 155             //use of preview feature, warn
 156             preview.warnPreview(pos, feature);
 157         }
 158     }
 159 
 160     /** Report an error at the given position using the provided arguments.
 161      */
 162     protected void lexError(int pos, JCDiagnostic.Error key) {
 163         log.error(pos, key);
 164         tk = TokenKind.ERROR;
 165         errPos = pos;
 166     }
 167 
 168     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
 169         log.error(flags, pos, key);
 170         tk = TokenKind.ERROR;
 171         errPos = pos;
 172     }
 173 
<span class="line-added"> 174     protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {</span>
<span class="line-added"> 175         DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;</span>
<span class="line-added"> 176         log.warning(lc, dp, key);</span>
<span class="line-added"> 177     }</span>
<span class="line-added"> 178 </span>
 179     /** Read next character in character or string literal and copy into sbuf.
<span class="line-added"> 180      *      pos - start of literal offset</span>
<span class="line-added"> 181      *      translateEscapesNow - true if String::translateEscapes is not available</span>
<span class="line-added"> 182      *                            in the java.base libs. Occurs during bootstrapping.</span>
<span class="line-added"> 183      *      multiline - true if scanning a text block. Allows newlines to be embedded</span>
<span class="line-added"> 184      *                  in the result.</span>
 185      */
<span class="line-modified"> 186     private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {</span>
<span class="line-modified"> 187          if (reader.ch == &#39;\\&#39;) {</span>
 188             if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {
 189                 reader.skipChar();
<span class="line-modified"> 190                 if (!translateEscapesNow) {</span>
<span class="line-added"> 191                     reader.putChar(false);</span>
<span class="line-added"> 192                 }</span>
<span class="line-added"> 193                 reader.putChar(true);</span>
 194             } else {
<span class="line-modified"> 195                 reader.nextChar(translateEscapesNow);</span>
 196                 switch (reader.ch) {
 197                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
 198                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
 199                     char leadch = reader.ch;
 200                     int oct = reader.digit(pos, 8);
<span class="line-modified"> 201                     reader.nextChar(translateEscapesNow);</span>
 202                     if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 203                         oct = oct * 8 + reader.digit(pos, 8);
<span class="line-modified"> 204                         reader.nextChar(translateEscapesNow);</span>
 205                         if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 206                             oct = oct * 8 + reader.digit(pos, 8);
<span class="line-modified"> 207                             reader.nextChar(translateEscapesNow);</span>
 208                         }
 209                     }
<span class="line-modified"> 210                     if (translateEscapesNow) {</span>
<span class="line-added"> 211                         reader.putChar((char)oct);</span>
<span class="line-added"> 212                     }</span>
 213                     break;
 214                 case &#39;b&#39;:
<span class="line-modified"> 215                     reader.putChar(translateEscapesNow ? &#39;\b&#39; : &#39;b&#39;, true); break;</span>
 216                 case &#39;t&#39;:
<span class="line-modified"> 217                     reader.putChar(translateEscapesNow ? &#39;\t&#39; : &#39;t&#39;, true); break;</span>
 218                 case &#39;n&#39;:
<span class="line-modified"> 219                     reader.putChar(translateEscapesNow ? &#39;\n&#39; : &#39;n&#39;, true); break;</span>
 220                 case &#39;f&#39;:
<span class="line-modified"> 221                     reader.putChar(translateEscapesNow ? &#39;\f&#39; : &#39;f&#39;, true); break;</span>
 222                 case &#39;r&#39;:
<span class="line-modified"> 223                     reader.putChar(translateEscapesNow ? &#39;\r&#39; : &#39;r&#39;, true); break;</span>
 224                 case &#39;\&#39;&#39;:

 225                 case &#39;\&quot;&#39;:

 226                 case &#39;\\&#39;:
<span class="line-modified"> 227                     reader.putChar(true); break;</span>
<span class="line-added"> 228                 case &#39;s&#39;:</span>
<span class="line-added"> 229                     checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-added"> 230                     reader.putChar(translateEscapesNow ? &#39; &#39; : &#39;s&#39;, true); break;</span>
<span class="line-added"> 231                 case &#39;\n&#39;:</span>
<span class="line-added"> 232                 case &#39;\r&#39;:</span>
<span class="line-added"> 233                     if (!multiline) {</span>
<span class="line-added"> 234                         lexError(reader.bp, Errors.IllegalEscChar);</span>
<span class="line-added"> 235                     } else {</span>
<span class="line-added"> 236                         int start = reader.bp;</span>
<span class="line-added"> 237                         checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-added"> 238                         if (reader.ch == &#39;\r&#39; &amp;&amp; reader.peekChar() == &#39;\n&#39;) {</span>
<span class="line-added"> 239                            reader.nextChar(translateEscapesNow);</span>
<span class="line-added"> 240                         }</span>
<span class="line-added"> 241                         reader.nextChar(translateEscapesNow);</span>
<span class="line-added"> 242                         processLineTerminator(start, reader.bp);</span>
<span class="line-added"> 243                     }</span>
<span class="line-added"> 244                     break;</span>
 245                 default:
 246                     lexError(reader.bp, Errors.IllegalEscChar);
 247                 }
 248             }
 249         } else if (reader.bp != reader.buflen) {
 250             reader.putChar(true);
 251         }
 252     }
 253 
<span class="line-added"> 254     /** Interim access to String methods used to support text blocks.</span>
<span class="line-added"> 255      *  Required to handle bootstrapping with pre-text block jdks.</span>
<span class="line-added"> 256      *  Should be replaced with direct calls in the &#39;next&#39; jdk.</span>
<span class="line-added"> 257      */</span>
<span class="line-added"> 258     static class TextBlockSupport {</span>
<span class="line-added"> 259         /** Reflection method to remove incidental indentation.</span>
<span class="line-added"> 260          */</span>
<span class="line-added"> 261         private static final Method stripIndent;</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263         /** Reflection method to translate escape sequences.</span>
<span class="line-added"> 264          */</span>
<span class="line-added"> 265         private static final Method translateEscapes;</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267         /** true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-added"> 268          */</span>
<span class="line-added"> 269         private static final boolean hasSupport;</span>
<span class="line-added"> 270 </span>
<span class="line-added"> 271         /** Get a string method via refection or null if not available.</span>
<span class="line-added"> 272          */</span>
<span class="line-added"> 273         private static Method getStringMethodOrNull(String name) {</span>
<span class="line-added"> 274             try {</span>
<span class="line-added"> 275                 return String.class.getMethod(name);</span>
<span class="line-added"> 276             } catch (Exception ex) {</span>
<span class="line-added"> 277                 // Method not available, return null.</span>
<span class="line-added"> 278             }</span>
<span class="line-added"> 279             return null;</span>
<span class="line-added"> 280         }</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282         static {</span>
<span class="line-added"> 283             // Get text block string methods.</span>
<span class="line-added"> 284             stripIndent = getStringMethodOrNull(&quot;stripIndent&quot;);</span>
<span class="line-added"> 285             translateEscapes = getStringMethodOrNull(&quot;translateEscapes&quot;);</span>
<span class="line-added"> 286             // true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-added"> 287             hasSupport = stripIndent != null &amp;&amp; translateEscapes != null;</span>
<span class="line-added"> 288         }</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290         /** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-added"> 291          */</span>
<span class="line-added"> 292         static boolean hasSupport() {</span>
<span class="line-added"> 293             return hasSupport;</span>
<span class="line-added"> 294         }</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296         /** Return the leading whitespace count (indentation) of the line.</span>
<span class="line-added"> 297          */</span>
<span class="line-added"> 298         private static int indent(String line) {</span>
<span class="line-added"> 299             return line.length() - line.stripLeading().length();</span>
<span class="line-added"> 300         }</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302         enum WhitespaceChecks {</span>
<span class="line-added"> 303             INCONSISTENT,</span>
<span class="line-added"> 304             TRAILING</span>
<span class="line-added"> 305         };</span>
<span class="line-added"> 306 </span>
<span class="line-added"> 307         /** Check that the use of white space in content is not problematic.</span>
<span class="line-added"> 308          */</span>
<span class="line-added"> 309         static Set&lt;WhitespaceChecks&gt; checkWhitespace(String string) {</span>
<span class="line-added"> 310             // Start with empty result set.</span>
<span class="line-added"> 311             Set&lt;WhitespaceChecks&gt; checks = new HashSet&lt;&gt;();</span>
<span class="line-added"> 312             // No need to check empty strings.</span>
<span class="line-added"> 313             if (string.isEmpty()) {</span>
<span class="line-added"> 314                 return checks;</span>
<span class="line-added"> 315             }</span>
<span class="line-added"> 316             // Maximum common indentation.</span>
<span class="line-added"> 317             int outdent = 0;</span>
<span class="line-added"> 318             // No need to check indentation if opting out (last line is empty.)</span>
<span class="line-added"> 319             char lastChar = string.charAt(string.length() - 1);</span>
<span class="line-added"> 320             boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;</span>
<span class="line-added"> 321             // Split string based at line terminators.</span>
<span class="line-added"> 322             String[] lines = string.split(&quot;\\R&quot;);</span>
<span class="line-added"> 323             int length = lines.length;</span>
<span class="line-added"> 324             // Extract last line.</span>
<span class="line-added"> 325             String lastLine = length == 0 ? &quot;&quot; : lines[length - 1];</span>
<span class="line-added"> 326              if (!optOut) {</span>
<span class="line-added"> 327                 // Prime with the last line indentation (may be blank.)</span>
<span class="line-added"> 328                 outdent = indent(lastLine);</span>
<span class="line-added"> 329                 for (String line : lines) {</span>
<span class="line-added"> 330                     // Blanks lines have no influence (last line accounted for.)</span>
<span class="line-added"> 331                     if (!line.isBlank()) {</span>
<span class="line-added"> 332                         outdent = Integer.min(outdent, indent(line));</span>
<span class="line-added"> 333                         if (outdent == 0) {</span>
<span class="line-added"> 334                             break;</span>
<span class="line-added"> 335                         }</span>
<span class="line-added"> 336                     }</span>
<span class="line-added"> 337                 }</span>
<span class="line-added"> 338             }</span>
<span class="line-added"> 339             // Last line is representative.</span>
<span class="line-added"> 340             String start = lastLine.substring(0, outdent);</span>
<span class="line-added"> 341             for (String line : lines) {</span>
<span class="line-added"> 342                 // Fail if a line does not have the same indentation.</span>
<span class="line-added"> 343                 if (!line.isBlank() &amp;&amp; !line.startsWith(start)) {</span>
<span class="line-added"> 344                     // Mix of different white space</span>
<span class="line-added"> 345                     checks.add(WhitespaceChecks.INCONSISTENT);</span>
<span class="line-added"> 346                 }</span>
<span class="line-added"> 347                 // Line has content even after indent is removed.</span>
<span class="line-added"> 348                 if (outdent &lt; line.length()) {</span>
<span class="line-added"> 349                     // Is the last character a white space.</span>
<span class="line-added"> 350                     lastChar = line.charAt(line.length() - 1);</span>
<span class="line-added"> 351                     if (Character.isWhitespace(lastChar)) {</span>
<span class="line-added"> 352                         // Has trailing white space.</span>
<span class="line-added"> 353                         checks.add(WhitespaceChecks.TRAILING);</span>
<span class="line-added"> 354                     }</span>
<span class="line-added"> 355                 }</span>
<span class="line-added"> 356             }</span>
<span class="line-added"> 357             return checks;</span>
<span class="line-added"> 358         }</span>
<span class="line-added"> 359 </span>
<span class="line-added"> 360         /** Invoke String::stripIndent through reflection.</span>
<span class="line-added"> 361          */</span>
<span class="line-added"> 362         static String stripIndent(String string) {</span>
<span class="line-added"> 363             try {</span>
<span class="line-added"> 364                 string = (String)stripIndent.invoke(string);</span>
<span class="line-added"> 365             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-added"> 366                 throw new RuntimeException(ex);</span>
<span class="line-added"> 367             }</span>
<span class="line-added"> 368             return string;</span>
<span class="line-added"> 369         }</span>
<span class="line-added"> 370 </span>
<span class="line-added"> 371         /** Invoke String::translateEscapes through reflection.</span>
<span class="line-added"> 372          */</span>
<span class="line-added"> 373         static String translateEscapes(String string) {</span>
<span class="line-added"> 374             try {</span>
<span class="line-added"> 375                 string = (String)translateEscapes.invoke(string);</span>
<span class="line-added"> 376             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-added"> 377                 throw new RuntimeException(ex);</span>
<span class="line-added"> 378             }</span>
<span class="line-added"> 379             return string;</span>
<span class="line-added"> 380         }</span>
<span class="line-added"> 381     }</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383     /** Test for EOLN.</span>
<span class="line-added"> 384      */</span>
<span class="line-added"> 385     private boolean isEOLN() {</span>
<span class="line-added"> 386         return reader.ch == LF || reader.ch == CR;</span>
<span class="line-added"> 387     }</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389     /** Test for CRLF.</span>
<span class="line-added"> 390      */</span>
<span class="line-added"> 391     private boolean isCRLF() {</span>
<span class="line-added"> 392         return reader.ch == CR &amp;&amp; reader.peekChar() == LF;</span>
<span class="line-added"> 393     }</span>
<span class="line-added"> 394 </span>
<span class="line-added"> 395     /** Count and skip repeated occurrences of the specified character.</span>
<span class="line-added"> 396      */</span>
<span class="line-added"> 397     private int countChar(char ch, int max) {</span>
<span class="line-added"> 398         int count = 0;</span>
<span class="line-added"> 399         for ( ; count &lt; max &amp;&amp; reader.bp &lt; reader.buflen &amp;&amp; reader.ch == ch; count++) {</span>
<span class="line-added"> 400             reader.scanChar();</span>
<span class="line-added"> 401         }</span>
<span class="line-added"> 402         return count;</span>
<span class="line-added"> 403     }</span>
<span class="line-added"> 404 </span>
<span class="line-added"> 405     /** Scan a string literal or text block.</span>
<span class="line-added"> 406      */</span>
<span class="line-added"> 407     private void scanString(int pos) {</span>
<span class="line-added"> 408         // Clear flags.</span>
<span class="line-added"> 409         isTextBlock = false;</span>
<span class="line-added"> 410         hasEscapeSequences = false;</span>
<span class="line-added"> 411         // Track the end of first line for error recovery.</span>
<span class="line-added"> 412         int firstEOLN = -1;</span>
<span class="line-added"> 413         // Attempt to scan for up to 3 double quotes.</span>
<span class="line-added"> 414         int openCount = countChar(&#39;\&quot;&#39;, 3);</span>
<span class="line-added"> 415         switch (openCount) {</span>
<span class="line-added"> 416         case 1: // Starting a string literal.</span>
<span class="line-added"> 417             break;</span>
<span class="line-added"> 418         case 2: // Starting an empty string literal.</span>
<span class="line-added"> 419             // Start again but only consume one quote.</span>
<span class="line-added"> 420             reader.reset(pos);</span>
<span class="line-added"> 421             openCount = countChar(&#39;\&quot;&#39;, 1);</span>
<span class="line-added"> 422             break;</span>
<span class="line-added"> 423         case 3: // Starting a text block.</span>
<span class="line-added"> 424             // Check if preview feature is enabled for text blocks.</span>
<span class="line-added"> 425             checkSourceLevel(pos, Feature.TEXT_BLOCKS);</span>
<span class="line-added"> 426             isTextBlock = true;</span>
<span class="line-added"> 427             // Verify the open delimiter sequence.</span>
<span class="line-added"> 428             boolean hasOpenEOLN = false;</span>
<span class="line-added"> 429             while (reader.bp &lt; reader.buflen &amp;&amp; Character.isWhitespace(reader.ch)) {</span>
<span class="line-added"> 430                 hasOpenEOLN = isEOLN();</span>
<span class="line-added"> 431                 if (hasOpenEOLN) {</span>
<span class="line-added"> 432                     break;</span>
<span class="line-added"> 433                 }</span>
<span class="line-added"> 434                 reader.scanChar();</span>
<span class="line-added"> 435             }</span>
<span class="line-added"> 436             // Error if the open delimiter sequence not is &quot;&quot;&quot;&lt;Whitespace&gt;*&lt;LineTerminator&gt;.</span>
<span class="line-added"> 437             if (!hasOpenEOLN) {</span>
<span class="line-added"> 438                 lexError(reader.bp, Errors.IllegalTextBlockOpen);</span>
<span class="line-added"> 439                 return;</span>
<span class="line-added"> 440             }</span>
<span class="line-added"> 441             // Skip line terminator.</span>
<span class="line-added"> 442             int start = reader.bp;</span>
<span class="line-added"> 443             if (isCRLF()) {</span>
<span class="line-added"> 444                 reader.scanChar();</span>
<span class="line-added"> 445             }</span>
<span class="line-added"> 446             reader.scanChar();</span>
<span class="line-added"> 447             processLineTerminator(start, reader.bp);</span>
<span class="line-added"> 448             break;</span>
<span class="line-added"> 449         }</span>
<span class="line-added"> 450         // While characters are available.</span>
<span class="line-added"> 451         while (reader.bp &lt; reader.buflen) {</span>
<span class="line-added"> 452             // If possible close delimiter sequence.</span>
<span class="line-added"> 453             if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="line-added"> 454                 // Check to see if enough double quotes are present.</span>
<span class="line-added"> 455                 int closeCount = countChar(&#39;\&quot;&#39;, openCount);</span>
<span class="line-added"> 456                 if (openCount == closeCount) {</span>
<span class="line-added"> 457                     // Good result.</span>
<span class="line-added"> 458                     tk = Tokens.TokenKind.STRINGLITERAL;</span>
<span class="line-added"> 459                     return;</span>
<span class="line-added"> 460                 }</span>
<span class="line-added"> 461                 // False alarm, add double quotes to string buffer.</span>
<span class="line-added"> 462                 reader.repeat(&#39;\&quot;&#39;, closeCount);</span>
<span class="line-added"> 463             } else if (isEOLN()) {</span>
<span class="line-added"> 464                 // Line terminator in string literal is an error.</span>
<span class="line-added"> 465                 // Fall out to unclosed string literal error.</span>
<span class="line-added"> 466                 if (openCount == 1) {</span>
<span class="line-added"> 467                     break;</span>
<span class="line-added"> 468                 }</span>
<span class="line-added"> 469                  // Add line terminator to string buffer.</span>
<span class="line-added"> 470                 int start = reader.bp;</span>
<span class="line-added"> 471                 if (isCRLF()) {</span>
<span class="line-added"> 472                     reader.scanChar();</span>
<span class="line-added"> 473                 }</span>
<span class="line-added"> 474                 reader.putChar(&#39;\n&#39;, true);</span>
<span class="line-added"> 475                 processLineTerminator(start, reader.bp);</span>
<span class="line-added"> 476                 // Record first line terminator for error recovery.</span>
<span class="line-added"> 477                 if (firstEOLN == -1) {</span>
<span class="line-added"> 478                     firstEOLN = reader.bp;</span>
<span class="line-added"> 479                 }</span>
<span class="line-added"> 480             } else if (reader.ch == &#39;\\&#39;) {</span>
<span class="line-added"> 481                 // Handle escape sequences.</span>
<span class="line-added"> 482                 hasEscapeSequences = true;</span>
<span class="line-added"> 483                 // Translate escapes immediately if TextBlockSupport is not available</span>
<span class="line-added"> 484                 // during bootstrapping.</span>
<span class="line-added"> 485                 boolean translateEscapesNow = !TextBlockSupport.hasSupport();</span>
<span class="line-added"> 486                 scanLitChar(pos, translateEscapesNow, openCount != 1);</span>
<span class="line-added"> 487             } else {</span>
<span class="line-added"> 488                 // Add character to string buffer.</span>
<span class="line-added"> 489                 reader.putChar(true);</span>
<span class="line-added"> 490             }</span>
<span class="line-added"> 491         }</span>
<span class="line-added"> 492         // String ended without close delimiter sequence.</span>
<span class="line-added"> 493         lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);</span>
<span class="line-added"> 494         if (firstEOLN  != -1) {</span>
<span class="line-added"> 495             // Reset recovery position to point after open delimiter sequence.</span>
<span class="line-added"> 496             reader.reset(firstEOLN);</span>
<span class="line-added"> 497         }</span>
<span class="line-added"> 498     }</span>
<span class="line-added"> 499 </span>
 500     private void scanDigits(int pos, int digitRadix) {
 501         char saveCh;
 502         int savePos;
 503         do {
 504             if (reader.ch != &#39;_&#39;) {
 505                 reader.putChar(false);
 506             }
 507             saveCh = reader.ch;
 508             savePos = reader.bp;
 509             reader.scanChar();
 510         } while (reader.digit(pos, digitRadix) &gt;= 0 || reader.ch == &#39;_&#39;);
 511         if (saveCh == &#39;_&#39;)
 512             lexError(savePos, Errors.IllegalUnderscore);
 513     }
 514 
 515     /** Read fractional part of hexadecimal floating point number.
 516      */
 517     private void scanHexExponentAndSuffix(int pos) {
 518         if (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;) {
 519             reader.putChar(true);
</pre>
<hr />
<pre>
 904                             reader.scanChar();
 905                             comments = addComment(comments, processComment(pos, reader.bp, style));
 906                             break;
 907                         } else {
 908                             lexError(pos, Errors.UnclosedComment);
 909                             break loop;
 910                         }
 911                     } else if (reader.ch == &#39;=&#39;) {
 912                         tk = TokenKind.SLASHEQ;
 913                         reader.scanChar();
 914                     } else {
 915                         tk = TokenKind.SLASH;
 916                     }
 917                     break loop;
 918                 case &#39;\&#39;&#39;:
 919                     reader.scanChar();
 920                     if (reader.ch == &#39;\&#39;&#39;) {
 921                         lexError(pos, Errors.EmptyCharLit);
 922                         reader.scanChar();
 923                     } else {
<span class="line-modified"> 924                         if (isEOLN())</span>
 925                             lexError(pos, Errors.IllegalLineEndInCharLit);
<span class="line-modified"> 926                         scanLitChar(pos, true, false);</span>
 927                         if (reader.ch == &#39;\&#39;&#39;) {
 928                             reader.scanChar();
 929                             tk = TokenKind.CHARLITERAL;
 930                         } else {
 931                             lexError(pos, Errors.UnclosedCharLit);
 932                         }
 933                     }
 934                     break loop;
 935                 case &#39;\&quot;&#39;:
<span class="line-modified"> 936                     scanString(pos);</span>








 937                     break loop;
<span class="line-modified"> 938                 default:</span>
 939                     if (isSpecial(reader.ch)) {
 940                         scanOperator();
 941                     } else {
 942                         boolean isJavaIdentifierStart;
 943                         int codePoint = -1;
 944                         if (reader.ch &lt; &#39;\u0080&#39;) {
 945                             // all ASCII range chars already handled, above
 946                             isJavaIdentifierStart = false;
 947                         } else {
 948                             codePoint = reader.peekSurrogates();
 949                             if (codePoint &gt;= 0) {
 950                                 if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {
 951                                     reader.putChar(true);
 952                                 }
 953                             } else {
 954                                 isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);
 955                             }
 956                         }
 957                         if (isJavaIdentifierStart) {
 958                             scanIdent();
</pre>
<hr />
<pre>
 967                             if (codePoint &gt;= 0) {
 968                                 char high = reader.ch;
 969                                 reader.scanChar();
 970                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) high, (int)reader.ch);
 971                             } else {
 972                                 arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ?
 973                                                 String.format(&quot;%s&quot;, reader.ch) :
 974                                                 String.format(&quot;\\u%04x&quot;, (int)reader.ch);
 975                             }
 976                             lexError(pos, Errors.IllegalChar(arg));
 977                             reader.scanChar();
 978                         }
 979                     }
 980                     break loop;
 981                 }
 982             }
 983             endPos = reader.bp;
 984             switch (tk.tag) {
 985                 case DEFAULT: return new Token(tk, pos, endPos, comments);
 986                 case NAMED: return new NamedToken(tk, pos, endPos, name, comments);
<span class="line-modified"> 987                 case STRING: {</span>
<span class="line-added"> 988                     // Get characters from string buffer.</span>
<span class="line-added"> 989                     String string = reader.chars();</span>
<span class="line-added"> 990                     // If a text block.</span>
<span class="line-added"> 991                     if (isTextBlock &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-added"> 992                         // Verify that the incidental indentation is consistent.</span>
<span class="line-added"> 993                         if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {</span>
<span class="line-added"> 994                             Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =</span>
<span class="line-added"> 995                                     TextBlockSupport.checkWhitespace(string);</span>
<span class="line-added"> 996                             if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {</span>
<span class="line-added"> 997                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-added"> 998                                         Warnings.InconsistentWhiteSpaceIndentation);</span>
<span class="line-added"> 999                             }</span>
<span class="line-added">1000                             if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {</span>
<span class="line-added">1001                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-added">1002                                         Warnings.TrailingWhiteSpaceWillBeRemoved);</span>
<span class="line-added">1003                             }</span>
<span class="line-added">1004                         }</span>
<span class="line-added">1005                         // Remove incidental indentation.</span>
<span class="line-added">1006                         try {</span>
<span class="line-added">1007                             string = TextBlockSupport.stripIndent(string);</span>
<span class="line-added">1008                         } catch (Exception ex) {</span>
<span class="line-added">1009                             // Error already reported, just use unstripped string.</span>
<span class="line-added">1010                         }</span>
<span class="line-added">1011                     }</span>
<span class="line-added">1012                     // Translate escape sequences if present.</span>
<span class="line-added">1013                     if (hasEscapeSequences &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-added">1014                         try {</span>
<span class="line-added">1015                             string = TextBlockSupport.translateEscapes(string);</span>
<span class="line-added">1016                         } catch (Exception ex) {</span>
<span class="line-added">1017                             // Error already reported, just use untranslated string.</span>
<span class="line-added">1018                         }</span>
<span class="line-added">1019                     }</span>
<span class="line-added">1020                     // Build string token.</span>
<span class="line-added">1021                     return new StringToken(tk, pos, endPos, string, comments);</span>
<span class="line-added">1022                 }</span>
1023                 case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);
1024                 default: throw new AssertionError();
1025             }
1026         }
1027         finally {
1028             if (scannerDebug) {
1029                     System.out.println(&quot;nextToken(&quot; + pos
1030                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
1031                                        new String(reader.getRawCharacters(pos, endPos))
1032                                        + &quot;|&quot;);
1033             }
1034         }
1035     }
1036     //where
1037         List&lt;Comment&gt; addComment(List&lt;Comment&gt; comments, Comment comment) {
1038             return comments == null ?
1039                     List.of(comment) :
1040                     comments.prepend(comment);
1041         }
1042 
</pre>
</td>
</tr>
</table>
<center><a href="DocCommentParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
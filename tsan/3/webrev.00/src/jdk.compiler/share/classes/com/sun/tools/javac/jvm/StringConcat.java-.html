<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/StringConcat.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.jvm;
 27 
 28 import com.sun.tools.javac.code.*;
 29 import com.sun.tools.javac.comp.Resolve;
 30 import com.sun.tools.javac.tree.JCTree;
 31 import com.sun.tools.javac.tree.TreeInfo;
 32 import com.sun.tools.javac.tree.TreeMaker;
 33 import com.sun.tools.javac.util.*;
 34 
 35 import static com.sun.tools.javac.code.Kinds.Kind.MTH;
 36 import static com.sun.tools.javac.code.TypeTag.*;
 37 import static com.sun.tools.javac.jvm.ByteCodes.*;
 38 import static com.sun.tools.javac.tree.JCTree.Tag.PLUS;
 39 import com.sun.tools.javac.jvm.Items.*;
 40 
 41 import java.util.HashMap;
 42 import java.util.Map;
 43 
 44 /** This lowers the String concatenation to something that JVM can understand.
 45  *
 46  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 47  *  If you write code that depends on this, you do so at your own risk.
 48  *  This code and its internal interfaces are subject to change or
 49  *  deletion without notice.&lt;/b&gt;
 50  */
 51 public abstract class StringConcat {
 52 
 53     /**
 54      * Maximum number of slots for String Concat call.
 55      * JDK&#39;s StringConcatFactory does not support more than that.
 56      */
 57     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 58     private static final char TAG_ARG   = &#39;\u0001&#39;;
 59     private static final char TAG_CONST = &#39;\u0002&#39;;
 60 
 61     protected final Gen gen;
 62     protected final Symtab syms;
 63     protected final Names names;
 64     protected final TreeMaker make;
 65     protected final Types types;
 66     protected final Map&lt;Type, Symbol&gt; sbAppends;
 67     protected final Resolve rs;
 68 
 69     protected static final Context.Key&lt;StringConcat&gt; concatKey = new Context.Key&lt;&gt;();
 70 
 71     public static StringConcat instance(Context context) {
 72         StringConcat instance = context.get(concatKey);
 73         if (instance == null) {
 74             instance = makeConcat(context);
 75         }
 76         return instance;
 77     }
 78 
 79     private static StringConcat makeConcat(Context context) {
 80         Target target = Target.instance(context);
 81         String opt = Options.instance(context).get(&quot;stringConcat&quot;);
 82         if (target.hasStringConcatFactory()) {
 83             if (opt == null) {
 84                 opt = &quot;indyWithConstants&quot;;
 85             }
 86         } else {
 87             if (opt != null &amp;&amp; !&quot;inline&quot;.equals(opt)) {
 88                 Assert.error(&quot;StringConcatFactory-based string concat is requested on a platform that does not support it.&quot;);
 89             }
 90             opt = &quot;inline&quot;;
 91         }
 92 
 93         switch (opt) {
 94             case &quot;inline&quot;:
 95                 return new Inline(context);
 96             case &quot;indy&quot;:
 97                 return new IndyPlain(context);
 98             case &quot;indyWithConstants&quot;:
 99                 return new IndyConstants(context);
100             default:
101                 Assert.error(&quot;Unknown stringConcat: &quot; + opt);
102                 throw new IllegalStateException(&quot;Unknown stringConcat: &quot; + opt);
103         }
104     }
105 
106     protected StringConcat(Context context) {
107         context.put(concatKey, this);
108         gen = Gen.instance(context);
109         syms = Symtab.instance(context);
110         types = Types.instance(context);
111         names = Names.instance(context);
112         make = TreeMaker.instance(context);
113         rs = Resolve.instance(context);
114         sbAppends = new HashMap&lt;&gt;();
115     }
116 
117     public abstract Item makeConcat(JCTree.JCAssignOp tree);
118     public abstract Item makeConcat(JCTree.JCBinary tree);
119 
120     protected List&lt;JCTree&gt; collectAll(JCTree tree) {
121         return collect(tree, List.nil());
122     }
123 
124     protected List&lt;JCTree&gt; collectAll(JCTree.JCExpression lhs, JCTree.JCExpression rhs) {
125         return List.&lt;JCTree&gt;nil()
126                 .appendList(collectAll(lhs))
127                 .appendList(collectAll(rhs));
128     }
129 
130     private List&lt;JCTree&gt; collect(JCTree tree, List&lt;JCTree&gt; res) {
131         tree = TreeInfo.skipParens(tree);
132         if (tree.hasTag(PLUS) &amp;&amp; tree.type.constValue() == null) {
133             JCTree.JCBinary op = (JCTree.JCBinary) tree;
134             if (op.operator.kind == MTH &amp;&amp; op.operator.opcode == string_add) {
135                 return res
136                         .appendList(collect(op.lhs, res))
137                         .appendList(collect(op.rhs, res));
138             }
139         }
140         return res.append(tree);
141     }
142 
143     /**
144      * If the type is not accessible from current context, try to figure out the
145      * sharpest accessible supertype.
146      *
147      * @param originalType type to sharpen
148      * @return sharped type
149      */
150     Type sharpestAccessible(Type originalType) {
151         if (originalType.hasTag(ARRAY)) {
152             return types.makeArrayType(sharpestAccessible(types.elemtype(originalType)));
153         }
154 
155         Type type = originalType;
156         while (!rs.isAccessible(gen.getAttrEnv(), type.asElement())) {
157             type = types.supertype(type);
158         }
159         return type;
160     }
161 
162     /**
163      * &quot;Legacy&quot; bytecode flavor: emit the StringBuilder.append chains for string
164      * concatenation.
165      */
166     private static class Inline extends StringConcat {
167         public Inline(Context context) {
168             super(context);
169         }
170 
171         @Override
172         public Item makeConcat(JCTree.JCAssignOp tree) {
173             // Generate code to make a string builder
174             JCDiagnostic.DiagnosticPosition pos = tree.pos();
175 
176             // Create a string builder.
177             newStringBuilder(tree);
178 
179             // Generate code for first string, possibly save one
180             // copy under builder
181             Item l = gen.genExpr(tree.lhs, tree.lhs.type);
182             if (l.width() &gt; 0) {
183                 gen.getCode().emitop0(dup_x1 + 3 * (l.width() - 1));
184             }
185 
186             // Load first string and append to builder.
187             l.load();
188             appendString(tree.lhs);
189 
190             // Append all other strings to builder.
191             List&lt;JCTree&gt; args = collectAll(tree.rhs);
192             for (JCTree t : args) {
193                 gen.genExpr(t, t.type).load();
194                 appendString(t);
195             }
196 
197             // Convert builder to string.
198             builderToString(pos);
199 
200             return l;
201         }
202 
203         @Override
204         public Item makeConcat(JCTree.JCBinary tree) {
205             JCDiagnostic.DiagnosticPosition pos = tree.pos();
206 
207             // Create a string builder.
208             newStringBuilder(tree);
209 
210             // Append all strings to builder.
211             List&lt;JCTree&gt; args = collectAll(tree);
212             for (JCTree t : args) {
213                 gen.genExpr(t, t.type).load();
214                 appendString(t);
215             }
216 
217             // Convert builder to string.
218             builderToString(pos);
219 
220             return gen.getItems().makeStackItem(syms.stringType);
221         }
222 
223         private JCDiagnostic.DiagnosticPosition newStringBuilder(JCTree tree) {
224             JCDiagnostic.DiagnosticPosition pos = tree.pos();
225             gen.getCode().emitop2(new_, gen.makeRef(pos, syms.stringBuilderType));
226             gen.getCode().emitop0(dup);
227             gen.callMethod(pos, syms.stringBuilderType, names.init, List.nil(), false);
228             return pos;
229         }
230 
231         private void appendString(JCTree tree) {
232             Type t = tree.type.baseType();
233             if (!t.isPrimitive() &amp;&amp; t.tsym != syms.stringType.tsym) {
234                 t = syms.objectType;
235             }
236 
237             Assert.checkNull(t.constValue());
238             Symbol method = sbAppends.get(t);
239             if (method == null) {
240                 method = rs.resolveInternalMethod(tree.pos(), gen.getAttrEnv(), syms.stringBuilderType, names.append, List.of(t), null);
241                 sbAppends.put(t, method);
242             }
243 
244             gen.getItems().makeMemberItem(method, false).invoke();
245         }
246 
247         private void builderToString(JCDiagnostic.DiagnosticPosition pos) {
248             gen.callMethod(pos, syms.stringBuilderType, names.toString, List.nil(), false);
249         }
250     }
251 
252     /**
253      * Base class for indified concatenation bytecode flavors.
254      */
255     private static abstract class Indy extends StringConcat {
256         public Indy(Context context) {
257             super(context);
258         }
259 
260         @Override
261         public Item makeConcat(JCTree.JCAssignOp tree) {
262             List&lt;JCTree&gt; args = collectAll(tree.lhs, tree.rhs);
263             Item l = gen.genExpr(tree.lhs, tree.lhs.type);
264             l.duplicate();
265             l.load();
266             emit(tree.pos(), args, false, tree.type);
267             return l;
268         }
269 
270         @Override
271         public Item makeConcat(JCTree.JCBinary tree) {
272             List&lt;JCTree&gt; args = collectAll(tree.lhs, tree.rhs);
273             emit(tree.pos(), args, true, tree.type);
274             return gen.getItems().makeStackItem(syms.stringType);
275         }
276 
277         protected abstract void emit(JCDiagnostic.DiagnosticPosition pos, List&lt;JCTree&gt; args, boolean generateFirstArg, Type type);
278 
279         /** Peel the argument list into smaller chunks. */
280         protected List&lt;List&lt;JCTree&gt;&gt; split(List&lt;JCTree&gt; args) {
281             ListBuffer&lt;List&lt;JCTree&gt;&gt; splits = new ListBuffer&lt;&gt;();
282 
283             int slots = 0;
284 
285             // Need to peel, so that neither call has more than acceptable number
286             // of slots for the arguments.
287             ListBuffer&lt;JCTree&gt; cArgs = new ListBuffer&lt;&gt;();
288             for (JCTree t : args) {
289                 int needSlots = (t.type.getTag() == LONG || t.type.getTag() == DOUBLE) ? 2 : 1;
290                 if (slots + needSlots &gt;= MAX_INDY_CONCAT_ARG_SLOTS) {
291                     splits.add(cArgs.toList());
292                     cArgs.clear();
293                     slots = 0;
294                 }
295                 cArgs.add(t);
296                 slots += needSlots;
297             }
298 
299             // Flush the tail slice
300             if (!cArgs.isEmpty()) {
301                 splits.add(cArgs.toList());
302             }
303 
304             return splits.toList();
305         }
306     }
307 
308     /**
309      * Emits the invokedynamic call to JDK java.lang.invoke.StringConcatFactory,
310      * without handling constants specially.
311      *
312      * We bypass empty strings, because they have no meaning at this level. This
313      * captures the Java language trick to force String concat with e.g. (&quot;&quot; + int)-like
314      * expression. Down here, we already know we are in String concat business, and do
315      * not require these markers.
316      */
317     private static class IndyPlain extends Indy {
318         public IndyPlain(Context context) {
319             super(context);
320         }
321 
322         /** Emit the indy concat for all these arguments, possibly peeling along the way */
323         protected void emit(JCDiagnostic.DiagnosticPosition pos, List&lt;JCTree&gt; args, boolean generateFirstArg, Type type) {
324             List&lt;List&lt;JCTree&gt;&gt; split = split(args);
325 
326             boolean first = true;
327             for (List&lt;JCTree&gt; t : split) {
328                 Assert.check(!t.isEmpty(), &quot;Arguments list is empty&quot;);
329 
330                 ListBuffer&lt;Type&gt; dynamicArgs = new ListBuffer&lt;&gt;();
331                 for (JCTree arg : t) {
332                     Object constVal = arg.type.constValue();
333                     if (&quot;&quot;.equals(constVal)) continue;
334                     if (arg.type == syms.botType) {
335                         dynamicArgs.add(types.boxedClass(syms.voidType).type);
336                     } else {
337                         dynamicArgs.add(sharpestAccessible(arg.type));
338                     }
339                     if (!first || generateFirstArg) {
340                         gen.genExpr(arg, arg.type).load();
341                     }
342                     first = false;
343                 }
344                 doCall(type, pos, dynamicArgs.toList());
345             }
346 
347             // More that one peel slice produced: concatenate the results
348             if (split.size() &gt; 1) {
349                 ListBuffer&lt;Type&gt; argTypes = new ListBuffer&lt;&gt;();
350                 for (int c = 0; c &lt; split.size(); c++) {
351                     argTypes.append(syms.stringType);
352                 }
353                 doCall(type, pos, argTypes.toList());
354             }
355         }
356 
357         /** Produce the actual invokedynamic call to StringConcatFactory */
358         private void doCall(Type type, JCDiagnostic.DiagnosticPosition pos, List&lt;Type&gt; dynamicArgTypes) {
359             Type.MethodType indyType = new Type.MethodType(dynamicArgTypes,
360                     type,
361                     List.nil(),
362                     syms.methodClass);
363 
364             int prevPos = make.pos;
365             try {
366                 make.at(pos);
367 
368                 List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
369                         syms.stringType,
370                         syms.methodTypeType);
371 
372                 Symbol bsm = rs.resolveInternalMethod(pos,
373                         gen.getAttrEnv(),
374                         syms.stringConcatFactory,
375                         names.makeConcat,
376                         bsm_staticArgs,
377                         null);
378 
379                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcat,
380                         syms.noSymbol,
381                         ClassFile.REF_invokeStatic,
382                         (Symbol.MethodSymbol)bsm,
383                         indyType,
384                         List.nil().toArray());
385 
386                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
387                 item.invoke();
388             } finally {
389                 make.at(prevPos);
390             }
391         }
392     }
393 
394     /**
395      * Emits the invokedynamic call to JDK java.lang.invoke.StringConcatFactory.
396      * This code concatenates all known constants into the recipe, possibly escaping
397      * some constants separately.
398      *
399      * We also bypass empty strings, because they have no meaning at this level. This
400      * captures the Java language trick to force String concat with e.g. (&quot;&quot; + int)-like
401      * expression. Down here, we already know we are in String concat business, and do
402      * not require these markers.
403      */
404     private static final class IndyConstants extends Indy {
405         public IndyConstants(Context context) {
406             super(context);
407         }
408 
409         @Override
410         protected void emit(JCDiagnostic.DiagnosticPosition pos, List&lt;JCTree&gt; args, boolean generateFirstArg, Type type) {
411             List&lt;List&lt;JCTree&gt;&gt; split = split(args);
412 
413             boolean first = true;
414             for (List&lt;JCTree&gt; t : split) {
415                 Assert.check(!t.isEmpty(), &quot;Arguments list is empty&quot;);
416 
417                 StringBuilder recipe = new StringBuilder(t.size());
418                 ListBuffer&lt;Type&gt; dynamicArgs = new ListBuffer&lt;&gt;();
419                 ListBuffer&lt;Object&gt; staticArgs = new ListBuffer&lt;&gt;();
420 
421                 for (JCTree arg : t) {
422                     Object constVal = arg.type.constValue();
423                     if (&quot;&quot;.equals(constVal)) continue;
424                     if (arg.type == syms.botType) {
425                         // Concat the null into the recipe right away
426                         recipe.append((String) null);
427                     } else if (constVal != null) {
428                         // Concat the String representation of the constant, except
429                         // for the case it contains special tags, which requires us
430                         // to expose it as detached constant.
431                         String a = arg.type.stringValue();
432                         if (a.indexOf(TAG_CONST) != -1 || a.indexOf(TAG_ARG) != -1) {
433                             recipe.append(TAG_CONST);
434                             staticArgs.add(a);
435                         } else {
436                             recipe.append(a);
437                         }
438                     } else {
439                         // Ordinary arguments come through the dynamic arguments.
440                         recipe.append(TAG_ARG);
441                         dynamicArgs.add(sharpestAccessible(arg.type));
442                         if (!first || generateFirstArg) {
443                             gen.genExpr(arg, arg.type).load();
444                         }
445                         first = false;
446                     }
447                 }
448 
449                 doCall(type, pos, recipe.toString(), staticArgs.toList(), dynamicArgs.toList());
450             }
451 
452             // More that one peel slice produced: concatenate the results
453             // All arguments are assumed to be non-constant Strings.
454             if (split.size() &gt; 1) {
455                 ListBuffer&lt;Type&gt; argTypes = new ListBuffer&lt;&gt;();
456                 StringBuilder recipe = new StringBuilder();
457                 for (int c = 0; c &lt; split.size(); c++) {
458                     argTypes.append(syms.stringType);
459                     recipe.append(TAG_ARG);
460                 }
461                 doCall(type, pos, recipe.toString(), List.nil(), argTypes.toList());
462             }
463         }
464 
465         /** Produce the actual invokedynamic call to StringConcatFactory */
466         private void doCall(Type type, JCDiagnostic.DiagnosticPosition pos, String recipe, List&lt;Object&gt; staticArgs, List&lt;Type&gt; dynamicArgTypes) {
467             Type.MethodType indyType = new Type.MethodType(dynamicArgTypes,
468                     type,
469                     List.nil(),
470                     syms.methodClass);
471 
472             int prevPos = make.pos;
473             try {
474                 make.at(pos);
475 
476                 ListBuffer&lt;Type&gt; constTypes = new ListBuffer&lt;&gt;();
477                 ListBuffer&lt;Object&gt; constants = new ListBuffer&lt;&gt;();
478                 for (Object t : staticArgs) {
479                     constants.add(t);
480                     constTypes.add(syms.stringType);
481                 }
482 
483                 List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
484                         syms.stringType,
485                         syms.methodTypeType)
486                         .append(syms.stringType)
487                         .appendList(constTypes);
488 
489                 Symbol bsm = rs.resolveInternalMethod(pos,
490                         gen.getAttrEnv(),
491                         syms.stringConcatFactory,
492                         names.makeConcatWithConstants,
493                         bsm_staticArgs,
494                         null);
495 
496                 Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.makeConcatWithConstants,
497                         syms.noSymbol,
498                         ClassFile.REF_invokeStatic,
499                         (Symbol.MethodSymbol)bsm,
500                         indyType,
501                         List.&lt;Object&gt;of(recipe).appendList(constants).toArray());
502 
503                 Items.Item item = gen.getItems().makeDynamicItem(dynSym);
504                 item.invoke();
505             } finally {
506                 make.at(prevPos);
507             }
508         }
509     }
510 
511 }
    </pre>
  </body>
</html>
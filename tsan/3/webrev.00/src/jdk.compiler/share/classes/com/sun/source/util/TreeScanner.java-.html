<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/source/util/TreeScanner.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.source.util;
 27 
 28 import com.sun.source.tree.*;
 29 import com.sun.source.tree.CaseTree.CaseKind;
 30 
 31 /**
 32  * A TreeVisitor that visits all the child tree nodes.
 33  * To visit nodes of a particular type, just override the
 34  * corresponding visitXYZ method.
 35  * Inside your method, call super.visitXYZ to visit descendant
 36  * nodes.
 37  *
 38  * &lt;p&gt;The default implementation of the visitXYZ methods will determine
 39  * a result as follows:
 40  * &lt;ul&gt;
 41  * &lt;li&gt;If the node being visited has no children, the result will be {@code null}.
 42  * &lt;li&gt;If the node being visited has one child, the result will be the
 43  * result of calling {@code scan} on that child. The child may be a simple node
 44  * or itself a list of nodes.
 45  * &lt;li&gt; If the node being visited has more than one child, the result will
 46  * be determined by calling {@code scan} each child in turn, and then combining the
 47  * result of each scan after the first with the cumulative result
 48  * so far, as determined by the {@link #reduce} method. Each child may be either
 49  * a simple node of a list of nodes. The default behavior of the {@code reduce}
 50  * method is such that the result of the visitXYZ method will be the result of
 51  * the last child scanned.
 52  * &lt;/ul&gt;
 53  *
 54  * &lt;p&gt;Here is an example to count the number of identifier nodes in a tree:
 55  * &lt;pre&gt;
 56  *   class CountIdentifiers extends TreeScanner&amp;lt;Integer,Void&amp;gt; {
 57  *      {@literal @}Override
 58  *      public Integer visitIdentifier(IdentifierTree node, Void p) {
 59  *          return 1;
 60  *      }
 61  *      {@literal @}Override
 62  *      public Integer reduce(Integer r1, Integer r2) {
 63  *          return (r1 == null ? 0 : r1) + (r2 == null ? 0 : r2);
 64  *      }
 65  *   }
 66  * &lt;/pre&gt;
 67  *
 68  * @param &lt;R&gt; the return type of this visitor&#39;s methods.  Use {@link
 69  *            Void} for visitors that do not need to return results.
 70  * @param &lt;P&gt; the type of the additional parameter to this visitor&#39;s
 71  *            methods.  Use {@code Void} for visitors that do not need an
 72  *            additional parameter.
 73  *
 74  * @author Peter von der Ah&amp;eacute;
 75  * @author Jonathan Gibbons
 76  * @since 1.6
 77  */
 78 public class TreeScanner&lt;R,P&gt; implements TreeVisitor&lt;R,P&gt; {
 79 
 80     /**
 81      * Scans a single node.
 82      * @param tree the node to be scanned
 83      * @param p a parameter value passed to the visit method
 84      * @return the result value from the visit method
 85      */
 86     public R scan(Tree tree, P p) {
 87         return (tree == null) ? null : tree.accept(this, p);
 88     }
 89 
 90     private R scanAndReduce(Tree node, P p, R r) {
 91         return reduce(scan(node, p), r);
 92     }
 93 
 94     /**
 95      * Scans a sequence of nodes.
 96      * @param nodes the nodes to be scanned
 97      * @param p a parameter value to be passed to the visit method for each node
 98      * @return the combined return value from the visit methods.
 99      *      The values are combined using the {@link #reduce reduce} method.
100      */
101     public R scan(Iterable&lt;? extends Tree&gt; nodes, P p) {
102         R r = null;
103         if (nodes != null) {
104             boolean first = true;
105             for (Tree node : nodes) {
106                 r = (first ? scan(node, p) : scanAndReduce(node, p, r));
107                 first = false;
108             }
109         }
110         return r;
111     }
112 
113     private R scanAndReduce(Iterable&lt;? extends Tree&gt; nodes, P p, R r) {
114         return reduce(scan(nodes, p), r);
115     }
116 
117     /**
118      * Reduces two results into a combined result.
119      * The default implementation is to return the first parameter.
120      * The general contract of the method is that it may take any action whatsoever.
121      * @param r1 the first of the values to be combined
122      * @param r2 the second of the values to be combined
123      * @return the result of combining the two parameters
124      */
125     public R reduce(R r1, R r2) {
126         return r1;
127     }
128 
129 
130 /* ***************************************************************************
131  * Visitor methods
132  ****************************************************************************/
133 
134     /**
135      * {@inheritDoc} This implementation scans the children in left to right order.
136      *
137      * @param node  {@inheritDoc}
138      * @param p  {@inheritDoc}
139      * @return the result of scanning
140      */
141     @Override
142     public R visitCompilationUnit(CompilationUnitTree node, P p) {
143         R r = scan(node.getPackage(), p);
144         r = scanAndReduce(node.getImports(), p, r);
145         r = scanAndReduce(node.getTypeDecls(), p, r);
146         return r;
147     }
148 
149     /**
150      * {@inheritDoc} This implementation scans the children in left to right order.
151      *
152      * @param node  {@inheritDoc}
153      * @param p  {@inheritDoc}
154      * @return the result of scanning
155      */
156     @Override
157     public R visitPackage(PackageTree node, P p) {
158         R r = scan(node.getAnnotations(), p);
159         r = scanAndReduce(node.getPackageName(), p, r);
160         return r;
161     }
162 
163     /**
164      * {@inheritDoc} This implementation scans the children in left to right order.
165      *
166      * @param node  {@inheritDoc}
167      * @param p  {@inheritDoc}
168      * @return the result of scanning
169      */
170     @Override
171     public R visitImport(ImportTree node, P p) {
172         return scan(node.getQualifiedIdentifier(), p);
173     }
174 
175     /**
176      * {@inheritDoc} This implementation scans the children in left to right order.
177      *
178      * @param node  {@inheritDoc}
179      * @param p  {@inheritDoc}
180      * @return the result of scanning
181      */
182     @Override
183     public R visitClass(ClassTree node, P p) {
184         R r = scan(node.getModifiers(), p);
185         r = scanAndReduce(node.getTypeParameters(), p, r);
186         r = scanAndReduce(node.getExtendsClause(), p, r);
187         r = scanAndReduce(node.getImplementsClause(), p, r);
188         r = scanAndReduce(node.getMembers(), p, r);
189         return r;
190     }
191 
192     /**
193      * {@inheritDoc} This implementation scans the children in left to right order.
194      *
195      * @param node  {@inheritDoc}
196      * @param p  {@inheritDoc}
197      * @return the result of scanning
198      */
199     @Override
200     public R visitMethod(MethodTree node, P p) {
201         R r = scan(node.getModifiers(), p);
202         r = scanAndReduce(node.getReturnType(), p, r);
203         r = scanAndReduce(node.getTypeParameters(), p, r);
204         r = scanAndReduce(node.getParameters(), p, r);
205         r = scanAndReduce(node.getReceiverParameter(), p, r);
206         r = scanAndReduce(node.getThrows(), p, r);
207         r = scanAndReduce(node.getBody(), p, r);
208         r = scanAndReduce(node.getDefaultValue(), p, r);
209         return r;
210     }
211 
212     /**
213      * {@inheritDoc} This implementation scans the children in left to right order.
214      *
215      * @param node  {@inheritDoc}
216      * @param p  {@inheritDoc}
217      * @return the result of scanning
218      */
219     @Override
220     public R visitVariable(VariableTree node, P p) {
221         R r = scan(node.getModifiers(), p);
222         r = scanAndReduce(node.getType(), p, r);
223         r = scanAndReduce(node.getNameExpression(), p, r);
224         r = scanAndReduce(node.getInitializer(), p, r);
225         return r;
226     }
227 
228     /**
229      * {@inheritDoc} This implementation returns {@code null}.
230      *
231      * @param node  {@inheritDoc}
232      * @param p  {@inheritDoc}
233      * @return the result of scanning
234      */
235     @Override
236     public R visitEmptyStatement(EmptyStatementTree node, P p) {
237         return null;
238     }
239 
240     /**
241      * {@inheritDoc} This implementation scans the children in left to right order.
242      *
243      * @param node  {@inheritDoc}
244      * @param p  {@inheritDoc}
245      * @return the result of scanning
246      */
247     @Override
248     public R visitBlock(BlockTree node, P p) {
249         return scan(node.getStatements(), p);
250     }
251 
252     /**
253      * {@inheritDoc} This implementation scans the children in left to right order.
254      *
255      * @param node  {@inheritDoc}
256      * @param p  {@inheritDoc}
257      * @return the result of scanning
258      */
259     @Override
260     public R visitDoWhileLoop(DoWhileLoopTree node, P p) {
261         R r = scan(node.getStatement(), p);
262         r = scanAndReduce(node.getCondition(), p, r);
263         return r;
264     }
265 
266     /**
267      * {@inheritDoc} This implementation scans the children in left to right order.
268      *
269      * @param node  {@inheritDoc}
270      * @param p  {@inheritDoc}
271      * @return the result of scanning
272      */
273     @Override
274     public R visitWhileLoop(WhileLoopTree node, P p) {
275         R r = scan(node.getCondition(), p);
276         r = scanAndReduce(node.getStatement(), p, r);
277         return r;
278     }
279 
280     /**
281      * {@inheritDoc} This implementation scans the children in left to right order.
282      *
283      * @param node  {@inheritDoc}
284      * @param p  {@inheritDoc}
285      * @return the result of scanning
286      */
287     @Override
288     public R visitForLoop(ForLoopTree node, P p) {
289         R r = scan(node.getInitializer(), p);
290         r = scanAndReduce(node.getCondition(), p, r);
291         r = scanAndReduce(node.getUpdate(), p, r);
292         r = scanAndReduce(node.getStatement(), p, r);
293         return r;
294     }
295 
296     /**
297      * {@inheritDoc} This implementation scans the children in left to right order.
298      *
299      * @param node  {@inheritDoc}
300      * @param p  {@inheritDoc}
301      * @return the result of scanning
302      */
303     @Override
304     public R visitEnhancedForLoop(EnhancedForLoopTree node, P p) {
305         R r = scan(node.getVariable(), p);
306         r = scanAndReduce(node.getExpression(), p, r);
307         r = scanAndReduce(node.getStatement(), p, r);
308         return r;
309     }
310 
311     /**
312      * {@inheritDoc} This implementation scans the children in left to right order.
313      *
314      * @param node  {@inheritDoc}
315      * @param p  {@inheritDoc}
316      * @return the result of scanning
317      */
318     @Override
319     public R visitLabeledStatement(LabeledStatementTree node, P p) {
320         return scan(node.getStatement(), p);
321     }
322 
323     /**
324      * {@inheritDoc} This implementation scans the children in left to right order.
325      *
326      * @param node  {@inheritDoc}
327      * @param p  {@inheritDoc}
328      * @return the result of scanning
329      */
330     @Override
331     public R visitSwitch(SwitchTree node, P p) {
332         R r = scan(node.getExpression(), p);
333         r = scanAndReduce(node.getCases(), p, r);
334         return r;
335     }
336 
337     /**
338      * {@inheritDoc} This implementation scans the children in left to right order.
339      *
340      * @param node  {@inheritDoc}
341      * @param p  {@inheritDoc}
342      * @return the result of scanning
343      *
344      * @deprecated
345      * This method is modeling switch expressions,
346      * which are part of a preview feature and may be removed
347      * if the preview feature is removed.
348      */
349     @Override
350     @Deprecated(forRemoval=true, since=&quot;12&quot;)
351     @SuppressWarnings(&quot;removal&quot;)
352     public R visitSwitchExpression(SwitchExpressionTree node, P p) {
353         R r = scan(node.getExpression(), p);
354         r = scanAndReduce(node.getCases(), p, r);
355         return r;
356     }
357 
358     /**
359      * {@inheritDoc} This implementation scans the children in left to right order.
360      *
361      * @param node  {@inheritDoc}
362      * @param p  {@inheritDoc}
363      * @return the result of scanning
364      */
365     @Override
366     @SuppressWarnings(&quot;removal&quot;)
367     public R visitCase(CaseTree node, P p) {
368         R r = scan(node.getExpressions(), p);
369         if (node.getCaseKind() == CaseKind.RULE)
370             r = scanAndReduce(node.getBody(), p, r);
371         else
372             r = scanAndReduce(node.getStatements(), p, r);
373         return r;
374     }
375 
376     /**
377      * {@inheritDoc} This implementation scans the children in left to right order.
378      *
379      * @param node  {@inheritDoc}
380      * @param p  {@inheritDoc}
381      * @return the result of scanning
382      */
383     @Override
384     public R visitSynchronized(SynchronizedTree node, P p) {
385         R r = scan(node.getExpression(), p);
386         r = scanAndReduce(node.getBlock(), p, r);
387         return r;
388     }
389 
390     /**
391      * {@inheritDoc} This implementation scans the children in left to right order.
392      *
393      * @param node  {@inheritDoc}
394      * @param p  {@inheritDoc}
395      * @return the result of scanning
396      */
397     @Override
398     public R visitTry(TryTree node, P p) {
399         R r = scan(node.getResources(), p);
400         r = scanAndReduce(node.getBlock(), p, r);
401         r = scanAndReduce(node.getCatches(), p, r);
402         r = scanAndReduce(node.getFinallyBlock(), p, r);
403         return r;
404     }
405 
406     /**
407      * {@inheritDoc} This implementation scans the children in left to right order.
408      *
409      * @param node  {@inheritDoc}
410      * @param p  {@inheritDoc}
411      * @return the result of scanning
412      */
413     @Override
414     public R visitCatch(CatchTree node, P p) {
415         R r = scan(node.getParameter(), p);
416         r = scanAndReduce(node.getBlock(), p, r);
417         return r;
418     }
419 
420     /**
421      * {@inheritDoc} This implementation scans the children in left to right order.
422      *
423      * @param node  {@inheritDoc}
424      * @param p  {@inheritDoc}
425      * @return the result of scanning
426      */
427     @Override
428     public R visitConditionalExpression(ConditionalExpressionTree node, P p) {
429         R r = scan(node.getCondition(), p);
430         r = scanAndReduce(node.getTrueExpression(), p, r);
431         r = scanAndReduce(node.getFalseExpression(), p, r);
432         return r;
433     }
434 
435     /**
436      * {@inheritDoc} This implementation scans the children in left to right order.
437      *
438      * @param node  {@inheritDoc}
439      * @param p  {@inheritDoc}
440      * @return the result of scanning
441      */
442     @Override
443     public R visitIf(IfTree node, P p) {
444         R r = scan(node.getCondition(), p);
445         r = scanAndReduce(node.getThenStatement(), p, r);
446         r = scanAndReduce(node.getElseStatement(), p, r);
447         return r;
448     }
449 
450     /**
451      * {@inheritDoc} This implementation scans the children in left to right order.
452      *
453      * @param node  {@inheritDoc}
454      * @param p  {@inheritDoc}
455      * @return the result of scanning
456      */
457     @Override
458     public R visitExpressionStatement(ExpressionStatementTree node, P p) {
459         return scan(node.getExpression(), p);
460     }
461 
462     /**
463      * {@inheritDoc} This implementation returns {@code null}.
464      *
465      * @param node  {@inheritDoc}
466      * @param p  {@inheritDoc}
467      * @return the result of scanning
468      */
469     @Override
470     @SuppressWarnings(&quot;removal&quot;)
471     public R visitBreak(BreakTree node, P p) {
472         return scan(node.getValue(), p);
473     }
474 
475     /**
476      * {@inheritDoc} This implementation returns {@code null}.
477      *
478      * @param node  {@inheritDoc}
479      * @param p  {@inheritDoc}
480      * @return the result of scanning
481      */
482     @Override
483     public R visitContinue(ContinueTree node, P p) {
484         return null;
485     }
486 
487     /**
488      * {@inheritDoc} This implementation scans the children in left to right order.
489      *
490      * @param node  {@inheritDoc}
491      * @param p  {@inheritDoc}
492      * @return the result of scanning
493      */
494     @Override
495     public R visitReturn(ReturnTree node, P p) {
496         return scan(node.getExpression(), p);
497     }
498 
499     /**
500      * {@inheritDoc} This implementation scans the children in left to right order.
501      *
502      * @param node  {@inheritDoc}
503      * @param p  {@inheritDoc}
504      * @return the result of scanning
505      */
506     @Override
507     public R visitThrow(ThrowTree node, P p) {
508         return scan(node.getExpression(), p);
509     }
510 
511     /**
512      * {@inheritDoc} This implementation scans the children in left to right order.
513      *
514      * @param node  {@inheritDoc}
515      * @param p  {@inheritDoc}
516      * @return the result of scanning
517      */
518     @Override
519     public R visitAssert(AssertTree node, P p) {
520         R r = scan(node.getCondition(), p);
521         r = scanAndReduce(node.getDetail(), p, r);
522         return r;
523     }
524 
525     /**
526      * {@inheritDoc} This implementation scans the children in left to right order.
527      *
528      * @param node  {@inheritDoc}
529      * @param p  {@inheritDoc}
530      * @return the result of scanning
531      */
532     @Override
533     public R visitMethodInvocation(MethodInvocationTree node, P p) {
534         R r = scan(node.getTypeArguments(), p);
535         r = scanAndReduce(node.getMethodSelect(), p, r);
536         r = scanAndReduce(node.getArguments(), p, r);
537         return r;
538     }
539 
540     /**
541      * {@inheritDoc} This implementation scans the children in left to right order.
542      *
543      * @param node  {@inheritDoc}
544      * @param p  {@inheritDoc}
545      * @return the result of scanning
546      */
547     @Override
548     public R visitNewClass(NewClassTree node, P p) {
549         R r = scan(node.getEnclosingExpression(), p);
550         r = scanAndReduce(node.getIdentifier(), p, r);
551         r = scanAndReduce(node.getTypeArguments(), p, r);
552         r = scanAndReduce(node.getArguments(), p, r);
553         r = scanAndReduce(node.getClassBody(), p, r);
554         return r;
555     }
556 
557     /**
558      * {@inheritDoc} This implementation scans the children in left to right order.
559      *
560      * @param node  {@inheritDoc}
561      * @param p  {@inheritDoc}
562      * @return the result of scanning
563      */
564     @Override
565     public R visitNewArray(NewArrayTree node, P p) {
566         R r = scan(node.getType(), p);
567         r = scanAndReduce(node.getDimensions(), p, r);
568         r = scanAndReduce(node.getInitializers(), p, r);
569         r = scanAndReduce(node.getAnnotations(), p, r);
570         for (Iterable&lt; ? extends Tree&gt; dimAnno : node.getDimAnnotations()) {
571             r = scanAndReduce(dimAnno, p, r);
572         }
573         return r;
574     }
575 
576     /**
577      * {@inheritDoc} This implementation scans the children in left to right order.
578      *
579      * @param node  {@inheritDoc}
580      * @param p  {@inheritDoc}
581      * @return the result of scanning
582      */
583     @Override
584     public R visitLambdaExpression(LambdaExpressionTree node, P p) {
585         R r = scan(node.getParameters(), p);
586         r = scanAndReduce(node.getBody(), p, r);
587         return r;
588     }
589 
590     /**
591      * {@inheritDoc} This implementation scans the children in left to right order.
592      *
593      * @param node  {@inheritDoc}
594      * @param p  {@inheritDoc}
595      * @return the result of scanning
596      */
597     @Override
598     public R visitParenthesized(ParenthesizedTree node, P p) {
599         return scan(node.getExpression(), p);
600     }
601 
602     /**
603      * {@inheritDoc} This implementation scans the children in left to right order.
604      *
605      * @param node  {@inheritDoc}
606      * @param p  {@inheritDoc}
607      * @return the result of scanning
608      */
609     @Override
610     public R visitAssignment(AssignmentTree node, P p) {
611         R r = scan(node.getVariable(), p);
612         r = scanAndReduce(node.getExpression(), p, r);
613         return r;
614     }
615 
616     /**
617      * {@inheritDoc} This implementation scans the children in left to right order.
618      *
619      * @param node  {@inheritDoc}
620      * @param p  {@inheritDoc}
621      * @return the result of scanning
622      */
623     @Override
624     public R visitCompoundAssignment(CompoundAssignmentTree node, P p) {
625         R r = scan(node.getVariable(), p);
626         r = scanAndReduce(node.getExpression(), p, r);
627         return r;
628     }
629 
630     /**
631      * {@inheritDoc} This implementation scans the children in left to right order.
632      *
633      * @param node  {@inheritDoc}
634      * @param p  {@inheritDoc}
635      * @return the result of scanning
636      */
637     @Override
638     public R visitUnary(UnaryTree node, P p) {
639         return scan(node.getExpression(), p);
640     }
641 
642     /**
643      * {@inheritDoc} This implementation scans the children in left to right order.
644      *
645      * @param node  {@inheritDoc}
646      * @param p  {@inheritDoc}
647      * @return the result of scanning
648      */
649     @Override
650     public R visitBinary(BinaryTree node, P p) {
651         R r = scan(node.getLeftOperand(), p);
652         r = scanAndReduce(node.getRightOperand(), p, r);
653         return r;
654     }
655 
656     /**
657      * {@inheritDoc} This implementation scans the children in left to right order.
658      *
659      * @param node  {@inheritDoc}
660      * @param p  {@inheritDoc}
661      * @return the result of scanning
662      */
663     @Override
664     public R visitTypeCast(TypeCastTree node, P p) {
665         R r = scan(node.getType(), p);
666         r = scanAndReduce(node.getExpression(), p, r);
667         return r;
668     }
669 
670     /**
671      * {@inheritDoc} This implementation scans the children in left to right order.
672      *
673      * @param node  {@inheritDoc}
674      * @param p  {@inheritDoc}
675      * @return the result of scanning
676      */
677     @Override
678     public R visitInstanceOf(InstanceOfTree node, P p) {
679         R r = scan(node.getExpression(), p);
680         r = scanAndReduce(node.getType(), p, r);
681         return r;
682     }
683 
684     /**
685      * {@inheritDoc} This implementation scans the children in left to right order.
686      *
687      * @param node  {@inheritDoc}
688      * @param p  {@inheritDoc}
689      * @return the result of scanning
690      */
691     @Override
692     public R visitArrayAccess(ArrayAccessTree node, P p) {
693         R r = scan(node.getExpression(), p);
694         r = scanAndReduce(node.getIndex(), p, r);
695         return r;
696     }
697 
698     /**
699      * {@inheritDoc} This implementation scans the children in left to right order.
700      *
701      * @param node  {@inheritDoc}
702      * @param p  {@inheritDoc}
703      * @return the result of scanning
704      */
705     @Override
706     public R visitMemberSelect(MemberSelectTree node, P p) {
707         return scan(node.getExpression(), p);
708     }
709 
710     /**
711      * {@inheritDoc} This implementation scans the children in left to right order.
712      *
713      * @param node  {@inheritDoc}
714      * @param p  {@inheritDoc}
715      * @return the result of scanning
716      */
717     @Override
718     public R visitMemberReference(MemberReferenceTree node, P p) {
719         R r = scan(node.getQualifierExpression(), p);
720         r = scanAndReduce(node.getTypeArguments(), p, r);
721         return r;
722     }
723 
724     /**
725      * {@inheritDoc} This implementation returns {@code null}.
726      *
727      * @param node  {@inheritDoc}
728      * @param p  {@inheritDoc}
729      * @return the result of scanning
730      */
731     @Override
732     public R visitIdentifier(IdentifierTree node, P p) {
733         return null;
734     }
735 
736     /**
737      * {@inheritDoc} This implementation returns {@code null}.
738      *
739      * @param node  {@inheritDoc}
740      * @param p  {@inheritDoc}
741      * @return the result of scanning
742      */
743     @Override
744     public R visitLiteral(LiteralTree node, P p) {
745         return null;
746     }
747 
748     /**
749      * {@inheritDoc} This implementation returns {@code null}.
750      *
751      * @param node  {@inheritDoc}
752      * @param p  {@inheritDoc}
753      * @return the result of scanning
754      */
755     @Override
756     public R visitPrimitiveType(PrimitiveTypeTree node, P p) {
757         return null;
758     }
759 
760     /**
761      * {@inheritDoc} This implementation scans the children in left to right order.
762      *
763      * @param node  {@inheritDoc}
764      * @param p  {@inheritDoc}
765      * @return the result of scanning
766      */
767     @Override
768     public R visitArrayType(ArrayTypeTree node, P p) {
769         return scan(node.getType(), p);
770     }
771 
772     /**
773      * {@inheritDoc} This implementation scans the children in left to right order.
774      *
775      * @param node  {@inheritDoc}
776      * @param p  {@inheritDoc}
777      * @return the result of scanning
778      */
779     @Override
780     public R visitParameterizedType(ParameterizedTypeTree node, P p) {
781         R r = scan(node.getType(), p);
782         r = scanAndReduce(node.getTypeArguments(), p, r);
783         return r;
784     }
785 
786     /**
787      * {@inheritDoc} This implementation scans the children in left to right order.
788      *
789      * @param node  {@inheritDoc}
790      * @param p  {@inheritDoc}
791      * @return the result of scanning
792      */
793     @Override
794     public R visitUnionType(UnionTypeTree node, P p) {
795         return scan(node.getTypeAlternatives(), p);
796     }
797 
798     /**
799      * {@inheritDoc} This implementation scans the children in left to right order.
800      *
801      * @param node  {@inheritDoc}
802      * @param p  {@inheritDoc}
803      * @return the result of scanning
804      */
805     @Override
806     public R visitIntersectionType(IntersectionTypeTree node, P p) {
807         return scan(node.getBounds(), p);
808     }
809 
810     /**
811      * {@inheritDoc} This implementation scans the children in left to right order.
812      *
813      * @param node  {@inheritDoc}
814      * @param p  {@inheritDoc}
815      * @return the result of scanning
816      */
817     @Override
818     public R visitTypeParameter(TypeParameterTree node, P p) {
819         R r = scan(node.getAnnotations(), p);
820         r = scanAndReduce(node.getBounds(), p, r);
821         return r;
822     }
823 
824     /**
825      * {@inheritDoc} This implementation scans the children in left to right order.
826      *
827      * @param node  {@inheritDoc}
828      * @param p  {@inheritDoc}
829      * @return the result of scanning
830      */
831     @Override
832     public R visitWildcard(WildcardTree node, P p) {
833         return scan(node.getBound(), p);
834     }
835 
836     /**
837      * {@inheritDoc} This implementation scans the children in left to right order.
838      *
839      * @param node  {@inheritDoc}
840      * @param p  {@inheritDoc}
841      * @return the result of scanning
842      */
843     @Override
844     public R visitModifiers(ModifiersTree node, P p) {
845         return scan(node.getAnnotations(), p);
846     }
847 
848     /**
849      * {@inheritDoc} This implementation scans the children in left to right order.
850      *
851      * @param node  {@inheritDoc}
852      * @param p  {@inheritDoc}
853      * @return the result of scanning
854      */
855     @Override
856     public R visitAnnotation(AnnotationTree node, P p) {
857         R r = scan(node.getAnnotationType(), p);
858         r = scanAndReduce(node.getArguments(), p, r);
859         return r;
860     }
861 
862     /**
863      * {@inheritDoc} This implementation scans the children in left to right order.
864      *
865      * @param node  {@inheritDoc}
866      * @param p  {@inheritDoc}
867      * @return the result of scanning
868      */
869     @Override
870     public R visitAnnotatedType(AnnotatedTypeTree node, P p) {
871         R r = scan(node.getAnnotations(), p);
872         r = scanAndReduce(node.getUnderlyingType(), p, r);
873         return r;
874     }
875 
876     @Override
877     public R visitModule(ModuleTree node, P p) {
878         R r = scan(node.getAnnotations(), p);
879         r = scanAndReduce(node.getName(), p, r);
880         r = scanAndReduce(node.getDirectives(), p, r);
881         return r;
882     }
883 
884     @Override
885     public R visitExports(ExportsTree node, P p) {
886         R r = scan(node.getPackageName(), p);
887         r = scanAndReduce(node.getModuleNames(), p, r);
888         return r;
889     }
890 
891     @Override
892     public R visitOpens(OpensTree node, P p) {
893         R r = scan(node.getPackageName(), p);
894         r = scanAndReduce(node.getModuleNames(), p, r);
895         return r;
896     }
897 
898     @Override
899     public R visitProvides(ProvidesTree node, P p) {
900         R r = scan(node.getServiceName(), p);
901         r = scanAndReduce(node.getImplementationNames(), p, r);
902         return r;
903     }
904 
905     @Override
906     public R visitRequires(RequiresTree node, P p) {
907         return scan(node.getModuleName(), p);
908     }
909 
910     @Override
911     public R visitUses(UsesTree node, P p) {
912         return scan(node.getServiceName(), p);
913     }
914 
915     /**
916      * {@inheritDoc} This implementation returns {@code null}.
917      *
918      * @param node  {@inheritDoc}
919      * @param p  {@inheritDoc}
920      * @return the result of scanning
921      */
922     @Override
923     public R visitOther(Tree node, P p) {
924         return null;
925     }
926 
927     /**
928      * {@inheritDoc} This implementation returns {@code null}.
929      *
930      * @param node  {@inheritDoc}
931      * @param p  {@inheritDoc}
932      * @return the result of scanning
933      */
934     @Override
935     public R visitErroneous(ErroneousTree node, P p) {
936         return null;
937     }
938 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavaTokenizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
<a name="2" id="anc2"></a><span class="line-added">  28 import com.sun.tools.javac.code.Lint;</span>
<span class="line-added">  29 import com.sun.tools.javac.code.Lint.LintCategory;</span>
  30 import com.sun.tools.javac.code.Preview;
  31 import com.sun.tools.javac.code.Source;
  32 import com.sun.tools.javac.code.Source.Feature;
  33 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  34 import com.sun.tools.javac.resources.CompilerProperties.Errors;
<a name="3" id="anc3"></a><span class="line-added">  35 import com.sun.tools.javac.resources.CompilerProperties.Warnings;</span>
  36 import com.sun.tools.javac.util.*;
<a name="4" id="anc4"></a><span class="line-modified">  37 import com.sun.tools.javac.util.JCDiagnostic.*;</span>
  38 
<a name="5" id="anc5"></a><span class="line-added">  39 import java.lang.reflect.InvocationTargetException;</span>
<span class="line-added">  40 import java.lang.reflect.Method;</span>
  41 import java.nio.CharBuffer;
<a name="6" id="anc6"></a><span class="line-added">  42 import java.util.HashSet;</span>
<span class="line-added">  43 import java.util.Set;</span>
  44 
  45 import static com.sun.tools.javac.parser.Tokens.*;
  46 import static com.sun.tools.javac.util.LayoutCharacters.*;
  47 
  48 /** The lexical analyzer maps an input stream consisting of
  49  *  ASCII characters and Unicode escapes into a token sequence.
  50  *
  51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  52  *  If you write code that depends on this, you do so at your own risk.
  53  *  This code and its internal interfaces are subject to change or
  54  *  deletion without notice.&lt;/b&gt;
  55  */
  56 public class JavaTokenizer {
  57 
  58     private static final boolean scannerDebug = false;
  59 
  60     /** The source language setting.
  61      */
  62     private Source source;
  63 
  64     /** The preview language setting. */
  65     private Preview preview;
  66 
  67     /** The log to be used for error reporting.
  68      */
  69     private final Log log;
  70 
  71     /** The token factory. */
  72     private final Tokens tokens;
  73 
  74     /** The token kind, set by nextToken().
  75      */
  76     protected TokenKind tk;
  77 
  78     /** The token&#39;s radix, set by nextToken().
  79      */
  80     protected int radix;
  81 
  82     /** The token&#39;s name, set by nextToken().
  83      */
  84     protected Name name;
  85 
  86     /** The position where a lexical error occurred;
  87      */
  88     protected int errPos = Position.NOPOS;
  89 
  90     /** The Unicode reader (low-level stream reader).
  91      */
  92     protected UnicodeReader reader;
  93 
<a name="7" id="anc7"></a><span class="line-added">  94     /** If is a text block</span>
<span class="line-added">  95      */</span>
<span class="line-added">  96     protected boolean isTextBlock;</span>
<span class="line-added">  97 </span>
<span class="line-added">  98     /** If contains escape sequences</span>
<span class="line-added">  99      */</span>
<span class="line-added"> 100     protected boolean hasEscapeSequences;</span>
<span class="line-added"> 101 </span>
 102     protected ScannerFactory fac;
 103 
<a name="8" id="anc8"></a><span class="line-added"> 104     // The set of lint options currently in effect. It is initialized</span>
<span class="line-added"> 105     // from the context, and then is set/reset as needed by Attr as it</span>
<span class="line-added"> 106     // visits all the various parts of the trees during attribution.</span>
<span class="line-added"> 107     protected Lint lint;</span>
<span class="line-added"> 108 </span>
 109     private static final boolean hexFloatsWork = hexFloatsWork();
 110     private static boolean hexFloatsWork() {
 111         try {
 112             Float.valueOf(&quot;0x1.0p1&quot;);
 113             return true;
 114         } catch (NumberFormatException ex) {
 115             return false;
 116         }
 117     }
 118 
 119     /**
 120      * Create a scanner from the input array.  This method might
 121      * modify the array.  To avoid copying the input array, ensure
 122      * that {@code inputLength &lt; input.length} or
 123      * {@code input[input.length -1]} is a white space character.
 124      *
 125      * @param fac the factory which created this Scanner
 126      * @param buf the input, might be modified
 127      * Must be positive and less than or equal to input.length.
 128      */
 129     protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {
 130         this(fac, new UnicodeReader(fac, buf));
 131     }
 132 
 133     protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {
 134         this(fac, new UnicodeReader(fac, buf, inputLength));
 135     }
 136 
 137     protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {
 138         this.fac = fac;
 139         this.log = fac.log;
 140         this.tokens = fac.tokens;
 141         this.source = fac.source;
 142         this.preview = fac.preview;
 143         this.reader = reader;
<a name="9" id="anc9"></a><span class="line-added"> 144         this.lint = fac.lint;</span>
 145     }
 146 
 147     protected void checkSourceLevel(int pos, Feature feature) {
 148         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
 149             //preview feature without --preview flag, error
 150             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
 151         } else if (!feature.allowedInSource(source)) {
 152             //incompatible source level, error
 153             lexError(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
 154         } else if (preview.isPreview(feature)) {
 155             //use of preview feature, warn
 156             preview.warnPreview(pos, feature);
 157         }
 158     }
 159 
 160     /** Report an error at the given position using the provided arguments.
 161      */
 162     protected void lexError(int pos, JCDiagnostic.Error key) {
 163         log.error(pos, key);
 164         tk = TokenKind.ERROR;
 165         errPos = pos;
 166     }
 167 
 168     protected void lexError(DiagnosticFlag flags, int pos, JCDiagnostic.Error key) {
 169         log.error(flags, pos, key);
 170         tk = TokenKind.ERROR;
 171         errPos = pos;
 172     }
 173 
<a name="10" id="anc10"></a><span class="line-added"> 174     protected void lexWarning(LintCategory lc, int pos, JCDiagnostic.Warning key) {</span>
<span class="line-added"> 175         DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;</span>
<span class="line-added"> 176         log.warning(lc, dp, key);</span>
<span class="line-added"> 177     }</span>
<span class="line-added"> 178 </span>
 179     /** Read next character in character or string literal and copy into sbuf.
<a name="11" id="anc11"></a><span class="line-added"> 180      *      pos - start of literal offset</span>
<span class="line-added"> 181      *      translateEscapesNow - true if String::translateEscapes is not available</span>
<span class="line-added"> 182      *                            in the java.base libs. Occurs during bootstrapping.</span>
<span class="line-added"> 183      *      multiline - true if scanning a text block. Allows newlines to be embedded</span>
<span class="line-added"> 184      *                  in the result.</span>
 185      */
<a name="12" id="anc12"></a><span class="line-modified"> 186     private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {</span>
<span class="line-modified"> 187          if (reader.ch == &#39;\\&#39;) {</span>
 188             if (reader.peekChar() == &#39;\\&#39; &amp;&amp; !reader.isUnicode()) {
 189                 reader.skipChar();
<a name="13" id="anc13"></a><span class="line-modified"> 190                 if (!translateEscapesNow) {</span>
<span class="line-added"> 191                     reader.putChar(false);</span>
<span class="line-added"> 192                 }</span>
<span class="line-added"> 193                 reader.putChar(true);</span>
 194             } else {
<a name="14" id="anc14"></a><span class="line-modified"> 195                 reader.nextChar(translateEscapesNow);</span>
 196                 switch (reader.ch) {
 197                 case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
 198                 case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
 199                     char leadch = reader.ch;
 200                     int oct = reader.digit(pos, 8);
<a name="15" id="anc15"></a><span class="line-modified"> 201                     reader.nextChar(translateEscapesNow);</span>
 202                     if (&#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 203                         oct = oct * 8 + reader.digit(pos, 8);
<a name="16" id="anc16"></a><span class="line-modified"> 204                         reader.nextChar(translateEscapesNow);</span>
 205                         if (leadch &lt;= &#39;3&#39; &amp;&amp; &#39;0&#39; &lt;= reader.ch &amp;&amp; reader.ch &lt;= &#39;7&#39;) {
 206                             oct = oct * 8 + reader.digit(pos, 8);
<a name="17" id="anc17"></a><span class="line-modified"> 207                             reader.nextChar(translateEscapesNow);</span>
 208                         }
 209                     }
<a name="18" id="anc18"></a><span class="line-modified"> 210                     if (translateEscapesNow) {</span>
<span class="line-added"> 211                         reader.putChar((char)oct);</span>
<span class="line-added"> 212                     }</span>
 213                     break;
 214                 case &#39;b&#39;:
<a name="19" id="anc19"></a><span class="line-modified"> 215                     reader.putChar(translateEscapesNow ? &#39;\b&#39; : &#39;b&#39;, true); break;</span>
 216                 case &#39;t&#39;:
<a name="20" id="anc20"></a><span class="line-modified"> 217                     reader.putChar(translateEscapesNow ? &#39;\t&#39; : &#39;t&#39;, true); break;</span>
 218                 case &#39;n&#39;:
<a name="21" id="anc21"></a><span class="line-modified"> 219                     reader.putChar(translateEscapesNow ? &#39;\n&#39; : &#39;n&#39;, true); break;</span>
 220                 case &#39;f&#39;:
<a name="22" id="anc22"></a><span class="line-modified"> 221                     reader.putChar(translateEscapesNow ? &#39;\f&#39; : &#39;f&#39;, true); break;</span>
 222                 case &#39;r&#39;:
<a name="23" id="anc23"></a><span class="line-modified"> 223                     reader.putChar(translateEscapesNow ? &#39;\r&#39; : &#39;r&#39;, true); break;</span>
 224                 case &#39;\&#39;&#39;:
<a name="24" id="anc24"></a>
 225                 case &#39;\&quot;&#39;:
<a name="25" id="anc25"></a>
 226                 case &#39;\\&#39;:
<a name="26" id="anc26"></a><span class="line-modified"> 227                     reader.putChar(true); break;</span>
<span class="line-added"> 228                 case &#39;s&#39;:</span>
<span class="line-added"> 229                     checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-added"> 230                     reader.putChar(translateEscapesNow ? &#39; &#39; : &#39;s&#39;, true); break;</span>
<span class="line-added"> 231                 case &#39;\n&#39;:</span>
<span class="line-added"> 232                 case &#39;\r&#39;:</span>
<span class="line-added"> 233                     if (!multiline) {</span>
<span class="line-added"> 234                         lexError(reader.bp, Errors.IllegalEscChar);</span>
<span class="line-added"> 235                     } else {</span>
<span class="line-added"> 236                         int start = reader.bp;</span>
<span class="line-added"> 237                         checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);</span>
<span class="line-added"> 238                         if (reader.ch == &#39;\r&#39; &amp;&amp; reader.peekChar() == &#39;\n&#39;) {</span>
<span class="line-added"> 239                            reader.nextChar(translateEscapesNow);</span>
<span class="line-added"> 240                         }</span>
<span class="line-added"> 241                         reader.nextChar(translateEscapesNow);</span>
<span class="line-added"> 242                         processLineTerminator(start, reader.bp);</span>
<span class="line-added"> 243                     }</span>
<span class="line-added"> 244                     break;</span>
 245                 default:
 246                     lexError(reader.bp, Errors.IllegalEscChar);
 247                 }
 248             }
 249         } else if (reader.bp != reader.buflen) {
 250             reader.putChar(true);
 251         }
 252     }
 253 
<a name="27" id="anc27"></a><span class="line-added"> 254     /** Interim access to String methods used to support text blocks.</span>
<span class="line-added"> 255      *  Required to handle bootstrapping with pre-text block jdks.</span>
<span class="line-added"> 256      *  Should be replaced with direct calls in the &#39;next&#39; jdk.</span>
<span class="line-added"> 257      */</span>
<span class="line-added"> 258     static class TextBlockSupport {</span>
<span class="line-added"> 259         /** Reflection method to remove incidental indentation.</span>
<span class="line-added"> 260          */</span>
<span class="line-added"> 261         private static final Method stripIndent;</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263         /** Reflection method to translate escape sequences.</span>
<span class="line-added"> 264          */</span>
<span class="line-added"> 265         private static final Method translateEscapes;</span>
<span class="line-added"> 266 </span>
<span class="line-added"> 267         /** true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-added"> 268          */</span>
<span class="line-added"> 269         private static final boolean hasSupport;</span>
<span class="line-added"> 270 </span>
<span class="line-added"> 271         /** Get a string method via refection or null if not available.</span>
<span class="line-added"> 272          */</span>
<span class="line-added"> 273         private static Method getStringMethodOrNull(String name) {</span>
<span class="line-added"> 274             try {</span>
<span class="line-added"> 275                 return String.class.getMethod(name);</span>
<span class="line-added"> 276             } catch (Exception ex) {</span>
<span class="line-added"> 277                 // Method not available, return null.</span>
<span class="line-added"> 278             }</span>
<span class="line-added"> 279             return null;</span>
<span class="line-added"> 280         }</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282         static {</span>
<span class="line-added"> 283             // Get text block string methods.</span>
<span class="line-added"> 284             stripIndent = getStringMethodOrNull(&quot;stripIndent&quot;);</span>
<span class="line-added"> 285             translateEscapes = getStringMethodOrNull(&quot;translateEscapes&quot;);</span>
<span class="line-added"> 286             // true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-added"> 287             hasSupport = stripIndent != null &amp;&amp; translateEscapes != null;</span>
<span class="line-added"> 288         }</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290         /** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.</span>
<span class="line-added"> 291          */</span>
<span class="line-added"> 292         static boolean hasSupport() {</span>
<span class="line-added"> 293             return hasSupport;</span>
<span class="line-added"> 294         }</span>
<span class="line-added"> 295 </span>
<span class="line-added"> 296         /** Return the leading whitespace count (indentation) of the line.</span>
<span class="line-added"> 297          */</span>
<span class="line-added"> 298         private static int indent(String line) {</span>
<span class="line-added"> 299             return line.length() - line.stripLeading().length();</span>
<span class="line-added"> 300         }</span>
<span class="line-added"> 301 </span>
<span class="line-added"> 302         enum WhitespaceChecks {</span>
<span class="line-added"> 303             INCONSISTENT,</span>
<span class="line-added"> 304             TRAILING</span>
<span class="line-added"> 305         };</span>
<span class="line-added"> 306 </span>
<span class="line-added"> 307         /** Check that the use of white space in content is not problematic.</span>
<span class="line-added"> 308          */</span>
<span class="line-added"> 309         static Set&lt;WhitespaceChecks&gt; checkWhitespace(String string) {</span>
<span class="line-added"> 310             // Start with empty result set.</span>
<span class="line-added"> 311             Set&lt;WhitespaceChecks&gt; checks = new HashSet&lt;&gt;();</span>
<span class="line-added"> 312             // No need to check empty strings.</span>
<span class="line-added"> 313             if (string.isEmpty()) {</span>
<span class="line-added"> 314                 return checks;</span>
<span class="line-added"> 315             }</span>
<span class="line-added"> 316             // Maximum common indentation.</span>
<span class="line-added"> 317             int outdent = 0;</span>
<span class="line-added"> 318             // No need to check indentation if opting out (last line is empty.)</span>
<span class="line-added"> 319             char lastChar = string.charAt(string.length() - 1);</span>
<span class="line-added"> 320             boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;</span>
<span class="line-added"> 321             // Split string based at line terminators.</span>
<span class="line-added"> 322             String[] lines = string.split(&quot;\\R&quot;);</span>
<span class="line-added"> 323             int length = lines.length;</span>
<span class="line-added"> 324             // Extract last line.</span>
<span class="line-added"> 325             String lastLine = length == 0 ? &quot;&quot; : lines[length - 1];</span>
<span class="line-added"> 326              if (!optOut) {</span>
<span class="line-added"> 327                 // Prime with the last line indentation (may be blank.)</span>
<span class="line-added"> 328                 outdent = indent(lastLine);</span>
<span class="line-added"> 329                 for (String line : lines) {</span>
<span class="line-added"> 330                     // Blanks lines have no influence (last line accounted for.)</span>
<span class="line-added"> 331                     if (!line.isBlank()) {</span>
<span class="line-added"> 332                         outdent = Integer.min(outdent, indent(line));</span>
<span class="line-added"> 333                         if (outdent == 0) {</span>
<span class="line-added"> 334                             break;</span>
<span class="line-added"> 335                         }</span>
<span class="line-added"> 336                     }</span>
<span class="line-added"> 337                 }</span>
<span class="line-added"> 338             }</span>
<span class="line-added"> 339             // Last line is representative.</span>
<span class="line-added"> 340             String start = lastLine.substring(0, outdent);</span>
<span class="line-added"> 341             for (String line : lines) {</span>
<span class="line-added"> 342                 // Fail if a line does not have the same indentation.</span>
<span class="line-added"> 343                 if (!line.isBlank() &amp;&amp; !line.startsWith(start)) {</span>
<span class="line-added"> 344                     // Mix of different white space</span>
<span class="line-added"> 345                     checks.add(WhitespaceChecks.INCONSISTENT);</span>
<span class="line-added"> 346                 }</span>
<span class="line-added"> 347                 // Line has content even after indent is removed.</span>
<span class="line-added"> 348                 if (outdent &lt; line.length()) {</span>
<span class="line-added"> 349                     // Is the last character a white space.</span>
<span class="line-added"> 350                     lastChar = line.charAt(line.length() - 1);</span>
<span class="line-added"> 351                     if (Character.isWhitespace(lastChar)) {</span>
<span class="line-added"> 352                         // Has trailing white space.</span>
<span class="line-added"> 353                         checks.add(WhitespaceChecks.TRAILING);</span>
<span class="line-added"> 354                     }</span>
<span class="line-added"> 355                 }</span>
<span class="line-added"> 356             }</span>
<span class="line-added"> 357             return checks;</span>
<span class="line-added"> 358         }</span>
<span class="line-added"> 359 </span>
<span class="line-added"> 360         /** Invoke String::stripIndent through reflection.</span>
<span class="line-added"> 361          */</span>
<span class="line-added"> 362         static String stripIndent(String string) {</span>
<span class="line-added"> 363             try {</span>
<span class="line-added"> 364                 string = (String)stripIndent.invoke(string);</span>
<span class="line-added"> 365             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-added"> 366                 throw new RuntimeException(ex);</span>
<span class="line-added"> 367             }</span>
<span class="line-added"> 368             return string;</span>
<span class="line-added"> 369         }</span>
<span class="line-added"> 370 </span>
<span class="line-added"> 371         /** Invoke String::translateEscapes through reflection.</span>
<span class="line-added"> 372          */</span>
<span class="line-added"> 373         static String translateEscapes(String string) {</span>
<span class="line-added"> 374             try {</span>
<span class="line-added"> 375                 string = (String)translateEscapes.invoke(string);</span>
<span class="line-added"> 376             } catch (InvocationTargetException | IllegalAccessException ex) {</span>
<span class="line-added"> 377                 throw new RuntimeException(ex);</span>
<span class="line-added"> 378             }</span>
<span class="line-added"> 379             return string;</span>
<span class="line-added"> 380         }</span>
<span class="line-added"> 381     }</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383     /** Test for EOLN.</span>
<span class="line-added"> 384      */</span>
<span class="line-added"> 385     private boolean isEOLN() {</span>
<span class="line-added"> 386         return reader.ch == LF || reader.ch == CR;</span>
<span class="line-added"> 387     }</span>
<span class="line-added"> 388 </span>
<span class="line-added"> 389     /** Test for CRLF.</span>
<span class="line-added"> 390      */</span>
<span class="line-added"> 391     private boolean isCRLF() {</span>
<span class="line-added"> 392         return reader.ch == CR &amp;&amp; reader.peekChar() == LF;</span>
<span class="line-added"> 393     }</span>
<span class="line-added"> 394 </span>
<span class="line-added"> 395     /** Count and skip repeated occurrences of the specified character.</span>
<span class="line-added"> 396      */</span>
<span class="line-added"> 397     private int countChar(char ch, int max) {</span>
<span class="line-added"> 398         int count = 0;</span>
<span class="line-added"> 399         for ( ; count &lt; max &amp;&amp; reader.bp &lt; reader.buflen &amp;&amp; reader.ch == ch; count++) {</span>
<span class="line-added"> 400             reader.scanChar();</span>
<span class="line-added"> 401         }</span>
<span class="line-added"> 402         return count;</span>
<span class="line-added"> 403     }</span>
<span class="line-added"> 404 </span>
<span class="line-added"> 405     /** Scan a string literal or text block.</span>
<span class="line-added"> 406      */</span>
<span class="line-added"> 407     private void scanString(int pos) {</span>
<span class="line-added"> 408         // Clear flags.</span>
<span class="line-added"> 409         isTextBlock = false;</span>
<span class="line-added"> 410         hasEscapeSequences = false;</span>
<span class="line-added"> 411         // Track the end of first line for error recovery.</span>
<span class="line-added"> 412         int firstEOLN = -1;</span>
<span class="line-added"> 413         // Attempt to scan for up to 3 double quotes.</span>
<span class="line-added"> 414         int openCount = countChar(&#39;\&quot;&#39;, 3);</span>
<span class="line-added"> 415         switch (openCount) {</span>
<span class="line-added"> 416         case 1: // Starting a string literal.</span>
<span class="line-added"> 417             break;</span>
<span class="line-added"> 418         case 2: // Starting an empty string literal.</span>
<span class="line-added"> 419             // Start again but only consume one quote.</span>
<span class="line-added"> 420             reader.reset(pos);</span>
<span class="line-added"> 421             openCount = countChar(&#39;\&quot;&#39;, 1);</span>
<span class="line-added"> 422             break;</span>
<span class="line-added"> 423         case 3: // Starting a text block.</span>
<span class="line-added"> 424             // Check if preview feature is enabled for text blocks.</span>
<span class="line-added"> 425             checkSourceLevel(pos, Feature.TEXT_BLOCKS);</span>
<span class="line-added"> 426             isTextBlock = true;</span>
<span class="line-added"> 427             // Verify the open delimiter sequence.</span>
<span class="line-added"> 428             boolean hasOpenEOLN = false;</span>
<span class="line-added"> 429             while (reader.bp &lt; reader.buflen &amp;&amp; Character.isWhitespace(reader.ch)) {</span>
<span class="line-added"> 430                 hasOpenEOLN = isEOLN();</span>
<span class="line-added"> 431                 if (hasOpenEOLN) {</span>
<span class="line-added"> 432                     break;</span>
<span class="line-added"> 433                 }</span>
<span class="line-added"> 434                 reader.scanChar();</span>
<span class="line-added"> 435             }</span>
<span class="line-added"> 436             // Error if the open delimiter sequence not is &quot;&quot;&quot;&lt;Whitespace&gt;*&lt;LineTerminator&gt;.</span>
<span class="line-added"> 437             if (!hasOpenEOLN) {</span>
<span class="line-added"> 438                 lexError(reader.bp, Errors.IllegalTextBlockOpen);</span>
<span class="line-added"> 439                 return;</span>
<span class="line-added"> 440             }</span>
<span class="line-added"> 441             // Skip line terminator.</span>
<span class="line-added"> 442             int start = reader.bp;</span>
<span class="line-added"> 443             if (isCRLF()) {</span>
<span class="line-added"> 444                 reader.scanChar();</span>
<span class="line-added"> 445             }</span>
<span class="line-added"> 446             reader.scanChar();</span>
<span class="line-added"> 447             processLineTerminator(start, reader.bp);</span>
<span class="line-added"> 448             break;</span>
<span class="line-added"> 449         }</span>
<span class="line-added"> 450         // While characters are available.</span>
<span class="line-added"> 451         while (reader.bp &lt; reader.buflen) {</span>
<span class="line-added"> 452             // If possible close delimiter sequence.</span>
<span class="line-added"> 453             if (reader.ch == &#39;\&quot;&#39;) {</span>
<span class="line-added"> 454                 // Check to see if enough double quotes are present.</span>
<span class="line-added"> 455                 int closeCount = countChar(&#39;\&quot;&#39;, openCount);</span>
<span class="line-added"> 456                 if (openCount == closeCount) {</span>
<span class="line-added"> 457                     // Good result.</span>
<span class="line-added"> 458                     tk = Tokens.TokenKind.STRINGLITERAL;</span>
<span class="line-added"> 459                     return;</span>
<span class="line-added"> 460                 }</span>
<span class="line-added"> 461                 // False alarm, add double quotes to string buffer.</span>
<span class="line-added"> 462                 reader.repeat(&#39;\&quot;&#39;, closeCount);</span>
<span class="line-added"> 463             } else if (isEOLN()) {</span>
<span class="line-added"> 464                 // Line terminator in string literal is an error.</span>
<span class="line-added"> 465                 // Fall out to unclosed string literal error.</span>
<span class="line-added"> 466                 if (openCount == 1) {</span>
<span class="line-added"> 467                     break;</span>
<span class="line-added"> 468                 }</span>
<span class="line-added"> 469                  // Add line terminator to string buffer.</span>
<span class="line-added"> 470                 int start = reader.bp;</span>
<span class="line-added"> 471                 if (isCRLF()) {</span>
<span class="line-added"> 472                     reader.scanChar();</span>
<span class="line-added"> 473                 }</span>
<span class="line-added"> 474                 reader.putChar(&#39;\n&#39;, true);</span>
<span class="line-added"> 475                 processLineTerminator(start, reader.bp);</span>
<span class="line-added"> 476                 // Record first line terminator for error recovery.</span>
<span class="line-added"> 477                 if (firstEOLN == -1) {</span>
<span class="line-added"> 478                     firstEOLN = reader.bp;</span>
<span class="line-added"> 479                 }</span>
<span class="line-added"> 480             } else if (reader.ch == &#39;\\&#39;) {</span>
<span class="line-added"> 481                 // Handle escape sequences.</span>
<span class="line-added"> 482                 hasEscapeSequences = true;</span>
<span class="line-added"> 483                 // Translate escapes immediately if TextBlockSupport is not available</span>
<span class="line-added"> 484                 // during bootstrapping.</span>
<span class="line-added"> 485                 boolean translateEscapesNow = !TextBlockSupport.hasSupport();</span>
<span class="line-added"> 486                 scanLitChar(pos, translateEscapesNow, openCount != 1);</span>
<span class="line-added"> 487             } else {</span>
<span class="line-added"> 488                 // Add character to string buffer.</span>
<span class="line-added"> 489                 reader.putChar(true);</span>
<span class="line-added"> 490             }</span>
<span class="line-added"> 491         }</span>
<span class="line-added"> 492         // String ended without close delimiter sequence.</span>
<span class="line-added"> 493         lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);</span>
<span class="line-added"> 494         if (firstEOLN  != -1) {</span>
<span class="line-added"> 495             // Reset recovery position to point after open delimiter sequence.</span>
<span class="line-added"> 496             reader.reset(firstEOLN);</span>
<span class="line-added"> 497         }</span>
<span class="line-added"> 498     }</span>
<span class="line-added"> 499 </span>
 500     private void scanDigits(int pos, int digitRadix) {
 501         char saveCh;
 502         int savePos;
 503         do {
 504             if (reader.ch != &#39;_&#39;) {
 505                 reader.putChar(false);
 506             }
 507             saveCh = reader.ch;
 508             savePos = reader.bp;
 509             reader.scanChar();
 510         } while (reader.digit(pos, digitRadix) &gt;= 0 || reader.ch == &#39;_&#39;);
 511         if (saveCh == &#39;_&#39;)
 512             lexError(savePos, Errors.IllegalUnderscore);
 513     }
 514 
 515     /** Read fractional part of hexadecimal floating point number.
 516      */
 517     private void scanHexExponentAndSuffix(int pos) {
 518         if (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;) {
 519             reader.putChar(true);
 520             skipIllegalUnderscores();
 521             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {
 522                 reader.putChar(true);
 523             }
 524             skipIllegalUnderscores();
 525             if (reader.digit(pos, 10) &gt;= 0) {
 526                 scanDigits(pos, 10);
 527                 if (!hexFloatsWork)
 528                     lexError(pos, Errors.UnsupportedCrossFpLit);
 529             } else
 530                 lexError(pos, Errors.MalformedFpLit);
 531         } else {
 532             lexError(pos, Errors.MalformedFpLit);
 533         }
 534         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {
 535             reader.putChar(true);
 536             tk = TokenKind.FLOATLITERAL;
 537             radix = 16;
 538         } else {
 539             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {
 540                 reader.putChar(true);
 541             }
 542             tk = TokenKind.DOUBLELITERAL;
 543             radix = 16;
 544         }
 545     }
 546 
 547     /** Read fractional part of floating point number.
 548      */
 549     private void scanFraction(int pos) {
 550         skipIllegalUnderscores();
 551         if (reader.digit(pos, 10) &gt;= 0) {
 552             scanDigits(pos, 10);
 553         }
 554         int sp1 = reader.sp;
 555         if (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39;) {
 556             reader.putChar(true);
 557             skipIllegalUnderscores();
 558             if (reader.ch == &#39;+&#39; || reader.ch == &#39;-&#39;) {
 559                 reader.putChar(true);
 560             }
 561             skipIllegalUnderscores();
 562             if (reader.digit(pos, 10) &gt;= 0) {
 563                 scanDigits(pos, 10);
 564                 return;
 565             }
 566             lexError(pos, Errors.MalformedFpLit);
 567             reader.sp = sp1;
 568         }
 569     }
 570 
 571     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.
 572      */
 573     private void scanFractionAndSuffix(int pos) {
 574         radix = 10;
 575         scanFraction(pos);
 576         if (reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39;) {
 577             reader.putChar(true);
 578             tk = TokenKind.FLOATLITERAL;
 579         } else {
 580             if (reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;) {
 581                 reader.putChar(true);
 582             }
 583             tk = TokenKind.DOUBLELITERAL;
 584         }
 585     }
 586 
 587     /** Read fractional part and &#39;d&#39; or &#39;f&#39; suffix of floating point number.
 588      */
 589     private void scanHexFractionAndSuffix(int pos, boolean seendigit) {
 590         radix = 16;
 591         Assert.check(reader.ch == &#39;.&#39;);
 592         reader.putChar(true);
 593         skipIllegalUnderscores();
 594         if (reader.digit(pos, 16) &gt;= 0) {
 595             seendigit = true;
 596             scanDigits(pos, 16);
 597         }
 598         if (!seendigit)
 599             lexError(pos, Errors.InvalidHexNumber);
 600         else
 601             scanHexExponentAndSuffix(pos);
 602     }
 603 
 604     private void skipIllegalUnderscores() {
 605         if (reader.ch == &#39;_&#39;) {
 606             lexError(reader.bp, Errors.IllegalUnderscore);
 607             while (reader.ch == &#39;_&#39;)
 608                 reader.scanChar();
 609         }
 610     }
 611 
 612     /** Read a number.
 613      *  @param radix  The radix of the number; one of 2, 8, 10, 16.
 614      */
 615     private void scanNumber(int pos, int radix) {
 616         // for octal, allow base-10 digit in case it&#39;s a float literal
 617         this.radix = radix;
 618         int digitRadix = (radix == 8 ? 10 : radix);
 619         int firstDigit = reader.digit(pos, Math.max(10, digitRadix));
 620         boolean seendigit = firstDigit &gt;= 0;
 621         boolean seenValidDigit = firstDigit &gt;= 0 &amp;&amp; firstDigit &lt; digitRadix;
 622         if (seendigit) {
 623             scanDigits(pos, digitRadix);
 624         }
 625         if (radix == 16 &amp;&amp; reader.ch == &#39;.&#39;) {
 626             scanHexFractionAndSuffix(pos, seendigit);
 627         } else if (seendigit &amp;&amp; radix == 16 &amp;&amp; (reader.ch == &#39;p&#39; || reader.ch == &#39;P&#39;)) {
 628             scanHexExponentAndSuffix(pos);
 629         } else if (digitRadix == 10 &amp;&amp; reader.ch == &#39;.&#39;) {
 630             reader.putChar(true);
 631             scanFractionAndSuffix(pos);
 632         } else if (digitRadix == 10 &amp;&amp;
 633                    (reader.ch == &#39;e&#39; || reader.ch == &#39;E&#39; ||
 634                     reader.ch == &#39;f&#39; || reader.ch == &#39;F&#39; ||
 635                     reader.ch == &#39;d&#39; || reader.ch == &#39;D&#39;)) {
 636             scanFractionAndSuffix(pos);
 637         } else {
 638             if (!seenValidDigit) {
 639                 switch (radix) {
 640                 case 2:
 641                     lexError(pos, Errors.InvalidBinaryNumber);
 642                     break;
 643                 case 16:
 644                     lexError(pos, Errors.InvalidHexNumber);
 645                     break;
 646                 }
 647             }
 648             if (reader.ch == &#39;l&#39; || reader.ch == &#39;L&#39;) {
 649                 reader.scanChar();
 650                 tk = TokenKind.LONGLITERAL;
 651             } else {
 652                 tk = TokenKind.INTLITERAL;
 653             }
 654         }
 655     }
 656 
 657     /** Read an identifier.
 658      */
 659     private void scanIdent() {
 660         boolean isJavaIdentifierPart;
 661         char high;
 662         reader.putChar(true);
 663         do {
 664             switch (reader.ch) {
 665             case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 666             case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 667             case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 668             case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 669             case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 670             case &#39;Z&#39;:
 671             case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 672             case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 673             case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 674             case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 675             case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 676             case &#39;z&#39;:
 677             case &#39;$&#39;: case &#39;_&#39;:
 678             case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 679             case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 680                 break;
 681             case &#39;\u0000&#39;: case &#39;\u0001&#39;: case &#39;\u0002&#39;: case &#39;\u0003&#39;:
 682             case &#39;\u0004&#39;: case &#39;\u0005&#39;: case &#39;\u0006&#39;: case &#39;\u0007&#39;:
 683             case &#39;\u0008&#39;: case &#39;\u000E&#39;: case &#39;\u000F&#39;: case &#39;\u0010&#39;:
 684             case &#39;\u0011&#39;: case &#39;\u0012&#39;: case &#39;\u0013&#39;: case &#39;\u0014&#39;:
 685             case &#39;\u0015&#39;: case &#39;\u0016&#39;: case &#39;\u0017&#39;:
 686             case &#39;\u0018&#39;: case &#39;\u0019&#39;: case &#39;\u001B&#39;:
 687             case &#39;\u007F&#39;:
 688                 reader.scanChar();
 689                 continue;
 690             case &#39;\u001A&#39;: // EOI is also a legal identifier part
 691                 if (reader.bp &gt;= reader.buflen) {
 692                     name = reader.name();
 693                     tk = tokens.lookupKind(name);
 694                     return;
 695                 }
 696                 reader.scanChar();
 697                 continue;
 698             default:
 699                 if (reader.ch &lt; &#39;\u0080&#39;) {
 700                     // all ASCII range chars already handled, above
 701                     isJavaIdentifierPart = false;
 702                 } else {
 703                     if (Character.isIdentifierIgnorable(reader.ch)) {
 704                         reader.scanChar();
 705                         continue;
 706                     } else {
 707                         int codePoint = reader.peekSurrogates();
 708                         if (codePoint &gt;= 0) {
 709                             if (isJavaIdentifierPart = Character.isJavaIdentifierPart(codePoint)) {
 710                                 reader.putChar(true);
 711                             }
 712                         } else {
 713                             isJavaIdentifierPart = Character.isJavaIdentifierPart(reader.ch);
 714                         }
 715                     }
 716                 }
 717                 if (!isJavaIdentifierPart) {
 718                     name = reader.name();
 719                     tk = tokens.lookupKind(name);
 720                     return;
 721                 }
 722             }
 723             reader.putChar(true);
 724         } while (true);
 725     }
 726 
 727     /** Return true if reader.ch can be part of an operator.
 728      */
 729     private boolean isSpecial(char ch) {
 730         switch (ch) {
 731         case &#39;!&#39;: case &#39;%&#39;: case &#39;&amp;&#39;: case &#39;*&#39;: case &#39;?&#39;:
 732         case &#39;+&#39;: case &#39;-&#39;: case &#39;:&#39;: case &#39;&lt;&#39;: case &#39;=&#39;:
 733         case &#39;&gt;&#39;: case &#39;^&#39;: case &#39;|&#39;: case &#39;~&#39;:
 734         case &#39;@&#39;:
 735             return true;
 736         default:
 737             return false;
 738         }
 739     }
 740 
 741     /** Read longest possible sequence of special characters and convert
 742      *  to token.
 743      */
 744     private void scanOperator() {
 745         while (true) {
 746             reader.putChar(false);
 747             Name newname = reader.name();
 748             TokenKind tk1 = tokens.lookupKind(newname);
 749             if (tk1 == TokenKind.IDENTIFIER) {
 750                 reader.sp--;
 751                 break;
 752             }
 753             tk = tk1;
 754             reader.scanChar();
 755             if (!isSpecial(reader.ch)) break;
 756         }
 757     }
 758 
 759     /** Read token.
 760      */
 761     public Token readToken() {
 762 
 763         reader.sp = 0;
 764         name = null;
 765         radix = 0;
 766 
 767         int pos = 0;
 768         int endPos = 0;
 769         List&lt;Comment&gt; comments = null;
 770 
 771         try {
 772             loop: while (true) {
 773                 pos = reader.bp;
 774                 switch (reader.ch) {
 775                 case &#39; &#39;: // (Spec 3.6)
 776                 case &#39;\t&#39;: // (Spec 3.6)
 777                 case FF: // (Spec 3.6)
 778                     do {
 779                         reader.scanChar();
 780                     } while (reader.ch == &#39; &#39; || reader.ch == &#39;\t&#39; || reader.ch == FF);
 781                     processWhiteSpace(pos, reader.bp);
 782                     break;
 783                 case LF: // (Spec 3.4)
 784                     reader.scanChar();
 785                     processLineTerminator(pos, reader.bp);
 786                     break;
 787                 case CR: // (Spec 3.4)
 788                     reader.scanChar();
 789                     if (reader.ch == LF) {
 790                         reader.scanChar();
 791                     }
 792                     processLineTerminator(pos, reader.bp);
 793                     break;
 794                 case &#39;A&#39;: case &#39;B&#39;: case &#39;C&#39;: case &#39;D&#39;: case &#39;E&#39;:
 795                 case &#39;F&#39;: case &#39;G&#39;: case &#39;H&#39;: case &#39;I&#39;: case &#39;J&#39;:
 796                 case &#39;K&#39;: case &#39;L&#39;: case &#39;M&#39;: case &#39;N&#39;: case &#39;O&#39;:
 797                 case &#39;P&#39;: case &#39;Q&#39;: case &#39;R&#39;: case &#39;S&#39;: case &#39;T&#39;:
 798                 case &#39;U&#39;: case &#39;V&#39;: case &#39;W&#39;: case &#39;X&#39;: case &#39;Y&#39;:
 799                 case &#39;Z&#39;:
 800                 case &#39;a&#39;: case &#39;b&#39;: case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;:
 801                 case &#39;f&#39;: case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;:
 802                 case &#39;k&#39;: case &#39;l&#39;: case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;:
 803                 case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;: case &#39;s&#39;: case &#39;t&#39;:
 804                 case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;: case &#39;y&#39;:
 805                 case &#39;z&#39;:
 806                 case &#39;$&#39;: case &#39;_&#39;:
 807                     scanIdent();
 808                     break loop;
 809                 case &#39;0&#39;:
 810                     reader.scanChar();
 811                     if (reader.ch == &#39;x&#39; || reader.ch == &#39;X&#39;) {
 812                         reader.scanChar();
 813                         skipIllegalUnderscores();
 814                         scanNumber(pos, 16);
 815                     } else if (reader.ch == &#39;b&#39; || reader.ch == &#39;B&#39;) {
 816                         reader.scanChar();
 817                         skipIllegalUnderscores();
 818                         scanNumber(pos, 2);
 819                     } else {
 820                         reader.putChar(&#39;0&#39;);
 821                         if (reader.ch == &#39;_&#39;) {
 822                             int savePos = reader.bp;
 823                             do {
 824                                 reader.scanChar();
 825                             } while (reader.ch == &#39;_&#39;);
 826                             if (reader.digit(pos, 10) &lt; 0) {
 827                                 lexError(savePos, Errors.IllegalUnderscore);
 828                             }
 829                         }
 830                         scanNumber(pos, 8);
 831                     }
 832                     break loop;
 833                 case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;:
 834                 case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
 835                     scanNumber(pos, 10);
 836                     break loop;
 837                 case &#39;.&#39;:
 838                     reader.scanChar();
 839                     if (reader.digit(pos, 10) &gt;= 0) {
 840                         reader.putChar(&#39;.&#39;);
 841                         scanFractionAndSuffix(pos);
 842                     } else if (reader.ch == &#39;.&#39;) {
 843                         int savePos = reader.bp;
 844                         reader.putChar(&#39;.&#39;); reader.putChar(&#39;.&#39;, true);
 845                         if (reader.ch == &#39;.&#39;) {
 846                             reader.scanChar();
 847                             reader.putChar(&#39;.&#39;);
 848                             tk = TokenKind.ELLIPSIS;
 849                         } else {
 850                             lexError(savePos, Errors.IllegalDot);
 851                         }
 852                     } else {
 853                         tk = TokenKind.DOT;
 854                     }
 855                     break loop;
 856                 case &#39;,&#39;:
 857                     reader.scanChar(); tk = TokenKind.COMMA; break loop;
 858                 case &#39;;&#39;:
 859                     reader.scanChar(); tk = TokenKind.SEMI; break loop;
 860                 case &#39;(&#39;:
 861                     reader.scanChar(); tk = TokenKind.LPAREN; break loop;
 862                 case &#39;)&#39;:
 863                     reader.scanChar(); tk = TokenKind.RPAREN; break loop;
 864                 case &#39;[&#39;:
 865                     reader.scanChar(); tk = TokenKind.LBRACKET; break loop;
 866                 case &#39;]&#39;:
 867                     reader.scanChar(); tk = TokenKind.RBRACKET; break loop;
 868                 case &#39;{&#39;:
 869                     reader.scanChar(); tk = TokenKind.LBRACE; break loop;
 870                 case &#39;}&#39;:
 871                     reader.scanChar(); tk = TokenKind.RBRACE; break loop;
 872                 case &#39;/&#39;:
 873                     reader.scanChar();
 874                     if (reader.ch == &#39;/&#39;) {
 875                         do {
 876                             reader.scanCommentChar();
 877                         } while (reader.ch != CR &amp;&amp; reader.ch != LF &amp;&amp; reader.bp &lt; reader.buflen);
 878                         if (reader.bp &lt; reader.buflen) {
 879                             comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));
 880                         }
 881                         break;
 882                     } else if (reader.ch == &#39;*&#39;) {
 883                         boolean isEmpty = false;
 884                         reader.scanChar();
 885                         CommentStyle style;
 886                         if (reader.ch == &#39;*&#39;) {
 887                             style = CommentStyle.JAVADOC;
 888                             reader.scanCommentChar();
 889                             if (reader.ch == &#39;/&#39;) {
 890                                 isEmpty = true;
 891                             }
 892                         } else {
 893                             style = CommentStyle.BLOCK;
 894                         }
 895                         while (!isEmpty &amp;&amp; reader.bp &lt; reader.buflen) {
 896                             if (reader.ch == &#39;*&#39;) {
 897                                 reader.scanChar();
 898                                 if (reader.ch == &#39;/&#39;) break;
 899                             } else {
 900                                 reader.scanCommentChar();
 901                             }
 902                         }
 903                         if (reader.ch == &#39;/&#39;) {
 904                             reader.scanChar();
 905                             comments = addComment(comments, processComment(pos, reader.bp, style));
 906                             break;
 907                         } else {
 908                             lexError(pos, Errors.UnclosedComment);
 909                             break loop;
 910                         }
 911                     } else if (reader.ch == &#39;=&#39;) {
 912                         tk = TokenKind.SLASHEQ;
 913                         reader.scanChar();
 914                     } else {
 915                         tk = TokenKind.SLASH;
 916                     }
 917                     break loop;
 918                 case &#39;\&#39;&#39;:
 919                     reader.scanChar();
 920                     if (reader.ch == &#39;\&#39;&#39;) {
 921                         lexError(pos, Errors.EmptyCharLit);
 922                         reader.scanChar();
 923                     } else {
<a name="28" id="anc28"></a><span class="line-modified"> 924                         if (isEOLN())</span>
 925                             lexError(pos, Errors.IllegalLineEndInCharLit);
<a name="29" id="anc29"></a><span class="line-modified"> 926                         scanLitChar(pos, true, false);</span>
 927                         if (reader.ch == &#39;\&#39;&#39;) {
 928                             reader.scanChar();
 929                             tk = TokenKind.CHARLITERAL;
 930                         } else {
 931                             lexError(pos, Errors.UnclosedCharLit);
 932                         }
 933                     }
 934                     break loop;
 935                 case &#39;\&quot;&#39;:
<a name="30" id="anc30"></a><span class="line-modified"> 936                     scanString(pos);</span>








 937                     break loop;
<a name="31" id="anc31"></a><span class="line-modified"> 938                 default:</span>
 939                     if (isSpecial(reader.ch)) {
 940                         scanOperator();
 941                     } else {
 942                         boolean isJavaIdentifierStart;
 943                         int codePoint = -1;
 944                         if (reader.ch &lt; &#39;\u0080&#39;) {
 945                             // all ASCII range chars already handled, above
 946                             isJavaIdentifierStart = false;
 947                         } else {
 948                             codePoint = reader.peekSurrogates();
 949                             if (codePoint &gt;= 0) {
 950                                 if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {
 951                                     reader.putChar(true);
 952                                 }
 953                             } else {
 954                                 isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);
 955                             }
 956                         }
 957                         if (isJavaIdentifierStart) {
 958                             scanIdent();
 959                         } else if (reader.digit(pos, 10) &gt;= 0) {
 960                             scanNumber(pos, 10);
 961                         } else if (reader.bp == reader.buflen || reader.ch == EOI &amp;&amp; reader.bp + 1 == reader.buflen) { // JLS 3.5
 962                             tk = TokenKind.EOF;
 963                             pos = reader.realLength;
 964                         } else {
 965                             String arg;
 966 
 967                             if (codePoint &gt;= 0) {
 968                                 char high = reader.ch;
 969                                 reader.scanChar();
 970                                 arg = String.format(&quot;\\u%04x\\u%04x&quot;, (int) high, (int)reader.ch);
 971                             } else {
 972                                 arg = (32 &lt; reader.ch &amp;&amp; reader.ch &lt; 127) ?
 973                                                 String.format(&quot;%s&quot;, reader.ch) :
 974                                                 String.format(&quot;\\u%04x&quot;, (int)reader.ch);
 975                             }
 976                             lexError(pos, Errors.IllegalChar(arg));
 977                             reader.scanChar();
 978                         }
 979                     }
 980                     break loop;
 981                 }
 982             }
 983             endPos = reader.bp;
 984             switch (tk.tag) {
 985                 case DEFAULT: return new Token(tk, pos, endPos, comments);
 986                 case NAMED: return new NamedToken(tk, pos, endPos, name, comments);
<a name="32" id="anc32"></a><span class="line-modified"> 987                 case STRING: {</span>
<span class="line-added"> 988                     // Get characters from string buffer.</span>
<span class="line-added"> 989                     String string = reader.chars();</span>
<span class="line-added"> 990                     // If a text block.</span>
<span class="line-added"> 991                     if (isTextBlock &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-added"> 992                         // Verify that the incidental indentation is consistent.</span>
<span class="line-added"> 993                         if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {</span>
<span class="line-added"> 994                             Set&lt;TextBlockSupport.WhitespaceChecks&gt; checks =</span>
<span class="line-added"> 995                                     TextBlockSupport.checkWhitespace(string);</span>
<span class="line-added"> 996                             if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {</span>
<span class="line-added"> 997                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-added"> 998                                         Warnings.InconsistentWhiteSpaceIndentation);</span>
<span class="line-added"> 999                             }</span>
<span class="line-added">1000                             if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {</span>
<span class="line-added">1001                                 lexWarning(LintCategory.TEXT_BLOCKS, pos,</span>
<span class="line-added">1002                                         Warnings.TrailingWhiteSpaceWillBeRemoved);</span>
<span class="line-added">1003                             }</span>
<span class="line-added">1004                         }</span>
<span class="line-added">1005                         // Remove incidental indentation.</span>
<span class="line-added">1006                         try {</span>
<span class="line-added">1007                             string = TextBlockSupport.stripIndent(string);</span>
<span class="line-added">1008                         } catch (Exception ex) {</span>
<span class="line-added">1009                             // Error already reported, just use unstripped string.</span>
<span class="line-added">1010                         }</span>
<span class="line-added">1011                     }</span>
<span class="line-added">1012                     // Translate escape sequences if present.</span>
<span class="line-added">1013                     if (hasEscapeSequences &amp;&amp; TextBlockSupport.hasSupport()) {</span>
<span class="line-added">1014                         try {</span>
<span class="line-added">1015                             string = TextBlockSupport.translateEscapes(string);</span>
<span class="line-added">1016                         } catch (Exception ex) {</span>
<span class="line-added">1017                             // Error already reported, just use untranslated string.</span>
<span class="line-added">1018                         }</span>
<span class="line-added">1019                     }</span>
<span class="line-added">1020                     // Build string token.</span>
<span class="line-added">1021                     return new StringToken(tk, pos, endPos, string, comments);</span>
<span class="line-added">1022                 }</span>
1023                 case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);
1024                 default: throw new AssertionError();
1025             }
1026         }
1027         finally {
1028             if (scannerDebug) {
1029                     System.out.println(&quot;nextToken(&quot; + pos
1030                                        + &quot;,&quot; + endPos + &quot;)=|&quot; +
1031                                        new String(reader.getRawCharacters(pos, endPos))
1032                                        + &quot;|&quot;);
1033             }
1034         }
1035     }
1036     //where
1037         List&lt;Comment&gt; addComment(List&lt;Comment&gt; comments, Comment comment) {
1038             return comments == null ?
1039                     List.of(comment) :
1040                     comments.prepend(comment);
1041         }
1042 
1043     /** Return the position where a lexical error occurred;
1044      */
1045     public int errPos() {
1046         return errPos;
1047     }
1048 
1049     /** Set the position where a lexical error occurred;
1050      */
1051     public void errPos(int pos) {
1052         errPos = pos;
1053     }
1054 
1055     /**
1056      * Called when a complete comment has been scanned. pos and endPos
1057      * will mark the comment boundary.
1058      */
1059     protected Tokens.Comment processComment(int pos, int endPos, CommentStyle style) {
1060         if (scannerDebug)
1061             System.out.println(&quot;processComment(&quot; + pos
1062                                + &quot;,&quot; + endPos + &quot;,&quot; + style + &quot;)=|&quot;
1063                                + new String(reader.getRawCharacters(pos, endPos))
1064                                + &quot;|&quot;);
1065         char[] buf = reader.getRawCharacters(pos, endPos);
1066         return new BasicComment&lt;&gt;(new UnicodeReader(fac, buf, buf.length), style);
1067     }
1068 
1069     /**
1070      * Called when a complete whitespace run has been scanned. pos and endPos
1071      * will mark the whitespace boundary.
1072      */
1073     protected void processWhiteSpace(int pos, int endPos) {
1074         if (scannerDebug)
1075             System.out.println(&quot;processWhitespace(&quot; + pos
1076                                + &quot;,&quot; + endPos + &quot;)=|&quot; +
1077                                new String(reader.getRawCharacters(pos, endPos))
1078                                + &quot;|&quot;);
1079     }
1080 
1081     /**
1082      * Called when a line terminator has been processed.
1083      */
1084     protected void processLineTerminator(int pos, int endPos) {
1085         if (scannerDebug)
1086             System.out.println(&quot;processTerminator(&quot; + pos
1087                                + &quot;,&quot; + endPos + &quot;)=|&quot; +
1088                                new String(reader.getRawCharacters(pos, endPos))
1089                                + &quot;|&quot;);
1090     }
1091 
1092     /** Build a map for translating between line numbers and
1093      * positions in the input.
1094      *
1095      * @return a LineMap */
1096     public Position.LineMap getLineMap() {
1097         return Position.makeLineMap(reader.getRawCharacters(), reader.buflen, false);
1098     }
1099 
1100 
1101     /**
1102     * Scan a documentation comment; determine if a deprecated tag is present.
1103     * Called once the initial /, * have been skipped, positioned at the second *
1104     * (which is treated as the beginning of the first line).
1105     * Stops positioned at the closing &#39;/&#39;.
1106     */
1107     protected static class BasicComment&lt;U extends UnicodeReader&gt; implements Comment {
1108 
1109         CommentStyle cs;
1110         U comment_reader;
1111 
1112         protected boolean deprecatedFlag = false;
1113         protected boolean scanned = false;
1114 
1115         protected BasicComment(U comment_reader, CommentStyle cs) {
1116             this.comment_reader = comment_reader;
1117             this.cs = cs;
1118         }
1119 
1120         public String getText() {
1121             return null;
1122         }
1123 
1124         public int getSourcePos(int pos) {
1125             return -1;
1126         }
1127 
1128         public CommentStyle getStyle() {
1129             return cs;
1130         }
1131 
1132         public boolean isDeprecated() {
1133             if (!scanned &amp;&amp; cs == CommentStyle.JAVADOC) {
1134                 scanDocComment();
1135             }
1136             return deprecatedFlag;
1137         }
1138 
1139         @SuppressWarnings(&quot;fallthrough&quot;)
1140         protected void scanDocComment() {
1141             try {
1142                 boolean deprecatedPrefix = false;
1143 
1144                 comment_reader.bp += 3; // &#39;/**&#39;
1145                 comment_reader.ch = comment_reader.buf[comment_reader.bp];
1146 
1147                 forEachLine:
1148                 while (comment_reader.bp &lt; comment_reader.buflen) {
1149 
1150                     // Skip optional WhiteSpace at beginning of line
1151                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {
1152                         comment_reader.scanCommentChar();
1153                     }
1154 
1155                     // Skip optional consecutive Stars
1156                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == &#39;*&#39;) {
1157                         comment_reader.scanCommentChar();
1158                         if (comment_reader.ch == &#39;/&#39;) {
1159                             return;
1160                         }
1161                     }
1162 
1163                     // Skip optional WhiteSpace after Stars
1164                     while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; (comment_reader.ch == &#39; &#39; || comment_reader.ch == &#39;\t&#39; || comment_reader.ch == FF)) {
1165                         comment_reader.scanCommentChar();
1166                     }
1167 
1168                     deprecatedPrefix = false;
1169                     // At beginning of line in the JavaDoc sense.
1170                     if (!deprecatedFlag) {
1171                         String deprecated = &quot;@deprecated&quot;;
1172                         int i = 0;
1173                         while (comment_reader.bp &lt; comment_reader.buflen &amp;&amp; comment_reader.ch == deprecated.charAt(i)) {
1174                             comment_reader.scanCommentChar();
1175                             i++;
1176                             if (i == deprecated.length()) {
1177                                 deprecatedPrefix = true;
1178                                 break;
1179                             }
1180                         }
1181                     }
1182 
1183                     if (deprecatedPrefix &amp;&amp; comment_reader.bp &lt; comment_reader.buflen) {
1184                         if (Character.isWhitespace(comment_reader.ch)) {
1185                             deprecatedFlag = true;
1186                         } else if (comment_reader.ch == &#39;*&#39;) {
1187                             comment_reader.scanCommentChar();
1188                             if (comment_reader.ch == &#39;/&#39;) {
1189                                 deprecatedFlag = true;
1190                                 return;
1191                             }
1192                         }
1193                     }
1194 
1195                     // Skip rest of line
1196                     while (comment_reader.bp &lt; comment_reader.buflen) {
1197                         switch (comment_reader.ch) {
1198                             case &#39;*&#39;:
1199                                 comment_reader.scanCommentChar();
1200                                 if (comment_reader.ch == &#39;/&#39;) {
1201                                     return;
1202                                 }
1203                                 break;
1204                             case CR: // (Spec 3.4)
1205                                 comment_reader.scanCommentChar();
1206                                 if (comment_reader.ch != LF) {
1207                                     continue forEachLine;
1208                                 }
1209                             /* fall through to LF case */
1210                             case LF: // (Spec 3.4)
1211                                 comment_reader.scanCommentChar();
1212                                 continue forEachLine;
1213                             default:
1214                                 comment_reader.scanCommentChar();
1215                         }
1216                     } // rest of line
1217                 } // forEachLine
1218                 return;
1219             } finally {
1220                 scanned = true;
1221             }
1222         }
1223     }
1224 }
<a name="33" id="anc33"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="33" type="hidden" />
</body>
</html>
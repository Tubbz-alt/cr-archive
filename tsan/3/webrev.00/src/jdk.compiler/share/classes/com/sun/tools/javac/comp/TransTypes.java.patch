diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -565,10 +565,17 @@
         tree.pats = translate(tree.pats, null);
         tree.stats = translate(tree.stats);
         result = tree;
     }
 
+    public void visitBindingPattern(JCBindingPattern tree) {
+        if (tree.vartype != null) {
+            tree.vartype = translate(tree.vartype, null);
+        }
+        result = tree;
+    }
+
     public void visitSwitchExpression(JCSwitchExpression tree) {
         Type selsuper = types.supertype(tree.selector.type);
         boolean enumSwitch = selsuper != null &&
             selsuper.tsym == syms.enumSym;
         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
@@ -618,15 +625,18 @@
         result = tree;
     }
 
     @Override
     public void visitBreak(JCBreak tree) {
-        if (tree.isValueBreak()) {
-            tree.value = translate(tree.value, erasure(tree.value.type));
-            tree.value.type = erasure(tree.value.type);
-            tree.value = retype(tree.value, tree.value.type, pt);
-        }
+        result = tree;
+    }
+
+    @Override
+    public void visitYield(JCYield tree) {
+        tree.value = translate(tree.value, erasure(tree.value.type));
+        tree.value.type = erasure(tree.value.type);
+        tree.value = retype(tree.value, tree.value.type, pt);
         result = tree;
     }
 
     public void visitThrow(JCThrow tree) {
         tree.expr = translate(tree.expr, erasure(tree.expr.type));
@@ -775,11 +785,11 @@
         result = retype(tree, tree.type, pt);
     }
 
     public void visitTypeTest(JCInstanceOf tree) {
         tree.expr = translate(tree.expr, null);
-        tree.clazz = translate(tree.clazz, null);
+        tree.pattern = translate(tree.pattern, null);
         result = tree;
     }
 
     public void visitIndexed(JCArrayAccess tree) {
         tree.indexed = translate(tree.indexed, erasure(tree.indexed.type));

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Resolve.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeDiffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransTypes.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
550             returnType = prevRetType;
551         }
552     }
553 
554     public void visitSwitch(JCSwitch tree) {
555         Type selsuper = types.supertype(tree.selector.type);
556         boolean enumSwitch = selsuper != null &amp;&amp;
557             selsuper.tsym == syms.enumSym;
558         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
559         tree.selector = translate(tree.selector, target);
560         tree.cases = translateCases(tree.cases);
561         result = tree;
562     }
563 
564     public void visitCase(JCCase tree) {
565         tree.pats = translate(tree.pats, null);
566         tree.stats = translate(tree.stats);
567         result = tree;
568     }
569 







570     public void visitSwitchExpression(JCSwitchExpression tree) {
571         Type selsuper = types.supertype(tree.selector.type);
572         boolean enumSwitch = selsuper != null &amp;&amp;
573             selsuper.tsym == syms.enumSym;
574         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
575         tree.selector = translate(tree.selector, target);
576         tree.cases = translate(tree.cases);
577         tree.type = erasure(tree.type);
578         result = retype(tree, tree.type, pt);
579     }
580 
581     public void visitSynchronized(JCSynchronized tree) {
582         tree.lock = translate(tree.lock, erasure(tree.lock.type));
583         tree.body = translate(tree.body);
584         result = tree;
585     }
586 
587     public void visitTry(JCTry tree) {
588         tree.resources = translate(tree.resources, syms.autoCloseableType);
589         tree.body = translate(tree.body);
</pre>
<hr />
<pre>
603    public void visitIf(JCIf tree) {
604         tree.cond = translate(tree.cond, syms.booleanType);
605         tree.thenpart = translate(tree.thenpart);
606         tree.elsepart = translate(tree.elsepart);
607         result = tree;
608     }
609 
610     public void visitExec(JCExpressionStatement tree) {
611         tree.expr = translate(tree.expr, null);
612         result = tree;
613     }
614 
615     public void visitReturn(JCReturn tree) {
616         if (!returnType.hasTag(VOID))
617             tree.expr = translate(tree.expr, returnType);
618         result = tree;
619     }
620 
621     @Override
622     public void visitBreak(JCBreak tree) {
<span class="line-modified">623         if (tree.isValueBreak()) {</span>
<span class="line-modified">624             tree.value = translate(tree.value, erasure(tree.value.type));</span>
<span class="line-modified">625             tree.value.type = erasure(tree.value.type);</span>
<span class="line-modified">626             tree.value = retype(tree.value, tree.value.type, pt);</span>
<span class="line-modified">627         }</span>



628         result = tree;
629     }
630 
631     public void visitThrow(JCThrow tree) {
632         tree.expr = translate(tree.expr, erasure(tree.expr.type));
633         result = tree;
634     }
635 
636     public void visitAssert(JCAssert tree) {
637         tree.cond = translate(tree.cond, syms.booleanType);
638         if (tree.detail != null)
639             tree.detail = translate(tree.detail, erasure(tree.detail.type));
640         result = tree;
641     }
642 
643     public void visitApply(JCMethodInvocation tree) {
644         tree.meth = translate(tree.meth, null);
645         Symbol meth = TreeInfo.symbol(tree.meth);
646         Type mt = meth.erasure(types);
647         boolean useInstantiatedPtArgs =
</pre>
<hr />
<pre>
760                 ? (JCTypeCast) newExpression
761                 : null;
762             tree.expr = typeCast != null &amp;&amp; types.isSameType(typeCast.type, originalTarget)
763                 ? typeCast.expr
764                 : newExpression;
765         }
766         if (originalTarget.isIntersection()) {
767             Type.IntersectionClassType ict = (Type.IntersectionClassType)originalTarget;
768             for (Type c : ict.getExplicitComponents()) {
769                 Type ec = erasure(c);
770                 if (!types.isSameType(ec, tree.type)) {
771                     tree.expr = coerce(tree.expr, ec);
772                 }
773             }
774         }
775         result = retype(tree, tree.type, pt);
776     }
777 
778     public void visitTypeTest(JCInstanceOf tree) {
779         tree.expr = translate(tree.expr, null);
<span class="line-modified">780         tree.clazz = translate(tree.clazz, null);</span>
781         result = tree;
782     }
783 
784     public void visitIndexed(JCArrayAccess tree) {
785         tree.indexed = translate(tree.indexed, erasure(tree.indexed.type));
786         tree.index = translate(tree.index, syms.intType);
787 
788         // Insert casts of indexed expressions as needed.
789         result = retype(tree, types.elemtype(tree.indexed.type), pt);
790     }
791 
792     // There ought to be nothing to rewrite here;
793     // we don&#39;t generate code.
794     public void visitAnnotation(JCAnnotation tree) {
795         result = tree;
796     }
797 
798     public void visitIdent(JCIdent tree) {
799         Type et = tree.sym.erasure(types);
800 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
550             returnType = prevRetType;
551         }
552     }
553 
554     public void visitSwitch(JCSwitch tree) {
555         Type selsuper = types.supertype(tree.selector.type);
556         boolean enumSwitch = selsuper != null &amp;&amp;
557             selsuper.tsym == syms.enumSym;
558         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
559         tree.selector = translate(tree.selector, target);
560         tree.cases = translateCases(tree.cases);
561         result = tree;
562     }
563 
564     public void visitCase(JCCase tree) {
565         tree.pats = translate(tree.pats, null);
566         tree.stats = translate(tree.stats);
567         result = tree;
568     }
569 
<span class="line-added">570     public void visitBindingPattern(JCBindingPattern tree) {</span>
<span class="line-added">571         if (tree.vartype != null) {</span>
<span class="line-added">572             tree.vartype = translate(tree.vartype, null);</span>
<span class="line-added">573         }</span>
<span class="line-added">574         result = tree;</span>
<span class="line-added">575     }</span>
<span class="line-added">576 </span>
577     public void visitSwitchExpression(JCSwitchExpression tree) {
578         Type selsuper = types.supertype(tree.selector.type);
579         boolean enumSwitch = selsuper != null &amp;&amp;
580             selsuper.tsym == syms.enumSym;
581         Type target = enumSwitch ? erasure(tree.selector.type) : syms.intType;
582         tree.selector = translate(tree.selector, target);
583         tree.cases = translate(tree.cases);
584         tree.type = erasure(tree.type);
585         result = retype(tree, tree.type, pt);
586     }
587 
588     public void visitSynchronized(JCSynchronized tree) {
589         tree.lock = translate(tree.lock, erasure(tree.lock.type));
590         tree.body = translate(tree.body);
591         result = tree;
592     }
593 
594     public void visitTry(JCTry tree) {
595         tree.resources = translate(tree.resources, syms.autoCloseableType);
596         tree.body = translate(tree.body);
</pre>
<hr />
<pre>
610    public void visitIf(JCIf tree) {
611         tree.cond = translate(tree.cond, syms.booleanType);
612         tree.thenpart = translate(tree.thenpart);
613         tree.elsepart = translate(tree.elsepart);
614         result = tree;
615     }
616 
617     public void visitExec(JCExpressionStatement tree) {
618         tree.expr = translate(tree.expr, null);
619         result = tree;
620     }
621 
622     public void visitReturn(JCReturn tree) {
623         if (!returnType.hasTag(VOID))
624             tree.expr = translate(tree.expr, returnType);
625         result = tree;
626     }
627 
628     @Override
629     public void visitBreak(JCBreak tree) {
<span class="line-modified">630         result = tree;</span>
<span class="line-modified">631     }</span>
<span class="line-modified">632 </span>
<span class="line-modified">633     @Override</span>
<span class="line-modified">634     public void visitYield(JCYield tree) {</span>
<span class="line-added">635         tree.value = translate(tree.value, erasure(tree.value.type));</span>
<span class="line-added">636         tree.value.type = erasure(tree.value.type);</span>
<span class="line-added">637         tree.value = retype(tree.value, tree.value.type, pt);</span>
638         result = tree;
639     }
640 
641     public void visitThrow(JCThrow tree) {
642         tree.expr = translate(tree.expr, erasure(tree.expr.type));
643         result = tree;
644     }
645 
646     public void visitAssert(JCAssert tree) {
647         tree.cond = translate(tree.cond, syms.booleanType);
648         if (tree.detail != null)
649             tree.detail = translate(tree.detail, erasure(tree.detail.type));
650         result = tree;
651     }
652 
653     public void visitApply(JCMethodInvocation tree) {
654         tree.meth = translate(tree.meth, null);
655         Symbol meth = TreeInfo.symbol(tree.meth);
656         Type mt = meth.erasure(types);
657         boolean useInstantiatedPtArgs =
</pre>
<hr />
<pre>
770                 ? (JCTypeCast) newExpression
771                 : null;
772             tree.expr = typeCast != null &amp;&amp; types.isSameType(typeCast.type, originalTarget)
773                 ? typeCast.expr
774                 : newExpression;
775         }
776         if (originalTarget.isIntersection()) {
777             Type.IntersectionClassType ict = (Type.IntersectionClassType)originalTarget;
778             for (Type c : ict.getExplicitComponents()) {
779                 Type ec = erasure(c);
780                 if (!types.isSameType(ec, tree.type)) {
781                     tree.expr = coerce(tree.expr, ec);
782                 }
783             }
784         }
785         result = retype(tree, tree.type, pt);
786     }
787 
788     public void visitTypeTest(JCInstanceOf tree) {
789         tree.expr = translate(tree.expr, null);
<span class="line-modified">790         tree.pattern = translate(tree.pattern, null);</span>
791         result = tree;
792     }
793 
794     public void visitIndexed(JCArrayAccess tree) {
795         tree.indexed = translate(tree.indexed, erasure(tree.indexed.type));
796         tree.index = translate(tree.index, syms.intType);
797 
798         // Insert casts of indexed expressions as needed.
799         result = retype(tree, types.elemtype(tree.indexed.type), pt);
800     }
801 
802     // There ought to be nothing to rewrite here;
803     // we don&#39;t generate code.
804     public void visitAnnotation(JCAnnotation tree) {
805         result = tree;
806     }
807 
808     public void visitIdent(JCIdent tree) {
809         Type et = tree.sym.erasure(types);
810 
</pre>
</td>
</tr>
</table>
<center><a href="Resolve.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeDiffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
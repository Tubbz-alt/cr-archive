<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/file/BaseFileManager.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CacheFSInfo.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/file/BaseFileManager.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.lang.ref.SoftReference;
 31 import java.lang.reflect.Constructor;
 32 import java.lang.reflect.InvocationTargetException;
 33 import java.lang.reflect.Method;
 34 import java.net.URL;
 35 import java.net.URLClassLoader;
 36 import java.nio.ByteBuffer;
 37 import java.nio.CharBuffer;
 38 import java.nio.charset.Charset;
 39 import java.nio.charset.CharsetDecoder;
 40 import java.nio.charset.CoderResult;
 41 import java.nio.charset.CodingErrorAction;
 42 import java.nio.charset.IllegalCharsetNameException;
 43 import java.nio.charset.UnsupportedCharsetException;
 44 import java.nio.file.Path;
 45 import java.util.Collection;
 46 import java.util.HashMap;

 47 import java.util.Iterator;
 48 import java.util.Map;
 49 import java.util.Objects;
 50 import java.util.Set;
 51 
 52 import javax.tools.JavaFileManager;
 53 import javax.tools.JavaFileObject;
 54 import javax.tools.JavaFileObject.Kind;
 55 
 56 import com.sun.tools.javac.main.Option;
 57 import com.sun.tools.javac.main.OptionHelper;
 58 import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
 59 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 60 import com.sun.tools.javac.util.Abort;
 61 import com.sun.tools.javac.util.Context;
 62 import com.sun.tools.javac.util.DefinedBy;
 63 import com.sun.tools.javac.util.DefinedBy.Api;
 64 import com.sun.tools.javac.util.Log;
 65 import com.sun.tools.javac.util.Options;
 66 
 67 /**
<span class="line-modified"> 68  * Utility methods for building a filemanager.</span>
 69  * There are no references here to file-system specific objects such as
 70  * java.io.File or java.nio.file.Path.
 71  */
 72 public abstract class BaseFileManager implements JavaFileManager {
 73     protected BaseFileManager(Charset charset) {
 74         this.charset = charset;
 75         byteBufferCache = new ByteBufferCache();
 76         locations = createLocations();
 77     }
 78 
 79     /**
 80      * Set the context for JavacPathFileManager.
 81      * @param context the context containing items to be associated with the file manager
 82      */
 83     public void setContext(Context context) {
 84         log = Log.instance(context);
 85         options = Options.instance(context);
 86         classLoaderClass = options.get(&quot;procloader&quot;);
 87 
 88         // Avoid initializing Lint
 89         boolean warn = options.isLintSet(&quot;path&quot;);
 90         locations.update(log, warn, FSInfo.instance(context));
 91 
 92         // Setting this option is an indication that close() should defer actually closing
 93         // the file manager until after a specified period of inactivity.
<span class="line-modified"> 94         // This is to accomodate clients which save references to Symbols created for use</span>
 95         // within doclets or annotation processors, and which then attempt to use those
 96         // references after the tool exits, having closed any internally managed file manager.
 97         // Ideally, such clients should run the tool via the javax.tools API, providing their
 98         // own file manager, which can be closed by the client when all use of that file
 99         // manager is complete.
100         // If the option has a numeric value, it will be interpreted as the duration,
101         // in seconds, of the period of inactivity to wait for, before the file manager
102         // is actually closed.
103         // See also deferredClose().
104         String s = options.get(&quot;fileManager.deferClose&quot;);
105         if (s != null) {
106             try {
107                 deferredCloseTimeout = (int) (Float.parseFloat(s) * 1000);
108             } catch (NumberFormatException e) {
109                 deferredCloseTimeout = 60 * 1000;  // default: one minute, in millis
110             }
111         }
112     }
113 
114     protected Locations createLocations() {
</pre>
<hr />
<pre>
156                         close();
157                     }
158                 } catch (InterruptedException e) {
159                 } catch (IOException e) {
160                 }
161             }
162         };
163         t.setDaemon(true);
164         t.start();
165     }
166 
167     synchronized void updateLastUsedTime() {
168         if (deferredCloseTimeout &gt; 0) { // avoid updating the time unnecessarily
169             lastUsedTime = System.currentTimeMillis();
170         }
171     }
172 
173     private long lastUsedTime = System.currentTimeMillis();
174     protected long deferredCloseTimeout = 0;
175 




176     protected ClassLoader getClassLoader(URL[] urls) {
177         ClassLoader thisClassLoader = getClass().getClassLoader();
178 
179         // Allow the following to specify a closeable classloader
180         // other than URLClassLoader.
181 
182         // 1: Allow client to specify the class to use via hidden option
183         if (classLoaderClass != null) {
184             try {
185                 Class&lt;? extends ClassLoader&gt; loader =
186                         Class.forName(classLoaderClass).asSubclass(ClassLoader.class);
187                 Class&lt;?&gt;[] constrArgTypes = { URL[].class, ClassLoader.class };
188                 Constructor&lt;? extends ClassLoader&gt; constr = loader.getConstructor(constrArgTypes);
189                 return constr.newInstance(urls, thisClassLoader);
190             } catch (ReflectiveOperationException t) {
191                 // ignore errors loading user-provided class loader, fall through
192             }
193         }
194         return new URLClassLoader(urls, thisClassLoader);
195     }
196 
197     public boolean isDefaultBootClassPath() {
198         return locations.isDefaultBootClassPath();
199     }
200 




201     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Option handling&quot;&gt;
202     @Override @DefinedBy(Api.COMPILER)
203     public boolean handleOption(String current, Iterator&lt;String&gt; remaining) {
204         OptionHelper helper = new GrumpyHelper(log) {
205             @Override
206             public String get(Option option) {
207                 return options.get(option);
208             }
209 
210             @Override
211             public void put(String name, String value) {
212                 options.put(name, value);
213             }
214 
215             @Override
216             public void remove(String name) {
217                 options.remove(name);
218             }
219 
220             @Override
221             public boolean handleFileManagerOption(Option option, String value) {
222                 return handleOption(option, value);
223             }
224         };
225 
226         Option o = Option.lookup(current, javacFileManagerOptions);
227         if (o == null) {
228             return false;
229         }
230 
231         try {
232             o.handleOption(helper, current, remaining);
233         } catch (Option.InvalidValueException e) {
234             throw new IllegalArgumentException(e.getMessage(), e);
235         }
236 
237         return true;
238     }
239     // where
<span class="line-modified">240         private static final Set&lt;Option&gt; javacFileManagerOptions =</span>
241             Option.getJavacFileManagerOptions();
242 
243     @Override @DefinedBy(Api.COMPILER)
244     public int isSupportedOption(String option) {
245         Option o = Option.lookup(option, javacFileManagerOptions);
246         return (o == null) ? -1 : o.hasArg() ? 1 : 0;
247     }
248 
249     protected String multiReleaseValue;
250 
251     /**
252      * Common back end for OptionHelper handleFileManagerOption.
253      * @param option the option whose value to be set
254      * @param value the value for the option
255      * @return true if successful, and false otherwise
256      */
257     public boolean handleOption(Option option, String value) {
258         switch (option) {
259             case ENCODING:
260                 encodingName = value;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 27 
 28 import java.io.IOException;
 29 import java.io.InputStream;
 30 import java.lang.ref.SoftReference;
 31 import java.lang.reflect.Constructor;
 32 import java.lang.reflect.InvocationTargetException;
 33 import java.lang.reflect.Method;
 34 import java.net.URL;
 35 import java.net.URLClassLoader;
 36 import java.nio.ByteBuffer;
 37 import java.nio.CharBuffer;
 38 import java.nio.charset.Charset;
 39 import java.nio.charset.CharsetDecoder;
 40 import java.nio.charset.CoderResult;
 41 import java.nio.charset.CodingErrorAction;
 42 import java.nio.charset.IllegalCharsetNameException;
 43 import java.nio.charset.UnsupportedCharsetException;
 44 import java.nio.file.Path;
 45 import java.util.Collection;
 46 import java.util.HashMap;
<span class="line-added"> 47 import java.util.HashSet;</span>
 48 import java.util.Iterator;
 49 import java.util.Map;
 50 import java.util.Objects;
 51 import java.util.Set;
 52 
 53 import javax.tools.JavaFileManager;
 54 import javax.tools.JavaFileObject;
 55 import javax.tools.JavaFileObject.Kind;
 56 
 57 import com.sun.tools.javac.main.Option;
 58 import com.sun.tools.javac.main.OptionHelper;
 59 import com.sun.tools.javac.main.OptionHelper.GrumpyHelper;
 60 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 61 import com.sun.tools.javac.util.Abort;
 62 import com.sun.tools.javac.util.Context;
 63 import com.sun.tools.javac.util.DefinedBy;
 64 import com.sun.tools.javac.util.DefinedBy.Api;
 65 import com.sun.tools.javac.util.Log;
 66 import com.sun.tools.javac.util.Options;
 67 
 68 /**
<span class="line-modified"> 69  * Utility methods for building a file manager.</span>
 70  * There are no references here to file-system specific objects such as
 71  * java.io.File or java.nio.file.Path.
 72  */
 73 public abstract class BaseFileManager implements JavaFileManager {
 74     protected BaseFileManager(Charset charset) {
 75         this.charset = charset;
 76         byteBufferCache = new ByteBufferCache();
 77         locations = createLocations();
 78     }
 79 
 80     /**
 81      * Set the context for JavacPathFileManager.
 82      * @param context the context containing items to be associated with the file manager
 83      */
 84     public void setContext(Context context) {
 85         log = Log.instance(context);
 86         options = Options.instance(context);
 87         classLoaderClass = options.get(&quot;procloader&quot;);
 88 
 89         // Avoid initializing Lint
 90         boolean warn = options.isLintSet(&quot;path&quot;);
 91         locations.update(log, warn, FSInfo.instance(context));
 92 
 93         // Setting this option is an indication that close() should defer actually closing
 94         // the file manager until after a specified period of inactivity.
<span class="line-modified"> 95         // This is to accommodate clients which save references to Symbols created for use</span>
 96         // within doclets or annotation processors, and which then attempt to use those
 97         // references after the tool exits, having closed any internally managed file manager.
 98         // Ideally, such clients should run the tool via the javax.tools API, providing their
 99         // own file manager, which can be closed by the client when all use of that file
100         // manager is complete.
101         // If the option has a numeric value, it will be interpreted as the duration,
102         // in seconds, of the period of inactivity to wait for, before the file manager
103         // is actually closed.
104         // See also deferredClose().
105         String s = options.get(&quot;fileManager.deferClose&quot;);
106         if (s != null) {
107             try {
108                 deferredCloseTimeout = (int) (Float.parseFloat(s) * 1000);
109             } catch (NumberFormatException e) {
110                 deferredCloseTimeout = 60 * 1000;  // default: one minute, in millis
111             }
112         }
113     }
114 
115     protected Locations createLocations() {
</pre>
<hr />
<pre>
157                         close();
158                     }
159                 } catch (InterruptedException e) {
160                 } catch (IOException e) {
161                 }
162             }
163         };
164         t.setDaemon(true);
165         t.start();
166     }
167 
168     synchronized void updateLastUsedTime() {
169         if (deferredCloseTimeout &gt; 0) { // avoid updating the time unnecessarily
170             lastUsedTime = System.currentTimeMillis();
171         }
172     }
173 
174     private long lastUsedTime = System.currentTimeMillis();
175     protected long deferredCloseTimeout = 0;
176 
<span class="line-added">177     public void clear() {</span>
<span class="line-added">178         new HashSet&lt;&gt;(options.keySet()).forEach(k -&gt; options.remove(k));</span>
<span class="line-added">179     }</span>
<span class="line-added">180 </span>
181     protected ClassLoader getClassLoader(URL[] urls) {
182         ClassLoader thisClassLoader = getClass().getClassLoader();
183 
184         // Allow the following to specify a closeable classloader
185         // other than URLClassLoader.
186 
187         // 1: Allow client to specify the class to use via hidden option
188         if (classLoaderClass != null) {
189             try {
190                 Class&lt;? extends ClassLoader&gt; loader =
191                         Class.forName(classLoaderClass).asSubclass(ClassLoader.class);
192                 Class&lt;?&gt;[] constrArgTypes = { URL[].class, ClassLoader.class };
193                 Constructor&lt;? extends ClassLoader&gt; constr = loader.getConstructor(constrArgTypes);
194                 return constr.newInstance(urls, thisClassLoader);
195             } catch (ReflectiveOperationException t) {
196                 // ignore errors loading user-provided class loader, fall through
197             }
198         }
199         return new URLClassLoader(urls, thisClassLoader);
200     }
201 
202     public boolean isDefaultBootClassPath() {
203         return locations.isDefaultBootClassPath();
204     }
205 
<span class="line-added">206     public boolean isDefaultSystemModulesPath() {</span>
<span class="line-added">207         return locations.isDefaultSystemModulesPath();</span>
<span class="line-added">208     }</span>
<span class="line-added">209 </span>
210     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Option handling&quot;&gt;
211     @Override @DefinedBy(Api.COMPILER)
212     public boolean handleOption(String current, Iterator&lt;String&gt; remaining) {
213         OptionHelper helper = new GrumpyHelper(log) {
214             @Override
215             public String get(Option option) {
216                 return options.get(option);
217             }
218 
219             @Override
220             public void put(String name, String value) {
221                 options.put(name, value);
222             }
223 
224             @Override
225             public void remove(String name) {
226                 options.remove(name);
227             }
228 
229             @Override
230             public boolean handleFileManagerOption(Option option, String value) {
231                 return handleOption(option, value);
232             }
233         };
234 
235         Option o = Option.lookup(current, javacFileManagerOptions);
236         if (o == null) {
237             return false;
238         }
239 
240         try {
241             o.handleOption(helper, current, remaining);
242         } catch (Option.InvalidValueException e) {
243             throw new IllegalArgumentException(e.getMessage(), e);
244         }
245 
246         return true;
247     }
248     // where
<span class="line-modified">249         protected static final Set&lt;Option&gt; javacFileManagerOptions =</span>
250             Option.getJavacFileManagerOptions();
251 
252     @Override @DefinedBy(Api.COMPILER)
253     public int isSupportedOption(String option) {
254         Option o = Option.lookup(option, javacFileManagerOptions);
255         return (o == null) ? -1 : o.hasArg() ? 1 : 0;
256     }
257 
258     protected String multiReleaseValue;
259 
260     /**
261      * Common back end for OptionHelper handleFileManagerOption.
262      * @param option the option whose value to be set
263      * @param value the value for the option
264      * @return true if successful, and false otherwise
265      */
266     public boolean handleOption(Option option, String value) {
267         switch (option) {
268             case ENCODING:
269                 encodingName = value;
</pre>
</td>
</tr>
</table>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CacheFSInfo.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
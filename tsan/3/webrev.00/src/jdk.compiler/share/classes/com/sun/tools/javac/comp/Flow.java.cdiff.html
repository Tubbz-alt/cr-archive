<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Enter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Infer.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  package com.sun.tools.javac.comp;
  
  import java.util.HashMap;
  import java.util.HashSet;
  import java.util.Set;
<span class="line-added">+ import java.util.stream.Collectors;</span>
  
  import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  import com.sun.tools.javac.code.*;
  import com.sun.tools.javac.code.Scope.WriteableScope;
  import com.sun.tools.javac.code.Source.Feature;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,11 ***</span>
   *
   *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
   *  return statement&quot; iff V is DA before the return statement or V is
   *  DA at the end of any intervening finally block.  Note that we
   *  don&#39;t have to worry about the return expression because this
<span class="line-modified">!  *  concept is only used for construcrors.</span>
   *
   *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
   *  assigned at the end of a constructor, which is needed for final
   *  fields (8.3.1.2).  We implement the rule that V is DA at the end
   *  of the constructor iff it is DA and the end of the body of the
<span class="line-new-header">--- 135,11 ---</span>
   *
   *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
   *  return statement&quot; iff V is DA before the return statement or V is
   *  DA at the end of any intervening finally block.  Note that we
   *  don&#39;t have to worry about the return expression because this
<span class="line-modified">!  *  concept is only used for constructors.</span>
   *
   *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
   *  assigned at the end of a constructor, which is needed for final
   *  fields (8.3.1.2).  We implement the rule that V is DA at the end
   *  of the constructor iff it is DA and the end of the body of the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,11 ***</span>
  
      public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
          Log.DiagnosticHandler diagHandler = null;
          //we need to disable diagnostics temporarily; the problem is that if
          //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified">!         //message will be reported and will cause compilation to skip the flow analyis</span>
          //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
          //related errors, which will allow for more errors to be detected
          if (!speculative) {
              diagHandler = new Log.DiscardDiagnosticHandler(log);
          }
<span class="line-new-header">--- 221,11 ---</span>
  
      public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
          Log.DiagnosticHandler diagHandler = null;
          //we need to disable diagnostics temporarily; the problem is that if
          //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified">!         //message will be reported and will cause compilation to skip the flow analysis</span>
          //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
          //related errors, which will allow for more errors to be detected
          if (!speculative) {
              diagHandler = new Log.DiscardDiagnosticHandler(log);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 239,11 ***</span>
  
      public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
              JCLambda that, TreeMaker make) {
          //we need to disable diagnostics temporarily; the problem is that if
          //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified">!         //message will be reported and will cause compilation to skip the flow analyis</span>
          //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
          //related errors, which will allow for more errors to be detected
          Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
          try {
              new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
<span class="line-new-header">--- 240,11 ---</span>
  
      public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
              JCLambda that, TreeMaker make) {
          //we need to disable diagnostics temporarily; the problem is that if
          //a lambda expression contains e.g. an unreachable statement, an error
<span class="line-modified">!         //message will be reported and will cause compilation to skip the flow analysis</span>
          //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
          //related errors, which will allow for more errors to be detected
          Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
          try {
              new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,10 ***</span>
<span class="line-new-header">--- 254,44 ---</span>
          } finally {
              log.popDiagnosticHandler(diagHandler);
          }
      }
  
<span class="line-added">+     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {</span>
<span class="line-added">+         //we need to disable diagnostics temporarily; the problem is that if</span>
<span class="line-added">+         //&quot;that&quot; contains e.g. an unreachable statement, an error</span>
<span class="line-added">+         //message will be reported and will cause compilation to skip the flow analysis</span>
<span class="line-added">+         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis</span>
<span class="line-added">+         //related errors, which will allow for more errors to be detected</span>
<span class="line-added">+         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();</span>
<span class="line-added">+ </span>
<span class="line-added">+             analyzer.analyzeTree(env, that, make);</span>
<span class="line-added">+             return analyzer.isAlive();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             log.popDiagnosticHandler(diagHandler);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {</span>
<span class="line-added">+         //we need to disable diagnostics temporarily; the problem is that if</span>
<span class="line-added">+         //&quot;that&quot; contains e.g. an unreachable statement, an error</span>
<span class="line-added">+         //message will be reported and will cause compilation to skip the flow analysis</span>
<span class="line-added">+         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis</span>
<span class="line-added">+         //related errors, which will allow for more errors to be detected</span>
<span class="line-added">+         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();</span>
<span class="line-added">+ </span>
<span class="line-added">+             analyzer.analyzeTree(env, body, make);</span>
<span class="line-added">+             return analyzer.breaksOut();</span>
<span class="line-added">+         } finally {</span>
<span class="line-added">+             log.popDiagnosticHandler(diagHandler);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Definite assignment scan mode
       */
      enum FlowKind {
          /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 312,10 ***</span>
<span class="line-new-header">--- 347,16 ---</span>
              CONTINUE(JCTree.Tag.CONTINUE) {
                  @Override
                  JCTree getTarget(JCTree tree) {
                      return ((JCContinue)tree).target;
                  }
<span class="line-added">+             },</span>
<span class="line-added">+             YIELD(JCTree.Tag.YIELD) {</span>
<span class="line-added">+                 @Override</span>
<span class="line-added">+                 JCTree getTarget(JCTree tree) {</span>
<span class="line-added">+                     return ((JCYield)tree).target;</span>
<span class="line-added">+                 }</span>
              };
  
              final JCTree.Tag treeTag;
  
              private JumpKind(Tag treeTag) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 384,10 ***</span>
<span class="line-new-header">--- 425,15 ---</span>
          /** Resolve all breaks of this statement. */
          Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
              return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
          }
  
<span class="line-added">+         /** Resolve all yields of this statement. */</span>
<span class="line-added">+         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {</span>
<span class="line-added">+             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          @Override
          public void scan(JCTree tree) {
              if (tree != null &amp;&amp; (
                      tree.type == null ||
                      tree.type != Type.stuckType)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 398,13 ***</span>
          public void visitPackageDef(JCPackageDecl tree) {
              // Do nothing for PackageDecl
          }
  
          protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
<span class="line-modified">!             JCBreak brk = make.at(Position.NOPOS).Break(null);</span>
<span class="line-modified">!             brk.target = swtch;</span>
<span class="line-modified">!             scan(brk);</span>
          }
      }
  
      /**
       * This pass implements the first step of the dataflow analysis, namely
<span class="line-new-header">--- 444,19 ---</span>
          public void visitPackageDef(JCPackageDecl tree) {
              // Do nothing for PackageDecl
          }
  
          protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
<span class="line-modified">!             if (swtch.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-modified">!                 JCYield brk = make.at(Position.NOPOS).Yield(null);</span>
<span class="line-modified">!                 brk.target = swtch;</span>
<span class="line-added">+                 scan(brk);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 JCBreak brk = make.at(Position.NOPOS).Break(null);</span>
<span class="line-added">+                 brk.target = swtch;</span>
<span class="line-added">+                 scan(brk);</span>
<span class="line-added">+             }</span>
          }
      }
  
      /**
       * This pass implements the first step of the dataflow analysis, namely
</pre>
<hr />
<pre>
<span class="line-old-header">*** 506,20 ***</span>
              Assert.check(pendingExits.isEmpty());
  
              try {
                  alive = Liveness.ALIVE;
                  scanStat(tree.body);
  
                  if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
                      log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
  
                  List&lt;PendingExit&gt; exits = pendingExits.toList();
                  pendingExits = new ListBuffer&lt;&gt;();
                  while (exits.nonEmpty()) {
                      PendingExit exit = exits.head;
                      exits = exits.tail;
<span class="line-modified">!                     Assert.check(exit.tree.hasTag(RETURN));</span>
                  }
              } finally {
                  lint = lintPrev;
              }
          }
<span class="line-new-header">--- 558,22 ---</span>
              Assert.check(pendingExits.isEmpty());
  
              try {
                  alive = Liveness.ALIVE;
                  scanStat(tree.body);
<span class="line-added">+                 tree.completesNormally = alive != Liveness.DEAD;</span>
  
                  if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
                      log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
  
                  List&lt;PendingExit&gt; exits = pendingExits.toList();
                  pendingExits = new ListBuffer&lt;&gt;();
                  while (exits.nonEmpty()) {
                      PendingExit exit = exits.head;
                      exits = exits.tail;
<span class="line-modified">!                     Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added">+                                     log.hasErrorOn(exit.tree.pos()));</span>
                  }
              } finally {
                  lint = lintPrev;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 675,11 ***</span>
              }
              if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
                  log.error(tree, Errors.NotExhaustive);
              }
              alive = prevAlive;
<span class="line-modified">!             alive = alive.or(resolveBreaks(tree, prevPendingExits));</span>
          }
  
          public void visitTry(JCTry tree) {
              ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
              pendingExits = new ListBuffer&lt;&gt;();
<span class="line-new-header">--- 729,11 ---</span>
              }
              if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
                  log.error(tree, Errors.NotExhaustive);
              }
              alive = prevAlive;
<span class="line-modified">!             alive = alive.or(resolveYields(tree, prevPendingExits));</span>
          }
  
          public void visitTry(JCTry tree) {
              ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
              pendingExits = new ListBuffer&lt;&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 743,12 ***</span>
                  alive = Liveness.ALIVE;
              }
          }
  
          public void visitBreak(JCBreak tree) {
<span class="line-modified">!             if (tree.isValueBreak())</span>
<span class="line-modified">!                 scan(tree.value);</span>
              recordExit(new PendingExit(tree));
          }
  
          public void visitContinue(JCContinue tree) {
              recordExit(new PendingExit(tree));
<span class="line-new-header">--- 797,16 ---</span>
                  alive = Liveness.ALIVE;
              }
          }
  
          public void visitBreak(JCBreak tree) {
<span class="line-modified">!             recordExit(new PendingExit(tree));</span>
<span class="line-modified">!         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitYield(JCYield tree) {</span>
<span class="line-added">+             scan(tree.value);</span>
              recordExit(new PendingExit(tree));
          }
  
          public void visitContinue(JCContinue tree) {
              recordExit(new PendingExit(tree));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1030,11 ***</span>
                  pendingExits = new ListBuffer&lt;&gt;();
                  while (exits.nonEmpty()) {
                      PendingExit exit = exits.head;
                      exits = exits.tail;
                      if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">!                         Assert.check(exit.tree.hasTag(RETURN));</span>
                      } else {
                          // uncaught throws will be reported later
                          pendingExits.append(exit);
                      }
                  }
<span class="line-new-header">--- 1088,12 ---</span>
                  pendingExits = new ListBuffer&lt;&gt;();
                  while (exits.nonEmpty()) {
                      PendingExit exit = exits.head;
                      exits = exits.tail;
                      if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">!                         Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added">+                                          log.hasErrorOn(exit.tree.pos()));</span>
                      } else {
                          // uncaught throws will be reported later
                          pendingExits.append(exit);
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1124,11 ***</span>
              for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
                  JCCase c = l.head;
                  scan(c.pats);
                  scan(c.stats);
              }
<span class="line-modified">!             resolveBreaks(tree, prevPendingExits);</span>
          }
  
          public void visitTry(JCTry tree) {
              List&lt;Type&gt; caughtPrev = caught;
              List&lt;Type&gt; thrownPrev = thrown;
<span class="line-new-header">--- 1183,15 ---</span>
              for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
                  JCCase c = l.head;
                  scan(c.pats);
                  scan(c.stats);
              }
<span class="line-modified">!             if (tree.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-added">+                 resolveYields(tree, prevPendingExits);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 resolveBreaks(tree, prevPendingExits);</span>
<span class="line-added">+             }</span>
          }
  
          public void visitTry(JCTry tree) {
              List&lt;Type&gt; caughtPrev = caught;
              List&lt;Type&gt; thrownPrev = thrown;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1245,11 ***</span>
                      !isExceptionOrThrowable(exc) &amp;&amp;
                      !chk.intersects(exc, thrownInTry)) {
                  log.error(pos, Errors.ExceptNeverThrownInTry(exc));
              } else {
                  List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
<span class="line-modified">!                 // &#39;catchableThrownTypes&#39; cannnot possibly be empty - if &#39;exc&#39; was an</span>
                  // unchecked exception, the result list would not be empty, as the augmented
                  // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
                  // exception, that would have been covered in the branch above
                  if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
                          !isExceptionOrThrowable(exc)) {
<span class="line-new-header">--- 1308,11 ---</span>
                      !isExceptionOrThrowable(exc) &amp;&amp;
                      !chk.intersects(exc, thrownInTry)) {
                  log.error(pos, Errors.ExceptNeverThrownInTry(exc));
              } else {
                  List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
<span class="line-modified">!                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an</span>
                  // unchecked exception, the result list would not be empty, as the augmented
                  // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
                  // exception, that would have been covered in the branch above
                  if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
                          !isExceptionOrThrowable(exc)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1265,12 ***</span>
                  return exc.tsym == syms.throwableType.tsym ||
                      exc.tsym == syms.exceptionType.tsym;
              }
  
          public void visitBreak(JCBreak tree) {
<span class="line-modified">!             if (tree.isValueBreak())</span>
<span class="line-modified">!                 scan(tree.value);</span>
              recordExit(new PendingExit(tree));
          }
  
          public void visitContinue(JCContinue tree) {
              recordExit(new PendingExit(tree));
<span class="line-new-header">--- 1328,15 ---</span>
                  return exc.tsym == syms.throwableType.tsym ||
                      exc.tsym == syms.exceptionType.tsym;
              }
  
          public void visitBreak(JCBreak tree) {
<span class="line-modified">!             recordExit(new PendingExit(tree));</span>
<span class="line-modified">!         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public void visitYield(JCYield tree) {</span>
<span class="line-added">+             scan(tree.value);</span>
              recordExit(new PendingExit(tree));
          }
  
          public void visitContinue(JCContinue tree) {
              recordExit(new PendingExit(tree));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1355,11 ***</span>
                  pendingExits = new ListBuffer&lt;&gt;();
                  while (exits.nonEmpty()) {
                      PendingExit exit = exits.head;
                      exits = exits.tail;
                      if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">!                         Assert.check(exit.tree.hasTag(RETURN));</span>
                      } else {
                          // uncaught throws will be reported later
                          pendingExits.append(exit);
                      }
                  }
<span class="line-new-header">--- 1421,12 ---</span>
                  pendingExits = new ListBuffer&lt;&gt;();
                  while (exits.nonEmpty()) {
                      PendingExit exit = exits.head;
                      exits = exits.tail;
                      if (!(exit instanceof ThrownPendingExit)) {
<span class="line-modified">!                         Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added">+                                         log.hasErrorOn(exit.tree.pos()));</span>
                      } else {
                          // uncaught throws will be reported later
                          pendingExits.append(exit);
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1433,10 ***</span>
<span class="line-new-header">--- 1500,72 ---</span>
          public void visitClassDef(JCClassDecl tree) {
              //skip
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Determine if alive after the given tree.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     class SnippetAliveAnalyzer extends AliveAnalyzer {</span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitClassDef(JCClassDecl tree) {</span>
<span class="line-added">+             //skip</span>
<span class="line-added">+         }</span>
<span class="line-added">+         public boolean isAlive() {</span>
<span class="line-added">+             return super.alive != Liveness.DEAD;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     class SnippetBreakAnalyzer extends AliveAnalyzer {</span>
<span class="line-added">+         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();</span>
<span class="line-added">+         private boolean breaksOut;</span>
<span class="line-added">+ </span>
<span class="line-added">+         public SnippetBreakAnalyzer() {</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitLabelled(JCTree.JCLabeledStatement tree) {</span>
<span class="line-added">+             seenTrees.add(tree);</span>
<span class="line-added">+             super.visitLabelled(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitWhileLoop(JCTree.JCWhileLoop tree) {</span>
<span class="line-added">+             seenTrees.add(tree);</span>
<span class="line-added">+             super.visitWhileLoop(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitForLoop(JCTree.JCForLoop tree) {</span>
<span class="line-added">+             seenTrees.add(tree);</span>
<span class="line-added">+             super.visitForLoop(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {</span>
<span class="line-added">+             seenTrees.add(tree);</span>
<span class="line-added">+             super.visitForeachLoop(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {</span>
<span class="line-added">+             seenTrees.add(tree);</span>
<span class="line-added">+             super.visitDoLoop(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
<span class="line-added">+         public void visitBreak(JCBreak tree) {</span>
<span class="line-added">+             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;</span>
<span class="line-added">+                           !seenTrees.contains(tree.target));</span>
<span class="line-added">+             super.visitBreak(tree);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         public boolean breaksOut() {</span>
<span class="line-added">+             return breaksOut;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Specialized pass that performs DA/DU on a lambda
       */
      class LambdaAssignAnalyzer extends AssignAnalyzer {
          WriteableScope enclosedSymbols;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1732,11 ***</span>
  
          void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
              if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
                  trackable(sym) &amp;&amp;
                  !inits.isMember(sym.adr)) {
<span class="line-modified">!                 log.error(pos, errkey);</span>
                  inits.incl(sym.adr);
              }
          }
  
          /** Utility method to reset several Bits instances.
<span class="line-new-header">--- 1861,11 ---</span>
  
          void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
              if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
                  trackable(sym) &amp;&amp;
                  !inits.isMember(sym.adr)) {
<span class="line-modified">!                     log.error(pos, errkey);</span>
                  inits.incl(sym.adr);
              }
          }
  
          /** Utility method to reset several Bits instances.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1952,22 ***</span>
                      }
                      // else we are in an instance initializer block;
                      // leave caught unchanged.
                      scan(tree.body);
  
                      if (isInitialConstructor) {
                          boolean isSynthesized = (tree.sym.flags() &amp;
                                                   GENERATEDCONSTR) != 0;
                          for (int i = firstadr; i &lt; nextadr; i++) {
                              JCVariableDecl vardecl = vardecls[i];
                              VarSymbol var = vardecl.sym;
                              if (var.owner == classDef.sym) {
                                  // choose the diagnostic position based on whether
                                  // the ctor is default(synthesized) or not
<span class="line-modified">!                                 if (isSynthesized) {</span>
                                      checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
<span class="line-modified">!                                         var, Errors.VarNotInitializedInDefaultConstructor(var));</span>
                                  } else {
                                      checkInit(TreeInfo.diagEndPos(tree.body), var);
                                  }
                              }
                          }
<span class="line-new-header">--- 2081,41 ---</span>
                      }
                      // else we are in an instance initializer block;
                      // leave caught unchanged.
                      scan(tree.body);
  
<span class="line-added">+                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;</span>
                      if (isInitialConstructor) {
                          boolean isSynthesized = (tree.sym.flags() &amp;
                                                   GENERATEDCONSTR) != 0;
                          for (int i = firstadr; i &lt; nextadr; i++) {
                              JCVariableDecl vardecl = vardecls[i];
                              VarSymbol var = vardecl.sym;
                              if (var.owner == classDef.sym) {
                                  // choose the diagnostic position based on whether
                                  // the ctor is default(synthesized) or not
<span class="line-modified">!                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {</span>
                                      checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
<span class="line-modified">!                                             var, Errors.VarNotInitializedInDefaultConstructor(var));</span>
<span class="line-added">+                                 } else if (isCompactConstructor) {</span>
<span class="line-added">+                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;</span>
<span class="line-added">+                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;</span>
<span class="line-added">+                                             !var.isStatic() &amp;&amp;</span>
<span class="line-added">+                                             var.owner.kind == TYP;</span>
<span class="line-added">+                                     if (isInstanceRecordField) {</span>
<span class="line-added">+                                         boolean notInitialized = !inits.isMember(var.adr);</span>
<span class="line-added">+                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {</span>
<span class="line-added">+                                         /*  this way we indicate Lower that it should generate an initialization for this field</span>
<span class="line-added">+                                          *  in the compact constructor</span>
<span class="line-added">+                                          */</span>
<span class="line-added">+                                             var.flags_field |= UNINITIALIZED_FIELD;</span>
<span class="line-added">+                                         } else {</span>
<span class="line-added">+                                             checkInit(TreeInfo.diagEndPos(tree.body), var);</span>
<span class="line-added">+                                         }</span>
<span class="line-added">+                                     } else {</span>
<span class="line-added">+                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);</span>
<span class="line-added">+                                     }</span>
                                  } else {
                                      checkInit(TreeInfo.diagEndPos(tree.body), var);
                                  }
                              }
                          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1975,11 ***</span>
                      List&lt;PendingExit&gt; exits = pendingExits.toList();
                      pendingExits = new ListBuffer&lt;&gt;();
                      while (exits.nonEmpty()) {
                          PendingExit exit = exits.head;
                          exits = exits.tail;
<span class="line-modified">!                         Assert.check(exit.tree.hasTag(RETURN), exit.tree);</span>
                          if (isInitialConstructor) {
                              Assert.check(exit instanceof AssignPendingExit);
                              inits.assign(((AssignPendingExit) exit).exit_inits);
                              for (int i = firstadr; i &lt; nextadr; i++) {
                                  checkInit(exit.tree.pos(), vardecls[i].sym);
<span class="line-new-header">--- 2123,13 ---</span>
                      List&lt;PendingExit&gt; exits = pendingExits.toList();
                      pendingExits = new ListBuffer&lt;&gt;();
                      while (exits.nonEmpty()) {
                          PendingExit exit = exits.head;
                          exits = exits.tail;
<span class="line-modified">!                         Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-added">+                                          log.hasErrorOn(exit.tree.pos()),</span>
<span class="line-added">+                                      exit.tree);</span>
                          if (isInitialConstructor) {
                              Assert.check(exit instanceof AssignPendingExit);
                              inits.assign(((AssignPendingExit) exit).exit_inits);
                              for (int i = firstadr; i &lt; nextadr; i++) {
                                  checkInit(exit.tree.pos(), vardecls[i].sym);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2224,13 ***</span>
                      uninits.assign(uninits.andSet(uninitsSwitch));
                  }
                  // Warn about fall-through if lint switch fallthrough enabled.
              }
              if (!hasDefault) {
<span class="line-modified">!                 inits.andSet(initsSwitch);</span>
              }
<span class="line-removed">-             resolveBreaks(tree, prevPendingExits);</span>
              nextadr = nextadrPrev;
          }
          // where
              /** Add any variables defined in stats to inits and uninits. */
              private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
<span class="line-new-header">--- 2374,21 ---</span>
                      uninits.assign(uninits.andSet(uninitsSwitch));
                  }
                  // Warn about fall-through if lint switch fallthrough enabled.
              }
              if (!hasDefault) {
<span class="line-modified">!                 if (tree.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-added">+                     markDead();</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     inits.andSet(initsSwitch);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (tree.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-added">+                 resolveYields(tree, prevPendingExits);</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 resolveBreaks(tree, prevPendingExits);</span>
              }
              nextadr = nextadrPrev;
          }
          // where
              /** Add any variables defined in stats to inits and uninits. */
              private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2391,39 ***</span>
              }
          }
  
          @Override
          public void visitBreak(JCBreak tree) {
<span class="line-modified">!             if (tree.isValueBreak()) {</span>
<span class="line-modified">!                 if (tree.target.hasTag(SWITCH_EXPRESSION)) {</span>
<span class="line-modified">!                     JCSwitchExpression expr = (JCSwitchExpression) tree.target;</span>
<span class="line-modified">!                     if (expr.type.hasTag(BOOLEAN)) {</span>
<span class="line-modified">!                         scanCond(tree.value);</span>
<span class="line-modified">!                         Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);</span>
<span class="line-modified">!                         Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);</span>
<span class="line-modified">!                         Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);</span>
<span class="line-modified">!                         Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);</span>
<span class="line-modified">!                         PendingExit exit = new PendingExit(tree) {</span>
<span class="line-modified">!                             @Override</span>
<span class="line-modified">!                             void resolveJump() {</span>
<span class="line-modified">!                                 if (!inits.isReset()) {</span>
<span class="line-modified">!                                     split(true);</span>
<span class="line-modified">!                                 }</span>
<span class="line-modified">!                                 initsWhenTrue.andSet(initsAfterBreakWhenTrue);</span>
<span class="line-modified">!                                 initsWhenFalse.andSet(initsAfterBreakWhenFalse);</span>
<span class="line-modified">!                                 uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);</span>
<span class="line-modified">!                                 uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);</span>
<span class="line-modified">!                             }</span>
<span class="line-modified">!                         };</span>
<span class="line-modified">!                         merge();</span>
<span class="line-removed">-                         recordExit(exit);</span>
<span class="line-removed">-                         return ;</span>
                      }
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 scan(tree.value);</span>
              }
<span class="line-removed">-             recordExit(new AssignPendingExit(tree, inits, uninits));</span>
          }
  
          @Override
          public void visitContinue(JCContinue tree) {
              recordExit(new AssignPendingExit(tree, inits, uninits));
<span class="line-new-header">--- 2549,41 ---</span>
              }
          }
  
          @Override
          public void visitBreak(JCBreak tree) {
<span class="line-modified">!             recordExit(new AssignPendingExit(tree, inits, uninits));</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         @Override</span>
<span class="line-modified">!         public void visitYield(JCYield tree) {</span>
<span class="line-modified">!             JCSwitchExpression expr = (JCSwitchExpression) tree.target;</span>
<span class="line-modified">!             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {</span>
<span class="line-modified">!                 scanCond(tree.value);</span>
<span class="line-modified">!                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);</span>
<span class="line-modified">!                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);</span>
<span class="line-modified">!                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);</span>
<span class="line-modified">!                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);</span>
<span class="line-modified">!                 PendingExit exit = new PendingExit(tree) {</span>
<span class="line-modified">!                     @Override</span>
<span class="line-modified">!                     void resolveJump() {</span>
<span class="line-modified">!                         if (!inits.isReset()) {</span>
<span class="line-modified">!                             split(true);</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">!                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);</span>
<span class="line-modified">!                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);</span>
<span class="line-modified">!                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);</span>
<span class="line-modified">!                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);</span>
                      }
<span class="line-modified">!                 };</span>
<span class="line-modified">!                 merge();</span>
<span class="line-added">+                 recordExit(exit);</span>
<span class="line-added">+                 return ;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 scanExpr(tree.value);</span>
<span class="line-added">+                 recordExit(new AssignPendingExit(tree, inits, uninits));</span>
              }
          }
  
          @Override
          public void visitContinue(JCContinue tree) {
              recordExit(new AssignPendingExit(tree, inits, uninits));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2782,13 ***</span>
              }
              super.visitTry(tree);
          }
  
          @Override
<span class="line-modified">!         public void visitBreak(JCBreak tree) {</span>
<span class="line-modified">!             if (tree.isValueBreak())</span>
<span class="line-removed">-                 scan(tree.value);</span>
          }
  
          public void visitModuleDef(JCModuleDecl tree) {
              // Do nothing for modules
          }
<span class="line-new-header">--- 2942,12 ---</span>
              }
              super.visitTry(tree);
          }
  
          @Override
<span class="line-modified">!         public void visitYield(JCYield tree) {</span>
<span class="line-modified">!             scan(tree.value);</span>
          }
  
          public void visitModuleDef(JCModuleDecl tree) {
              // Do nothing for modules
          }
</pre>
<center><a href="Enter.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Infer.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
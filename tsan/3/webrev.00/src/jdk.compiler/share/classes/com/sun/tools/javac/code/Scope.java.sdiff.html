<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Scope.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Printer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Source.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Scope.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 372                         newTable[i] = e;
 373                     }
 374                 }
 375                 return new ScopeImpl(this, newOwner, newTable, n);
 376             } else {
 377                 return new ScopeImpl(this, newOwner, this.table.clone(), this.nelems);
 378             }
 379         }
 380 
 381         /** Remove all entries of this scope from its table, if shared
 382          *  with next.
 383          */
 384         public WriteableScope leave() {
 385             Assert.check(shared == 0);
 386             if (table != next.table) return next;
 387             while (elems != null) {
 388                 int hash = getIndex(elems.sym.name);
 389                 Entry e = table[hash];
 390                 Assert.check(e == elems, elems.sym);
 391                 table[hash] = elems.shadowed;
<span class="line-modified"> 392                 elems = elems.sibling;</span>
 393             }
 394             Assert.check(next.shared &gt; 0);
 395             next.shared--;
 396             next.nelems = nelems;
 397             // System.out.println(&quot;====&gt; leaving scope &quot; + this.hashCode() + &quot; owned by &quot; + this.owner + &quot; to &quot; + next.hashCode());
 398             // new Error().printStackTrace(System.out);
 399             return next;
 400         }
 401 
 402         /** Double size of hash table.
 403          */
 404         private void dble() {
 405             Assert.check(shared == 0);
 406             Entry[] oldtable = table;
 407             Entry[] newtable = new Entry[oldtable.length * 2];
 408             for (ScopeImpl s = this; s != null; s = s.next) {
 409                 if (s.table == oldtable) {
 410                     Assert.check(s == this || s.shared != 0);
 411                     s.table = newtable;
 412                     s.hashMask = newtable.length - 1;
</pre>
<hr />
<pre>
 449          */
 450         public void remove(Symbol sym) {
 451             Assert.check(shared == 0);
 452             Entry e = lookup(sym.name, candidate -&gt; candidate == sym);
 453             if (e.scope == null) return;
 454 
 455             // remove e from table and shadowed list;
 456             int i = getIndex(sym.name);
 457             Entry te = table[i];
 458             if (te == e)
 459                 table[i] = e.shadowed;
 460             else while (true) {
 461                 if (te.shadowed == e) {
 462                     te.shadowed = e.shadowed;
 463                     break;
 464                 }
 465                 te = te.shadowed;
 466             }
 467 
 468             // remove e from elems and sibling list
<span class="line-modified"> 469             te = elems;</span>
<span class="line-modified"> 470             if (te == e)</span>
<span class="line-modified"> 471                 elems = e.sibling;</span>
<span class="line-modified"> 472             else while (true) {</span>
<span class="line-modified"> 473                 if (te.sibling == e) {</span>
<span class="line-modified"> 474                     te.sibling = e.sibling;</span>
<span class="line-modified"> 475                     break;</span>
<span class="line-modified"> 476                 }</span>
<span class="line-modified"> 477                 te = te.sibling;</span>
 478             }
 479 
 480             removeCount++;
 481 
 482             //notify listeners
 483             listeners.symbolRemoved(sym, this);
 484         }
 485 
 486         /** Enter symbol sym in this scope if not already there.
 487          */
 488         public void enterIfAbsent(Symbol sym) {
 489             Assert.check(shared == 0);
 490             Entry e = lookup(sym.name);
 491             while (e.scope == this &amp;&amp; e.sym.kind != sym.kind) e = e.next();
 492             if (e.scope != this) enter(sym);
 493         }
 494 
 495         /** Given a class, is there already a class with same fully
 496          *  qualified name in this (import) scope?
 497          */
</pre>
<hr />
<pre>
 580                 public boolean hasNext() {
 581                     if (seenRemoveCount != currScope.removeCount &amp;&amp;
 582                         currEntry != null &amp;&amp;
 583                         !currEntry.scope.includes(currEntry.sym)) {
 584                         doNext(); //skip entry that is no longer in the Scope
 585                         seenRemoveCount = currScope.removeCount;
 586                     }
 587                     return currEntry != null;
 588                 }
 589 
 590                 public Symbol next() {
 591                     if (!hasNext()) {
 592                         throw new NoSuchElementException();
 593                     }
 594 
 595                     return doNext();
 596                 }
 597                 private Symbol doNext() {
 598                     Symbol sym = (currEntry == null ? null : currEntry.sym);
 599                     if (currEntry != null) {
<span class="line-modified"> 600                         currEntry = currEntry.sibling;</span>
 601                     }
 602                     update();
 603                     return sym;
 604                 }
 605 
 606                 private void update() {
 607                     skipToNextMatchingEntry();
 608                     if (lookupKind == RECURSIVE) {
 609                         while (currEntry == null &amp;&amp; currScope.next != null) {
 610                             currScope = currScope.next;
 611                             currEntry = currScope.elems;
 612                             seenRemoveCount = currScope.removeCount;
 613                             skipToNextMatchingEntry();
 614                         }
 615                     }
 616                 }
 617 
 618                 void skipToNextMatchingEntry() {
 619                     while (currEntry != null &amp;&amp; sf != null &amp;&amp; !sf.accepts(currEntry.sym)) {
<span class="line-modified"> 620                         currEntry = currEntry.sibling;</span>
 621                     }
 622                 }
 623             };
 624         }
 625 
 626         public Iterable&lt;Symbol&gt; getSymbolsByName(final Name name,
 627                                                  final Filter&lt;Symbol&gt; sf,
 628                                                  final LookupKind lookupKind) {
 629             return () -&gt; new Iterator&lt;Symbol&gt;() {
 630                Entry currentEntry = lookup(name, sf);
 631                int seenRemoveCount = currentEntry.scope != null ?
 632                        currentEntry.scope.removeCount : -1;
 633 
 634                public boolean hasNext() {
 635                    if (currentEntry.scope != null &amp;&amp;
 636                        seenRemoveCount != currentEntry.scope.removeCount &amp;&amp;
 637                        !currentEntry.scope.includes(currentEntry.sym)) {
 638                        doNext(); //skip entry that is no longer in the Scope
 639                    }
 640                    return currentEntry.scope != null &amp;&amp;
</pre>
<hr />
<pre>
 660 
 661         public Scope getOrigin(Symbol s) {
 662             for (Scope.Entry e = lookup(s.name); e.scope != null ; e = e.next()) {
 663                 if (e.sym == s) {
 664                     return this;
 665                 }
 666             }
 667             return null;
 668         }
 669 
 670         @Override
 671         public boolean isStaticallyImported(Symbol s) {
 672             return false;
 673         }
 674 
 675         public String toString() {
 676             StringBuilder result = new StringBuilder();
 677             result.append(&quot;Scope[&quot;);
 678             for (ScopeImpl s = this; s != null ; s = s.next) {
 679                 if (s != this) result.append(&quot; | &quot;);
<span class="line-modified"> 680                 for (Entry e = s.elems; e != null; e = e.sibling) {</span>
 681                     if (e != s.elems) result.append(&quot;, &quot;);
 682                     result.append(e.sym);
 683                 }
 684             }
 685             result.append(&quot;]&quot;);
 686             return result.toString();
 687         }
 688     }
 689 
 690     /** A class for scope entries.
 691      */
 692     private static class Entry {
 693 
 694         /** The referenced symbol.
 695          *  sym == null   iff   this == sentinel
 696          */
 697         public Symbol sym;
 698 
 699         /** An entry with the same hash code, or sentinel.
 700          */
 701         private Entry shadowed;
 702 
 703         /** Next entry in same scope.
 704          */
<span class="line-modified"> 705         public Entry sibling;</span>




 706 
 707         /** The entry&#39;s scope.
 708          *  scope == null   iff   this == sentinel
 709          */
 710         public ScopeImpl scope;
 711 
<span class="line-modified"> 712         public Entry(Symbol sym, Entry shadowed, Entry sibling, ScopeImpl scope) {</span>
 713             this.sym = sym;
 714             this.shadowed = shadowed;
<span class="line-modified"> 715             this.sibling = sibling;</span>
 716             this.scope = scope;


 717         }
 718 
 719         /** Return next entry with the same name as this entry, proceeding
 720          *  outwards if not found in this scope.
 721          */
 722         public Entry next() {
 723             return shadowed;
 724         }
 725 
 726         public Entry next(Filter&lt;Symbol&gt; sf) {
 727             if (shadowed.sym == null || sf == null || sf.accepts(shadowed.sym)) return shadowed;
 728             else return shadowed.next(sf);
 729         }
 730 
 731     }
 732 
 733     public static class ImportScope extends CompoundScope {
 734 
 735         public ImportScope(Symbol owner) {
 736             super(owner);
</pre>
</td>
<td>
<hr />
<pre>
 372                         newTable[i] = e;
 373                     }
 374                 }
 375                 return new ScopeImpl(this, newOwner, newTable, n);
 376             } else {
 377                 return new ScopeImpl(this, newOwner, this.table.clone(), this.nelems);
 378             }
 379         }
 380 
 381         /** Remove all entries of this scope from its table, if shared
 382          *  with next.
 383          */
 384         public WriteableScope leave() {
 385             Assert.check(shared == 0);
 386             if (table != next.table) return next;
 387             while (elems != null) {
 388                 int hash = getIndex(elems.sym.name);
 389                 Entry e = table[hash];
 390                 Assert.check(e == elems, elems.sym);
 391                 table[hash] = elems.shadowed;
<span class="line-modified"> 392                 elems = elems.nextSibling;</span>
 393             }
 394             Assert.check(next.shared &gt; 0);
 395             next.shared--;
 396             next.nelems = nelems;
 397             // System.out.println(&quot;====&gt; leaving scope &quot; + this.hashCode() + &quot; owned by &quot; + this.owner + &quot; to &quot; + next.hashCode());
 398             // new Error().printStackTrace(System.out);
 399             return next;
 400         }
 401 
 402         /** Double size of hash table.
 403          */
 404         private void dble() {
 405             Assert.check(shared == 0);
 406             Entry[] oldtable = table;
 407             Entry[] newtable = new Entry[oldtable.length * 2];
 408             for (ScopeImpl s = this; s != null; s = s.next) {
 409                 if (s.table == oldtable) {
 410                     Assert.check(s == this || s.shared != 0);
 411                     s.table = newtable;
 412                     s.hashMask = newtable.length - 1;
</pre>
<hr />
<pre>
 449          */
 450         public void remove(Symbol sym) {
 451             Assert.check(shared == 0);
 452             Entry e = lookup(sym.name, candidate -&gt; candidate == sym);
 453             if (e.scope == null) return;
 454 
 455             // remove e from table and shadowed list;
 456             int i = getIndex(sym.name);
 457             Entry te = table[i];
 458             if (te == e)
 459                 table[i] = e.shadowed;
 460             else while (true) {
 461                 if (te.shadowed == e) {
 462                     te.shadowed = e.shadowed;
 463                     break;
 464                 }
 465                 te = te.shadowed;
 466             }
 467 
 468             // remove e from elems and sibling list
<span class="line-modified"> 469             if (elems == e) {</span>
<span class="line-modified"> 470                 elems = e.nextSibling;</span>
<span class="line-modified"> 471                 if (elems != null)</span>
<span class="line-modified"> 472                     elems.prevSibling = null;</span>
<span class="line-modified"> 473             } else {</span>
<span class="line-modified"> 474                 Assert.check(e.prevSibling != null, e.sym);</span>
<span class="line-modified"> 475                 e.prevSibling.nextSibling = e.nextSibling;</span>
<span class="line-modified"> 476                 if (e.nextSibling != null)</span>
<span class="line-modified"> 477                     e.nextSibling.prevSibling = e.prevSibling;</span>
 478             }
 479 
 480             removeCount++;
 481 
 482             //notify listeners
 483             listeners.symbolRemoved(sym, this);
 484         }
 485 
 486         /** Enter symbol sym in this scope if not already there.
 487          */
 488         public void enterIfAbsent(Symbol sym) {
 489             Assert.check(shared == 0);
 490             Entry e = lookup(sym.name);
 491             while (e.scope == this &amp;&amp; e.sym.kind != sym.kind) e = e.next();
 492             if (e.scope != this) enter(sym);
 493         }
 494 
 495         /** Given a class, is there already a class with same fully
 496          *  qualified name in this (import) scope?
 497          */
</pre>
<hr />
<pre>
 580                 public boolean hasNext() {
 581                     if (seenRemoveCount != currScope.removeCount &amp;&amp;
 582                         currEntry != null &amp;&amp;
 583                         !currEntry.scope.includes(currEntry.sym)) {
 584                         doNext(); //skip entry that is no longer in the Scope
 585                         seenRemoveCount = currScope.removeCount;
 586                     }
 587                     return currEntry != null;
 588                 }
 589 
 590                 public Symbol next() {
 591                     if (!hasNext()) {
 592                         throw new NoSuchElementException();
 593                     }
 594 
 595                     return doNext();
 596                 }
 597                 private Symbol doNext() {
 598                     Symbol sym = (currEntry == null ? null : currEntry.sym);
 599                     if (currEntry != null) {
<span class="line-modified"> 600                         currEntry = currEntry.nextSibling;</span>
 601                     }
 602                     update();
 603                     return sym;
 604                 }
 605 
 606                 private void update() {
 607                     skipToNextMatchingEntry();
 608                     if (lookupKind == RECURSIVE) {
 609                         while (currEntry == null &amp;&amp; currScope.next != null) {
 610                             currScope = currScope.next;
 611                             currEntry = currScope.elems;
 612                             seenRemoveCount = currScope.removeCount;
 613                             skipToNextMatchingEntry();
 614                         }
 615                     }
 616                 }
 617 
 618                 void skipToNextMatchingEntry() {
 619                     while (currEntry != null &amp;&amp; sf != null &amp;&amp; !sf.accepts(currEntry.sym)) {
<span class="line-modified"> 620                         currEntry = currEntry.nextSibling;</span>
 621                     }
 622                 }
 623             };
 624         }
 625 
 626         public Iterable&lt;Symbol&gt; getSymbolsByName(final Name name,
 627                                                  final Filter&lt;Symbol&gt; sf,
 628                                                  final LookupKind lookupKind) {
 629             return () -&gt; new Iterator&lt;Symbol&gt;() {
 630                Entry currentEntry = lookup(name, sf);
 631                int seenRemoveCount = currentEntry.scope != null ?
 632                        currentEntry.scope.removeCount : -1;
 633 
 634                public boolean hasNext() {
 635                    if (currentEntry.scope != null &amp;&amp;
 636                        seenRemoveCount != currentEntry.scope.removeCount &amp;&amp;
 637                        !currentEntry.scope.includes(currentEntry.sym)) {
 638                        doNext(); //skip entry that is no longer in the Scope
 639                    }
 640                    return currentEntry.scope != null &amp;&amp;
</pre>
<hr />
<pre>
 660 
 661         public Scope getOrigin(Symbol s) {
 662             for (Scope.Entry e = lookup(s.name); e.scope != null ; e = e.next()) {
 663                 if (e.sym == s) {
 664                     return this;
 665                 }
 666             }
 667             return null;
 668         }
 669 
 670         @Override
 671         public boolean isStaticallyImported(Symbol s) {
 672             return false;
 673         }
 674 
 675         public String toString() {
 676             StringBuilder result = new StringBuilder();
 677             result.append(&quot;Scope[&quot;);
 678             for (ScopeImpl s = this; s != null ; s = s.next) {
 679                 if (s != this) result.append(&quot; | &quot;);
<span class="line-modified"> 680                 for (Entry e = s.elems; e != null; e = e.nextSibling) {</span>
 681                     if (e != s.elems) result.append(&quot;, &quot;);
 682                     result.append(e.sym);
 683                 }
 684             }
 685             result.append(&quot;]&quot;);
 686             return result.toString();
 687         }
 688     }
 689 
 690     /** A class for scope entries.
 691      */
 692     private static class Entry {
 693 
 694         /** The referenced symbol.
 695          *  sym == null   iff   this == sentinel
 696          */
 697         public Symbol sym;
 698 
 699         /** An entry with the same hash code, or sentinel.
 700          */
 701         private Entry shadowed;
 702 
 703         /** Next entry in same scope.
 704          */
<span class="line-modified"> 705         public Entry nextSibling;</span>
<span class="line-added"> 706 </span>
<span class="line-added"> 707         /** Prev entry in same scope.</span>
<span class="line-added"> 708          */</span>
<span class="line-added"> 709         public Entry prevSibling;</span>
 710 
 711         /** The entry&#39;s scope.
 712          *  scope == null   iff   this == sentinel
 713          */
 714         public ScopeImpl scope;
 715 
<span class="line-modified"> 716         public Entry(Symbol sym, Entry shadowed, Entry nextSibling, ScopeImpl scope) {</span>
 717             this.sym = sym;
 718             this.shadowed = shadowed;
<span class="line-modified"> 719             this.nextSibling = nextSibling;</span>
 720             this.scope = scope;
<span class="line-added"> 721             if (nextSibling != null)</span>
<span class="line-added"> 722                 nextSibling.prevSibling = this;</span>
 723         }
 724 
 725         /** Return next entry with the same name as this entry, proceeding
 726          *  outwards if not found in this scope.
 727          */
 728         public Entry next() {
 729             return shadowed;
 730         }
 731 
 732         public Entry next(Filter&lt;Symbol&gt; sf) {
 733             if (shadowed.sym == null || sf == null || sf.accepts(shadowed.sym)) return shadowed;
 734             else return shadowed.next(sf);
 735         }
 736 
 737     }
 738 
 739     public static class ImportScope extends CompoundScope {
 740 
 741         public ImportScope(Symbol owner) {
 742             super(owner);
</pre>
</td>
</tr>
</table>
<center><a href="Printer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Source.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
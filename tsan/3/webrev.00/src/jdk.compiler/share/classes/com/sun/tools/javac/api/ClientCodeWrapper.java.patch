diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/api/ClientCodeWrapper.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/api/ClientCodeWrapper.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/api/ClientCodeWrapper.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/api/ClientCodeWrapper.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -44,10 +44,11 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
+import java.util.ServiceLoader;
 import java.util.Set;
 
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.NestingKind;
 import javax.tools.Diagnostic;
@@ -70,15 +71,15 @@
 /**
  *  Wrap objects to enable unchecked exceptions to be caught and handled.
  *
  *  For each method, exceptions are handled as follows:
  *  <ul>
- *  <li>Checked exceptions are left alone and propogate upwards in the
+ *  <li>Checked exceptions are left alone to propagate upwards in the
  *      obvious way, since they are an expected aspect of the method's
  *      specification.
  *  <li>Unchecked exceptions which have already been caught and wrapped in
- *      ClientCodeException are left alone to continue propogating upwards.
+ *      ClientCodeException are left alone to continue propagating upwards.
  *  <li>All other unchecked exceptions (i.e. subtypes of RuntimeException
  *      and Error) and caught, and rethrown as a ClientCodeException with
  *      its cause set to the original exception.
  *  </ul>
  *
@@ -154,11 +155,11 @@
             return ((JavaFileObject) ((WrappedJavaFileObject) fo).clientFileObject);
         else
             return fo;
     }
 
-    public <T /*super JavaFileOject*/> DiagnosticListener<T> wrap(DiagnosticListener<T> dl) {
+    public <T /*super JavaFileObject*/> DiagnosticListener<T> wrap(DiagnosticListener<T> dl) {
         if (isTrusted(dl))
             return dl;
         return new WrappedDiagnosticListener<>(dl);
     }
 
@@ -415,10 +416,21 @@
 
         @Override
         public String toString() {
             return wrappedToString(getClass(), clientJavaFileManager);
         }
+
+        @Override @DefinedBy(Api.COMPILER)
+        public <S> ServiceLoader<S> getServiceLoader(Location location, Class<S> service) throws IOException {
+            try {
+                return clientJavaFileManager.getServiceLoader(location, service);
+            } catch (ClientCodeException e) {
+                throw e;
+            } catch (RuntimeException | Error e) {
+                throw new ClientCodeException(e);
+            }
+        }
     }
 
     protected class WrappedStandardJavaFileManager extends WrappedJavaFileManager
             implements StandardJavaFileManager {
         WrappedStandardJavaFileManager(StandardJavaFileManager clientJavaFileManager) {
@@ -434,10 +446,22 @@
             } catch (RuntimeException | Error e) {
                 throw new ClientCodeException(e);
             }
         }
 
+        @Override @DefinedBy(Api.COMPILER)
+        public Iterable<? extends JavaFileObject> getJavaFileObjectsFromPaths(Collection<? extends Path> paths) {
+            try {
+                return ((StandardJavaFileManager)clientJavaFileManager).getJavaFileObjectsFromPaths(paths);
+            } catch (ClientCodeException e) {
+                throw e;
+            } catch (RuntimeException | Error e) {
+                throw new ClientCodeException(e);
+            }
+        }
+
+        @Deprecated(since = "13")
         @Override @DefinedBy(Api.COMPILER)
         public Iterable<? extends JavaFileObject> getJavaFileObjectsFromPaths(Iterable<? extends Path> paths) {
             try {
                 return ((StandardJavaFileManager)clientJavaFileManager).getJavaFileObjectsFromPaths(paths);
             } catch (ClientCodeException e) {
@@ -553,10 +577,22 @@
             } catch (ClientCodeException e) {
                 throw e;
             } catch (RuntimeException | Error e) {
                 throw new ClientCodeException(e);
             }
+        }
+
+        @Override @DefinedBy(Api.COMPILER)
+        public void setLocationForModule(Location location, String moduleName, Collection<? extends Path> paths) throws IOException {
+            try {
+                System.out.println("invoking wrapped setLocationForModule");
+                ((StandardJavaFileManager)clientJavaFileManager).setLocationForModule(location, moduleName, paths);
+            } catch (ClientCodeException e) {
+                throw e;
+            } catch (RuntimeException | Error e) {
+                throw new ClientCodeException(e);
+            }
         }
     }
 
     protected class WrappedFileObject implements FileObject {
         protected FileObject clientFileObject;

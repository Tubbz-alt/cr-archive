<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TreeDiffer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TransTypes.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeHasher.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TreeDiffer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Symbol;
 29 import com.sun.tools.javac.tree.JCTree;
 30 import com.sun.tools.javac.tree.JCTree.JCAnnotatedType;
 31 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 32 import com.sun.tools.javac.tree.JCTree.JCArrayAccess;
 33 import com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;
 34 import com.sun.tools.javac.tree.JCTree.JCAssert;
 35 import com.sun.tools.javac.tree.JCTree.JCAssign;
 36 import com.sun.tools.javac.tree.JCTree.JCAssignOp;
 37 import com.sun.tools.javac.tree.JCTree.JCBinary;

 38 import com.sun.tools.javac.tree.JCTree.JCBlock;
 39 import com.sun.tools.javac.tree.JCTree.JCBreak;
 40 import com.sun.tools.javac.tree.JCTree.JCCase;
 41 import com.sun.tools.javac.tree.JCTree.JCCatch;
 42 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 43 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 44 import com.sun.tools.javac.tree.JCTree.JCConditional;
 45 import com.sun.tools.javac.tree.JCTree.JCContinue;
 46 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 47 import com.sun.tools.javac.tree.JCTree.JCEnhancedForLoop;
 48 import com.sun.tools.javac.tree.JCTree.JCErroneous;
 49 import com.sun.tools.javac.tree.JCTree.JCExports;
 50 import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;
 51 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 52 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 53 import com.sun.tools.javac.tree.JCTree.JCIdent;
 54 import com.sun.tools.javac.tree.JCTree.JCIf;
 55 import com.sun.tools.javac.tree.JCTree.JCImport;
 56 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 57 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 58 import com.sun.tools.javac.tree.JCTree.JCLambda;
 59 import com.sun.tools.javac.tree.JCTree.JCLiteral;
 60 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
 61 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 62 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 63 import com.sun.tools.javac.tree.JCTree.JCModifiers;
 64 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
 65 import com.sun.tools.javac.tree.JCTree.JCNewArray;
 66 import com.sun.tools.javac.tree.JCTree.JCNewClass;
 67 import com.sun.tools.javac.tree.JCTree.JCOpens;
 68 import com.sun.tools.javac.tree.JCTree.JCPackageDecl;
 69 import com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;
 70 import com.sun.tools.javac.tree.JCTree.JCProvides;
 71 import com.sun.tools.javac.tree.JCTree.JCRequires;
 72 import com.sun.tools.javac.tree.JCTree.JCReturn;
 73 import com.sun.tools.javac.tree.JCTree.JCSwitch;

 74 import com.sun.tools.javac.tree.JCTree.JCSynchronized;
 75 import com.sun.tools.javac.tree.JCTree.JCThrow;
 76 import com.sun.tools.javac.tree.JCTree.JCTry;
 77 import com.sun.tools.javac.tree.JCTree.JCTypeApply;
 78 import com.sun.tools.javac.tree.JCTree.JCTypeCast;
 79 import com.sun.tools.javac.tree.JCTree.JCTypeIntersection;
 80 import com.sun.tools.javac.tree.JCTree.JCTypeParameter;
 81 import com.sun.tools.javac.tree.JCTree.JCTypeUnion;
 82 import com.sun.tools.javac.tree.JCTree.JCUnary;
 83 import com.sun.tools.javac.tree.JCTree.JCUses;
 84 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 85 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 86 import com.sun.tools.javac.tree.JCTree.JCWildcard;

 87 import com.sun.tools.javac.tree.JCTree.LetExpr;
 88 import com.sun.tools.javac.tree.JCTree.TypeBoundKind;
 89 import com.sun.tools.javac.tree.TreeInfo;
 90 import com.sun.tools.javac.tree.TreeScanner;
 91 import com.sun.tools.javac.util.List;
 92 import java.util.Collection;
 93 import java.util.HashMap;
 94 import java.util.Iterator;
 95 import java.util.Map;
 96 import java.util.Objects;
 97 
 98 /** A visitor that compares two lambda bodies for structural equality. */
 99 public class TreeDiffer extends TreeScanner {
100 
101     public TreeDiffer(
102             Collection&lt;? extends Symbol&gt; symbols, Collection&lt;? extends Symbol&gt; otherSymbols) {
103         this.equiv = equiv(symbols, otherSymbols);
104     }
105 
106     private static Map&lt;Symbol, Symbol&gt; equiv(
</pre>
<hr />
<pre>
233     }
234 
235     @Override
236     public void visitAssignop(JCAssignOp tree) {
237         JCAssignOp that = (JCAssignOp) parameter;
238         result =
239                 scan(tree.lhs, that.lhs)
240                         &amp;&amp; scan(tree.rhs, that.rhs)
241                         &amp;&amp; tree.operator == that.operator;
242     }
243 
244     @Override
245     public void visitBinary(JCBinary tree) {
246         JCBinary that = (JCBinary) parameter;
247         result =
248                 scan(tree.lhs, that.lhs)
249                         &amp;&amp; scan(tree.rhs, that.rhs)
250                         &amp;&amp; tree.operator == that.operator;
251     }
252 












253     @Override
254     public void visitBlock(JCBlock tree) {
255         JCBlock that = (JCBlock) parameter;
256         result = tree.flags == that.flags &amp;&amp; scan(tree.stats, that.stats);
257     }
258 
259     @Override
260     public void visitBreak(JCBreak tree) {
261         JCBreak that = (JCBreak) parameter;






262         result = scan(tree.value, that.value);
263     }
264 
265     @Override
266     public void visitCase(JCCase tree) {
267         JCCase that = (JCCase) parameter;
268         result = scan(tree.pats, that.pats) &amp;&amp; scan(tree.stats, that.stats);
269     }
270 
271     @Override
272     public void visitCatch(JCCatch tree) {
273         JCCatch that = (JCCatch) parameter;
274         result = scan(tree.param, that.param) &amp;&amp; scan(tree.body, that.body);
275     }
276 
277     @Override
278     public void visitClassDef(JCClassDecl tree) {
279         JCClassDecl that = (JCClassDecl) parameter;
280         result =
281                 scan(tree.mods, that.mods)
</pre>
<hr />
<pre>
481     public void visitRequires(JCRequires tree) {
482         JCRequires that = (JCRequires) parameter;
483         result =
484                 tree.isTransitive == that.isTransitive
485                         &amp;&amp; tree.isStaticPhase == that.isStaticPhase
486                         &amp;&amp; scan(tree.moduleName, that.moduleName);
487     }
488 
489     @Override
490     public void visitReturn(JCReturn tree) {
491         JCReturn that = (JCReturn) parameter;
492         result = scan(tree.expr, that.expr);
493     }
494 
495     @Override
496     public void visitSwitch(JCSwitch tree) {
497         JCSwitch that = (JCSwitch) parameter;
498         result = scan(tree.selector, that.selector) &amp;&amp; scan(tree.cases, that.cases);
499     }
500 






501     @Override
502     public void visitSynchronized(JCSynchronized tree) {
503         JCSynchronized that = (JCSynchronized) parameter;
504         result = scan(tree.lock, that.lock) &amp;&amp; scan(tree.body, that.body);
505     }
506 
507     @Override
508     public void visitThrow(JCThrow tree) {
509         JCThrow that = (JCThrow) parameter;
510         result = scan(tree.expr, that.expr);
511     }
512 
513     @Override
514     public void visitTopLevel(JCCompilationUnit tree) {
515         JCCompilationUnit that = (JCCompilationUnit) parameter;
516         result =
517                 scan(tree.defs, that.defs)
518                         &amp;&amp; tree.modle == that.modle
519                         &amp;&amp; tree.packge == that.packge;
520     }
</pre>
<hr />
<pre>
560     }
561 
562     @Override
563     public void visitTypeIntersection(JCTypeIntersection tree) {
564         JCTypeIntersection that = (JCTypeIntersection) parameter;
565         result = scan(tree.bounds, that.bounds);
566     }
567 
568     @Override
569     public void visitTypeParameter(JCTypeParameter tree) {
570         JCTypeParameter that = (JCTypeParameter) parameter;
571         result =
572                 tree.name == that.name
573                         &amp;&amp; scan(tree.bounds, that.bounds)
574                         &amp;&amp; scan(tree.annotations, that.annotations);
575     }
576 
577     @Override
578     public void visitTypeTest(JCInstanceOf tree) {
579         JCInstanceOf that = (JCInstanceOf) parameter;
<span class="line-modified">580         result = scan(tree.expr, that.expr) &amp;&amp; scan(tree.clazz, that.clazz);</span>
581     }
582 
583     @Override
584     public void visitTypeUnion(JCTypeUnion tree) {
585         JCTypeUnion that = (JCTypeUnion) parameter;
586         result = scan(tree.alternatives, that.alternatives);
587     }
588 
589     @Override
590     public void visitUnary(JCUnary tree) {
591         JCUnary that = (JCUnary) parameter;
592         result = scan(tree.arg, that.arg) &amp;&amp; tree.operator == that.operator;
593     }
594 
595     @Override
596     public void visitUses(JCUses tree) {
597         JCUses that = (JCUses) parameter;
598         result = scan(tree.qualid, that.qualid);
599     }
600 
</pre>
</td>
<td>
<hr />
<pre>
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Symbol;
 29 import com.sun.tools.javac.tree.JCTree;
 30 import com.sun.tools.javac.tree.JCTree.JCAnnotatedType;
 31 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
 32 import com.sun.tools.javac.tree.JCTree.JCArrayAccess;
 33 import com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;
 34 import com.sun.tools.javac.tree.JCTree.JCAssert;
 35 import com.sun.tools.javac.tree.JCTree.JCAssign;
 36 import com.sun.tools.javac.tree.JCTree.JCAssignOp;
 37 import com.sun.tools.javac.tree.JCTree.JCBinary;
<span class="line-added"> 38 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;</span>
 39 import com.sun.tools.javac.tree.JCTree.JCBlock;
 40 import com.sun.tools.javac.tree.JCTree.JCBreak;
 41 import com.sun.tools.javac.tree.JCTree.JCCase;
 42 import com.sun.tools.javac.tree.JCTree.JCCatch;
 43 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 44 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 45 import com.sun.tools.javac.tree.JCTree.JCConditional;
 46 import com.sun.tools.javac.tree.JCTree.JCContinue;
 47 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 48 import com.sun.tools.javac.tree.JCTree.JCEnhancedForLoop;
 49 import com.sun.tools.javac.tree.JCTree.JCErroneous;
 50 import com.sun.tools.javac.tree.JCTree.JCExports;
 51 import com.sun.tools.javac.tree.JCTree.JCExpressionStatement;
 52 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 53 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 54 import com.sun.tools.javac.tree.JCTree.JCIdent;
 55 import com.sun.tools.javac.tree.JCTree.JCIf;
 56 import com.sun.tools.javac.tree.JCTree.JCImport;
 57 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 58 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 59 import com.sun.tools.javac.tree.JCTree.JCLambda;
 60 import com.sun.tools.javac.tree.JCTree.JCLiteral;
 61 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
 62 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 63 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 64 import com.sun.tools.javac.tree.JCTree.JCModifiers;
 65 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
 66 import com.sun.tools.javac.tree.JCTree.JCNewArray;
 67 import com.sun.tools.javac.tree.JCTree.JCNewClass;
 68 import com.sun.tools.javac.tree.JCTree.JCOpens;
 69 import com.sun.tools.javac.tree.JCTree.JCPackageDecl;
 70 import com.sun.tools.javac.tree.JCTree.JCPrimitiveTypeTree;
 71 import com.sun.tools.javac.tree.JCTree.JCProvides;
 72 import com.sun.tools.javac.tree.JCTree.JCRequires;
 73 import com.sun.tools.javac.tree.JCTree.JCReturn;
 74 import com.sun.tools.javac.tree.JCTree.JCSwitch;
<span class="line-added"> 75 import com.sun.tools.javac.tree.JCTree.JCSwitchExpression;</span>
 76 import com.sun.tools.javac.tree.JCTree.JCSynchronized;
 77 import com.sun.tools.javac.tree.JCTree.JCThrow;
 78 import com.sun.tools.javac.tree.JCTree.JCTry;
 79 import com.sun.tools.javac.tree.JCTree.JCTypeApply;
 80 import com.sun.tools.javac.tree.JCTree.JCTypeCast;
 81 import com.sun.tools.javac.tree.JCTree.JCTypeIntersection;
 82 import com.sun.tools.javac.tree.JCTree.JCTypeParameter;
 83 import com.sun.tools.javac.tree.JCTree.JCTypeUnion;
 84 import com.sun.tools.javac.tree.JCTree.JCUnary;
 85 import com.sun.tools.javac.tree.JCTree.JCUses;
 86 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 87 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 88 import com.sun.tools.javac.tree.JCTree.JCWildcard;
<span class="line-added"> 89 import com.sun.tools.javac.tree.JCTree.JCYield;</span>
 90 import com.sun.tools.javac.tree.JCTree.LetExpr;
 91 import com.sun.tools.javac.tree.JCTree.TypeBoundKind;
 92 import com.sun.tools.javac.tree.TreeInfo;
 93 import com.sun.tools.javac.tree.TreeScanner;
 94 import com.sun.tools.javac.util.List;
 95 import java.util.Collection;
 96 import java.util.HashMap;
 97 import java.util.Iterator;
 98 import java.util.Map;
 99 import java.util.Objects;
100 
101 /** A visitor that compares two lambda bodies for structural equality. */
102 public class TreeDiffer extends TreeScanner {
103 
104     public TreeDiffer(
105             Collection&lt;? extends Symbol&gt; symbols, Collection&lt;? extends Symbol&gt; otherSymbols) {
106         this.equiv = equiv(symbols, otherSymbols);
107     }
108 
109     private static Map&lt;Symbol, Symbol&gt; equiv(
</pre>
<hr />
<pre>
236     }
237 
238     @Override
239     public void visitAssignop(JCAssignOp tree) {
240         JCAssignOp that = (JCAssignOp) parameter;
241         result =
242                 scan(tree.lhs, that.lhs)
243                         &amp;&amp; scan(tree.rhs, that.rhs)
244                         &amp;&amp; tree.operator == that.operator;
245     }
246 
247     @Override
248     public void visitBinary(JCBinary tree) {
249         JCBinary that = (JCBinary) parameter;
250         result =
251                 scan(tree.lhs, that.lhs)
252                         &amp;&amp; scan(tree.rhs, that.rhs)
253                         &amp;&amp; tree.operator == that.operator;
254     }
255 
<span class="line-added">256     @Override</span>
<span class="line-added">257     public void visitBindingPattern(JCBindingPattern tree) {</span>
<span class="line-added">258         JCBindingPattern that = (JCBindingPattern) parameter;</span>
<span class="line-added">259         result =</span>
<span class="line-added">260                 scan(tree.vartype, that.vartype)</span>
<span class="line-added">261                         &amp;&amp; tree.name == that.name;</span>
<span class="line-added">262         if (!result) {</span>
<span class="line-added">263             return;</span>
<span class="line-added">264         }</span>
<span class="line-added">265         equiv.put(tree.symbol, that.symbol);</span>
<span class="line-added">266     }</span>
<span class="line-added">267 </span>
268     @Override
269     public void visitBlock(JCBlock tree) {
270         JCBlock that = (JCBlock) parameter;
271         result = tree.flags == that.flags &amp;&amp; scan(tree.stats, that.stats);
272     }
273 
274     @Override
275     public void visitBreak(JCBreak tree) {
276         JCBreak that = (JCBreak) parameter;
<span class="line-added">277         result = tree.label == that.label;</span>
<span class="line-added">278     }</span>
<span class="line-added">279 </span>
<span class="line-added">280     @Override</span>
<span class="line-added">281     public void visitYield(JCYield tree) {</span>
<span class="line-added">282         JCYield that = (JCYield) parameter;</span>
283         result = scan(tree.value, that.value);
284     }
285 
286     @Override
287     public void visitCase(JCCase tree) {
288         JCCase that = (JCCase) parameter;
289         result = scan(tree.pats, that.pats) &amp;&amp; scan(tree.stats, that.stats);
290     }
291 
292     @Override
293     public void visitCatch(JCCatch tree) {
294         JCCatch that = (JCCatch) parameter;
295         result = scan(tree.param, that.param) &amp;&amp; scan(tree.body, that.body);
296     }
297 
298     @Override
299     public void visitClassDef(JCClassDecl tree) {
300         JCClassDecl that = (JCClassDecl) parameter;
301         result =
302                 scan(tree.mods, that.mods)
</pre>
<hr />
<pre>
502     public void visitRequires(JCRequires tree) {
503         JCRequires that = (JCRequires) parameter;
504         result =
505                 tree.isTransitive == that.isTransitive
506                         &amp;&amp; tree.isStaticPhase == that.isStaticPhase
507                         &amp;&amp; scan(tree.moduleName, that.moduleName);
508     }
509 
510     @Override
511     public void visitReturn(JCReturn tree) {
512         JCReturn that = (JCReturn) parameter;
513         result = scan(tree.expr, that.expr);
514     }
515 
516     @Override
517     public void visitSwitch(JCSwitch tree) {
518         JCSwitch that = (JCSwitch) parameter;
519         result = scan(tree.selector, that.selector) &amp;&amp; scan(tree.cases, that.cases);
520     }
521 
<span class="line-added">522     @Override</span>
<span class="line-added">523     public void visitSwitchExpression(JCSwitchExpression tree) {</span>
<span class="line-added">524         JCSwitchExpression that = (JCSwitchExpression) parameter;</span>
<span class="line-added">525         result = scan(tree.selector, that.selector) &amp;&amp; scan(tree.cases, that.cases);</span>
<span class="line-added">526     }</span>
<span class="line-added">527 </span>
528     @Override
529     public void visitSynchronized(JCSynchronized tree) {
530         JCSynchronized that = (JCSynchronized) parameter;
531         result = scan(tree.lock, that.lock) &amp;&amp; scan(tree.body, that.body);
532     }
533 
534     @Override
535     public void visitThrow(JCThrow tree) {
536         JCThrow that = (JCThrow) parameter;
537         result = scan(tree.expr, that.expr);
538     }
539 
540     @Override
541     public void visitTopLevel(JCCompilationUnit tree) {
542         JCCompilationUnit that = (JCCompilationUnit) parameter;
543         result =
544                 scan(tree.defs, that.defs)
545                         &amp;&amp; tree.modle == that.modle
546                         &amp;&amp; tree.packge == that.packge;
547     }
</pre>
<hr />
<pre>
587     }
588 
589     @Override
590     public void visitTypeIntersection(JCTypeIntersection tree) {
591         JCTypeIntersection that = (JCTypeIntersection) parameter;
592         result = scan(tree.bounds, that.bounds);
593     }
594 
595     @Override
596     public void visitTypeParameter(JCTypeParameter tree) {
597         JCTypeParameter that = (JCTypeParameter) parameter;
598         result =
599                 tree.name == that.name
600                         &amp;&amp; scan(tree.bounds, that.bounds)
601                         &amp;&amp; scan(tree.annotations, that.annotations);
602     }
603 
604     @Override
605     public void visitTypeTest(JCInstanceOf tree) {
606         JCInstanceOf that = (JCInstanceOf) parameter;
<span class="line-modified">607         result = scan(tree.expr, that.expr) &amp;&amp; scan(tree.pattern, that.pattern);</span>
608     }
609 
610     @Override
611     public void visitTypeUnion(JCTypeUnion tree) {
612         JCTypeUnion that = (JCTypeUnion) parameter;
613         result = scan(tree.alternatives, that.alternatives);
614     }
615 
616     @Override
617     public void visitUnary(JCUnary tree) {
618         JCUnary that = (JCUnary) parameter;
619         result = scan(tree.arg, that.arg) &amp;&amp; tree.operator == that.operator;
620     }
621 
622     @Override
623     public void visitUses(JCUses tree) {
624         JCUses that = (JCUses) parameter;
625         result = scan(tree.qualid, that.qualid);
626     }
627 
</pre>
</td>
</tr>
</table>
<center><a href="TransTypes.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeHasher.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
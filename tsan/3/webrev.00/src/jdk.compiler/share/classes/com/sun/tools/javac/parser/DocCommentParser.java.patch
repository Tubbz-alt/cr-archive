diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/DocCommentParser.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/DocCommentParser.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/DocCommentParser.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/DocCommentParser.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -186,11 +186,11 @@
                 case '<':
                     newline = false;
                     if (isFileContent) {
                         switch (phase) {
                             case PREAMBLE:
-                                if (peek("body")) {
+                                if (isEndPreamble()) {
                                     trees.add(html());
                                     if (textStart == -1) {
                                         textStart = bp;
                                         lastNonWhite = -1;
                                     }
@@ -198,11 +198,11 @@
                                     newline = true;
                                     break loop;
                                 }
                                 break;
                             case BODY:
-                                if (peek("/body")) {
+                                if (isEndBody()) {
                                     addPendingText(trees, lastNonWhite);
                                     break loop;
                                 }
                                 break;
                             default:
@@ -785,10 +785,98 @@
             nextChar();
             return m.at(p).newEntityTree(name);
         }
     }
 
+    /**
+     * Returns whether this is the end of the preamble of an HTML file.
+     * The preamble ends with start of {@code body} element followed by
+     * possible whitespace and the start of a {@code main} element.
+     *
+     * @return whether this is the end of the preamble
+     */
+    boolean isEndPreamble() {
+        final int savedpos = bp;
+        try {
+            if (ch == '<')
+                nextChar();
+
+            if (isIdentifierStart(ch)) {
+                String name = StringUtils.toLowerCase(readIdentifier().toString());
+                switch (name) {
+                    case "body":
+                        // Check if also followed by <main>
+                        // 1. skip rest of <body>
+                        while (ch != -1 && ch != '>') {
+                            nextChar();
+                        }
+                        if (ch == '>') {
+                            nextChar();
+                        }
+                        // 2. skip any whitespce
+                        while (ch != -1 && Character.isWhitespace(ch)) {
+                            nextChar();
+                        }
+                        // 3. check if looking at "<main..."
+                        if (ch == '<') {
+                            nextChar();
+                            if (isIdentifierStart(ch)) {
+                                name = StringUtils.toLowerCase(readIdentifier().toString());
+                                if (name.equals("main")) {
+                                    return false;
+                                }
+                            }
+                        }
+                        // if <body> is _not_ followed by <main> then this is the
+                        // end of the preamble
+                        return true;
+
+                    case "main":
+                        // <main> is unconditionally the end of the preamble
+                        return true;
+                }
+            }
+            return false;
+        } finally {
+            bp = savedpos;
+            ch = buf[bp];
+        }
+    }
+
+    /**
+     * Returns whether this is the end of the main body of the content in a standalone
+     * HTML file.
+     * The content ends with the closing tag for a {@code main} or {@code body} element.
+     *
+     * @return whether this is the end of the main body of the content
+     */
+    boolean isEndBody() {
+        final int savedpos = bp;
+        try {
+            if (ch == '<')
+                nextChar();
+
+            if (ch == '/') {
+                nextChar();
+                if (isIdentifierStart(ch)) {
+                    String name = StringUtils.toLowerCase(readIdentifier().toString());
+                    switch (name) {
+                        case "body":
+                        case "main":
+                            return true;
+                    }
+                }
+            }
+
+            return false;
+        } finally {
+            bp = savedpos;
+            ch = buf[bp];
+        }
+
+    }
+
     boolean peek(String s) {
         final int savedpos = bp;
         try {
             if (ch == '<')
                 nextChar();
@@ -840,11 +928,11 @@
             if (isIdentifierStart(ch)) {
                 Name name = readIdentifier();
                 skipWhitespace();
                 if (ch == '>') {
                     nextChar();
-                    return m.at(p).newEndElementTree(name);
+                    return m.at(p).newEndElementTree(name).setEndPos(bp);
                 }
             }
         } else if (ch == '!') {
             nextChar();
             if (ch == '-') {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/file/Locations.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacFileManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../jvm/CRTable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/file/Locations.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  77 import javax.tools.StandardJavaFileManager.PathFactory;
  78 import javax.tools.StandardLocation;
  79 
  80 import jdk.internal.jmod.JmodFile;
  81 
  82 import com.sun.tools.javac.code.Lint;
  83 import com.sun.tools.javac.code.Lint.LintCategory;
  84 import com.sun.tools.javac.main.Option;
  85 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  86 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  87 import com.sun.tools.javac.util.DefinedBy;
  88 import com.sun.tools.javac.util.DefinedBy.Api;
  89 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  90 import com.sun.tools.javac.util.ListBuffer;
  91 import com.sun.tools.javac.util.Log;
  92 import com.sun.tools.javac.jvm.ModuleNameReader;
  93 import com.sun.tools.javac.util.Iterators;
  94 import com.sun.tools.javac.util.Pair;
  95 import com.sun.tools.javac.util.StringUtils;
  96 

  97 import static javax.tools.StandardLocation.PLATFORM_CLASS_PATH;
  98 
  99 import static com.sun.tools.javac.main.Option.BOOT_CLASS_PATH;
 100 import static com.sun.tools.javac.main.Option.ENDORSEDDIRS;
 101 import static com.sun.tools.javac.main.Option.EXTDIRS;
 102 import static com.sun.tools.javac.main.Option.XBOOTCLASSPATH_APPEND;
 103 import static com.sun.tools.javac.main.Option.XBOOTCLASSPATH_PREPEND;
 104 
 105 /**
 106  * This class converts command line arguments, environment variables and system properties (in
 107  * File.pathSeparator-separated String form) into a boot class path, user class path, and source
 108  * path (in {@code Collection&lt;String&gt;} form).
 109  *
 110  * &lt;p&gt;
 111  * &lt;b&gt;This is NOT part of any supported API. If you write code that depends on this, you do so at
 112  * your own risk. This code and its internal interfaces are subject to change or deletion without
 113  * notice.&lt;/b&gt;
 114  */
 115 public class Locations {
 116 
</pre>
<hr />
<pre>
 168             throw ex;
 169         }
 170     }
 171 
 172     void update(Log log, boolean warn, FSInfo fsInfo) {
 173         this.log = log;
 174         this.warn = warn;
 175         this.fsInfo = fsInfo;
 176     }
 177 
 178     void setPathFactory(PathFactory f) {
 179         pathFactory = f;
 180     }
 181 
 182     boolean isDefaultBootClassPath() {
 183         BootClassPathLocationHandler h
 184                 = (BootClassPathLocationHandler) getHandler(PLATFORM_CLASS_PATH);
 185         return h.isDefault();
 186     }
 187 






 188     /**
 189      * Split a search path into its elements. Empty path elements will be ignored.
 190      *
 191      * @param searchPath The search path to be split
 192      * @return The elements of the path
 193      */
 194     private Iterable&lt;Path&gt; getPathEntries(String searchPath) {
 195         return getPathEntries(searchPath, null);
 196     }
 197 
 198     /**
 199      * Split a search path into its elements. If emptyPathDefault is not null, all empty elements in the
 200      * path, including empty elements at either end of the path, will be replaced with the value of
 201      * emptyPathDefault.
 202      *
 203      * @param searchPath The search path to be split
 204      * @param emptyPathDefault The value to substitute for empty path elements, or null, to ignore
 205      * empty path elements
 206      * @return The elements of the path
 207      */
</pre>
<hr />
<pre>
 209         ListBuffer&lt;Path&gt; entries = new ListBuffer&lt;&gt;();
 210         for (String s: searchPath.split(Pattern.quote(File.pathSeparator), -1)) {
 211             if (s.isEmpty()) {
 212                 if (emptyPathDefault != null) {
 213                     entries.add(emptyPathDefault);
 214                 }
 215             } else {
 216                 try {
 217                     entries.add(getPath(s));
 218                 } catch (IllegalArgumentException e) {
 219                     if (warn) {
 220                         log.warning(LintCategory.PATH, Warnings.InvalidPath(s));
 221                     }
 222                 }
 223             }
 224         }
 225         return entries;
 226     }
 227 
 228     public void setMultiReleaseValue(String multiReleaseValue) {
<span class="line-modified"> 229         fsEnv = Collections.singletonMap(&quot;multi-release&quot;, multiReleaseValue);</span>
 230     }
 231 
 232     private boolean contains(Collection&lt;Path&gt; searchPath, Path file) throws IOException {
 233 
 234         if (searchPath == null) {
 235             return false;
 236         }
 237 
 238         Path enclosingJar = null;
 239         if (file.getFileSystem().provider() == fsInfo.getJarFSProvider()) {
 240             URI uri = file.toUri();
 241             if (uri.getScheme().equals(&quot;jar&quot;)) {
 242                 String ssp = uri.getSchemeSpecificPart();
 243                 int sep = ssp.lastIndexOf(&quot;!&quot;);
 244                 if (ssp.startsWith(&quot;file:&quot;) &amp;&amp; sep &gt; 0) {
 245                     enclosingJar = Paths.get(URI.create(ssp.substring(0, sep)));
 246                 }
 247             }
 248         }
 249 
</pre>
<hr />
<pre>
 256                 return true;
 257             }
 258             if (enclosingJar != null
 259                     &amp;&amp; Files.isSameFile(enclosingJar, np)) {
 260                 return true;
 261             }
 262         }
 263 
 264         return false;
 265     }
 266 
 267     /**
 268      * Utility class to help evaluate a path option. Duplicate entries are ignored, jar class paths
 269      * can be expanded.
 270      */
 271     private class SearchPath extends LinkedHashSet&lt;Path&gt; {
 272 
 273         private static final long serialVersionUID = 0;
 274 
 275         private boolean expandJarClassPaths = false;
<span class="line-modified"> 276         private final Set&lt;Path&gt; canonicalValues = new HashSet&lt;&gt;();</span>
 277 
 278         public SearchPath expandJarClassPaths(boolean x) {
 279             expandJarClassPaths = x;
 280             return this;
 281         }
 282 
 283         /**
 284          * What to use when path element is the empty string
 285          */
<span class="line-modified"> 286         private Path emptyPathDefault = null;</span>
 287 
 288         public SearchPath emptyPathDefault(Path x) {
 289             emptyPathDefault = x;
 290             return this;
 291         }
 292 
 293         public SearchPath addDirectories(String dirs, boolean warn) {
 294             boolean prev = expandJarClassPaths;
 295             expandJarClassPaths = true;
 296             try {
 297                 if (dirs != null) {
 298                     for (Path dir : getPathEntries(dirs)) {
 299                         addDirectory(dir, warn);
 300                     }
 301                 }
 302                 return this;
 303             } finally {
 304                 expandJarClassPaths = prev;
 305             }
 306         }
</pre>
<hr />
<pre>
 362                                 Warnings.PathElementNotFound(file));
 363                 }
 364                 super.add(file);
 365                 return;
 366             }
 367 
 368             Path canonFile = fsInfo.getCanonicalFile(file);
 369             if (canonicalValues.contains(canonFile)) {
 370                 /* Discard duplicates and avoid infinite recursion */
 371                 return;
 372             }
 373 
 374             if (fsInfo.isFile(file)) {
 375                 /* File is an ordinary file. */
 376                 if (   !file.getFileName().toString().endsWith(&quot;.jmod&quot;)
 377                     &amp;&amp; !file.endsWith(&quot;modules&quot;)) {
 378                     if (!isArchive(file)) {
 379                         /* Not a recognized extension; open it to see if
 380                          it looks like a valid zip file. */
 381                         try {
<span class="line-modified"> 382                             FileSystems.newFileSystem(file, null).close();</span>
 383                             if (warn) {
 384                                 log.warning(Lint.LintCategory.PATH,
 385                                             Warnings.UnexpectedArchiveFile(file));
 386                             }
 387                         } catch (IOException | ProviderNotFoundException e) {
 388                             // FIXME: include e.getLocalizedMessage in warning
 389                             if (warn) {
 390                                 log.warning(Lint.LintCategory.PATH,
 391                                             Warnings.InvalidArchiveFile(file));
 392                             }
 393                             return;
 394                         }
 395                     } else {
 396                         if (fsInfo.getJarFSProvider() == null) {
 397                             log.error(Errors.NoZipfsForArchive(file));
 398                             return ;
 399                         }
 400                     }
 401                 }
 402             }
</pre>
<hr />
<pre>
 955         }
 956 
 957         private void lazy() {
 958             if (searchPath == null) {
 959                 try {
 960                     searchPath = Collections.unmodifiableCollection(computePath());
 961                 } catch (IOException e) {
 962                     // TODO: need better handling here, e.g. javac Abort?
 963                     throw new UncheckedIOException(e);
 964                 }
 965             }
 966         }
 967 
 968         @Override
 969         boolean contains(Path file) throws IOException {
 970             return Locations.this.contains(searchPath, file);
 971         }
 972     }
 973 
 974     /**
<span class="line-modified"> 975      * A LocationHander to represent modules found from a module-oriented</span>
 976      * location such as MODULE_SOURCE_PATH, UPGRADE_MODULE_PATH,
 977      * SYSTEM_MODULES and MODULE_PATH.
 978      *
 979      * The Location can be specified to accept overriding classes from the
 980      * {@code --patch-module &lt;module&gt;=&lt;path&gt; } parameter.
 981      */
 982     private class ModuleLocationHandler extends LocationHandler implements Location {
 983         private final LocationHandler parent;
 984         private final String name;
 985         private final String moduleName;
 986         private final boolean output;
 987         boolean explicit;
 988         Collection&lt;Path&gt; searchPath;
 989 
 990         ModuleLocationHandler(LocationHandler parent, String name, String moduleName,
 991                 Collection&lt;Path&gt; searchPath, boolean output) {
 992             this.parent = parent;
 993             this.name = name;
 994             this.moduleName = moduleName;
 995             this.searchPath = searchPath;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  77 import javax.tools.StandardJavaFileManager.PathFactory;
  78 import javax.tools.StandardLocation;
  79 
  80 import jdk.internal.jmod.JmodFile;
  81 
  82 import com.sun.tools.javac.code.Lint;
  83 import com.sun.tools.javac.code.Lint.LintCategory;
  84 import com.sun.tools.javac.main.Option;
  85 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  86 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  87 import com.sun.tools.javac.util.DefinedBy;
  88 import com.sun.tools.javac.util.DefinedBy.Api;
  89 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  90 import com.sun.tools.javac.util.ListBuffer;
  91 import com.sun.tools.javac.util.Log;
  92 import com.sun.tools.javac.jvm.ModuleNameReader;
  93 import com.sun.tools.javac.util.Iterators;
  94 import com.sun.tools.javac.util.Pair;
  95 import com.sun.tools.javac.util.StringUtils;
  96 
<span class="line-added">  97 import static javax.tools.StandardLocation.SYSTEM_MODULES;</span>
  98 import static javax.tools.StandardLocation.PLATFORM_CLASS_PATH;
  99 
 100 import static com.sun.tools.javac.main.Option.BOOT_CLASS_PATH;
 101 import static com.sun.tools.javac.main.Option.ENDORSEDDIRS;
 102 import static com.sun.tools.javac.main.Option.EXTDIRS;
 103 import static com.sun.tools.javac.main.Option.XBOOTCLASSPATH_APPEND;
 104 import static com.sun.tools.javac.main.Option.XBOOTCLASSPATH_PREPEND;
 105 
 106 /**
 107  * This class converts command line arguments, environment variables and system properties (in
 108  * File.pathSeparator-separated String form) into a boot class path, user class path, and source
 109  * path (in {@code Collection&lt;String&gt;} form).
 110  *
 111  * &lt;p&gt;
 112  * &lt;b&gt;This is NOT part of any supported API. If you write code that depends on this, you do so at
 113  * your own risk. This code and its internal interfaces are subject to change or deletion without
 114  * notice.&lt;/b&gt;
 115  */
 116 public class Locations {
 117 
</pre>
<hr />
<pre>
 169             throw ex;
 170         }
 171     }
 172 
 173     void update(Log log, boolean warn, FSInfo fsInfo) {
 174         this.log = log;
 175         this.warn = warn;
 176         this.fsInfo = fsInfo;
 177     }
 178 
 179     void setPathFactory(PathFactory f) {
 180         pathFactory = f;
 181     }
 182 
 183     boolean isDefaultBootClassPath() {
 184         BootClassPathLocationHandler h
 185                 = (BootClassPathLocationHandler) getHandler(PLATFORM_CLASS_PATH);
 186         return h.isDefault();
 187     }
 188 
<span class="line-added"> 189     boolean isDefaultSystemModulesPath() {</span>
<span class="line-added"> 190         SystemModulesLocationHandler h</span>
<span class="line-added"> 191                 = (SystemModulesLocationHandler) getHandler(SYSTEM_MODULES);</span>
<span class="line-added"> 192         return !h.isExplicit();</span>
<span class="line-added"> 193     }</span>
<span class="line-added"> 194 </span>
 195     /**
 196      * Split a search path into its elements. Empty path elements will be ignored.
 197      *
 198      * @param searchPath The search path to be split
 199      * @return The elements of the path
 200      */
 201     private Iterable&lt;Path&gt; getPathEntries(String searchPath) {
 202         return getPathEntries(searchPath, null);
 203     }
 204 
 205     /**
 206      * Split a search path into its elements. If emptyPathDefault is not null, all empty elements in the
 207      * path, including empty elements at either end of the path, will be replaced with the value of
 208      * emptyPathDefault.
 209      *
 210      * @param searchPath The search path to be split
 211      * @param emptyPathDefault The value to substitute for empty path elements, or null, to ignore
 212      * empty path elements
 213      * @return The elements of the path
 214      */
</pre>
<hr />
<pre>
 216         ListBuffer&lt;Path&gt; entries = new ListBuffer&lt;&gt;();
 217         for (String s: searchPath.split(Pattern.quote(File.pathSeparator), -1)) {
 218             if (s.isEmpty()) {
 219                 if (emptyPathDefault != null) {
 220                     entries.add(emptyPathDefault);
 221                 }
 222             } else {
 223                 try {
 224                     entries.add(getPath(s));
 225                 } catch (IllegalArgumentException e) {
 226                     if (warn) {
 227                         log.warning(LintCategory.PATH, Warnings.InvalidPath(s));
 228                     }
 229                 }
 230             }
 231         }
 232         return entries;
 233     }
 234 
 235     public void setMultiReleaseValue(String multiReleaseValue) {
<span class="line-modified"> 236         fsEnv = Collections.singletonMap(&quot;releaseVersion&quot;, multiReleaseValue);</span>
 237     }
 238 
 239     private boolean contains(Collection&lt;Path&gt; searchPath, Path file) throws IOException {
 240 
 241         if (searchPath == null) {
 242             return false;
 243         }
 244 
 245         Path enclosingJar = null;
 246         if (file.getFileSystem().provider() == fsInfo.getJarFSProvider()) {
 247             URI uri = file.toUri();
 248             if (uri.getScheme().equals(&quot;jar&quot;)) {
 249                 String ssp = uri.getSchemeSpecificPart();
 250                 int sep = ssp.lastIndexOf(&quot;!&quot;);
 251                 if (ssp.startsWith(&quot;file:&quot;) &amp;&amp; sep &gt; 0) {
 252                     enclosingJar = Paths.get(URI.create(ssp.substring(0, sep)));
 253                 }
 254             }
 255         }
 256 
</pre>
<hr />
<pre>
 263                 return true;
 264             }
 265             if (enclosingJar != null
 266                     &amp;&amp; Files.isSameFile(enclosingJar, np)) {
 267                 return true;
 268             }
 269         }
 270 
 271         return false;
 272     }
 273 
 274     /**
 275      * Utility class to help evaluate a path option. Duplicate entries are ignored, jar class paths
 276      * can be expanded.
 277      */
 278     private class SearchPath extends LinkedHashSet&lt;Path&gt; {
 279 
 280         private static final long serialVersionUID = 0;
 281 
 282         private boolean expandJarClassPaths = false;
<span class="line-modified"> 283         private final transient Set&lt;Path&gt; canonicalValues = new HashSet&lt;&gt;();</span>
 284 
 285         public SearchPath expandJarClassPaths(boolean x) {
 286             expandJarClassPaths = x;
 287             return this;
 288         }
 289 
 290         /**
 291          * What to use when path element is the empty string
 292          */
<span class="line-modified"> 293         private transient Path emptyPathDefault = null;</span>
 294 
 295         public SearchPath emptyPathDefault(Path x) {
 296             emptyPathDefault = x;
 297             return this;
 298         }
 299 
 300         public SearchPath addDirectories(String dirs, boolean warn) {
 301             boolean prev = expandJarClassPaths;
 302             expandJarClassPaths = true;
 303             try {
 304                 if (dirs != null) {
 305                     for (Path dir : getPathEntries(dirs)) {
 306                         addDirectory(dir, warn);
 307                     }
 308                 }
 309                 return this;
 310             } finally {
 311                 expandJarClassPaths = prev;
 312             }
 313         }
</pre>
<hr />
<pre>
 369                                 Warnings.PathElementNotFound(file));
 370                 }
 371                 super.add(file);
 372                 return;
 373             }
 374 
 375             Path canonFile = fsInfo.getCanonicalFile(file);
 376             if (canonicalValues.contains(canonFile)) {
 377                 /* Discard duplicates and avoid infinite recursion */
 378                 return;
 379             }
 380 
 381             if (fsInfo.isFile(file)) {
 382                 /* File is an ordinary file. */
 383                 if (   !file.getFileName().toString().endsWith(&quot;.jmod&quot;)
 384                     &amp;&amp; !file.endsWith(&quot;modules&quot;)) {
 385                     if (!isArchive(file)) {
 386                         /* Not a recognized extension; open it to see if
 387                          it looks like a valid zip file. */
 388                         try {
<span class="line-modified"> 389                             FileSystems.newFileSystem(file, (ClassLoader)null).close();</span>
 390                             if (warn) {
 391                                 log.warning(Lint.LintCategory.PATH,
 392                                             Warnings.UnexpectedArchiveFile(file));
 393                             }
 394                         } catch (IOException | ProviderNotFoundException e) {
 395                             // FIXME: include e.getLocalizedMessage in warning
 396                             if (warn) {
 397                                 log.warning(Lint.LintCategory.PATH,
 398                                             Warnings.InvalidArchiveFile(file));
 399                             }
 400                             return;
 401                         }
 402                     } else {
 403                         if (fsInfo.getJarFSProvider() == null) {
 404                             log.error(Errors.NoZipfsForArchive(file));
 405                             return ;
 406                         }
 407                     }
 408                 }
 409             }
</pre>
<hr />
<pre>
 962         }
 963 
 964         private void lazy() {
 965             if (searchPath == null) {
 966                 try {
 967                     searchPath = Collections.unmodifiableCollection(computePath());
 968                 } catch (IOException e) {
 969                     // TODO: need better handling here, e.g. javac Abort?
 970                     throw new UncheckedIOException(e);
 971                 }
 972             }
 973         }
 974 
 975         @Override
 976         boolean contains(Path file) throws IOException {
 977             return Locations.this.contains(searchPath, file);
 978         }
 979     }
 980 
 981     /**
<span class="line-modified"> 982      * A LocationHandler to represent modules found from a module-oriented</span>
 983      * location such as MODULE_SOURCE_PATH, UPGRADE_MODULE_PATH,
 984      * SYSTEM_MODULES and MODULE_PATH.
 985      *
 986      * The Location can be specified to accept overriding classes from the
 987      * {@code --patch-module &lt;module&gt;=&lt;path&gt; } parameter.
 988      */
 989     private class ModuleLocationHandler extends LocationHandler implements Location {
 990         private final LocationHandler parent;
 991         private final String name;
 992         private final String moduleName;
 993         private final boolean output;
 994         boolean explicit;
 995         Collection&lt;Path&gt; searchPath;
 996 
 997         ModuleLocationHandler(LocationHandler parent, String name, String moduleName,
 998                 Collection&lt;Path&gt; searchPath, boolean output) {
 999             this.parent = parent;
1000             this.name = name;
1001             this.moduleName = moduleName;
1002             this.searchPath = searchPath;
</pre>
</td>
</tr>
</table>
<center><a href="JavacFileManager.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../jvm/CRTable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
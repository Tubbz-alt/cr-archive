<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Code.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/ClassWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.util.LinkedHashMap;
  30 import java.util.Map;
  31 import java.util.Set;
<span class="line-removed">  32 import java.util.HashSet;</span>
  33 import java.util.LinkedHashSet;
<span class="line-modified">  34 import java.util.stream.Collectors;</span>
  35 
  36 import javax.tools.JavaFileManager;
  37 import javax.tools.FileObject;
  38 import javax.tools.JavaFileManager.Location;
  39 import javax.tools.JavaFileObject;
  40 
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Directive.*;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;
<span class="line-removed">  47 import com.sun.tools.javac.code.Types.UniqueType;</span>
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.file.PathFileObject;
<span class="line-modified">  50 import com.sun.tools.javac.jvm.Pool.DynamicMethod;</span>
<span class="line-modified">  51 import com.sun.tools.javac.jvm.Pool.Method;</span>
<span class="line-removed">  52 import com.sun.tools.javac.jvm.Pool.MethodHandle;</span>
<span class="line-removed">  53 import com.sun.tools.javac.jvm.Pool.Variable;</span>
  54 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  55 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  56 import com.sun.tools.javac.util.*;

  57 
  58 import static com.sun.tools.javac.code.Flags.*;
  59 import static com.sun.tools.javac.code.Kinds.Kind.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.TypeTag.*;
  62 import static com.sun.tools.javac.main.Option.*;
  63 
  64 import static javax.tools.StandardLocation.CLASS_OUTPUT;
  65 
  66 /** This class provides operations to map an internal symbol table graph
  67  *  rooted in a ClassSymbol into a classfile.
  68  *
  69  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  70  *  If you write code that depends on this, you do so at your own risk.
  71  *  This code and its internal interfaces are subject to change or
  72  *  deletion without notice.&lt;/b&gt;
  73  */
  74 public class ClassWriter extends ClassFile {
  75     protected static final Context.Key&lt;ClassWriter&gt; classWriterKey = new Context.Key&lt;&gt;();
  76 
</pre>
<hr />
<pre>
 100      * Target class version.
 101      */
 102     private Target target;
 103 
 104     /**
 105      * Source language version.
 106      */
 107     private Source source;
 108 
 109     /** Type utilities. */
 110     private Types types;
 111 
 112     private Check check;
 113 
 114     /**
 115      * If true, class files will be written in module-specific subdirectories
 116      * of the CLASS_OUTPUT location.
 117      */
 118     public boolean multiModuleMode;
 119 


 120     /** The initial sizes of the data and constant pool buffers.
 121      *  Sizes are increased when buffers get full.
 122      */
 123     static final int DATA_BUF_SIZE = 0x0fff0;
<span class="line-modified"> 124     static final int POOL_BUF_SIZE = 0x1fff0;</span>
 125 
 126     /** An output buffer for member info.
 127      */
<span class="line-modified"> 128     ByteBuffer databuf = new ByteBuffer(DATA_BUF_SIZE);</span>
 129 
 130     /** An output buffer for the constant pool.
 131      */
<span class="line-modified"> 132     ByteBuffer poolbuf = new ByteBuffer(POOL_BUF_SIZE);</span>
<span class="line-removed"> 133 </span>
<span class="line-removed"> 134     /** The constant pool.</span>
<span class="line-removed"> 135      */</span>
<span class="line-removed"> 136     Pool pool;</span>
<span class="line-removed"> 137 </span>
<span class="line-removed"> 138     /** The inner classes to be written, as a set.</span>
<span class="line-removed"> 139      */</span>
<span class="line-removed"> 140     Set&lt;ClassSymbol&gt; innerClasses;</span>
<span class="line-removed"> 141 </span>
<span class="line-removed"> 142     /** The inner classes to be written, as a queue where</span>
<span class="line-removed"> 143      *  enclosing classes come first.</span>
<span class="line-removed"> 144      */</span>
<span class="line-removed"> 145     ListBuffer&lt;ClassSymbol&gt; innerClassesQueue;</span>
 146 
<span class="line-modified"> 147     /** The bootstrap methods to be written in the corresponding class attribute</span>
<span class="line-removed"> 148      *  (one for each invokedynamic)</span>
 149      */
<span class="line-modified"> 150     Map&lt;DynamicMethod.BootstrapMethodsKey, DynamicMethod.BootstrapMethodsValue&gt; bootstrapMethods;</span>
 151 
 152     /** The log to use for verbose output.
 153      */
 154     private final Log log;
 155 
 156     /** The name table. */
 157     private final Names names;
 158 
 159     /** Access to files. */
 160     private final JavaFileManager fileManager;
 161 
<span class="line-removed"> 162     /** Sole signature generator */</span>
<span class="line-removed"> 163     private final CWSignatureGenerator signatureGen;</span>
<span class="line-removed"> 164 </span>
 165     /** The tags and constants used in compressed stackmap. */
 166     static final int SAME_FRAME_SIZE = 64;
 167     static final int SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247;
 168     static final int SAME_FRAME_EXTENDED = 251;
 169     static final int FULL_FRAME = 255;
 170     static final int MAX_LOCAL_LENGTH_DIFF = 4;
 171 
 172     /** Get the ClassWriter instance for this context. */
 173     public static ClassWriter instance(Context context) {
 174         ClassWriter instance = context.get(classWriterKey);
 175         if (instance == null)
 176             instance = new ClassWriter(context);
 177         return instance;
 178     }
 179 
 180     /** Construct a class writer, given an options table.
 181      */
 182     protected ClassWriter(Context context) {
 183         context.put(classWriterKey, this);
 184 
 185         log = Log.instance(context);
 186         names = Names.instance(context);
 187         options = Options.instance(context);
 188         preview = Preview.instance(context);
 189         target = Target.instance(context);
 190         source = Source.instance(context);
 191         types = Types.instance(context);
 192         check = Check.instance(context);
 193         fileManager = context.get(JavaFileManager.class);
<span class="line-modified"> 194         signatureGen = new CWSignatureGenerator(types);</span>
 195 
 196         verbose        = options.isSet(VERBOSE);
 197         genCrt         = options.isSet(XJCOV);
 198         debugstackmap = options.isSet(&quot;debug.stackmap&quot;);
 199 
 200         emitSourceFile = options.isUnset(G_CUSTOM) ||
 201                             options.isSet(G_CUSTOM, &quot;source&quot;);
 202 
 203         String modifierFlags = options.get(&quot;debug.dumpmodifiers&quot;);
 204         if (modifierFlags != null) {
 205             dumpClassModifiers = modifierFlags.indexOf(&#39;c&#39;) != -1;
 206             dumpFieldModifiers = modifierFlags.indexOf(&#39;f&#39;) != -1;
 207             dumpInnerClassModifiers = modifierFlags.indexOf(&#39;i&#39;) != -1;
 208             dumpMethodModifiers = modifierFlags.indexOf(&#39;m&#39;) != -1;
 209         }
 210     }
 211 




 212 /******************************************************************
 213  * Diagnostics: dump generated class names and modifiers
 214  ******************************************************************/
 215 
 216     /** Value of option &#39;dumpmodifiers&#39; is a string
 217      *  indicating which modifiers should be dumped for debugging:
 218      *    &#39;c&#39; -- classes
 219      *    &#39;f&#39; -- fields
 220      *    &#39;i&#39; -- innerclass attributes
 221      *    &#39;m&#39; -- methods
 222      *  For example, to dump everything:
 223      *    javac -XDdumpmodifiers=cifm MyProg.java
 224      */
 225     private boolean dumpClassModifiers; // -XDdumpmodifiers=c
 226     private boolean dumpFieldModifiers; // -XDdumpmodifiers=f
 227     private boolean dumpInnerClassModifiers; // -XDdumpmodifiers=i
 228     private boolean dumpMethodModifiers; // -XDdumpmodifiers=m
 229 
 230 
 231     /** Return flags as a string, separated by &quot; &quot;.
</pre>
<hr />
<pre>
 255  ******************************************************************/
 256 
 257     /** Write a character into given byte buffer;
 258      *  byte buffer will not be grown.
 259      */
 260     void putChar(ByteBuffer buf, int op, int x) {
 261         buf.elems[op  ] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 262         buf.elems[op+1] = (byte)((x      ) &amp; 0xFF);
 263     }
 264 
 265     /** Write an integer into given byte buffer;
 266      *  byte buffer will not be grown.
 267      */
 268     void putInt(ByteBuffer buf, int adr, int x) {
 269         buf.elems[adr  ] = (byte)((x &gt;&gt; 24) &amp; 0xFF);
 270         buf.elems[adr+1] = (byte)((x &gt;&gt; 16) &amp; 0xFF);
 271         buf.elems[adr+2] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 272         buf.elems[adr+3] = (byte)((x      ) &amp; 0xFF);
 273     }
 274 
<span class="line-removed"> 275     /**</span>
<span class="line-removed"> 276      * Signature Generation</span>
<span class="line-removed"> 277      */</span>
<span class="line-removed"> 278     private class CWSignatureGenerator extends Types.SignatureGenerator {</span>
<span class="line-removed"> 279 </span>
<span class="line-removed"> 280         /**</span>
<span class="line-removed"> 281          * An output buffer for type signatures.</span>
<span class="line-removed"> 282          */</span>
<span class="line-removed"> 283         ByteBuffer sigbuf = new ByteBuffer();</span>
<span class="line-removed"> 284 </span>
<span class="line-removed"> 285         CWSignatureGenerator(Types types) {</span>
<span class="line-removed"> 286             super(types);</span>
<span class="line-removed"> 287         }</span>
<span class="line-removed"> 288 </span>
<span class="line-removed"> 289         /**</span>
<span class="line-removed"> 290          * Assemble signature of given type in string buffer.</span>
<span class="line-removed"> 291          * Check for uninitialized types before calling the general case.</span>
<span class="line-removed"> 292          */</span>
<span class="line-removed"> 293         @Override</span>
<span class="line-removed"> 294         public void assembleSig(Type type) {</span>
<span class="line-removed"> 295             switch (type.getTag()) {</span>
<span class="line-removed"> 296                 case UNINITIALIZED_THIS:</span>
<span class="line-removed"> 297                 case UNINITIALIZED_OBJECT:</span>
<span class="line-removed"> 298                     // we don&#39;t yet have a spec for uninitialized types in the</span>
<span class="line-removed"> 299                     // local variable table</span>
<span class="line-removed"> 300                     assembleSig(types.erasure(((UninitializedType)type).qtype));</span>
<span class="line-removed"> 301                     break;</span>
<span class="line-removed"> 302                 default:</span>
<span class="line-removed"> 303                     super.assembleSig(type);</span>
<span class="line-removed"> 304             }</span>
<span class="line-removed"> 305         }</span>
<span class="line-removed"> 306 </span>
<span class="line-removed"> 307         @Override</span>
<span class="line-removed"> 308         protected void append(char ch) {</span>
<span class="line-removed"> 309             sigbuf.appendByte(ch);</span>
<span class="line-removed"> 310         }</span>
<span class="line-removed"> 311 </span>
<span class="line-removed"> 312         @Override</span>
<span class="line-removed"> 313         protected void append(byte[] ba) {</span>
<span class="line-removed"> 314             sigbuf.appendBytes(ba);</span>
<span class="line-removed"> 315         }</span>
<span class="line-removed"> 316 </span>
<span class="line-removed"> 317         @Override</span>
<span class="line-removed"> 318         protected void append(Name name) {</span>
<span class="line-removed"> 319             sigbuf.appendName(name);</span>
<span class="line-removed"> 320         }</span>
<span class="line-removed"> 321 </span>
<span class="line-removed"> 322         @Override</span>
<span class="line-removed"> 323         protected void classReference(ClassSymbol c) {</span>
<span class="line-removed"> 324             enterInner(c);</span>
<span class="line-removed"> 325         }</span>
<span class="line-removed"> 326 </span>
<span class="line-removed"> 327         private void reset() {</span>
<span class="line-removed"> 328             sigbuf.reset();</span>
<span class="line-removed"> 329         }</span>
<span class="line-removed"> 330 </span>
<span class="line-removed"> 331         private Name toName() {</span>
<span class="line-removed"> 332             return sigbuf.toName(names);</span>
<span class="line-removed"> 333         }</span>
<span class="line-removed"> 334 </span>
<span class="line-removed"> 335         private boolean isEmpty() {</span>
<span class="line-removed"> 336             return sigbuf.length == 0;</span>
<span class="line-removed"> 337         }</span>
<span class="line-removed"> 338     }</span>
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340     /**</span>
<span class="line-removed"> 341      * Return signature of given type</span>
<span class="line-removed"> 342      */</span>
<span class="line-removed"> 343     Name typeSig(Type type) {</span>
<span class="line-removed"> 344         Assert.check(signatureGen.isEmpty());</span>
<span class="line-removed"> 345         //- System.out.println(&quot; ? &quot; + type);</span>
<span class="line-removed"> 346         signatureGen.assembleSig(type);</span>
<span class="line-removed"> 347         Name n = signatureGen.toName();</span>
<span class="line-removed"> 348         signatureGen.reset();</span>
<span class="line-removed"> 349         //- System.out.println(&quot;   &quot; + n);</span>
<span class="line-removed"> 350         return n;</span>
<span class="line-removed"> 351     }</span>
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353     /** Given a type t, return the extended class name of its erasure in</span>
<span class="line-removed"> 354      *  external representation.</span>
<span class="line-removed"> 355      */</span>
<span class="line-removed"> 356     public Name xClassName(Type t) {</span>
<span class="line-removed"> 357         if (t.hasTag(CLASS)) {</span>
<span class="line-removed"> 358             return names.fromUtf(externalize(t.tsym.flatName()));</span>
<span class="line-removed"> 359         } else if (t.hasTag(ARRAY)) {</span>
<span class="line-removed"> 360             return typeSig(types.erasure(t));</span>
<span class="line-removed"> 361         } else {</span>
<span class="line-removed"> 362             throw new AssertionError(&quot;xClassName expects class or array type, got &quot; + t);</span>
<span class="line-removed"> 363         }</span>
<span class="line-removed"> 364     }</span>
<span class="line-removed"> 365 </span>
 366 /******************************************************************
 367  * Writing the Constant Pool
 368  ******************************************************************/
 369 
 370     /** Thrown when the constant pool is over full.
 371      */
<span class="line-modified"> 372     public static class PoolOverflow extends Exception {</span>
 373         private static final long serialVersionUID = 0;
 374         public PoolOverflow() {}
 375     }
<span class="line-modified"> 376     public static class StringOverflow extends Exception {</span>
 377         private static final long serialVersionUID = 0;
 378         public final String value;
 379         public StringOverflow(String s) {
 380             value = s;
 381         }
 382     }
 383 
<span class="line-removed"> 384     /** Write constant pool to pool buffer.</span>
<span class="line-removed"> 385      *  Note: during writing, constant pool</span>
<span class="line-removed"> 386      *  might grow since some parts of constants still need to be entered.</span>
<span class="line-removed"> 387      */</span>
<span class="line-removed"> 388     void writePool(Pool pool) throws PoolOverflow, StringOverflow {</span>
<span class="line-removed"> 389         int poolCountIdx = poolbuf.length;</span>
<span class="line-removed"> 390         poolbuf.appendChar(0);</span>
<span class="line-removed"> 391         int i = 1;</span>
<span class="line-removed"> 392         while (i &lt; pool.pp) {</span>
<span class="line-removed"> 393             Object value = pool.pool[i];</span>
<span class="line-removed"> 394             Assert.checkNonNull(value);</span>
<span class="line-removed"> 395             if (value instanceof Method || value instanceof Variable)</span>
<span class="line-removed"> 396                 value = ((DelegatedSymbol)value).getUnderlyingSymbol();</span>
<span class="line-removed"> 397 </span>
<span class="line-removed"> 398             if (value instanceof MethodSymbol) {</span>
<span class="line-removed"> 399                 MethodSymbol m = (MethodSymbol)value;</span>
<span class="line-removed"> 400                 if (!m.isDynamic()) {</span>
<span class="line-removed"> 401                     poolbuf.appendByte((m.owner.flags() &amp; INTERFACE) != 0</span>
<span class="line-removed"> 402                               ? CONSTANT_InterfaceMethodref</span>
<span class="line-removed"> 403                               : CONSTANT_Methodref);</span>
<span class="line-removed"> 404                     poolbuf.appendChar(pool.put(m.owner));</span>
<span class="line-removed"> 405                     poolbuf.appendChar(pool.put(nameType(m)));</span>
<span class="line-removed"> 406                 } else {</span>
<span class="line-removed"> 407                     //invokedynamic</span>
<span class="line-removed"> 408                     DynamicMethodSymbol dynSym = (DynamicMethodSymbol)m;</span>
<span class="line-removed"> 409                     MethodHandle handle = new MethodHandle(dynSym.bsmKind, dynSym.bsm, types);</span>
<span class="line-removed"> 410                     DynamicMethod.BootstrapMethodsKey key = new DynamicMethod.BootstrapMethodsKey(dynSym, types);</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412                     // Figure out the index for existing BSM; create a new BSM if no key</span>
<span class="line-removed"> 413                     DynamicMethod.BootstrapMethodsValue val = bootstrapMethods.get(key);</span>
<span class="line-removed"> 414                     if (val == null) {</span>
<span class="line-removed"> 415                         int index = bootstrapMethods.size();</span>
<span class="line-removed"> 416                         val = new DynamicMethod.BootstrapMethodsValue(handle, index);</span>
<span class="line-removed"> 417                         bootstrapMethods.put(key, val);</span>
<span class="line-removed"> 418                     }</span>
<span class="line-removed"> 419 </span>
<span class="line-removed"> 420                     //init cp entries</span>
<span class="line-removed"> 421                     pool.put(names.BootstrapMethods);</span>
<span class="line-removed"> 422                     pool.put(handle);</span>
<span class="line-removed"> 423                     for (Object staticArg : dynSym.staticArgs) {</span>
<span class="line-removed"> 424                         pool.put(staticArg);</span>
<span class="line-removed"> 425                     }</span>
<span class="line-removed"> 426                     poolbuf.appendByte(CONSTANT_InvokeDynamic);</span>
<span class="line-removed"> 427                     poolbuf.appendChar(val.index);</span>
<span class="line-removed"> 428                     poolbuf.appendChar(pool.put(nameType(dynSym)));</span>
<span class="line-removed"> 429                 }</span>
<span class="line-removed"> 430             } else if (value instanceof VarSymbol) {</span>
<span class="line-removed"> 431                 VarSymbol v = (VarSymbol)value;</span>
<span class="line-removed"> 432                 poolbuf.appendByte(CONSTANT_Fieldref);</span>
<span class="line-removed"> 433                 poolbuf.appendChar(pool.put(v.owner));</span>
<span class="line-removed"> 434                 poolbuf.appendChar(pool.put(nameType(v)));</span>
<span class="line-removed"> 435             } else if (value instanceof Name) {</span>
<span class="line-removed"> 436                 poolbuf.appendByte(CONSTANT_Utf8);</span>
<span class="line-removed"> 437                 byte[] bs = ((Name)value).toUtf();</span>
<span class="line-removed"> 438                 poolbuf.appendChar(bs.length);</span>
<span class="line-removed"> 439                 poolbuf.appendBytes(bs, 0, bs.length);</span>
<span class="line-removed"> 440                 if (bs.length &gt; Pool.MAX_STRING_LENGTH)</span>
<span class="line-removed"> 441                     throw new StringOverflow(value.toString());</span>
<span class="line-removed"> 442             } else if (value instanceof ClassSymbol) {</span>
<span class="line-removed"> 443                 ClassSymbol c = (ClassSymbol)value;</span>
<span class="line-removed"> 444                 if (c.owner.kind == TYP) pool.put(c.owner);</span>
<span class="line-removed"> 445                 poolbuf.appendByte(CONSTANT_Class);</span>
<span class="line-removed"> 446                 if (c.type.hasTag(ARRAY)) {</span>
<span class="line-removed"> 447                     poolbuf.appendChar(pool.put(typeSig(c.type)));</span>
<span class="line-removed"> 448                 } else {</span>
<span class="line-removed"> 449                     poolbuf.appendChar(pool.put(names.fromUtf(externalize(c.flatname))));</span>
<span class="line-removed"> 450                     enterInner(c);</span>
<span class="line-removed"> 451                 }</span>
<span class="line-removed"> 452             } else if (value instanceof NameAndType) {</span>
<span class="line-removed"> 453                 NameAndType nt = (NameAndType)value;</span>
<span class="line-removed"> 454                 poolbuf.appendByte(CONSTANT_NameandType);</span>
<span class="line-removed"> 455                 poolbuf.appendChar(pool.put(nt.name));</span>
<span class="line-removed"> 456                 poolbuf.appendChar(pool.put(typeSig(nt.uniqueType.type)));</span>
<span class="line-removed"> 457             } else if (value instanceof Integer) {</span>
<span class="line-removed"> 458                 poolbuf.appendByte(CONSTANT_Integer);</span>
<span class="line-removed"> 459                 poolbuf.appendInt(((Integer)value).intValue());</span>
<span class="line-removed"> 460             } else if (value instanceof Long) {</span>
<span class="line-removed"> 461                 poolbuf.appendByte(CONSTANT_Long);</span>
<span class="line-removed"> 462                 poolbuf.appendLong(((Long)value).longValue());</span>
<span class="line-removed"> 463                 i++;</span>
<span class="line-removed"> 464             } else if (value instanceof Float) {</span>
<span class="line-removed"> 465                 poolbuf.appendByte(CONSTANT_Float);</span>
<span class="line-removed"> 466                 poolbuf.appendFloat(((Float)value).floatValue());</span>
<span class="line-removed"> 467             } else if (value instanceof Double) {</span>
<span class="line-removed"> 468                 poolbuf.appendByte(CONSTANT_Double);</span>
<span class="line-removed"> 469                 poolbuf.appendDouble(((Double)value).doubleValue());</span>
<span class="line-removed"> 470                 i++;</span>
<span class="line-removed"> 471             } else if (value instanceof String) {</span>
<span class="line-removed"> 472                 poolbuf.appendByte(CONSTANT_String);</span>
<span class="line-removed"> 473                 poolbuf.appendChar(pool.put(names.fromString((String)value)));</span>
<span class="line-removed"> 474             } else if (value instanceof UniqueType) {</span>
<span class="line-removed"> 475                 Type type = ((UniqueType)value).type;</span>
<span class="line-removed"> 476                 if (type.hasTag(METHOD)) {</span>
<span class="line-removed"> 477                     poolbuf.appendByte(CONSTANT_MethodType);</span>
<span class="line-removed"> 478                     poolbuf.appendChar(pool.put(typeSig((MethodType)type)));</span>
<span class="line-removed"> 479                 } else {</span>
<span class="line-removed"> 480                     Assert.check(type.hasTag(ARRAY));</span>
<span class="line-removed"> 481                     poolbuf.appendByte(CONSTANT_Class);</span>
<span class="line-removed"> 482                     poolbuf.appendChar(pool.put(xClassName(type)));</span>
<span class="line-removed"> 483                 }</span>
<span class="line-removed"> 484             } else if (value instanceof MethodHandle) {</span>
<span class="line-removed"> 485                 MethodHandle ref = (MethodHandle)value;</span>
<span class="line-removed"> 486                 poolbuf.appendByte(CONSTANT_MethodHandle);</span>
<span class="line-removed"> 487                 poolbuf.appendByte(ref.refKind);</span>
<span class="line-removed"> 488                 poolbuf.appendChar(pool.put(ref.refSym));</span>
<span class="line-removed"> 489             } else if (value instanceof ModuleSymbol) {</span>
<span class="line-removed"> 490                 ModuleSymbol m = (ModuleSymbol)value;</span>
<span class="line-removed"> 491                 poolbuf.appendByte(CONSTANT_Module);</span>
<span class="line-removed"> 492                 poolbuf.appendChar(pool.put(m.name));</span>
<span class="line-removed"> 493             } else if (value instanceof PackageSymbol) {</span>
<span class="line-removed"> 494                 PackageSymbol m = (PackageSymbol)value;</span>
<span class="line-removed"> 495                 poolbuf.appendByte(CONSTANT_Package);</span>
<span class="line-removed"> 496                 poolbuf.appendChar(pool.put(names.fromUtf(externalize(m.fullname))));</span>
<span class="line-removed"> 497             } else {</span>
<span class="line-removed"> 498                 Assert.error(&quot;writePool &quot; + value);</span>
<span class="line-removed"> 499             }</span>
<span class="line-removed"> 500             i++;</span>
<span class="line-removed"> 501         }</span>
<span class="line-removed"> 502         if (pool.pp &gt; Pool.MAX_ENTRIES)</span>
<span class="line-removed"> 503             throw new PoolOverflow();</span>
<span class="line-removed"> 504         putChar(poolbuf, poolCountIdx, pool.pp);</span>
<span class="line-removed"> 505     }</span>
<span class="line-removed"> 506 </span>
<span class="line-removed"> 507     /** Given a symbol, return its name-and-type.</span>
<span class="line-removed"> 508      */</span>
<span class="line-removed"> 509     NameAndType nameType(Symbol sym) {</span>
<span class="line-removed"> 510         return new NameAndType(sym.name, sym.externalType(types), types);</span>
<span class="line-removed"> 511         // the NameAndType is generated from a symbol reference, and the</span>
<span class="line-removed"> 512         // adjustment of adding an additional this$n parameter needs to be made.</span>
<span class="line-removed"> 513     }</span>
<span class="line-removed"> 514 </span>
 515 /******************************************************************
 516  * Writing Attributes
 517  ******************************************************************/
 518 
 519     /** Write header for an attribute to data buffer and return
 520      *  position past attribute length index.
 521      */
<span class="line-modified"> 522     int writeAttr(Name attrName) {</span>
<span class="line-modified"> 523         databuf.appendChar(pool.put(attrName));</span>

 524         databuf.appendInt(0);
 525         return databuf.length;
 526     }
 527 
 528     /** Fill in attribute length.
 529      */
<span class="line-modified"> 530     void endAttr(int index) {</span>
 531         putInt(databuf, index - 4, databuf.length - index);
 532     }
 533 
 534     /** Leave space for attribute count and return index for
 535      *  number of attributes field.
 536      */
 537     int beginAttrs() {
 538         databuf.appendChar(0);
 539         return databuf.length;
 540     }
 541 
 542     /** Fill in number of attributes.
 543      */
 544     void endAttrs(int index, int count) {
 545         putChar(databuf, index - 2, count);
 546     }
 547 
 548     /** Write the EnclosingMethod attribute if needed.
 549      *  Returns the number of attributes written (0 or 1).
 550      */
 551     int writeEnclosingMethodAttribute(ClassSymbol c) {
 552         return writeEnclosingMethodAttribute(names.EnclosingMethod, c);
 553     }
 554 
 555     /** Write the EnclosingMethod attribute with a specified name.
 556      *  Returns the number of attributes written (0 or 1).
 557      */
 558     protected int writeEnclosingMethodAttribute(Name attributeName, ClassSymbol c) {
 559         if (c.owner.kind != MTH &amp;&amp; // neither a local class
 560             c.name != names.empty) // nor anonymous
 561             return 0;
 562 
 563         int alenIdx = writeAttr(attributeName);
 564         ClassSymbol enclClass = c.owner.enclClass();
 565         MethodSymbol enclMethod =
 566             (c.owner.type == null // local to init block
 567              || c.owner.kind != MTH) // or member init
 568             ? null
<span class="line-modified"> 569             : (MethodSymbol)c.owner;</span>
<span class="line-modified"> 570         databuf.appendChar(pool.put(enclClass));</span>
<span class="line-modified"> 571         databuf.appendChar(enclMethod == null ? 0 : pool.put(nameType(c.owner)));</span>
 572         endAttr(alenIdx);
 573         return 1;
 574     }
 575 
 576     /** Write flag attributes; return number of attributes written.
 577      */
 578     int writeFlagAttrs(long flags) {
 579         int acount = 0;
 580         if ((flags &amp; DEPRECATED) != 0) {
 581             int alenIdx = writeAttr(names.Deprecated);
 582             endAttr(alenIdx);
 583             acount++;
 584         }
 585         return acount;
 586     }
 587 
 588     /** Write member (field or method) attributes;
 589      *  return number of attributes written.
 590      */
<span class="line-modified"> 591     int writeMemberAttrs(Symbol sym) {</span>
<span class="line-modified"> 592         int acount = writeFlagAttrs(sym.flags());</span>



 593         long flags = sym.flags();
 594         if ((flags &amp; (SYNTHETIC | BRIDGE)) != SYNTHETIC &amp;&amp;
 595             (flags &amp; ANONCONSTR) == 0 &amp;&amp;
 596             (!types.isSameType(sym.type, sym.erasure(types)) ||
<span class="line-modified"> 597              signatureGen.hasTypeVar(sym.type.getThrownTypes()))) {</span>
 598             // note that a local class with captured variables
 599             // will get a signature attribute
 600             int alenIdx = writeAttr(names.Signature);
<span class="line-modified"> 601             databuf.appendChar(pool.put(typeSig(sym.type)));</span>
 602             endAttr(alenIdx);
 603             acount++;
 604         }
 605         acount += writeJavaAnnotations(sym.getRawAttributes());
 606         acount += writeTypeAnnotations(sym.getRawTypeAttributes(), false);
 607         return acount;
 608     }
 609 
 610     /**
 611      * Write method parameter names attribute.
 612      */
 613     int writeMethodParametersAttr(MethodSymbol m) {
 614         MethodType ty = m.externalType(types).asMethodType();
 615         final int allparams = ty.argtypes.size();
 616         if (m.params != null &amp;&amp; allparams != 0) {
 617             final int attrIndex = writeAttr(names.MethodParameters);
 618             databuf.appendByte(allparams);
 619             // Write extra parameters first
 620             for (VarSymbol s : m.extraParams) {
 621                 final int flags =
 622                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 623                     ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified"> 624                 databuf.appendChar(pool.put(s.name));</span>
 625                 databuf.appendChar(flags);
 626             }
 627             // Now write the real parameters
 628             for (VarSymbol s : m.params) {
 629                 final int flags =
 630                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 631                     ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified"> 632                 databuf.appendChar(pool.put(s.name));</span>
 633                 databuf.appendChar(flags);
 634             }
 635             // Now write the captured locals
 636             for (VarSymbol s : m.capturedLocals) {
 637                 final int flags =
 638                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 639                     ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified"> 640                 databuf.appendChar(pool.put(s.name));</span>
 641                 databuf.appendChar(flags);
 642             }
 643             endAttr(attrIndex);
 644             return 1;
 645         } else
 646             return 0;
 647     }
 648 
<span class="line-removed"> 649 </span>
 650     private void writeParamAnnotations(List&lt;VarSymbol&gt; params,
 651                                        RetentionPolicy retention) {

 652         for (VarSymbol s : params) {
 653             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
 654             for (Attribute.Compound a : s.getRawAttributes())
 655                 if (types.getRetention(a) == retention)
 656                     buf.append(a);
 657             databuf.appendChar(buf.length());
 658             for (Attribute.Compound a : buf)
 659                 writeCompoundAttribute(a);
 660         }
 661 
 662     }
 663 
 664     private void writeParamAnnotations(MethodSymbol m,
 665                                        RetentionPolicy retention) {
 666         databuf.appendByte(m.params.length());
 667         writeParamAnnotations(m.params, retention);
 668     }
 669 
 670     /** Write method parameter annotations;
 671      *  return number of attributes written.
 672      */
<span class="line-modified"> 673     int writeParameterAttrs(MethodSymbol m) {</span>
 674         boolean hasVisible = false;
 675         boolean hasInvisible = false;
<span class="line-modified"> 676         if (m.params != null) {</span>
<span class="line-modified"> 677             for (VarSymbol s : m.params) {</span>
 678                 for (Attribute.Compound a : s.getRawAttributes()) {
 679                     switch (types.getRetention(a)) {
 680                     case SOURCE: break;
 681                     case CLASS: hasInvisible = true; break;
 682                     case RUNTIME: hasVisible = true; break;
 683                     default: // /* fail soft */ throw new AssertionError(vis);
 684                     }
 685                 }
 686             }
 687         }
 688 
 689         int attrCount = 0;
 690         if (hasVisible) {
 691             int attrIndex = writeAttr(names.RuntimeVisibleParameterAnnotations);
<span class="line-modified"> 692             writeParamAnnotations(m, RetentionPolicy.RUNTIME);</span>
 693             endAttr(attrIndex);
 694             attrCount++;
 695         }
 696         if (hasInvisible) {
 697             int attrIndex = writeAttr(names.RuntimeInvisibleParameterAnnotations);
<span class="line-modified"> 698             writeParamAnnotations(m, RetentionPolicy.CLASS);</span>
 699             endAttr(attrIndex);
 700             attrCount++;
 701         }
 702         return attrCount;
 703     }
 704 
 705 /**********************************************************************
 706  * Writing Java-language annotations (aka metadata, attributes)
 707  **********************************************************************/
 708 
 709     /** Write Java-language annotations; return number of JVM
 710      *  attributes written (zero or one).
 711      */
 712     int writeJavaAnnotations(List&lt;Attribute.Compound&gt; attrs) {
 713         if (attrs.isEmpty()) return 0;
 714         ListBuffer&lt;Attribute.Compound&gt; visibles = new ListBuffer&lt;&gt;();
 715         ListBuffer&lt;Attribute.Compound&gt; invisibles = new ListBuffer&lt;&gt;();
 716         for (Attribute.Compound a : attrs) {
 717             switch (types.getRetention(a)) {
 718             case SOURCE: break;
</pre>
<hr />
<pre>
 786             attrCount++;
 787         }
 788 
 789         if (invisibles.length() != 0) {
 790             int attrIndex = writeAttr(names.RuntimeInvisibleTypeAnnotations);
 791             databuf.appendChar(invisibles.length());
 792             for (Attribute.TypeCompound p : invisibles)
 793                 writeTypeAnnotation(p);
 794             endAttr(attrIndex);
 795             attrCount++;
 796         }
 797 
 798         return attrCount;
 799     }
 800 
 801     /** A visitor to write an attribute including its leading
 802      *  single-character marker.
 803      */
 804     class AttributeWriter implements Attribute.Visitor {
 805         public void visitConstant(Attribute.Constant _value) {
<span class="line-modified"> 806             Object value = _value.value;</span>
<span class="line-modified"> 807             switch (_value.type.getTag()) {</span>
<span class="line-modified"> 808             case BYTE:</span>
<span class="line-removed"> 809                 databuf.appendByte(&#39;B&#39;);</span>
<span class="line-removed"> 810                 break;</span>
<span class="line-removed"> 811             case CHAR:</span>
<span class="line-removed"> 812                 databuf.appendByte(&#39;C&#39;);</span>
<span class="line-removed"> 813                 break;</span>
<span class="line-removed"> 814             case SHORT:</span>
<span class="line-removed"> 815                 databuf.appendByte(&#39;S&#39;);</span>
<span class="line-removed"> 816                 break;</span>
<span class="line-removed"> 817             case INT:</span>
<span class="line-removed"> 818                 databuf.appendByte(&#39;I&#39;);</span>
<span class="line-removed"> 819                 break;</span>
<span class="line-removed"> 820             case LONG:</span>
<span class="line-removed"> 821                 databuf.appendByte(&#39;J&#39;);</span>
<span class="line-removed"> 822                 break;</span>
<span class="line-removed"> 823             case FLOAT:</span>
<span class="line-removed"> 824                 databuf.appendByte(&#39;F&#39;);</span>
<span class="line-removed"> 825                 break;</span>
<span class="line-removed"> 826             case DOUBLE:</span>
<span class="line-removed"> 827                 databuf.appendByte(&#39;D&#39;);</span>
<span class="line-removed"> 828                 break;</span>
<span class="line-removed"> 829             case BOOLEAN:</span>
<span class="line-removed"> 830                 databuf.appendByte(&#39;Z&#39;);</span>
<span class="line-removed"> 831                 break;</span>
<span class="line-removed"> 832             case CLASS:</span>
<span class="line-removed"> 833                 Assert.check(value instanceof String);</span>
 834                 databuf.appendByte(&#39;s&#39;);
<span class="line-modified"> 835                 value = names.fromString(value.toString()); // CONSTANT_Utf8</span>
<span class="line-modified"> 836                 break;</span>
<span class="line-modified"> 837             default:</span>
<span class="line-modified"> 838                 throw new AssertionError(_value.type);</span>



























 839             }
<span class="line-removed"> 840             databuf.appendChar(pool.put(value));</span>
 841         }
 842         public void visitEnum(Attribute.Enum e) {
 843             databuf.appendByte(&#39;e&#39;);
<span class="line-modified"> 844             databuf.appendChar(pool.put(typeSig(e.value.type)));</span>
<span class="line-modified"> 845             databuf.appendChar(pool.put(e.value.name));</span>
 846         }
 847         public void visitClass(Attribute.Class clazz) {
 848             databuf.appendByte(&#39;c&#39;);
<span class="line-modified"> 849             databuf.appendChar(pool.put(typeSig(types.erasure(clazz.classType))));</span>
 850         }
 851         public void visitCompound(Attribute.Compound compound) {
 852             databuf.appendByte(&#39;@&#39;);
 853             writeCompoundAttribute(compound);
 854         }
 855         public void visitError(Attribute.Error x) {
 856             throw new AssertionError(x);
 857         }
 858         public void visitArray(Attribute.Array array) {
 859             databuf.appendByte(&#39;[&#39;);
 860             databuf.appendChar(array.values.length);
 861             for (Attribute a : array.values) {
 862                 a.accept(this);
 863             }
 864         }
 865     }
 866     AttributeWriter awriter = new AttributeWriter();
 867 
 868     /** Write a compound attribute excluding the &#39;@&#39; marker. */
 869     void writeCompoundAttribute(Attribute.Compound c) {
<span class="line-modified"> 870         databuf.appendChar(pool.put(typeSig(c.type)));</span>
 871         databuf.appendChar(c.values.length());
 872         for (Pair&lt;Symbol.MethodSymbol,Attribute&gt; p : c.values) {
<span class="line-modified"> 873             databuf.appendChar(pool.put(p.fst.name));</span>
 874             p.snd.accept(awriter);
 875         }
 876     }
 877 
 878     void writeTypeAnnotation(Attribute.TypeCompound c) {
 879         writePosition(c.position);
 880         writeCompoundAttribute(c);
 881     }
 882 
 883     void writePosition(TypeAnnotationPosition p) {
 884         databuf.appendByte(p.type.targetTypeValue()); // TargetType tag is a byte
 885         switch (p.type) {
 886         // instanceof
 887         case INSTANCEOF:
 888         // new expression
 889         case NEW:
 890         // constructor/method reference receiver
 891         case CONSTRUCTOR_REFERENCE:
 892         case METHOD_REFERENCE:
 893             databuf.appendChar(p.offset);
</pre>
<hr />
<pre>
 957         { // Append location data for generics/arrays.
 958             databuf.appendByte(p.location.size());
 959             java.util.List&lt;Integer&gt; loc = TypeAnnotationPosition.getBinaryFromTypePath(p.location);
 960             for (int i : loc)
 961                 databuf.appendByte((byte)i);
 962         }
 963     }
 964 
 965 /**********************************************************************
 966  * Writing module attributes
 967  **********************************************************************/
 968 
 969     /** Write the Module attribute if needed.
 970      *  Returns the number of attributes written (0 or 1).
 971      */
 972     int writeModuleAttribute(ClassSymbol c) {
 973         ModuleSymbol m = (ModuleSymbol) c.owner;
 974 
 975         int alenIdx = writeAttr(names.Module);
 976 
<span class="line-modified"> 977         databuf.appendChar(pool.put(m));</span>
 978         databuf.appendChar(ModuleFlags.value(m.flags)); // module_flags
<span class="line-modified"> 979         databuf.appendChar(m.version != null ? pool.put(m.version) : 0);</span>
 980 
 981         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
 982         for (RequiresDirective r: m.requires) {
 983             if (!r.flags.contains(RequiresFlag.EXTRA))
 984                 requires.add(r);
 985         }
 986         databuf.appendChar(requires.size());
 987         for (RequiresDirective r: requires) {
<span class="line-modified"> 988             databuf.appendChar(pool.put(r.module));</span>
 989             databuf.appendChar(RequiresFlag.value(r.flags));
<span class="line-modified"> 990             databuf.appendChar(r.module.version != null ? pool.put(r.module.version) : 0);</span>
 991         }
 992 
 993         List&lt;ExportsDirective&gt; exports = m.exports;
 994         databuf.appendChar(exports.size());
 995         for (ExportsDirective e: exports) {
<span class="line-modified"> 996             databuf.appendChar(pool.put(e.packge));</span>
 997             databuf.appendChar(ExportsFlag.value(e.flags));
 998             if (e.modules == null) {
 999                 databuf.appendChar(0);
1000             } else {
1001                 databuf.appendChar(e.modules.size());
1002                 for (ModuleSymbol msym: e.modules) {
<span class="line-modified">1003                     databuf.appendChar(pool.put(msym));</span>
1004                 }
1005             }
1006         }
1007 
1008         List&lt;OpensDirective&gt; opens = m.opens;
1009         databuf.appendChar(opens.size());
1010         for (OpensDirective o: opens) {
<span class="line-modified">1011             databuf.appendChar(pool.put(o.packge));</span>
1012             databuf.appendChar(OpensFlag.value(o.flags));
1013             if (o.modules == null) {
1014                 databuf.appendChar(0);
1015             } else {
1016                 databuf.appendChar(o.modules.size());
1017                 for (ModuleSymbol msym: o.modules) {
<span class="line-modified">1018                     databuf.appendChar(pool.put(msym));</span>
1019                 }
1020             }
1021         }
1022 
1023         List&lt;UsesDirective&gt; uses = m.uses;
1024         databuf.appendChar(uses.size());
1025         for (UsesDirective s: uses) {
<span class="line-modified">1026             databuf.appendChar(pool.put(s.service));</span>
1027         }
1028 
1029         // temporary fix to merge repeated provides clause for same service;
1030         // eventually this should be disallowed when analyzing the module,
1031         // so that each service type only appears once.
1032         Map&lt;ClassSymbol, Set&lt;ClassSymbol&gt;&gt; mergedProvides = new LinkedHashMap&lt;&gt;();
1033         for (ProvidesDirective p : m.provides) {
1034             mergedProvides.computeIfAbsent(p.service, s -&gt; new LinkedHashSet&lt;&gt;()).addAll(p.impls);
1035         }
1036         databuf.appendChar(mergedProvides.size());
1037         mergedProvides.forEach((srvc, impls) -&gt; {
<span class="line-modified">1038             databuf.appendChar(pool.put(srvc));</span>
1039             databuf.appendChar(impls.size());
<span class="line-modified">1040             impls.forEach(impl -&gt; databuf.appendChar(pool.put(impl)));</span>
1041         });
1042 
1043         endAttr(alenIdx);
1044         return 1;
1045     }
1046 
1047 /**********************************************************************
1048  * Writing Objects
1049  **********************************************************************/
1050 
<span class="line-removed">1051     /** Enter an inner class into the `innerClasses&#39; set/queue.</span>
<span class="line-removed">1052      */</span>
<span class="line-removed">1053     void enterInner(ClassSymbol c) {</span>
<span class="line-removed">1054         if (c.type.isCompound()) {</span>
<span class="line-removed">1055             throw new AssertionError(&quot;Unexpected intersection type: &quot; + c.type);</span>
<span class="line-removed">1056         }</span>
<span class="line-removed">1057         try {</span>
<span class="line-removed">1058             c.complete();</span>
<span class="line-removed">1059         } catch (CompletionFailure ex) {</span>
<span class="line-removed">1060             System.err.println(&quot;error: &quot; + c + &quot;: &quot; + ex.getMessage());</span>
<span class="line-removed">1061             throw ex;</span>
<span class="line-removed">1062         }</span>
<span class="line-removed">1063         if (!c.type.hasTag(CLASS)) return; // arrays</span>
<span class="line-removed">1064         if (pool != null &amp;&amp; // pool might be null if called from xClassName</span>
<span class="line-removed">1065             c.owner.enclClass() != null &amp;&amp;</span>
<span class="line-removed">1066             (innerClasses == null || !innerClasses.contains(c))) {</span>
<span class="line-removed">1067 //          log.errWriter.println(&quot;enter inner &quot; + c);//DEBUG</span>
<span class="line-removed">1068             enterInner(c.owner.enclClass());</span>
<span class="line-removed">1069             pool.put(c);</span>
<span class="line-removed">1070             if (c.name != names.empty)</span>
<span class="line-removed">1071                 pool.put(c.name);</span>
<span class="line-removed">1072             if (innerClasses == null) {</span>
<span class="line-removed">1073                 innerClasses = new HashSet&lt;&gt;();</span>
<span class="line-removed">1074                 innerClassesQueue = new ListBuffer&lt;&gt;();</span>
<span class="line-removed">1075                 pool.put(names.InnerClasses);</span>
<span class="line-removed">1076             }</span>
<span class="line-removed">1077             innerClasses.add(c);</span>
<span class="line-removed">1078             innerClassesQueue.append(c);</span>
<span class="line-removed">1079         }</span>
<span class="line-removed">1080     }</span>
<span class="line-removed">1081 </span>
1082     /** Write &quot;inner classes&quot; attribute.
1083      */
1084     void writeInnerClasses() {
1085         int alenIdx = writeAttr(names.InnerClasses);
<span class="line-modified">1086         databuf.appendChar(innerClassesQueue.length());</span>
<span class="line-modified">1087         for (List&lt;ClassSymbol&gt; l = innerClassesQueue.toList();</span>
<span class="line-removed">1088              l.nonEmpty();</span>
<span class="line-removed">1089              l = l.tail) {</span>
<span class="line-removed">1090             ClassSymbol inner = l.head;</span>
1091             inner.markAbstractIfNeeded(types);
1092             char flags = (char) adjustFlags(inner.flags_field);
1093             if ((flags &amp; INTERFACE) != 0) flags |= ABSTRACT; // Interfaces are always ABSTRACT
1094             flags &amp;= ~STRICTFP; //inner classes should not have the strictfp flag set.
1095             if (dumpInnerClassModifiers) {
1096                 PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
1097                 pw.println(&quot;INNERCLASS  &quot; + inner.name);
1098                 pw.println(&quot;---&quot; + flagNames(flags));
1099             }
<span class="line-modified">1100             databuf.appendChar(pool.get(inner));</span>
1101             databuf.appendChar(
<span class="line-modified">1102                 inner.owner.kind == TYP &amp;&amp; !inner.name.isEmpty() ? pool.get(inner.owner) : 0);</span>
1103             databuf.appendChar(
<span class="line-modified">1104                 !inner.name.isEmpty() ? pool.get(inner.name) : 0);</span>
1105             databuf.appendChar(flags);
1106         }
1107         endAttr(alenIdx);
1108     }
1109 

















1110     /**
1111      * Write NestMembers attribute (if needed)
1112      */
1113     int writeNestMembersIfNeeded(ClassSymbol csym) {
<span class="line-modified">1114         ListBuffer&lt;Symbol&gt; nested = new ListBuffer&lt;&gt;();</span>
1115         listNested(csym, nested);
<span class="line-modified">1116         Set&lt;Symbol&gt; nestedUnique = new LinkedHashSet&lt;&gt;(nested);</span>
1117         if (csym.owner.kind == PCK &amp;&amp; !nestedUnique.isEmpty()) {
1118             int alenIdx = writeAttr(names.NestMembers);
1119             databuf.appendChar(nestedUnique.size());
<span class="line-modified">1120             for (Symbol s : nestedUnique) {</span>
<span class="line-modified">1121                 databuf.appendChar(pool.put(s));</span>
1122             }
1123             endAttr(alenIdx);
1124             return 1;
1125         }
1126         return 0;
1127     }
1128 
1129     /**
1130      * Write NestHost attribute (if needed)
1131      */
1132     int writeNestHostIfNeeded(ClassSymbol csym) {
1133         if (csym.owner.kind != PCK) {
1134             int alenIdx = writeAttr(names.NestHost);
<span class="line-modified">1135             databuf.appendChar(pool.put(csym.outermostClass()));</span>
1136             endAttr(alenIdx);
1137             return 1;
1138         }
1139         return 0;
1140     }
1141 
<span class="line-modified">1142     private void listNested(Symbol sym, ListBuffer&lt;Symbol&gt; seen) {</span>
1143         if (sym.kind != TYP) return;
1144         ClassSymbol csym = (ClassSymbol)sym;
1145         if (csym.owner.kind != PCK) {
1146             seen.add(csym);
1147         }
1148         if (csym.members() != null) {
1149             for (Symbol s : sym.members().getSymbols()) {
1150                 listNested(s, seen);
1151             }
1152         }
1153         if (csym.trans_local != null) {
1154             for (Symbol s : csym.trans_local) {
1155                 listNested(s, seen);
1156             }
1157         }
1158     }
1159 
1160     /** Write &quot;bootstrapMethods&quot; attribute.
1161      */
1162     void writeBootstrapMethods() {
1163         int alenIdx = writeAttr(names.BootstrapMethods);
<span class="line-modified">1164         databuf.appendChar(bootstrapMethods.size());</span>
<span class="line-modified">1165         for (Map.Entry&lt;DynamicMethod.BootstrapMethodsKey, DynamicMethod.BootstrapMethodsValue&gt; entry : bootstrapMethods.entrySet()) {</span>
<span class="line-removed">1166             DynamicMethod.BootstrapMethodsKey bsmKey = entry.getKey();</span>
1167             //write BSM handle
<span class="line-modified">1168             databuf.appendChar(pool.get(entry.getValue().mh));</span>
<span class="line-modified">1169             Object[] uniqueArgs = bsmKey.getUniqueArgs();</span>
1170             //write static args length
1171             databuf.appendChar(uniqueArgs.length);
1172             //write static args array
<span class="line-modified">1173             for (Object o : uniqueArgs) {</span>
<span class="line-modified">1174                 databuf.appendChar(pool.get(o));</span>
1175             }
1176         }
1177         endAttr(alenIdx);
1178     }
1179 
1180     /** Write field symbol, entering all references into constant pool.
1181      */
1182     void writeField(VarSymbol v) {
1183         int flags = adjustFlags(v.flags());
1184         databuf.appendChar(flags);
1185         if (dumpFieldModifiers) {
1186             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
1187             pw.println(&quot;FIELD  &quot; + v.name);
1188             pw.println(&quot;---&quot; + flagNames(v.flags()));
1189         }
<span class="line-modified">1190         databuf.appendChar(pool.put(v.name));</span>
<span class="line-modified">1191         databuf.appendChar(pool.put(typeSig(v.erasure(types))));</span>
1192         int acountIdx = beginAttrs();
1193         int acount = 0;
1194         if (v.getConstValue() != null) {
1195             int alenIdx = writeAttr(names.ConstantValue);
<span class="line-modified">1196             databuf.appendChar(pool.put(v.getConstValue()));</span>
1197             endAttr(alenIdx);
1198             acount++;
1199         }
<span class="line-modified">1200         acount += writeMemberAttrs(v);</span>

1201         endAttrs(acountIdx, acount);
1202     }
1203 
1204     /** Write method symbol, entering all references into constant pool.
1205      */
1206     void writeMethod(MethodSymbol m) {
1207         int flags = adjustFlags(m.flags());
1208         databuf.appendChar(flags);
1209         if (dumpMethodModifiers) {
1210             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
1211             pw.println(&quot;METHOD  &quot; + m.name);
1212             pw.println(&quot;---&quot; + flagNames(m.flags()));
1213         }
<span class="line-modified">1214         databuf.appendChar(pool.put(m.name));</span>
<span class="line-modified">1215         databuf.appendChar(pool.put(typeSig(m.externalType(types))));</span>
1216         int acountIdx = beginAttrs();
1217         int acount = 0;
1218         if (m.code != null) {
1219             int alenIdx = writeAttr(names.Code);
1220             writeCode(m.code);
1221             m.code = null; // to conserve space
1222             endAttr(alenIdx);
1223             acount++;
1224         }
1225         List&lt;Type&gt; thrown = m.erasure(types).getThrownTypes();
1226         if (thrown.nonEmpty()) {
1227             int alenIdx = writeAttr(names.Exceptions);
1228             databuf.appendChar(thrown.length());
1229             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
<span class="line-modified">1230                 databuf.appendChar(pool.put(l.head.tsym));</span>
1231             endAttr(alenIdx);
1232             acount++;
1233         }
1234         if (m.defaultValue != null) {
1235             int alenIdx = writeAttr(names.AnnotationDefault);
1236             m.defaultValue.accept(awriter);
1237             endAttr(alenIdx);
1238             acount++;
1239         }
<span class="line-modified">1240         if (options.isSet(PARAMETERS) &amp;&amp; target.hasMethodParameters()) {</span>
1241             if (!m.isLambdaMethod()) // Per JDK-8138729, do not emit parameters table for lambda bodies.
1242                 acount += writeMethodParametersAttr(m);
1243         }
<span class="line-modified">1244         acount += writeMemberAttrs(m);</span>
1245         if (!m.isLambdaMethod())
<span class="line-modified">1246             acount += writeParameterAttrs(m);</span>

1247         endAttrs(acountIdx, acount);
1248     }
1249 
1250     /** Write code attribute of method.
1251      */
1252     void writeCode(Code code) {
1253         databuf.appendChar(code.max_stack);
1254         databuf.appendChar(code.max_locals);
1255         databuf.appendInt(code.cp);
1256         databuf.appendBytes(code.code, 0, code.cp);
1257         databuf.appendChar(code.catchInfo.length());
1258         for (List&lt;char[]&gt; l = code.catchInfo.toList();
1259              l.nonEmpty();
1260              l = l.tail) {
1261             for (int i = 0; i &lt; l.head.length; i++)
1262                 databuf.appendChar(l.head[i]);
1263         }
1264         int acountIdx = beginAttrs();
1265         int acount = 0;
1266 
</pre>
<hr />
<pre>
1286             acount++;
1287         }
1288 
1289         // counter for number of generic local variables
1290         if (code.varDebugInfo &amp;&amp; code.varBufferSize &gt; 0) {
1291             int nGenericVars = 0;
1292             int alenIdx = writeAttr(names.LocalVariableTable);
1293             databuf.appendChar(code.getLVTSize());
1294             for (int i=0; i&lt;code.varBufferSize; i++) {
1295                 Code.LocalVar var = code.varBuffer[i];
1296 
1297                 for (Code.LocalVar.Range r: var.aliveRanges) {
1298                     // write variable info
1299                     Assert.check(r.start_pc &gt;= 0
1300                             &amp;&amp; r.start_pc &lt;= code.cp);
1301                     databuf.appendChar(r.start_pc);
1302                     Assert.check(r.length &gt; 0
1303                             &amp;&amp; (r.start_pc + r.length) &lt;= code.cp);
1304                     databuf.appendChar(r.length);
1305                     VarSymbol sym = var.sym;
<span class="line-modified">1306                     databuf.appendChar(pool.put(sym.name));</span>
<span class="line-modified">1307                     Type vartype = sym.erasure(types);</span>
<span class="line-removed">1308                     databuf.appendChar(pool.put(typeSig(vartype)));</span>
1309                     databuf.appendChar(var.reg);
1310                     if (needsLocalVariableTypeEntry(var.sym.type)) {
1311                         nGenericVars++;
1312                     }
1313                 }
1314             }
1315             endAttr(alenIdx);
1316             acount++;
1317 
1318             if (nGenericVars &gt; 0) {
1319                 alenIdx = writeAttr(names.LocalVariableTypeTable);
1320                 databuf.appendChar(nGenericVars);
1321                 int count = 0;
1322 
1323                 for (int i=0; i&lt;code.varBufferSize; i++) {
1324                     Code.LocalVar var = code.varBuffer[i];
1325                     VarSymbol sym = var.sym;
1326                     if (!needsLocalVariableTypeEntry(sym.type))
1327                         continue;
1328                     for (Code.LocalVar.Range r : var.aliveRanges) {
1329                         // write variable info
1330                         databuf.appendChar(r.start_pc);
1331                         databuf.appendChar(r.length);
<span class="line-modified">1332                         databuf.appendChar(pool.put(sym.name));</span>
<span class="line-modified">1333                         databuf.appendChar(pool.put(typeSig(sym.type)));</span>
1334                         databuf.appendChar(var.reg);
1335                         count++;
1336                     }
1337                 }
1338                 Assert.check(count == nGenericVars);
1339                 endAttr(alenIdx);
1340                 acount++;
1341             }
1342         }
1343 
1344         if (code.stackMapBufferSize &gt; 0) {
1345             if (debugstackmap) System.out.println(&quot;Stack map for &quot; + code.meth);
1346             int alenIdx = writeAttr(code.stackMap.getAttributeName(names));
1347             writeStackMap(code);
1348             endAttr(alenIdx);
1349             acount++;
1350         }
1351 
1352         acount += writeTypeAnnotations(code.meth.getRawTypeAttributes(), true);
1353 
</pre>
<hr />
<pre>
1440                 databuf.appendByte(1);
1441                 break;
1442             case FLOAT:
1443                 if (debugstackmap) System.out.print(&quot;float&quot;);
1444                 databuf.appendByte(2);
1445                 break;
1446             case DOUBLE:
1447                 if (debugstackmap) System.out.print(&quot;double&quot;);
1448                 databuf.appendByte(3);
1449                 break;
1450             case LONG:
1451                 if (debugstackmap) System.out.print(&quot;long&quot;);
1452                 databuf.appendByte(4);
1453                 break;
1454             case BOT: // null
1455                 if (debugstackmap) System.out.print(&quot;null&quot;);
1456                 databuf.appendByte(5);
1457                 break;
1458             case CLASS:
1459             case ARRAY:
<span class="line-removed">1460                 if (debugstackmap) System.out.print(&quot;object(&quot; + t + &quot;)&quot;);</span>
<span class="line-removed">1461                 databuf.appendByte(7);</span>
<span class="line-removed">1462                 databuf.appendChar(pool.put(t));</span>
<span class="line-removed">1463                 break;</span>
1464             case TYPEVAR:
1465                 if (debugstackmap) System.out.print(&quot;object(&quot; + types.erasure(t).tsym + &quot;)&quot;);
1466                 databuf.appendByte(7);
<span class="line-modified">1467                 databuf.appendChar(pool.put(types.erasure(t).tsym));</span>
1468                 break;
1469             case UNINITIALIZED_THIS:
1470                 if (debugstackmap) System.out.print(&quot;uninit_this&quot;);
1471                 databuf.appendByte(6);
1472                 break;
1473             case UNINITIALIZED_OBJECT:
1474                 { UninitializedType uninitType = (UninitializedType)t;
1475                 databuf.appendByte(8);
1476                 if (debugstackmap) System.out.print(&quot;uninit_object@&quot; + uninitType.offset);
1477                 databuf.appendChar(uninitType.offset);
1478                 }
1479                 break;
1480             default:
1481                 throw new AssertionError();
1482             }
1483         }
1484 
1485     /** An entry in the JSR202 StackMapTable */
1486     abstract static class StackMapTableFrame {
1487         abstract int getFrameType();
</pre>
<hr />
<pre>
1746         } catch (InvalidSignatureException ex) {
1747             log.error(Errors.CannotGenerateClass(c, Fragments.IllegalSignature(c, ex.type())));
1748         } finally {
1749             if (out != null) {
1750                 // if we are propagating an exception, delete the file
1751                 out.close();
1752                 outFile.delete();
1753                 outFile = null;
1754             }
1755         }
1756         return outFile; // may be null if write failed
1757     }
1758 
1759     /** Write class `c&#39; to outstream `out&#39;.
1760      */
1761     public void writeClassFile(OutputStream out, ClassSymbol c)
1762         throws IOException, PoolOverflow, StringOverflow {
1763         Assert.check((c.flags() &amp; COMPOUND) == 0);
1764         databuf.reset();
1765         poolbuf.reset();
<span class="line-removed">1766         signatureGen.reset();</span>
<span class="line-removed">1767         pool = c.pool;</span>
<span class="line-removed">1768         innerClasses = null;</span>
<span class="line-removed">1769         innerClassesQueue = null;</span>
<span class="line-removed">1770         bootstrapMethods = new LinkedHashMap&lt;&gt;();</span>
1771 
1772         Type supertype = types.supertype(c.type);
1773         List&lt;Type&gt; interfaces = types.interfaces(c.type);
1774         List&lt;Type&gt; typarams = c.type.getTypeArguments();
1775 
1776         int flags;
1777         if (c.owner.kind == MDL) {
1778             flags = ACC_MODULE;
1779         } else {
1780             flags = adjustFlags(c.flags() &amp; ~DEFAULT);
1781             if ((flags &amp; PROTECTED) != 0) flags |= PUBLIC;
1782             flags = flags &amp; ClassFlags &amp; ~STRICTFP;
1783             if ((flags &amp; INTERFACE) == 0) flags |= ACC_SUPER;
1784         }
1785 
1786         if (dumpClassModifiers) {
1787             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
1788             pw.println();
1789             pw.println(&quot;CLASSFILE  &quot; + c.getQualifiedName());
1790             pw.println(&quot;---&quot; + flagNames(flags));
1791         }
1792         databuf.appendChar(flags);
1793 
1794         if (c.owner.kind == MDL) {
1795             PackageSymbol unnamed = ((ModuleSymbol) c.owner).unnamedPackage;
<span class="line-modified">1796             databuf.appendChar(pool.put(new ClassSymbol(0, names.module_info, unnamed)));</span>
1797         } else {
<span class="line-modified">1798             databuf.appendChar(pool.put(c));</span>
1799         }
<span class="line-modified">1800         databuf.appendChar(supertype.hasTag(CLASS) ? pool.put(supertype.tsym) : 0);</span>
1801         databuf.appendChar(interfaces.length());
1802         for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)
<span class="line-modified">1803             databuf.appendChar(pool.put(l.head.tsym));</span>
1804         int fieldsCount = 0;
1805         int methodsCount = 0;
1806         for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
1807             switch (sym.kind) {
1808             case VAR: fieldsCount++; break;
1809             case MTH: if ((sym.flags() &amp; HYPOTHETICAL) == 0) methodsCount++;
1810                       break;
<span class="line-modified">1811             case TYP: enterInner((ClassSymbol)sym); break;</span>
1812             default : Assert.error();
1813             }
1814         }
1815 
1816         if (c.trans_local != null) {
1817             for (ClassSymbol local : c.trans_local) {
<span class="line-modified">1818                 enterInner(local);</span>
1819             }
1820         }
1821 
1822         databuf.appendChar(fieldsCount);
1823         writeFields(c.members());
1824         databuf.appendChar(methodsCount);
1825         writeMethods(c.members());
1826 
1827         int acountIdx = beginAttrs();
1828         int acount = 0;
1829 
1830         boolean sigReq =
1831             typarams.length() != 0 || supertype.allparams().length() != 0;
1832         for (List&lt;Type&gt; l = interfaces; !sigReq &amp;&amp; l.nonEmpty(); l = l.tail)
1833             sigReq = l.head.allparams().length() != 0;
1834         if (sigReq) {
1835             int alenIdx = writeAttr(names.Signature);
<span class="line-modified">1836             if (typarams.length() != 0) signatureGen.assembleParamsSig(typarams);</span>
<span class="line-removed">1837             signatureGen.assembleSig(supertype);</span>
<span class="line-removed">1838             for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)</span>
<span class="line-removed">1839                 signatureGen.assembleSig(l.head);</span>
<span class="line-removed">1840             databuf.appendChar(pool.put(signatureGen.toName()));</span>
<span class="line-removed">1841             signatureGen.reset();</span>
1842             endAttr(alenIdx);
1843             acount++;
1844         }
1845 
1846         if (c.sourcefile != null &amp;&amp; emitSourceFile) {
1847             int alenIdx = writeAttr(names.SourceFile);
1848             // WHM 6/29/1999: Strip file path prefix.  We do it here at
1849             // the last possible moment because the sourcefile may be used
1850             // elsewhere in error diagnostics. Fixes 4241573.
<span class="line-removed">1851             //databuf.appendChar(c.pool.put(c.sourcefile));</span>
1852             String simpleName = PathFileObject.getSimpleName(c.sourcefile);
<span class="line-modified">1853             databuf.appendChar(c.pool.put(names.fromString(simpleName)));</span>
1854             endAttr(alenIdx);
1855             acount++;
1856         }
1857 
1858         if (genCrt) {
1859             // Append SourceID attribute
1860             int alenIdx = writeAttr(names.SourceID);
<span class="line-modified">1861             databuf.appendChar(c.pool.put(names.fromString(Long.toString(getLastModified(c.sourcefile)))));</span>
1862             endAttr(alenIdx);
1863             acount++;
1864             // Append CompilationID attribute
1865             alenIdx = writeAttr(names.CompilationID);
<span class="line-modified">1866             databuf.appendChar(c.pool.put(names.fromString(Long.toString(System.currentTimeMillis()))));</span>
1867             endAttr(alenIdx);
1868             acount++;
1869         }
1870 
1871         acount += writeFlagAttrs(c.flags());
1872         acount += writeJavaAnnotations(c.getRawAttributes());
1873         acount += writeTypeAnnotations(c.getRawTypeAttributes(), false);
1874         acount += writeEnclosingMethodAttribute(c);
1875         if (c.owner.kind == MDL) {
1876             acount += writeModuleAttribute(c);
1877             acount += writeFlagAttrs(c.owner.flags() &amp; ~DEPRECATED);
1878         }
1879         acount += writeExtraClassAttributes(c);

1880 
1881         poolbuf.appendInt(JAVA_MAGIC);
1882         if (preview.isEnabled()) {
1883             poolbuf.appendChar(ClassFile.PREVIEW_MINOR_VERSION);
1884         } else {
1885             poolbuf.appendChar(target.minorVersion);
1886         }
1887         poolbuf.appendChar(target.majorVersion);
1888 
1889         if (c.owner.kind != MDL) {
1890             if (target.hasNestmateAccess()) {
1891                 acount += writeNestMembersIfNeeded(c);
1892                 acount += writeNestHostIfNeeded(c);
1893             }
1894         }
1895 
<span class="line-modified">1896         writePool(c.pool);</span>


1897 
<span class="line-modified">1898         if (innerClasses != null) {</span>
<span class="line-modified">1899             writeInnerClasses();</span>
1900             acount++;
1901         }
1902 
<span class="line-modified">1903         if (!bootstrapMethods.isEmpty()) {</span>
<span class="line-modified">1904             writeBootstrapMethods();</span>
1905             acount++;
1906         }
1907 
1908         endAttrs(acountIdx, acount);
1909 
<span class="line-removed">1910         poolbuf.appendBytes(databuf.elems, 0, databuf.length);</span>
1911         out.write(poolbuf.elems, 0, poolbuf.length);
1912 
<span class="line-modified">1913         pool = c.pool = null; // to conserve space</span>
<span class="line-modified">1914      }</span>











1915 
<span class="line-modified">1916     /**Allows subclasses to write additional class attributes</span>
1917      *
1918      * @return the number of attributes written
1919      */
<span class="line-modified">1920     protected int writeExtraClassAttributes(ClassSymbol c) {</span>
<span class="line-modified">1921         return 0;</span>




1922     }
1923 
1924     int adjustFlags(final long flags) {
1925         int result = (int)flags;
1926 
1927         if ((flags &amp; BRIDGE) != 0)
1928             result |= ACC_BRIDGE;
1929         if ((flags &amp; VARARGS) != 0)
1930             result |= ACC_VARARGS;
1931         if ((flags &amp; DEFAULT) != 0)
1932             result &amp;= ~ABSTRACT;
1933         return result;
1934     }
1935 
1936     long getLastModified(FileObject filename) {
1937         long mod = 0;
1938         try {
1939             mod = filename.getLastModified();
1940         } catch (SecurityException e) {
1941             throw new AssertionError(&quot;CRT: couldn&#39;t get source file modification date: &quot; + e.getMessage());
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import java.io.*;
  29 import java.util.LinkedHashMap;
  30 import java.util.Map;
  31 import java.util.Set;

  32 import java.util.LinkedHashSet;
<span class="line-modified">  33 import java.util.function.ToIntFunction;</span>
  34 
  35 import javax.tools.JavaFileManager;
  36 import javax.tools.FileObject;
  37 import javax.tools.JavaFileManager.Location;
  38 import javax.tools.JavaFileObject;
  39 
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  42 import com.sun.tools.javac.code.Directive.*;
  43 import com.sun.tools.javac.code.Symbol.*;
  44 import com.sun.tools.javac.code.Type.*;
  45 import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;

  46 import com.sun.tools.javac.comp.Check;
  47 import com.sun.tools.javac.file.PathFileObject;
<span class="line-modified">  48 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;</span>
<span class="line-modified">  49 import com.sun.tools.javac.jvm.PoolConstant.Dynamic.BsmKey;</span>


  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  52 import com.sun.tools.javac.util.*;
<span class="line-added">  53 import com.sun.tools.javac.util.List;</span>
  54 
  55 import static com.sun.tools.javac.code.Flags.*;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  58 import static com.sun.tools.javac.code.TypeTag.*;
  59 import static com.sun.tools.javac.main.Option.*;
  60 
  61 import static javax.tools.StandardLocation.CLASS_OUTPUT;
  62 
  63 /** This class provides operations to map an internal symbol table graph
  64  *  rooted in a ClassSymbol into a classfile.
  65  *
  66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  67  *  If you write code that depends on this, you do so at your own risk.
  68  *  This code and its internal interfaces are subject to change or
  69  *  deletion without notice.&lt;/b&gt;
  70  */
  71 public class ClassWriter extends ClassFile {
  72     protected static final Context.Key&lt;ClassWriter&gt; classWriterKey = new Context.Key&lt;&gt;();
  73 
</pre>
<hr />
<pre>
  97      * Target class version.
  98      */
  99     private Target target;
 100 
 101     /**
 102      * Source language version.
 103      */
 104     private Source source;
 105 
 106     /** Type utilities. */
 107     private Types types;
 108 
 109     private Check check;
 110 
 111     /**
 112      * If true, class files will be written in module-specific subdirectories
 113      * of the CLASS_OUTPUT location.
 114      */
 115     public boolean multiModuleMode;
 116 
<span class="line-added"> 117     private List&lt;ToIntFunction&lt;Symbol&gt;&gt; extraAttributeHooks = List.nil();</span>
<span class="line-added"> 118 </span>
 119     /** The initial sizes of the data and constant pool buffers.
 120      *  Sizes are increased when buffers get full.
 121      */
 122     static final int DATA_BUF_SIZE = 0x0fff0;
<span class="line-modified"> 123     static final int CLASS_BUF_SIZE = 0x1fff0;</span>
 124 
 125     /** An output buffer for member info.
 126      */
<span class="line-modified"> 127     public ByteBuffer databuf = new ByteBuffer(DATA_BUF_SIZE);</span>
 128 
 129     /** An output buffer for the constant pool.
 130      */
<span class="line-modified"> 131     ByteBuffer poolbuf = new ByteBuffer(CLASS_BUF_SIZE);</span>













 132 
<span class="line-modified"> 133     /** The constant pool writer.</span>

 134      */
<span class="line-modified"> 135     final PoolWriter poolWriter;</span>
 136 
 137     /** The log to use for verbose output.
 138      */
 139     private final Log log;
 140 
 141     /** The name table. */
 142     private final Names names;
 143 
 144     /** Access to files. */
 145     private final JavaFileManager fileManager;
 146 



 147     /** The tags and constants used in compressed stackmap. */
 148     static final int SAME_FRAME_SIZE = 64;
 149     static final int SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247;
 150     static final int SAME_FRAME_EXTENDED = 251;
 151     static final int FULL_FRAME = 255;
 152     static final int MAX_LOCAL_LENGTH_DIFF = 4;
 153 
 154     /** Get the ClassWriter instance for this context. */
 155     public static ClassWriter instance(Context context) {
 156         ClassWriter instance = context.get(classWriterKey);
 157         if (instance == null)
 158             instance = new ClassWriter(context);
 159         return instance;
 160     }
 161 
 162     /** Construct a class writer, given an options table.
 163      */
 164     protected ClassWriter(Context context) {
 165         context.put(classWriterKey, this);
 166 
 167         log = Log.instance(context);
 168         names = Names.instance(context);
 169         options = Options.instance(context);
 170         preview = Preview.instance(context);
 171         target = Target.instance(context);
 172         source = Source.instance(context);
 173         types = Types.instance(context);
 174         check = Check.instance(context);
 175         fileManager = context.get(JavaFileManager.class);
<span class="line-modified"> 176         poolWriter = Gen.instance(context).poolWriter;</span>
 177 
 178         verbose        = options.isSet(VERBOSE);
 179         genCrt         = options.isSet(XJCOV);
 180         debugstackmap = options.isSet(&quot;debug.stackmap&quot;);
 181 
 182         emitSourceFile = options.isUnset(G_CUSTOM) ||
 183                             options.isSet(G_CUSTOM, &quot;source&quot;);
 184 
 185         String modifierFlags = options.get(&quot;debug.dumpmodifiers&quot;);
 186         if (modifierFlags != null) {
 187             dumpClassModifiers = modifierFlags.indexOf(&#39;c&#39;) != -1;
 188             dumpFieldModifiers = modifierFlags.indexOf(&#39;f&#39;) != -1;
 189             dumpInnerClassModifiers = modifierFlags.indexOf(&#39;i&#39;) != -1;
 190             dumpMethodModifiers = modifierFlags.indexOf(&#39;m&#39;) != -1;
 191         }
 192     }
 193 
<span class="line-added"> 194     public void addExtraAttributes(ToIntFunction&lt;Symbol&gt; addExtraAttributes) {</span>
<span class="line-added"> 195         extraAttributeHooks = extraAttributeHooks.prepend(addExtraAttributes);</span>
<span class="line-added"> 196     }</span>
<span class="line-added"> 197 </span>
 198 /******************************************************************
 199  * Diagnostics: dump generated class names and modifiers
 200  ******************************************************************/
 201 
 202     /** Value of option &#39;dumpmodifiers&#39; is a string
 203      *  indicating which modifiers should be dumped for debugging:
 204      *    &#39;c&#39; -- classes
 205      *    &#39;f&#39; -- fields
 206      *    &#39;i&#39; -- innerclass attributes
 207      *    &#39;m&#39; -- methods
 208      *  For example, to dump everything:
 209      *    javac -XDdumpmodifiers=cifm MyProg.java
 210      */
 211     private boolean dumpClassModifiers; // -XDdumpmodifiers=c
 212     private boolean dumpFieldModifiers; // -XDdumpmodifiers=f
 213     private boolean dumpInnerClassModifiers; // -XDdumpmodifiers=i
 214     private boolean dumpMethodModifiers; // -XDdumpmodifiers=m
 215 
 216 
 217     /** Return flags as a string, separated by &quot; &quot;.
</pre>
<hr />
<pre>
 241  ******************************************************************/
 242 
 243     /** Write a character into given byte buffer;
 244      *  byte buffer will not be grown.
 245      */
 246     void putChar(ByteBuffer buf, int op, int x) {
 247         buf.elems[op  ] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 248         buf.elems[op+1] = (byte)((x      ) &amp; 0xFF);
 249     }
 250 
 251     /** Write an integer into given byte buffer;
 252      *  byte buffer will not be grown.
 253      */
 254     void putInt(ByteBuffer buf, int adr, int x) {
 255         buf.elems[adr  ] = (byte)((x &gt;&gt; 24) &amp; 0xFF);
 256         buf.elems[adr+1] = (byte)((x &gt;&gt; 16) &amp; 0xFF);
 257         buf.elems[adr+2] = (byte)((x &gt;&gt;  8) &amp; 0xFF);
 258         buf.elems[adr+3] = (byte)((x      ) &amp; 0xFF);
 259     }
 260 



























































































 261 /******************************************************************
 262  * Writing the Constant Pool
 263  ******************************************************************/
 264 
 265     /** Thrown when the constant pool is over full.
 266      */
<span class="line-modified"> 267     public static class PoolOverflow extends RuntimeException {</span>
 268         private static final long serialVersionUID = 0;
 269         public PoolOverflow() {}
 270     }
<span class="line-modified"> 271     public static class StringOverflow extends RuntimeException {</span>
 272         private static final long serialVersionUID = 0;
 273         public final String value;
 274         public StringOverflow(String s) {
 275             value = s;
 276         }
 277     }
 278 



































































































































 279 /******************************************************************
 280  * Writing Attributes
 281  ******************************************************************/
 282 
 283     /** Write header for an attribute to data buffer and return
 284      *  position past attribute length index.
 285      */
<span class="line-modified"> 286     public int writeAttr(Name attrName) {</span>
<span class="line-modified"> 287         int index = poolWriter.putName(attrName);</span>
<span class="line-added"> 288         databuf.appendChar(index);</span>
 289         databuf.appendInt(0);
 290         return databuf.length;
 291     }
 292 
 293     /** Fill in attribute length.
 294      */
<span class="line-modified"> 295     public void endAttr(int index) {</span>
 296         putInt(databuf, index - 4, databuf.length - index);
 297     }
 298 
 299     /** Leave space for attribute count and return index for
 300      *  number of attributes field.
 301      */
 302     int beginAttrs() {
 303         databuf.appendChar(0);
 304         return databuf.length;
 305     }
 306 
 307     /** Fill in number of attributes.
 308      */
 309     void endAttrs(int index, int count) {
 310         putChar(databuf, index - 2, count);
 311     }
 312 
 313     /** Write the EnclosingMethod attribute if needed.
 314      *  Returns the number of attributes written (0 or 1).
 315      */
 316     int writeEnclosingMethodAttribute(ClassSymbol c) {
 317         return writeEnclosingMethodAttribute(names.EnclosingMethod, c);
 318     }
 319 
 320     /** Write the EnclosingMethod attribute with a specified name.
 321      *  Returns the number of attributes written (0 or 1).
 322      */
 323     protected int writeEnclosingMethodAttribute(Name attributeName, ClassSymbol c) {
 324         if (c.owner.kind != MTH &amp;&amp; // neither a local class
 325             c.name != names.empty) // nor anonymous
 326             return 0;
 327 
 328         int alenIdx = writeAttr(attributeName);
 329         ClassSymbol enclClass = c.owner.enclClass();
 330         MethodSymbol enclMethod =
 331             (c.owner.type == null // local to init block
 332              || c.owner.kind != MTH) // or member init
 333             ? null
<span class="line-modified"> 334             : ((MethodSymbol)c.owner).originalEnclosingMethod();</span>
<span class="line-modified"> 335         databuf.appendChar(poolWriter.putClass(enclClass));</span>
<span class="line-modified"> 336         databuf.appendChar(enclMethod == null ? 0 : poolWriter.putNameAndType(enclMethod));</span>
 337         endAttr(alenIdx);
 338         return 1;
 339     }
 340 
 341     /** Write flag attributes; return number of attributes written.
 342      */
 343     int writeFlagAttrs(long flags) {
 344         int acount = 0;
 345         if ((flags &amp; DEPRECATED) != 0) {
 346             int alenIdx = writeAttr(names.Deprecated);
 347             endAttr(alenIdx);
 348             acount++;
 349         }
 350         return acount;
 351     }
 352 
 353     /** Write member (field or method) attributes;
 354      *  return number of attributes written.
 355      */
<span class="line-modified"> 356     int writeMemberAttrs(Symbol sym, boolean isRecordComponent) {</span>
<span class="line-modified"> 357         int acount = 0;</span>
<span class="line-added"> 358         if (!isRecordComponent) {</span>
<span class="line-added"> 359             acount = writeFlagAttrs(sym.flags());</span>
<span class="line-added"> 360         }</span>
 361         long flags = sym.flags();
 362         if ((flags &amp; (SYNTHETIC | BRIDGE)) != SYNTHETIC &amp;&amp;
 363             (flags &amp; ANONCONSTR) == 0 &amp;&amp;
 364             (!types.isSameType(sym.type, sym.erasure(types)) ||
<span class="line-modified"> 365              poolWriter.signatureGen.hasTypeVar(sym.type.getThrownTypes()))) {</span>
 366             // note that a local class with captured variables
 367             // will get a signature attribute
 368             int alenIdx = writeAttr(names.Signature);
<span class="line-modified"> 369             databuf.appendChar(poolWriter.putSignature(sym));</span>
 370             endAttr(alenIdx);
 371             acount++;
 372         }
 373         acount += writeJavaAnnotations(sym.getRawAttributes());
 374         acount += writeTypeAnnotations(sym.getRawTypeAttributes(), false);
 375         return acount;
 376     }
 377 
 378     /**
 379      * Write method parameter names attribute.
 380      */
 381     int writeMethodParametersAttr(MethodSymbol m) {
 382         MethodType ty = m.externalType(types).asMethodType();
 383         final int allparams = ty.argtypes.size();
 384         if (m.params != null &amp;&amp; allparams != 0) {
 385             final int attrIndex = writeAttr(names.MethodParameters);
 386             databuf.appendByte(allparams);
 387             // Write extra parameters first
 388             for (VarSymbol s : m.extraParams) {
 389                 final int flags =
 390                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 391                     ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified"> 392                 databuf.appendChar(poolWriter.putName(s.name));</span>
 393                 databuf.appendChar(flags);
 394             }
 395             // Now write the real parameters
 396             for (VarSymbol s : m.params) {
 397                 final int flags =
 398                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 399                     ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified"> 400                 databuf.appendChar(poolWriter.putName(s.name));</span>
 401                 databuf.appendChar(flags);
 402             }
 403             // Now write the captured locals
 404             for (VarSymbol s : m.capturedLocals) {
 405                 final int flags =
 406                     ((int) s.flags() &amp; (FINAL | SYNTHETIC | MANDATED)) |
 407                     ((int) m.flags() &amp; SYNTHETIC);
<span class="line-modified"> 408                 databuf.appendChar(poolWriter.putName(s.name));</span>
 409                 databuf.appendChar(flags);
 410             }
 411             endAttr(attrIndex);
 412             return 1;
 413         } else
 414             return 0;
 415     }
 416 

 417     private void writeParamAnnotations(List&lt;VarSymbol&gt; params,
 418                                        RetentionPolicy retention) {
<span class="line-added"> 419         databuf.appendByte(params.length());</span>
 420         for (VarSymbol s : params) {
 421             ListBuffer&lt;Attribute.Compound&gt; buf = new ListBuffer&lt;&gt;();
 422             for (Attribute.Compound a : s.getRawAttributes())
 423                 if (types.getRetention(a) == retention)
 424                     buf.append(a);
 425             databuf.appendChar(buf.length());
 426             for (Attribute.Compound a : buf)
 427                 writeCompoundAttribute(a);
 428         }
 429 
 430     }
 431 
 432     private void writeParamAnnotations(MethodSymbol m,
 433                                        RetentionPolicy retention) {
 434         databuf.appendByte(m.params.length());
 435         writeParamAnnotations(m.params, retention);
 436     }
 437 
 438     /** Write method parameter annotations;
 439      *  return number of attributes written.
 440      */
<span class="line-modified"> 441     int writeParameterAttrs(List&lt;VarSymbol&gt; vars) {</span>
 442         boolean hasVisible = false;
 443         boolean hasInvisible = false;
<span class="line-modified"> 444         if (vars != null) {</span>
<span class="line-modified"> 445             for (VarSymbol s : vars) {</span>
 446                 for (Attribute.Compound a : s.getRawAttributes()) {
 447                     switch (types.getRetention(a)) {
 448                     case SOURCE: break;
 449                     case CLASS: hasInvisible = true; break;
 450                     case RUNTIME: hasVisible = true; break;
 451                     default: // /* fail soft */ throw new AssertionError(vis);
 452                     }
 453                 }
 454             }
 455         }
 456 
 457         int attrCount = 0;
 458         if (hasVisible) {
 459             int attrIndex = writeAttr(names.RuntimeVisibleParameterAnnotations);
<span class="line-modified"> 460             writeParamAnnotations(vars, RetentionPolicy.RUNTIME);</span>
 461             endAttr(attrIndex);
 462             attrCount++;
 463         }
 464         if (hasInvisible) {
 465             int attrIndex = writeAttr(names.RuntimeInvisibleParameterAnnotations);
<span class="line-modified"> 466             writeParamAnnotations(vars, RetentionPolicy.CLASS);</span>
 467             endAttr(attrIndex);
 468             attrCount++;
 469         }
 470         return attrCount;
 471     }
 472 
 473 /**********************************************************************
 474  * Writing Java-language annotations (aka metadata, attributes)
 475  **********************************************************************/
 476 
 477     /** Write Java-language annotations; return number of JVM
 478      *  attributes written (zero or one).
 479      */
 480     int writeJavaAnnotations(List&lt;Attribute.Compound&gt; attrs) {
 481         if (attrs.isEmpty()) return 0;
 482         ListBuffer&lt;Attribute.Compound&gt; visibles = new ListBuffer&lt;&gt;();
 483         ListBuffer&lt;Attribute.Compound&gt; invisibles = new ListBuffer&lt;&gt;();
 484         for (Attribute.Compound a : attrs) {
 485             switch (types.getRetention(a)) {
 486             case SOURCE: break;
</pre>
<hr />
<pre>
 554             attrCount++;
 555         }
 556 
 557         if (invisibles.length() != 0) {
 558             int attrIndex = writeAttr(names.RuntimeInvisibleTypeAnnotations);
 559             databuf.appendChar(invisibles.length());
 560             for (Attribute.TypeCompound p : invisibles)
 561                 writeTypeAnnotation(p);
 562             endAttr(attrIndex);
 563             attrCount++;
 564         }
 565 
 566         return attrCount;
 567     }
 568 
 569     /** A visitor to write an attribute including its leading
 570      *  single-character marker.
 571      */
 572     class AttributeWriter implements Attribute.Visitor {
 573         public void visitConstant(Attribute.Constant _value) {
<span class="line-modified"> 574             if (_value.type.getTag() == CLASS) {</span>
<span class="line-modified"> 575                 Assert.check(_value.value instanceof String);</span>
<span class="line-modified"> 576                 String s = (String)_value.value;</span>

























 577                 databuf.appendByte(&#39;s&#39;);
<span class="line-modified"> 578                 databuf.appendChar(poolWriter.putName(names.fromString(s)));</span>
<span class="line-modified"> 579             } else {</span>
<span class="line-modified"> 580                 switch (_value.type.getTag()) {</span>
<span class="line-modified"> 581                     case BYTE:</span>
<span class="line-added"> 582                         databuf.appendByte(&#39;B&#39;);</span>
<span class="line-added"> 583                         break;</span>
<span class="line-added"> 584                     case CHAR:</span>
<span class="line-added"> 585                         databuf.appendByte(&#39;C&#39;);</span>
<span class="line-added"> 586                         break;</span>
<span class="line-added"> 587                     case SHORT:</span>
<span class="line-added"> 588                         databuf.appendByte(&#39;S&#39;);</span>
<span class="line-added"> 589                         break;</span>
<span class="line-added"> 590                     case INT:</span>
<span class="line-added"> 591                         databuf.appendByte(&#39;I&#39;);</span>
<span class="line-added"> 592                         break;</span>
<span class="line-added"> 593                     case LONG:</span>
<span class="line-added"> 594                         databuf.appendByte(&#39;J&#39;);</span>
<span class="line-added"> 595                         break;</span>
<span class="line-added"> 596                     case FLOAT:</span>
<span class="line-added"> 597                         databuf.appendByte(&#39;F&#39;);</span>
<span class="line-added"> 598                         break;</span>
<span class="line-added"> 599                     case DOUBLE:</span>
<span class="line-added"> 600                         databuf.appendByte(&#39;D&#39;);</span>
<span class="line-added"> 601                         break;</span>
<span class="line-added"> 602                     case BOOLEAN:</span>
<span class="line-added"> 603                         databuf.appendByte(&#39;Z&#39;);</span>
<span class="line-added"> 604                         break;</span>
<span class="line-added"> 605                     default:</span>
<span class="line-added"> 606                         throw new AssertionError(_value.type);</span>
<span class="line-added"> 607                 }</span>
<span class="line-added"> 608                 databuf.appendChar(poolWriter.putConstant(_value.value));</span>
 609             }

 610         }
 611         public void visitEnum(Attribute.Enum e) {
 612             databuf.appendByte(&#39;e&#39;);
<span class="line-modified"> 613             databuf.appendChar(poolWriter.putDescriptor(e.value.type));</span>
<span class="line-modified"> 614             databuf.appendChar(poolWriter.putName(e.value.name));</span>
 615         }
 616         public void visitClass(Attribute.Class clazz) {
 617             databuf.appendByte(&#39;c&#39;);
<span class="line-modified"> 618             databuf.appendChar(poolWriter.putDescriptor(clazz.classType));</span>
 619         }
 620         public void visitCompound(Attribute.Compound compound) {
 621             databuf.appendByte(&#39;@&#39;);
 622             writeCompoundAttribute(compound);
 623         }
 624         public void visitError(Attribute.Error x) {
 625             throw new AssertionError(x);
 626         }
 627         public void visitArray(Attribute.Array array) {
 628             databuf.appendByte(&#39;[&#39;);
 629             databuf.appendChar(array.values.length);
 630             for (Attribute a : array.values) {
 631                 a.accept(this);
 632             }
 633         }
 634     }
 635     AttributeWriter awriter = new AttributeWriter();
 636 
 637     /** Write a compound attribute excluding the &#39;@&#39; marker. */
 638     void writeCompoundAttribute(Attribute.Compound c) {
<span class="line-modified"> 639         databuf.appendChar(poolWriter.putDescriptor(c.type));</span>
 640         databuf.appendChar(c.values.length());
 641         for (Pair&lt;Symbol.MethodSymbol,Attribute&gt; p : c.values) {
<span class="line-modified"> 642             databuf.appendChar(poolWriter.putName(p.fst.name));</span>
 643             p.snd.accept(awriter);
 644         }
 645     }
 646 
 647     void writeTypeAnnotation(Attribute.TypeCompound c) {
 648         writePosition(c.position);
 649         writeCompoundAttribute(c);
 650     }
 651 
 652     void writePosition(TypeAnnotationPosition p) {
 653         databuf.appendByte(p.type.targetTypeValue()); // TargetType tag is a byte
 654         switch (p.type) {
 655         // instanceof
 656         case INSTANCEOF:
 657         // new expression
 658         case NEW:
 659         // constructor/method reference receiver
 660         case CONSTRUCTOR_REFERENCE:
 661         case METHOD_REFERENCE:
 662             databuf.appendChar(p.offset);
</pre>
<hr />
<pre>
 726         { // Append location data for generics/arrays.
 727             databuf.appendByte(p.location.size());
 728             java.util.List&lt;Integer&gt; loc = TypeAnnotationPosition.getBinaryFromTypePath(p.location);
 729             for (int i : loc)
 730                 databuf.appendByte((byte)i);
 731         }
 732     }
 733 
 734 /**********************************************************************
 735  * Writing module attributes
 736  **********************************************************************/
 737 
 738     /** Write the Module attribute if needed.
 739      *  Returns the number of attributes written (0 or 1).
 740      */
 741     int writeModuleAttribute(ClassSymbol c) {
 742         ModuleSymbol m = (ModuleSymbol) c.owner;
 743 
 744         int alenIdx = writeAttr(names.Module);
 745 
<span class="line-modified"> 746         databuf.appendChar(poolWriter.putModule(m));</span>
 747         databuf.appendChar(ModuleFlags.value(m.flags)); // module_flags
<span class="line-modified"> 748         databuf.appendChar(m.version != null ? poolWriter.putName(m.version) : 0);</span>
 749 
 750         ListBuffer&lt;RequiresDirective&gt; requires = new ListBuffer&lt;&gt;();
 751         for (RequiresDirective r: m.requires) {
 752             if (!r.flags.contains(RequiresFlag.EXTRA))
 753                 requires.add(r);
 754         }
 755         databuf.appendChar(requires.size());
 756         for (RequiresDirective r: requires) {
<span class="line-modified"> 757             databuf.appendChar(poolWriter.putModule(r.module));</span>
 758             databuf.appendChar(RequiresFlag.value(r.flags));
<span class="line-modified"> 759             databuf.appendChar(r.module.version != null ? poolWriter.putName(r.module.version) : 0);</span>
 760         }
 761 
 762         List&lt;ExportsDirective&gt; exports = m.exports;
 763         databuf.appendChar(exports.size());
 764         for (ExportsDirective e: exports) {
<span class="line-modified"> 765             databuf.appendChar(poolWriter.putPackage(e.packge));</span>
 766             databuf.appendChar(ExportsFlag.value(e.flags));
 767             if (e.modules == null) {
 768                 databuf.appendChar(0);
 769             } else {
 770                 databuf.appendChar(e.modules.size());
 771                 for (ModuleSymbol msym: e.modules) {
<span class="line-modified"> 772                     databuf.appendChar(poolWriter.putModule(msym));</span>
 773                 }
 774             }
 775         }
 776 
 777         List&lt;OpensDirective&gt; opens = m.opens;
 778         databuf.appendChar(opens.size());
 779         for (OpensDirective o: opens) {
<span class="line-modified"> 780             databuf.appendChar(poolWriter.putPackage(o.packge));</span>
 781             databuf.appendChar(OpensFlag.value(o.flags));
 782             if (o.modules == null) {
 783                 databuf.appendChar(0);
 784             } else {
 785                 databuf.appendChar(o.modules.size());
 786                 for (ModuleSymbol msym: o.modules) {
<span class="line-modified"> 787                     databuf.appendChar(poolWriter.putModule(msym));</span>
 788                 }
 789             }
 790         }
 791 
 792         List&lt;UsesDirective&gt; uses = m.uses;
 793         databuf.appendChar(uses.size());
 794         for (UsesDirective s: uses) {
<span class="line-modified"> 795             databuf.appendChar(poolWriter.putClass(s.service));</span>
 796         }
 797 
 798         // temporary fix to merge repeated provides clause for same service;
 799         // eventually this should be disallowed when analyzing the module,
 800         // so that each service type only appears once.
 801         Map&lt;ClassSymbol, Set&lt;ClassSymbol&gt;&gt; mergedProvides = new LinkedHashMap&lt;&gt;();
 802         for (ProvidesDirective p : m.provides) {
 803             mergedProvides.computeIfAbsent(p.service, s -&gt; new LinkedHashSet&lt;&gt;()).addAll(p.impls);
 804         }
 805         databuf.appendChar(mergedProvides.size());
 806         mergedProvides.forEach((srvc, impls) -&gt; {
<span class="line-modified"> 807             databuf.appendChar(poolWriter.putClass(srvc));</span>
 808             databuf.appendChar(impls.size());
<span class="line-modified"> 809             impls.forEach(impl -&gt; databuf.appendChar(poolWriter.putClass(impl)));</span>
 810         });
 811 
 812         endAttr(alenIdx);
 813         return 1;
 814     }
 815 
 816 /**********************************************************************
 817  * Writing Objects
 818  **********************************************************************/
 819 































 820     /** Write &quot;inner classes&quot; attribute.
 821      */
 822     void writeInnerClasses() {
 823         int alenIdx = writeAttr(names.InnerClasses);
<span class="line-modified"> 824         databuf.appendChar(poolWriter.innerClasses.size());</span>
<span class="line-modified"> 825         for (ClassSymbol inner : poolWriter.innerClasses) {</span>



 826             inner.markAbstractIfNeeded(types);
 827             char flags = (char) adjustFlags(inner.flags_field);
 828             if ((flags &amp; INTERFACE) != 0) flags |= ABSTRACT; // Interfaces are always ABSTRACT
 829             flags &amp;= ~STRICTFP; //inner classes should not have the strictfp flag set.
 830             if (dumpInnerClassModifiers) {
 831                 PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 832                 pw.println(&quot;INNERCLASS  &quot; + inner.name);
 833                 pw.println(&quot;---&quot; + flagNames(flags));
 834             }
<span class="line-modified"> 835             databuf.appendChar(poolWriter.putClass(inner));</span>
 836             databuf.appendChar(
<span class="line-modified"> 837                 inner.owner.kind == TYP &amp;&amp; !inner.name.isEmpty() ? poolWriter.putClass((ClassSymbol)inner.owner) : 0);</span>
 838             databuf.appendChar(
<span class="line-modified"> 839                 !inner.name.isEmpty() ? poolWriter.putName(inner.name) : 0);</span>
 840             databuf.appendChar(flags);
 841         }
 842         endAttr(alenIdx);
 843     }
 844 
<span class="line-added"> 845     int writeRecordAttribute(ClassSymbol csym) {</span>
<span class="line-added"> 846         int alenIdx = writeAttr(names.Record);</span>
<span class="line-added"> 847         Scope s = csym.members();</span>
<span class="line-added"> 848         databuf.appendChar(csym.getRecordComponents().size());</span>
<span class="line-added"> 849         for (VarSymbol v: csym.getRecordComponents()) {</span>
<span class="line-added"> 850             //databuf.appendChar(poolWriter.putMember(v.accessor.head.snd));</span>
<span class="line-added"> 851             databuf.appendChar(poolWriter.putName(v.name));</span>
<span class="line-added"> 852             databuf.appendChar(poolWriter.putDescriptor(v));</span>
<span class="line-added"> 853             int acountIdx = beginAttrs();</span>
<span class="line-added"> 854             int acount = 0;</span>
<span class="line-added"> 855             acount += writeMemberAttrs(v, true);</span>
<span class="line-added"> 856             endAttrs(acountIdx, acount);</span>
<span class="line-added"> 857         }</span>
<span class="line-added"> 858         endAttr(alenIdx);</span>
<span class="line-added"> 859         return 1;</span>
<span class="line-added"> 860     }</span>
<span class="line-added"> 861 </span>
 862     /**
 863      * Write NestMembers attribute (if needed)
 864      */
 865     int writeNestMembersIfNeeded(ClassSymbol csym) {
<span class="line-modified"> 866         ListBuffer&lt;ClassSymbol&gt; nested = new ListBuffer&lt;&gt;();</span>
 867         listNested(csym, nested);
<span class="line-modified"> 868         Set&lt;ClassSymbol&gt; nestedUnique = new LinkedHashSet&lt;&gt;(nested);</span>
 869         if (csym.owner.kind == PCK &amp;&amp; !nestedUnique.isEmpty()) {
 870             int alenIdx = writeAttr(names.NestMembers);
 871             databuf.appendChar(nestedUnique.size());
<span class="line-modified"> 872             for (ClassSymbol s : nestedUnique) {</span>
<span class="line-modified"> 873                 databuf.appendChar(poolWriter.putClass(s));</span>
 874             }
 875             endAttr(alenIdx);
 876             return 1;
 877         }
 878         return 0;
 879     }
 880 
 881     /**
 882      * Write NestHost attribute (if needed)
 883      */
 884     int writeNestHostIfNeeded(ClassSymbol csym) {
 885         if (csym.owner.kind != PCK) {
 886             int alenIdx = writeAttr(names.NestHost);
<span class="line-modified"> 887             databuf.appendChar(poolWriter.putClass(csym.outermostClass()));</span>
 888             endAttr(alenIdx);
 889             return 1;
 890         }
 891         return 0;
 892     }
 893 
<span class="line-modified"> 894     private void listNested(Symbol sym, ListBuffer&lt;ClassSymbol&gt; seen) {</span>
 895         if (sym.kind != TYP) return;
 896         ClassSymbol csym = (ClassSymbol)sym;
 897         if (csym.owner.kind != PCK) {
 898             seen.add(csym);
 899         }
 900         if (csym.members() != null) {
 901             for (Symbol s : sym.members().getSymbols()) {
 902                 listNested(s, seen);
 903             }
 904         }
 905         if (csym.trans_local != null) {
 906             for (Symbol s : csym.trans_local) {
 907                 listNested(s, seen);
 908             }
 909         }
 910     }
 911 
 912     /** Write &quot;bootstrapMethods&quot; attribute.
 913      */
 914     void writeBootstrapMethods() {
 915         int alenIdx = writeAttr(names.BootstrapMethods);
<span class="line-modified"> 916         databuf.appendChar(poolWriter.bootstrapMethods.size());</span>
<span class="line-modified"> 917         for (BsmKey bsmKey : poolWriter.bootstrapMethods.keySet()) {</span>

 918             //write BSM handle
<span class="line-modified"> 919             databuf.appendChar(poolWriter.putConstant(bsmKey.bsm));</span>
<span class="line-modified"> 920             LoadableConstant[] uniqueArgs = bsmKey.staticArgs;</span>
 921             //write static args length
 922             databuf.appendChar(uniqueArgs.length);
 923             //write static args array
<span class="line-modified"> 924             for (LoadableConstant arg : uniqueArgs) {</span>
<span class="line-modified"> 925                 databuf.appendChar(poolWriter.putConstant(arg));</span>
 926             }
 927         }
 928         endAttr(alenIdx);
 929     }
 930 
 931     /** Write field symbol, entering all references into constant pool.
 932      */
 933     void writeField(VarSymbol v) {
 934         int flags = adjustFlags(v.flags());
 935         databuf.appendChar(flags);
 936         if (dumpFieldModifiers) {
 937             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 938             pw.println(&quot;FIELD  &quot; + v.name);
 939             pw.println(&quot;---&quot; + flagNames(v.flags()));
 940         }
<span class="line-modified"> 941         databuf.appendChar(poolWriter.putName(v.name));</span>
<span class="line-modified"> 942         databuf.appendChar(poolWriter.putDescriptor(v));</span>
 943         int acountIdx = beginAttrs();
 944         int acount = 0;
 945         if (v.getConstValue() != null) {
 946             int alenIdx = writeAttr(names.ConstantValue);
<span class="line-modified"> 947             databuf.appendChar(poolWriter.putConstant(v.getConstValue()));</span>
 948             endAttr(alenIdx);
 949             acount++;
 950         }
<span class="line-modified"> 951         acount += writeMemberAttrs(v, false);</span>
<span class="line-added"> 952         acount += writeExtraAttributes(v);</span>
 953         endAttrs(acountIdx, acount);
 954     }
 955 
 956     /** Write method symbol, entering all references into constant pool.
 957      */
 958     void writeMethod(MethodSymbol m) {
 959         int flags = adjustFlags(m.flags());
 960         databuf.appendChar(flags);
 961         if (dumpMethodModifiers) {
 962             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
 963             pw.println(&quot;METHOD  &quot; + m.name);
 964             pw.println(&quot;---&quot; + flagNames(m.flags()));
 965         }
<span class="line-modified"> 966         databuf.appendChar(poolWriter.putName(m.name));</span>
<span class="line-modified"> 967         databuf.appendChar(poolWriter.putDescriptor(m));</span>
 968         int acountIdx = beginAttrs();
 969         int acount = 0;
 970         if (m.code != null) {
 971             int alenIdx = writeAttr(names.Code);
 972             writeCode(m.code);
 973             m.code = null; // to conserve space
 974             endAttr(alenIdx);
 975             acount++;
 976         }
 977         List&lt;Type&gt; thrown = m.erasure(types).getThrownTypes();
 978         if (thrown.nonEmpty()) {
 979             int alenIdx = writeAttr(names.Exceptions);
 980             databuf.appendChar(thrown.length());
 981             for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
<span class="line-modified"> 982                 databuf.appendChar(poolWriter.putClass(l.head));</span>
 983             endAttr(alenIdx);
 984             acount++;
 985         }
 986         if (m.defaultValue != null) {
 987             int alenIdx = writeAttr(names.AnnotationDefault);
 988             m.defaultValue.accept(awriter);
 989             endAttr(alenIdx);
 990             acount++;
 991         }
<span class="line-modified"> 992         if (target.hasMethodParameters() &amp;&amp; (options.isSet(PARAMETERS) || m.isConstructor() &amp;&amp; (m.flags_field &amp; RECORD) != 0)) {</span>
 993             if (!m.isLambdaMethod()) // Per JDK-8138729, do not emit parameters table for lambda bodies.
 994                 acount += writeMethodParametersAttr(m);
 995         }
<span class="line-modified"> 996         acount += writeMemberAttrs(m, false);</span>
 997         if (!m.isLambdaMethod())
<span class="line-modified"> 998             acount += writeParameterAttrs(m.params);</span>
<span class="line-added"> 999         acount += writeExtraAttributes(m);</span>
1000         endAttrs(acountIdx, acount);
1001     }
1002 
1003     /** Write code attribute of method.
1004      */
1005     void writeCode(Code code) {
1006         databuf.appendChar(code.max_stack);
1007         databuf.appendChar(code.max_locals);
1008         databuf.appendInt(code.cp);
1009         databuf.appendBytes(code.code, 0, code.cp);
1010         databuf.appendChar(code.catchInfo.length());
1011         for (List&lt;char[]&gt; l = code.catchInfo.toList();
1012              l.nonEmpty();
1013              l = l.tail) {
1014             for (int i = 0; i &lt; l.head.length; i++)
1015                 databuf.appendChar(l.head[i]);
1016         }
1017         int acountIdx = beginAttrs();
1018         int acount = 0;
1019 
</pre>
<hr />
<pre>
1039             acount++;
1040         }
1041 
1042         // counter for number of generic local variables
1043         if (code.varDebugInfo &amp;&amp; code.varBufferSize &gt; 0) {
1044             int nGenericVars = 0;
1045             int alenIdx = writeAttr(names.LocalVariableTable);
1046             databuf.appendChar(code.getLVTSize());
1047             for (int i=0; i&lt;code.varBufferSize; i++) {
1048                 Code.LocalVar var = code.varBuffer[i];
1049 
1050                 for (Code.LocalVar.Range r: var.aliveRanges) {
1051                     // write variable info
1052                     Assert.check(r.start_pc &gt;= 0
1053                             &amp;&amp; r.start_pc &lt;= code.cp);
1054                     databuf.appendChar(r.start_pc);
1055                     Assert.check(r.length &gt; 0
1056                             &amp;&amp; (r.start_pc + r.length) &lt;= code.cp);
1057                     databuf.appendChar(r.length);
1058                     VarSymbol sym = var.sym;
<span class="line-modified">1059                     databuf.appendChar(poolWriter.putName(sym.name));</span>
<span class="line-modified">1060                     databuf.appendChar(poolWriter.putDescriptor(sym));</span>

1061                     databuf.appendChar(var.reg);
1062                     if (needsLocalVariableTypeEntry(var.sym.type)) {
1063                         nGenericVars++;
1064                     }
1065                 }
1066             }
1067             endAttr(alenIdx);
1068             acount++;
1069 
1070             if (nGenericVars &gt; 0) {
1071                 alenIdx = writeAttr(names.LocalVariableTypeTable);
1072                 databuf.appendChar(nGenericVars);
1073                 int count = 0;
1074 
1075                 for (int i=0; i&lt;code.varBufferSize; i++) {
1076                     Code.LocalVar var = code.varBuffer[i];
1077                     VarSymbol sym = var.sym;
1078                     if (!needsLocalVariableTypeEntry(sym.type))
1079                         continue;
1080                     for (Code.LocalVar.Range r : var.aliveRanges) {
1081                         // write variable info
1082                         databuf.appendChar(r.start_pc);
1083                         databuf.appendChar(r.length);
<span class="line-modified">1084                         databuf.appendChar(poolWriter.putName(sym.name));</span>
<span class="line-modified">1085                         databuf.appendChar(poolWriter.putSignature(sym));</span>
1086                         databuf.appendChar(var.reg);
1087                         count++;
1088                     }
1089                 }
1090                 Assert.check(count == nGenericVars);
1091                 endAttr(alenIdx);
1092                 acount++;
1093             }
1094         }
1095 
1096         if (code.stackMapBufferSize &gt; 0) {
1097             if (debugstackmap) System.out.println(&quot;Stack map for &quot; + code.meth);
1098             int alenIdx = writeAttr(code.stackMap.getAttributeName(names));
1099             writeStackMap(code);
1100             endAttr(alenIdx);
1101             acount++;
1102         }
1103 
1104         acount += writeTypeAnnotations(code.meth.getRawTypeAttributes(), true);
1105 
</pre>
<hr />
<pre>
1192                 databuf.appendByte(1);
1193                 break;
1194             case FLOAT:
1195                 if (debugstackmap) System.out.print(&quot;float&quot;);
1196                 databuf.appendByte(2);
1197                 break;
1198             case DOUBLE:
1199                 if (debugstackmap) System.out.print(&quot;double&quot;);
1200                 databuf.appendByte(3);
1201                 break;
1202             case LONG:
1203                 if (debugstackmap) System.out.print(&quot;long&quot;);
1204                 databuf.appendByte(4);
1205                 break;
1206             case BOT: // null
1207                 if (debugstackmap) System.out.print(&quot;null&quot;);
1208                 databuf.appendByte(5);
1209                 break;
1210             case CLASS:
1211             case ARRAY:




1212             case TYPEVAR:
1213                 if (debugstackmap) System.out.print(&quot;object(&quot; + types.erasure(t).tsym + &quot;)&quot;);
1214                 databuf.appendByte(7);
<span class="line-modified">1215                 databuf.appendChar(poolWriter.putClass(types.erasure(t)));</span>
1216                 break;
1217             case UNINITIALIZED_THIS:
1218                 if (debugstackmap) System.out.print(&quot;uninit_this&quot;);
1219                 databuf.appendByte(6);
1220                 break;
1221             case UNINITIALIZED_OBJECT:
1222                 { UninitializedType uninitType = (UninitializedType)t;
1223                 databuf.appendByte(8);
1224                 if (debugstackmap) System.out.print(&quot;uninit_object@&quot; + uninitType.offset);
1225                 databuf.appendChar(uninitType.offset);
1226                 }
1227                 break;
1228             default:
1229                 throw new AssertionError();
1230             }
1231         }
1232 
1233     /** An entry in the JSR202 StackMapTable */
1234     abstract static class StackMapTableFrame {
1235         abstract int getFrameType();
</pre>
<hr />
<pre>
1494         } catch (InvalidSignatureException ex) {
1495             log.error(Errors.CannotGenerateClass(c, Fragments.IllegalSignature(c, ex.type())));
1496         } finally {
1497             if (out != null) {
1498                 // if we are propagating an exception, delete the file
1499                 out.close();
1500                 outFile.delete();
1501                 outFile = null;
1502             }
1503         }
1504         return outFile; // may be null if write failed
1505     }
1506 
1507     /** Write class `c&#39; to outstream `out&#39;.
1508      */
1509     public void writeClassFile(OutputStream out, ClassSymbol c)
1510         throws IOException, PoolOverflow, StringOverflow {
1511         Assert.check((c.flags() &amp; COMPOUND) == 0);
1512         databuf.reset();
1513         poolbuf.reset();





1514 
1515         Type supertype = types.supertype(c.type);
1516         List&lt;Type&gt; interfaces = types.interfaces(c.type);
1517         List&lt;Type&gt; typarams = c.type.getTypeArguments();
1518 
1519         int flags;
1520         if (c.owner.kind == MDL) {
1521             flags = ACC_MODULE;
1522         } else {
1523             flags = adjustFlags(c.flags() &amp; ~DEFAULT);
1524             if ((flags &amp; PROTECTED) != 0) flags |= PUBLIC;
1525             flags = flags &amp; ClassFlags &amp; ~STRICTFP;
1526             if ((flags &amp; INTERFACE) == 0) flags |= ACC_SUPER;
1527         }
1528 
1529         if (dumpClassModifiers) {
1530             PrintWriter pw = log.getWriter(Log.WriterKind.ERROR);
1531             pw.println();
1532             pw.println(&quot;CLASSFILE  &quot; + c.getQualifiedName());
1533             pw.println(&quot;---&quot; + flagNames(flags));
1534         }
1535         databuf.appendChar(flags);
1536 
1537         if (c.owner.kind == MDL) {
1538             PackageSymbol unnamed = ((ModuleSymbol) c.owner).unnamedPackage;
<span class="line-modified">1539             databuf.appendChar(poolWriter.putClass(new ClassSymbol(0, names.module_info, unnamed)));</span>
1540         } else {
<span class="line-modified">1541             databuf.appendChar(poolWriter.putClass(c));</span>
1542         }
<span class="line-modified">1543         databuf.appendChar(supertype.hasTag(CLASS) ? poolWriter.putClass((ClassSymbol)supertype.tsym) : 0);</span>
1544         databuf.appendChar(interfaces.length());
1545         for (List&lt;Type&gt; l = interfaces; l.nonEmpty(); l = l.tail)
<span class="line-modified">1546             databuf.appendChar(poolWriter.putClass((ClassSymbol)l.head.tsym));</span>
1547         int fieldsCount = 0;
1548         int methodsCount = 0;
1549         for (Symbol sym : c.members().getSymbols(NON_RECURSIVE)) {
1550             switch (sym.kind) {
1551             case VAR: fieldsCount++; break;
1552             case MTH: if ((sym.flags() &amp; HYPOTHETICAL) == 0) methodsCount++;
1553                       break;
<span class="line-modified">1554             case TYP: poolWriter.enterInner((ClassSymbol)sym); break;</span>
1555             default : Assert.error();
1556             }
1557         }
1558 
1559         if (c.trans_local != null) {
1560             for (ClassSymbol local : c.trans_local) {
<span class="line-modified">1561                 poolWriter.enterInner(local);</span>
1562             }
1563         }
1564 
1565         databuf.appendChar(fieldsCount);
1566         writeFields(c.members());
1567         databuf.appendChar(methodsCount);
1568         writeMethods(c.members());
1569 
1570         int acountIdx = beginAttrs();
1571         int acount = 0;
1572 
1573         boolean sigReq =
1574             typarams.length() != 0 || supertype.allparams().length() != 0;
1575         for (List&lt;Type&gt; l = interfaces; !sigReq &amp;&amp; l.nonEmpty(); l = l.tail)
1576             sigReq = l.head.allparams().length() != 0;
1577         if (sigReq) {
1578             int alenIdx = writeAttr(names.Signature);
<span class="line-modified">1579             databuf.appendChar(poolWriter.putSignature(c));</span>





1580             endAttr(alenIdx);
1581             acount++;
1582         }
1583 
1584         if (c.sourcefile != null &amp;&amp; emitSourceFile) {
1585             int alenIdx = writeAttr(names.SourceFile);
1586             // WHM 6/29/1999: Strip file path prefix.  We do it here at
1587             // the last possible moment because the sourcefile may be used
1588             // elsewhere in error diagnostics. Fixes 4241573.

1589             String simpleName = PathFileObject.getSimpleName(c.sourcefile);
<span class="line-modified">1590             databuf.appendChar(poolWriter.putName(names.fromString(simpleName)));</span>
1591             endAttr(alenIdx);
1592             acount++;
1593         }
1594 
1595         if (genCrt) {
1596             // Append SourceID attribute
1597             int alenIdx = writeAttr(names.SourceID);
<span class="line-modified">1598             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(getLastModified(c.sourcefile)))));</span>
1599             endAttr(alenIdx);
1600             acount++;
1601             // Append CompilationID attribute
1602             alenIdx = writeAttr(names.CompilationID);
<span class="line-modified">1603             databuf.appendChar(poolWriter.putName(names.fromString(Long.toString(System.currentTimeMillis()))));</span>
1604             endAttr(alenIdx);
1605             acount++;
1606         }
1607 
1608         acount += writeFlagAttrs(c.flags());
1609         acount += writeJavaAnnotations(c.getRawAttributes());
1610         acount += writeTypeAnnotations(c.getRawTypeAttributes(), false);
1611         acount += writeEnclosingMethodAttribute(c);
1612         if (c.owner.kind == MDL) {
1613             acount += writeModuleAttribute(c);
1614             acount += writeFlagAttrs(c.owner.flags() &amp; ~DEPRECATED);
1615         }
1616         acount += writeExtraClassAttributes(c);
<span class="line-added">1617         acount += writeExtraAttributes(c);</span>
1618 
1619         poolbuf.appendInt(JAVA_MAGIC);
1620         if (preview.isEnabled()) {
1621             poolbuf.appendChar(ClassFile.PREVIEW_MINOR_VERSION);
1622         } else {
1623             poolbuf.appendChar(target.minorVersion);
1624         }
1625         poolbuf.appendChar(target.majorVersion);
1626 
1627         if (c.owner.kind != MDL) {
1628             if (target.hasNestmateAccess()) {
1629                 acount += writeNestMembersIfNeeded(c);
1630                 acount += writeNestHostIfNeeded(c);
1631             }
1632         }
1633 
<span class="line-modified">1634         if (c.isRecord()) {</span>
<span class="line-added">1635             acount += writeRecordAttribute(c);</span>
<span class="line-added">1636         }</span>
1637 
<span class="line-modified">1638         if (!poolWriter.bootstrapMethods.isEmpty()) {</span>
<span class="line-modified">1639             writeBootstrapMethods();</span>
1640             acount++;
1641         }
1642 
<span class="line-modified">1643         if (!poolWriter.innerClasses.isEmpty()) {</span>
<span class="line-modified">1644             writeInnerClasses();</span>
1645             acount++;
1646         }
1647 
1648         endAttrs(acountIdx, acount);
1649 

1650         out.write(poolbuf.elems, 0, poolbuf.length);
1651 
<span class="line-modified">1652         poolWriter.writePool(out);</span>
<span class="line-modified">1653         poolWriter.reset(); // to save space</span>
<span class="line-added">1654 </span>
<span class="line-added">1655         out.write(databuf.elems, 0, databuf.length);</span>
<span class="line-added">1656     }</span>
<span class="line-added">1657 </span>
<span class="line-added">1658      /**Allows subclasses to write additional class attributes</span>
<span class="line-added">1659       *</span>
<span class="line-added">1660       * @return the number of attributes written</span>
<span class="line-added">1661       */</span>
<span class="line-added">1662     protected int writeExtraClassAttributes(ClassSymbol c) {</span>
<span class="line-added">1663         return 0;</span>
<span class="line-added">1664     }</span>
1665 
<span class="line-modified">1666     /**Allows friends to write additional attributes</span>
1667      *
1668      * @return the number of attributes written
1669      */
<span class="line-modified">1670     protected int writeExtraAttributes(Symbol sym) {</span>
<span class="line-modified">1671         int i = 0;</span>
<span class="line-added">1672         for (ToIntFunction&lt;Symbol&gt; hook : extraAttributeHooks) {</span>
<span class="line-added">1673             i += hook.applyAsInt(sym);</span>
<span class="line-added">1674         }</span>
<span class="line-added">1675         return i;</span>
1676     }
1677 
1678     int adjustFlags(final long flags) {
1679         int result = (int)flags;
1680 
1681         if ((flags &amp; BRIDGE) != 0)
1682             result |= ACC_BRIDGE;
1683         if ((flags &amp; VARARGS) != 0)
1684             result |= ACC_VARARGS;
1685         if ((flags &amp; DEFAULT) != 0)
1686             result &amp;= ~ABSTRACT;
1687         return result;
1688     }
1689 
1690     long getLastModified(FileObject filename) {
1691         long mod = 0;
1692         try {
1693             mod = filename.getLastModified();
1694         } catch (SecurityException e) {
1695             throw new AssertionError(&quot;CRT: couldn&#39;t get source file modification date: &quot; + e.getMessage());
</pre>
</td>
</tr>
</table>
<center><a href="ClassReader.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Code.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
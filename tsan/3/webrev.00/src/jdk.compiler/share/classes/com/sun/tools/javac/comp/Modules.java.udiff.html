<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemberEnter.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Operators.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Modules.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -353,11 +353,11 @@</span>
      }
  
      private void setCompilationUnitModules(List&lt;JCCompilationUnit&gt; trees, Set&lt;ModuleSymbol&gt; rootModules, ClassSymbol c) {
          // update the module for each compilation unit
          if (multiModuleMode) {
<span class="udiff-line-modified-removed">-             checkNoAllModulePath();</span>
<span class="udiff-line-modified-added">+             boolean patchesAutomaticModules = false;</span>
              for (JCCompilationUnit tree: trees) {
                  if (tree.defs.isEmpty()) {
                      tree.modle = syms.unnamedModule;
                      continue;
                  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -373,10 +373,11 @@</span>
                      if (plocn != null) {
                          Name name = names.fromString(fileManager.inferModuleName(plocn));
                          ModuleSymbol msym = moduleFinder.findModule(name);
                          tree.modle = msym;
                          rootModules.add(msym);
<span class="udiff-line-added">+                         patchesAutomaticModules |= (msym.flags_field &amp; Flags.AUTOMATIC_MODULE) != 0;</span>
  
                          if (msplocn != null) {
                              Name mspname = names.fromString(fileManager.inferModuleName(msplocn));
                              if (name != mspname) {
                                  log.error(tree.pos(), Errors.FilePatchedAndMsp(name, mspname));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -436,10 +437,13 @@</span>
                      throw new Error(e); // FIXME
                  } finally {
                      log.useSource(prev);
                  }
              }
<span class="udiff-line-added">+             if (!patchesAutomaticModules) {</span>
<span class="udiff-line-added">+                 checkNoAllModulePath();</span>
<span class="udiff-line-added">+             }</span>
              if (syms.unnamedModule.sourceLocation == null) {
                  syms.unnamedModule.completer = getUnnamedModuleCompleter();
                  syms.unnamedModule.sourceLocation = StandardLocation.SOURCE_PATH;
                  syms.unnamedModule.classLocation = StandardLocation.CLASS_PATH;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -456,13 +460,15 @@</span>
                              chk.completionError(null, cf);
                              defaultModule = syms.unnamedModule;
                          }
                          if (defaultModule == syms.unnamedModule) {
                              if (moduleOverride != null) {
<span class="udiff-line-removed">-                                 checkNoAllModulePath();</span>
                                  defaultModule = moduleFinder.findModule(names.fromString(moduleOverride));
                                  defaultModule.patchOutputLocation = StandardLocation.CLASS_OUTPUT;
<span class="udiff-line-added">+                                 if ((defaultModule.flags_field &amp; Flags.AUTOMATIC_MODULE) == 0) {</span>
<span class="udiff-line-added">+                                     checkNoAllModulePath();</span>
<span class="udiff-line-added">+                                 }</span>
                              } else {
                                  // Question: why not do findAllModules and initVisiblePackages here?
                                  // i.e. body of unnamedModuleCompleter
                                  defaultModule.completer = getUnnamedModuleCompleter();
                                  defaultModule.sourceLocation = StandardLocation.SOURCE_PATH;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1152,11 +1158,11 @@</span>
                      /* The implementation must be defined in the same module as the provides directive
                       * (else, error)
                       */
                      PackageSymbol implementationDefiningPackage = impl.packge();
                      if (implementationDefiningPackage.modle != msym) {
<span class="udiff-line-modified-removed">-                         // TODO: should use tree for the implentation name, not the entire provides tree</span>
<span class="udiff-line-modified-added">+                         // TODO: should use tree for the implementation name, not the entire provides tree</span>
                          // TODO: should improve error message to identify the implementation type
                          log.error(tree.pos(), Errors.ServiceImplementationNotInRightModule(implementationDefiningPackage.modle));
                      }
  
                      /* There is no inherent requirement that module that provides a service should actually
</pre>
<center><a href="MemberEnter.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Operators.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
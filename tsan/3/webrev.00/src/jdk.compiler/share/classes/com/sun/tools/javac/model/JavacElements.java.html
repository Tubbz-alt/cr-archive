<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/model/JavacElements.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.model;
 27 
 28 import java.util.Collections;
 29 import java.util.HashMap;
 30 import java.util.HashSet;
 31 import java.util.LinkedHashSet;
 32 import java.util.Map;
 33 import java.util.Optional;
 34 import java.util.Set;
 35 import java.util.stream.Collectors;
 36 
 37 import javax.lang.model.AnnotatedConstruct;
 38 import javax.lang.model.SourceVersion;
 39 import javax.lang.model.element.*;
 40 import javax.lang.model.type.DeclaredType;
 41 import javax.lang.model.util.Elements;
 42 import javax.tools.JavaFileObject;
 43 import static javax.lang.model.util.ElementFilter.methodsIn;
 44 
 45 import com.sun.source.util.JavacTask;
 46 import com.sun.tools.javac.api.JavacTaskImpl;
 47 import com.sun.tools.javac.code.*;
 48 import com.sun.tools.javac.code.Attribute.Compound;
 49 import com.sun.tools.javac.code.Directive.ExportsDirective;
 50 import com.sun.tools.javac.code.Directive.ExportsFlag;
 51 import com.sun.tools.javac.code.Directive.OpensDirective;
 52 import com.sun.tools.javac.code.Directive.OpensFlag;
 53 import com.sun.tools.javac.code.Directive.RequiresDirective;
 54 import com.sun.tools.javac.code.Directive.RequiresFlag;
 55 import com.sun.tools.javac.code.Scope.WriteableScope;
 56 import com.sun.tools.javac.code.Source.Feature;
 57 import com.sun.tools.javac.code.Symbol.*;
 58 import com.sun.tools.javac.comp.AttrContext;
 59 import com.sun.tools.javac.comp.Enter;
 60 import com.sun.tools.javac.comp.Env;
 61 import com.sun.tools.javac.main.JavaCompiler;
 62 import com.sun.tools.javac.processing.PrintingProcessor;
 63 import com.sun.tools.javac.tree.JCTree;
 64 import com.sun.tools.javac.tree.JCTree.*;
 65 import com.sun.tools.javac.tree.TreeInfo;
 66 import com.sun.tools.javac.tree.TreeScanner;
 67 import com.sun.tools.javac.util.*;
 68 import com.sun.tools.javac.util.DefinedBy.Api;
 69 import com.sun.tools.javac.util.Name;
 70 import static com.sun.tools.javac.code.Kinds.Kind.*;
 71 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
 72 import static com.sun.tools.javac.code.TypeTag.CLASS;
 73 import com.sun.tools.javac.comp.Modules;
 74 import com.sun.tools.javac.comp.Resolve;
 75 import com.sun.tools.javac.comp.Resolve.RecoveryLoadClass;
 76 import com.sun.tools.javac.resources.CompilerProperties.Notes;
 77 import static com.sun.tools.javac.tree.JCTree.Tag.*;
 78 
 79 /**
 80  * Utility methods for operating on program elements.
 81  *
 82  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 83  * If you write code that depends on this, you do so at your own
 84  * risk.  This code and its internal interfaces are subject to change
 85  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 86  */
 87 public class JavacElements implements Elements {
 88 
 89     private final JavaCompiler javaCompiler;
 90     private final Symtab syms;
 91     private final Modules modules;
 92     private final Names names;
 93     private final Types types;
 94     private final Enter enter;
 95     private final Resolve resolve;
 96     private final JavacTaskImpl javacTaskImpl;
 97     private final Log log;
 98     private final boolean allowModules;
 99 
100     public static JavacElements instance(Context context) {
101         JavacElements instance = context.get(JavacElements.class);
102         if (instance == null)
103             instance = new JavacElements(context);
104         return instance;
105     }
106 
107     protected JavacElements(Context context) {
108         context.put(JavacElements.class, this);
109         javaCompiler = JavaCompiler.instance(context);
110         syms = Symtab.instance(context);
111         modules = Modules.instance(context);
112         names = Names.instance(context);
113         types = Types.instance(context);
114         enter = Enter.instance(context);
115         resolve = Resolve.instance(context);
116         JavacTask t = context.get(JavacTask.class);
117         javacTaskImpl = t instanceof JavacTaskImpl ? (JavacTaskImpl) t : null;
118         log = Log.instance(context);
119         Source source = Source.instance(context);
120         allowModules = Feature.MODULES.allowedInSource(source);
121     }
122 
123     @Override @DefinedBy(Api.LANGUAGE_MODEL)
124     public Set&lt;? extends ModuleElement&gt; getAllModuleElements() {
125         if (allowModules)
126             return Collections.unmodifiableSet(modules.allModules());
127         else
128             return Collections.emptySet();
129     }
130 
131     @Override @DefinedBy(Api.LANGUAGE_MODEL)
132     public ModuleSymbol getModuleElement(CharSequence name) {
133         ensureEntered(&quot;getModuleElement&quot;);
134         if (modules.getDefaultModule() == syms.noModule)
135             return null;
136         String strName = name.toString();
137         if (strName.equals(&quot;&quot;))
138             return syms.unnamedModule;
139         return modules.getObservableModule(names.fromString(strName));
140     }
141 
142     @Override @DefinedBy(Api.LANGUAGE_MODEL)
143     public PackageSymbol getPackageElement(CharSequence name) {
144         return doGetPackageElement(null, name);
145     }
146 
147     @Override @DefinedBy(Api.LANGUAGE_MODEL)
148     public PackageSymbol getPackageElement(ModuleElement module, CharSequence name) {
149         module.getClass();
150         return doGetPackageElement(module, name);
151     }
152 
153     private PackageSymbol doGetPackageElement(ModuleElement module, CharSequence name) {
154         ensureEntered(&quot;getPackageElement&quot;);
155         return doGetElement(module, &quot;getPackageElement&quot;, name, PackageSymbol.class);
156     }
157 
158     @Override @DefinedBy(Api.LANGUAGE_MODEL)
159     public ClassSymbol getTypeElement(CharSequence name) {
160         return doGetTypeElement(null, name);
161     }
162 
163     @Override @DefinedBy(Api.LANGUAGE_MODEL)
164     public ClassSymbol getTypeElement(ModuleElement module, CharSequence name) {
165         module.getClass();
166 
167         return doGetTypeElement(module, name);
168     }
169 
170     private ClassSymbol doGetTypeElement(ModuleElement module, CharSequence name) {
171         ensureEntered(&quot;getTypeElement&quot;);
172         return doGetElement(module, &quot;getTypeElement&quot;, name, ClassSymbol.class);
173     }
174 
175     private &lt;S extends Symbol&gt; S doGetElement(ModuleElement module, String methodName,
176                                               CharSequence name, Class&lt;S&gt; clazz) {
177         String strName = name.toString();
178         if (!SourceVersion.isName(strName) &amp;&amp; (!strName.isEmpty() || clazz == ClassSymbol.class)) {
179             return null;
180         }
181         if (module == null) {
182             return unboundNameToSymbol(methodName, strName, clazz);
183         } else {
184             return nameToSymbol((ModuleSymbol) module, strName, clazz);
185         }
186     }
187 
188     private final Set&lt;String&gt; alreadyWarnedDuplicates = new HashSet&lt;&gt;();
189     private final Map&lt;Pair&lt;String, String&gt;, Optional&lt;Symbol&gt;&gt; resultCache = new HashMap&lt;&gt;();
190 
191     @SuppressWarnings(&quot;unchecked&quot;)
192     private &lt;S extends Symbol&gt; S unboundNameToSymbol(String methodName,
193                                                      String nameStr,
194                                                      Class&lt;S&gt; clazz) {
195         if (modules.getDefaultModule() == syms.noModule) { //not a modular mode:
196             return nameToSymbol(syms.noModule, nameStr, clazz);
197         }
198 
199         return (S) resultCache.computeIfAbsent(Pair.of(methodName, nameStr), p -&gt; {
200             Set&lt;S&gt; found = new LinkedHashSet&lt;&gt;();
201 
202             for (ModuleSymbol msym : modules.allModules()) {
203                 S sym = nameToSymbol(msym, nameStr, clazz);
204 
205                 if (sym == null)
206                     continue;
207 
208                 if (clazz == ClassSymbol.class) {
209                     // Always include classes
210                     found.add(sym);
211                 } else if (clazz == PackageSymbol.class) {
212                     // In module mode, ignore the &quot;spurious&quot; empty packages that &quot;enclose&quot; module-specific packages.
213                     // For example, if a module contains classes or package info in package p.q.r, it will also appear
214                     // to have additional packages p.q and p, even though these packages have no content other
215                     // than the subpackage.  We don&#39;t want those empty packages showing up in searches for p or p.q.
216                     if (!sym.members().isEmpty() || ((PackageSymbol) sym).package_info != null) {
217                         found.add(sym);
218                     }
219                 }
220             }
221 
222             if (found.size() == 1) {
223                 return Optional.of(found.iterator().next());
224             } else if (found.size() &gt; 1) {
225                 //more than one element found, produce a note:
226                 if (alreadyWarnedDuplicates.add(methodName + &quot;:&quot; + nameStr)) {
227                     String moduleNames = found.stream()
228                                               .map(s -&gt; s.packge().modle)
229                                               .map(m -&gt; m.toString())
230                                               .collect(Collectors.joining(&quot;, &quot;));
231                     log.note(Notes.MultipleElements(methodName, nameStr, moduleNames));
232                 }
233                 return Optional.empty();
234             } else {
235                 //not found:
236                 return Optional.empty();
237             }
238         }).orElse(null);
239     }
240 
241     /**
242      * Returns a symbol given the type&#39;s or package&#39;s canonical name,
243      * or null if the name isn&#39;t found.
244      */
245     private &lt;S extends Symbol&gt; S nameToSymbol(ModuleSymbol module, String nameStr, Class&lt;S&gt; clazz) {
246         Name name = names.fromString(nameStr);
247         // First check cache.
248         Symbol sym = (clazz == ClassSymbol.class)
249                     ? syms.getClass(module, name)
250                     : syms.lookupPackage(module, name);
251 
252         try {
253             if (sym == null)
254                 sym = javaCompiler.resolveIdent(module, nameStr);
255 
256             if (clazz.isInstance(sym)) {
257                 sym.complete();
258                 if (sym.kind != ERR &amp;&amp;
259                     sym.exists() &amp;&amp;
260                     name.equals(sym.getQualifiedName())) {
261                     return clazz.cast(sym);
262                 }
263             }
264             return null;
265         } catch (CompletionFailure cf) {
266             cf.dcfh.handleAPICompletionFailure(cf);
267             return null;
268         }
269     }
270 
271     /**
272      * Returns the tree for an annotation given the annotated element
273      * and the element&#39;s own tree.  Returns null if the tree cannot be found.
274      */
275     private JCTree matchAnnoToTree(AnnotationMirror findme,
276                                    Element e, JCTree tree) {
277         Symbol sym = cast(Symbol.class, e);
278         class Vis extends JCTree.Visitor {
279             List&lt;JCAnnotation&gt; result = null;
280             public void visitModuleDef(JCModuleDecl tree) {
281                 result = tree.mods.annotations;
282             }
283             public void visitPackageDef(JCPackageDecl tree) {
284                 result = tree.annotations;
285             }
286             public void visitClassDef(JCClassDecl tree) {
287                 result = tree.mods.annotations;
288             }
289             public void visitMethodDef(JCMethodDecl tree) {
290                 result = tree.mods.annotations;
291             }
292             public void visitVarDef(JCVariableDecl tree) {
293                 result = tree.mods.annotations;
294             }
295             @Override
296             public void visitTypeParameter(JCTypeParameter tree) {
297                 result = tree.annotations;
298             }
299         }
300         Vis vis = new Vis();
301         tree.accept(vis);
302         if (vis.result == null)
303             return null;
304 
305         List&lt;Attribute.Compound&gt; annos = sym.getAnnotationMirrors();
306         return matchAnnoToTree(cast(Attribute.Compound.class, findme),
307                                annos,
308                                vis.result);
309     }
310 
311     /**
312      * Returns the tree for an annotation given a list of annotations
313      * in which to search (recursively) and their corresponding trees.
314      * Returns null if the tree cannot be found.
315      */
316     private JCTree matchAnnoToTree(Attribute.Compound findme,
317                                    List&lt;Attribute.Compound&gt; annos,
318                                    List&lt;JCAnnotation&gt; trees) {
319         for (Attribute.Compound anno : annos) {
320             for (JCAnnotation tree : trees) {
321                 if (tree.type.tsym != anno.type.tsym)
322                     continue;
323                 JCTree match = matchAttributeToTree(findme, anno, tree);
324                 if (match != null)
325                     return match;
326             }
327         }
328         return null;
329     }
330 
331     /**
332      * Returns the tree for an attribute given an enclosing attribute to
333      * search (recursively) and the enclosing attribute&#39;s corresponding tree.
334      * Returns null if the tree cannot be found.
335      */
336     private JCTree matchAttributeToTree(final Attribute findme,
337                                         final Attribute attr,
338                                         final JCTree tree) {
339         if (attr == findme)
340             return tree;
341 
342         class Vis implements Attribute.Visitor {
343             JCTree result = null;
344             public void visitConstant(Attribute.Constant value) {
345             }
346             public void visitClass(Attribute.Class clazz) {
347             }
348             public void visitCompound(Attribute.Compound anno) {
349                 for (Pair&lt;MethodSymbol, Attribute&gt; pair : anno.values) {
350                     JCExpression expr = scanForAssign(pair.fst, tree);
351                     if (expr != null) {
352                         JCTree match = matchAttributeToTree(findme, pair.snd, expr);
353                         if (match != null) {
354                             result = match;
355                             return;
356                         }
357                     }
358                 }
359             }
360             public void visitArray(Attribute.Array array) {
361                 if (tree.hasTag(NEWARRAY)) {
362                     List&lt;JCExpression&gt; elems = ((JCNewArray)tree).elems;
363                     for (Attribute value : array.values) {
364                         JCTree match = matchAttributeToTree(findme, value, elems.head);
365                         if (match != null) {
366                             result = match;
367                             return;
368                         }
369                         elems = elems.tail;
370                     }
371                 } else if (array.values.length == 1) {
372                     // the tree may not be a NEWARRAY for single-element array initializers
373                     result = matchAttributeToTree(findme, array.values[0], tree);
374                 }
375             }
376             public void visitEnum(Attribute.Enum e) {
377             }
378             public void visitError(Attribute.Error e) {
379             }
380         }
381         Vis vis = new Vis();
382         attr.accept(vis);
383         return vis.result;
384     }
385 
386     /**
387      * Scans for a JCAssign node with a LHS matching a given
388      * symbol, and returns its RHS.  Does not scan nested JCAnnotations.
389      */
390     private JCExpression scanForAssign(final MethodSymbol sym,
391                                        final JCTree tree) {
392         class TS extends TreeScanner {
393             JCExpression result = null;
394             public void scan(JCTree t) {
395                 if (t != null &amp;&amp; result == null)
396                     t.accept(this);
397             }
398             public void visitAnnotation(JCAnnotation t) {
399                 if (t == tree)
400                     scan(t.args);
401             }
402             public void visitAssign(JCAssign t) {
403                 if (t.lhs.hasTag(IDENT)) {
404                     JCIdent ident = (JCIdent) t.lhs;
405                     if (ident.sym == sym)
406                         result = t.rhs;
407                 }
408             }
409         }
410         TS scanner = new TS();
411         tree.accept(scanner);
412         return scanner.result;
413     }
414 
415     /**
416      * Returns the tree node corresponding to this element, or null
417      * if none can be found.
418      */
419     public JCTree getTree(Element e) {
420         Pair&lt;JCTree, ?&gt; treeTop = getTreeAndTopLevel(e);
421         return (treeTop != null) ? treeTop.fst : null;
422     }
423 
424     @DefinedBy(Api.LANGUAGE_MODEL)
425     public String getDocComment(Element e) {
426         // Our doc comment is contained in a map in our toplevel,
427         // indexed by our tree.  Find our enter environment, which gives
428         // us our toplevel.  It also gives us a tree that contains our
429         // tree:  walk it to find our tree.  This is painful.
430         Pair&lt;JCTree, JCCompilationUnit&gt; treeTop = getTreeAndTopLevel(e);
431         if (treeTop == null)
432             return null;
433         JCTree tree = treeTop.fst;
434         JCCompilationUnit toplevel = treeTop.snd;
435         if (toplevel.docComments == null)
436             return null;
437         return toplevel.docComments.getCommentText(tree);
438     }
439 
440     @DefinedBy(Api.LANGUAGE_MODEL)
441     public PackageElement getPackageOf(Element e) {
442         if (e.getKind() == ElementKind.MODULE)
443             return null;
444         else
445             return cast(Symbol.class, e).packge();
446     }
447 
448     @DefinedBy(Api.LANGUAGE_MODEL)
449     public ModuleElement getModuleOf(Element e) {
450         Symbol sym = cast(Symbol.class, e);
451         if (modules.getDefaultModule() == syms.noModule)
452             return null;
453         return (sym.kind == MDL) ? ((ModuleElement) e) : sym.packge().modle;
454     }
455 
456     @DefinedBy(Api.LANGUAGE_MODEL)
457     public boolean isDeprecated(Element e) {
458         Symbol sym = cast(Symbol.class, e);
459         sym.apiComplete();
460         return sym.isDeprecated();
461     }
462 
463     @Override @DefinedBy(Api.LANGUAGE_MODEL)
464     public Origin getOrigin(Element e) {
465         Symbol sym = cast(Symbol.class, e);
466         if ((sym.flags() &amp; Flags.GENERATEDCONSTR) != 0)
467             return Origin.MANDATED;
468         if ((sym.flags() &amp; Flags.MANDATED) != 0)
469             return Origin.MANDATED;
470         //TypeElement.getEnclosedElements does not return synthetic elements,
471         //and most synthetic elements are not read from the classfile anyway:
472         return Origin.EXPLICIT;
473     }
474 
475     @Override @DefinedBy(Api.LANGUAGE_MODEL)
476     public Origin getOrigin(AnnotatedConstruct c, AnnotationMirror a) {
477         Compound ac = cast(Compound.class, a);
478         if (ac.isSynthesized())
479             return Origin.MANDATED;
480         return Origin.EXPLICIT;
481     }
482 
483     @Override @DefinedBy(Api.LANGUAGE_MODEL)
484     public Origin getOrigin(ModuleElement m, ModuleElement.Directive directive) {
485         switch (directive.getKind()) {
486             case REQUIRES:
487                 RequiresDirective rd = cast(RequiresDirective.class, directive);
488                 if (rd.flags.contains(RequiresFlag.MANDATED))
489                     return Origin.MANDATED;
490                 if (rd.flags.contains(RequiresFlag.SYNTHETIC))
491                     return Origin.SYNTHETIC;
492                 return Origin.EXPLICIT;
493             case EXPORTS:
494                 ExportsDirective ed = cast(ExportsDirective.class, directive);
495                 if (ed.flags.contains(ExportsFlag.MANDATED))
496                     return Origin.MANDATED;
497                 if (ed.flags.contains(ExportsFlag.SYNTHETIC))
498                     return Origin.SYNTHETIC;
499                 return Origin.EXPLICIT;
500             case OPENS:
501                 OpensDirective od = cast(OpensDirective.class, directive);
502                 if (od.flags.contains(OpensFlag.MANDATED))
503                     return Origin.MANDATED;
504                 if (od.flags.contains(OpensFlag.SYNTHETIC))
505                     return Origin.SYNTHETIC;
506                 return Origin.EXPLICIT;
507         }
508         return Origin.EXPLICIT;
509     }
510 
511     @DefinedBy(Api.LANGUAGE_MODEL)
512     public Name getBinaryName(TypeElement type) {
513         return cast(TypeSymbol.class, type).flatName();
514     }
515 
516     @DefinedBy(Api.LANGUAGE_MODEL)
517     public Map&lt;MethodSymbol, Attribute&gt; getElementValuesWithDefaults(
518                                                         AnnotationMirror a) {
519         Attribute.Compound anno = cast(Attribute.Compound.class, a);
520         DeclaredType annotype = a.getAnnotationType();
521         Map&lt;MethodSymbol, Attribute&gt; valmap = anno.getElementValues();
522 
523         for (ExecutableElement ex :
524                  methodsIn(annotype.asElement().getEnclosedElements())) {
525             MethodSymbol meth = (MethodSymbol) ex;
526             Attribute defaultValue = meth.getDefaultValue();
527             if (defaultValue != null &amp;&amp; !valmap.containsKey(meth)) {
528                 valmap.put(meth, defaultValue);
529             }
530         }
531         return valmap;
532     }
533 
534     /**
535      * {@inheritDoc}
536      */
537     @DefinedBy(Api.LANGUAGE_MODEL)
538     public FilteredMemberList getAllMembers(TypeElement element) {
539         Symbol sym = cast(Symbol.class, element);
540         WriteableScope scope = sym.members().dupUnshared();
541         List&lt;Type&gt; closure = types.closure(sym.asType());
542         for (Type t : closure)
543             addMembers(scope, t);
544         return new FilteredMemberList(scope);
545     }
546     // where
547         private void addMembers(WriteableScope scope, Type type) {
548             members:
549             for (Symbol e : type.asElement().members().getSymbols(NON_RECURSIVE)) {
550                 for (Symbol overrider : scope.getSymbolsByName(e.getSimpleName())) {
551                     if (overrider.kind == e.kind &amp;&amp; (overrider.flags() &amp; Flags.SYNTHETIC) == 0) {
552                         if (overrider.getKind() == ElementKind.METHOD &amp;&amp;
553                                 overrides((ExecutableElement)overrider, (ExecutableElement)e, (TypeElement)type.asElement())) {
554                             continue members;
555                         }
556                     }
557                 }
558                 boolean derived = e.getEnclosingElement() != scope.owner;
559                 ElementKind kind = e.getKind();
560                 boolean initializer = kind == ElementKind.CONSTRUCTOR
561                     || kind == ElementKind.INSTANCE_INIT
562                     || kind == ElementKind.STATIC_INIT;
563                 if (!derived || (!initializer &amp;&amp; e.isInheritedIn(scope.owner, types)))
564                     scope.enter(e);
565             }
566         }
567 
568     /**
569      * Returns all annotations of an element, whether
570      * inherited or directly present.
571      *
572      * @param e  the element being examined
573      * @return all annotations of the element
574      */
575     @Override @DefinedBy(Api.LANGUAGE_MODEL)
576     public List&lt;Attribute.Compound&gt; getAllAnnotationMirrors(Element e) {
577         Symbol sym = cast(Symbol.class, e);
578         List&lt;Attribute.Compound&gt; annos = sym.getAnnotationMirrors();
579         while (sym.getKind() == ElementKind.CLASS) {
580             Type sup = ((ClassSymbol) sym).getSuperclass();
581             if (!sup.hasTag(CLASS) || sup.isErroneous() ||
582                     sup.tsym == syms.objectType.tsym) {
583                 break;
584             }
585             sym = sup.tsym;
586             List&lt;Attribute.Compound&gt; oldAnnos = annos;
587             List&lt;Attribute.Compound&gt; newAnnos = sym.getAnnotationMirrors();
588             for (Attribute.Compound anno : newAnnos) {
589                 if (isInherited(anno.type) &amp;&amp;
590                         !containsAnnoOfType(oldAnnos, anno.type)) {
591                     annos = annos.prepend(anno);
592                 }
593             }
594         }
595         return annos;
596     }
597 
598     /**
599      * Tests whether an annotation type is @Inherited.
600      */
601     private boolean isInherited(Type annotype) {
602         return annotype.tsym.attribute(syms.inheritedType.tsym) != null;
603     }
604 
605     /**
606      * Tests whether a list of annotations contains an annotation
607      * of a given type.
608      */
609     private static boolean containsAnnoOfType(List&lt;Attribute.Compound&gt; annos,
610                                               Type type) {
611         for (Attribute.Compound anno : annos) {
612             if (anno.type.tsym == type.tsym)
613                 return true;
614         }
615         return false;
616     }
617 
618     @DefinedBy(Api.LANGUAGE_MODEL)
619     public boolean hides(Element hiderEl, Element hideeEl) {
620         Symbol hider = cast(Symbol.class, hiderEl);
621         Symbol hidee = cast(Symbol.class, hideeEl);
622 
623         // Fields only hide fields; methods only methods; types only types.
624         // Names must match.  Nothing hides itself (just try it).
625         if (hider == hidee ||
626                 hider.kind != hidee.kind ||
627                 hider.name != hidee.name) {
628             return false;
629         }
630 
631         // Only static methods can hide other methods.
632         // Methods only hide methods with matching signatures.
633         if (hider.kind == MTH) {
634             if (!hider.isStatic() ||
635                         !types.isSubSignature(hider.type, hidee.type)) {
636                 return false;
637             }
638         }
639 
640         // Hider must be in a subclass of hidee&#39;s class.
641         // Note that if M1 hides M2, and M2 hides M3, and M3 is accessible
642         // in M1&#39;s class, then M1 and M2 both hide M3.
643         ClassSymbol hiderClass = hider.owner.enclClass();
644         ClassSymbol hideeClass = hidee.owner.enclClass();
645         if (hiderClass == null || hideeClass == null ||
646                 !hiderClass.isSubClass(hideeClass, types)) {
647             return false;
648         }
649 
650         // Hidee must be accessible in hider&#39;s class.
651         return hidee.isAccessibleIn(hiderClass, types);
652     }
653 
654     @DefinedBy(Api.LANGUAGE_MODEL)
655     public boolean overrides(ExecutableElement riderEl,
656                              ExecutableElement rideeEl, TypeElement typeEl) {
657         MethodSymbol rider = cast(MethodSymbol.class, riderEl);
658         MethodSymbol ridee = cast(MethodSymbol.class, rideeEl);
659         ClassSymbol origin = cast(ClassSymbol.class, typeEl);
660 
661         return rider.name == ridee.name &amp;&amp;
662 
663                // not reflexive as per JLS
664                rider != ridee &amp;&amp;
665 
666                // we don&#39;t care if ridee is static, though that wouldn&#39;t
667                // compile
668                !rider.isStatic() &amp;&amp;
669 
670                // Symbol.overrides assumes the following
671                ridee.isMemberOf(origin, types) &amp;&amp;
672 
673                // check access and signatures; don&#39;t check return types
674                rider.overrides(ridee, origin, types, false);
675     }
676 
677     @DefinedBy(Api.LANGUAGE_MODEL)
678     public String getConstantExpression(Object value) {
679         return Constants.format(value);
680     }
681 
682     /**
683      * Print a representation of the elements to the given writer in
684      * the specified order.  The main purpose of this method is for
685      * diagnostics.  The exact format of the output is &lt;em&gt;not&lt;/em&gt;
686      * specified and is subject to change.
687      *
688      * @param w the writer to print the output to
689      * @param elements the elements to print
690      */
691     @DefinedBy(Api.LANGUAGE_MODEL)
692     public void printElements(java.io.Writer w, Element... elements) {
693         for (Element element : elements)
694             (new PrintingProcessor.PrintingElementVisitor(w, this)).visit(element).flush();
695     }
696 
697     @DefinedBy(Api.LANGUAGE_MODEL)
698     public Name getName(CharSequence cs) {
699         return names.fromString(cs.toString());
700     }
701 
702     @Override @DefinedBy(Api.LANGUAGE_MODEL)
703     public boolean isFunctionalInterface(TypeElement element) {
704         if (element.getKind() != ElementKind.INTERFACE)
705             return false;
706         else {
707             TypeSymbol tsym = cast(TypeSymbol.class, element);
708             return types.isFunctionalInterface(tsym);
709         }
710     }
711 
712     /**
713      * Returns the tree node and compilation unit corresponding to this
714      * element, or null if they can&#39;t be found.
715      */
716     private Pair&lt;JCTree, JCCompilationUnit&gt; getTreeAndTopLevel(Element e) {
717         Symbol sym = cast(Symbol.class, e);
718         Env&lt;AttrContext&gt; enterEnv = getEnterEnv(sym);
719         if (enterEnv == null)
720             return null;
721         JCTree tree = TreeInfo.declarationFor(sym, enterEnv.tree);
722         if (tree == null || enterEnv.toplevel == null)
723             return null;
724         return new Pair&lt;&gt;(tree, enterEnv.toplevel);
725     }
726 
727     /**
728      * Returns the best approximation for the tree node and compilation unit
729      * corresponding to the given element, annotation and value.
730      * If the element is null, null is returned.
731      * If the annotation is null or cannot be found, the tree node and
732      * compilation unit for the element is returned.
733      * If the annotation value is null or cannot be found, the tree node and
734      * compilation unit for the annotation is returned.
735      */
736     public Pair&lt;JCTree, JCCompilationUnit&gt; getTreeAndTopLevel(
737                       Element e, AnnotationMirror a, AnnotationValue v) {
738         if (e == null)
739             return null;
740 
741         Pair&lt;JCTree, JCCompilationUnit&gt; elemTreeTop = getTreeAndTopLevel(e);
742         if (elemTreeTop == null)
743             return null;
744 
745         if (a == null)
746             return elemTreeTop;
747 
748         JCTree annoTree = matchAnnoToTree(a, e, elemTreeTop.fst);
749         if (annoTree == null)
750             return elemTreeTop;
751 
752         if (v == null)
753             return new Pair&lt;&gt;(annoTree, elemTreeTop.snd);
754 
755         JCTree valueTree = matchAttributeToTree(
756                 cast(Attribute.class, v), cast(Attribute.class, a), annoTree);
757         if (valueTree == null)
758             return new Pair&lt;&gt;(annoTree, elemTreeTop.snd);
759 
760         return new Pair&lt;&gt;(valueTree, elemTreeTop.snd);
761     }
762 
763     /**
764      * Returns a symbol&#39;s enter environment, or null if it has none.
765      */
766     private Env&lt;AttrContext&gt; getEnterEnv(Symbol sym) {
767         // Get enclosing class of sym, or sym itself if it is a class
768         // package, or module.
769         TypeSymbol ts = null;
770         switch (sym.kind) {
771             case PCK:
772                 ts = (PackageSymbol)sym;
773                 break;
774             case MDL:
775                 ts = (ModuleSymbol)sym;
776                 break;
777             default:
778                 ts = sym.enclClass();
779         }
780         return (ts != null)
781                 ? enter.getEnv(ts)
782                 : null;
783     }
784 
785     private void ensureEntered(String methodName) {
786         if (javacTaskImpl != null) {
787             javacTaskImpl.ensureEntered();
788         }
789         if (!javaCompiler.isEnterDone()) {
790             throw new IllegalStateException(&quot;Cannot use Elements.&quot; + methodName + &quot; before the TaskEvent.Kind.ENTER finished event.&quot;);
791         }
792     }
793 
794     /**
795      * Returns an object cast to the specified type.
796      * @throws NullPointerException if the object is {@code null}
797      * @throws IllegalArgumentException if the object is of the wrong type
798      */
799     private static &lt;T&gt; T cast(Class&lt;T&gt; clazz, Object o) {
800         if (! clazz.isInstance(o))
801             throw new IllegalArgumentException(o.toString());
802         return clazz.cast(o);
803     }
804 
805     public void newRound() {
806         resultCache.clear();
807     }
808 }
    </pre>
  </body>
</html>
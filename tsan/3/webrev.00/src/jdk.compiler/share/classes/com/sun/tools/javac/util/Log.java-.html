<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/util/Log.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.util;
 27 
 28 import java.io.*;
 29 import java.util.Arrays;
 30 import java.util.EnumMap;
 31 import java.util.EnumSet;
 32 import java.util.HashSet;
 33 import java.util.Map;
 34 import java.util.Queue;
 35 import java.util.Set;
 36 import java.util.function.Predicate;
 37 
 38 import javax.tools.DiagnosticListener;
 39 import javax.tools.JavaFileObject;
 40 
 41 import com.sun.tools.javac.api.DiagnosticFormatter;
 42 import com.sun.tools.javac.main.Main;
 43 import com.sun.tools.javac.main.Option;
 44 import com.sun.tools.javac.tree.EndPosTable;
 45 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticInfo;
 47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 48 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
 49 
 50 import static com.sun.tools.javac.main.Option.*;
 51 
 52 /** A class for error logs. Reports errors and warnings, and
 53  *  keeps track of error numbers and positions.
 54  *
 55  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 56  *  If you write code that depends on this, you do so at your own risk.
 57  *  This code and its internal interfaces are subject to change or
 58  *  deletion without notice.&lt;/b&gt;
 59  */
 60 public class Log extends AbstractLog {
 61     /** The context key for the log. */
 62     public static final Context.Key&lt;Log&gt; logKey = new Context.Key&lt;&gt;();
 63 
 64     /** The context key for the standard output PrintWriter. */
 65     public static final Context.Key&lt;PrintWriter&gt; outKey = new Context.Key&lt;&gt;();
 66 
 67     /** The context key for the diagnostic PrintWriter. */
 68     public static final Context.Key&lt;PrintWriter&gt; errKey = new Context.Key&lt;&gt;();
 69 
 70     /* TODO: Should unify this with prefix handling in JCDiagnostic.Factory. */
 71     public enum PrefixKind {
 72         JAVAC(&quot;javac.&quot;),
 73         COMPILER_MISC(&quot;compiler.misc.&quot;);
 74         PrefixKind(String v) {
 75             value = v;
 76         }
 77         public String key(String k) {
 78             return value + k;
 79         }
 80         final String value;
 81     }
 82 
 83     /**
 84      * DiagnosticHandler&#39;s provide the initial handling for diagnostics.
 85      * When a diagnostic handler is created and has been initialized, it
 86      * should install itself as the current diagnostic handler. When a
 87      * client has finished using a handler, the client should call
 88      * {@code log.removeDiagnosticHandler();}
 89      *
 90      * Note that javax.tools.DiagnosticListener (if set) is called later in the
 91      * diagnostic pipeline.
 92      */
 93     public static abstract class DiagnosticHandler {
 94         /**
 95          * The previously installed diagnostic handler.
 96          */
 97         protected DiagnosticHandler prev;
 98 
 99         /**
100          * Install this diagnostic handler as the current one,
101          * recording the previous one.
102          */
103         protected void install(Log log) {
104             prev = log.diagnosticHandler;
105             log.diagnosticHandler = this;
106         }
107 
108         /**
109          * Handle a diagnostic.
110          */
111         public abstract void report(JCDiagnostic diag);
112     }
113 
114     /**
115      * A DiagnosticHandler that discards all diagnostics.
116      */
117     public static class DiscardDiagnosticHandler extends DiagnosticHandler {
118         public DiscardDiagnosticHandler(Log log) {
119             install(log);
120         }
121 
122         @Override
123         public void report(JCDiagnostic diag) { }
124     }
125 
126     /**
127      * A DiagnosticHandler that can defer some or all diagnostics,
128      * by buffering them for later examination and/or reporting.
129      * If a diagnostic is not deferred, or is subsequently reported
130      * with reportAllDiagnostics(), it will be reported to the previously
131      * active diagnostic handler.
132      */
133     public static class DeferredDiagnosticHandler extends DiagnosticHandler {
134         private Queue&lt;JCDiagnostic&gt; deferred = new ListBuffer&lt;&gt;();
135         private final Filter&lt;JCDiagnostic&gt; filter;
136 
137         public DeferredDiagnosticHandler(Log log) {
138             this(log, null);
139         }
140 
141         public DeferredDiagnosticHandler(Log log, Filter&lt;JCDiagnostic&gt; filter) {
142             this.filter = filter;
143             install(log);
144         }
145 
146         @Override
147         public void report(JCDiagnostic diag) {
148             if (!diag.isFlagSet(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE) &amp;&amp;
149                 (filter == null || filter.accepts(diag))) {
150                 deferred.add(diag);
151             } else {
152                 prev.report(diag);
153             }
154         }
155 
156         public Queue&lt;JCDiagnostic&gt; getDiagnostics() {
157             return deferred;
158         }
159 
160         /** Report all deferred diagnostics. */
161         public void reportDeferredDiagnostics() {
162             reportDeferredDiagnostics(d -&gt; true);
163         }
164 
165         /** Report selected deferred diagnostics. */
166         public void reportDeferredDiagnostics(Predicate&lt;JCDiagnostic&gt; accepter) {
167             JCDiagnostic d;
168             while ((d = deferred.poll()) != null) {
169                 if (accepter.test(d))
170                     prev.report(d);
171             }
172             deferred = null; // prevent accidental ongoing use
173         }
174     }
175 
176     public enum WriterKind { NOTICE, WARNING, ERROR, STDOUT, STDERR }
177 
178     private final Map&lt;WriterKind, PrintWriter&gt; writers;
179 
180     /** The maximum number of errors/warnings that are reported.
181      */
182     protected int MaxErrors;
183     protected int MaxWarnings;
184 
185     /** Switch: prompt user on each error.
186      */
187     public boolean promptOnError;
188 
189     /** Switch: emit warning messages.
190      */
191     public boolean emitWarnings;
192 
193     /** Switch: suppress note messages.
194      */
195     public boolean suppressNotes;
196 
197     /** Print stack trace on errors?
198      */
199     public boolean dumpOnError;
200 
201     /**
202      * Diagnostic listener, if provided through programmatic
203      * interface to javac (JSR 199).
204      */
205     protected DiagnosticListener&lt;? super JavaFileObject&gt; diagListener;
206 
207     /**
208      * Formatter for diagnostics.
209      */
210     private DiagnosticFormatter&lt;JCDiagnostic&gt; diagFormatter;
211 
212     /**
213      * Keys for expected diagnostics.
214      */
215     public Set&lt;String&gt; expectDiagKeys;
216 
217     /**
218      * Set to true if a compressed diagnostic is reported
219      */
220     public boolean compressedOutput;
221 
222     /**
223      * JavacMessages object used for localization.
224      */
225     private JavacMessages messages;
226 
227     /**
228      * Handler for initial dispatch of diagnostics.
229      */
230     private DiagnosticHandler diagnosticHandler;
231 
232     /** Get the Log instance for this context. */
233     public static Log instance(Context context) {
234         Log instance = context.get(logKey);
235         if (instance == null)
236             instance = new Log(context);
237         return instance;
238     }
239 
240     /**
241      * Register a Context.Factory to create a Log.
242      */
243     public static void preRegister(Context context, PrintWriter w) {
244         context.put(Log.class, (Context.Factory&lt;Log&gt;) (c -&gt; new Log(c, w)));
245     }
246 
247     /**
248      * Construct a log with default settings.
249      * If no streams are set in the context, the log will be initialized to use
250      * System.out for normal output, and System.err for all diagnostic output.
251      * If one stream is set in the context, with either Log.outKey or Log.errKey,
252      * it will be used for all output.
253      * Otherwise, the log will be initialized to use both streams found in the context.
254      */
255     protected Log(Context context) {
256         this(context, initWriters(context));
257     }
258 
259     /**
260      * Initialize a map of writers based on values found in the context
261      * @param context the context in which to find writers to use
262      * @return a map of writers
263      */
264     private static Map&lt;WriterKind, PrintWriter&gt; initWriters(Context context) {
265         PrintWriter out = context.get(outKey);
266         PrintWriter err = context.get(errKey);
267         if (out == null &amp;&amp; err == null) {
268             out = new PrintWriter(System.out, true);
269             err = new PrintWriter(System.err, true);
270             return initWriters(out, err);
271         } else if (out == null || err == null) {
272             PrintWriter pw = (out != null) ? out : err;
273             return initWriters(pw, pw);
274         } else {
275             return initWriters(out, err);
276         }
277     }
278 
279     /**
280      * Construct a log with all output sent to a single output stream.
281      */
282     protected Log(Context context, PrintWriter writer) {
283         this(context, initWriters(writer, writer));
284     }
285 
286     /**
287      * Construct a log.
288      * The log will be initialized to use stdOut for normal output, and stdErr
289      * for all diagnostic output.
290      */
291     protected Log(Context context, PrintWriter out, PrintWriter err) {
292         this(context, initWriters(out, err));
293     }
294 
295     /**
296      * Initialize a writer map for a stream for normal output, and a stream for diagnostics.
297      * @param out a stream to be used for normal output
298      * @param err a stream to be used for diagnostic messages, such as errors, warnings, etc
299      * @return a map of writers
300      */
301     private static Map&lt;WriterKind, PrintWriter&gt; initWriters(PrintWriter out, PrintWriter err) {
302         Map&lt;WriterKind, PrintWriter&gt; writers = new EnumMap&lt;&gt;(WriterKind.class);
303         writers.put(WriterKind.ERROR, err);
304         writers.put(WriterKind.WARNING, err);
305         writers.put(WriterKind.NOTICE, err);
306 
307         writers.put(WriterKind.STDOUT, out);
308         writers.put(WriterKind.STDERR, err);
309 
310         return writers;
311     }
312 
313     /**
314      * Construct a log with given I/O redirections.
315      * @deprecated
316      * This constructor is provided to support the supported but now-deprecated javadoc entry point
317      *      com.sun.tools.javadoc.Main.execute(String programName,
318      *          PrintWriter errWriter, PrintWriter warnWriter, PrintWriter noticeWriter,
319      *          String defaultDocletClassName, String... args)
320      */
321     @Deprecated
322     protected Log(Context context, PrintWriter errWriter, PrintWriter warnWriter, PrintWriter noticeWriter) {
323         this(context, initWriters(errWriter, warnWriter, noticeWriter));
324     }
325 
326     /**
327      * Initialize a writer map with different streams for different types of diagnostics.
328      * @param errWriter a stream for writing error messages
329      * @param warnWriter a stream for writing warning messages
330      * @param noticeWriter a stream for writing notice messages
331      * @return a map of writers
332      * @deprecated This method exists to support a supported but now deprecated javadoc entry point.
333      */
334     @Deprecated
335     private static Map&lt;WriterKind, PrintWriter&gt;  initWriters(PrintWriter errWriter, PrintWriter warnWriter, PrintWriter noticeWriter) {
336         Map&lt;WriterKind, PrintWriter&gt; writers = new EnumMap&lt;&gt;(WriterKind.class);
337         writers.put(WriterKind.ERROR, errWriter);
338         writers.put(WriterKind.WARNING, warnWriter);
339         writers.put(WriterKind.NOTICE, noticeWriter);
340 
341         writers.put(WriterKind.STDOUT, noticeWriter);
342         writers.put(WriterKind.STDERR, errWriter);
343 
344         return writers;
345     }
346 
347     /**
348      * Creates a log.
349      * @param context the context in which the log should be registered
350      * @param writers a map of writers that can be accessed by the kind of writer required
351      */
352     private Log(Context context, Map&lt;WriterKind, PrintWriter&gt; writers) {
353         super(JCDiagnostic.Factory.instance(context));
354         context.put(logKey, this);
355         this.writers = writers;
356 
357         @SuppressWarnings(&quot;unchecked&quot;) // FIXME
358         DiagnosticListener&lt;? super JavaFileObject&gt; dl =
359             context.get(DiagnosticListener.class);
360         this.diagListener = dl;
361 
362         diagnosticHandler = new DefaultDiagnosticHandler();
363 
364         messages = JavacMessages.instance(context);
365         messages.add(Main.javacBundleName);
366 
367         final Options options = Options.instance(context);
368         initOptions(options);
369         options.addListener(() -&gt; initOptions(options));
370     }
371     // where
372         private void initOptions(Options options) {
373             this.dumpOnError = options.isSet(DOE);
374             this.promptOnError = options.isSet(PROMPT);
375             this.emitWarnings = options.isUnset(XLINT_CUSTOM, &quot;none&quot;);
376             this.suppressNotes = options.isSet(&quot;suppressNotes&quot;);
377             this.MaxErrors = getIntOption(options, XMAXERRS, getDefaultMaxErrors());
378             this.MaxWarnings = getIntOption(options, XMAXWARNS, getDefaultMaxWarnings());
379 
380             boolean rawDiagnostics = options.isSet(&quot;rawDiagnostics&quot;);
381             this.diagFormatter = rawDiagnostics ? new RawDiagnosticFormatter(options) :
382                                                   new BasicDiagnosticFormatter(options, messages);
383 
384             String ek = options.get(&quot;expectKeys&quot;);
385             if (ek != null)
386                 expectDiagKeys = new HashSet&lt;&gt;(Arrays.asList(ek.split(&quot;, *&quot;)));
387         }
388 
389         private int getIntOption(Options options, Option option, int defaultValue) {
390             String s = options.get(option);
391             try {
392                 if (s != null) {
393                     int n = Integer.parseInt(s);
394                     return (n &lt;= 0 ? Integer.MAX_VALUE : n);
395                 }
396             } catch (NumberFormatException e) {
397                 // silently ignore ill-formed numbers
398             }
399             return defaultValue;
400         }
401 
402         /** Default value for -Xmaxerrs.
403          */
404         protected int getDefaultMaxErrors() {
405             return 100;
406         }
407 
408         /** Default value for -Xmaxwarns.
409          */
410         protected int getDefaultMaxWarnings() {
411             return 100;
412         }
413 
414     /** The number of errors encountered so far.
415      */
416     public int nerrors = 0;
417 
418     /** The number of warnings encountered so far.
419      */
420     public int nwarnings = 0;
421 
422     /** A set of all errors generated so far. This is used to avoid printing an
423      *  error message more than once. For each error, a pair consisting of the
424      *  source file name and source code position of the error is added to the set.
425      */
426     protected Set&lt;Pair&lt;JavaFileObject, Integer&gt;&gt; recorded = new HashSet&lt;&gt;();
427 
428     /** A set of &quot;not-supported-in-source-X&quot; errors produced so far. This is used to only generate
429      *  one such error per file.
430      */
431     protected Set&lt;Pair&lt;JavaFileObject, List&lt;String&gt;&gt;&gt;  recordedSourceLevelErrors = new HashSet&lt;&gt;();
432 
433     public boolean hasDiagnosticListener() {
434         return diagListener != null;
435     }
436 
437     public void setEndPosTable(JavaFileObject name, EndPosTable endPosTable) {
438         Assert.checkNonNull(name);
439         getSource(name).setEndPosTable(endPosTable);
440     }
441 
442     /** Return current sourcefile.
443      */
444     public JavaFileObject currentSourceFile() {
445         return source == null ? null : source.getFile();
446     }
447 
448     /** Get the current diagnostic formatter.
449      */
450     public DiagnosticFormatter&lt;JCDiagnostic&gt; getDiagnosticFormatter() {
451         return diagFormatter;
452     }
453 
454     /** Set the current diagnostic formatter.
455      */
456     public void setDiagnosticFormatter(DiagnosticFormatter&lt;JCDiagnostic&gt; diagFormatter) {
457         this.diagFormatter = diagFormatter;
458     }
459 
460     public PrintWriter getWriter(WriterKind kind) {
461         return writers.get(kind);
462     }
463 
464     public void setWriter(WriterKind kind, PrintWriter pw) {
465         Assert.checkNonNull(pw);
466         writers.put(kind, pw);
467     }
468 
469     public void setWriters(PrintWriter pw) {
470         Assert.checkNonNull(pw);
471         for (WriterKind k: WriterKind.values())
472             writers.put(k, pw);
473     }
474 
475     /**
476      * Replace the specified diagnostic handler with the
477      * handler that was current at the time this handler was created.
478      * The given handler must be the currently installed handler;
479      * it must be specified explicitly for clarity and consistency checking.
480      */
481     public void popDiagnosticHandler(DiagnosticHandler h) {
482         Assert.check(diagnosticHandler == h);
483         diagnosticHandler = h.prev;
484     }
485 
486     /** Flush the logs
487      */
488     public void flush() {
489         for (PrintWriter pw: writers.values()) {
490             pw.flush();
491         }
492     }
493 
494     public void flush(WriterKind kind) {
495         getWriter(kind).flush();
496     }
497 
498     /** Returns true if an error needs to be reported for a given
499      * source name and pos.
500      */
501     protected boolean shouldReport(JavaFileObject file, int pos) {
502         if (file == null)
503             return true;
504 
505         Pair&lt;JavaFileObject,Integer&gt; coords = new Pair&lt;&gt;(file, pos);
506         boolean shouldReport = !recorded.contains(coords);
507         if (shouldReport)
508             recorded.add(coords);
509         return shouldReport;
510     }
511 
512     /** Returns true if a diagnostics needs to be reported.
513      */
514     private boolean shouldReport(JCDiagnostic d) {
515         JavaFileObject file = d.getSource();
516 
517         if (file == null)
518             return true;
519 
520         if (!shouldReport(file, d.getIntPosition()))
521             return false;
522 
523         if (!d.isFlagSet(DiagnosticFlag.SOURCE_LEVEL))
524             return true;
525 
526         Pair&lt;JavaFileObject, List&lt;String&gt;&gt; coords = new Pair&lt;&gt;(file, getCode(d));
527         boolean shouldReport = !recordedSourceLevelErrors.contains(coords);
528         if (shouldReport)
529             recordedSourceLevelErrors.add(coords);
530         return shouldReport;
531     }
532 
533     //where
534         private List&lt;String&gt; getCode(JCDiagnostic d) {
535             ListBuffer&lt;String&gt; buf = new ListBuffer&lt;&gt;();
536             getCodeRecursive(buf, d);
537             return buf.toList();
538         }
539 
540         private void getCodeRecursive(ListBuffer&lt;String&gt; buf, JCDiagnostic d) {
541             buf.add(d.getCode());
542             for (Object o : d.getArgs()) {
543                 if (o instanceof JCDiagnostic) {
544                     getCodeRecursive(buf, (JCDiagnostic)o);
545                 }
546             }
547         }
548 
549     /** Prompt user after an error.
550      */
551     public void prompt() {
552         if (promptOnError) {
553             System.err.println(localize(&quot;resume.abort&quot;));
554             try {
555                 while (true) {
556                     switch (System.in.read()) {
557                     case &#39;a&#39;: case &#39;A&#39;:
558                         System.exit(-1);
559                         return;
560                     case &#39;r&#39;: case &#39;R&#39;:
561                         return;
562                     case &#39;x&#39;: case &#39;X&#39;:
563                         throw new AssertionError(&quot;user abort&quot;);
564                     default:
565                     }
566                 }
567             } catch (IOException e) {}
568         }
569     }
570 
571     /** Print the faulty source code line and point to the error.
572      *  @param pos   Buffer index of the error position, must be on current line
573      */
574     private void printErrLine(int pos, PrintWriter writer) {
575         String line = (source == null ? null : source.getLine(pos));
576         if (line == null)
577             return;
578         int col = source.getColumnNumber(pos, false);
579 
580         printRawLines(writer, line);
581         for (int i = 0; i &lt; col - 1; i++) {
582             writer.print((line.charAt(i) == &#39;\t&#39;) ? &quot;\t&quot; : &quot; &quot;);
583         }
584         writer.println(&quot;^&quot;);
585         writer.flush();
586     }
587 
588     public void printNewline() {
589         PrintWriter noticeWriter = writers.get(WriterKind.NOTICE);
590         noticeWriter.println();
591     }
592 
593     public void printNewline(WriterKind wk) {
594         getWriter(wk).println();
595     }
596 
597     public void printLines(String key, Object... args) {
598         PrintWriter noticeWriter = writers.get(WriterKind.NOTICE);
599         printRawLines(noticeWriter, localize(key, args));
600     }
601 
602     public void printLines(DiagnosticInfo diag) {
603         PrintWriter noticeWriter = writers.get(WriterKind.NOTICE);
604         printRawLines(noticeWriter, localize(diag));
605     }
606 
607     public void printLines(PrefixKind pk, String key, Object... args) {
608         PrintWriter noticeWriter = writers.get(WriterKind.NOTICE);
609         printRawLines(noticeWriter, localize(pk, key, args));
610     }
611 
612     public void printLines(WriterKind wk, String key, Object... args) {
613         printRawLines(getWriter(wk), localize(key, args));
614     }
615 
616     public void printLines(WriterKind wk, PrefixKind pk, String key, Object... args) {
617         printRawLines(getWriter(wk), localize(pk, key, args));
618     }
619 
620     /** Print the text of a message, translating newlines appropriately
621      *  for the platform.
622      */
623     public void printRawLines(String msg) {
624         PrintWriter noticeWriter = writers.get(WriterKind.NOTICE);
625         printRawLines(noticeWriter, msg);
626     }
627 
628     /** Print the text of a message, translating newlines appropriately
629      *  for the platform.
630      */
631     public void printRawLines(WriterKind kind, String msg) {
632         printRawLines(getWriter(kind), msg);
633     }
634 
635     /** Print the text of a message, translating newlines appropriately
636      *  for the platform.
637      */
638     public static void printRawLines(PrintWriter writer, String msg) {
639         int nl;
640         while ((nl = msg.indexOf(&#39;\n&#39;)) != -1) {
641             writer.println(msg.substring(0, nl));
642             msg = msg.substring(nl+1);
643         }
644         if (msg.length() != 0) writer.println(msg);
645     }
646 
647     /**
648      * Print the localized text of a &quot;verbose&quot; message to the
649      * noticeWriter stream.
650      */
651     public void printVerbose(String key, Object... args) {
652         PrintWriter noticeWriter = writers.get(WriterKind.NOTICE);
653         printRawLines(noticeWriter, localize(&quot;verbose.&quot; + key, args));
654     }
655 
656     @Override
657     protected void directError(String key, Object... args) {
658         PrintWriter errWriter = writers.get(WriterKind.ERROR);
659         printRawLines(errWriter, localize(key, args));
660         errWriter.flush();
661     }
662 
663     /** Report a warning that cannot be suppressed.
664      *  @param pos    The source position at which to report the warning.
665      *  @param key    The key for the localized warning message.
666      *  @param args   Fields of the warning message.
667      */
668     public void strictWarning(DiagnosticPosition pos, String key, Object ... args) {
669         writeDiagnostic(diags.warning(null, source, pos, key, args));
670         nwarnings++;
671     }
672 
673     /**
674      * Primary method to report a diagnostic.
675      * @param diagnostic
676      */
677     @Override
678     public void report(JCDiagnostic diagnostic) {
679         diagnosticHandler.report(diagnostic);
680      }
681 
682     /**
683      * Common diagnostic handling.
684      * The diagnostic is counted, and depending on the options and how many diagnostics have been
685      * reported so far, the diagnostic may be handed off to writeDiagnostic.
686      */
687     private class DefaultDiagnosticHandler extends DiagnosticHandler {
688         @Override
689         public void report(JCDiagnostic diagnostic) {
690             if (expectDiagKeys != null)
691                 expectDiagKeys.remove(diagnostic.getCode());
692 
693             switch (diagnostic.getType()) {
694             case FRAGMENT:
695                 throw new IllegalArgumentException();
696 
697             case NOTE:
698                 // Print out notes only when we are permitted to report warnings
699                 // Notes are only generated at the end of a compilation, so should be small
700                 // in number.
701                 if ((emitWarnings || diagnostic.isMandatory()) &amp;&amp; !suppressNotes) {
702                     writeDiagnostic(diagnostic);
703                 }
704                 break;
705 
706             case WARNING:
707                 if (emitWarnings || diagnostic.isMandatory()) {
708                     if (nwarnings &lt; MaxWarnings) {
709                         writeDiagnostic(diagnostic);
710                         nwarnings++;
711                     }
712                 }
713                 break;
714 
715             case ERROR:
716                 if (nerrors &lt; MaxErrors &amp;&amp;
717                     (diagnostic.isFlagSet(DiagnosticFlag.API) ||
718                      shouldReport(diagnostic))) {
719                     writeDiagnostic(diagnostic);
720                     nerrors++;
721                 }
722                 break;
723             }
724             if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {
725                 compressedOutput = true;
726             }
727         }
728     }
729 
730     /**
731      * Write out a diagnostic.
732      */
733     protected void writeDiagnostic(JCDiagnostic diag) {
734         if (diagListener != null) {
735             diagListener.report(diag);
736             return;
737         }
738 
739         PrintWriter writer = getWriterForDiagnosticType(diag.getType());
740 
741         printRawLines(writer, diagFormatter.format(diag, messages.getCurrentLocale()));
742 
743         if (promptOnError) {
744             switch (diag.getType()) {
745             case ERROR:
746             case WARNING:
747                 prompt();
748             }
749         }
750 
751         if (dumpOnError)
752             new RuntimeException().printStackTrace(writer);
753 
754         writer.flush();
755     }
756 
757     @Deprecated
758     protected PrintWriter getWriterForDiagnosticType(DiagnosticType dt) {
759         switch (dt) {
760         case FRAGMENT:
761             throw new IllegalArgumentException();
762 
763         case NOTE:
764             return writers.get(WriterKind.NOTICE);
765 
766         case WARNING:
767             return writers.get(WriterKind.WARNING);
768 
769         case ERROR:
770             return writers.get(WriterKind.ERROR);
771 
772         default:
773             throw new Error();
774         }
775     }
776 
777     /** Find a localized string in the resource bundle.
778      *  Because this method is static, it ignores the locale.
779      *  Use localize(key, args) when possible.
780      *  @param key    The key for the localized string.
781      *  @param args   Fields to substitute into the string.
782      */
783     public static String getLocalizedString(String key, Object ... args) {
784         return JavacMessages.getDefaultLocalizedString(PrefixKind.COMPILER_MISC.key(key), args);
785     }
786 
787     /** Find a localized string in the resource bundle.
788      *  @param key    The key for the localized string.
789      *  @param args   Fields to substitute into the string.
790      */
791     public String localize(String key, Object... args) {
792         return localize(PrefixKind.COMPILER_MISC, key, args);
793     }
794 
795     public String localize(JCDiagnostic.DiagnosticInfo diagInfo) {
796         if (useRawMessages) {
797             return diagInfo.key();
798         } else {
799             return messages.getLocalizedString(diagInfo);
800         }
801     }
802 
803     /** Find a localized string in the resource bundle.
804      *  @param key    The key for the localized string.
805      *  @param args   Fields to substitute into the string.
806      */
807     public String localize(PrefixKind pk, String key, Object... args) {
808         if (useRawMessages)
809             return pk.key(key);
810         else
811             return messages.getLocalizedString(pk.key(key), args);
812     }
813     // where
814         // backdoor hook for testing, should transition to use -XDrawDiagnostics
815         private static boolean useRawMessages = false;
816 
817 /***************************************************************************
818  * raw error messages without internationalization; used for experimentation
819  * and quick prototyping
820  ***************************************************************************/
821 
822     /** print an error or warning message:
823      */
824     private void printRawDiag(PrintWriter pw, String prefix, int pos, String msg) {
825         if (source == null || pos == Position.NOPOS) {
826             printRawLines(pw, prefix + msg);
827         } else {
828             int line = source.getLineNumber(pos);
829             JavaFileObject file = source.getFile();
830             if (file != null)
831                 printRawLines(pw,
832                            file.getName() + &quot;:&quot; +
833                            line + &quot;: &quot; + msg);
834             printErrLine(pos, pw);
835         }
836         pw.flush();
837     }
838 
839     /** report an error:
840      */
841     public void rawError(int pos, String msg) {
842         PrintWriter errWriter = writers.get(WriterKind.ERROR);
843         if (nerrors &lt; MaxErrors &amp;&amp; shouldReport(currentSourceFile(), pos)) {
844             printRawDiag(errWriter, &quot;error: &quot;, pos, msg);
845             prompt();
846             nerrors++;
847         }
848         errWriter.flush();
849     }
850 
851     /** report a warning:
852      */
853     public void rawWarning(int pos, String msg) {
854         PrintWriter warnWriter = writers.get(WriterKind.ERROR);
855         if (nwarnings &lt; MaxWarnings &amp;&amp; emitWarnings) {
856             printRawDiag(warnWriter, &quot;warning: &quot;, pos, msg);
857         }
858         prompt();
859         nwarnings++;
860         warnWriter.flush();
861     }
862 
863     public static String format(String fmt, Object... args) {
864         return String.format((java.util.Locale)null, fmt, args);
865     }
866 
867 }
    </pre>
  </body>
</html>
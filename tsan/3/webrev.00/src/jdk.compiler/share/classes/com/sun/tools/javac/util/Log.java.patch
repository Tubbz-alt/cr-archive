diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Log.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Log.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Log.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/util/Log.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -417,10 +417,18 @@
 
     /** The number of warnings encountered so far.
      */
     public int nwarnings = 0;
 
+    /** The number of errors encountered after MaxErrors was reached.
+     */
+    public int nsuppressederrors = 0;
+
+    /** The number of warnings encountered after MaxWarnings was reached.
+     */
+    public int nsuppressedwarns = 0;
+
     /** A set of all errors generated so far. This is used to avoid printing an
      *  error message more than once. For each error, a pair consisting of the
      *  source file name and source code position of the error is added to the set.
      */
     protected Set<Pair<JavaFileObject, Integer>> recorded = new HashSet<>();
@@ -544,10 +552,17 @@
                     getCodeRecursive(buf, (JCDiagnostic)o);
                 }
             }
         }
 
+    /**Is an error reported at the given pos (inside the current source)?*/
+    public boolean hasErrorOn(DiagnosticPosition pos) {
+        JavaFileObject file = source != null ? source.fileObject : null;
+
+        return file != null && recorded.contains(new Pair<>(file, pos.getPreferredPosition()));
+    }
+
     /** Prompt user after an error.
      */
     public void prompt() {
         if (promptOnError) {
             System.err.println(localize("resume.abort"));
@@ -706,20 +721,25 @@
             case WARNING:
                 if (emitWarnings || diagnostic.isMandatory()) {
                     if (nwarnings < MaxWarnings) {
                         writeDiagnostic(diagnostic);
                         nwarnings++;
+                    } else {
+                        nsuppressedwarns++;
                     }
                 }
                 break;
 
             case ERROR:
-                if (nerrors < MaxErrors &&
-                    (diagnostic.isFlagSet(DiagnosticFlag.API) ||
-                     shouldReport(diagnostic))) {
-                    writeDiagnostic(diagnostic);
-                    nerrors++;
+                if (diagnostic.isFlagSet(DiagnosticFlag.API) ||
+                     shouldReport(diagnostic)) {
+                    if (nerrors < MaxErrors) {
+                        writeDiagnostic(diagnostic);
+                        nerrors++;
+                    } else {
+                        nsuppressederrors++;
+                    }
                 }
                 break;
             }
             if (diagnostic.isFlagSet(JCDiagnostic.DiagnosticFlag.COMPRESSED)) {
                 compressedOutput = true;
@@ -842,20 +862,26 @@
         PrintWriter errWriter = writers.get(WriterKind.ERROR);
         if (nerrors < MaxErrors && shouldReport(currentSourceFile(), pos)) {
             printRawDiag(errWriter, "error: ", pos, msg);
             prompt();
             nerrors++;
+        } else {
+            nsuppressederrors++;
         }
         errWriter.flush();
     }
 
     /** report a warning:
      */
     public void rawWarning(int pos, String msg) {
         PrintWriter warnWriter = writers.get(WriterKind.ERROR);
-        if (nwarnings < MaxWarnings && emitWarnings) {
-            printRawDiag(warnWriter, "warning: ", pos, msg);
+        if (emitWarnings) {
+            if (nwarnings < MaxWarnings) {
+                printRawDiag(warnWriter, "warning: ", pos, msg);
+            } else {
+                nsuppressedwarns++;
+            }
         }
         prompt();
         nwarnings++;
         warnWriter.flush();
     }

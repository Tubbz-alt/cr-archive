<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTaskPool.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClientCodeWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacTrees.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTaskPool.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import java.io.Writer;
 30 import java.util.ArrayDeque;
 31 import java.util.ArrayList;
 32 import java.util.Collection;
 33 import java.util.HashMap;
 34 import java.util.HashSet;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Queue;
 38 import java.util.Set;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.StreamSupport;
 41 
 42 import javax.tools.Diagnostic;
 43 import javax.tools.DiagnosticListener;
 44 import javax.tools.JavaFileManager;
 45 import javax.tools.JavaFileObject;
 46 
 47 import com.sun.source.tree.ClassTree;
 48 import com.sun.source.tree.CompilationUnitTree;

 49 import com.sun.source.util.JavacTask;
 50 import com.sun.source.util.TaskEvent;
 51 import com.sun.source.util.TaskEvent.Kind;
 52 import com.sun.source.util.TaskListener;
 53 import com.sun.source.util.TreeScanner;
 54 import com.sun.tools.javac.code.Kinds;

 55 import com.sun.tools.javac.code.Symbol;
 56 import com.sun.tools.javac.code.Symtab;
 57 import com.sun.tools.javac.code.Type;
 58 import com.sun.tools.javac.code.Type.ClassType;
 59 import com.sun.tools.javac.code.TypeTag;
 60 import com.sun.tools.javac.code.Types;
 61 import com.sun.tools.javac.comp.Annotate;
 62 import com.sun.tools.javac.comp.Check;
 63 import com.sun.tools.javac.comp.CompileStates;
 64 import com.sun.tools.javac.comp.Enter;
 65 import com.sun.tools.javac.comp.Modules;
 66 import com.sun.tools.javac.main.Arguments;
 67 import com.sun.tools.javac.main.JavaCompiler;
 68 import com.sun.tools.javac.model.JavacElements;
 69 import com.sun.tools.javac.tree.JCTree.JCClassDecl;

 70 import com.sun.tools.javac.util.Context;
 71 import com.sun.tools.javac.util.DefinedBy;
 72 import com.sun.tools.javac.util.DefinedBy.Api;
 73 import com.sun.tools.javac.util.Log;
 74 
 75 /**
 76  * A pool of reusable JavacTasks. When a task is no valid anymore, it is returned to the pool,
 77  * and its Context may be reused for future processing in some cases. The reuse is achieved
 78  * by replacing some components (most notably JavaCompiler and Log) with reusable counterparts,
 79  * and by cleaning up leftovers from previous compilation.
 80  * &lt;p&gt;
 81  * For each combination of options, a separate task/context is created and kept, as most option
 82  * values are cached inside components themselves.
 83  * &lt;p&gt;
 84  * When the compilation redefines sensitive classes (e.g. classes in the the java.* packages), the
 85  * task/context is not reused.
 86  * &lt;p&gt;
 87  * When the task is reused, then packages that were already listed won&#39;t be listed again.
 88  * &lt;p&gt;
 89  * Care must be taken to only return tasks that won&#39;t be used by the original caller.
</pre>
<hr />
<pre>
109     private int statReused = 0;
110     private int statNew = 0;
111     private int statPolluted = 0;
112     private int statRemoved = 0;
113 
114     /**Creates the pool.
115      *
116      * @param maxPoolSize maximum number of tasks/context that will be kept in the pool.
117      */
118     public JavacTaskPool(int maxPoolSize) {
119         this.maxPoolSize = maxPoolSize;
120     }
121 
122     /**Creates a new task as if by {@link javax.tools.JavaCompiler#getTask} and runs the provided
123      * worker with it. The task is only valid while the worker is running. The internal structures
124      * may be reused from some previous compilation.
125      *
126      * @param out a Writer for additional output from the compiler;
127      * use {@code System.err} if {@code null}
128      * @param fileManager a file manager; if {@code null} use the
<span class="line-modified">129      * compiler&#39;s standard filemanager</span>
130      * @param diagnosticListener a diagnostic listener; if {@code
131      * null} use the compiler&#39;s default method for reporting
132      * diagnostics
133      * @param options compiler options, {@code null} means no options
134      * @param classes names of classes to be processed by annotation
135      * processing, {@code null} means no class names
136      * @param compilationUnits the compilation units to compile, {@code
137      * null} means no compilation units
138      * @param worker that should be run with the task
139      * @return an object representing the compilation
140      * @throws RuntimeException if an unrecoverable error
141      * occurred in a user supplied component.  The
142      * {@linkplain Throwable#getCause() cause} will be the error in
143      * user code.
144      * @throws IllegalArgumentException if any of the options are invalid,
145      * or if any of the given compilation units are of other kind than
146      * {@linkplain JavaFileObject.Kind#SOURCE source}
147      */
148     public &lt;Z&gt; Z getTask(Writer out,
149                          JavaFileManager fileManager,
</pre>
<hr />
<pre>
240             put(JavaCompiler.compilerKey, ReusableJavaCompiler.factory);
241         }
242 
243         void clear() {
244             drop(Arguments.argsKey);
245             drop(DiagnosticListener.class);
246             drop(Log.outKey);
247             drop(Log.errKey);
248             drop(JavaFileManager.class);
249             drop(JavacTask.class);
250             drop(JavacTrees.class);
251             drop(JavacElements.class);
252 
253             if (ht.get(Log.logKey) instanceof ReusableLog) {
254                 //log already inited - not first round
255                 ((ReusableLog)Log.instance(this)).clear();
256                 Enter.instance(this).newRound();
257                 ((ReusableJavaCompiler)ReusableJavaCompiler.instance(this)).clear();
258                 Types.instance(this).newRound();
259                 Check.instance(this).newRound();


260                 Modules.instance(this).newRound();
261                 Annotate.instance(this).newRound();
262                 CompileStates.instance(this).clear();
263                 MultiTaskListener.instance(this).clear();
264 
265                 //find if any of the roots have redefined java.* classes
266                 Symtab syms = Symtab.instance(this);
267                 pollutionScanner.scan(roots, syms);
268                 roots.clear();
269             }
270         }
271 
272         /**
273          * This scanner detects as to whether the shared context has been polluted. This happens
274          * whenever a compiled program redefines a core class (in &#39;java.*&#39; package) or when
275          * (typically because of cyclic inheritance) the symbol kind of a core class has been touched.
276          */
277         TreeScanner&lt;Void, Symtab&gt; pollutionScanner = new TreeScanner&lt;Void, Symtab&gt;() {












278             @Override @DefinedBy(Api.COMPILER_TREE)
279             public Void visitClass(ClassTree node, Symtab syms) {
280                 Symbol sym = ((JCClassDecl)node).sym;
281                 if (sym != null) {
282                     syms.removeClass(sym.packge().modle, sym.flatName());
283                     Type sup = supertype(sym);
284                     if (isCoreClass(sym) ||
285                             (sup != null &amp;&amp; isCoreClass(sup.tsym) &amp;&amp; sup.tsym.kind != Kinds.Kind.TYP)) {
286                         polluted = true;
287                     }
288                 }
289                 return super.visitClass(node, syms);
290             }
291 
292             private boolean isCoreClass(Symbol s) {
293                 return s.flatName().toString().startsWith(&quot;java.&quot;);
294             }
295 
296             private Type supertype(Symbol s) {
297                 if (s.type == null ||
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 import java.io.Writer;
 30 import java.util.ArrayDeque;
 31 import java.util.ArrayList;
 32 import java.util.Collection;
 33 import java.util.HashMap;
 34 import java.util.HashSet;
 35 import java.util.List;
 36 import java.util.Map;
 37 import java.util.Queue;
 38 import java.util.Set;
 39 import java.util.stream.Collectors;
 40 import java.util.stream.StreamSupport;
 41 
 42 import javax.tools.Diagnostic;
 43 import javax.tools.DiagnosticListener;
 44 import javax.tools.JavaFileManager;
 45 import javax.tools.JavaFileObject;
 46 
 47 import com.sun.source.tree.ClassTree;
 48 import com.sun.source.tree.CompilationUnitTree;
<span class="line-added"> 49 import com.sun.source.tree.Tree;</span>
 50 import com.sun.source.util.JavacTask;
 51 import com.sun.source.util.TaskEvent;
 52 import com.sun.source.util.TaskEvent.Kind;
 53 import com.sun.source.util.TaskListener;
 54 import com.sun.source.util.TreeScanner;
 55 import com.sun.tools.javac.code.Kinds;
<span class="line-added"> 56 import com.sun.tools.javac.code.Preview;</span>
 57 import com.sun.tools.javac.code.Symbol;
 58 import com.sun.tools.javac.code.Symtab;
 59 import com.sun.tools.javac.code.Type;
 60 import com.sun.tools.javac.code.Type.ClassType;
 61 import com.sun.tools.javac.code.TypeTag;
 62 import com.sun.tools.javac.code.Types;
 63 import com.sun.tools.javac.comp.Annotate;
 64 import com.sun.tools.javac.comp.Check;
 65 import com.sun.tools.javac.comp.CompileStates;
 66 import com.sun.tools.javac.comp.Enter;
 67 import com.sun.tools.javac.comp.Modules;
 68 import com.sun.tools.javac.main.Arguments;
 69 import com.sun.tools.javac.main.JavaCompiler;
 70 import com.sun.tools.javac.model.JavacElements;
 71 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
<span class="line-added"> 72 import com.sun.tools.javac.tree.JCTree.LetExpr;</span>
 73 import com.sun.tools.javac.util.Context;
 74 import com.sun.tools.javac.util.DefinedBy;
 75 import com.sun.tools.javac.util.DefinedBy.Api;
 76 import com.sun.tools.javac.util.Log;
 77 
 78 /**
 79  * A pool of reusable JavacTasks. When a task is no valid anymore, it is returned to the pool,
 80  * and its Context may be reused for future processing in some cases. The reuse is achieved
 81  * by replacing some components (most notably JavaCompiler and Log) with reusable counterparts,
 82  * and by cleaning up leftovers from previous compilation.
 83  * &lt;p&gt;
 84  * For each combination of options, a separate task/context is created and kept, as most option
 85  * values are cached inside components themselves.
 86  * &lt;p&gt;
 87  * When the compilation redefines sensitive classes (e.g. classes in the the java.* packages), the
 88  * task/context is not reused.
 89  * &lt;p&gt;
 90  * When the task is reused, then packages that were already listed won&#39;t be listed again.
 91  * &lt;p&gt;
 92  * Care must be taken to only return tasks that won&#39;t be used by the original caller.
</pre>
<hr />
<pre>
112     private int statReused = 0;
113     private int statNew = 0;
114     private int statPolluted = 0;
115     private int statRemoved = 0;
116 
117     /**Creates the pool.
118      *
119      * @param maxPoolSize maximum number of tasks/context that will be kept in the pool.
120      */
121     public JavacTaskPool(int maxPoolSize) {
122         this.maxPoolSize = maxPoolSize;
123     }
124 
125     /**Creates a new task as if by {@link javax.tools.JavaCompiler#getTask} and runs the provided
126      * worker with it. The task is only valid while the worker is running. The internal structures
127      * may be reused from some previous compilation.
128      *
129      * @param out a Writer for additional output from the compiler;
130      * use {@code System.err} if {@code null}
131      * @param fileManager a file manager; if {@code null} use the
<span class="line-modified">132      * compiler&#39;s standard file manager</span>
133      * @param diagnosticListener a diagnostic listener; if {@code
134      * null} use the compiler&#39;s default method for reporting
135      * diagnostics
136      * @param options compiler options, {@code null} means no options
137      * @param classes names of classes to be processed by annotation
138      * processing, {@code null} means no class names
139      * @param compilationUnits the compilation units to compile, {@code
140      * null} means no compilation units
141      * @param worker that should be run with the task
142      * @return an object representing the compilation
143      * @throws RuntimeException if an unrecoverable error
144      * occurred in a user supplied component.  The
145      * {@linkplain Throwable#getCause() cause} will be the error in
146      * user code.
147      * @throws IllegalArgumentException if any of the options are invalid,
148      * or if any of the given compilation units are of other kind than
149      * {@linkplain JavaFileObject.Kind#SOURCE source}
150      */
151     public &lt;Z&gt; Z getTask(Writer out,
152                          JavaFileManager fileManager,
</pre>
<hr />
<pre>
243             put(JavaCompiler.compilerKey, ReusableJavaCompiler.factory);
244         }
245 
246         void clear() {
247             drop(Arguments.argsKey);
248             drop(DiagnosticListener.class);
249             drop(Log.outKey);
250             drop(Log.errKey);
251             drop(JavaFileManager.class);
252             drop(JavacTask.class);
253             drop(JavacTrees.class);
254             drop(JavacElements.class);
255 
256             if (ht.get(Log.logKey) instanceof ReusableLog) {
257                 //log already inited - not first round
258                 ((ReusableLog)Log.instance(this)).clear();
259                 Enter.instance(this).newRound();
260                 ((ReusableJavaCompiler)ReusableJavaCompiler.instance(this)).clear();
261                 Types.instance(this).newRound();
262                 Check.instance(this).newRound();
<span class="line-added">263                 Check.instance(this).clear(); //clear mandatory warning handlers</span>
<span class="line-added">264                 Preview.instance(this).clear(); //clear mandatory warning handlers</span>
265                 Modules.instance(this).newRound();
266                 Annotate.instance(this).newRound();
267                 CompileStates.instance(this).clear();
268                 MultiTaskListener.instance(this).clear();
269 
270                 //find if any of the roots have redefined java.* classes
271                 Symtab syms = Symtab.instance(this);
272                 pollutionScanner.scan(roots, syms);
273                 roots.clear();
274             }
275         }
276 
277         /**
278          * This scanner detects as to whether the shared context has been polluted. This happens
279          * whenever a compiled program redefines a core class (in &#39;java.*&#39; package) or when
280          * (typically because of cyclic inheritance) the symbol kind of a core class has been touched.
281          */
282         TreeScanner&lt;Void, Symtab&gt; pollutionScanner = new TreeScanner&lt;Void, Symtab&gt;() {
<span class="line-added">283             @Override @DefinedBy(Api.COMPILER_TREE)</span>
<span class="line-added">284             public Void scan(Tree tree, Symtab syms) {</span>
<span class="line-added">285                 if (tree instanceof LetExpr) {</span>
<span class="line-added">286                     LetExpr le = (LetExpr) tree;</span>
<span class="line-added">287                     scan(le.defs, syms);</span>
<span class="line-added">288                     scan(le.expr, syms);</span>
<span class="line-added">289                     return null;</span>
<span class="line-added">290                 } else {</span>
<span class="line-added">291                     return super.scan(tree, syms);</span>
<span class="line-added">292                 }</span>
<span class="line-added">293             }</span>
<span class="line-added">294 </span>
295             @Override @DefinedBy(Api.COMPILER_TREE)
296             public Void visitClass(ClassTree node, Symtab syms) {
297                 Symbol sym = ((JCClassDecl)node).sym;
298                 if (sym != null) {
299                     syms.removeClass(sym.packge().modle, sym.flatName());
300                     Type sup = supertype(sym);
301                     if (isCoreClass(sym) ||
302                             (sup != null &amp;&amp; isCoreClass(sup.tsym) &amp;&amp; sup.tsym.kind != Kinds.Kind.TYP)) {
303                         polluted = true;
304                     }
305                 }
306                 return super.visitClass(node, syms);
307             }
308 
309             private boolean isCoreClass(Symbol s) {
310                 return s.flatName().toString().startsWith(&quot;java.&quot;);
311             }
312 
313             private Type supertype(Symbol s) {
314                 if (s.type == null ||
</pre>
</td>
</tr>
</table>
<center><a href="ClientCodeWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JavacTrees.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
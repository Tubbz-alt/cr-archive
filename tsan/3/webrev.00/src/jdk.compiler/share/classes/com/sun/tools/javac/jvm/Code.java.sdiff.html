<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClassWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Gen.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Code.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.*;
  29 import com.sun.tools.javac.code.Symbol.*;
<span class="line-removed">  30 import com.sun.tools.javac.code.Types.UniqueType;</span>
  31 import com.sun.tools.javac.resources.CompilerProperties.Errors;
<span class="line-removed">  32 import com.sun.tools.javac.tree.JCTree;</span>
  33 import com.sun.tools.javac.util.*;
  34 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  35 



  36 import static com.sun.tools.javac.code.TypeTag.BOT;
  37 import static com.sun.tools.javac.code.TypeTag.INT;
  38 import static com.sun.tools.javac.jvm.ByteCodes.*;











  39 import static com.sun.tools.javac.jvm.UninitializedType.*;
  40 import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableFrame;

  41 
  42 /** An internal structure that corresponds to the code attribute of
  43  *  methods in a classfile. The class also provides some utility operations to
  44  *  generate bytecode instructions.
  45  *
  46  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  47  *  If you write code that depends on this, you do so at your own risk.
  48  *  This code and its internal interfaces are subject to change or
  49  *  deletion without notice.&lt;/b&gt;
  50  */
  51 public class Code {
  52 
  53     public final boolean debugCode;
  54     public final boolean needStackMap;
  55 
  56     public enum StackMapFormat {
  57         NONE,
  58         CLDC {
  59             Name getAttributeName(Names names) {
  60                 return names.StackMap;
  61             }
  62         },
  63         JSR202 {
  64             Name getAttributeName(Names names) {
  65                 return names.StackMapTable;
  66             }
  67         };
  68         Name getAttributeName(Names names) {
  69             return names.empty;
  70         }
  71     }
  72 
  73     final Types types;
  74     final Symtab syms;

  75 
  76 /*---------- classfile fields: --------------- */
  77 
  78     /** The maximum stack size.
  79      */
  80     public int max_stack = 0;
  81 
  82     /** The maximum number of local variable slots.
  83      */
  84     public int max_locals = 0;
  85 
  86     /** The code buffer.
  87      */
  88     public byte[] code = new byte[64];
  89 
  90     /** the current code pointer.
  91      */
  92     public int cp = 0;
  93 
  94     /** Check the code against VM spec limits; if
</pre>
<hr />
<pre>
 160     int pendingStatPos = Position.NOPOS;
 161 
 162     /** Set true when a stackMap is needed at the current PC. */
 163     boolean pendingStackMap = false;
 164 
 165     /** The stack map format to be generated. */
 166     StackMapFormat stackMap;
 167 
 168     /** Switch: emit variable debug info.
 169      */
 170     boolean varDebugInfo;
 171 
 172     /** Switch: emit line number info.
 173      */
 174     boolean lineDebugInfo;
 175 
 176     /** Emit line number info if map supplied
 177      */
 178     Position.LineMap lineMap;
 179 
<span class="line-removed"> 180     /** The constant pool of the current class.</span>
<span class="line-removed"> 181      */</span>
<span class="line-removed"> 182     final Pool pool;</span>
<span class="line-removed"> 183 </span>
 184     final MethodSymbol meth;
 185 
 186     private int letExprStackPos = 0;
 187 
 188     /** Construct a code object, given the settings of the fatcode,
 189      *  debugging info switches and the CharacterRangeTable.
 190      */
 191     public Code(MethodSymbol meth,
 192                 boolean fatcode,
 193                 Position.LineMap lineMap,
 194                 boolean varDebugInfo,
 195                 StackMapFormat stackMap,
 196                 boolean debugCode,
 197                 CRTable crt,
 198                 Symtab syms,
 199                 Types types,
<span class="line-modified"> 200                 Pool pool) {</span>
 201         this.meth = meth;
 202         this.fatcode = fatcode;
 203         this.lineMap = lineMap;
 204         this.lineDebugInfo = lineMap != null;
 205         this.varDebugInfo = varDebugInfo;
 206         this.crt = crt;
 207         this.syms = syms;
 208         this.types = types;

 209         this.debugCode = debugCode;
 210         this.stackMap = stackMap;
 211         switch (stackMap) {
 212         case CLDC:
 213         case JSR202:
 214             this.needStackMap = true;
 215             break;
 216         default:
 217             this.needStackMap = false;
 218         }
 219         state = new State();
 220         lvar = new LocalVar[20];
<span class="line-removed"> 221         this.pool = pool;</span>
 222     }
 223 
 224 
 225 /* **************************************************************************
 226  * Typecodes &amp; related stuff
 227  ****************************************************************************/
 228 
 229     /** Given a type, return its type code (used implicitly in the
 230      *  JVM architecture).
 231      */
 232     public static int typecode(Type type) {
 233         switch (type.getTag()) {
 234         case BYTE: return BYTEcode;
 235         case SHORT: return SHORTcode;
 236         case CHAR: return CHARcode;
 237         case INT: return INTcode;
 238         case LONG: return LONGcode;
 239         case FLOAT: return FLOATcode;
 240         case DOUBLE: return DOUBLEcode;
 241         case BOOLEAN: return BYTEcode;
</pre>
<hr />
<pre>
 372             if (pendingStatPos != Position.NOPOS)
 373                 markStatBegin();
 374             if (pendingStackMap) {
 375                 pendingStackMap = false;
 376                 emitStackMap();
 377             }
 378             if (debugCode)
 379                 System.err.println(&quot;emit@&quot; + cp + &quot; stack=&quot; +
 380                                    state.stacksize + &quot;: &quot; +
 381                                    mnem(op));
 382             emit1(op);
 383         }
 384     }
 385 
 386     void postop() {
 387         Assert.check(alive || isStatementStart());
 388     }
 389 
 390     /** Emit a ldc (or ldc_w) instruction, taking into account operand size
 391     */
<span class="line-modified"> 392     public void emitLdc(int od) {</span>

 393         if (od &lt;= 255) {
<span class="line-modified"> 394             emitop1(ldc1, od);</span>
 395         }
 396         else {
<span class="line-modified"> 397             emitop2(ldc2, od);</span>
 398         }
 399     }
 400 
 401     /** Emit a multinewarray instruction.
 402      */
 403     public void emitMultianewarray(int ndims, int type, Type arrayType) {
 404         emitop(multianewarray);
 405         if (!alive) return;
 406         emit2(type);
 407         emit1(ndims);
 408         state.pop(ndims);
 409         state.push(arrayType);
 410     }
 411 
 412     /** Emit newarray.
 413      */
 414     public void emitNewarray(int elemcode, Type arrayType) {
 415         emitop(newarray);
 416         if (!alive) return;
 417         emit1(elemcode);
 418         state.pop(1); // count
 419         state.push(arrayType);
 420     }
 421 
 422     /** Emit anewarray.
 423      */
 424     public void emitAnewarray(int od, Type arrayType) {
 425         emitop(anewarray);
 426         if (!alive) return;
 427         emit2(od);
 428         state.pop(1);
 429         state.push(arrayType);
 430     }
 431 
 432     /** Emit an invokeinterface instruction.
 433      */
<span class="line-modified"> 434     public void emitInvokeinterface(int meth, Type mtype) {</span>
 435         int argsize = width(mtype.getParameterTypes());
 436         emitop(invokeinterface);
 437         if (!alive) return;
<span class="line-modified"> 438         emit2(meth);</span>
 439         emit1(argsize + 1);
 440         emit1(0);
 441         state.pop(argsize + 1);
 442         state.push(mtype.getReturnType());
 443     }
 444 
 445     /** Emit an invokespecial instruction.
 446      */
<span class="line-modified"> 447     public void emitInvokespecial(int meth, Type mtype) {</span>
 448         int argsize = width(mtype.getParameterTypes());
 449         emitop(invokespecial);
 450         if (!alive) return;
<span class="line-modified"> 451         emit2(meth);</span>
<span class="line-removed"> 452         Symbol sym = (Symbol)pool.pool[meth];</span>
 453         state.pop(argsize);
<span class="line-modified"> 454         if (sym.isConstructor())</span>
 455             state.markInitialized((UninitializedType)state.peek());
 456         state.pop(1);
 457         state.push(mtype.getReturnType());
 458     }
 459 
 460     /** Emit an invokestatic instruction.
 461      */
<span class="line-modified"> 462     public void emitInvokestatic(int meth, Type mtype) {</span>
 463         int argsize = width(mtype.getParameterTypes());
 464         emitop(invokestatic);
 465         if (!alive) return;
<span class="line-modified"> 466         emit2(meth);</span>
 467         state.pop(argsize);
 468         state.push(mtype.getReturnType());
 469     }
 470 
 471     /** Emit an invokevirtual instruction.
 472      */
<span class="line-modified"> 473     public void emitInvokevirtual(int meth, Type mtype) {</span>
 474         int argsize = width(mtype.getParameterTypes());
 475         emitop(invokevirtual);
 476         if (!alive) return;
<span class="line-modified"> 477         emit2(meth);</span>
 478         state.pop(argsize + 1);
 479         state.push(mtype.getReturnType());
 480     }
 481 
 482     /** Emit an invokedynamic instruction.
 483      */
<span class="line-modified"> 484     public void emitInvokedynamic(int desc, Type mtype) {</span>
 485         int argsize = width(mtype.getParameterTypes());
 486         emitop(invokedynamic);
 487         if (!alive) return;
<span class="line-modified"> 488         emit2(desc);</span>
 489         emit2(0);
 490         state.pop(argsize);
 491         state.push(mtype.getReturnType());
 492     }
 493 
 494     /** Emit an opcode with no operand field.
 495      */
 496     public void emitop0(int op) {
 497         emitop(op);
 498         if (!alive) return;
 499         switch (op) {
 500         case aaload: {
 501             state.pop(1);// index
 502             Type a = state.stack[state.stacksize-1];
 503             Assert.check(!a.hasTag(BOT)); // null type as is cannot be indexed.
 504             state.pop(1);
 505             state.push(types.erasure(types.elemtype(a))); }
 506             break;
 507         case goto_:
 508             markDead();
</pre>
<hr />
<pre>
 879         case ret:
 880             markDead();
 881             break;
 882         case wide:
 883             // must be handled by the caller.
 884             return;
 885         case monitorenter:
 886         case monitorexit:
 887             state.pop(1);
 888             break;
 889 
 890         default:
 891             throw new AssertionError(mnem(op));
 892         }
 893         postop();
 894     }
 895 
 896     /** Emit an opcode with a one-byte operand field.
 897      */
 898     public void emitop1(int op, int od) {




 899         emitop(op);
 900         if (!alive) return;
 901         emit1(od);
 902         switch (op) {
 903         case bipush:
 904             state.push(syms.intType);
 905             break;
 906         case ldc1:
<span class="line-modified"> 907             state.push(typeForPool(pool.pool[od]));</span>
 908             break;
 909         default:
 910             throw new AssertionError(mnem(op));
 911         }
 912         postop();
 913     }
 914 
<span class="line-removed"> 915     /** The type of a constant pool entry. */</span>
<span class="line-removed"> 916     private Type typeForPool(Object o) {</span>
<span class="line-removed"> 917         if (o instanceof Integer) return syms.intType;</span>
<span class="line-removed"> 918         if (o instanceof Float) return syms.floatType;</span>
<span class="line-removed"> 919         if (o instanceof String) return syms.stringType;</span>
<span class="line-removed"> 920         if (o instanceof Long) return syms.longType;</span>
<span class="line-removed"> 921         if (o instanceof Double) return syms.doubleType;</span>
<span class="line-removed"> 922         if (o instanceof ClassSymbol) return syms.classType;</span>
<span class="line-removed"> 923         if (o instanceof Pool.MethodHandle) return syms.methodHandleType;</span>
<span class="line-removed"> 924         if (o instanceof UniqueType) return typeForPool(((UniqueType)o).type);</span>
<span class="line-removed"> 925         if (o instanceof Type) {</span>
<span class="line-removed"> 926             Type ty = (Type) o;</span>
<span class="line-removed"> 927 </span>
<span class="line-removed"> 928             if (ty instanceof Type.ArrayType) return syms.classType;</span>
<span class="line-removed"> 929             if (ty instanceof Type.MethodType) return syms.methodTypeType;</span>
<span class="line-removed"> 930         }</span>
<span class="line-removed"> 931         throw new AssertionError(&quot;Invalid type of constant pool entry: &quot; + o.getClass());</span>
<span class="line-removed"> 932     }</span>
<span class="line-removed"> 933 </span>
 934     /** Emit an opcode with a one-byte operand field;
 935      *  widen if field does not fit in a byte.
 936      */
 937     public void emitop1w(int op, int od) {
 938         if (od &gt; 0xFF) {
 939             emitop(wide);
 940             emitop(op);
 941             emit2(od);
 942         } else {
 943             emitop(op);
 944             emit1(od);
 945         }
 946         if (!alive) return;
 947         switch (op) {
 948         case iload:
 949             state.push(syms.intType);
 950             break;
 951         case lload:
 952             state.push(syms.longType);
 953             break;
</pre>
<hr />
<pre>
 986             emitop(wide);
 987             emitop(op);
 988             emit2(od1);
 989             emit2(od2);
 990         } else {
 991             emitop(op);
 992             emit1(od1);
 993             emit1(od2);
 994         }
 995         if (!alive) return;
 996         switch (op) {
 997         case iinc:
 998             break;
 999         default:
1000             throw new AssertionError(mnem(op));
1001         }
1002     }
1003 
1004     /** Emit an opcode with a two-byte operand field.
1005      */





1006     public void emitop2(int op, int od) {




1007         emitop(op);
1008         if (!alive) return;
1009         emit2(od);
1010         switch (op) {
1011         case getstatic:
<span class="line-modified">1012             state.push(((Symbol)(pool.pool[od])).erasure(types));</span>
1013             break;
1014         case putstatic:
<span class="line-modified">1015             state.pop(((Symbol)(pool.pool[od])).erasure(types));</span>
<span class="line-removed">1016             break;</span>
<span class="line-removed">1017         case new_:</span>
<span class="line-removed">1018             Symbol sym;</span>
<span class="line-removed">1019             if (pool.pool[od] instanceof UniqueType) {</span>
<span class="line-removed">1020                 // Required by change in Gen.makeRef to allow</span>
<span class="line-removed">1021                 // annotated types.</span>
<span class="line-removed">1022                 // TODO: is this needed anywhere else?</span>
<span class="line-removed">1023                 sym = ((UniqueType)(pool.pool[od])).type.tsym;</span>
<span class="line-removed">1024             } else {</span>
<span class="line-removed">1025                 sym = (Symbol)(pool.pool[od]);</span>
<span class="line-removed">1026             }</span>
<span class="line-removed">1027             state.push(uninitializedObject(sym.erasure(types), cp-3));</span>
1028             break;





1029         case sipush:
1030             state.push(syms.intType);
1031             break;
1032         case if_acmp_null:
1033         case if_acmp_nonnull:
1034         case ifeq:
1035         case ifne:
1036         case iflt:
1037         case ifge:
1038         case ifgt:
1039         case ifle:
1040             state.pop(1);
1041             break;
1042         case if_icmpeq:
1043         case if_icmpne:
1044         case if_icmplt:
1045         case if_icmpge:
1046         case if_icmpgt:
1047         case if_icmple:
1048         case if_acmpeq:
1049         case if_acmpne:
1050             state.pop(2);
1051             break;
1052         case goto_:
1053             markDead();
1054             break;
1055         case putfield:
<span class="line-modified">1056             state.pop(((Symbol)(pool.pool[od])).erasure(types));</span>
1057             state.pop(1); // object ref
1058             break;
1059         case getfield:
1060             state.pop(1); // object ref
<span class="line-modified">1061             state.push(((Symbol)(pool.pool[od])).erasure(types));</span>
1062             break;
1063         case checkcast: {
1064             state.pop(1); // object ref
<span class="line-modified">1065             Object o = pool.pool[od];</span>
<span class="line-removed">1066             Type t = (o instanceof Symbol)</span>
<span class="line-removed">1067                 ? ((Symbol)o).erasure(types)</span>
<span class="line-removed">1068                 : types.erasure((((UniqueType)o).type));</span>
1069             state.push(t);
1070             break; }
1071         case ldc2w:
<span class="line-modified">1072             state.push(typeForPool(pool.pool[od]));</span>
1073             break;
1074         case instanceof_:
1075             state.pop(1);
1076             state.push(syms.intType);
1077             break;
1078         case ldc2:
<span class="line-modified">1079             state.push(typeForPool(pool.pool[od]));</span>
1080             break;
1081         case jsr:
1082             break;
1083         default:
1084             throw new AssertionError(mnem(op));
1085         }
1086         // postop();
1087     }
1088 
1089     /** Emit an opcode with a four-byte operand field.
1090      */
1091     public void emitop4(int op, int od) {
1092         emitop(op);
1093         if (!alive) return;
1094         emit4(od);
1095         switch (op) {
1096         case goto_w:
1097             markDead();
1098             break;
1099         case jsr_w:
</pre>
<hr />
<pre>
2065         } else {
2066             state.defined.incl(adr);
2067             if (cp &lt; Character.MAX_VALUE) {
2068                 v.openRange((char)cp);
2069             }
2070         }
2071     }
2072 
2073     /** Mark a register as being undefined. */
2074     public void setUndefined(int adr) {
2075         state.defined.excl(adr);
2076         if (adr &lt; lvar.length &amp;&amp;
2077             lvar[adr] != null &amp;&amp;
2078             lvar[adr].isLastRangeInitialized()) {
2079             LocalVar v = lvar[adr];
2080             char length = (char)(curCP() - v.lastRange().start_pc);
2081             if (length &lt; Character.MAX_VALUE) {
2082                 lvar[adr] = v.dup();
2083                 v.closeRange(length);
2084                 putVar(v);

2085             } else {
2086                 v.removeLastRange();
2087             }
2088         }
2089     }
2090 
2091     /** End the scope of a variable. */
2092     private void endScope(int adr) {
2093         LocalVar v = lvar[adr];
2094         if (v != null) {
2095             if (v.isLastRangeInitialized()) {
2096                 char length = (char)(curCP() - v.lastRange().start_pc);
2097                 if (length &lt; Character.MAX_VALUE) {
2098                     v.closeRange(length);
2099                     putVar(v);
2100                     fillLocalVarPosition(v);
2101                 }
2102             }
2103             /** the call to curCP() can implicitly adjust the current cp, if so
2104              * the alive range of local variables may be modified. Thus we need
2105              * all of them. For this reason assigning null to the given address
2106              * should be the last action to do.
2107              */
2108             lvar[adr] = null;
2109         }
2110         state.defined.excl(adr);
2111     }
2112 
2113     private void fillLocalVarPosition(LocalVar lv) {
2114         if (lv == null || lv.sym == null || lv.sym.isExceptionParameter()|| !lv.sym.hasTypeAnnotations())
2115             return;
<span class="line-modified">2116         LocalVar.Range widestRange = lv.getWidestRange();</span>





2117         for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
2118             TypeAnnotationPosition p = ta.position;
<span class="line-modified">2119             if (widestRange.closed() &amp;&amp; widestRange.length &gt; 0) {</span>
<span class="line-modified">2120                 p.lvarOffset = new int[] { (int)widestRange.start_pc };</span>
<span class="line-modified">2121                 p.lvarLength = new int[] { (int)widestRange.length };</span>
<span class="line-modified">2122                 p.lvarIndex = new int[] { (int)lv.reg };</span>
<span class="line-removed">2123                 p.isValidOffset = true;</span>
<span class="line-removed">2124             } else {</span>
<span class="line-removed">2125                 p.isValidOffset = false;</span>
<span class="line-removed">2126             }</span>
2127         }
2128     }
2129 










2130     // Method to be called after compressCatchTable to
2131     // fill in the exception table index for type
2132     // annotations on exception parameters.
2133     public void fillExceptionParameterPositions() {
2134         for (int i = 0; i &lt; varBufferSize; ++i) {
2135             LocalVar lv = varBuffer[i];
2136             if (lv == null || lv.sym == null
2137                     || !lv.sym.hasTypeAnnotations()
2138                     || !lv.sym.isExceptionParameter())
2139                 continue;
2140 
2141             for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
2142                 TypeAnnotationPosition p = ta.position;
2143                 if (p.hasCatchType()) {
2144                     final int idx = findExceptionIndex(p);
2145                     if (idx == -1)
2146                         Assert.error(&quot;Could not find exception index for type annotation &quot; +
2147                                      ta + &quot; on exception parameter&quot;);
2148                     p.setExceptionIndex(idx);
2149                 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.jvm;
  27 
  28 import com.sun.tools.javac.code.*;
  29 import com.sun.tools.javac.code.Symbol.*;

  30 import com.sun.tools.javac.resources.CompilerProperties.Errors;

  31 import com.sun.tools.javac.util.*;
  32 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  33 
<span class="line-added">  34 import java.util.function.ToIntBiFunction;</span>
<span class="line-added">  35 import java.util.function.ToIntFunction;</span>
<span class="line-added">  36 </span>
  37 import static com.sun.tools.javac.code.TypeTag.BOT;
  38 import static com.sun.tools.javac.code.TypeTag.INT;
  39 import static com.sun.tools.javac.jvm.ByteCodes.*;
<span class="line-added">  40 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Class;</span>
<span class="line-added">  41 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Double;</span>
<span class="line-added">  42 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Fieldref;</span>
<span class="line-added">  43 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Float;</span>
<span class="line-added">  44 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Integer;</span>
<span class="line-added">  45 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_InterfaceMethodref;</span>
<span class="line-added">  46 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Long;</span>
<span class="line-added">  47 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodHandle;</span>
<span class="line-added">  48 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_MethodType;</span>
<span class="line-added">  49 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_Methodref;</span>
<span class="line-added">  50 import static com.sun.tools.javac.jvm.ClassFile.CONSTANT_String;</span>
  51 import static com.sun.tools.javac.jvm.UninitializedType.*;
  52 import static com.sun.tools.javac.jvm.ClassWriter.StackMapTableFrame;
<span class="line-added">  53 import java.util.Arrays;</span>
  54 
  55 /** An internal structure that corresponds to the code attribute of
  56  *  methods in a classfile. The class also provides some utility operations to
  57  *  generate bytecode instructions.
  58  *
  59  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  60  *  If you write code that depends on this, you do so at your own risk.
  61  *  This code and its internal interfaces are subject to change or
  62  *  deletion without notice.&lt;/b&gt;
  63  */
  64 public class Code {
  65 
  66     public final boolean debugCode;
  67     public final boolean needStackMap;
  68 
  69     public enum StackMapFormat {
  70         NONE,
  71         CLDC {
  72             Name getAttributeName(Names names) {
  73                 return names.StackMap;
  74             }
  75         },
  76         JSR202 {
  77             Name getAttributeName(Names names) {
  78                 return names.StackMapTable;
  79             }
  80         };
  81         Name getAttributeName(Names names) {
  82             return names.empty;
  83         }
  84     }
  85 
  86     final Types types;
  87     final Symtab syms;
<span class="line-added">  88     final PoolWriter poolWriter;</span>
  89 
  90 /*---------- classfile fields: --------------- */
  91 
  92     /** The maximum stack size.
  93      */
  94     public int max_stack = 0;
  95 
  96     /** The maximum number of local variable slots.
  97      */
  98     public int max_locals = 0;
  99 
 100     /** The code buffer.
 101      */
 102     public byte[] code = new byte[64];
 103 
 104     /** the current code pointer.
 105      */
 106     public int cp = 0;
 107 
 108     /** Check the code against VM spec limits; if
</pre>
<hr />
<pre>
 174     int pendingStatPos = Position.NOPOS;
 175 
 176     /** Set true when a stackMap is needed at the current PC. */
 177     boolean pendingStackMap = false;
 178 
 179     /** The stack map format to be generated. */
 180     StackMapFormat stackMap;
 181 
 182     /** Switch: emit variable debug info.
 183      */
 184     boolean varDebugInfo;
 185 
 186     /** Switch: emit line number info.
 187      */
 188     boolean lineDebugInfo;
 189 
 190     /** Emit line number info if map supplied
 191      */
 192     Position.LineMap lineMap;
 193 




 194     final MethodSymbol meth;
 195 
 196     private int letExprStackPos = 0;
 197 
 198     /** Construct a code object, given the settings of the fatcode,
 199      *  debugging info switches and the CharacterRangeTable.
 200      */
 201     public Code(MethodSymbol meth,
 202                 boolean fatcode,
 203                 Position.LineMap lineMap,
 204                 boolean varDebugInfo,
 205                 StackMapFormat stackMap,
 206                 boolean debugCode,
 207                 CRTable crt,
 208                 Symtab syms,
 209                 Types types,
<span class="line-modified"> 210                 PoolWriter poolWriter) {</span>
 211         this.meth = meth;
 212         this.fatcode = fatcode;
 213         this.lineMap = lineMap;
 214         this.lineDebugInfo = lineMap != null;
 215         this.varDebugInfo = varDebugInfo;
 216         this.crt = crt;
 217         this.syms = syms;
 218         this.types = types;
<span class="line-added"> 219         this.poolWriter = poolWriter;</span>
 220         this.debugCode = debugCode;
 221         this.stackMap = stackMap;
 222         switch (stackMap) {
 223         case CLDC:
 224         case JSR202:
 225             this.needStackMap = true;
 226             break;
 227         default:
 228             this.needStackMap = false;
 229         }
 230         state = new State();
 231         lvar = new LocalVar[20];

 232     }
 233 
 234 
 235 /* **************************************************************************
 236  * Typecodes &amp; related stuff
 237  ****************************************************************************/
 238 
 239     /** Given a type, return its type code (used implicitly in the
 240      *  JVM architecture).
 241      */
 242     public static int typecode(Type type) {
 243         switch (type.getTag()) {
 244         case BYTE: return BYTEcode;
 245         case SHORT: return SHORTcode;
 246         case CHAR: return CHARcode;
 247         case INT: return INTcode;
 248         case LONG: return LONGcode;
 249         case FLOAT: return FLOATcode;
 250         case DOUBLE: return DOUBLEcode;
 251         case BOOLEAN: return BYTEcode;
</pre>
<hr />
<pre>
 382             if (pendingStatPos != Position.NOPOS)
 383                 markStatBegin();
 384             if (pendingStackMap) {
 385                 pendingStackMap = false;
 386                 emitStackMap();
 387             }
 388             if (debugCode)
 389                 System.err.println(&quot;emit@&quot; + cp + &quot; stack=&quot; +
 390                                    state.stacksize + &quot;: &quot; +
 391                                    mnem(op));
 392             emit1(op);
 393         }
 394     }
 395 
 396     void postop() {
 397         Assert.check(alive || isStatementStart());
 398     }
 399 
 400     /** Emit a ldc (or ldc_w) instruction, taking into account operand size
 401     */
<span class="line-modified"> 402     public void emitLdc(LoadableConstant constant) {</span>
<span class="line-added"> 403         int od = poolWriter.putConstant(constant);</span>
 404         if (od &lt;= 255) {
<span class="line-modified"> 405             emitop1(ldc1, od, constant);</span>
 406         }
 407         else {
<span class="line-modified"> 408             emitop2(ldc2, od, constant);</span>
 409         }
 410     }
 411 
 412     /** Emit a multinewarray instruction.
 413      */
 414     public void emitMultianewarray(int ndims, int type, Type arrayType) {
 415         emitop(multianewarray);
 416         if (!alive) return;
 417         emit2(type);
 418         emit1(ndims);
 419         state.pop(ndims);
 420         state.push(arrayType);
 421     }
 422 
 423     /** Emit newarray.
 424      */
 425     public void emitNewarray(int elemcode, Type arrayType) {
 426         emitop(newarray);
 427         if (!alive) return;
 428         emit1(elemcode);
 429         state.pop(1); // count
 430         state.push(arrayType);
 431     }
 432 
 433     /** Emit anewarray.
 434      */
 435     public void emitAnewarray(int od, Type arrayType) {
 436         emitop(anewarray);
 437         if (!alive) return;
 438         emit2(od);
 439         state.pop(1);
 440         state.push(arrayType);
 441     }
 442 
 443     /** Emit an invokeinterface instruction.
 444      */
<span class="line-modified"> 445     public void emitInvokeinterface(Symbol member, Type mtype) {</span>
 446         int argsize = width(mtype.getParameterTypes());
 447         emitop(invokeinterface);
 448         if (!alive) return;
<span class="line-modified"> 449         emit2(poolWriter.putMember(member));</span>
 450         emit1(argsize + 1);
 451         emit1(0);
 452         state.pop(argsize + 1);
 453         state.push(mtype.getReturnType());
 454     }
 455 
 456     /** Emit an invokespecial instruction.
 457      */
<span class="line-modified"> 458     public void emitInvokespecial(Symbol member, Type mtype) {</span>
 459         int argsize = width(mtype.getParameterTypes());
 460         emitop(invokespecial);
 461         if (!alive) return;
<span class="line-modified"> 462         emit2(poolWriter.putMember(member));</span>

 463         state.pop(argsize);
<span class="line-modified"> 464         if (member.isConstructor())</span>
 465             state.markInitialized((UninitializedType)state.peek());
 466         state.pop(1);
 467         state.push(mtype.getReturnType());
 468     }
 469 
 470     /** Emit an invokestatic instruction.
 471      */
<span class="line-modified"> 472     public void emitInvokestatic(Symbol member, Type mtype) {</span>
 473         int argsize = width(mtype.getParameterTypes());
 474         emitop(invokestatic);
 475         if (!alive) return;
<span class="line-modified"> 476         emit2(poolWriter.putMember(member));</span>
 477         state.pop(argsize);
 478         state.push(mtype.getReturnType());
 479     }
 480 
 481     /** Emit an invokevirtual instruction.
 482      */
<span class="line-modified"> 483     public void emitInvokevirtual(Symbol member, Type mtype) {</span>
 484         int argsize = width(mtype.getParameterTypes());
 485         emitop(invokevirtual);
 486         if (!alive) return;
<span class="line-modified"> 487         emit2(poolWriter.putMember(member));</span>
 488         state.pop(argsize + 1);
 489         state.push(mtype.getReturnType());
 490     }
 491 
 492     /** Emit an invokedynamic instruction.
 493      */
<span class="line-modified"> 494     public void emitInvokedynamic(DynamicMethodSymbol dynMember, Type mtype) {</span>
 495         int argsize = width(mtype.getParameterTypes());
 496         emitop(invokedynamic);
 497         if (!alive) return;
<span class="line-modified"> 498         emit2(poolWriter.putDynamic(dynMember));</span>
 499         emit2(0);
 500         state.pop(argsize);
 501         state.push(mtype.getReturnType());
 502     }
 503 
 504     /** Emit an opcode with no operand field.
 505      */
 506     public void emitop0(int op) {
 507         emitop(op);
 508         if (!alive) return;
 509         switch (op) {
 510         case aaload: {
 511             state.pop(1);// index
 512             Type a = state.stack[state.stacksize-1];
 513             Assert.check(!a.hasTag(BOT)); // null type as is cannot be indexed.
 514             state.pop(1);
 515             state.push(types.erasure(types.elemtype(a))); }
 516             break;
 517         case goto_:
 518             markDead();
</pre>
<hr />
<pre>
 889         case ret:
 890             markDead();
 891             break;
 892         case wide:
 893             // must be handled by the caller.
 894             return;
 895         case monitorenter:
 896         case monitorexit:
 897             state.pop(1);
 898             break;
 899 
 900         default:
 901             throw new AssertionError(mnem(op));
 902         }
 903         postop();
 904     }
 905 
 906     /** Emit an opcode with a one-byte operand field.
 907      */
 908     public void emitop1(int op, int od) {
<span class="line-added"> 909         emitop1(op, od, null);</span>
<span class="line-added"> 910     }</span>
<span class="line-added"> 911 </span>
<span class="line-added"> 912     public void emitop1(int op, int od, PoolConstant data) {</span>
 913         emitop(op);
 914         if (!alive) return;
 915         emit1(od);
 916         switch (op) {
 917         case bipush:
 918             state.push(syms.intType);
 919             break;
 920         case ldc1:
<span class="line-modified"> 921             state.push(types.constantType((LoadableConstant)data));</span>
 922             break;
 923         default:
 924             throw new AssertionError(mnem(op));
 925         }
 926         postop();
 927     }
 928 



















 929     /** Emit an opcode with a one-byte operand field;
 930      *  widen if field does not fit in a byte.
 931      */
 932     public void emitop1w(int op, int od) {
 933         if (od &gt; 0xFF) {
 934             emitop(wide);
 935             emitop(op);
 936             emit2(od);
 937         } else {
 938             emitop(op);
 939             emit1(od);
 940         }
 941         if (!alive) return;
 942         switch (op) {
 943         case iload:
 944             state.push(syms.intType);
 945             break;
 946         case lload:
 947             state.push(syms.longType);
 948             break;
</pre>
<hr />
<pre>
 981             emitop(wide);
 982             emitop(op);
 983             emit2(od1);
 984             emit2(od2);
 985         } else {
 986             emitop(op);
 987             emit1(od1);
 988             emit1(od2);
 989         }
 990         if (!alive) return;
 991         switch (op) {
 992         case iinc:
 993             break;
 994         default:
 995             throw new AssertionError(mnem(op));
 996         }
 997     }
 998 
 999     /** Emit an opcode with a two-byte operand field.
1000      */
<span class="line-added">1001     public &lt;P extends PoolConstant&gt; void emitop2(int op, P constant, ToIntBiFunction&lt;PoolWriter, P&gt; poolFunc) {</span>
<span class="line-added">1002         int od = poolFunc.applyAsInt(poolWriter, constant);</span>
<span class="line-added">1003         emitop2(op, od, constant);</span>
<span class="line-added">1004     }</span>
<span class="line-added">1005 </span>
1006     public void emitop2(int op, int od) {
<span class="line-added">1007         emitop2(op, od, null);</span>
<span class="line-added">1008     }</span>
<span class="line-added">1009 </span>
<span class="line-added">1010     public void emitop2(int op, int od, PoolConstant data) {</span>
1011         emitop(op);
1012         if (!alive) return;
1013         emit2(od);
1014         switch (op) {
1015         case getstatic:
<span class="line-modified">1016             state.push(((Symbol)data).erasure(types));</span>
1017             break;
1018         case putstatic:
<span class="line-modified">1019             state.pop(((Symbol)data).erasure(types));</span>












1020             break;
<span class="line-added">1021         case new_: {</span>
<span class="line-added">1022             Type t = (Type)data;</span>
<span class="line-added">1023             state.push(uninitializedObject(t.tsym.erasure(types), cp-3));</span>
<span class="line-added">1024             break;</span>
<span class="line-added">1025         }</span>
1026         case sipush:
1027             state.push(syms.intType);
1028             break;
1029         case if_acmp_null:
1030         case if_acmp_nonnull:
1031         case ifeq:
1032         case ifne:
1033         case iflt:
1034         case ifge:
1035         case ifgt:
1036         case ifle:
1037             state.pop(1);
1038             break;
1039         case if_icmpeq:
1040         case if_icmpne:
1041         case if_icmplt:
1042         case if_icmpge:
1043         case if_icmpgt:
1044         case if_icmple:
1045         case if_acmpeq:
1046         case if_acmpne:
1047             state.pop(2);
1048             break;
1049         case goto_:
1050             markDead();
1051             break;
1052         case putfield:
<span class="line-modified">1053             state.pop(((Symbol)data).erasure(types));</span>
1054             state.pop(1); // object ref
1055             break;
1056         case getfield:
1057             state.pop(1); // object ref
<span class="line-modified">1058             state.push(((Symbol)data).erasure(types));</span>
1059             break;
1060         case checkcast: {
1061             state.pop(1); // object ref
<span class="line-modified">1062             Type t = types.erasure((Type)data);</span>



1063             state.push(t);
1064             break; }
1065         case ldc2w:
<span class="line-modified">1066             state.push(types.constantType((LoadableConstant)data));</span>
1067             break;
1068         case instanceof_:
1069             state.pop(1);
1070             state.push(syms.intType);
1071             break;
1072         case ldc2:
<span class="line-modified">1073             state.push(types.constantType((LoadableConstant)data));</span>
1074             break;
1075         case jsr:
1076             break;
1077         default:
1078             throw new AssertionError(mnem(op));
1079         }
1080         // postop();
1081     }
1082 
1083     /** Emit an opcode with a four-byte operand field.
1084      */
1085     public void emitop4(int op, int od) {
1086         emitop(op);
1087         if (!alive) return;
1088         emit4(od);
1089         switch (op) {
1090         case goto_w:
1091             markDead();
1092             break;
1093         case jsr_w:
</pre>
<hr />
<pre>
2059         } else {
2060             state.defined.incl(adr);
2061             if (cp &lt; Character.MAX_VALUE) {
2062                 v.openRange((char)cp);
2063             }
2064         }
2065     }
2066 
2067     /** Mark a register as being undefined. */
2068     public void setUndefined(int adr) {
2069         state.defined.excl(adr);
2070         if (adr &lt; lvar.length &amp;&amp;
2071             lvar[adr] != null &amp;&amp;
2072             lvar[adr].isLastRangeInitialized()) {
2073             LocalVar v = lvar[adr];
2074             char length = (char)(curCP() - v.lastRange().start_pc);
2075             if (length &lt; Character.MAX_VALUE) {
2076                 lvar[adr] = v.dup();
2077                 v.closeRange(length);
2078                 putVar(v);
<span class="line-added">2079                 fillLocalVarPosition(v);</span>
2080             } else {
2081                 v.removeLastRange();
2082             }
2083         }
2084     }
2085 
2086     /** End the scope of a variable. */
2087     private void endScope(int adr) {
2088         LocalVar v = lvar[adr];
2089         if (v != null) {
2090             if (v.isLastRangeInitialized()) {
2091                 char length = (char)(curCP() - v.lastRange().start_pc);
2092                 if (length &lt; Character.MAX_VALUE) {
2093                     v.closeRange(length);
2094                     putVar(v);
2095                     fillLocalVarPosition(v);
2096                 }
2097             }
2098             /** the call to curCP() can implicitly adjust the current cp, if so
2099              * the alive range of local variables may be modified. Thus we need
2100              * all of them. For this reason assigning null to the given address
2101              * should be the last action to do.
2102              */
2103             lvar[adr] = null;
2104         }
2105         state.defined.excl(adr);
2106     }
2107 
2108     private void fillLocalVarPosition(LocalVar lv) {
2109         if (lv == null || lv.sym == null || lv.sym.isExceptionParameter()|| !lv.sym.hasTypeAnnotations())
2110             return;
<span class="line-modified">2111         LocalVar.Range[] validRanges = lv.aliveRanges.stream().filter(r -&gt; r.closed() &amp;&amp; r.length &gt; 0).toArray(s -&gt; new LocalVar.Range[s]);</span>
<span class="line-added">2112         if (validRanges.length == 0)</span>
<span class="line-added">2113             return ;</span>
<span class="line-added">2114         int[] lvarOffset = Arrays.stream(validRanges).mapToInt(r -&gt; r.start_pc).toArray();</span>
<span class="line-added">2115         int[] lvarLength = Arrays.stream(validRanges).mapToInt(r -&gt; r.length).toArray();</span>
<span class="line-added">2116         int[] lvarIndex = Arrays.stream(validRanges).mapToInt(r -&gt; lv.reg).toArray();</span>
2117         for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
2118             TypeAnnotationPosition p = ta.position;
<span class="line-modified">2119             p.lvarOffset = appendArray(p.lvarOffset, lvarOffset);</span>
<span class="line-modified">2120             p.lvarLength = appendArray(p.lvarLength, lvarLength);</span>
<span class="line-modified">2121             p.lvarIndex = appendArray(p.lvarIndex, lvarIndex);</span>
<span class="line-modified">2122             p.isValidOffset = true;</span>




2123         }
2124     }
2125 
<span class="line-added">2126     private int[] appendArray(int[] source, int[] append) {</span>
<span class="line-added">2127         if (source == null || source.length == 0) return append;</span>
<span class="line-added">2128 </span>
<span class="line-added">2129         int[] result = new int[source.length + append.length];</span>
<span class="line-added">2130 </span>
<span class="line-added">2131         System.arraycopy(source, 0, result, 0, source.length);</span>
<span class="line-added">2132         System.arraycopy(append, 0, result, source.length, append.length);</span>
<span class="line-added">2133         return result;</span>
<span class="line-added">2134     }</span>
<span class="line-added">2135 </span>
2136     // Method to be called after compressCatchTable to
2137     // fill in the exception table index for type
2138     // annotations on exception parameters.
2139     public void fillExceptionParameterPositions() {
2140         for (int i = 0; i &lt; varBufferSize; ++i) {
2141             LocalVar lv = varBuffer[i];
2142             if (lv == null || lv.sym == null
2143                     || !lv.sym.hasTypeAnnotations()
2144                     || !lv.sym.isExceptionParameter())
2145                 continue;
2146 
2147             for (Attribute.TypeCompound ta : lv.sym.getRawTypeAttributes()) {
2148                 TypeAnnotationPosition p = ta.position;
2149                 if (p.hasCatchType()) {
2150                     final int idx = findExceptionIndex(p);
2151                     if (idx == -1)
2152                         Assert.error(&quot;Could not find exception index for type annotation &quot; +
2153                                      ta + &quot; on exception parameter&quot;);
2154                     p.setExceptionIndex(idx);
2155                 }
</pre>
</td>
</tr>
</table>
<center><a href="ClassWriter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Gen.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
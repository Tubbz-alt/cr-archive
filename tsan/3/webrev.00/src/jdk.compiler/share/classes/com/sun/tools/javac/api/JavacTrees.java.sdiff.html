<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavacTaskPool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../code/Attribute.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/api/JavacTrees.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2017, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.api;
  27 
  28 import java.io.FileNotFoundException;
  29 import java.io.IOException;
  30 import java.text.BreakIterator;
<span class="line-modified">  31 import java.util.Collections;</span>
  32 import java.util.HashSet;
  33 import java.util.Map;

  34 import java.util.Set;
  35 import java.util.WeakHashMap;
<span class="line-removed">  36 import java.util.regex.Matcher;</span>
<span class="line-removed">  37 import java.util.regex.Pattern;</span>
  38 
  39 import javax.annotation.processing.ProcessingEnvironment;
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.Modifier;
  46 import javax.lang.model.element.NestingKind;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.TypeElement;
  49 import javax.lang.model.type.DeclaredType;
  50 import javax.lang.model.type.TypeKind;
  51 import javax.lang.model.type.TypeMirror;
  52 import javax.tools.Diagnostic;
  53 import javax.tools.FileObject;
  54 import javax.tools.ForwardingFileObject;
  55 import javax.tools.JavaCompiler;
  56 import javax.tools.JavaFileManager;
  57 import javax.tools.JavaFileObject;
  58 import javax.tools.JavaFileObject.Kind;
  59 import javax.tools.StandardLocation;
  60 
  61 import com.sun.source.doctree.DocCommentTree;
  62 import com.sun.source.doctree.DocTree;
<span class="line-removed">  63 import com.sun.source.doctree.EndElementTree;</span>
<span class="line-removed">  64 import com.sun.source.doctree.StartElementTree;</span>
  65 import com.sun.source.tree.CatchTree;

  66 import com.sun.source.tree.CompilationUnitTree;
  67 import com.sun.source.tree.Scope;
  68 import com.sun.source.tree.Tree;
  69 import com.sun.source.util.DocSourcePositions;
  70 import com.sun.source.util.DocTreePath;
  71 import com.sun.source.util.DocTreeScanner;
  72 import com.sun.source.util.DocTrees;
  73 import com.sun.source.util.JavacTask;
<span class="line-removed">  74 import com.sun.source.util.SimpleDocTreeVisitor;</span>
  75 import com.sun.source.util.TreePath;
  76 import com.sun.tools.javac.code.Flags;
  77 import com.sun.tools.javac.code.Scope.NamedImportScope;
  78 import com.sun.tools.javac.code.Scope.StarImportScope;
  79 import com.sun.tools.javac.code.Scope.WriteableScope;
<span class="line-removed">  80 import com.sun.tools.javac.code.Symbol;</span>
  81 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  82 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  83 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  84 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  85 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  86 import com.sun.tools.javac.code.Symbol.VarSymbol;
  87 import com.sun.tools.javac.code.Symtab;
  88 import com.sun.tools.javac.code.Type;
  89 import com.sun.tools.javac.code.Type.ArrayType;
  90 import com.sun.tools.javac.code.Type.ClassType;
  91 import com.sun.tools.javac.code.Type.ErrorType;
  92 import com.sun.tools.javac.code.Type.UnionClassType;
  93 import com.sun.tools.javac.code.Types;
  94 import com.sun.tools.javac.code.Types.TypeRelation;
  95 import com.sun.tools.javac.comp.Attr;
  96 import com.sun.tools.javac.comp.AttrContext;

  97 import com.sun.tools.javac.comp.Enter;
  98 import com.sun.tools.javac.comp.Env;
  99 import com.sun.tools.javac.comp.MemberEnter;
 100 import com.sun.tools.javac.comp.Modules;
 101 import com.sun.tools.javac.comp.Resolve;

 102 import com.sun.tools.javac.file.BaseFileManager;
 103 import com.sun.tools.javac.model.JavacElements;
 104 import com.sun.tools.javac.parser.DocCommentParser;
 105 import com.sun.tools.javac.parser.ParserFactory;
 106 import com.sun.tools.javac.parser.Tokens.Comment;
 107 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
 108 import com.sun.tools.javac.processing.JavacProcessingEnvironment;
 109 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 110 import com.sun.tools.javac.resources.CompilerProperties.Notes;
 111 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 112 import com.sun.tools.javac.tree.DCTree;
 113 import com.sun.tools.javac.tree.DCTree.DCBlockTag;

 114 import com.sun.tools.javac.tree.DCTree.DCDocComment;
 115 import com.sun.tools.javac.tree.DCTree.DCEndPosTree;

 116 import com.sun.tools.javac.tree.DCTree.DCErroneous;
 117 import com.sun.tools.javac.tree.DCTree.DCIdentifier;
 118 import com.sun.tools.javac.tree.DCTree.DCParam;
 119 import com.sun.tools.javac.tree.DCTree.DCReference;
 120 import com.sun.tools.javac.tree.DCTree.DCText;
 121 import com.sun.tools.javac.tree.DocCommentTable;
 122 import com.sun.tools.javac.tree.DocTreeMaker;
 123 import com.sun.tools.javac.tree.EndPosTable;
 124 import com.sun.tools.javac.tree.JCTree;
 125 import com.sun.tools.javac.tree.JCTree.JCBlock;
 126 import com.sun.tools.javac.tree.JCTree.JCCatch;
 127 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 128 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 129 import com.sun.tools.javac.tree.JCTree.JCExpression;
 130 import com.sun.tools.javac.tree.JCTree.JCIdent;
 131 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 132 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 133 import com.sun.tools.javac.tree.TreeCopier;
 134 import com.sun.tools.javac.tree.TreeInfo;
 135 import com.sun.tools.javac.tree.TreeMaker;

 136 import com.sun.tools.javac.util.Abort;
 137 import com.sun.tools.javac.util.Assert;
 138 import com.sun.tools.javac.util.Context;
 139 import com.sun.tools.javac.util.DefinedBy;
 140 import com.sun.tools.javac.util.DefinedBy.Api;
 141 import com.sun.tools.javac.util.DiagnosticSource;
 142 import com.sun.tools.javac.util.JCDiagnostic;
 143 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 144 import com.sun.tools.javac.util.List;
 145 import com.sun.tools.javac.util.ListBuffer;
 146 import com.sun.tools.javac.util.Log;
 147 import com.sun.tools.javac.util.Name;
 148 import com.sun.tools.javac.util.Names;
 149 import com.sun.tools.javac.util.Pair;
 150 import com.sun.tools.javac.util.Position;
 151 
 152 import static com.sun.tools.javac.code.Kinds.Kind.*;
 153 import static com.sun.tools.javac.code.TypeTag.*;
 154 
 155 /**
 156  * Provides an implementation of Trees.
 157  *
 158  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 159  * If you write code that depends on this, you do so at your own
 160  * risk.  This code and its internal interfaces are subject to change
 161  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 162  *
 163  * @author Peter von der Ah&amp;eacute;
 164  */
 165 public class JavacTrees extends DocTrees {
 166 
 167     // in a world of a single context per compilation, these would all be final
 168     private Modules modules;
 169     private Resolve resolve;
 170     private Enter enter;
 171     private Log log;
 172     private MemberEnter memberEnter;
 173     private Attr attr;

 174     private TreeMaker treeMaker;
 175     private JavacElements elements;
 176     private JavacTaskImpl javacTaskImpl;
 177     private Names names;
 178     private Types types;
 179     private DocTreeMaker docTreeMaker;
 180     private BreakIterator breakIterator;
 181     private JavaFileManager fileManager;
 182     private ParserFactory parser;
 183     private Symtab syms;
 184 
 185     private final Map&lt;Type, Type&gt; extraType2OriginalMap = new WeakHashMap&lt;&gt;();
 186 
 187     // called reflectively from Trees.instance(CompilationTask task)
 188     public static JavacTrees instance(JavaCompiler.CompilationTask task) {
 189         if (!(task instanceof BasicJavacTask))
 190             throw new IllegalArgumentException();
 191         return instance(((BasicJavacTask)task).getContext());
 192     }
 193 
</pre>
<hr />
<pre>
 201     public static JavacTrees instance(Context context) {
 202         JavacTrees instance = context.get(JavacTrees.class);
 203         if (instance == null)
 204             instance = new JavacTrees(context);
 205         return instance;
 206     }
 207 
 208     protected JavacTrees(Context context) {
 209         this.breakIterator = null;
 210         context.put(JavacTrees.class, this);
 211         init(context);
 212     }
 213 
 214     public void updateContext(Context context) {
 215         init(context);
 216     }
 217 
 218     private void init(Context context) {
 219         modules = Modules.instance(context);
 220         attr = Attr.instance(context);

 221         enter = Enter.instance(context);
 222         elements = JavacElements.instance(context);
 223         log = Log.instance(context);
 224         resolve = Resolve.instance(context);
 225         treeMaker = TreeMaker.instance(context);
 226         memberEnter = MemberEnter.instance(context);
 227         names = Names.instance(context);
 228         types = Types.instance(context);
 229         docTreeMaker = DocTreeMaker.instance(context);
 230         parser = ParserFactory.instance(context);
 231         syms = Symtab.instance(context);
 232         fileManager = context.get(JavaFileManager.class);
 233         JavacTask t = context.get(JavacTask.class);
 234         if (t instanceof JavacTaskImpl)
 235             javacTaskImpl = (JavacTaskImpl) t;
 236     }
 237 
 238     @Override @DefinedBy(Api.COMPILER_TREE)
 239     public BreakIterator getBreakIterator() {
 240         return breakIterator;
</pre>
<hr />
<pre>
 284                             return dcComment.comment.getSourcePos(ident.pos + (ident.name != names.error ? ident.name.length() : 0));
 285                         case PARAM:
 286                             DCParam param = (DCParam) tree;
 287 
 288                             if (param.isTypeParameter &amp;&amp; param.getDescription().isEmpty()) {
 289                                 correction = 1;
 290                             }
 291                         case AUTHOR: case DEPRECATED: case RETURN: case SEE:
 292                         case SERIAL: case SERIAL_DATA: case SERIAL_FIELD: case SINCE:
 293                         case THROWS: case UNKNOWN_BLOCK_TAG: case VERSION: {
 294                             DocTree last = getLastChild(tree);
 295 
 296                             if (last != null) {
 297                                 return getEndPosition(file, comment, last) + correction;
 298                             }
 299 
 300                             DCBlockTag block = (DCBlockTag) tree;
 301 
 302                             return dcComment.comment.getSourcePos(block.pos + block.getTagName().length() + 1);
 303                         }








 304                         default:
 305                             DocTree last = getLastChild(tree);
 306 
 307                             if (last != null) {
 308                                 return getEndPosition(file, comment, last);
 309                             }
 310                             break;
 311                     }
 312 
 313                     return Position.NOPOS;
 314                 }
 315             };
 316     }
 317 
 318     @Override @DefinedBy(Api.COMPILER_TREE)
 319     public DocTreeMaker getDocTreeFactory() {
 320         return docTreeMaker;
 321     }
 322 
 323     private DocTree getLastChild(DocTree tree) {
</pre>
<hr />
<pre>
 392         if (sym == null) {
 393             for (TreePath p = path; p != null; p = p.getParentPath()) {
 394                 JCTree t = (JCTree) p.getLeaf();
 395                 if (t.hasTag(JCTree.Tag.CLASSDEF)) {
 396                     JCClassDecl ct = (JCClassDecl) t;
 397                     if (ct.sym != null) {
 398                         if ((ct.sym.flags_field &amp; Flags.UNATTRIBUTED) != 0) {
 399                             attr.attribClass(ct.pos(), ct.sym);
 400                             sym = TreeInfo.symbolFor(tree);
 401                         }
 402                         break;
 403                     }
 404                 }
 405             }
 406         }
 407         return sym;
 408     }
 409 
 410     @Override @DefinedBy(Api.COMPILER_TREE)
 411     public Element getElement(DocTreePath path) {
<span class="line-modified"> 412         DocTree forTree = path.getLeaf();</span>
<span class="line-modified"> 413         if (forTree instanceof DCReference)</span>
<span class="line-modified"> 414             return attributeDocReference(path.getTreePath(), ((DCReference) forTree));</span>
<span class="line-modified"> 415         if (forTree instanceof DCIdentifier) {</span>
 416             if (path.getParentPath().getLeaf() instanceof DCParam) {
 417                 return attributeParamIdentifier(path.getTreePath(), (DCParam) path.getParentPath().getLeaf());
 418             }
 419         }
 420         return null;
 421     }
 422 
 423     @Override @DefinedBy(Api.COMPILER_TREE)
 424     public java.util.List&lt;DocTree&gt; getFirstSentence(java.util.List&lt;? extends DocTree&gt; list) {
 425         return docTreeMaker.getFirstSentence(list);
 426     }
 427 
 428     private Symbol attributeDocReference(TreePath path, DCReference ref) {
 429         Env&lt;AttrContext&gt; env = getAttrContext(path);
 430         if (env == null) return null;
 431 
 432         Log.DeferredDiagnosticHandler deferredDiagnosticHandler =
 433                 new Log.DeferredDiagnosticHandler(log);
 434         try {
 435             final TypeSymbol tsym;
</pre>
<hr />
<pre>
 508                 // explicit (possibly empty) arg list given, so cannot be a field
 509                 return msym;
 510             }
 511 
 512             VarSymbol vsym = (ref.paramTypes != null) ? null : findField(sym, memberName);
 513             // prefer a field over a method with no parameters
 514             if (vsym != null &amp;&amp;
 515                     (msym == null ||
 516                         types.isSubtypeUnchecked(vsym.enclClass().asType(), msym.enclClass().asType()))) {
 517                 return vsym;
 518             } else {
 519                 return msym;
 520             }
 521         } catch (Abort e) { // may be thrown by Check.completionError in case of bad class file
 522             return null;
 523         } finally {
 524             log.popDiagnosticHandler(deferredDiagnosticHandler);
 525         }
 526     }
 527 
<span class="line-modified"> 528     private Symbol attributeParamIdentifier(TreePath path, DCParam ptag) {</span>
 529         Symbol javadocSymbol = getElement(path);
 530         if (javadocSymbol == null)
 531             return null;
 532         ElementKind kind = javadocSymbol.getKind();
 533         List&lt;? extends Symbol&gt; params = List.nil();
 534         if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {
 535             MethodSymbol ee = (MethodSymbol) javadocSymbol;
<span class="line-modified"> 536             params = ptag.isTypeParameter()</span>
 537                     ? ee.getTypeParameters()
 538                     : ee.getParameters();
 539         } else if (kind.isClass() || kind.isInterface()) {
 540             ClassSymbol te = (ClassSymbol) javadocSymbol;
<span class="line-modified"> 541             params = te.getTypeParameters();</span>


 542         }
 543 
 544         for (Symbol param : params) {
<span class="line-modified"> 545             if (param.getSimpleName() == ptag.getName().getName()) {</span>
 546                 return param;
 547             }
 548         }
 549         return null;
 550     }
 551 
 552     /** @see com.sun.tools.javadoc.ClassDocImpl#findField */
 553     private VarSymbol findField(ClassSymbol tsym, Name fieldName) {
 554         return searchField(tsym, fieldName, new HashSet&lt;&gt;());
 555     }
 556 
 557     /** @see com.sun.tools.javadoc.ClassDocImpl#searchField */
 558     private VarSymbol searchField(ClassSymbol tsym, Name fieldName, Set&lt;ClassSymbol&gt; searched) {
 559         if (searched.contains(tsym)) {
 560             return null;
 561         }
 562         searched.add(tsym);
 563 
 564         for (Symbol sym : tsym.members().getSymbolsByName(fieldName)) {
 565             if (sym.kind == VAR) {
</pre>
<hr />
<pre>
 898                 case INTERFACE:
 899 //                    System.err.println(&quot;CLASS: &quot; + ((JCClassDecl)tree).sym.getSimpleName());
 900                     env = enter.getClassEnv(((JCClassDecl)tree).sym);
 901                     if (env == null) return null;
 902                     break;
 903                 case METHOD:
 904 //                    System.err.println(&quot;METHOD: &quot; + ((JCMethodDecl)tree).sym.getSimpleName());
 905                     method = (JCMethodDecl)tree;
 906                     env = memberEnter.getMethodEnv(method, env);
 907                     break;
 908                 case VARIABLE:
 909 //                    System.err.println(&quot;FIELD: &quot; + ((JCVariableDecl)tree).sym.getSimpleName());
 910                     field = (JCVariableDecl)tree;
 911                     break;
 912                 case BLOCK: {
 913 //                    System.err.println(&quot;BLOCK: &quot;);
 914                     if (method != null) {
 915                         try {
 916                             Assert.check(method.body == tree);
 917                             method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified"> 918                             env = attribStatToTree(method.body, env, copier.leafCopy);</span>
 919                         } finally {
 920                             method.body = (JCBlock) tree;
 921                         }
 922                     } else {
 923                         JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified"> 924                         env = attribStatToTree(body, env, copier.leafCopy);</span>
 925                     }
 926                     return env;
 927                 }
 928                 default:
 929 //                    System.err.println(&quot;DEFAULT: &quot; + tree.getKind());
 930                     if (field != null &amp;&amp; field.getInitializer() == tree) {
 931                         env = memberEnter.getInitEnv(field, env);
 932                         JCExpression expr = copier.copy((JCExpression)tree, (JCTree) path.getLeaf());
<span class="line-modified"> 933                         env = attribExprToTree(expr, env, copier.leafCopy);</span>
 934                         return env;
 935                     }
 936             }
 937         }
 938         return (field != null) ? memberEnter.getInitEnv(field, env) : env;
 939     }
 940 
<span class="line-modified"> 941     private Env&lt;AttrContext&gt; attribStatToTree(JCTree stat, Env&lt;AttrContext&gt;env, JCTree tree) {</span>
<span class="line-modified"> 942         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</span>
<span class="line-modified"> 943         try {</span>
<span class="line-modified"> 944             return attr.attribStatToTree(stat, env, tree);</span>
<span class="line-modified"> 945         } finally {</span>
<span class="line-modified"> 946             log.useSource(prev);</span>






































 947         }
 948     }
 949 
<span class="line-modified"> 950     private Env&lt;AttrContext&gt; attribExprToTree(JCExpression expr, Env&lt;AttrContext&gt;env, JCTree tree) {</span>
<span class="line-modified"> 951         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);</span>
<span class="line-modified"> 952         try {</span>
<span class="line-modified"> 953             return attr.attribExprToTree(expr, env, tree);</span>
<span class="line-modified"> 954         } finally {</span>
<span class="line-modified"> 955             log.useSource(prev);</span>



























































 956         }


 957     }
 958 
 959     static JavaFileObject asJavaFileObject(FileObject fileObject) {
 960         JavaFileObject jfo = null;
 961 
 962         if (fileObject instanceof JavaFileObject) {
 963             jfo = (JavaFileObject) fileObject;
 964             checkHtmlKind(fileObject, Kind.HTML);
 965             return jfo;
 966         }
 967 
 968         checkHtmlKind(fileObject);
 969         jfo = new HtmlFileObject(fileObject);
 970         return jfo;
 971     }
 972 
 973     private static void checkHtmlKind(FileObject fileObject) {
 974         checkHtmlKind(fileObject, BaseFileManager.getKind(fileObject.getName()));
 975     }
 976 
</pre>
<hr />
<pre>
1048     @Override @DefinedBy(Api.COMPILER_TREE)
1049     public DocTreePath getDocTreePath(FileObject fileObject, PackageElement packageElement) {
1050         JavaFileObject jfo = asJavaFileObject(fileObject);
1051         DocCommentTree docCommentTree = getDocCommentTree(jfo);
1052         if (docCommentTree == null)
1053             return null;
1054         TreePath treePath = makeTreePath((PackageSymbol)packageElement, jfo, docCommentTree);
1055         return new DocTreePath(treePath, docCommentTree);
1056     }
1057 
1058     @Override @DefinedBy(Api.COMPILER_TREE)
1059     public void setBreakIterator(BreakIterator breakiterator) {
1060         this.breakIterator = breakiterator;
1061     }
1062 
1063     /**
1064      * Makes a copy of a tree, noting the value resulting from copying a particular leaf.
1065      **/
1066     protected static class Copier extends TreeCopier&lt;JCTree&gt; {
1067         JCTree leafCopy = null;

1068 
1069         protected Copier(TreeMaker M) {
1070             super(M);
1071         }
1072 
1073         @Override
1074         public &lt;T extends JCTree&gt; T copy(T t, JCTree leaf) {
1075             T t2 = super.copy(t, leaf);
1076             if (t == leaf)
1077                 leafCopy = t2;
1078             return t2;
1079         }








1080     }
1081 
1082     protected Copier createCopier(TreeMaker maker) {
1083         return new Copier(maker);
1084     }
1085 
1086     /**
1087      * Returns the original type from the ErrorType object.
1088      * @param errorType The errorType for which we want to get the original type.
1089      * @return TypeMirror corresponding to the original type, replaced by the ErrorType.
1090      *         noType (type.tag == NONE) is returned if there is no original type.
1091      */
1092     @Override @DefinedBy(Api.COMPILER_TREE)
1093     public TypeMirror getOriginalType(javax.lang.model.type.ErrorType errorType) {
1094         if (errorType instanceof com.sun.tools.javac.code.Type.ErrorType) {
1095             return ((com.sun.tools.javac.code.Type.ErrorType)errorType).getOriginalType();
1096         }
1097         if (errorType instanceof com.sun.tools.javac.code.Type.ClassType &amp;&amp;
1098             errorType.getKind() == TypeKind.ERROR) {
1099             ClassType ct = (ClassType) errorType;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.api;
  27 
  28 import java.io.FileNotFoundException;
  29 import java.io.IOException;
  30 import java.text.BreakIterator;
<span class="line-modified">  31 import java.util.HashMap;</span>
  32 import java.util.HashSet;
  33 import java.util.Map;
<span class="line-added">  34 import java.util.Map.Entry;</span>
  35 import java.util.Set;
  36 import java.util.WeakHashMap;


  37 
  38 import javax.annotation.processing.ProcessingEnvironment;
  39 import javax.lang.model.element.AnnotationMirror;
  40 import javax.lang.model.element.AnnotationValue;
  41 import javax.lang.model.element.Element;
  42 import javax.lang.model.element.ElementKind;
  43 import javax.lang.model.element.ExecutableElement;
  44 import javax.lang.model.element.Modifier;
  45 import javax.lang.model.element.NestingKind;
  46 import javax.lang.model.element.PackageElement;
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.type.DeclaredType;
  49 import javax.lang.model.type.TypeKind;
  50 import javax.lang.model.type.TypeMirror;
  51 import javax.tools.Diagnostic;
  52 import javax.tools.FileObject;
  53 import javax.tools.ForwardingFileObject;
  54 import javax.tools.JavaCompiler;
  55 import javax.tools.JavaFileManager;
  56 import javax.tools.JavaFileObject;
  57 import javax.tools.JavaFileObject.Kind;
  58 import javax.tools.StandardLocation;
  59 
  60 import com.sun.source.doctree.DocCommentTree;
  61 import com.sun.source.doctree.DocTree;


  62 import com.sun.source.tree.CatchTree;
<span class="line-added">  63 import com.sun.source.tree.ClassTree;</span>
  64 import com.sun.source.tree.CompilationUnitTree;
  65 import com.sun.source.tree.Scope;
  66 import com.sun.source.tree.Tree;
  67 import com.sun.source.util.DocSourcePositions;
  68 import com.sun.source.util.DocTreePath;
  69 import com.sun.source.util.DocTreeScanner;
  70 import com.sun.source.util.DocTrees;
  71 import com.sun.source.util.JavacTask;

  72 import com.sun.source.util.TreePath;
  73 import com.sun.tools.javac.code.Flags;
  74 import com.sun.tools.javac.code.Scope.NamedImportScope;
  75 import com.sun.tools.javac.code.Scope.StarImportScope;
  76 import com.sun.tools.javac.code.Scope.WriteableScope;

  77 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  78 import com.sun.tools.javac.code.Symbol.MethodSymbol;
  79 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  80 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  81 import com.sun.tools.javac.code.Symbol.TypeSymbol;
  82 import com.sun.tools.javac.code.Symbol.VarSymbol;
  83 import com.sun.tools.javac.code.Symtab;
  84 import com.sun.tools.javac.code.Type;
  85 import com.sun.tools.javac.code.Type.ArrayType;
  86 import com.sun.tools.javac.code.Type.ClassType;
  87 import com.sun.tools.javac.code.Type.ErrorType;
  88 import com.sun.tools.javac.code.Type.UnionClassType;
  89 import com.sun.tools.javac.code.Types;
  90 import com.sun.tools.javac.code.Types.TypeRelation;
  91 import com.sun.tools.javac.comp.Attr;
  92 import com.sun.tools.javac.comp.AttrContext;
<span class="line-added">  93 import com.sun.tools.javac.comp.Check;</span>
  94 import com.sun.tools.javac.comp.Enter;
  95 import com.sun.tools.javac.comp.Env;
  96 import com.sun.tools.javac.comp.MemberEnter;
  97 import com.sun.tools.javac.comp.Modules;
  98 import com.sun.tools.javac.comp.Resolve;
<span class="line-added">  99 import com.sun.tools.javac.code.Symbol;</span>
 100 import com.sun.tools.javac.file.BaseFileManager;
 101 import com.sun.tools.javac.model.JavacElements;
 102 import com.sun.tools.javac.parser.DocCommentParser;
 103 import com.sun.tools.javac.parser.ParserFactory;
 104 import com.sun.tools.javac.parser.Tokens.Comment;
 105 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
 106 import com.sun.tools.javac.processing.JavacProcessingEnvironment;
 107 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 108 import com.sun.tools.javac.resources.CompilerProperties.Notes;
 109 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 110 import com.sun.tools.javac.tree.DCTree;
 111 import com.sun.tools.javac.tree.DCTree.DCBlockTag;
<span class="line-added"> 112 import com.sun.tools.javac.tree.DCTree.DCComment;</span>
 113 import com.sun.tools.javac.tree.DCTree.DCDocComment;
 114 import com.sun.tools.javac.tree.DCTree.DCEndPosTree;
<span class="line-added"> 115 import com.sun.tools.javac.tree.DCTree.DCEntity;</span>
 116 import com.sun.tools.javac.tree.DCTree.DCErroneous;
 117 import com.sun.tools.javac.tree.DCTree.DCIdentifier;
 118 import com.sun.tools.javac.tree.DCTree.DCParam;
 119 import com.sun.tools.javac.tree.DCTree.DCReference;
 120 import com.sun.tools.javac.tree.DCTree.DCText;
 121 import com.sun.tools.javac.tree.DocCommentTable;
 122 import com.sun.tools.javac.tree.DocTreeMaker;
 123 import com.sun.tools.javac.tree.EndPosTable;
 124 import com.sun.tools.javac.tree.JCTree;
 125 import com.sun.tools.javac.tree.JCTree.JCBlock;
 126 import com.sun.tools.javac.tree.JCTree.JCCatch;
 127 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 128 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
 129 import com.sun.tools.javac.tree.JCTree.JCExpression;
 130 import com.sun.tools.javac.tree.JCTree.JCIdent;
 131 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 132 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 133 import com.sun.tools.javac.tree.TreeCopier;
 134 import com.sun.tools.javac.tree.TreeInfo;
 135 import com.sun.tools.javac.tree.TreeMaker;
<span class="line-added"> 136 import com.sun.tools.javac.tree.TreeScanner;</span>
 137 import com.sun.tools.javac.util.Abort;
 138 import com.sun.tools.javac.util.Assert;
 139 import com.sun.tools.javac.util.Context;
 140 import com.sun.tools.javac.util.DefinedBy;
 141 import com.sun.tools.javac.util.DefinedBy.Api;
 142 import com.sun.tools.javac.util.DiagnosticSource;
 143 import com.sun.tools.javac.util.JCDiagnostic;
 144 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
 145 import com.sun.tools.javac.util.List;
 146 import com.sun.tools.javac.util.ListBuffer;
 147 import com.sun.tools.javac.util.Log;
 148 import com.sun.tools.javac.util.Name;
 149 import com.sun.tools.javac.util.Names;
 150 import com.sun.tools.javac.util.Pair;
 151 import com.sun.tools.javac.util.Position;
 152 
 153 import static com.sun.tools.javac.code.Kinds.Kind.*;
 154 import static com.sun.tools.javac.code.TypeTag.*;
 155 
 156 /**
 157  * Provides an implementation of Trees.
 158  *
 159  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 160  * If you write code that depends on this, you do so at your own
 161  * risk.  This code and its internal interfaces are subject to change
 162  * or deletion without notice.&lt;/b&gt;&lt;/p&gt;
 163  *
 164  * @author Peter von der Ah&amp;eacute;
 165  */
 166 public class JavacTrees extends DocTrees {
 167 
 168     // in a world of a single context per compilation, these would all be final
 169     private Modules modules;
 170     private Resolve resolve;
 171     private Enter enter;
 172     private Log log;
 173     private MemberEnter memberEnter;
 174     private Attr attr;
<span class="line-added"> 175     private Check chk;</span>
 176     private TreeMaker treeMaker;
 177     private JavacElements elements;
 178     private JavacTaskImpl javacTaskImpl;
 179     private Names names;
 180     private Types types;
 181     private DocTreeMaker docTreeMaker;
 182     private BreakIterator breakIterator;
 183     private JavaFileManager fileManager;
 184     private ParserFactory parser;
 185     private Symtab syms;
 186 
 187     private final Map&lt;Type, Type&gt; extraType2OriginalMap = new WeakHashMap&lt;&gt;();
 188 
 189     // called reflectively from Trees.instance(CompilationTask task)
 190     public static JavacTrees instance(JavaCompiler.CompilationTask task) {
 191         if (!(task instanceof BasicJavacTask))
 192             throw new IllegalArgumentException();
 193         return instance(((BasicJavacTask)task).getContext());
 194     }
 195 
</pre>
<hr />
<pre>
 203     public static JavacTrees instance(Context context) {
 204         JavacTrees instance = context.get(JavacTrees.class);
 205         if (instance == null)
 206             instance = new JavacTrees(context);
 207         return instance;
 208     }
 209 
 210     protected JavacTrees(Context context) {
 211         this.breakIterator = null;
 212         context.put(JavacTrees.class, this);
 213         init(context);
 214     }
 215 
 216     public void updateContext(Context context) {
 217         init(context);
 218     }
 219 
 220     private void init(Context context) {
 221         modules = Modules.instance(context);
 222         attr = Attr.instance(context);
<span class="line-added"> 223         chk = Check.instance(context);</span>
 224         enter = Enter.instance(context);
 225         elements = JavacElements.instance(context);
 226         log = Log.instance(context);
 227         resolve = Resolve.instance(context);
 228         treeMaker = TreeMaker.instance(context);
 229         memberEnter = MemberEnter.instance(context);
 230         names = Names.instance(context);
 231         types = Types.instance(context);
 232         docTreeMaker = DocTreeMaker.instance(context);
 233         parser = ParserFactory.instance(context);
 234         syms = Symtab.instance(context);
 235         fileManager = context.get(JavaFileManager.class);
 236         JavacTask t = context.get(JavacTask.class);
 237         if (t instanceof JavacTaskImpl)
 238             javacTaskImpl = (JavacTaskImpl) t;
 239     }
 240 
 241     @Override @DefinedBy(Api.COMPILER_TREE)
 242     public BreakIterator getBreakIterator() {
 243         return breakIterator;
</pre>
<hr />
<pre>
 287                             return dcComment.comment.getSourcePos(ident.pos + (ident.name != names.error ? ident.name.length() : 0));
 288                         case PARAM:
 289                             DCParam param = (DCParam) tree;
 290 
 291                             if (param.isTypeParameter &amp;&amp; param.getDescription().isEmpty()) {
 292                                 correction = 1;
 293                             }
 294                         case AUTHOR: case DEPRECATED: case RETURN: case SEE:
 295                         case SERIAL: case SERIAL_DATA: case SERIAL_FIELD: case SINCE:
 296                         case THROWS: case UNKNOWN_BLOCK_TAG: case VERSION: {
 297                             DocTree last = getLastChild(tree);
 298 
 299                             if (last != null) {
 300                                 return getEndPosition(file, comment, last) + correction;
 301                             }
 302 
 303                             DCBlockTag block = (DCBlockTag) tree;
 304 
 305                             return dcComment.comment.getSourcePos(block.pos + block.getTagName().length() + 1);
 306                         }
<span class="line-added"> 307                         case ENTITY: {</span>
<span class="line-added"> 308                             DCEntity endEl = (DCEntity) tree;</span>
<span class="line-added"> 309                             return dcComment.comment.getSourcePos(endEl.pos + (endEl.name != names.error ? endEl.name.length() : 0) + 2);</span>
<span class="line-added"> 310                         }</span>
<span class="line-added"> 311                         case COMMENT: {</span>
<span class="line-added"> 312                             DCComment endEl = (DCComment) tree;</span>
<span class="line-added"> 313                             return dcComment.comment.getSourcePos(endEl.pos + endEl.body.length());</span>
<span class="line-added"> 314                         }</span>
 315                         default:
 316                             DocTree last = getLastChild(tree);
 317 
 318                             if (last != null) {
 319                                 return getEndPosition(file, comment, last);
 320                             }
 321                             break;
 322                     }
 323 
 324                     return Position.NOPOS;
 325                 }
 326             };
 327     }
 328 
 329     @Override @DefinedBy(Api.COMPILER_TREE)
 330     public DocTreeMaker getDocTreeFactory() {
 331         return docTreeMaker;
 332     }
 333 
 334     private DocTree getLastChild(DocTree tree) {
</pre>
<hr />
<pre>
 403         if (sym == null) {
 404             for (TreePath p = path; p != null; p = p.getParentPath()) {
 405                 JCTree t = (JCTree) p.getLeaf();
 406                 if (t.hasTag(JCTree.Tag.CLASSDEF)) {
 407                     JCClassDecl ct = (JCClassDecl) t;
 408                     if (ct.sym != null) {
 409                         if ((ct.sym.flags_field &amp; Flags.UNATTRIBUTED) != 0) {
 410                             attr.attribClass(ct.pos(), ct.sym);
 411                             sym = TreeInfo.symbolFor(tree);
 412                         }
 413                         break;
 414                     }
 415                 }
 416             }
 417         }
 418         return sym;
 419     }
 420 
 421     @Override @DefinedBy(Api.COMPILER_TREE)
 422     public Element getElement(DocTreePath path) {
<span class="line-modified"> 423         DocTree tree = path.getLeaf();</span>
<span class="line-modified"> 424         if (tree instanceof DCReference)</span>
<span class="line-modified"> 425             return attributeDocReference(path.getTreePath(), ((DCReference) tree));</span>
<span class="line-modified"> 426         if (tree instanceof DCIdentifier) {</span>
 427             if (path.getParentPath().getLeaf() instanceof DCParam) {
 428                 return attributeParamIdentifier(path.getTreePath(), (DCParam) path.getParentPath().getLeaf());
 429             }
 430         }
 431         return null;
 432     }
 433 
 434     @Override @DefinedBy(Api.COMPILER_TREE)
 435     public java.util.List&lt;DocTree&gt; getFirstSentence(java.util.List&lt;? extends DocTree&gt; list) {
 436         return docTreeMaker.getFirstSentence(list);
 437     }
 438 
 439     private Symbol attributeDocReference(TreePath path, DCReference ref) {
 440         Env&lt;AttrContext&gt; env = getAttrContext(path);
 441         if (env == null) return null;
 442 
 443         Log.DeferredDiagnosticHandler deferredDiagnosticHandler =
 444                 new Log.DeferredDiagnosticHandler(log);
 445         try {
 446             final TypeSymbol tsym;
</pre>
<hr />
<pre>
 519                 // explicit (possibly empty) arg list given, so cannot be a field
 520                 return msym;
 521             }
 522 
 523             VarSymbol vsym = (ref.paramTypes != null) ? null : findField(sym, memberName);
 524             // prefer a field over a method with no parameters
 525             if (vsym != null &amp;&amp;
 526                     (msym == null ||
 527                         types.isSubtypeUnchecked(vsym.enclClass().asType(), msym.enclClass().asType()))) {
 528                 return vsym;
 529             } else {
 530                 return msym;
 531             }
 532         } catch (Abort e) { // may be thrown by Check.completionError in case of bad class file
 533             return null;
 534         } finally {
 535             log.popDiagnosticHandler(deferredDiagnosticHandler);
 536         }
 537     }
 538 
<span class="line-modified"> 539     private Symbol attributeParamIdentifier(TreePath path, DCParam paramTag) {</span>
 540         Symbol javadocSymbol = getElement(path);
 541         if (javadocSymbol == null)
 542             return null;
 543         ElementKind kind = javadocSymbol.getKind();
 544         List&lt;? extends Symbol&gt; params = List.nil();
 545         if (kind == ElementKind.METHOD || kind == ElementKind.CONSTRUCTOR) {
 546             MethodSymbol ee = (MethodSymbol) javadocSymbol;
<span class="line-modified"> 547             params = paramTag.isTypeParameter()</span>
 548                     ? ee.getTypeParameters()
 549                     : ee.getParameters();
 550         } else if (kind.isClass() || kind.isInterface()) {
 551             ClassSymbol te = (ClassSymbol) javadocSymbol;
<span class="line-modified"> 552             params = paramTag.isTypeParameter()</span>
<span class="line-added"> 553                     ? te.getTypeParameters()</span>
<span class="line-added"> 554                     : te.getRecordComponents();</span>
 555         }
 556 
 557         for (Symbol param : params) {
<span class="line-modified"> 558             if (param.getSimpleName() == paramTag.getName().getName()) {</span>
 559                 return param;
 560             }
 561         }
 562         return null;
 563     }
 564 
 565     /** @see com.sun.tools.javadoc.ClassDocImpl#findField */
 566     private VarSymbol findField(ClassSymbol tsym, Name fieldName) {
 567         return searchField(tsym, fieldName, new HashSet&lt;&gt;());
 568     }
 569 
 570     /** @see com.sun.tools.javadoc.ClassDocImpl#searchField */
 571     private VarSymbol searchField(ClassSymbol tsym, Name fieldName, Set&lt;ClassSymbol&gt; searched) {
 572         if (searched.contains(tsym)) {
 573             return null;
 574         }
 575         searched.add(tsym);
 576 
 577         for (Symbol sym : tsym.members().getSymbolsByName(fieldName)) {
 578             if (sym.kind == VAR) {
</pre>
<hr />
<pre>
 911                 case INTERFACE:
 912 //                    System.err.println(&quot;CLASS: &quot; + ((JCClassDecl)tree).sym.getSimpleName());
 913                     env = enter.getClassEnv(((JCClassDecl)tree).sym);
 914                     if (env == null) return null;
 915                     break;
 916                 case METHOD:
 917 //                    System.err.println(&quot;METHOD: &quot; + ((JCMethodDecl)tree).sym.getSimpleName());
 918                     method = (JCMethodDecl)tree;
 919                     env = memberEnter.getMethodEnv(method, env);
 920                     break;
 921                 case VARIABLE:
 922 //                    System.err.println(&quot;FIELD: &quot; + ((JCVariableDecl)tree).sym.getSimpleName());
 923                     field = (JCVariableDecl)tree;
 924                     break;
 925                 case BLOCK: {
 926 //                    System.err.println(&quot;BLOCK: &quot;);
 927                     if (method != null) {
 928                         try {
 929                             Assert.check(method.body == tree);
 930                             method.body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified"> 931                             env = attribStatToTree(method.body, env, copier.leafCopy, copier.copiedClasses);</span>
 932                         } finally {
 933                             method.body = (JCBlock) tree;
 934                         }
 935                     } else {
 936                         JCBlock body = copier.copy((JCBlock)tree, (JCTree) path.getLeaf());
<span class="line-modified"> 937                         env = attribStatToTree(body, env, copier.leafCopy, copier.copiedClasses);</span>
 938                     }
 939                     return env;
 940                 }
 941                 default:
 942 //                    System.err.println(&quot;DEFAULT: &quot; + tree.getKind());
 943                     if (field != null &amp;&amp; field.getInitializer() == tree) {
 944                         env = memberEnter.getInitEnv(field, env);
 945                         JCExpression expr = copier.copy((JCExpression)tree, (JCTree) path.getLeaf());
<span class="line-modified"> 946                         env = attribExprToTree(expr, env, copier.leafCopy, copier.copiedClasses);</span>
 947                         return env;
 948                     }
 949             }
 950         }
 951         return (field != null) ? memberEnter.getInitEnv(field, env) : env;
 952     }
 953 
<span class="line-modified"> 954     private Env&lt;AttrContext&gt; attribStatToTree(JCTree stat, Env&lt;AttrContext&gt;env,</span>
<span class="line-modified"> 955                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {</span>
<span class="line-modified"> 956         Env&lt;AttrContext&gt; result = attr.attribStatToTree(stat, env, tree);</span>
<span class="line-modified"> 957 </span>
<span class="line-modified"> 958         fixLocalClassNames(copiedClasses, env);</span>
<span class="line-modified"> 959 </span>
<span class="line-added"> 960         return result;</span>
<span class="line-added"> 961     }</span>
<span class="line-added"> 962 </span>
<span class="line-added"> 963     private Env&lt;AttrContext&gt; attribExprToTree(JCExpression expr, Env&lt;AttrContext&gt;env,</span>
<span class="line-added"> 964                                               JCTree tree, Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses) {</span>
<span class="line-added"> 965         Env&lt;AttrContext&gt; result = attr.attribExprToTree(expr, env, tree);</span>
<span class="line-added"> 966 </span>
<span class="line-added"> 967         fixLocalClassNames(copiedClasses, env);</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969         return result;</span>
<span class="line-added"> 970     }</span>
<span class="line-added"> 971 </span>
<span class="line-added"> 972     /* Change the flatnames of the local and anonymous classes in the Scope to</span>
<span class="line-added"> 973      * the names they would have if the whole file was attributed normally.</span>
<span class="line-added"> 974      */</span>
<span class="line-added"> 975     private void fixLocalClassNames(Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses,</span>
<span class="line-added"> 976                                     Env&lt;AttrContext&gt; lastEnv) {</span>
<span class="line-added"> 977         Map&lt;JCClassDecl, Name&gt; flatnameForClass = null;</span>
<span class="line-added"> 978 </span>
<span class="line-added"> 979         for (Entry&lt;JCClassDecl, JCClassDecl&gt; e : copiedClasses.entrySet()) {</span>
<span class="line-added"> 980             if (e.getKey().sym != null) {</span>
<span class="line-added"> 981                 Name origName;</span>
<span class="line-added"> 982                 if (e.getValue().sym != null) {</span>
<span class="line-added"> 983                     //if the source tree was already attributed, use the flatname</span>
<span class="line-added"> 984                     //from the source tree&#39;s Symbol:</span>
<span class="line-added"> 985                     origName = e.getValue().sym.flatname;</span>
<span class="line-added"> 986                 } else {</span>
<span class="line-added"> 987                     //otherwise, compute the flatnames (for source trees) as</span>
<span class="line-added"> 988                     //if the full source code would be attributed:</span>
<span class="line-added"> 989                     if (flatnameForClass == null) {</span>
<span class="line-added"> 990                         flatnameForClass = prepareFlatnameForClass(lastEnv);</span>
<span class="line-added"> 991                     }</span>
<span class="line-added"> 992                     origName = flatnameForClass.get(e.getValue());</span>
<span class="line-added"> 993                 }</span>
<span class="line-added"> 994                 if (origName != null) {</span>
<span class="line-added"> 995                     e.getKey().sym.flatname = origName;</span>
<span class="line-added"> 996                 }</span>
<span class="line-added"> 997             }</span>
 998         }
 999     }
1000 
<span class="line-modified">1001     /* This method computes and assigns flatnames to trees, as if they would be</span>
<span class="line-modified">1002      * normally assigned during attribution of the full source code.</span>
<span class="line-modified">1003      */</span>
<span class="line-modified">1004     private Map&lt;JCTree.JCClassDecl, Name&gt; prepareFlatnameForClass(Env&lt;AttrContext&gt; env) {</span>
<span class="line-modified">1005         Map&lt;JCClassDecl, Name&gt; flatNameForClass = new HashMap&lt;&gt;();</span>
<span class="line-modified">1006         Symbol enclClass = env.enclClass.sym;</span>
<span class="line-added">1007 </span>
<span class="line-added">1008         if (enclClass != null &amp;&amp; (enclClass.flags_field &amp; Flags.UNATTRIBUTED) != 0) {</span>
<span class="line-added">1009             ListBuffer&lt;ClassSymbol&gt; toClear = new ListBuffer&lt;&gt;();</span>
<span class="line-added">1010             new TreeScanner() {</span>
<span class="line-added">1011                 Symbol owner;</span>
<span class="line-added">1012                 boolean localContext;</span>
<span class="line-added">1013                 @Override</span>
<span class="line-added">1014                 public void visitClassDef(JCClassDecl tree) {</span>
<span class="line-added">1015                     //compute the name (and ClassSymbol) which would be used</span>
<span class="line-added">1016                     //for this class for full attribution</span>
<span class="line-added">1017                     Symbol prevOwner = owner;</span>
<span class="line-added">1018                     try {</span>
<span class="line-added">1019                         ClassSymbol c;</span>
<span class="line-added">1020                         if (tree.sym != null) {</span>
<span class="line-added">1021                             //already entered:</span>
<span class="line-added">1022                             c = tree.sym;</span>
<span class="line-added">1023                         } else {</span>
<span class="line-added">1024                             c = syms.defineClass(tree.name, owner);</span>
<span class="line-added">1025                             if (owner.kind != TYP) {</span>
<span class="line-added">1026                                 //for local classes, assign the flatname</span>
<span class="line-added">1027                                 c.flatname = chk.localClassName(c);</span>
<span class="line-added">1028                                 chk.putCompiled(c);</span>
<span class="line-added">1029                                 toClear.add(c);</span>
<span class="line-added">1030                             }</span>
<span class="line-added">1031                             flatNameForClass.put(tree, c.flatname);</span>
<span class="line-added">1032                         }</span>
<span class="line-added">1033                         owner = c;</span>
<span class="line-added">1034                         super.visitClassDef(tree);</span>
<span class="line-added">1035                     } finally {</span>
<span class="line-added">1036                         owner = prevOwner;</span>
<span class="line-added">1037                     }</span>
<span class="line-added">1038                 }</span>
<span class="line-added">1039 </span>
<span class="line-added">1040                 @Override</span>
<span class="line-added">1041                 public void visitBlock(JCBlock tree) {</span>
<span class="line-added">1042                     Symbol prevOwner = owner;</span>
<span class="line-added">1043                     try {</span>
<span class="line-added">1044                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);</span>
<span class="line-added">1045                         super.visitBlock(tree);</span>
<span class="line-added">1046                     } finally {</span>
<span class="line-added">1047                         owner = prevOwner;</span>
<span class="line-added">1048                     }</span>
<span class="line-added">1049                 }</span>
<span class="line-added">1050                 @Override</span>
<span class="line-added">1051                 public void visitVarDef(JCVariableDecl tree) {</span>
<span class="line-added">1052                     Symbol prevOwner = owner;</span>
<span class="line-added">1053                     try {</span>
<span class="line-added">1054                         owner = new MethodSymbol(0, names.empty, Type.noType, owner);</span>
<span class="line-added">1055                         super.visitVarDef(tree);</span>
<span class="line-added">1056                     } finally {</span>
<span class="line-added">1057                         owner = prevOwner;</span>
<span class="line-added">1058                     }</span>
<span class="line-added">1059                 }</span>
<span class="line-added">1060             }.scan(env.enclClass);</span>
<span class="line-added">1061             //revert changes done by the visitor:</span>
<span class="line-added">1062             toClear.stream().forEach(c -&gt; {</span>
<span class="line-added">1063                 chk.clearLocalClassNameIndexes(c);</span>
<span class="line-added">1064                 chk.removeCompiled(c);</span>
<span class="line-added">1065             });</span>
1066         }
<span class="line-added">1067 </span>
<span class="line-added">1068         return flatNameForClass;</span>
1069     }
1070 
1071     static JavaFileObject asJavaFileObject(FileObject fileObject) {
1072         JavaFileObject jfo = null;
1073 
1074         if (fileObject instanceof JavaFileObject) {
1075             jfo = (JavaFileObject) fileObject;
1076             checkHtmlKind(fileObject, Kind.HTML);
1077             return jfo;
1078         }
1079 
1080         checkHtmlKind(fileObject);
1081         jfo = new HtmlFileObject(fileObject);
1082         return jfo;
1083     }
1084 
1085     private static void checkHtmlKind(FileObject fileObject) {
1086         checkHtmlKind(fileObject, BaseFileManager.getKind(fileObject.getName()));
1087     }
1088 
</pre>
<hr />
<pre>
1160     @Override @DefinedBy(Api.COMPILER_TREE)
1161     public DocTreePath getDocTreePath(FileObject fileObject, PackageElement packageElement) {
1162         JavaFileObject jfo = asJavaFileObject(fileObject);
1163         DocCommentTree docCommentTree = getDocCommentTree(jfo);
1164         if (docCommentTree == null)
1165             return null;
1166         TreePath treePath = makeTreePath((PackageSymbol)packageElement, jfo, docCommentTree);
1167         return new DocTreePath(treePath, docCommentTree);
1168     }
1169 
1170     @Override @DefinedBy(Api.COMPILER_TREE)
1171     public void setBreakIterator(BreakIterator breakiterator) {
1172         this.breakIterator = breakiterator;
1173     }
1174 
1175     /**
1176      * Makes a copy of a tree, noting the value resulting from copying a particular leaf.
1177      **/
1178     protected static class Copier extends TreeCopier&lt;JCTree&gt; {
1179         JCTree leafCopy = null;
<span class="line-added">1180         private Map&lt;JCClassDecl, JCClassDecl&gt; copiedClasses = new HashMap&lt;&gt;();</span>
1181 
1182         protected Copier(TreeMaker M) {
1183             super(M);
1184         }
1185 
1186         @Override
1187         public &lt;T extends JCTree&gt; T copy(T t, JCTree leaf) {
1188             T t2 = super.copy(t, leaf);
1189             if (t == leaf)
1190                 leafCopy = t2;
1191             return t2;
1192         }
<span class="line-added">1193 </span>
<span class="line-added">1194         @Override</span>
<span class="line-added">1195         public JCTree visitClass(ClassTree node, JCTree p) {</span>
<span class="line-added">1196             JCTree nue = super.visitClass(node, p);</span>
<span class="line-added">1197             copiedClasses.put((JCClassDecl) nue, (JCClassDecl) node);</span>
<span class="line-added">1198             return nue;</span>
<span class="line-added">1199         }</span>
<span class="line-added">1200 </span>
1201     }
1202 
1203     protected Copier createCopier(TreeMaker maker) {
1204         return new Copier(maker);
1205     }
1206 
1207     /**
1208      * Returns the original type from the ErrorType object.
1209      * @param errorType The errorType for which we want to get the original type.
1210      * @return TypeMirror corresponding to the original type, replaced by the ErrorType.
1211      *         noType (type.tag == NONE) is returned if there is no original type.
1212      */
1213     @Override @DefinedBy(Api.COMPILER_TREE)
1214     public TypeMirror getOriginalType(javax.lang.model.type.ErrorType errorType) {
1215         if (errorType instanceof com.sun.tools.javac.code.Type.ErrorType) {
1216             return ((com.sun.tools.javac.code.Type.ErrorType)errorType).getOriginalType();
1217         }
1218         if (errorType instanceof com.sun.tools.javac.code.Type.ClassType &amp;&amp;
1219             errorType.getKind() == TypeKind.ERROR) {
1220             ClassType ct = (ClassType) errorType;
</pre>
</td>
</tr>
</table>
<center><a href="JavacTaskPool.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../code/Attribute.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
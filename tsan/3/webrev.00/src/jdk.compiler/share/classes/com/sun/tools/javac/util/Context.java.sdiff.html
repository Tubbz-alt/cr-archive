<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/util/Context.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ClientCodeException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Convert.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/util/Context.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42  * the component itself, and (2) a convention for a pattern of usage
 43  * in which each base component registers itself by calling an
 44  * instance method that is overridden in extended components.  A base
 45  * phase supporting extension would look something like this:
 46  *
 47  * &lt;pre&gt;{@code
 48  * public class Phase {
 49  *     protected static final Context.Key&lt;Phase&gt; phaseKey =
 50  *         new Context.Key&lt;Phase&gt;();
 51  *
 52  *     public static Phase instance(Context context) {
 53  *         Phase instance = context.get(phaseKey);
 54  *         if (instance == null)
 55  *             // the phase has not been overridden
 56  *             instance = new Phase(context);
 57  *         return instance;
 58  *     }
 59  *
 60  *     protected Phase(Context context) {
 61  *         context.put(phaseKey, this);
<span class="line-modified"> 62  *         // other intitialization follows...</span>
 63  *     }
 64  * }
 65  * }&lt;/pre&gt;
 66  *
 67  * &lt;p&gt;In the compiler, we simply use Phase.instance(context) to get
 68  * the reference to the phase.  But in extensions of the compiler, we
 69  * must register extensions of the phases to replace the base phase,
 70  * and this must be done before any reference to the phase is accessed
 71  * using Phase.instance().  An extended phase might be declared thus:
 72  *
 73  * &lt;pre&gt;{@code
 74  * public class NewPhase extends Phase {
 75  *     protected NewPhase(Context context) {
 76  *         super(context);
 77  *     }
 78  *     public static void preRegister(final Context context) {
 79  *         context.put(phaseKey, new Context.Factory&lt;Phase&gt;() {
 80  *             public Phase make() {
 81  *                 return new NewPhase(context);
 82  *             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 42  * the component itself, and (2) a convention for a pattern of usage
 43  * in which each base component registers itself by calling an
 44  * instance method that is overridden in extended components.  A base
 45  * phase supporting extension would look something like this:
 46  *
 47  * &lt;pre&gt;{@code
 48  * public class Phase {
 49  *     protected static final Context.Key&lt;Phase&gt; phaseKey =
 50  *         new Context.Key&lt;Phase&gt;();
 51  *
 52  *     public static Phase instance(Context context) {
 53  *         Phase instance = context.get(phaseKey);
 54  *         if (instance == null)
 55  *             // the phase has not been overridden
 56  *             instance = new Phase(context);
 57  *         return instance;
 58  *     }
 59  *
 60  *     protected Phase(Context context) {
 61  *         context.put(phaseKey, this);
<span class="line-modified"> 62  *         // other initialization follows...</span>
 63  *     }
 64  * }
 65  * }&lt;/pre&gt;
 66  *
 67  * &lt;p&gt;In the compiler, we simply use Phase.instance(context) to get
 68  * the reference to the phase.  But in extensions of the compiler, we
 69  * must register extensions of the phases to replace the base phase,
 70  * and this must be done before any reference to the phase is accessed
 71  * using Phase.instance().  An extended phase might be declared thus:
 72  *
 73  * &lt;pre&gt;{@code
 74  * public class NewPhase extends Phase {
 75  *     protected NewPhase(Context context) {
 76  *         super(context);
 77  *     }
 78  *     public static void preRegister(final Context context) {
 79  *         context.put(phaseKey, new Context.Factory&lt;Phase&gt;() {
 80  *             public Phase make() {
 81  *                 return new NewPhase(context);
 82  *             }
</pre>
</td>
</tr>
</table>
<center><a href="ClientCodeException.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Convert.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
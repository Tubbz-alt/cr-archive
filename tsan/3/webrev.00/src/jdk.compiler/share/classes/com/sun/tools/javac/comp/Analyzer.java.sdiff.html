<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Analyzer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Types.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Annotate.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Analyzer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import java.util.ArrayDeque;

 29 import java.util.EnumSet;
 30 import java.util.HashMap;
 31 import java.util.Map;
 32 import java.util.Queue;
<span class="line-modified"> 33 import java.util.function.Predicate;</span>
 34 
 35 import com.sun.source.tree.LambdaExpressionTree;
 36 import com.sun.source.tree.NewClassTree;
 37 import com.sun.tools.javac.code.Flags;
 38 import com.sun.tools.javac.code.Kinds.Kind;
 39 import com.sun.tools.javac.code.Source;
 40 import com.sun.tools.javac.code.Source.Feature;
 41 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 42 import com.sun.tools.javac.code.Type;
 43 import com.sun.tools.javac.code.Types;
 44 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;

 45 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 46 import com.sun.tools.javac.tree.JCTree;
 47 import com.sun.tools.javac.tree.JCTree.JCBlock;
 48 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 49 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 50 import com.sun.tools.javac.tree.JCTree.JCEnhancedForLoop;
 51 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 52 import com.sun.tools.javac.tree.JCTree.JCIf;
 53 import com.sun.tools.javac.tree.JCTree.JCLambda;
 54 import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;
 55 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 56 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 57 import com.sun.tools.javac.tree.JCTree.JCNewClass;
 58 import com.sun.tools.javac.tree.JCTree.JCStatement;
 59 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 60 import com.sun.tools.javac.tree.JCTree.JCTry;
 61 import com.sun.tools.javac.tree.JCTree.JCTypeApply;
 62 import com.sun.tools.javac.tree.JCTree.JCUnary;
 63 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 64 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
</pre>
<hr />
<pre>
429         @Override
430         void process(JCEnhancedForLoop oldTree, JCEnhancedForLoop newTree, boolean hasErrors){
431             processVar(oldTree.var, newTree.var, hasErrors);
432         }
433     }
434 
435     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
436     StatementAnalyzer&lt;JCTree, JCTree&gt;[] analyzers = new StatementAnalyzer[] {
437             new DiamondInitializer(),
438             new LambdaAnalyzer(),
439             new RedundantTypeArgAnalyzer(),
440             new RedundantLocalVarTypeAnalyzer(),
441             new RedundantLocalVarTypeAnalyzerForEach()
442     };
443 
444     /**
445      * Create a copy of Env if needed.
446      */
447     Env&lt;AttrContext&gt; copyEnvIfNeeded(JCTree tree, Env&lt;AttrContext&gt; env) {
448         if (!analyzerModes.isEmpty() &amp;&amp;
<span class="line-modified">449                 !env.info.isSpeculative &amp;&amp;</span>
450                 TreeInfo.isStatement(tree) &amp;&amp;
451                 !tree.hasTag(LABELLED)) {
452             Env&lt;AttrContext&gt; analyzeEnv =
453                     env.dup(env.tree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));
454             analyzeEnv.info.returnResult = analyzeEnv.info.returnResult != null ?
455                     attr.new ResultInfo(analyzeEnv.info.returnResult.pkind,
456                                         analyzeEnv.info.returnResult.pt) : null;
457             return analyzeEnv;
458         } else {
459             return null;
460         }
461     }
462 
463     /**
464      * Analyze an AST node if needed.
465      */
466     void analyzeIfNeeded(JCTree tree, Env&lt;AttrContext&gt; env) {
467         if (env != null) {
468             JCStatement stmt = (JCStatement)tree;
469             analyze(stmt, env);
</pre>
<hr />
<pre>
545         }
546     };
547 
548     DeferredAnalysisHelper deferredAnalysisHelper = queueDeferredHelper;
549 
550     void doAnalysis(RewritingContext rewriting) {
551         DiagnosticSource prevSource = log.currentSource();
552         LocalCacheContext localCacheContext = argumentAttr.withLocalCacheContext();
553         try {
554             log.useSource(rewriting.env.toplevel.getSourceFile());
555 
556             JCStatement treeToAnalyze = (JCStatement)rewriting.originalTree;
557             if (rewriting.env.info.scope.owner.kind == Kind.TYP) {
558                 //add a block to hoist potential dangling variable declarations
559                 treeToAnalyze = make.at(Position.NOPOS)
560                                     .Block(Flags.SYNTHETIC, List.of((JCStatement)rewriting.originalTree));
561             }
562 
563             //TODO: to further refine the analysis, try all rewriting combinations
564             deferredAttr.attribSpeculative(treeToAnalyze, rewriting.env, attr.statInfo, new TreeRewriter(rewriting),
<span class="line-modified">565                     t -&gt; rewriting.diagHandler(), argumentAttr.withLocalCacheContext());</span>
566             rewriting.analyzer.process(rewriting.oldTree, rewriting.replacement, rewriting.erroneous);
567         } catch (Throwable ex) {
<span class="line-modified">568             Assert.error(&quot;Analyzer error when processing: &quot; + rewriting.originalTree);</span>




569         } finally {
570             log.useSource(prevSource.getFile());
571             localCacheContext.leave();
572         }
573     }
574 
575     public void flush(Env&lt;AttrContext&gt; flushEnv) {
576         deferredAnalysisHelper.flush(flushEnv);
577     }
578 
579     /**
580      * Subclass of {@link com.sun.tools.javac.tree.TreeScanner} which visit AST-nodes w/o crossing
581      * statement boundaries.
582      */
583     class StatementScanner extends TreeScanner {
584         /** Tree rewritings (generated by analyzers). */
585         ListBuffer&lt;RewritingContext&gt; rewritings = new ListBuffer&lt;&gt;();
586         JCTree originalTree;
587         Env&lt;AttrContext&gt; env;
588 
</pre>
<hr />
<pre>
610                     }
611                 }
612             }
613             super.scan(tree);
614         }
615 
616         @Override
617         public void visitClassDef(JCClassDecl tree) {
618             //do nothing (prevents seeing same stuff twice)
619         }
620 
621         @Override
622         public void visitMethodDef(JCMethodDecl tree) {
623             //do nothing (prevents seeing same stuff twice)
624         }
625 
626         @Override
627         public void visitBlock(JCBlock tree) {
628             //do nothing (prevents seeing same stuff twice)
629         }





630 
631         @Override
632         public void visitSwitch(JCSwitch tree) {
633             scan(tree.getExpression());
634         }
635 
636         @Override
637         public void visitForLoop(JCForLoop tree) {
638             //skip body and var decl (to prevents same statements to be analyzed twice)
639             scan(tree.getCondition());
640             scan(tree.getUpdate());
641         }
642 
643         @Override
644         public void visitTry(JCTry tree) {
645             //skip resources (to prevents same statements to be analyzed twice)
646             scan(tree.getBlock());
647             scan(tree.getCatches());
648             scan(tree.getFinallyBlock());
649         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import java.util.ArrayDeque;
<span class="line-added"> 29 import java.util.Arrays;</span>
 30 import java.util.EnumSet;
 31 import java.util.HashMap;
 32 import java.util.Map;
 33 import java.util.Queue;
<span class="line-modified"> 34 import java.util.stream.Collectors;</span>
 35 
 36 import com.sun.source.tree.LambdaExpressionTree;
 37 import com.sun.source.tree.NewClassTree;
 38 import com.sun.tools.javac.code.Flags;
 39 import com.sun.tools.javac.code.Kinds.Kind;
 40 import com.sun.tools.javac.code.Source;
 41 import com.sun.tools.javac.code.Source.Feature;
 42 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 43 import com.sun.tools.javac.code.Type;
 44 import com.sun.tools.javac.code.Types;
 45 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
<span class="line-added"> 46 import com.sun.tools.javac.comp.DeferredAttr.AttributionMode;</span>
 47 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
 48 import com.sun.tools.javac.tree.JCTree;
 49 import com.sun.tools.javac.tree.JCTree.JCBlock;
 50 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 51 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 52 import com.sun.tools.javac.tree.JCTree.JCEnhancedForLoop;
 53 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 54 import com.sun.tools.javac.tree.JCTree.JCIf;
 55 import com.sun.tools.javac.tree.JCTree.JCLambda;
 56 import com.sun.tools.javac.tree.JCTree.JCLambda.ParameterKind;
 57 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 58 import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;
 59 import com.sun.tools.javac.tree.JCTree.JCNewClass;
 60 import com.sun.tools.javac.tree.JCTree.JCStatement;
 61 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 62 import com.sun.tools.javac.tree.JCTree.JCTry;
 63 import com.sun.tools.javac.tree.JCTree.JCTypeApply;
 64 import com.sun.tools.javac.tree.JCTree.JCUnary;
 65 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 66 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
</pre>
<hr />
<pre>
431         @Override
432         void process(JCEnhancedForLoop oldTree, JCEnhancedForLoop newTree, boolean hasErrors){
433             processVar(oldTree.var, newTree.var, hasErrors);
434         }
435     }
436 
437     @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
438     StatementAnalyzer&lt;JCTree, JCTree&gt;[] analyzers = new StatementAnalyzer[] {
439             new DiamondInitializer(),
440             new LambdaAnalyzer(),
441             new RedundantTypeArgAnalyzer(),
442             new RedundantLocalVarTypeAnalyzer(),
443             new RedundantLocalVarTypeAnalyzerForEach()
444     };
445 
446     /**
447      * Create a copy of Env if needed.
448      */
449     Env&lt;AttrContext&gt; copyEnvIfNeeded(JCTree tree, Env&lt;AttrContext&gt; env) {
450         if (!analyzerModes.isEmpty() &amp;&amp;
<span class="line-modified">451                 !env.info.attributionMode.isSpeculative &amp;&amp;</span>
452                 TreeInfo.isStatement(tree) &amp;&amp;
453                 !tree.hasTag(LABELLED)) {
454             Env&lt;AttrContext&gt; analyzeEnv =
455                     env.dup(env.tree, env.info.dup(env.info.scope.dupUnshared(env.info.scope.owner)));
456             analyzeEnv.info.returnResult = analyzeEnv.info.returnResult != null ?
457                     attr.new ResultInfo(analyzeEnv.info.returnResult.pkind,
458                                         analyzeEnv.info.returnResult.pt) : null;
459             return analyzeEnv;
460         } else {
461             return null;
462         }
463     }
464 
465     /**
466      * Analyze an AST node if needed.
467      */
468     void analyzeIfNeeded(JCTree tree, Env&lt;AttrContext&gt; env) {
469         if (env != null) {
470             JCStatement stmt = (JCStatement)tree;
471             analyze(stmt, env);
</pre>
<hr />
<pre>
547         }
548     };
549 
550     DeferredAnalysisHelper deferredAnalysisHelper = queueDeferredHelper;
551 
552     void doAnalysis(RewritingContext rewriting) {
553         DiagnosticSource prevSource = log.currentSource();
554         LocalCacheContext localCacheContext = argumentAttr.withLocalCacheContext();
555         try {
556             log.useSource(rewriting.env.toplevel.getSourceFile());
557 
558             JCStatement treeToAnalyze = (JCStatement)rewriting.originalTree;
559             if (rewriting.env.info.scope.owner.kind == Kind.TYP) {
560                 //add a block to hoist potential dangling variable declarations
561                 treeToAnalyze = make.at(Position.NOPOS)
562                                     .Block(Flags.SYNTHETIC, List.of((JCStatement)rewriting.originalTree));
563             }
564 
565             //TODO: to further refine the analysis, try all rewriting combinations
566             deferredAttr.attribSpeculative(treeToAnalyze, rewriting.env, attr.statInfo, new TreeRewriter(rewriting),
<span class="line-modified">567                     () -&gt; rewriting.diagHandler(), AttributionMode.ANALYZER, argumentAttr.withLocalCacheContext());</span>
568             rewriting.analyzer.process(rewriting.oldTree, rewriting.replacement, rewriting.erroneous);
569         } catch (Throwable ex) {
<span class="line-modified">570             Assert.error(&quot;Analyzer error when processing: &quot; +</span>
<span class="line-added">571                          rewriting.originalTree + &quot;:&quot; + ex.toString() + &quot;\n&quot; +</span>
<span class="line-added">572                          Arrays.stream(ex.getStackTrace())</span>
<span class="line-added">573                                .map(se -&gt; se.toString())</span>
<span class="line-added">574                                .collect(Collectors.joining(&quot;\n&quot;)));</span>
575         } finally {
576             log.useSource(prevSource.getFile());
577             localCacheContext.leave();
578         }
579     }
580 
581     public void flush(Env&lt;AttrContext&gt; flushEnv) {
582         deferredAnalysisHelper.flush(flushEnv);
583     }
584 
585     /**
586      * Subclass of {@link com.sun.tools.javac.tree.TreeScanner} which visit AST-nodes w/o crossing
587      * statement boundaries.
588      */
589     class StatementScanner extends TreeScanner {
590         /** Tree rewritings (generated by analyzers). */
591         ListBuffer&lt;RewritingContext&gt; rewritings = new ListBuffer&lt;&gt;();
592         JCTree originalTree;
593         Env&lt;AttrContext&gt; env;
594 
</pre>
<hr />
<pre>
616                     }
617                 }
618             }
619             super.scan(tree);
620         }
621 
622         @Override
623         public void visitClassDef(JCClassDecl tree) {
624             //do nothing (prevents seeing same stuff twice)
625         }
626 
627         @Override
628         public void visitMethodDef(JCMethodDecl tree) {
629             //do nothing (prevents seeing same stuff twice)
630         }
631 
632         @Override
633         public void visitBlock(JCBlock tree) {
634             //do nothing (prevents seeing same stuff twice)
635         }
<span class="line-added">636 </span>
<span class="line-added">637         @Override</span>
<span class="line-added">638         public void visitLambda(JCLambda tree) {</span>
<span class="line-added">639             //do nothing (prevents seeing same stuff in lambda expression twice)</span>
<span class="line-added">640         }</span>
641 
642         @Override
643         public void visitSwitch(JCSwitch tree) {
644             scan(tree.getExpression());
645         }
646 
647         @Override
648         public void visitForLoop(JCForLoop tree) {
649             //skip body and var decl (to prevents same statements to be analyzed twice)
650             scan(tree.getCondition());
651             scan(tree.getUpdate());
652         }
653 
654         @Override
655         public void visitTry(JCTry tree) {
656             //skip resources (to prevents same statements to be analyzed twice)
657             scan(tree.getBlock());
658             scan(tree.getCatches());
659             scan(tree.getFinallyBlock());
660         }
</pre>
</td>
</tr>
</table>
<center><a href="../code/Types.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Annotate.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>